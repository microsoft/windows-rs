#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_UI_Shell_PropertiesSystem\"`*"]
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
#[inline]
pub unsafe fn CreateNamedPropertyStore() -> ::windows::core::Result<super::super::UI::Shell::PropertiesSystem::INamedPropertyStore> {
    ::windows_targets::link ! ( "mf.dll""system" fn CreateNamedPropertyStore ( ppstore : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<super::super::UI::Shell::PropertiesSystem::INamedPropertyStore>();
    CreateNamedPropertyStore(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_UI_Shell_PropertiesSystem\"`*"]
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
#[inline]
pub unsafe fn CreatePropertyStore() -> ::windows::core::Result<super::super::UI::Shell::PropertiesSystem::IPropertyStore> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn CreatePropertyStore ( ppstore : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<super::super::UI::Shell::PropertiesSystem::IPropertyStore>();
    CreatePropertyStore(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn DXVA2CreateDirect3DDeviceManager9(presettoken: *mut u32, ppdevicemanager: *mut ::core::option::Option<IDirect3DDeviceManager9>) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "dxva2.dll""system" fn DXVA2CreateDirect3DDeviceManager9 ( presettoken : *mut u32 , ppdevicemanager : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    DXVA2CreateDirect3DDeviceManager9(presettoken, ::core::mem::transmute(ppdevicemanager)).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
#[inline]
pub unsafe fn DXVA2CreateVideoService<P0>(pdd: P0, riid: *const ::windows::core::GUID, ppservice: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D9::IDirect3DDevice9>,
{
    ::windows_targets::link ! ( "dxva2.dll""system" fn DXVA2CreateVideoService ( pdd : * mut::core::ffi::c_void , riid : *const ::windows::core::GUID , ppservice : *mut *mut ::core::ffi::c_void ) -> ::windows::core::HRESULT );
    DXVA2CreateVideoService(pdd.into_param().abi(), riid, ppservice).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
#[inline]
pub unsafe fn DXVAHD_CreateDevice<P0>(pd3ddevice: P0, pcontentdesc: *const DXVAHD_CONTENT_DESC, usage: DXVAHD_DEVICE_USAGE, pplugin: PDXVAHDSW_Plugin) -> ::windows::core::Result<IDXVAHD_Device>
where
    P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D9::IDirect3DDevice9Ex>,
{
    ::windows_targets::link ! ( "dxva2.dll""system" fn DXVAHD_CreateDevice ( pd3ddevice : * mut::core::ffi::c_void , pcontentdesc : *const DXVAHD_CONTENT_DESC , usage : DXVAHD_DEVICE_USAGE , pplugin : PDXVAHDSW_Plugin , ppdevice : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IDXVAHD_Device>();
    DXVAHD_CreateDevice(pd3ddevice.into_param().abi(), pcontentdesc, usage, pplugin, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFAddPeriodicCallback<P0>(callback: MFPERIODICCALLBACK, pcontext: P0, pdwkey: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFAddPeriodicCallback ( callback : MFPERIODICCALLBACK , pcontext : * mut::core::ffi::c_void , pdwkey : *mut u32 ) -> ::windows::core::HRESULT );
    MFAddPeriodicCallback(callback, pcontext.into_param().abi(), ::core::mem::transmute(pdwkey.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFAllocateSerialWorkQueue(dwworkqueue: u32) -> ::windows::core::Result<u32> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFAllocateSerialWorkQueue ( dwworkqueue : u32 , pdwworkqueue : *mut u32 ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<u32>();
    MFAllocateSerialWorkQueue(dwworkqueue, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFAllocateWorkQueue() -> ::windows::core::Result<u32> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFAllocateWorkQueue ( pdwworkqueue : *mut u32 ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<u32>();
    MFAllocateWorkQueue(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFAllocateWorkQueueEx(workqueuetype: MFASYNC_WORKQUEUE_TYPE) -> ::windows::core::Result<u32> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFAllocateWorkQueueEx ( workqueuetype : MFASYNC_WORKQUEUE_TYPE , pdwworkqueue : *mut u32 ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<u32>();
    MFAllocateWorkQueueEx(workqueuetype, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFAverageTimePerFrameToFrameRate(unaveragetimeperframe: u64, punnumerator: *mut u32, pundenominator: *mut u32) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFAverageTimePerFrameToFrameRate ( unaveragetimeperframe : u64 , punnumerator : *mut u32 , pundenominator : *mut u32 ) -> ::windows::core::HRESULT );
    MFAverageTimePerFrameToFrameRate(unaveragetimeperframe, punnumerator, pundenominator).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFBeginCreateFile<P0, P1, P2>(accessmode: MF_FILE_ACCESSMODE, openmode: MF_FILE_OPENMODE, fflags: MF_FILE_FLAGS, pwszfilepath: P0, pcallback: P1, pstate: P2) -> ::windows::core::Result<::windows::core::IUnknown>
where
    P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    P1: ::windows::core::IntoParam<IMFAsyncCallback>,
    P2: ::windows::core::IntoParam<::windows::core::IUnknown>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFBeginCreateFile ( accessmode : MF_FILE_ACCESSMODE , openmode : MF_FILE_OPENMODE , fflags : MF_FILE_FLAGS , pwszfilepath : ::windows::core::PCWSTR , pcallback : * mut::core::ffi::c_void , pstate : * mut::core::ffi::c_void , ppcancelcookie : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<::windows::core::IUnknown>();
    MFBeginCreateFile(accessmode, openmode, fflags, pwszfilepath.into_param().abi(), pcallback.into_param().abi(), pstate.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFBeginRegisterWorkQueueWithMMCSS<P0, P1, P2>(dwworkqueueid: u32, wszclass: P0, dwtaskid: u32, pdonecallback: P1, pdonestate: P2) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    P1: ::windows::core::IntoParam<IMFAsyncCallback>,
    P2: ::windows::core::IntoParam<::windows::core::IUnknown>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFBeginRegisterWorkQueueWithMMCSS ( dwworkqueueid : u32 , wszclass : ::windows::core::PCWSTR , dwtaskid : u32 , pdonecallback : * mut::core::ffi::c_void , pdonestate : * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFBeginRegisterWorkQueueWithMMCSS(dwworkqueueid, wszclass.into_param().abi(), dwtaskid, pdonecallback.into_param().abi(), pdonestate.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFBeginRegisterWorkQueueWithMMCSSEx<P0, P1, P2>(dwworkqueueid: u32, wszclass: P0, dwtaskid: u32, lpriority: i32, pdonecallback: P1, pdonestate: P2) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    P1: ::windows::core::IntoParam<IMFAsyncCallback>,
    P2: ::windows::core::IntoParam<::windows::core::IUnknown>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFBeginRegisterWorkQueueWithMMCSSEx ( dwworkqueueid : u32 , wszclass : ::windows::core::PCWSTR , dwtaskid : u32 , lpriority : i32 , pdonecallback : * mut::core::ffi::c_void , pdonestate : * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFBeginRegisterWorkQueueWithMMCSSEx(dwworkqueueid, wszclass.into_param().abi(), dwtaskid, lpriority, pdonecallback.into_param().abi(), pdonestate.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFBeginUnregisterWorkQueueWithMMCSS<P0, P1>(dwworkqueueid: u32, pdonecallback: P0, pdonestate: P1) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFAsyncCallback>,
    P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFBeginUnregisterWorkQueueWithMMCSS ( dwworkqueueid : u32 , pdonecallback : * mut::core::ffi::c_void , pdonestate : * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFBeginUnregisterWorkQueueWithMMCSS(dwworkqueueid, pdonecallback.into_param().abi(), pdonestate.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Gdi\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
#[inline]
pub unsafe fn MFCalculateBitmapImageSize(pbmih: *const super::super::Graphics::Gdi::BITMAPINFOHEADER, cbbufsize: u32, pcbimagesize: *mut u32, pbknown: ::core::option::Option<*mut super::super::Foundation::BOOL>) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCalculateBitmapImageSize ( pbmih : *const super::super::Graphics::Gdi:: BITMAPINFOHEADER , cbbufsize : u32 , pcbimagesize : *mut u32 , pbknown : *mut super::super::Foundation:: BOOL ) -> ::windows::core::HRESULT );
    MFCalculateBitmapImageSize(pbmih, cbbufsize, pcbimagesize, ::core::mem::transmute(pbknown.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCalculateImageSize(guidsubtype: *const ::windows::core::GUID, unwidth: u32, unheight: u32) -> ::windows::core::Result<u32> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCalculateImageSize ( guidsubtype : *const ::windows::core::GUID , unwidth : u32 , unheight : u32 , pcbimagesize : *mut u32 ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<u32>();
    MFCalculateImageSize(guidsubtype, unwidth, unheight, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCancelCreateFile<P0>(pcancelcookie: P0) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCancelCreateFile ( pcancelcookie : * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFCancelCreateFile(pcancelcookie.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCancelWorkItem(key: u64) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCancelWorkItem ( key : u64 ) -> ::windows::core::HRESULT );
    MFCancelWorkItem(key).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MFCombineSamples<P0, P1>(psample: P0, psampletoadd: P1, dwmaxmergeddurationinms: u32) -> ::windows::core::Result<super::super::Foundation::BOOL>
where
    P0: ::windows::core::IntoParam<IMFSample>,
    P1: ::windows::core::IntoParam<IMFSample>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCombineSamples ( psample : * mut::core::ffi::c_void , psampletoadd : * mut::core::ffi::c_void , dwmaxmergeddurationinms : u32 , pmerged : *mut super::super::Foundation:: BOOL ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
    MFCombineSamples(psample.into_param().abi(), psampletoadd.into_param().abi(), dwmaxmergeddurationinms, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MFCompareFullToPartialMediaType<P0, P1>(pmftypefull: P0, pmftypepartial: P1) -> super::super::Foundation::BOOL
where
    P0: ::windows::core::IntoParam<IMFMediaType>,
    P1: ::windows::core::IntoParam<IMFMediaType>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCompareFullToPartialMediaType ( pmftypefull : * mut::core::ffi::c_void , pmftypepartial : * mut::core::ffi::c_void ) -> super::super::Foundation:: BOOL );
    MFCompareFullToPartialMediaType(pmftypefull.into_param().abi(), pmftypepartial.into_param().abi())
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MFConvertColorInfoFromDXVA(ptoformat: *mut MFVIDEOFORMAT, dwfromdxva: u32) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFConvertColorInfoFromDXVA ( ptoformat : *mut MFVIDEOFORMAT , dwfromdxva : u32 ) -> ::windows::core::HRESULT );
    MFConvertColorInfoFromDXVA(ptoformat, dwfromdxva).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MFConvertColorInfoToDXVA(pdwtodxva: *mut u32, pfromformat: *const MFVIDEOFORMAT) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFConvertColorInfoToDXVA ( pdwtodxva : *mut u32 , pfromformat : *const MFVIDEOFORMAT ) -> ::windows::core::HRESULT );
    MFConvertColorInfoToDXVA(pdwtodxva, pfromformat).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFConvertFromFP16Array(pdest: *mut f32, psrc: *const u16, dwcount: u32) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFConvertFromFP16Array ( pdest : *mut f32 , psrc : *const u16 , dwcount : u32 ) -> ::windows::core::HRESULT );
    MFConvertFromFP16Array(pdest, psrc, dwcount).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFConvertToFP16Array(pdest: *mut u16, psrc: *const f32, dwcount: u32) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFConvertToFP16Array ( pdest : *mut u16 , psrc : *const f32 , dwcount : u32 ) -> ::windows::core::HRESULT );
    MFConvertToFP16Array(pdest, psrc, dwcount).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCopyImage(pdest: *mut u8, ldeststride: i32, psrc: *const u8, lsrcstride: i32, dwwidthinbytes: u32, dwlines: u32) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCopyImage ( pdest : *mut u8 , ldeststride : i32 , psrc : *const u8 , lsrcstride : i32 , dwwidthinbytes : u32 , dwlines : u32 ) -> ::windows::core::HRESULT );
    MFCopyImage(pdest, ldeststride, psrc, lsrcstride, dwwidthinbytes, dwlines).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MFCreate2DMediaBuffer<P0>(dwwidth: u32, dwheight: u32, dwfourcc: u32, fbottomup: P0) -> ::windows::core::Result<IMFMediaBuffer>
where
    P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreate2DMediaBuffer ( dwwidth : u32 , dwheight : u32 , dwfourcc : u32 , fbottomup : super::super::Foundation:: BOOL , ppbuffer : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaBuffer>();
    MFCreate2DMediaBuffer(dwwidth, dwheight, dwfourcc, fbottomup.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreate3GPMediaSink<P0, P1, P2>(pibytestream: P0, pvideomediatype: P1, paudiomediatype: P2) -> ::windows::core::Result<IMFMediaSink>
where
    P0: ::windows::core::IntoParam<IMFByteStream>,
    P1: ::windows::core::IntoParam<IMFMediaType>,
    P2: ::windows::core::IntoParam<IMFMediaType>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreate3GPMediaSink ( pibytestream : * mut::core::ffi::c_void , pvideomediatype : * mut::core::ffi::c_void , paudiomediatype : * mut::core::ffi::c_void , ppimediasink : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaSink>();
    MFCreate3GPMediaSink(pibytestream.into_param().abi(), pvideomediatype.into_param().abi(), paudiomediatype.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateAC3MediaSink<P0, P1>(ptargetbytestream: P0, paudiomediatype: P1) -> ::windows::core::Result<IMFMediaSink>
where
    P0: ::windows::core::IntoParam<IMFByteStream>,
    P1: ::windows::core::IntoParam<IMFMediaType>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateAC3MediaSink ( ptargetbytestream : * mut::core::ffi::c_void , paudiomediatype : * mut::core::ffi::c_void , ppmediasink : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaSink>();
    MFCreateAC3MediaSink(ptargetbytestream.into_param().abi(), paudiomediatype.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateADTSMediaSink<P0, P1>(ptargetbytestream: P0, paudiomediatype: P1) -> ::windows::core::Result<IMFMediaSink>
where
    P0: ::windows::core::IntoParam<IMFByteStream>,
    P1: ::windows::core::IntoParam<IMFMediaType>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateADTSMediaSink ( ptargetbytestream : * mut::core::ffi::c_void , paudiomediatype : * mut::core::ffi::c_void , ppmediasink : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaSink>();
    MFCreateADTSMediaSink(ptargetbytestream.into_param().abi(), paudiomediatype.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MFCreateAMMediaTypeFromMFMediaType<P0>(pmftype: P0, guidformatblocktype: ::windows::core::GUID, ppamtype: *mut *mut AM_MEDIA_TYPE) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFMediaType>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateAMMediaTypeFromMFMediaType ( pmftype : * mut::core::ffi::c_void , guidformatblocktype : ::windows::core::GUID , ppamtype : *mut *mut AM_MEDIA_TYPE ) -> ::windows::core::HRESULT );
    MFCreateAMMediaTypeFromMFMediaType(pmftype.into_param().abi(), ::core::mem::transmute(guidformatblocktype), ppamtype).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateASFContentInfo() -> ::windows::core::Result<IMFASFContentInfo> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateASFContentInfo ( ppicontentinfo : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFASFContentInfo>();
    MFCreateASFContentInfo(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateASFIndexer() -> ::windows::core::Result<IMFASFIndexer> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateASFIndexer ( ppiindexer : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFASFIndexer>();
    MFCreateASFIndexer(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateASFIndexerByteStream<P0>(picontentbytestream: P0, cbindexstartoffset: u64) -> ::windows::core::Result<IMFByteStream>
where
    P0: ::windows::core::IntoParam<IMFByteStream>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateASFIndexerByteStream ( picontentbytestream : * mut::core::ffi::c_void , cbindexstartoffset : u64 , piindexbytestream : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFByteStream>();
    MFCreateASFIndexerByteStream(picontentbytestream.into_param().abi(), cbindexstartoffset, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateASFMediaSink<P0>(pibytestream: P0) -> ::windows::core::Result<IMFMediaSink>
where
    P0: ::windows::core::IntoParam<IMFByteStream>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateASFMediaSink ( pibytestream : * mut::core::ffi::c_void , ppimediasink : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaSink>();
    MFCreateASFMediaSink(pibytestream.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateASFMediaSinkActivate<P0, P1>(pwszfilename: P0, pcontentinfo: P1) -> ::windows::core::Result<IMFActivate>
where
    P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    P1: ::windows::core::IntoParam<IMFASFContentInfo>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateASFMediaSinkActivate ( pwszfilename : ::windows::core::PCWSTR , pcontentinfo : * mut::core::ffi::c_void , ppiactivate : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFActivate>();
    MFCreateASFMediaSinkActivate(pwszfilename.into_param().abi(), pcontentinfo.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateASFMultiplexer() -> ::windows::core::Result<IMFASFMultiplexer> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateASFMultiplexer ( ppimultiplexer : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFASFMultiplexer>();
    MFCreateASFMultiplexer(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateASFProfile() -> ::windows::core::Result<IMFASFProfile> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateASFProfile ( ppiprofile : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFASFProfile>();
    MFCreateASFProfile(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateASFProfileFromPresentationDescriptor<P0>(pipd: P0) -> ::windows::core::Result<IMFASFProfile>
where
    P0: ::windows::core::IntoParam<IMFPresentationDescriptor>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateASFProfileFromPresentationDescriptor ( pipd : * mut::core::ffi::c_void , ppiprofile : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFASFProfile>();
    MFCreateASFProfileFromPresentationDescriptor(pipd.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateASFSplitter() -> ::windows::core::Result<IMFASFSplitter> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateASFSplitter ( ppisplitter : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFASFSplitter>();
    MFCreateASFSplitter(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateASFStreamSelector<P0>(piasfprofile: P0) -> ::windows::core::Result<IMFASFStreamSelector>
where
    P0: ::windows::core::IntoParam<IMFASFProfile>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateASFStreamSelector ( piasfprofile : * mut::core::ffi::c_void , ppselector : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFASFStreamSelector>();
    MFCreateASFStreamSelector(piasfprofile.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateASFStreamingMediaSink<P0>(pibytestream: P0) -> ::windows::core::Result<IMFMediaSink>
where
    P0: ::windows::core::IntoParam<IMFByteStream>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateASFStreamingMediaSink ( pibytestream : * mut::core::ffi::c_void , ppimediasink : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaSink>();
    MFCreateASFStreamingMediaSink(pibytestream.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateASFStreamingMediaSinkActivate<P0, P1>(pbytestreamactivate: P0, pcontentinfo: P1) -> ::windows::core::Result<IMFActivate>
where
    P0: ::windows::core::IntoParam<IMFActivate>,
    P1: ::windows::core::IntoParam<IMFASFContentInfo>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateASFStreamingMediaSinkActivate ( pbytestreamactivate : * mut::core::ffi::c_void , pcontentinfo : * mut::core::ffi::c_void , ppiactivate : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFActivate>();
    MFCreateASFStreamingMediaSinkActivate(pbytestreamactivate.into_param().abi(), pcontentinfo.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateAVIMediaSink<P0, P1, P2>(pibytestream: P0, pvideomediatype: P1, paudiomediatype: P2) -> ::windows::core::Result<IMFMediaSink>
where
    P0: ::windows::core::IntoParam<IMFByteStream>,
    P1: ::windows::core::IntoParam<IMFMediaType>,
    P2: ::windows::core::IntoParam<IMFMediaType>,
{
    ::windows_targets::link ! ( "mfsrcsnk.dll""system" fn MFCreateAVIMediaSink ( pibytestream : * mut::core::ffi::c_void , pvideomediatype : * mut::core::ffi::c_void , paudiomediatype : * mut::core::ffi::c_void , ppimediasink : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaSink>();
    MFCreateAVIMediaSink(pibytestream.into_param().abi(), pvideomediatype.into_param().abi(), paudiomediatype.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateAggregateSource<P0>(psourcecollection: P0) -> ::windows::core::Result<IMFMediaSource>
where
    P0: ::windows::core::IntoParam<IMFCollection>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateAggregateSource ( psourcecollection : * mut::core::ffi::c_void , ppaggsource : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaSource>();
    MFCreateAggregateSource(psourcecollection.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateAlignedMemoryBuffer(cbmaxlength: u32, cbaligment: u32) -> ::windows::core::Result<IMFMediaBuffer> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateAlignedMemoryBuffer ( cbmaxlength : u32 , cbaligment : u32 , ppbuffer : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaBuffer>();
    MFCreateAlignedMemoryBuffer(cbmaxlength, cbaligment, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateAsyncResult<P0, P1, P2>(punkobject: P0, pcallback: P1, punkstate: P2) -> ::windows::core::Result<IMFAsyncResult>
where
    P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    P1: ::windows::core::IntoParam<IMFAsyncCallback>,
    P2: ::windows::core::IntoParam<::windows::core::IUnknown>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateAsyncResult ( punkobject : * mut::core::ffi::c_void , pcallback : * mut::core::ffi::c_void , punkstate : * mut::core::ffi::c_void , ppasyncresult : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFAsyncResult>();
    MFCreateAsyncResult(punkobject.into_param().abi(), pcallback.into_param().abi(), punkstate.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateAttributes(ppmfattributes: *mut ::core::option::Option<IMFAttributes>, cinitialsize: u32) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateAttributes ( ppmfattributes : *mut * mut::core::ffi::c_void , cinitialsize : u32 ) -> ::windows::core::HRESULT );
    MFCreateAttributes(::core::mem::transmute(ppmfattributes), cinitialsize).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Media_Audio\"`*"]
#[cfg(feature = "Win32_Media_Audio")]
#[inline]
pub unsafe fn MFCreateAudioMediaType(paudioformat: *const super::Audio::WAVEFORMATEX) -> ::windows::core::Result<IMFAudioMediaType> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateAudioMediaType ( paudioformat : *const super::Audio:: WAVEFORMATEX , ppiaudiomediatype : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFAudioMediaType>();
    MFCreateAudioMediaType(paudioformat, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateAudioRenderer<P0>(paudioattributes: P0) -> ::windows::core::Result<IMFMediaSink>
where
    P0: ::windows::core::IntoParam<IMFAttributes>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateAudioRenderer ( paudioattributes : * mut::core::ffi::c_void , ppsink : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaSink>();
    MFCreateAudioRenderer(paudioattributes.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateAudioRendererActivate() -> ::windows::core::Result<IMFActivate> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateAudioRendererActivate ( ppactivate : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFActivate>();
    MFCreateAudioRendererActivate(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateCameraOcclusionStateMonitor<P0, P1>(symboliclink: P0, callback: P1) -> ::windows::core::Result<IMFCameraOcclusionStateMonitor>
where
    P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    P1: ::windows::core::IntoParam<IMFCameraOcclusionStateReportCallback>,
{
    ::windows_targets::link ! ( "mfsensorgroup.dll""system" fn MFCreateCameraOcclusionStateMonitor ( symboliclink : ::windows::core::PCWSTR , callback : * mut::core::ffi::c_void , occlusionstatemonitor : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFCameraOcclusionStateMonitor>();
    MFCreateCameraOcclusionStateMonitor(symboliclink.into_param().abi(), callback.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateCollection() -> ::windows::core::Result<IMFCollection> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateCollection ( ppimfcollection : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFCollection>();
    MFCreateCollection(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateContentDecryptorContext<P0, P1>(guidmediaprotectionsystemid: *const ::windows::core::GUID, pd3dmanager: P0, pcontentprotectiondevice: P1) -> ::windows::core::Result<IMFContentDecryptorContext>
where
    P0: ::windows::core::IntoParam<IMFDXGIDeviceManager>,
    P1: ::windows::core::IntoParam<IMFContentProtectionDevice>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateContentDecryptorContext ( guidmediaprotectionsystemid : *const ::windows::core::GUID , pd3dmanager : * mut::core::ffi::c_void , pcontentprotectiondevice : * mut::core::ffi::c_void , ppcontentdecryptorcontext : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFContentDecryptorContext>();
    MFCreateContentDecryptorContext(guidmediaprotectionsystemid, pd3dmanager.into_param().abi(), pcontentprotectiondevice.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateContentProtectionDevice(protectionsystemid: *const ::windows::core::GUID) -> ::windows::core::Result<IMFContentProtectionDevice> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateContentProtectionDevice ( protectionsystemid : *const ::windows::core::GUID , contentprotectiondevice : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFContentProtectionDevice>();
    MFCreateContentProtectionDevice(protectionsystemid, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateCredentialCache() -> ::windows::core::Result<IMFNetCredentialCache> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateCredentialCache ( ppcache : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFNetCredentialCache>();
    MFCreateCredentialCache(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[inline]
pub unsafe fn MFCreateD3D12SynchronizationObject<P0>(pdevice: P0, riid: *const ::windows::core::GUID, ppvsyncobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Device>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateD3D12SynchronizationObject ( pdevice : * mut::core::ffi::c_void , riid : *const ::windows::core::GUID , ppvsyncobject : *mut *mut ::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFCreateD3D12SynchronizationObject(pdevice.into_param().abi(), riid, ppvsyncobject).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateDXGIDeviceManager(resettoken: *mut u32, ppdevicemanager: *mut ::core::option::Option<IMFDXGIDeviceManager>) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateDXGIDeviceManager ( resettoken : *mut u32 , ppdevicemanager : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFCreateDXGIDeviceManager(resettoken, ::core::mem::transmute(ppdevicemanager)).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MFCreateDXGISurfaceBuffer<P0, P1>(riid: *const ::windows::core::GUID, punksurface: P0, usubresourceindex: u32, fbottomupwhenlinear: P1) -> ::windows::core::Result<IMFMediaBuffer>
where
    P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    P1: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateDXGISurfaceBuffer ( riid : *const ::windows::core::GUID , punksurface : * mut::core::ffi::c_void , usubresourceindex : u32 , fbottomupwhenlinear : super::super::Foundation:: BOOL , ppbuffer : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaBuffer>();
    MFCreateDXGISurfaceBuffer(riid, punksurface.into_param().abi(), usubresourceindex, fbottomupwhenlinear.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MFCreateDXSurfaceBuffer<P0, P1>(riid: *const ::windows::core::GUID, punksurface: P0, fbottomupwhenlinear: P1) -> ::windows::core::Result<IMFMediaBuffer>
where
    P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    P1: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateDXSurfaceBuffer ( riid : *const ::windows::core::GUID , punksurface : * mut::core::ffi::c_void , fbottomupwhenlinear : super::super::Foundation:: BOOL , ppbuffer : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaBuffer>();
    MFCreateDXSurfaceBuffer(riid, punksurface.into_param().abi(), fbottomupwhenlinear.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateDeviceSource<P0>(pattributes: P0) -> ::windows::core::Result<IMFMediaSource>
where
    P0: ::windows::core::IntoParam<IMFAttributes>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateDeviceSource ( pattributes : * mut::core::ffi::c_void , ppsource : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaSource>();
    MFCreateDeviceSource(pattributes.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateDeviceSourceActivate<P0>(pattributes: P0) -> ::windows::core::Result<IMFActivate>
where
    P0: ::windows::core::IntoParam<IMFAttributes>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateDeviceSourceActivate ( pattributes : * mut::core::ffi::c_void , ppactivate : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFActivate>();
    MFCreateDeviceSourceActivate(pattributes.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_System_Com\"`*"]
#[cfg(feature = "Win32_System_Com")]
#[inline]
pub unsafe fn MFCreateEncryptedMediaExtensionsStoreActivate<P0, P1, P2>(pmphost: P0, objectstream: P1, classid: P2) -> ::windows::core::Result<IMFActivate>
where
    P0: ::windows::core::IntoParam<IMFPMPHostApp>,
    P1: ::windows::core::IntoParam<super::super::System::Com::IStream>,
    P2: ::windows::core::IntoParam<::windows::core::PCWSTR>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateEncryptedMediaExtensionsStoreActivate ( pmphost : * mut::core::ffi::c_void , objectstream : * mut::core::ffi::c_void , classid : ::windows::core::PCWSTR , activate : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFActivate>();
    MFCreateEncryptedMediaExtensionsStoreActivate(pmphost.into_param().abi(), objectstream.into_param().abi(), classid.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateEventQueue() -> ::windows::core::Result<IMFMediaEventQueue> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateEventQueue ( ppmediaeventqueue : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaEventQueue>();
    MFCreateEventQueue(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateExtendedCameraIntrinsicModel(distortionmodeltype: MFCameraIntrinsic_DistortionModelType) -> ::windows::core::Result<IMFExtendedCameraIntrinsicModel> {
    ::windows_targets::link ! ( "mfcore.dll""system" fn MFCreateExtendedCameraIntrinsicModel ( distortionmodeltype : MFCameraIntrinsic_DistortionModelType , ppextendedcameraintrinsicmodel : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFExtendedCameraIntrinsicModel>();
    MFCreateExtendedCameraIntrinsicModel(distortionmodeltype, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateExtendedCameraIntrinsics() -> ::windows::core::Result<IMFExtendedCameraIntrinsics> {
    ::windows_targets::link ! ( "mfcore.dll""system" fn MFCreateExtendedCameraIntrinsics ( ppextendedcameraintrinsics : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFExtendedCameraIntrinsics>();
    MFCreateExtendedCameraIntrinsics(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateFMPEG4MediaSink<P0, P1, P2>(pibytestream: P0, pvideomediatype: P1, paudiomediatype: P2) -> ::windows::core::Result<IMFMediaSink>
where
    P0: ::windows::core::IntoParam<IMFByteStream>,
    P1: ::windows::core::IntoParam<IMFMediaType>,
    P2: ::windows::core::IntoParam<IMFMediaType>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateFMPEG4MediaSink ( pibytestream : * mut::core::ffi::c_void , pvideomediatype : * mut::core::ffi::c_void , paudiomediatype : * mut::core::ffi::c_void , ppimediasink : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaSink>();
    MFCreateFMPEG4MediaSink(pibytestream.into_param().abi(), pvideomediatype.into_param().abi(), paudiomediatype.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateFile<P0>(accessmode: MF_FILE_ACCESSMODE, openmode: MF_FILE_OPENMODE, fflags: MF_FILE_FLAGS, pwszfileurl: P0) -> ::windows::core::Result<IMFByteStream>
where
    P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateFile ( accessmode : MF_FILE_ACCESSMODE , openmode : MF_FILE_OPENMODE , fflags : MF_FILE_FLAGS , pwszfileurl : ::windows::core::PCWSTR , ppibytestream : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFByteStream>();
    MFCreateFile(accessmode, openmode, fflags, pwszfileurl.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Media_DxMediaObjects\"`*"]
#[cfg(feature = "Win32_Media_DxMediaObjects")]
#[inline]
pub unsafe fn MFCreateLegacyMediaBufferOnMFMediaBuffer<P0, P1>(psample: P0, pmfmediabuffer: P1, cboffset: u32) -> ::windows::core::Result<super::DxMediaObjects::IMediaBuffer>
where
    P0: ::windows::core::IntoParam<IMFSample>,
    P1: ::windows::core::IntoParam<IMFMediaBuffer>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateLegacyMediaBufferOnMFMediaBuffer ( psample : * mut::core::ffi::c_void , pmfmediabuffer : * mut::core::ffi::c_void , cboffset : u32 , ppmediabuffer : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<super::DxMediaObjects::IMediaBuffer>();
    MFCreateLegacyMediaBufferOnMFMediaBuffer(psample.into_param().abi(), pmfmediabuffer.into_param().abi(), cboffset, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_System_Com\"`*"]
#[cfg(feature = "Win32_System_Com")]
#[inline]
pub unsafe fn MFCreateMFByteStreamOnStream<P0>(pstream: P0) -> ::windows::core::Result<IMFByteStream>
where
    P0: ::windows::core::IntoParam<super::super::System::Com::IStream>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateMFByteStreamOnStream ( pstream : * mut::core::ffi::c_void , ppbytestream : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFByteStream>();
    MFCreateMFByteStreamOnStream(pstream.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateMFByteStreamOnStreamEx<P0>(punkstream: P0) -> ::windows::core::Result<IMFByteStream>
where
    P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateMFByteStreamOnStreamEx ( punkstream : * mut::core::ffi::c_void , ppbytestream : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFByteStream>();
    MFCreateMFByteStreamOnStreamEx(punkstream.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateMFByteStreamWrapper<P0>(pstream: P0) -> ::windows::core::Result<IMFByteStream>
where
    P0: ::windows::core::IntoParam<IMFByteStream>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateMFByteStreamWrapper ( pstream : * mut::core::ffi::c_void , ppstreamwrapper : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFByteStream>();
    MFCreateMFByteStreamWrapper(pstream.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MFCreateMFVideoFormatFromMFMediaType<P0>(pmftype: P0, ppmfvf: *mut *mut MFVIDEOFORMAT, pcbsize: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFMediaType>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateMFVideoFormatFromMFMediaType ( pmftype : * mut::core::ffi::c_void , ppmfvf : *mut *mut MFVIDEOFORMAT , pcbsize : *mut u32 ) -> ::windows::core::HRESULT );
    MFCreateMFVideoFormatFromMFMediaType(pmftype.into_param().abi(), ppmfvf, ::core::mem::transmute(pcbsize.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateMP3MediaSink<P0>(ptargetbytestream: P0) -> ::windows::core::Result<IMFMediaSink>
where
    P0: ::windows::core::IntoParam<IMFByteStream>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateMP3MediaSink ( ptargetbytestream : * mut::core::ffi::c_void , ppmediasink : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaSink>();
    MFCreateMP3MediaSink(ptargetbytestream.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateMPEG4MediaSink<P0, P1, P2>(pibytestream: P0, pvideomediatype: P1, paudiomediatype: P2) -> ::windows::core::Result<IMFMediaSink>
where
    P0: ::windows::core::IntoParam<IMFByteStream>,
    P1: ::windows::core::IntoParam<IMFMediaType>,
    P2: ::windows::core::IntoParam<IMFMediaType>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateMPEG4MediaSink ( pibytestream : * mut::core::ffi::c_void , pvideomediatype : * mut::core::ffi::c_void , paudiomediatype : * mut::core::ffi::c_void , ppimediasink : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaSink>();
    MFCreateMPEG4MediaSink(pibytestream.into_param().abi(), pvideomediatype.into_param().abi(), paudiomediatype.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateMediaBufferFromMediaType<P0>(pmediatype: P0, llduration: i64, dwminlength: u32, dwminalignment: u32) -> ::windows::core::Result<IMFMediaBuffer>
where
    P0: ::windows::core::IntoParam<IMFMediaType>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateMediaBufferFromMediaType ( pmediatype : * mut::core::ffi::c_void , llduration : i64 , dwminlength : u32 , dwminalignment : u32 , ppbuffer : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaBuffer>();
    MFCreateMediaBufferFromMediaType(pmediatype.into_param().abi(), llduration, dwminlength, dwminalignment, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateMediaBufferWrapper<P0>(pbuffer: P0, cboffset: u32, dwlength: u32) -> ::windows::core::Result<IMFMediaBuffer>
where
    P0: ::windows::core::IntoParam<IMFMediaBuffer>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateMediaBufferWrapper ( pbuffer : * mut::core::ffi::c_void , cboffset : u32 , dwlength : u32 , ppbuffer : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaBuffer>();
    MFCreateMediaBufferWrapper(pbuffer.into_param().abi(), cboffset, dwlength, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
#[inline]
pub unsafe fn MFCreateMediaEvent(met: u32, guidextendedtype: *const ::windows::core::GUID, hrstatus: ::windows::core::HRESULT, pvvalue: ::core::option::Option<*const super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<IMFMediaEvent> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateMediaEvent ( met : u32 , guidextendedtype : *const ::windows::core::GUID , hrstatus : ::windows::core::HRESULT , pvvalue : *const super::super::System::Com::StructuredStorage:: PROPVARIANT , ppevent : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaEvent>();
    MFCreateMediaEvent(met, guidextendedtype, hrstatus, ::core::mem::transmute(pvvalue.unwrap_or(::std::ptr::null())), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateMediaExtensionActivate<P0, P1>(szactivatableclassid: P0, pconfiguration: P1, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateMediaExtensionActivate ( szactivatableclassid : ::windows::core::PCWSTR , pconfiguration : * mut::core::ffi::c_void , riid : *const ::windows::core::GUID , ppvobject : *mut *mut ::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFCreateMediaExtensionActivate(szactivatableclassid.into_param().abi(), pconfiguration.into_param().abi(), riid, ppvobject).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateMediaSession<P0>(pconfiguration: P0) -> ::windows::core::Result<IMFMediaSession>
where
    P0: ::windows::core::IntoParam<IMFAttributes>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateMediaSession ( pconfiguration : * mut::core::ffi::c_void , ppmediasession : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaSession>();
    MFCreateMediaSession(pconfiguration.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateMediaType() -> ::windows::core::Result<IMFMediaType> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateMediaType ( ppmftype : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
    MFCreateMediaType(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateMediaTypeFromProperties<P0>(punkstream: P0) -> ::windows::core::Result<IMFMediaType>
where
    P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateMediaTypeFromProperties ( punkstream : * mut::core::ffi::c_void , ppmediatype : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
    MFCreateMediaTypeFromProperties(punkstream.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateMediaTypeFromRepresentation(guidrepresentation: ::windows::core::GUID, pvrepresentation: *const ::core::ffi::c_void) -> ::windows::core::Result<IMFMediaType> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateMediaTypeFromRepresentation ( guidrepresentation : ::windows::core::GUID , pvrepresentation : *const ::core::ffi::c_void , ppimediatype : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
    MFCreateMediaTypeFromRepresentation(::core::mem::transmute(guidrepresentation), pvrepresentation, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateMemoryBuffer(cbmaxlength: u32) -> ::windows::core::Result<IMFMediaBuffer> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateMemoryBuffer ( cbmaxlength : u32 , ppbuffer : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaBuffer>();
    MFCreateMemoryBuffer(cbmaxlength, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateMuxSink<P0, P1>(guidoutputsubtype: ::windows::core::GUID, poutputattributes: P0, poutputbytestream: P1) -> ::windows::core::Result<IMFMediaSink>
where
    P0: ::windows::core::IntoParam<IMFAttributes>,
    P1: ::windows::core::IntoParam<IMFByteStream>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateMuxSink ( guidoutputsubtype : ::windows::core::GUID , poutputattributes : * mut::core::ffi::c_void , poutputbytestream : * mut::core::ffi::c_void , ppmuxsink : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaSink>();
    MFCreateMuxSink(::core::mem::transmute(guidoutputsubtype), poutputattributes.into_param().abi(), poutputbytestream.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateMuxStreamAttributes<P0>(pattributestomux: P0) -> ::windows::core::Result<IMFAttributes>
where
    P0: ::windows::core::IntoParam<IMFCollection>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateMuxStreamAttributes ( pattributestomux : * mut::core::ffi::c_void , ppmuxattribs : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFAttributes>();
    MFCreateMuxStreamAttributes(pattributestomux.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateMuxStreamMediaType<P0>(pmediatypestomux: P0) -> ::windows::core::Result<IMFMediaType>
where
    P0: ::windows::core::IntoParam<IMFCollection>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateMuxStreamMediaType ( pmediatypestomux : * mut::core::ffi::c_void , ppmuxmediatype : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
    MFCreateMuxStreamMediaType(pmediatypestomux.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateMuxStreamSample<P0>(psamplestomux: P0) -> ::windows::core::Result<IMFSample>
where
    P0: ::windows::core::IntoParam<IMFCollection>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateMuxStreamSample ( psamplestomux : * mut::core::ffi::c_void , ppmuxsample : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFSample>();
    MFCreateMuxStreamSample(psamplestomux.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateNetSchemePlugin(riid: *const ::windows::core::GUID, ppvhandler: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateNetSchemePlugin ( riid : *const ::windows::core::GUID , ppvhandler : *mut *mut ::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFCreateNetSchemePlugin(riid, ppvhandler).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreatePMPMediaSession<P0>(dwcreationflags: u32, pconfiguration: P0, ppmediasession: *mut ::core::option::Option<IMFMediaSession>, ppenableractivate: ::core::option::Option<*mut ::core::option::Option<IMFActivate>>) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFAttributes>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreatePMPMediaSession ( dwcreationflags : u32 , pconfiguration : * mut::core::ffi::c_void , ppmediasession : *mut * mut::core::ffi::c_void , ppenableractivate : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFCreatePMPMediaSession(dwcreationflags, pconfiguration.into_param().abi(), ::core::mem::transmute(ppmediasession), ::core::mem::transmute(ppenableractivate.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreatePMPServer(dwcreationflags: u32) -> ::windows::core::Result<IMFPMPServer> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreatePMPServer ( dwcreationflags : u32 , pppmpserver : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFPMPServer>();
    MFCreatePMPServer(dwcreationflags, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreatePresentationClock() -> ::windows::core::Result<IMFPresentationClock> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreatePresentationClock ( pppresentationclock : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFPresentationClock>();
    MFCreatePresentationClock(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreatePresentationDescriptor(apstreamdescriptors: ::core::option::Option<&[::core::option::Option<IMFStreamDescriptor>]>) -> ::windows::core::Result<IMFPresentationDescriptor> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreatePresentationDescriptor ( cstreamdescriptors : u32 , apstreamdescriptors : *const * mut::core::ffi::c_void , pppresentationdescriptor : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFPresentationDescriptor>();
    MFCreatePresentationDescriptor(apstreamdescriptors.as_deref().map_or(0, |slice| slice.len() as _), ::core::mem::transmute(apstreamdescriptors.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr())), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreatePresentationDescriptorFromASFProfile<P0>(piprofile: P0) -> ::windows::core::Result<IMFPresentationDescriptor>
where
    P0: ::windows::core::IntoParam<IMFASFProfile>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreatePresentationDescriptorFromASFProfile ( piprofile : * mut::core::ffi::c_void , ppipd : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFPresentationDescriptor>();
    MFCreatePresentationDescriptorFromASFProfile(piprofile.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreatePropertiesFromMediaType<P0>(pmediatype: P0, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFMediaType>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreatePropertiesFromMediaType ( pmediatype : * mut::core::ffi::c_void , riid : *const ::windows::core::GUID , ppv : *mut *mut ::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFCreatePropertiesFromMediaType(pmediatype.into_param().abi(), riid, ppv).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateProtectedEnvironmentAccess() -> ::windows::core::Result<IMFProtectedEnvironmentAccess> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateProtectedEnvironmentAccess ( ppaccess : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFProtectedEnvironmentAccess>();
    MFCreateProtectedEnvironmentAccess(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_UI_Shell_PropertiesSystem\"`*"]
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
#[inline]
pub unsafe fn MFCreateProxyLocator<P0, P1>(pszprotocol: P0, pproxyconfig: P1) -> ::windows::core::Result<IMFNetProxyLocator>
where
    P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    P1: ::windows::core::IntoParam<super::super::UI::Shell::PropertiesSystem::IPropertyStore>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateProxyLocator ( pszprotocol : ::windows::core::PCWSTR , pproxyconfig : * mut::core::ffi::c_void , ppproxylocator : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFNetProxyLocator>();
    MFCreateProxyLocator(pszprotocol.into_param().abi(), pproxyconfig.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateRelativePanelWatcher<P0, P1>(videodeviceid: P0, displaymonitordeviceid: P1) -> ::windows::core::Result<IMFRelativePanelWatcher>
where
    P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
{
    ::windows_targets::link ! ( "mfsensorgroup.dll""system" fn MFCreateRelativePanelWatcher ( videodeviceid : ::windows::core::PCWSTR , displaymonitordeviceid : ::windows::core::PCWSTR , pprelativepanelwatcher : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFRelativePanelWatcher>();
    MFCreateRelativePanelWatcher(videodeviceid.into_param().abi(), displaymonitordeviceid.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateRemoteDesktopPlugin() -> ::windows::core::Result<IMFRemoteDesktopPlugin> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateRemoteDesktopPlugin ( ppplugin : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFRemoteDesktopPlugin>();
    MFCreateRemoteDesktopPlugin(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateSample() -> ::windows::core::Result<IMFSample> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateSample ( ppimfsample : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFSample>();
    MFCreateSample(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateSampleCopierMFT() -> ::windows::core::Result<IMFTransform> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateSampleCopierMFT ( ppcopiermft : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFTransform>();
    MFCreateSampleCopierMFT(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateSampleGrabberSinkActivate<P0, P1>(pimfmediatype: P0, pimfsamplegrabbersinkcallback: P1) -> ::windows::core::Result<IMFActivate>
where
    P0: ::windows::core::IntoParam<IMFMediaType>,
    P1: ::windows::core::IntoParam<IMFSampleGrabberSinkCallback>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateSampleGrabberSinkActivate ( pimfmediatype : * mut::core::ffi::c_void , pimfsamplegrabbersinkcallback : * mut::core::ffi::c_void , ppiactivate : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFActivate>();
    MFCreateSampleGrabberSinkActivate(pimfmediatype.into_param().abi(), pimfsamplegrabbersinkcallback.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateSensorActivityMonitor<P0>(pcallback: P0) -> ::windows::core::Result<IMFSensorActivityMonitor>
where
    P0: ::windows::core::IntoParam<IMFSensorActivitiesReportCallback>,
{
    ::windows_targets::link ! ( "mfsensorgroup.dll""system" fn MFCreateSensorActivityMonitor ( pcallback : * mut::core::ffi::c_void , ppactivitymonitor : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFSensorActivityMonitor>();
    MFCreateSensorActivityMonitor(pcallback.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateSensorGroup<P0>(sensorgroupsymboliclink: P0) -> ::windows::core::Result<IMFSensorGroup>
where
    P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
{
    ::windows_targets::link ! ( "mfsensorgroup.dll""system" fn MFCreateSensorGroup ( sensorgroupsymboliclink : ::windows::core::PCWSTR , ppsensorgroup : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFSensorGroup>();
    MFCreateSensorGroup(sensorgroupsymboliclink.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateSensorProfile<P0>(profiletype: *const ::windows::core::GUID, profileindex: u32, constraints: P0) -> ::windows::core::Result<IMFSensorProfile>
where
    P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
{
    ::windows_targets::link ! ( "mfsensorgroup.dll""system" fn MFCreateSensorProfile ( profiletype : *const ::windows::core::GUID , profileindex : u32 , constraints : ::windows::core::PCWSTR , ppprofile : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFSensorProfile>();
    MFCreateSensorProfile(profiletype, profileindex, constraints.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateSensorProfileCollection() -> ::windows::core::Result<IMFSensorProfileCollection> {
    ::windows_targets::link ! ( "mfsensorgroup.dll""system" fn MFCreateSensorProfileCollection ( ppsensorprofile : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFSensorProfileCollection>();
    MFCreateSensorProfileCollection(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateSensorStream<P0, P1>(streamid: u32, pattributes: P0, pmediatypecollection: P1) -> ::windows::core::Result<IMFSensorStream>
where
    P0: ::windows::core::IntoParam<IMFAttributes>,
    P1: ::windows::core::IntoParam<IMFCollection>,
{
    ::windows_targets::link ! ( "mfsensorgroup.dll""system" fn MFCreateSensorStream ( streamid : u32 , pattributes : * mut::core::ffi::c_void , pmediatypecollection : * mut::core::ffi::c_void , ppstream : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFSensorStream>();
    MFCreateSensorStream(streamid, pattributes.into_param().abi(), pmediatypecollection.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
#[inline]
pub unsafe fn MFCreateSequencerSegmentOffset(dwid: u32, hnsoffset: i64) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateSequencerSegmentOffset ( dwid : u32 , hnsoffset : i64 , pvarsegmentoffset : *mut super::super::System::Com::StructuredStorage:: PROPVARIANT ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<super::super::System::Com::StructuredStorage::PROPVARIANT>();
    MFCreateSequencerSegmentOffset(dwid, hnsoffset, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateSequencerSource<P0>(preserved: P0) -> ::windows::core::Result<IMFSequencerSource>
where
    P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateSequencerSource ( preserved : * mut::core::ffi::c_void , ppsequencersource : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFSequencerSource>();
    MFCreateSequencerSource(preserved.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateSimpleTypeHandler() -> ::windows::core::Result<IMFMediaTypeHandler> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateSimpleTypeHandler ( pphandler : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaTypeHandler>();
    MFCreateSimpleTypeHandler(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateSinkWriterFromMediaSink<P0, P1>(pmediasink: P0, pattributes: P1) -> ::windows::core::Result<IMFSinkWriter>
where
    P0: ::windows::core::IntoParam<IMFMediaSink>,
    P1: ::windows::core::IntoParam<IMFAttributes>,
{
    ::windows_targets::link ! ( "mfreadwrite.dll""system" fn MFCreateSinkWriterFromMediaSink ( pmediasink : * mut::core::ffi::c_void , pattributes : * mut::core::ffi::c_void , ppsinkwriter : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFSinkWriter>();
    MFCreateSinkWriterFromMediaSink(pmediasink.into_param().abi(), pattributes.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateSinkWriterFromURL<P0, P1, P2>(pwszoutputurl: P0, pbytestream: P1, pattributes: P2) -> ::windows::core::Result<IMFSinkWriter>
where
    P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    P1: ::windows::core::IntoParam<IMFByteStream>,
    P2: ::windows::core::IntoParam<IMFAttributes>,
{
    ::windows_targets::link ! ( "mfreadwrite.dll""system" fn MFCreateSinkWriterFromURL ( pwszoutputurl : ::windows::core::PCWSTR , pbytestream : * mut::core::ffi::c_void , pattributes : * mut::core::ffi::c_void , ppsinkwriter : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFSinkWriter>();
    MFCreateSinkWriterFromURL(pwszoutputurl.into_param().abi(), pbytestream.into_param().abi(), pattributes.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateSourceReaderFromByteStream<P0, P1>(pbytestream: P0, pattributes: P1) -> ::windows::core::Result<IMFSourceReader>
where
    P0: ::windows::core::IntoParam<IMFByteStream>,
    P1: ::windows::core::IntoParam<IMFAttributes>,
{
    ::windows_targets::link ! ( "mfreadwrite.dll""system" fn MFCreateSourceReaderFromByteStream ( pbytestream : * mut::core::ffi::c_void , pattributes : * mut::core::ffi::c_void , ppsourcereader : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFSourceReader>();
    MFCreateSourceReaderFromByteStream(pbytestream.into_param().abi(), pattributes.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateSourceReaderFromMediaSource<P0, P1>(pmediasource: P0, pattributes: P1) -> ::windows::core::Result<IMFSourceReader>
where
    P0: ::windows::core::IntoParam<IMFMediaSource>,
    P1: ::windows::core::IntoParam<IMFAttributes>,
{
    ::windows_targets::link ! ( "mfreadwrite.dll""system" fn MFCreateSourceReaderFromMediaSource ( pmediasource : * mut::core::ffi::c_void , pattributes : * mut::core::ffi::c_void , ppsourcereader : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFSourceReader>();
    MFCreateSourceReaderFromMediaSource(pmediasource.into_param().abi(), pattributes.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateSourceReaderFromURL<P0, P1>(pwszurl: P0, pattributes: P1) -> ::windows::core::Result<IMFSourceReader>
where
    P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    P1: ::windows::core::IntoParam<IMFAttributes>,
{
    ::windows_targets::link ! ( "mfreadwrite.dll""system" fn MFCreateSourceReaderFromURL ( pwszurl : ::windows::core::PCWSTR , pattributes : * mut::core::ffi::c_void , ppsourcereader : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFSourceReader>();
    MFCreateSourceReaderFromURL(pwszurl.into_param().abi(), pattributes.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateSourceResolver() -> ::windows::core::Result<IMFSourceResolver> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateSourceResolver ( ppisourceresolver : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFSourceResolver>();
    MFCreateSourceResolver(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateStandardQualityManager() -> ::windows::core::Result<IMFQualityManager> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateStandardQualityManager ( ppqualitymanager : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFQualityManager>();
    MFCreateStandardQualityManager(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateStreamDescriptor(dwstreamidentifier: u32, apmediatypes: &[::core::option::Option<IMFMediaType>]) -> ::windows::core::Result<IMFStreamDescriptor> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateStreamDescriptor ( dwstreamidentifier : u32 , cmediatypes : u32 , apmediatypes : *const * mut::core::ffi::c_void , ppdescriptor : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFStreamDescriptor>();
    MFCreateStreamDescriptor(dwstreamidentifier, apmediatypes.len() as _, ::core::mem::transmute(apmediatypes.as_ptr()), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_System_Com\"`*"]
#[cfg(feature = "Win32_System_Com")]
#[inline]
pub unsafe fn MFCreateStreamOnMFByteStream<P0>(pbytestream: P0) -> ::windows::core::Result<super::super::System::Com::IStream>
where
    P0: ::windows::core::IntoParam<IMFByteStream>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateStreamOnMFByteStream ( pbytestream : * mut::core::ffi::c_void , ppstream : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<super::super::System::Com::IStream>();
    MFCreateStreamOnMFByteStream(pbytestream.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateStreamOnMFByteStreamEx<P0>(pbytestream: P0, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFByteStream>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateStreamOnMFByteStreamEx ( pbytestream : * mut::core::ffi::c_void , riid : *const ::windows::core::GUID , ppv : *mut *mut ::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFCreateStreamOnMFByteStreamEx(pbytestream.into_param().abi(), riid, ppv).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateSystemTimeSource() -> ::windows::core::Result<IMFPresentationTimeSource> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateSystemTimeSource ( ppsystemtimesource : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFPresentationTimeSource>();
    MFCreateSystemTimeSource(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateTempFile(accessmode: MF_FILE_ACCESSMODE, openmode: MF_FILE_OPENMODE, fflags: MF_FILE_FLAGS) -> ::windows::core::Result<IMFByteStream> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateTempFile ( accessmode : MF_FILE_ACCESSMODE , openmode : MF_FILE_OPENMODE , fflags : MF_FILE_FLAGS , ppibytestream : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFByteStream>();
    MFCreateTempFile(accessmode, openmode, fflags, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateTopoLoader() -> ::windows::core::Result<IMFTopoLoader> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateTopoLoader ( ppobj : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFTopoLoader>();
    MFCreateTopoLoader(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateTopology() -> ::windows::core::Result<IMFTopology> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateTopology ( pptopo : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFTopology>();
    MFCreateTopology(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateTopologyNode(nodetype: MF_TOPOLOGY_TYPE) -> ::windows::core::Result<IMFTopologyNode> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateTopologyNode ( nodetype : MF_TOPOLOGY_TYPE , ppnode : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFTopologyNode>();
    MFCreateTopologyNode(nodetype, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateTrackedSample() -> ::windows::core::Result<IMFTrackedSample> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateTrackedSample ( ppmfsample : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFTrackedSample>();
    MFCreateTrackedSample(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateTranscodeProfile() -> ::windows::core::Result<IMFTranscodeProfile> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateTranscodeProfile ( pptranscodeprofile : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFTranscodeProfile>();
    MFCreateTranscodeProfile(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateTranscodeSinkActivate() -> ::windows::core::Result<IMFActivate> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateTranscodeSinkActivate ( ppactivate : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFActivate>();
    MFCreateTranscodeSinkActivate(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateTranscodeTopology<P0, P1, P2>(psrc: P0, pwszoutputfilepath: P1, pprofile: P2) -> ::windows::core::Result<IMFTopology>
where
    P0: ::windows::core::IntoParam<IMFMediaSource>,
    P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    P2: ::windows::core::IntoParam<IMFTranscodeProfile>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateTranscodeTopology ( psrc : * mut::core::ffi::c_void , pwszoutputfilepath : ::windows::core::PCWSTR , pprofile : * mut::core::ffi::c_void , pptranscodetopo : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFTopology>();
    MFCreateTranscodeTopology(psrc.into_param().abi(), pwszoutputfilepath.into_param().abi(), pprofile.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateTranscodeTopologyFromByteStream<P0, P1, P2>(psrc: P0, poutputstream: P1, pprofile: P2) -> ::windows::core::Result<IMFTopology>
where
    P0: ::windows::core::IntoParam<IMFMediaSource>,
    P1: ::windows::core::IntoParam<IMFByteStream>,
    P2: ::windows::core::IntoParam<IMFTranscodeProfile>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateTranscodeTopologyFromByteStream ( psrc : * mut::core::ffi::c_void , poutputstream : * mut::core::ffi::c_void , pprofile : * mut::core::ffi::c_void , pptranscodetopo : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFTopology>();
    MFCreateTranscodeTopologyFromByteStream(psrc.into_param().abi(), poutputstream.into_param().abi(), pprofile.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateTransformActivate() -> ::windows::core::Result<IMFActivate> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateTransformActivate ( ppactivate : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFActivate>();
    MFCreateTransformActivate(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MFCreateVideoMediaType(pvideoformat: *const MFVIDEOFORMAT) -> ::windows::core::Result<IMFVideoMediaType> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateVideoMediaType ( pvideoformat : *const MFVIDEOFORMAT , ppivideomediatype : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFVideoMediaType>();
    MFCreateVideoMediaType(pvideoformat, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Gdi\"`*"]
#[cfg(feature = "Win32_Graphics_Gdi")]
#[inline]
pub unsafe fn MFCreateVideoMediaTypeFromBitMapInfoHeader(pbmihbitmapinfoheader: *const super::super::Graphics::Gdi::BITMAPINFOHEADER, dwpixelaspectratiox: u32, dwpixelaspectratioy: u32, interlacemode: MFVideoInterlaceMode, videoflags: u64, qwframespersecondnumerator: u64, qwframesperseconddenominator: u64, dwmaxbitrate: u32) -> ::windows::core::Result<IMFVideoMediaType> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateVideoMediaTypeFromBitMapInfoHeader ( pbmihbitmapinfoheader : *const super::super::Graphics::Gdi:: BITMAPINFOHEADER , dwpixelaspectratiox : u32 , dwpixelaspectratioy : u32 , interlacemode : MFVideoInterlaceMode , videoflags : u64 , qwframespersecondnumerator : u64 , qwframesperseconddenominator : u64 , dwmaxbitrate : u32 , ppivideomediatype : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFVideoMediaType>();
    MFCreateVideoMediaTypeFromBitMapInfoHeader(pbmihbitmapinfoheader, dwpixelaspectratiox, dwpixelaspectratioy, interlacemode, videoflags, qwframespersecondnumerator, qwframesperseconddenominator, dwmaxbitrate, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Gdi\"`*"]
#[cfg(feature = "Win32_Graphics_Gdi")]
#[inline]
pub unsafe fn MFCreateVideoMediaTypeFromBitMapInfoHeaderEx(pbmihbitmapinfoheader: *const super::super::Graphics::Gdi::BITMAPINFOHEADER, cbbitmapinfoheader: u32, dwpixelaspectratiox: u32, dwpixelaspectratioy: u32, interlacemode: MFVideoInterlaceMode, videoflags: u64, dwframespersecondnumerator: u32, dwframesperseconddenominator: u32, dwmaxbitrate: u32) -> ::windows::core::Result<IMFVideoMediaType> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateVideoMediaTypeFromBitMapInfoHeaderEx ( pbmihbitmapinfoheader : *const super::super::Graphics::Gdi:: BITMAPINFOHEADER , cbbitmapinfoheader : u32 , dwpixelaspectratiox : u32 , dwpixelaspectratioy : u32 , interlacemode : MFVideoInterlaceMode , videoflags : u64 , dwframespersecondnumerator : u32 , dwframesperseconddenominator : u32 , dwmaxbitrate : u32 , ppivideomediatype : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFVideoMediaType>();
    MFCreateVideoMediaTypeFromBitMapInfoHeaderEx(pbmihbitmapinfoheader, cbbitmapinfoheader, dwpixelaspectratiox, dwpixelaspectratioy, interlacemode, videoflags, dwframespersecondnumerator, dwframesperseconddenominator, dwmaxbitrate, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateVideoMediaTypeFromSubtype(pamsubtype: *const ::windows::core::GUID) -> ::windows::core::Result<IMFVideoMediaType> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateVideoMediaTypeFromSubtype ( pamsubtype : *const ::windows::core::GUID , ppivideomediatype : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFVideoMediaType>();
    MFCreateVideoMediaTypeFromSubtype(pamsubtype, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateVideoMixer<P0>(powner: P0, riiddevice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
{
    ::windows_targets::link ! ( "evr.dll""system" fn MFCreateVideoMixer ( powner : * mut::core::ffi::c_void , riiddevice : *const ::windows::core::GUID , riid : *const ::windows::core::GUID , ppv : *mut *mut ::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFCreateVideoMixer(powner.into_param().abi(), riiddevice, riid, ppv).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateVideoMixerAndPresenter<P0, P1>(pmixerowner: P0, ppresenterowner: P1, riidmixer: *const ::windows::core::GUID, ppvvideomixer: *mut *mut ::core::ffi::c_void, riidpresenter: *const ::windows::core::GUID, ppvvideopresenter: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
{
    ::windows_targets::link ! ( "evr.dll""system" fn MFCreateVideoMixerAndPresenter ( pmixerowner : * mut::core::ffi::c_void , ppresenterowner : * mut::core::ffi::c_void , riidmixer : *const ::windows::core::GUID , ppvvideomixer : *mut *mut ::core::ffi::c_void , riidpresenter : *const ::windows::core::GUID , ppvvideopresenter : *mut *mut ::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFCreateVideoMixerAndPresenter(pmixerowner.into_param().abi(), ppresenterowner.into_param().abi(), riidmixer, ppvvideomixer, riidpresenter, ppvvideopresenter).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateVideoPresenter<P0>(powner: P0, riiddevice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvideopresenter: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
{
    ::windows_targets::link ! ( "evr.dll""system" fn MFCreateVideoPresenter ( powner : * mut::core::ffi::c_void , riiddevice : *const ::windows::core::GUID , riid : *const ::windows::core::GUID , ppvideopresenter : *mut *mut ::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFCreateVideoPresenter(powner.into_param().abi(), riiddevice, riid, ppvideopresenter).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateVideoRenderer(riidrenderer: *const ::windows::core::GUID, ppvideorenderer: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateVideoRenderer ( riidrenderer : *const ::windows::core::GUID , ppvideorenderer : *mut *mut ::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFCreateVideoRenderer(riidrenderer, ppvideorenderer).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MFCreateVideoRendererActivate<P0>(hwndvideo: P0) -> ::windows::core::Result<IMFActivate>
where
    P0: ::windows::core::IntoParam<super::super::Foundation::HWND>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateVideoRendererActivate ( hwndvideo : super::super::Foundation:: HWND , ppactivate : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFActivate>();
    MFCreateVideoRendererActivate(hwndvideo.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateVideoSampleAllocator(riid: *const ::windows::core::GUID, ppsampleallocator: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "evr.dll""system" fn MFCreateVideoSampleAllocator ( riid : *const ::windows::core::GUID , ppsampleallocator : *mut *mut ::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFCreateVideoSampleAllocator(riid, ppsampleallocator).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateVideoSampleAllocatorEx(riid: *const ::windows::core::GUID, ppsampleallocator: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateVideoSampleAllocatorEx ( riid : *const ::windows::core::GUID , ppsampleallocator : *mut *mut ::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFCreateVideoSampleAllocatorEx(riid, ppsampleallocator).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateVideoSampleFromSurface<P0>(punksurface: P0) -> ::windows::core::Result<IMFSample>
where
    P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
{
    ::windows_targets::link ! ( "evr.dll""system" fn MFCreateVideoSampleFromSurface ( punksurface : * mut::core::ffi::c_void , ppsample : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFSample>();
    MFCreateVideoSampleFromSurface(punksurface.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateVirtualCamera<P0, P1>(r#type: MFVirtualCameraType, lifetime: MFVirtualCameraLifetime, access: MFVirtualCameraAccess, friendlyname: P0, sourceid: P1, categories: ::core::option::Option<&[::windows::core::GUID]>) -> ::windows::core::Result<IMFVirtualCamera>
where
    P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
{
    ::windows_targets::link ! ( "mfsensorgroup.dll""system" fn MFCreateVirtualCamera ( r#type : MFVirtualCameraType , lifetime : MFVirtualCameraLifetime , access : MFVirtualCameraAccess , friendlyname : ::windows::core::PCWSTR , sourceid : ::windows::core::PCWSTR , categories : *const ::windows::core::GUID , categorycount : u32 , virtualcamera : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFVirtualCamera>();
    MFCreateVirtualCamera(r#type, lifetime, access, friendlyname.into_param().abi(), sourceid.into_param().abi(), ::core::mem::transmute(categories.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr())), categories.as_deref().map_or(0, |slice| slice.len() as _), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateWAVEMediaSink<P0, P1>(ptargetbytestream: P0, paudiomediatype: P1) -> ::windows::core::Result<IMFMediaSink>
where
    P0: ::windows::core::IntoParam<IMFByteStream>,
    P1: ::windows::core::IntoParam<IMFMediaType>,
{
    ::windows_targets::link ! ( "mfsrcsnk.dll""system" fn MFCreateWAVEMediaSink ( ptargetbytestream : * mut::core::ffi::c_void , paudiomediatype : * mut::core::ffi::c_void , ppmediasink : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaSink>();
    MFCreateWAVEMediaSink(ptargetbytestream.into_param().abi(), paudiomediatype.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFCreateWICBitmapBuffer<P0>(riid: *const ::windows::core::GUID, punksurface: P0) -> ::windows::core::Result<IMFMediaBuffer>
where
    P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateWICBitmapBuffer ( riid : *const ::windows::core::GUID , punksurface : * mut::core::ffi::c_void , ppbuffer : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaBuffer>();
    MFCreateWICBitmapBuffer(riid, punksurface.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_UI_Shell_PropertiesSystem\"`*"]
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
#[inline]
pub unsafe fn MFCreateWMAEncoderActivate<P0, P1>(pmediatype: P0, pencodingconfigurationproperties: P1) -> ::windows::core::Result<IMFActivate>
where
    P0: ::windows::core::IntoParam<IMFMediaType>,
    P1: ::windows::core::IntoParam<super::super::UI::Shell::PropertiesSystem::IPropertyStore>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateWMAEncoderActivate ( pmediatype : * mut::core::ffi::c_void , pencodingconfigurationproperties : * mut::core::ffi::c_void , ppactivate : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFActivate>();
    MFCreateWMAEncoderActivate(pmediatype.into_param().abi(), pencodingconfigurationproperties.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_UI_Shell_PropertiesSystem\"`*"]
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
#[inline]
pub unsafe fn MFCreateWMVEncoderActivate<P0, P1>(pmediatype: P0, pencodingconfigurationproperties: P1) -> ::windows::core::Result<IMFActivate>
where
    P0: ::windows::core::IntoParam<IMFMediaType>,
    P1: ::windows::core::IntoParam<super::super::UI::Shell::PropertiesSystem::IPropertyStore>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFCreateWMVEncoderActivate ( pmediatype : * mut::core::ffi::c_void , pencodingconfigurationproperties : * mut::core::ffi::c_void , ppactivate : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFActivate>();
    MFCreateWMVEncoderActivate(pmediatype.into_param().abi(), pencodingconfigurationproperties.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Media_Audio\"`*"]
#[cfg(feature = "Win32_Media_Audio")]
#[inline]
pub unsafe fn MFCreateWaveFormatExFromMFMediaType<P0>(pmftype: P0, ppwf: *mut *mut super::Audio::WAVEFORMATEX, pcbsize: ::core::option::Option<*mut u32>, flags: u32) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFMediaType>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFCreateWaveFormatExFromMFMediaType ( pmftype : * mut::core::ffi::c_void , ppwf : *mut *mut super::Audio:: WAVEFORMATEX , pcbsize : *mut u32 , flags : u32 ) -> ::windows::core::HRESULT );
    MFCreateWaveFormatExFromMFMediaType(pmftype.into_param().abi(), ppwf, ::core::mem::transmute(pcbsize.unwrap_or(::std::ptr::null_mut())), flags).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_System_Com\"`*"]
#[cfg(feature = "Win32_System_Com")]
#[inline]
pub unsafe fn MFDeserializeAttributesFromStream<P0, P1>(pattr: P0, dwoptions: u32, pstm: P1) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFAttributes>,
    P1: ::windows::core::IntoParam<super::super::System::Com::IStream>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFDeserializeAttributesFromStream ( pattr : * mut::core::ffi::c_void , dwoptions : u32 , pstm : * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFDeserializeAttributesFromStream(pattr.into_param().abi(), dwoptions, pstm.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFDeserializePresentationDescriptor(pbdata: &[u8]) -> ::windows::core::Result<IMFPresentationDescriptor> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFDeserializePresentationDescriptor ( cbdata : u32 , pbdata : *const u8 , pppd : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFPresentationDescriptor>();
    MFDeserializePresentationDescriptor(pbdata.len() as _, ::core::mem::transmute(pbdata.as_ptr()), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFEndCreateFile<P0>(presult: P0) -> ::windows::core::Result<IMFByteStream>
where
    P0: ::windows::core::IntoParam<IMFAsyncResult>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFEndCreateFile ( presult : * mut::core::ffi::c_void , ppfile : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFByteStream>();
    MFEndCreateFile(presult.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFEndRegisterWorkQueueWithMMCSS<P0>(presult: P0) -> ::windows::core::Result<u32>
where
    P0: ::windows::core::IntoParam<IMFAsyncResult>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFEndRegisterWorkQueueWithMMCSS ( presult : * mut::core::ffi::c_void , pdwtaskid : *mut u32 ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<u32>();
    MFEndRegisterWorkQueueWithMMCSS(presult.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFEndUnregisterWorkQueueWithMMCSS<P0>(presult: P0) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFAsyncResult>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFEndUnregisterWorkQueueWithMMCSS ( presult : * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFEndUnregisterWorkQueueWithMMCSS(presult.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFEnumDeviceSources<P0>(pattributes: P0, pppsourceactivate: *mut *mut ::core::option::Option<IMFActivate>, pcsourceactivate: *mut u32) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFAttributes>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFEnumDeviceSources ( pattributes : * mut::core::ffi::c_void , pppsourceactivate : *mut *mut ::core::option::Option < IMFActivate > , pcsourceactivate : *mut u32 ) -> ::windows::core::HRESULT );
    MFEnumDeviceSources(pattributes.into_param().abi(), pppsourceactivate, pcsourceactivate).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFFrameRateToAverageTimePerFrame(unnumerator: u32, undenominator: u32) -> ::windows::core::Result<u64> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFFrameRateToAverageTimePerFrame ( unnumerator : u32 , undenominator : u32 , punaveragetimeperframe : *mut u64 ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<u64>();
    MFFrameRateToAverageTimePerFrame(unnumerator, undenominator, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFGetAttributesAsBlob<P0>(pattributes: P0, pbuf: &mut [u8]) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFAttributes>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFGetAttributesAsBlob ( pattributes : * mut::core::ffi::c_void , pbuf : *mut u8 , cbbufsize : u32 ) -> ::windows::core::HRESULT );
    MFGetAttributesAsBlob(pattributes.into_param().abi(), ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFGetAttributesAsBlobSize<P0>(pattributes: P0) -> ::windows::core::Result<u32>
where
    P0: ::windows::core::IntoParam<IMFAttributes>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFGetAttributesAsBlobSize ( pattributes : * mut::core::ffi::c_void , pcbbufsize : *mut u32 ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<u32>();
    MFGetAttributesAsBlobSize(pattributes.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFGetContentProtectionSystemCLSID(guidprotectionsystemid: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::GUID> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFGetContentProtectionSystemCLSID ( guidprotectionsystemid : *const ::windows::core::GUID , pclsid : *mut ::windows::core::GUID ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
    MFGetContentProtectionSystemCLSID(guidprotectionsystemid, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFGetLocalId(verifier: &[u8]) -> ::windows::core::Result<::windows::core::PWSTR> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFGetLocalId ( verifier : *const u8 , size : u32 , id : *mut ::windows::core::PWSTR ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<::windows::core::PWSTR>();
    MFGetLocalId(::core::mem::transmute(verifier.as_ptr()), verifier.len() as _, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFGetMFTMerit<P0>(pmft: P0, verifier: &[u8]) -> ::windows::core::Result<u32>
where
    P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFGetMFTMerit ( pmft : * mut::core::ffi::c_void , cbverifier : u32 , verifier : *const u8 , merit : *mut u32 ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<u32>();
    MFGetMFTMerit(pmft.into_param().abi(), verifier.len() as _, ::core::mem::transmute(verifier.as_ptr()), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFGetPlaneSize(format: u32, dwwidth: u32, dwheight: u32) -> ::windows::core::Result<u32> {
    ::windows_targets::link ! ( "evr.dll""system" fn MFGetPlaneSize ( format : u32 , dwwidth : u32 , dwheight : u32 , pdwplanesize : *mut u32 ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<u32>();
    MFGetPlaneSize(format, dwwidth, dwheight, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFGetPluginControl() -> ::windows::core::Result<IMFPluginControl> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFGetPluginControl ( ppplugincontrol : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFPluginControl>();
    MFGetPluginControl(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFGetService<P0>(punkobject: P0, guidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFGetService ( punkobject : * mut::core::ffi::c_void , guidservice : *const ::windows::core::GUID , riid : *const ::windows::core::GUID , ppvobject : *mut *mut ::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFGetService(punkobject.into_param().abi(), guidservice, riid, ppvobject).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFGetStrideForBitmapInfoHeader(format: u32, dwwidth: u32) -> ::windows::core::Result<i32> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFGetStrideForBitmapInfoHeader ( format : u32 , dwwidth : u32 , pstride : *mut i32 ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<i32>();
    MFGetStrideForBitmapInfoHeader(format, dwwidth, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
#[inline]
pub unsafe fn MFGetSupportedMimeTypes() -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFGetSupportedMimeTypes ( ppropvarmimetypearray : *mut super::super::System::Com::StructuredStorage:: PROPVARIANT ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<super::super::System::Com::StructuredStorage::PROPVARIANT>();
    MFGetSupportedMimeTypes(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
#[inline]
pub unsafe fn MFGetSupportedSchemes() -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFGetSupportedSchemes ( ppropvarschemearray : *mut super::super::System::Com::StructuredStorage:: PROPVARIANT ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<super::super::System::Com::StructuredStorage::PROPVARIANT>();
    MFGetSupportedSchemes(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFGetSystemId() -> ::windows::core::Result<IMFSystemId> {
    ::windows_targets::link ! ( "mf.dll""system" fn MFGetSystemId ( ppid : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFSystemId>();
    MFGetSystemId(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFGetSystemTime() -> i64 {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFGetSystemTime ( ) -> i64 );
    MFGetSystemTime()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFGetTimerPeriodicity() -> ::windows::core::Result<u32> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFGetTimerPeriodicity ( periodicity : *mut u32 ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<u32>();
    MFGetTimerPeriodicity(&mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MFGetTopoNodeCurrentType<P0, P1>(pnode: P0, dwstreamindex: u32, foutput: P1) -> ::windows::core::Result<IMFMediaType>
where
    P0: ::windows::core::IntoParam<IMFTopologyNode>,
    P1: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFGetTopoNodeCurrentType ( pnode : * mut::core::ffi::c_void , dwstreamindex : u32 , foutput : super::super::Foundation:: BOOL , pptype : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
    MFGetTopoNodeCurrentType(pnode.into_param().abi(), dwstreamindex, foutput.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MFGetUncompressedVideoFormat(pvideoformat: *const MFVIDEOFORMAT) -> u32 {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFGetUncompressedVideoFormat ( pvideoformat : *const MFVIDEOFORMAT ) -> u32 );
    MFGetUncompressedVideoFormat(pvideoformat)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFGetWorkQueueMMCSSClass(dwworkqueueid: u32, pwszclass: ::windows::core::PWSTR, pcchclass: *mut u32) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFGetWorkQueueMMCSSClass ( dwworkqueueid : u32 , pwszclass : ::windows::core::PWSTR , pcchclass : *mut u32 ) -> ::windows::core::HRESULT );
    MFGetWorkQueueMMCSSClass(dwworkqueueid, ::core::mem::transmute(pwszclass), pcchclass).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFGetWorkQueueMMCSSPriority(dwworkqueueid: u32) -> ::windows::core::Result<i32> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFGetWorkQueueMMCSSPriority ( dwworkqueueid : u32 , lpriority : *mut i32 ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<i32>();
    MFGetWorkQueueMMCSSPriority(dwworkqueueid, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFGetWorkQueueMMCSSTaskId(dwworkqueueid: u32) -> ::windows::core::Result<u32> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFGetWorkQueueMMCSSTaskId ( dwworkqueueid : u32 , pdwtaskid : *mut u32 ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<u32>();
    MFGetWorkQueueMMCSSTaskId(dwworkqueueid, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFHeapAlloc<P0>(nsize: usize, dwflags: u32, pszfile: P0, line: i32, eat: EAllocationType) -> *mut ::core::ffi::c_void
where
    P0: ::windows::core::IntoParam<::windows::core::PCSTR>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFHeapAlloc ( nsize : usize , dwflags : u32 , pszfile : ::windows::core::PCSTR , line : i32 , eat : EAllocationType ) -> *mut ::core::ffi::c_void );
    MFHeapAlloc(nsize, dwflags, pszfile.into_param().abi(), line, eat)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFHeapFree(pv: *mut ::core::ffi::c_void) {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFHeapFree ( pv : *mut ::core::ffi::c_void ) -> ( ) );
    MFHeapFree(pv)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MFInitAMMediaTypeFromMFMediaType<P0>(pmftype: P0, guidformatblocktype: ::windows::core::GUID, pamtype: *mut AM_MEDIA_TYPE) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFMediaType>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFInitAMMediaTypeFromMFMediaType ( pmftype : * mut::core::ffi::c_void , guidformatblocktype : ::windows::core::GUID , pamtype : *mut AM_MEDIA_TYPE ) -> ::windows::core::HRESULT );
    MFInitAMMediaTypeFromMFMediaType(pmftype.into_param().abi(), ::core::mem::transmute(guidformatblocktype), pamtype).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFInitAttributesFromBlob<P0>(pattributes: P0, pbuf: &[u8]) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFAttributes>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFInitAttributesFromBlob ( pattributes : * mut::core::ffi::c_void , pbuf : *const u8 , cbbufsize : u32 ) -> ::windows::core::HRESULT );
    MFInitAttributesFromBlob(pattributes.into_param().abi(), ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MFInitMediaTypeFromAMMediaType<P0>(pmftype: P0, pamtype: *const AM_MEDIA_TYPE) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFMediaType>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFInitMediaTypeFromAMMediaType ( pmftype : * mut::core::ffi::c_void , pamtype : *const AM_MEDIA_TYPE ) -> ::windows::core::HRESULT );
    MFInitMediaTypeFromAMMediaType(pmftype.into_param().abi(), pamtype).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MFInitMediaTypeFromMFVideoFormat<P0>(pmftype: P0, pmfvf: *const MFVIDEOFORMAT, cbbufsize: u32) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFMediaType>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFInitMediaTypeFromMFVideoFormat ( pmftype : * mut::core::ffi::c_void , pmfvf : *const MFVIDEOFORMAT , cbbufsize : u32 ) -> ::windows::core::HRESULT );
    MFInitMediaTypeFromMFVideoFormat(pmftype.into_param().abi(), pmfvf, cbbufsize).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Gdi\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
#[inline]
pub unsafe fn MFInitMediaTypeFromMPEG1VideoInfo<P0>(pmftype: P0, pmp1vi: *const MPEG1VIDEOINFO, cbbufsize: u32, psubtype: ::core::option::Option<*const ::windows::core::GUID>) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFMediaType>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFInitMediaTypeFromMPEG1VideoInfo ( pmftype : * mut::core::ffi::c_void , pmp1vi : *const MPEG1VIDEOINFO , cbbufsize : u32 , psubtype : *const ::windows::core::GUID ) -> ::windows::core::HRESULT );
    MFInitMediaTypeFromMPEG1VideoInfo(pmftype.into_param().abi(), pmp1vi, cbbufsize, ::core::mem::transmute(psubtype.unwrap_or(::std::ptr::null()))).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Gdi\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
#[inline]
pub unsafe fn MFInitMediaTypeFromMPEG2VideoInfo<P0>(pmftype: P0, pmp2vi: *const MPEG2VIDEOINFO, cbbufsize: u32, psubtype: ::core::option::Option<*const ::windows::core::GUID>) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFMediaType>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFInitMediaTypeFromMPEG2VideoInfo ( pmftype : * mut::core::ffi::c_void , pmp2vi : *const MPEG2VIDEOINFO , cbbufsize : u32 , psubtype : *const ::windows::core::GUID ) -> ::windows::core::HRESULT );
    MFInitMediaTypeFromMPEG2VideoInfo(pmftype.into_param().abi(), pmp2vi, cbbufsize, ::core::mem::transmute(psubtype.unwrap_or(::std::ptr::null()))).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Gdi\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
#[inline]
pub unsafe fn MFInitMediaTypeFromVideoInfoHeader<P0>(pmftype: P0, pvih: *const VIDEOINFOHEADER, cbbufsize: u32, psubtype: ::core::option::Option<*const ::windows::core::GUID>) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFMediaType>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFInitMediaTypeFromVideoInfoHeader ( pmftype : * mut::core::ffi::c_void , pvih : *const VIDEOINFOHEADER , cbbufsize : u32 , psubtype : *const ::windows::core::GUID ) -> ::windows::core::HRESULT );
    MFInitMediaTypeFromVideoInfoHeader(pmftype.into_param().abi(), pvih, cbbufsize, ::core::mem::transmute(psubtype.unwrap_or(::std::ptr::null()))).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Gdi\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
#[inline]
pub unsafe fn MFInitMediaTypeFromVideoInfoHeader2<P0>(pmftype: P0, pvih2: *const VIDEOINFOHEADER2, cbbufsize: u32, psubtype: ::core::option::Option<*const ::windows::core::GUID>) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFMediaType>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFInitMediaTypeFromVideoInfoHeader2 ( pmftype : * mut::core::ffi::c_void , pvih2 : *const VIDEOINFOHEADER2 , cbbufsize : u32 , psubtype : *const ::windows::core::GUID ) -> ::windows::core::HRESULT );
    MFInitMediaTypeFromVideoInfoHeader2(pmftype.into_param().abi(), pvih2, cbbufsize, ::core::mem::transmute(psubtype.unwrap_or(::std::ptr::null()))).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Media_Audio\"`*"]
#[cfg(feature = "Win32_Media_Audio")]
#[inline]
pub unsafe fn MFInitMediaTypeFromWaveFormatEx<P0>(pmftype: P0, pwaveformat: *const super::Audio::WAVEFORMATEX, cbbufsize: u32) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFMediaType>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFInitMediaTypeFromWaveFormatEx ( pmftype : * mut::core::ffi::c_void , pwaveformat : *const super::Audio:: WAVEFORMATEX , cbbufsize : u32 ) -> ::windows::core::HRESULT );
    MFInitMediaTypeFromWaveFormatEx(pmftype.into_param().abi(), pwaveformat, cbbufsize).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MFInitVideoFormat(pvideoformat: *const MFVIDEOFORMAT, r#type: MFStandardVideoFormat) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFInitVideoFormat ( pvideoformat : *const MFVIDEOFORMAT , r#type : MFStandardVideoFormat ) -> ::windows::core::HRESULT );
    MFInitVideoFormat(pvideoformat, r#type).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MFInitVideoFormat_RGB(pvideoformat: *const MFVIDEOFORMAT, dwwidth: u32, dwheight: u32, d3dfmt: u32) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFInitVideoFormat_RGB ( pvideoformat : *const MFVIDEOFORMAT , dwwidth : u32 , dwheight : u32 , d3dfmt : u32 ) -> ::windows::core::HRESULT );
    MFInitVideoFormat_RGB(pvideoformat, dwwidth, dwheight, d3dfmt).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFInvokeCallback<P0>(pasyncresult: P0) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFAsyncResult>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFInvokeCallback ( pasyncresult : * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFInvokeCallback(pasyncresult.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MFIsContentProtectionDeviceSupported(protectionsystemid: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::Foundation::BOOL> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFIsContentProtectionDeviceSupported ( protectionsystemid : *const ::windows::core::GUID , issupported : *mut super::super::Foundation:: BOOL ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
    MFIsContentProtectionDeviceSupported(protectionsystemid, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MFIsFormatYUV(format: u32) -> super::super::Foundation::BOOL {
    ::windows_targets::link ! ( "evr.dll""system" fn MFIsFormatYUV ( format : u32 ) -> super::super::Foundation:: BOOL );
    MFIsFormatYUV(format)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MFIsVirtualCameraTypeSupported(r#type: MFVirtualCameraType) -> ::windows::core::Result<super::super::Foundation::BOOL> {
    ::windows_targets::link ! ( "mfsensorgroup.dll""system" fn MFIsVirtualCameraTypeSupported ( r#type : MFVirtualCameraType , supported : *mut super::super::Foundation:: BOOL ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
    MFIsVirtualCameraTypeSupported(r#type, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFLoadSignedLibrary<P0>(pszname: P0) -> ::windows::core::Result<IMFSignedLibrary>
where
    P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFLoadSignedLibrary ( pszname : ::windows::core::PCWSTR , pplib : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFSignedLibrary>();
    MFLoadSignedLibrary(pszname.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFLockDXGIDeviceManager(presettoken: ::core::option::Option<*mut u32>, ppmanager: *mut ::core::option::Option<IMFDXGIDeviceManager>) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFLockDXGIDeviceManager ( presettoken : *mut u32 , ppmanager : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFLockDXGIDeviceManager(::core::mem::transmute(presettoken.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(ppmanager)).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFLockPlatform() -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFLockPlatform ( ) -> ::windows::core::HRESULT );
    MFLockPlatform().ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFLockSharedWorkQueue<P0>(wszclass: P0, basepriority: i32, pdwtaskid: *mut u32, pid: *mut u32) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFLockSharedWorkQueue ( wszclass : ::windows::core::PCWSTR , basepriority : i32 , pdwtaskid : *mut u32 , pid : *mut u32 ) -> ::windows::core::HRESULT );
    MFLockSharedWorkQueue(wszclass.into_param().abi(), basepriority, pdwtaskid, pid).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFLockWorkQueue(dwworkqueue: u32) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFLockWorkQueue ( dwworkqueue : u32 ) -> ::windows::core::HRESULT );
    MFLockWorkQueue(dwworkqueue).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
#[inline]
pub unsafe fn MFMapDX9FormatToDXGIFormat(dx9: u32) -> super::super::Graphics::Dxgi::Common::DXGI_FORMAT {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFMapDX9FormatToDXGIFormat ( dx9 : u32 ) -> super::super::Graphics::Dxgi::Common:: DXGI_FORMAT );
    MFMapDX9FormatToDXGIFormat(dx9)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
#[inline]
pub unsafe fn MFMapDXGIFormatToDX9Format(dx11: super::super::Graphics::Dxgi::Common::DXGI_FORMAT) -> u32 {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFMapDXGIFormatToDX9Format ( dx11 : super::super::Graphics::Dxgi::Common:: DXGI_FORMAT ) -> u32 );
    MFMapDXGIFormatToDX9Format(dx11)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MFPCreateMediaPlayer<P0, P1, P2, P3>(pwszurl: P0, fstartplayback: P1, creationoptions: MFP_CREATION_OPTIONS, pcallback: P2, hwnd: P3, ppmediaplayer: ::core::option::Option<*mut ::core::option::Option<IMFPMediaPlayer>>) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    P1: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    P2: ::windows::core::IntoParam<IMFPMediaPlayerCallback>,
    P3: ::windows::core::IntoParam<super::super::Foundation::HWND>,
{
    ::windows_targets::link ! ( "mfplay.dll""system" fn MFPCreateMediaPlayer ( pwszurl : ::windows::core::PCWSTR , fstartplayback : super::super::Foundation:: BOOL , creationoptions : MFP_CREATION_OPTIONS , pcallback : * mut::core::ffi::c_void , hwnd : super::super::Foundation:: HWND , ppmediaplayer : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFPCreateMediaPlayer(pwszurl.into_param().abi(), fstartplayback.into_param().abi(), creationoptions, pcallback.into_param().abi(), hwnd.into_param().abi(), ::core::mem::transmute(ppmediaplayer.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MFPutWaitingWorkItem<P0, P1>(hevent: P0, priority: i32, presult: P1, pkey: ::core::option::Option<*mut u64>) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<super::super::Foundation::HANDLE>,
    P1: ::windows::core::IntoParam<IMFAsyncResult>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFPutWaitingWorkItem ( hevent : super::super::Foundation:: HANDLE , priority : i32 , presult : * mut::core::ffi::c_void , pkey : *mut u64 ) -> ::windows::core::HRESULT );
    MFPutWaitingWorkItem(hevent.into_param().abi(), priority, presult.into_param().abi(), ::core::mem::transmute(pkey.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFPutWorkItem<P0, P1>(dwqueue: u32, pcallback: P0, pstate: P1) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFAsyncCallback>,
    P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFPutWorkItem ( dwqueue : u32 , pcallback : * mut::core::ffi::c_void , pstate : * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFPutWorkItem(dwqueue, pcallback.into_param().abi(), pstate.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFPutWorkItem2<P0, P1>(dwqueue: u32, priority: i32, pcallback: P0, pstate: P1) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFAsyncCallback>,
    P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFPutWorkItem2 ( dwqueue : u32 , priority : i32 , pcallback : * mut::core::ffi::c_void , pstate : * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFPutWorkItem2(dwqueue, priority, pcallback.into_param().abi(), pstate.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFPutWorkItemEx<P0>(dwqueue: u32, presult: P0) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFAsyncResult>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFPutWorkItemEx ( dwqueue : u32 , presult : * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFPutWorkItemEx(dwqueue, presult.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFPutWorkItemEx2<P0>(dwqueue: u32, priority: i32, presult: P0) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFAsyncResult>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFPutWorkItemEx2 ( dwqueue : u32 , priority : i32 , presult : * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFPutWorkItemEx2(dwqueue, priority, presult.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFRegisterLocalByteStreamHandler<P0, P1, P2>(szfileextension: P0, szmimetype: P1, pactivate: P2) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    P2: ::windows::core::IntoParam<IMFActivate>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFRegisterLocalByteStreamHandler ( szfileextension : ::windows::core::PCWSTR , szmimetype : ::windows::core::PCWSTR , pactivate : * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFRegisterLocalByteStreamHandler(szfileextension.into_param().abi(), szmimetype.into_param().abi(), pactivate.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFRegisterLocalSchemeHandler<P0, P1>(szscheme: P0, pactivate: P1) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    P1: ::windows::core::IntoParam<IMFActivate>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFRegisterLocalSchemeHandler ( szscheme : ::windows::core::PCWSTR , pactivate : * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFRegisterLocalSchemeHandler(szscheme.into_param().abi(), pactivate.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFRegisterPlatformWithMMCSS<P0>(wszclass: P0, pdwtaskid: *mut u32, lpriority: i32) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFRegisterPlatformWithMMCSS ( wszclass : ::windows::core::PCWSTR , pdwtaskid : *mut u32 , lpriority : i32 ) -> ::windows::core::HRESULT );
    MFRegisterPlatformWithMMCSS(wszclass.into_param().abi(), pdwtaskid, lpriority).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFRemovePeriodicCallback(dwkey: u32) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFRemovePeriodicCallback ( dwkey : u32 ) -> ::windows::core::HRESULT );
    MFRemovePeriodicCallback(dwkey).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFRequireProtectedEnvironment<P0>(ppresentationdescriptor: P0) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFPresentationDescriptor>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFRequireProtectedEnvironment ( ppresentationdescriptor : * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFRequireProtectedEnvironment(ppresentationdescriptor.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFScheduleWorkItem<P0, P1>(pcallback: P0, pstate: P1, timeout: i64, pkey: ::core::option::Option<*mut u64>) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFAsyncCallback>,
    P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFScheduleWorkItem ( pcallback : * mut::core::ffi::c_void , pstate : * mut::core::ffi::c_void , timeout : i64 , pkey : *mut u64 ) -> ::windows::core::HRESULT );
    MFScheduleWorkItem(pcallback.into_param().abi(), pstate.into_param().abi(), timeout, ::core::mem::transmute(pkey.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFScheduleWorkItemEx<P0>(presult: P0, timeout: i64, pkey: ::core::option::Option<*mut u64>) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFAsyncResult>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFScheduleWorkItemEx ( presult : * mut::core::ffi::c_void , timeout : i64 , pkey : *mut u64 ) -> ::windows::core::HRESULT );
    MFScheduleWorkItemEx(presult.into_param().abi(), timeout, ::core::mem::transmute(pkey.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_System_Com\"`*"]
#[cfg(feature = "Win32_System_Com")]
#[inline]
pub unsafe fn MFSerializeAttributesToStream<P0, P1>(pattr: P0, dwoptions: u32, pstm: P1) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFAttributes>,
    P1: ::windows::core::IntoParam<super::super::System::Com::IStream>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFSerializeAttributesToStream ( pattr : * mut::core::ffi::c_void , dwoptions : u32 , pstm : * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFSerializeAttributesToStream(pattr.into_param().abi(), dwoptions, pstm.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFSerializePresentationDescriptor<P0>(ppd: P0, pcbdata: *mut u32, ppbdata: *mut *mut u8) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFPresentationDescriptor>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFSerializePresentationDescriptor ( ppd : * mut::core::ffi::c_void , pcbdata : *mut u32 , ppbdata : *mut *mut u8 ) -> ::windows::core::HRESULT );
    MFSerializePresentationDescriptor(ppd.into_param().abi(), pcbdata, ppbdata).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFShutdown() -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFShutdown ( ) -> ::windows::core::HRESULT );
    MFShutdown().ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFShutdownObject<P0>(punk: P0) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFShutdownObject ( punk : * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFShutdownObject(punk.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFSplitSample<P0>(psample: P0, poutputsamples: &mut [::core::option::Option<IMFSample>], pdwoutputsamplecount: *mut u32) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFSample>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFSplitSample ( psample : * mut::core::ffi::c_void , poutputsamples : *mut * mut::core::ffi::c_void , dwoutputsamplemaxcount : u32 , pdwoutputsamplecount : *mut u32 ) -> ::windows::core::HRESULT );
    MFSplitSample(psample.into_param().abi(), ::core::mem::transmute(poutputsamples.as_ptr()), poutputsamples.len() as _, pdwoutputsamplecount).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFStartup(version: u32, dwflags: u32) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFStartup ( version : u32 , dwflags : u32 ) -> ::windows::core::HRESULT );
    MFStartup(version, dwflags).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFTEnum<P0>(guidcategory: ::windows::core::GUID, flags: u32, pinputtype: ::core::option::Option<*const MFT_REGISTER_TYPE_INFO>, poutputtype: ::core::option::Option<*const MFT_REGISTER_TYPE_INFO>, pattributes: P0, ppclsidmft: *mut *mut ::windows::core::GUID, pcmfts: *mut u32) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFAttributes>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFTEnum ( guidcategory : ::windows::core::GUID , flags : u32 , pinputtype : *const MFT_REGISTER_TYPE_INFO , poutputtype : *const MFT_REGISTER_TYPE_INFO , pattributes : * mut::core::ffi::c_void , ppclsidmft : *mut *mut ::windows::core::GUID , pcmfts : *mut u32 ) -> ::windows::core::HRESULT );
    MFTEnum(::core::mem::transmute(guidcategory), flags, ::core::mem::transmute(pinputtype.unwrap_or(::std::ptr::null())), ::core::mem::transmute(poutputtype.unwrap_or(::std::ptr::null())), pattributes.into_param().abi(), ppclsidmft, pcmfts).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFTEnum2<P0>(guidcategory: ::windows::core::GUID, flags: MFT_ENUM_FLAG, pinputtype: ::core::option::Option<*const MFT_REGISTER_TYPE_INFO>, poutputtype: ::core::option::Option<*const MFT_REGISTER_TYPE_INFO>, pattributes: P0, pppmftactivate: *mut *mut ::core::option::Option<IMFActivate>, pnummftactivate: *mut u32) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<IMFAttributes>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFTEnum2 ( guidcategory : ::windows::core::GUID , flags : MFT_ENUM_FLAG , pinputtype : *const MFT_REGISTER_TYPE_INFO , poutputtype : *const MFT_REGISTER_TYPE_INFO , pattributes : * mut::core::ffi::c_void , pppmftactivate : *mut *mut ::core::option::Option < IMFActivate > , pnummftactivate : *mut u32 ) -> ::windows::core::HRESULT );
    MFTEnum2(::core::mem::transmute(guidcategory), flags, ::core::mem::transmute(pinputtype.unwrap_or(::std::ptr::null())), ::core::mem::transmute(poutputtype.unwrap_or(::std::ptr::null())), pattributes.into_param().abi(), pppmftactivate, pnummftactivate).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFTEnumEx(guidcategory: ::windows::core::GUID, flags: MFT_ENUM_FLAG, pinputtype: ::core::option::Option<*const MFT_REGISTER_TYPE_INFO>, poutputtype: ::core::option::Option<*const MFT_REGISTER_TYPE_INFO>, pppmftactivate: *mut *mut ::core::option::Option<IMFActivate>, pnummftactivate: *mut u32) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFTEnumEx ( guidcategory : ::windows::core::GUID , flags : MFT_ENUM_FLAG , pinputtype : *const MFT_REGISTER_TYPE_INFO , poutputtype : *const MFT_REGISTER_TYPE_INFO , pppmftactivate : *mut *mut ::core::option::Option < IMFActivate > , pnummftactivate : *mut u32 ) -> ::windows::core::HRESULT );
    MFTEnumEx(::core::mem::transmute(guidcategory), flags, ::core::mem::transmute(pinputtype.unwrap_or(::std::ptr::null())), ::core::mem::transmute(poutputtype.unwrap_or(::std::ptr::null())), pppmftactivate, pnummftactivate).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFTGetInfo(clsidmft: ::windows::core::GUID, pszname: ::core::option::Option<*mut ::windows::core::PWSTR>, ppinputtypes: ::core::option::Option<*mut *mut MFT_REGISTER_TYPE_INFO>, pcinputtypes: ::core::option::Option<*mut u32>, ppoutputtypes: ::core::option::Option<*mut *mut MFT_REGISTER_TYPE_INFO>, pcoutputtypes: ::core::option::Option<*mut u32>, ppattributes: ::core::option::Option<*mut ::core::option::Option<IMFAttributes>>) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFTGetInfo ( clsidmft : ::windows::core::GUID , pszname : *mut ::windows::core::PWSTR , ppinputtypes : *mut *mut MFT_REGISTER_TYPE_INFO , pcinputtypes : *mut u32 , ppoutputtypes : *mut *mut MFT_REGISTER_TYPE_INFO , pcoutputtypes : *mut u32 , ppattributes : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFTGetInfo(::core::mem::transmute(clsidmft), ::core::mem::transmute(pszname.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(ppinputtypes.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(pcinputtypes.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(ppoutputtypes.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(pcoutputtypes.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(ppattributes.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFTRegister<P0, P1>(clsidmft: ::windows::core::GUID, guidcategory: ::windows::core::GUID, pszname: P0, flags: u32, pinputtypes: ::core::option::Option<&[MFT_REGISTER_TYPE_INFO]>, poutputtypes: ::core::option::Option<&[MFT_REGISTER_TYPE_INFO]>, pattributes: P1) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    P1: ::windows::core::IntoParam<IMFAttributes>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFTRegister ( clsidmft : ::windows::core::GUID , guidcategory : ::windows::core::GUID , pszname : ::windows::core::PCWSTR , flags : u32 , cinputtypes : u32 , pinputtypes : *const MFT_REGISTER_TYPE_INFO , coutputtypes : u32 , poutputtypes : *const MFT_REGISTER_TYPE_INFO , pattributes : * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFTRegister(::core::mem::transmute(clsidmft), ::core::mem::transmute(guidcategory), pszname.into_param().abi(), flags, pinputtypes.as_deref().map_or(0, |slice| slice.len() as _), ::core::mem::transmute(pinputtypes.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr())), poutputtypes.as_deref().map_or(0, |slice| slice.len() as _), ::core::mem::transmute(poutputtypes.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr())), pattributes.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_System_Com\"`*"]
#[cfg(feature = "Win32_System_Com")]
#[inline]
pub unsafe fn MFTRegisterLocal<P0, P1>(pclassfactory: P0, guidcategory: *const ::windows::core::GUID, pszname: P1, flags: u32, pinputtypes: ::core::option::Option<&[MFT_REGISTER_TYPE_INFO]>, poutputtypes: ::core::option::Option<&[MFT_REGISTER_TYPE_INFO]>) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<super::super::System::Com::IClassFactory>,
    P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFTRegisterLocal ( pclassfactory : * mut::core::ffi::c_void , guidcategory : *const ::windows::core::GUID , pszname : ::windows::core::PCWSTR , flags : u32 , cinputtypes : u32 , pinputtypes : *const MFT_REGISTER_TYPE_INFO , coutputtypes : u32 , poutputtypes : *const MFT_REGISTER_TYPE_INFO ) -> ::windows::core::HRESULT );
    MFTRegisterLocal(pclassfactory.into_param().abi(), guidcategory, pszname.into_param().abi(), flags, pinputtypes.as_deref().map_or(0, |slice| slice.len() as _), ::core::mem::transmute(pinputtypes.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr())), poutputtypes.as_deref().map_or(0, |slice| slice.len() as _), ::core::mem::transmute(poutputtypes.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr()))).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFTRegisterLocalByCLSID<P0>(clisdmft: *const ::windows::core::GUID, guidcategory: *const ::windows::core::GUID, pszname: P0, flags: u32, pinputtypes: ::core::option::Option<&[MFT_REGISTER_TYPE_INFO]>, poutputtypes: ::core::option::Option<&[MFT_REGISTER_TYPE_INFO]>) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFTRegisterLocalByCLSID ( clisdmft : *const ::windows::core::GUID , guidcategory : *const ::windows::core::GUID , pszname : ::windows::core::PCWSTR , flags : u32 , cinputtypes : u32 , pinputtypes : *const MFT_REGISTER_TYPE_INFO , coutputtypes : u32 , poutputtypes : *const MFT_REGISTER_TYPE_INFO ) -> ::windows::core::HRESULT );
    MFTRegisterLocalByCLSID(clisdmft, guidcategory, pszname.into_param().abi(), flags, pinputtypes.as_deref().map_or(0, |slice| slice.len() as _), ::core::mem::transmute(pinputtypes.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr())), poutputtypes.as_deref().map_or(0, |slice| slice.len() as _), ::core::mem::transmute(poutputtypes.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr()))).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFTUnregister(clsidmft: ::windows::core::GUID) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFTUnregister ( clsidmft : ::windows::core::GUID ) -> ::windows::core::HRESULT );
    MFTUnregister(::core::mem::transmute(clsidmft)).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_System_Com\"`*"]
#[cfg(feature = "Win32_System_Com")]
#[inline]
pub unsafe fn MFTUnregisterLocal<P0>(pclassfactory: P0) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<super::super::System::Com::IClassFactory>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFTUnregisterLocal ( pclassfactory : * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    MFTUnregisterLocal(pclassfactory.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFTUnregisterLocalByCLSID(clsidmft: ::windows::core::GUID) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFTUnregisterLocalByCLSID ( clsidmft : ::windows::core::GUID ) -> ::windows::core::HRESULT );
    MFTUnregisterLocalByCLSID(::core::mem::transmute(clsidmft)).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFTranscodeGetAudioOutputAvailableTypes<P0>(guidsubtype: *const ::windows::core::GUID, dwmftflags: u32, pcodecconfig: P0) -> ::windows::core::Result<IMFCollection>
where
    P0: ::windows::core::IntoParam<IMFAttributes>,
{
    ::windows_targets::link ! ( "mf.dll""system" fn MFTranscodeGetAudioOutputAvailableTypes ( guidsubtype : *const ::windows::core::GUID , dwmftflags : u32 , pcodecconfig : * mut::core::ffi::c_void , ppavailabletypes : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFCollection>();
    MFTranscodeGetAudioOutputAvailableTypes(guidsubtype, dwmftflags, pcodecconfig.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFUnlockDXGIDeviceManager() -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFUnlockDXGIDeviceManager ( ) -> ::windows::core::HRESULT );
    MFUnlockDXGIDeviceManager().ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFUnlockPlatform() -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFUnlockPlatform ( ) -> ::windows::core::HRESULT );
    MFUnlockPlatform().ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFUnlockWorkQueue(dwworkqueue: u32) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFUnlockWorkQueue ( dwworkqueue : u32 ) -> ::windows::core::HRESULT );
    MFUnlockWorkQueue(dwworkqueue).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFUnregisterPlatformFromMMCSS() -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFUnregisterPlatformFromMMCSS ( ) -> ::windows::core::HRESULT );
    MFUnregisterPlatformFromMMCSS().ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFUnwrapMediaType<P0>(pwrap: P0) -> ::windows::core::Result<IMFMediaType>
where
    P0: ::windows::core::IntoParam<IMFMediaType>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFUnwrapMediaType ( pwrap : * mut::core::ffi::c_void , pporig : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
    MFUnwrapMediaType(pwrap.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFValidateMediaTypeSize(formattype: ::windows::core::GUID, pblock: ::core::option::Option<&[u8]>) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFValidateMediaTypeSize ( formattype : ::windows::core::GUID , pblock : *const u8 , cbsize : u32 ) -> ::windows::core::HRESULT );
    MFValidateMediaTypeSize(::core::mem::transmute(formattype), ::core::mem::transmute(pblock.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr())), pblock.as_deref().map_or(0, |slice| slice.len() as _)).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFWrapMediaType<P0>(porig: P0, majortype: *const ::windows::core::GUID, subtype: *const ::windows::core::GUID) -> ::windows::core::Result<IMFMediaType>
where
    P0: ::windows::core::IntoParam<IMFMediaType>,
{
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFWrapMediaType ( porig : * mut::core::ffi::c_void , majortype : *const ::windows::core::GUID , subtype : *const ::windows::core::GUID , ppwrap : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
    MFWrapMediaType(porig.into_param().abi(), majortype, subtype, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn MFllMulDiv(a: i64, b: i64, c: i64, d: i64) -> i64 {
    ::windows_targets::link ! ( "mfplat.dll""system" fn MFllMulDiv ( a : i64 , b : i64 , c : i64 , d : i64 ) -> i64 );
    MFllMulDiv(a, b, c, d)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn OPMGetVideoOutputForTarget(padapterluid: *const super::super::Foundation::LUID, vidpntarget: u32, vos: OPM_VIDEO_OUTPUT_SEMANTICS) -> ::windows::core::Result<IOPMVideoOutput> {
    ::windows_targets::link ! ( "dxva2.dll""system" fn OPMGetVideoOutputForTarget ( padapterluid : *const super::super::Foundation:: LUID , vidpntarget : u32 , vos : OPM_VIDEO_OUTPUT_SEMANTICS , ppopmvideooutput : *mut * mut::core::ffi::c_void ) -> ::windows::core::HRESULT );
    let mut result__ = ::windows::core::zeroed::<IOPMVideoOutput>();
    OPMGetVideoOutputForTarget(padapterluid, vidpntarget, vos, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Gdi\"`*"]
#[cfg(feature = "Win32_Graphics_Gdi")]
#[inline]
pub unsafe fn OPMGetVideoOutputsFromHMONITOR<P0>(hmonitor: P0, vos: OPM_VIDEO_OUTPUT_SEMANTICS, pulnumvideooutputs: *mut u32, pppopmvideooutputarray: *mut *mut ::core::option::Option<IOPMVideoOutput>) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<super::super::Graphics::Gdi::HMONITOR>,
{
    ::windows_targets::link ! ( "dxva2.dll""system" fn OPMGetVideoOutputsFromHMONITOR ( hmonitor : super::super::Graphics::Gdi:: HMONITOR , vos : OPM_VIDEO_OUTPUT_SEMANTICS , pulnumvideooutputs : *mut u32 , pppopmvideooutputarray : *mut *mut ::core::option::Option < IOPMVideoOutput > ) -> ::windows::core::HRESULT );
    OPMGetVideoOutputsFromHMONITOR(hmonitor.into_param().abi(), vos, pulnumvideooutputs, pppopmvideooutputarray).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
#[inline]
pub unsafe fn OPMGetVideoOutputsFromIDirect3DDevice9Object<P0>(pdirect3ddevice9: P0, vos: OPM_VIDEO_OUTPUT_SEMANTICS, pulnumvideooutputs: *mut u32, pppopmvideooutputarray: *mut *mut ::core::option::Option<IOPMVideoOutput>) -> ::windows::core::Result<()>
where
    P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D9::IDirect3DDevice9>,
{
    ::windows_targets::link ! ( "dxva2.dll""system" fn OPMGetVideoOutputsFromIDirect3DDevice9Object ( pdirect3ddevice9 : * mut::core::ffi::c_void , vos : OPM_VIDEO_OUTPUT_SEMANTICS , pulnumvideooutputs : *mut u32 , pppopmvideooutputarray : *mut *mut ::core::option::Option < IOPMVideoOutput > ) -> ::windows::core::HRESULT );
    OPMGetVideoOutputsFromIDirect3DDevice9Object(pdirect3ddevice9.into_param().abi(), vos, pulnumvideooutputs, pppopmvideooutputarray).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn OPMXboxEnableHDCP(hdcptype: OPM_HDCP_TYPE) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "opmxbox.dll""system" fn OPMXboxEnableHDCP ( hdcptype : OPM_HDCP_TYPE ) -> ::windows::core::HRESULT );
    OPMXboxEnableHDCP(hdcptype).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn OPMXboxGetHDCPStatus(phdcpstatus: *mut OPM_HDCP_STATUS) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "opmxbox.dll""system" fn OPMXboxGetHDCPStatus ( phdcpstatus : *mut OPM_HDCP_STATUS ) -> ::windows::core::HRESULT );
    OPMXboxGetHDCPStatus(phdcpstatus).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[inline]
pub unsafe fn OPMXboxGetHDCPStatusAndType(phdcpstatus: *mut OPM_HDCP_STATUS, phdcptype: *mut OPM_HDCP_TYPE) -> ::windows::core::Result<()> {
    ::windows_targets::link ! ( "opmxbox.dll""system" fn OPMXboxGetHDCPStatusAndType ( phdcpstatus : *mut OPM_HDCP_STATUS , phdcptype : *mut OPM_HDCP_TYPE ) -> ::windows::core::HRESULT );
    OPMXboxGetHDCPStatusAndType(phdcpstatus, phdcptype).ok()
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IAdvancedMediaCapture(::windows::core::IUnknown);
impl IAdvancedMediaCapture {
    pub unsafe fn GetAdvancedMediaCaptureSettings(&self) -> ::windows::core::Result<IAdvancedMediaCaptureSettings> {
        let mut result__ = ::windows::core::zeroed::<IAdvancedMediaCaptureSettings>();
        (::windows::core::Interface::vtable(self).GetAdvancedMediaCaptureSettings)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IAdvancedMediaCapture, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IAdvancedMediaCapture {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAdvancedMediaCapture {}
impl ::core::fmt::Debug for IAdvancedMediaCapture {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAdvancedMediaCapture").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IAdvancedMediaCapture {
    type Vtable = IAdvancedMediaCapture_Vtbl;
}
impl ::core::clone::Clone for IAdvancedMediaCapture {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IAdvancedMediaCapture {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd0751585_d216_4344_b5bf_463b68f977bb);
}
#[repr(C)]
#[doc(hidden)]
pub struct IAdvancedMediaCapture_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetAdvancedMediaCaptureSettings: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, value: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IAdvancedMediaCaptureInitializationSettings(::windows::core::IUnknown);
impl IAdvancedMediaCaptureInitializationSettings {
    pub unsafe fn SetDirectxDeviceManager<P0>(&self, value: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFDXGIDeviceManager>,
    {
        (::windows::core::Interface::vtable(self).SetDirectxDeviceManager)(::windows::core::Interface::as_raw(self), value.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IAdvancedMediaCaptureInitializationSettings, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IAdvancedMediaCaptureInitializationSettings {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAdvancedMediaCaptureInitializationSettings {}
impl ::core::fmt::Debug for IAdvancedMediaCaptureInitializationSettings {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAdvancedMediaCaptureInitializationSettings").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IAdvancedMediaCaptureInitializationSettings {
    type Vtable = IAdvancedMediaCaptureInitializationSettings_Vtbl;
}
impl ::core::clone::Clone for IAdvancedMediaCaptureInitializationSettings {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IAdvancedMediaCaptureInitializationSettings {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3de21209_8ba6_4f2a_a577_2819b56ff14d);
}
#[repr(C)]
#[doc(hidden)]
pub struct IAdvancedMediaCaptureInitializationSettings_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetDirectxDeviceManager: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IAdvancedMediaCaptureSettings(::windows::core::IUnknown);
impl IAdvancedMediaCaptureSettings {
    pub unsafe fn GetDirectxDeviceManager(&self) -> ::windows::core::Result<IMFDXGIDeviceManager> {
        let mut result__ = ::windows::core::zeroed::<IMFDXGIDeviceManager>();
        (::windows::core::Interface::vtable(self).GetDirectxDeviceManager)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IAdvancedMediaCaptureSettings, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IAdvancedMediaCaptureSettings {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAdvancedMediaCaptureSettings {}
impl ::core::fmt::Debug for IAdvancedMediaCaptureSettings {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAdvancedMediaCaptureSettings").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IAdvancedMediaCaptureSettings {
    type Vtable = IAdvancedMediaCaptureSettings_Vtbl;
}
impl ::core::clone::Clone for IAdvancedMediaCaptureSettings {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IAdvancedMediaCaptureSettings {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x24e0485f_a33e_4aa1_b564_6019b1d14f65);
}
#[repr(C)]
#[doc(hidden)]
pub struct IAdvancedMediaCaptureSettings_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetDirectxDeviceManager: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, value: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IAudioSourceProvider(::windows::core::IUnknown);
impl IAudioSourceProvider {
    pub unsafe fn ProvideInput(&self, dwsamplecount: u32, pdwchannelcount: *mut u32, pinterleavedaudiodata: ::core::option::Option<*mut f32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ProvideInput)(::windows::core::Interface::as_raw(self), dwsamplecount, pdwchannelcount, ::core::mem::transmute(pinterleavedaudiodata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
}
::windows::imp::interface_hierarchy!(IAudioSourceProvider, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IAudioSourceProvider {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IAudioSourceProvider {}
impl ::core::fmt::Debug for IAudioSourceProvider {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IAudioSourceProvider").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IAudioSourceProvider {
    type Vtable = IAudioSourceProvider_Vtbl;
}
impl ::core::clone::Clone for IAudioSourceProvider {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IAudioSourceProvider {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xebbaf249_afc2_4582_91c6_b60df2e84954);
}
#[repr(C)]
#[doc(hidden)]
pub struct IAudioSourceProvider_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub ProvideInput: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwsamplecount: u32, pdwchannelcount: *mut u32, pinterleavedaudiodata: *mut f32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IClusterDetector(::windows::core::IUnknown);
impl IClusterDetector {
    pub unsafe fn Initialize(&self, wbaseentrylevel: u16, wclusterentrylevel: u16) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Initialize)(::windows::core::Interface::as_raw(self), wbaseentrylevel, wclusterentrylevel).ok()
    }
    pub unsafe fn Detect<P0>(&self, dwmaxnumclusters: u32, fminclusterduration: f32, fmaxclusterduration: f32, psrctoc: P0) -> ::windows::core::Result<IToc>
    where
        P0: ::windows::core::IntoParam<IToc>,
    {
        let mut result__ = ::windows::core::zeroed::<IToc>();
        (::windows::core::Interface::vtable(self).Detect)(::windows::core::Interface::as_raw(self), dwmaxnumclusters, fminclusterduration, fmaxclusterduration, psrctoc.into_param().abi(), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IClusterDetector, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IClusterDetector {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IClusterDetector {}
impl ::core::fmt::Debug for IClusterDetector {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IClusterDetector").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IClusterDetector {
    type Vtable = IClusterDetector_Vtbl;
}
impl ::core::clone::Clone for IClusterDetector {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IClusterDetector {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3f07f7b7_c680_41d9_9423_915107ec9ff9);
}
#[repr(C)]
#[doc(hidden)]
pub struct IClusterDetector_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub Initialize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, wbaseentrylevel: u16, wclusterentrylevel: u16) -> ::windows::core::HRESULT,
    pub Detect: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwmaxnumclusters: u32, fminclusterduration: f32, fmaxclusterduration: f32, psrctoc: *mut ::core::ffi::c_void, ppdsttoc: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct ICodecAPI(::windows::core::IUnknown);
impl ICodecAPI {
    pub unsafe fn IsSupported(&self, api: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).IsSupported)(::windows::core::Interface::as_raw(self), api).ok()
    }
    pub unsafe fn IsModifiable(&self, api: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).IsModifiable)(::windows::core::Interface::as_raw(self), api).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn GetParameterRange(&self, api: *const ::windows::core::GUID, valuemin: *mut super::super::System::Com::VARIANT, valuemax: *mut super::super::System::Com::VARIANT, steppingdelta: *mut super::super::System::Com::VARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetParameterRange)(::windows::core::Interface::as_raw(self), api, valuemin, valuemax, steppingdelta).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn GetParameterValues(&self, api: *const ::windows::core::GUID, values: *mut *mut super::super::System::Com::VARIANT, valuescount: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetParameterValues)(::windows::core::Interface::as_raw(self), api, values, valuescount).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn GetDefaultValue(&self, api: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::VARIANT> {
        let mut result__ = ::windows::core::zeroed::<super::super::System::Com::VARIANT>();
        (::windows::core::Interface::vtable(self).GetDefaultValue)(::windows::core::Interface::as_raw(self), api, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn GetValue(&self, api: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::VARIANT> {
        let mut result__ = ::windows::core::zeroed::<super::super::System::Com::VARIANT>();
        (::windows::core::Interface::vtable(self).GetValue)(::windows::core::Interface::as_raw(self), api, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn SetValue(&self, api: *const ::windows::core::GUID, value: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetValue)(::windows::core::Interface::as_raw(self), api, value).ok()
    }
    pub unsafe fn RegisterForEvent(&self, api: *const ::windows::core::GUID, userdata: isize) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RegisterForEvent)(::windows::core::Interface::as_raw(self), api, userdata).ok()
    }
    pub unsafe fn UnregisterForEvent(&self, api: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).UnregisterForEvent)(::windows::core::Interface::as_raw(self), api).ok()
    }
    pub unsafe fn SetAllDefaults(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetAllDefaults)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com\"`, `\"Win32_System_Ole\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub unsafe fn SetValueWithNotify(&self, api: *const ::windows::core::GUID, value: *mut super::super::System::Com::VARIANT, changedparam: *mut *mut ::windows::core::GUID, changedparamcount: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetValueWithNotify)(::windows::core::Interface::as_raw(self), api, value, changedparam, changedparamcount).ok()
    }
    pub unsafe fn SetAllDefaultsWithNotify(&self, changedparam: *mut *mut ::windows::core::GUID, changedparamcount: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetAllDefaultsWithNotify)(::windows::core::Interface::as_raw(self), changedparam, changedparamcount).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn GetAllSettings<P0>(&self, __midl__icodecapi0000: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::System::Com::IStream>,
    {
        (::windows::core::Interface::vtable(self).GetAllSettings)(::windows::core::Interface::as_raw(self), __midl__icodecapi0000.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetAllSettings<P0>(&self, __midl__icodecapi0001: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::System::Com::IStream>,
    {
        (::windows::core::Interface::vtable(self).SetAllSettings)(::windows::core::Interface::as_raw(self), __midl__icodecapi0001.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn SetAllSettingsWithNotify<P0>(&self, __midl__icodecapi0002: P0, changedparam: *mut *mut ::windows::core::GUID, changedparamcount: *mut u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::System::Com::IStream>,
    {
        (::windows::core::Interface::vtable(self).SetAllSettingsWithNotify)(::windows::core::Interface::as_raw(self), __midl__icodecapi0002.into_param().abi(), changedparam, changedparamcount).ok()
    }
}
::windows::imp::interface_hierarchy!(ICodecAPI, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ICodecAPI {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ICodecAPI {}
impl ::core::fmt::Debug for ICodecAPI {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ICodecAPI").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ICodecAPI {
    type Vtable = ICodecAPI_Vtbl;
}
impl ::core::clone::Clone for ICodecAPI {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ICodecAPI {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x901db4c7_31ce_41a2_85dc_8fa0bf41b8da);
}
#[repr(C)]
#[doc(hidden)]
pub struct ICodecAPI_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub IsSupported: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub IsModifiable: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub GetParameterRange: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, valuemin: *mut super::super::System::Com::VARIANT, valuemax: *mut super::super::System::Com::VARIANT, steppingdelta: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole")))]
    GetParameterRange: usize,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub GetParameterValues: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, values: *mut *mut super::super::System::Com::VARIANT, valuescount: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole")))]
    GetParameterValues: usize,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub GetDefaultValue: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, value: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole")))]
    GetDefaultValue: usize,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub GetValue: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, value: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole")))]
    GetValue: usize,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub SetValue: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, value: *const super::super::System::Com::VARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole")))]
    SetValue: usize,
    pub RegisterForEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, userdata: isize) -> ::windows::core::HRESULT,
    pub UnregisterForEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub SetAllDefaults: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
    pub SetValueWithNotify: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, value: *mut super::super::System::Com::VARIANT, changedparam: *mut *mut ::windows::core::GUID, changedparamcount: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole")))]
    SetValueWithNotify: usize,
    pub SetAllDefaultsWithNotify: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, changedparam: *mut *mut ::windows::core::GUID, changedparamcount: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_System_Com")]
    pub GetAllSettings: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, __midl__icodecapi0000: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    GetAllSettings: usize,
    #[cfg(feature = "Win32_System_Com")]
    pub SetAllSettings: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, __midl__icodecapi0001: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    SetAllSettings: usize,
    #[cfg(feature = "Win32_System_Com")]
    pub SetAllSettingsWithNotify: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, __midl__icodecapi0002: *mut ::core::ffi::c_void, changedparam: *mut *mut ::windows::core::GUID, changedparamcount: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    SetAllSettingsWithNotify: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(transparent)]
pub struct ID3D12VideoDecodeCommandList(::windows::core::IUnknown);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoDecodeCommandList {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetPrivateData(&self, guid: *const ::windows::core::GUID, pdatasize: *mut u32, pdata: ::core::option::Option<*mut ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.GetPrivateData)(::windows::core::Interface::as_raw(self), guid, pdatasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateData(&self, guid: *const ::windows::core::GUID, datasize: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPrivateData)(::windows::core::Interface::as_raw(self), guid, datasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateDataInterface<P0>(&self, guid: *const ::windows::core::GUID, pdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPrivateDataInterface)(::windows::core::Interface::as_raw(self), guid, pdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetName)(::windows::core::Interface::as_raw(self), name.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetDevice<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.base__.GetDevice)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetType(&self) -> super::super::Graphics::Direct3D12::D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self).base__.GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Close)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self).Reset)(::windows::core::Interface::as_raw(self), pallocator.into_param().abi()).ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self).ClearState)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self).ResourceBarrier)(::windows::core::Interface::as_raw(self), pbarriers.len() as _, ::core::mem::transmute(pbarriers.as_ptr()))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub unsafe fn DiscardResource<P0>(&self, presource: P0, pregion: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION>)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).DiscardResource)(::windows::core::Interface::as_raw(self), presource.into_param().abi(), ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).BeginQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).EndQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResolveQueryData<P0, P1>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: P1, aligneddestinationbufferoffset: u64)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).ResolveQueryData)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, startindex, numqueries, pdestinationbuffer.into_param().abi(), aligneddestinationbufferoffset)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPredication<P0>(&self, pbuffer: P0, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).SetPredication)(::windows::core::Interface::as_raw(self), pbuffer.into_param().abi(), alignedbufferoffset, operation)
    }
    pub unsafe fn SetMarker(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).SetMarker)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn BeginEvent(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).BeginEvent)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self).EndEvent)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn DecodeFrame<P0>(&self, pdecoder: P0, poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS, pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoDecoder>,
    {
        (::windows::core::Interface::vtable(self).DecodeFrame)(::windows::core::Interface::as_raw(self), pdecoder.into_param().abi(), poutputarguments, pinputarguments)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn WriteBufferImmediate(&self, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE>) {
        (::windows::core::Interface::vtable(self).WriteBufferImmediate)(::windows::core::Interface::as_raw(self), count, pparams, ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())))
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
::windows::imp::interface_hierarchy!(ID3D12VideoDecodeCommandList, ::windows::core::IUnknown, super::super::Graphics::Direct3D12::ID3D12Object, super::super::Graphics::Direct3D12::ID3D12DeviceChild, super::super::Graphics::Direct3D12::ID3D12CommandList);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for ID3D12VideoDecodeCommandList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for ID3D12VideoDecodeCommandList {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for ID3D12VideoDecodeCommandList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDecodeCommandList").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Send for ID3D12VideoDecodeCommandList {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Sync for ID3D12VideoDecodeCommandList {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::Interface for ID3D12VideoDecodeCommandList {
    type Vtable = ID3D12VideoDecodeCommandList_Vtbl;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for ID3D12VideoDecodeCommandList {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::ComInterface for ID3D12VideoDecodeCommandList {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3b60536e_ad29_4e64_a269_f853837e5e53);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDecodeCommandList_Vtbl {
    pub base__: super::super::Graphics::Direct3D12::ID3D12CommandList_Vtbl,
    pub Close: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub Reset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pallocator: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    Reset: usize,
    pub ClearState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub ResourceBarrier: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, numbarriers: u32, pbarriers: *const super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    ResourceBarrier: usize,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub DiscardResource: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presource: *mut ::core::ffi::c_void, pregion: *const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION),
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12")))]
    DiscardResource: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub BeginQuery: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pqueryheap: *mut ::core::ffi::c_void, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    BeginQuery: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub EndQuery: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pqueryheap: *mut ::core::ffi::c_void, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    EndQuery: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub ResolveQueryData: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pqueryheap: *mut ::core::ffi::c_void, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: *mut ::core::ffi::c_void, aligneddestinationbufferoffset: u64),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    ResolveQueryData: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub SetPredication: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbuffer: *mut ::core::ffi::c_void, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    SetPredication: usize,
    pub SetMarker: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32),
    pub BeginEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32),
    pub EndEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub DecodeFrame: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdecoder: *mut ::core::ffi::c_void, poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS, pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS),
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common")))]
    DecodeFrame: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub WriteBufferImmediate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    WriteBufferImmediate: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(transparent)]
pub struct ID3D12VideoDecodeCommandList1(::windows::core::IUnknown);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoDecodeCommandList1 {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetPrivateData(&self, guid: *const ::windows::core::GUID, pdatasize: *mut u32, pdata: ::core::option::Option<*mut ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.GetPrivateData)(::windows::core::Interface::as_raw(self), guid, pdatasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateData(&self, guid: *const ::windows::core::GUID, datasize: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.SetPrivateData)(::windows::core::Interface::as_raw(self), guid, datasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateDataInterface<P0>(&self, guid: *const ::windows::core::GUID, pdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.SetPrivateDataInterface)(::windows::core::Interface::as_raw(self), guid, pdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.SetName)(::windows::core::Interface::as_raw(self), name.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetDevice<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.GetDevice)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetType(&self) -> super::super::Graphics::Direct3D12::D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self).base__.base__.GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Close)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self).base__.Reset)(::windows::core::Interface::as_raw(self), pallocator.into_param().abi()).ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self).base__.ClearState)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self).base__.ResourceBarrier)(::windows::core::Interface::as_raw(self), pbarriers.len() as _, ::core::mem::transmute(pbarriers.as_ptr()))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub unsafe fn DiscardResource<P0>(&self, presource: P0, pregion: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION>)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.DiscardResource)(::windows::core::Interface::as_raw(self), presource.into_param().abi(), ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.BeginQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.EndQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResolveQueryData<P0, P1>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: P1, aligneddestinationbufferoffset: u64)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.ResolveQueryData)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, startindex, numqueries, pdestinationbuffer.into_param().abi(), aligneddestinationbufferoffset)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPredication<P0>(&self, pbuffer: P0, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.SetPredication)(::windows::core::Interface::as_raw(self), pbuffer.into_param().abi(), alignedbufferoffset, operation)
    }
    pub unsafe fn SetMarker(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).base__.SetMarker)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn BeginEvent(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).base__.BeginEvent)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self).base__.EndEvent)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn DecodeFrame<P0>(&self, pdecoder: P0, poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS, pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoDecoder>,
    {
        (::windows::core::Interface::vtable(self).base__.DecodeFrame)(::windows::core::Interface::as_raw(self), pdecoder.into_param().abi(), poutputarguments, pinputarguments)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn WriteBufferImmediate(&self, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE>) {
        (::windows::core::Interface::vtable(self).base__.WriteBufferImmediate)(::windows::core::Interface::as_raw(self), count, pparams, ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn DecodeFrame1<P0>(&self, pdecoder: P0, poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1, pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoDecoder>,
    {
        (::windows::core::Interface::vtable(self).DecodeFrame1)(::windows::core::Interface::as_raw(self), pdecoder.into_param().abi(), poutputarguments, pinputarguments)
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
::windows::imp::interface_hierarchy!(ID3D12VideoDecodeCommandList1, ::windows::core::IUnknown, super::super::Graphics::Direct3D12::ID3D12Object, super::super::Graphics::Direct3D12::ID3D12DeviceChild, super::super::Graphics::Direct3D12::ID3D12CommandList, ID3D12VideoDecodeCommandList);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for ID3D12VideoDecodeCommandList1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for ID3D12VideoDecodeCommandList1 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for ID3D12VideoDecodeCommandList1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDecodeCommandList1").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Send for ID3D12VideoDecodeCommandList1 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Sync for ID3D12VideoDecodeCommandList1 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::Interface for ID3D12VideoDecodeCommandList1 {
    type Vtable = ID3D12VideoDecodeCommandList1_Vtbl;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for ID3D12VideoDecodeCommandList1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::ComInterface for ID3D12VideoDecodeCommandList1 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd52f011b_b56e_453c_a05a_a7f311c8f472);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDecodeCommandList1_Vtbl {
    pub base__: ID3D12VideoDecodeCommandList_Vtbl,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub DecodeFrame1: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdecoder: *mut ::core::ffi::c_void, poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1, pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS),
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common")))]
    DecodeFrame1: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(transparent)]
pub struct ID3D12VideoDecodeCommandList2(::windows::core::IUnknown);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoDecodeCommandList2 {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetPrivateData(&self, guid: *const ::windows::core::GUID, pdatasize: *mut u32, pdata: ::core::option::Option<*mut ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.GetPrivateData)(::windows::core::Interface::as_raw(self), guid, pdatasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateData(&self, guid: *const ::windows::core::GUID, datasize: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.SetPrivateData)(::windows::core::Interface::as_raw(self), guid, datasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateDataInterface<P0>(&self, guid: *const ::windows::core::GUID, pdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.SetPrivateDataInterface)(::windows::core::Interface::as_raw(self), guid, pdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.SetName)(::windows::core::Interface::as_raw(self), name.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetDevice<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.GetDevice)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetType(&self) -> super::super::Graphics::Direct3D12::D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self).base__.base__.base__.GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.Close)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.Reset)(::windows::core::Interface::as_raw(self), pallocator.into_param().abi()).ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self).base__.base__.ClearState)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self).base__.base__.ResourceBarrier)(::windows::core::Interface::as_raw(self), pbarriers.len() as _, ::core::mem::transmute(pbarriers.as_ptr()))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub unsafe fn DiscardResource<P0>(&self, presource: P0, pregion: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION>)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.DiscardResource)(::windows::core::Interface::as_raw(self), presource.into_param().abi(), ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.BeginQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.EndQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResolveQueryData<P0, P1>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: P1, aligneddestinationbufferoffset: u64)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.ResolveQueryData)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, startindex, numqueries, pdestinationbuffer.into_param().abi(), aligneddestinationbufferoffset)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPredication<P0>(&self, pbuffer: P0, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.SetPredication)(::windows::core::Interface::as_raw(self), pbuffer.into_param().abi(), alignedbufferoffset, operation)
    }
    pub unsafe fn SetMarker(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).base__.base__.SetMarker)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn BeginEvent(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).base__.base__.BeginEvent)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self).base__.base__.EndEvent)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn DecodeFrame<P0>(&self, pdecoder: P0, poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS, pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoDecoder>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.DecodeFrame)(::windows::core::Interface::as_raw(self), pdecoder.into_param().abi(), poutputarguments, pinputarguments)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn WriteBufferImmediate(&self, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE>) {
        (::windows::core::Interface::vtable(self).base__.base__.WriteBufferImmediate)(::windows::core::Interface::as_raw(self), count, pparams, ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn DecodeFrame1<P0>(&self, pdecoder: P0, poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1, pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoDecoder>,
    {
        (::windows::core::Interface::vtable(self).base__.DecodeFrame1)(::windows::core::Interface::as_raw(self), pdecoder.into_param().abi(), poutputarguments, pinputarguments)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self).SetProtectedResourceSession)(::windows::core::Interface::as_raw(self), pprotectedresourcesession.into_param().abi())
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn InitializeExtensionCommand<P0>(&self, pextensioncommand: P0, pinitializationparameters: *const ::core::ffi::c_void, initializationparameterssizeinbytes: usize)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self).InitializeExtensionCommand)(::windows::core::Interface::as_raw(self), pextensioncommand.into_param().abi(), pinitializationparameters, initializationparameterssizeinbytes)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ExecuteExtensionCommand<P0>(&self, pextensioncommand: P0, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self).ExecuteExtensionCommand)(::windows::core::Interface::as_raw(self), pextensioncommand.into_param().abi(), pexecutionparameters, executionparameterssizeinbytes)
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
::windows::imp::interface_hierarchy!(ID3D12VideoDecodeCommandList2, ::windows::core::IUnknown, super::super::Graphics::Direct3D12::ID3D12Object, super::super::Graphics::Direct3D12::ID3D12DeviceChild, super::super::Graphics::Direct3D12::ID3D12CommandList, ID3D12VideoDecodeCommandList, ID3D12VideoDecodeCommandList1);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for ID3D12VideoDecodeCommandList2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for ID3D12VideoDecodeCommandList2 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for ID3D12VideoDecodeCommandList2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDecodeCommandList2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Send for ID3D12VideoDecodeCommandList2 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Sync for ID3D12VideoDecodeCommandList2 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::Interface for ID3D12VideoDecodeCommandList2 {
    type Vtable = ID3D12VideoDecodeCommandList2_Vtbl;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for ID3D12VideoDecodeCommandList2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::ComInterface for ID3D12VideoDecodeCommandList2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6e120880_c114_4153_8036_d247051e1729);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDecodeCommandList2_Vtbl {
    pub base__: ID3D12VideoDecodeCommandList1_Vtbl,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub SetProtectedResourceSession: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pprotectedresourcesession: *mut ::core::ffi::c_void),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    SetProtectedResourceSession: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub InitializeExtensionCommand: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pextensioncommand: *mut ::core::ffi::c_void, pinitializationparameters: *const ::core::ffi::c_void, initializationparameterssizeinbytes: usize),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    InitializeExtensionCommand: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub ExecuteExtensionCommand: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pextensioncommand: *mut ::core::ffi::c_void, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    ExecuteExtensionCommand: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(transparent)]
pub struct ID3D12VideoDecodeCommandList3(::windows::core::IUnknown);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoDecodeCommandList3 {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetPrivateData(&self, guid: *const ::windows::core::GUID, pdatasize: *mut u32, pdata: ::core::option::Option<*mut ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.base__.GetPrivateData)(::windows::core::Interface::as_raw(self), guid, pdatasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateData(&self, guid: *const ::windows::core::GUID, datasize: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.base__.SetPrivateData)(::windows::core::Interface::as_raw(self), guid, datasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateDataInterface<P0>(&self, guid: *const ::windows::core::GUID, pdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.base__.SetPrivateDataInterface)(::windows::core::Interface::as_raw(self), guid, pdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.base__.SetName)(::windows::core::Interface::as_raw(self), name.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetDevice<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.GetDevice)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetType(&self) -> super::super::Graphics::Direct3D12::D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.Close)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.Reset)(::windows::core::Interface::as_raw(self), pallocator.into_param().abi()).ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self).base__.base__.base__.ClearState)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self).base__.base__.base__.ResourceBarrier)(::windows::core::Interface::as_raw(self), pbarriers.len() as _, ::core::mem::transmute(pbarriers.as_ptr()))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub unsafe fn DiscardResource<P0>(&self, presource: P0, pregion: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION>)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.DiscardResource)(::windows::core::Interface::as_raw(self), presource.into_param().abi(), ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.BeginQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.EndQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResolveQueryData<P0, P1>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: P1, aligneddestinationbufferoffset: u64)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.ResolveQueryData)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, startindex, numqueries, pdestinationbuffer.into_param().abi(), aligneddestinationbufferoffset)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPredication<P0>(&self, pbuffer: P0, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPredication)(::windows::core::Interface::as_raw(self), pbuffer.into_param().abi(), alignedbufferoffset, operation)
    }
    pub unsafe fn SetMarker(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetMarker)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn BeginEvent(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).base__.base__.base__.BeginEvent)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self).base__.base__.base__.EndEvent)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn DecodeFrame<P0>(&self, pdecoder: P0, poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS, pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoDecoder>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.DecodeFrame)(::windows::core::Interface::as_raw(self), pdecoder.into_param().abi(), poutputarguments, pinputarguments)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn WriteBufferImmediate(&self, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE>) {
        (::windows::core::Interface::vtable(self).base__.base__.base__.WriteBufferImmediate)(::windows::core::Interface::as_raw(self), count, pparams, ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn DecodeFrame1<P0>(&self, pdecoder: P0, poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1, pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoDecoder>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.DecodeFrame1)(::windows::core::Interface::as_raw(self), pdecoder.into_param().abi(), poutputarguments, pinputarguments)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self).base__.SetProtectedResourceSession)(::windows::core::Interface::as_raw(self), pprotectedresourcesession.into_param().abi())
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn InitializeExtensionCommand<P0>(&self, pextensioncommand: P0, pinitializationparameters: *const ::core::ffi::c_void, initializationparameterssizeinbytes: usize)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self).base__.InitializeExtensionCommand)(::windows::core::Interface::as_raw(self), pextensioncommand.into_param().abi(), pinitializationparameters, initializationparameterssizeinbytes)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ExecuteExtensionCommand<P0>(&self, pextensioncommand: P0, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self).base__.ExecuteExtensionCommand)(::windows::core::Interface::as_raw(self), pextensioncommand.into_param().abi(), pexecutionparameters, executionparameterssizeinbytes)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn Barrier(&self, pbarriergroups: &[super::super::Graphics::Direct3D12::D3D12_BARRIER_GROUP]) {
        (::windows::core::Interface::vtable(self).Barrier)(::windows::core::Interface::as_raw(self), pbarriergroups.len() as _, ::core::mem::transmute(pbarriergroups.as_ptr()))
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
::windows::imp::interface_hierarchy!(ID3D12VideoDecodeCommandList3, ::windows::core::IUnknown, super::super::Graphics::Direct3D12::ID3D12Object, super::super::Graphics::Direct3D12::ID3D12DeviceChild, super::super::Graphics::Direct3D12::ID3D12CommandList, ID3D12VideoDecodeCommandList, ID3D12VideoDecodeCommandList1, ID3D12VideoDecodeCommandList2);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for ID3D12VideoDecodeCommandList3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for ID3D12VideoDecodeCommandList3 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for ID3D12VideoDecodeCommandList3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDecodeCommandList3").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Send for ID3D12VideoDecodeCommandList3 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Sync for ID3D12VideoDecodeCommandList3 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::Interface for ID3D12VideoDecodeCommandList3 {
    type Vtable = ID3D12VideoDecodeCommandList3_Vtbl;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for ID3D12VideoDecodeCommandList3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::ComInterface for ID3D12VideoDecodeCommandList3 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2aee8c37_9562_42da_8abf_61efeb2e4513);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDecodeCommandList3_Vtbl {
    pub base__: ID3D12VideoDecodeCommandList2_Vtbl,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub Barrier: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, numbarriergroups: u32, pbarriergroups: *const super::super::Graphics::Direct3D12::D3D12_BARRIER_GROUP),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    Barrier: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(transparent)]
pub struct ID3D12VideoDecoder(::windows::core::IUnknown);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoDecoder {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetPrivateData(&self, guid: *const ::windows::core::GUID, pdatasize: *mut u32, pdata: ::core::option::Option<*mut ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.GetPrivateData)(::windows::core::Interface::as_raw(self), guid, pdatasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateData(&self, guid: *const ::windows::core::GUID, datasize: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPrivateData)(::windows::core::Interface::as_raw(self), guid, datasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateDataInterface<P0>(&self, guid: *const ::windows::core::GUID, pdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPrivateDataInterface)(::windows::core::Interface::as_raw(self), guid, pdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetName)(::windows::core::Interface::as_raw(self), name.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetDevice<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.base__.GetDevice)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
    pub unsafe fn GetDesc(&self) -> D3D12_VIDEO_DECODER_DESC {
        let mut result__: D3D12_VIDEO_DECODER_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetDesc)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
::windows::imp::interface_hierarchy!(ID3D12VideoDecoder, ::windows::core::IUnknown, super::super::Graphics::Direct3D12::ID3D12Object, super::super::Graphics::Direct3D12::ID3D12DeviceChild, super::super::Graphics::Direct3D12::ID3D12Pageable);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for ID3D12VideoDecoder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for ID3D12VideoDecoder {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for ID3D12VideoDecoder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDecoder").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Send for ID3D12VideoDecoder {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Sync for ID3D12VideoDecoder {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::Interface for ID3D12VideoDecoder {
    type Vtable = ID3D12VideoDecoder_Vtbl;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for ID3D12VideoDecoder {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::ComInterface for ID3D12VideoDecoder {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc59b6bdc_7720_4074_a136_17a156037470);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDecoder_Vtbl {
    pub base__: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl,
    pub GetDesc: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, result__: *mut D3D12_VIDEO_DECODER_DESC),
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(transparent)]
pub struct ID3D12VideoDecoder1(::windows::core::IUnknown);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoDecoder1 {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetPrivateData(&self, guid: *const ::windows::core::GUID, pdatasize: *mut u32, pdata: ::core::option::Option<*mut ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.GetPrivateData)(::windows::core::Interface::as_raw(self), guid, pdatasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateData(&self, guid: *const ::windows::core::GUID, datasize: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.SetPrivateData)(::windows::core::Interface::as_raw(self), guid, datasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateDataInterface<P0>(&self, guid: *const ::windows::core::GUID, pdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.SetPrivateDataInterface)(::windows::core::Interface::as_raw(self), guid, pdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.SetName)(::windows::core::Interface::as_raw(self), name.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetDevice<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.GetDevice)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
    pub unsafe fn GetDesc(&self) -> D3D12_VIDEO_DECODER_DESC {
        let mut result__: D3D12_VIDEO_DECODER_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).base__.GetDesc)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
    pub unsafe fn GetProtectedResourceSession<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).GetProtectedResourceSession)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
::windows::imp::interface_hierarchy!(ID3D12VideoDecoder1, ::windows::core::IUnknown, super::super::Graphics::Direct3D12::ID3D12Object, super::super::Graphics::Direct3D12::ID3D12DeviceChild, super::super::Graphics::Direct3D12::ID3D12Pageable, ID3D12VideoDecoder);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for ID3D12VideoDecoder1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for ID3D12VideoDecoder1 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for ID3D12VideoDecoder1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDecoder1").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Send for ID3D12VideoDecoder1 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Sync for ID3D12VideoDecoder1 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::Interface for ID3D12VideoDecoder1 {
    type Vtable = ID3D12VideoDecoder1_Vtbl;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for ID3D12VideoDecoder1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::ComInterface for ID3D12VideoDecoder1 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x79a2e5fb_ccd2_469a_9fde_195d10951f7e);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDecoder1_Vtbl {
    pub base__: ID3D12VideoDecoder_Vtbl,
    pub GetProtectedResourceSession: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(transparent)]
pub struct ID3D12VideoDecoderHeap(::windows::core::IUnknown);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoDecoderHeap {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetPrivateData(&self, guid: *const ::windows::core::GUID, pdatasize: *mut u32, pdata: ::core::option::Option<*mut ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.GetPrivateData)(::windows::core::Interface::as_raw(self), guid, pdatasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateData(&self, guid: *const ::windows::core::GUID, datasize: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPrivateData)(::windows::core::Interface::as_raw(self), guid, datasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateDataInterface<P0>(&self, guid: *const ::windows::core::GUID, pdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPrivateDataInterface)(::windows::core::Interface::as_raw(self), guid, pdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetName)(::windows::core::Interface::as_raw(self), name.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetDevice<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.base__.GetDevice)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(feature = "Win32_Graphics_Dxgi_Common")]
    pub unsafe fn GetDesc(&self) -> D3D12_VIDEO_DECODER_HEAP_DESC {
        let mut result__: D3D12_VIDEO_DECODER_HEAP_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetDesc)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
::windows::imp::interface_hierarchy!(ID3D12VideoDecoderHeap, ::windows::core::IUnknown, super::super::Graphics::Direct3D12::ID3D12Object, super::super::Graphics::Direct3D12::ID3D12DeviceChild, super::super::Graphics::Direct3D12::ID3D12Pageable);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for ID3D12VideoDecoderHeap {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for ID3D12VideoDecoderHeap {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for ID3D12VideoDecoderHeap {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDecoderHeap").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Send for ID3D12VideoDecoderHeap {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Sync for ID3D12VideoDecoderHeap {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::Interface for ID3D12VideoDecoderHeap {
    type Vtable = ID3D12VideoDecoderHeap_Vtbl;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for ID3D12VideoDecoderHeap {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::ComInterface for ID3D12VideoDecoderHeap {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0946b7c9_ebf6_4047_bb73_8683e27dbb1f);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDecoderHeap_Vtbl {
    pub base__: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl,
    #[cfg(feature = "Win32_Graphics_Dxgi_Common")]
    pub GetDesc: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, result__: *mut D3D12_VIDEO_DECODER_HEAP_DESC),
    #[cfg(not(feature = "Win32_Graphics_Dxgi_Common"))]
    GetDesc: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(transparent)]
pub struct ID3D12VideoDecoderHeap1(::windows::core::IUnknown);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoDecoderHeap1 {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetPrivateData(&self, guid: *const ::windows::core::GUID, pdatasize: *mut u32, pdata: ::core::option::Option<*mut ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.GetPrivateData)(::windows::core::Interface::as_raw(self), guid, pdatasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateData(&self, guid: *const ::windows::core::GUID, datasize: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.SetPrivateData)(::windows::core::Interface::as_raw(self), guid, datasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateDataInterface<P0>(&self, guid: *const ::windows::core::GUID, pdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.SetPrivateDataInterface)(::windows::core::Interface::as_raw(self), guid, pdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.SetName)(::windows::core::Interface::as_raw(self), name.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetDevice<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.GetDevice)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(feature = "Win32_Graphics_Dxgi_Common")]
    pub unsafe fn GetDesc(&self) -> D3D12_VIDEO_DECODER_HEAP_DESC {
        let mut result__: D3D12_VIDEO_DECODER_HEAP_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).base__.GetDesc)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
    pub unsafe fn GetProtectedResourceSession<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).GetProtectedResourceSession)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
::windows::imp::interface_hierarchy!(ID3D12VideoDecoderHeap1, ::windows::core::IUnknown, super::super::Graphics::Direct3D12::ID3D12Object, super::super::Graphics::Direct3D12::ID3D12DeviceChild, super::super::Graphics::Direct3D12::ID3D12Pageable, ID3D12VideoDecoderHeap);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for ID3D12VideoDecoderHeap1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for ID3D12VideoDecoderHeap1 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for ID3D12VideoDecoderHeap1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDecoderHeap1").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Send for ID3D12VideoDecoderHeap1 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Sync for ID3D12VideoDecoderHeap1 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::Interface for ID3D12VideoDecoderHeap1 {
    type Vtable = ID3D12VideoDecoderHeap1_Vtbl;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for ID3D12VideoDecoderHeap1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::ComInterface for ID3D12VideoDecoderHeap1 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xda1d98c5_539f_41b2_bf6b_1198a03b6d26);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDecoderHeap1_Vtbl {
    pub base__: ID3D12VideoDecoderHeap_Vtbl,
    pub GetProtectedResourceSession: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct ID3D12VideoDevice(::windows::core::IUnknown);
impl ID3D12VideoDevice {
    pub unsafe fn CheckFeatureSupport(&self, featurevideo: D3D12_FEATURE_VIDEO, pfeaturesupportdata: *mut ::core::ffi::c_void, featuresupportdatasize: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).CheckFeatureSupport)(::windows::core::Interface::as_raw(self), featurevideo, pfeaturesupportdata, featuresupportdatasize).ok()
    }
    pub unsafe fn CreateVideoDecoder<T>(&self, pdesc: *const D3D12_VIDEO_DECODER_DESC) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateVideoDecoder)(::windows::core::Interface::as_raw(self), pdesc, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(feature = "Win32_Graphics_Dxgi_Common")]
    pub unsafe fn CreateVideoDecoderHeap<T>(&self, pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateVideoDecoderHeap)(::windows::core::Interface::as_raw(self), pvideodecoderheapdesc, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn CreateVideoProcessor<T>(&self, nodemask: u32, poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC, pinputstreamdescs: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC]) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateVideoProcessor)(::windows::core::Interface::as_raw(self), nodemask, poutputstreamdesc, pinputstreamdescs.len() as _, ::core::mem::transmute(pinputstreamdescs.as_ptr()), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(ID3D12VideoDevice, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12VideoDevice {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoDevice {}
impl ::core::fmt::Debug for ID3D12VideoDevice {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDevice").field(&self.0).finish()
    }
}
unsafe impl ::core::marker::Send for ID3D12VideoDevice {}
unsafe impl ::core::marker::Sync for ID3D12VideoDevice {}
unsafe impl ::windows::core::Interface for ID3D12VideoDevice {
    type Vtable = ID3D12VideoDevice_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoDevice {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoDevice {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1f052807_0b46_4acc_8a89_364f793718a4);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDevice_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub CheckFeatureSupport: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, featurevideo: D3D12_FEATURE_VIDEO, pfeaturesupportdata: *mut ::core::ffi::c_void, featuresupportdatasize: u32) -> ::windows::core::HRESULT,
    pub CreateVideoDecoder: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdesc: *const D3D12_VIDEO_DECODER_DESC, riid: *const ::windows::core::GUID, ppvideodecoder: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Dxgi_Common")]
    pub CreateVideoDecoderHeap: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC, riid: *const ::windows::core::GUID, ppvideodecoderheap: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Dxgi_Common"))]
    CreateVideoDecoderHeap: usize,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
    pub CreateVideoProcessor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, nodemask: u32, poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC, numinputstreamdescs: u32, pinputstreamdescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC, riid: *const ::windows::core::GUID, ppvideoprocessor: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common")))]
    CreateVideoProcessor: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct ID3D12VideoDevice1(::windows::core::IUnknown);
impl ID3D12VideoDevice1 {
    pub unsafe fn CheckFeatureSupport(&self, featurevideo: D3D12_FEATURE_VIDEO, pfeaturesupportdata: *mut ::core::ffi::c_void, featuresupportdatasize: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.CheckFeatureSupport)(::windows::core::Interface::as_raw(self), featurevideo, pfeaturesupportdata, featuresupportdatasize).ok()
    }
    pub unsafe fn CreateVideoDecoder<T>(&self, pdesc: *const D3D12_VIDEO_DECODER_DESC) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.CreateVideoDecoder)(::windows::core::Interface::as_raw(self), pdesc, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(feature = "Win32_Graphics_Dxgi_Common")]
    pub unsafe fn CreateVideoDecoderHeap<T>(&self, pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.CreateVideoDecoderHeap)(::windows::core::Interface::as_raw(self), pvideodecoderheapdesc, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn CreateVideoProcessor<T>(&self, nodemask: u32, poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC, pinputstreamdescs: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC]) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.CreateVideoProcessor)(::windows::core::Interface::as_raw(self), nodemask, poutputstreamdesc, pinputstreamdescs.len() as _, ::core::mem::transmute(pinputstreamdescs.as_ptr()), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn CreateVideoMotionEstimator<P0, T>(&self, pdesc: *const D3D12_VIDEO_MOTION_ESTIMATOR_DESC, pprotectedresourcesession: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateVideoMotionEstimator)(::windows::core::Interface::as_raw(self), pdesc, pprotectedresourcesession.into_param().abi(), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn CreateVideoMotionVectorHeap<P0, T>(&self, pdesc: *const D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC, pprotectedresourcesession: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateVideoMotionVectorHeap)(::windows::core::Interface::as_raw(self), pdesc, pprotectedresourcesession.into_param().abi(), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(ID3D12VideoDevice1, ::windows::core::IUnknown, ID3D12VideoDevice);
impl ::core::cmp::PartialEq for ID3D12VideoDevice1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoDevice1 {}
impl ::core::fmt::Debug for ID3D12VideoDevice1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDevice1").field(&self.0).finish()
    }
}
unsafe impl ::core::marker::Send for ID3D12VideoDevice1 {}
unsafe impl ::core::marker::Sync for ID3D12VideoDevice1 {}
unsafe impl ::windows::core::Interface for ID3D12VideoDevice1 {
    type Vtable = ID3D12VideoDevice1_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoDevice1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoDevice1 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x981611ad_a144_4c83_9890_f30e26d658ab);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDevice1_Vtbl {
    pub base__: ID3D12VideoDevice_Vtbl,
    #[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub CreateVideoMotionEstimator: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdesc: *const D3D12_VIDEO_MOTION_ESTIMATOR_DESC, pprotectedresourcesession: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppvideomotionestimator: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common")))]
    CreateVideoMotionEstimator: usize,
    #[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub CreateVideoMotionVectorHeap: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdesc: *const D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC, pprotectedresourcesession: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppvideomotionvectorheap: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common")))]
    CreateVideoMotionVectorHeap: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct ID3D12VideoDevice2(::windows::core::IUnknown);
impl ID3D12VideoDevice2 {
    pub unsafe fn CheckFeatureSupport(&self, featurevideo: D3D12_FEATURE_VIDEO, pfeaturesupportdata: *mut ::core::ffi::c_void, featuresupportdatasize: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.CheckFeatureSupport)(::windows::core::Interface::as_raw(self), featurevideo, pfeaturesupportdata, featuresupportdatasize).ok()
    }
    pub unsafe fn CreateVideoDecoder<T>(&self, pdesc: *const D3D12_VIDEO_DECODER_DESC) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.base__.CreateVideoDecoder)(::windows::core::Interface::as_raw(self), pdesc, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(feature = "Win32_Graphics_Dxgi_Common")]
    pub unsafe fn CreateVideoDecoderHeap<T>(&self, pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.base__.CreateVideoDecoderHeap)(::windows::core::Interface::as_raw(self), pvideodecoderheapdesc, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn CreateVideoProcessor<T>(&self, nodemask: u32, poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC, pinputstreamdescs: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC]) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.base__.CreateVideoProcessor)(::windows::core::Interface::as_raw(self), nodemask, poutputstreamdesc, pinputstreamdescs.len() as _, ::core::mem::transmute(pinputstreamdescs.as_ptr()), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn CreateVideoMotionEstimator<P0, T>(&self, pdesc: *const D3D12_VIDEO_MOTION_ESTIMATOR_DESC, pprotectedresourcesession: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.CreateVideoMotionEstimator)(::windows::core::Interface::as_raw(self), pdesc, pprotectedresourcesession.into_param().abi(), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn CreateVideoMotionVectorHeap<P0, T>(&self, pdesc: *const D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC, pprotectedresourcesession: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.CreateVideoMotionVectorHeap)(::windows::core::Interface::as_raw(self), pdesc, pprotectedresourcesession.into_param().abi(), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn CreateVideoDecoder1<P0, T>(&self, pdesc: *const D3D12_VIDEO_DECODER_DESC, pprotectedresourcesession: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateVideoDecoder1)(::windows::core::Interface::as_raw(self), pdesc, pprotectedresourcesession.into_param().abi(), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn CreateVideoDecoderHeap1<P0, T>(&self, pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC, pprotectedresourcesession: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateVideoDecoderHeap1)(::windows::core::Interface::as_raw(self), pvideodecoderheapdesc, pprotectedresourcesession.into_param().abi(), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn CreateVideoProcessor1<P0, T>(&self, nodemask: u32, poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC, pinputstreamdescs: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC], pprotectedresourcesession: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateVideoProcessor1)(::windows::core::Interface::as_raw(self), nodemask, poutputstreamdesc, pinputstreamdescs.len() as _, ::core::mem::transmute(pinputstreamdescs.as_ptr()), pprotectedresourcesession.into_param().abi(), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn CreateVideoExtensionCommand<P0, T>(&self, pdesc: *const D3D12_VIDEO_EXTENSION_COMMAND_DESC, pcreationparameters: *const ::core::ffi::c_void, creationparametersdatasizeinbytes: usize, pprotectedresourcesession: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateVideoExtensionCommand)(::windows::core::Interface::as_raw(self), pdesc, pcreationparameters, creationparametersdatasizeinbytes, pprotectedresourcesession.into_param().abi(), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ExecuteExtensionCommand<P0>(&self, pextensioncommand: P0, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize, poutputdata: *mut ::core::ffi::c_void, outputdatasizeinbytes: usize) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self).ExecuteExtensionCommand)(::windows::core::Interface::as_raw(self), pextensioncommand.into_param().abi(), pexecutionparameters, executionparameterssizeinbytes, poutputdata, outputdatasizeinbytes).ok()
    }
}
::windows::imp::interface_hierarchy!(ID3D12VideoDevice2, ::windows::core::IUnknown, ID3D12VideoDevice, ID3D12VideoDevice1);
impl ::core::cmp::PartialEq for ID3D12VideoDevice2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoDevice2 {}
impl ::core::fmt::Debug for ID3D12VideoDevice2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDevice2").field(&self.0).finish()
    }
}
unsafe impl ::core::marker::Send for ID3D12VideoDevice2 {}
unsafe impl ::core::marker::Sync for ID3D12VideoDevice2 {}
unsafe impl ::windows::core::Interface for ID3D12VideoDevice2 {
    type Vtable = ID3D12VideoDevice2_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoDevice2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoDevice2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf019ac49_f838_4a95_9b17_579437c8f513);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDevice2_Vtbl {
    pub base__: ID3D12VideoDevice1_Vtbl,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub CreateVideoDecoder1: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdesc: *const D3D12_VIDEO_DECODER_DESC, pprotectedresourcesession: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppvideodecoder: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    CreateVideoDecoder1: usize,
    #[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub CreateVideoDecoderHeap1: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC, pprotectedresourcesession: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppvideodecoderheap: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common")))]
    CreateVideoDecoderHeap1: usize,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub CreateVideoProcessor1: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, nodemask: u32, poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC, numinputstreamdescs: u32, pinputstreamdescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC, pprotectedresourcesession: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppvideoprocessor: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common")))]
    CreateVideoProcessor1: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub CreateVideoExtensionCommand: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdesc: *const D3D12_VIDEO_EXTENSION_COMMAND_DESC, pcreationparameters: *const ::core::ffi::c_void, creationparametersdatasizeinbytes: usize, pprotectedresourcesession: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppvideoextensioncommand: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    CreateVideoExtensionCommand: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub ExecuteExtensionCommand: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pextensioncommand: *mut ::core::ffi::c_void, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize, poutputdata: *mut ::core::ffi::c_void, outputdatasizeinbytes: usize) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    ExecuteExtensionCommand: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct ID3D12VideoDevice3(::windows::core::IUnknown);
impl ID3D12VideoDevice3 {
    pub unsafe fn CheckFeatureSupport(&self, featurevideo: D3D12_FEATURE_VIDEO, pfeaturesupportdata: *mut ::core::ffi::c_void, featuresupportdatasize: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.CheckFeatureSupport)(::windows::core::Interface::as_raw(self), featurevideo, pfeaturesupportdata, featuresupportdatasize).ok()
    }
    pub unsafe fn CreateVideoDecoder<T>(&self, pdesc: *const D3D12_VIDEO_DECODER_DESC) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.base__.base__.CreateVideoDecoder)(::windows::core::Interface::as_raw(self), pdesc, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(feature = "Win32_Graphics_Dxgi_Common")]
    pub unsafe fn CreateVideoDecoderHeap<T>(&self, pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.base__.base__.CreateVideoDecoderHeap)(::windows::core::Interface::as_raw(self), pvideodecoderheapdesc, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn CreateVideoProcessor<T>(&self, nodemask: u32, poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC, pinputstreamdescs: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC]) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.base__.base__.CreateVideoProcessor)(::windows::core::Interface::as_raw(self), nodemask, poutputstreamdesc, pinputstreamdescs.len() as _, ::core::mem::transmute(pinputstreamdescs.as_ptr()), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn CreateVideoMotionEstimator<P0, T>(&self, pdesc: *const D3D12_VIDEO_MOTION_ESTIMATOR_DESC, pprotectedresourcesession: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.base__.CreateVideoMotionEstimator)(::windows::core::Interface::as_raw(self), pdesc, pprotectedresourcesession.into_param().abi(), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn CreateVideoMotionVectorHeap<P0, T>(&self, pdesc: *const D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC, pprotectedresourcesession: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.base__.CreateVideoMotionVectorHeap)(::windows::core::Interface::as_raw(self), pdesc, pprotectedresourcesession.into_param().abi(), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn CreateVideoDecoder1<P0, T>(&self, pdesc: *const D3D12_VIDEO_DECODER_DESC, pprotectedresourcesession: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.CreateVideoDecoder1)(::windows::core::Interface::as_raw(self), pdesc, pprotectedresourcesession.into_param().abi(), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn CreateVideoDecoderHeap1<P0, T>(&self, pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC, pprotectedresourcesession: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.CreateVideoDecoderHeap1)(::windows::core::Interface::as_raw(self), pvideodecoderheapdesc, pprotectedresourcesession.into_param().abi(), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn CreateVideoProcessor1<P0, T>(&self, nodemask: u32, poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC, pinputstreamdescs: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC], pprotectedresourcesession: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.CreateVideoProcessor1)(::windows::core::Interface::as_raw(self), nodemask, poutputstreamdesc, pinputstreamdescs.len() as _, ::core::mem::transmute(pinputstreamdescs.as_ptr()), pprotectedresourcesession.into_param().abi(), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn CreateVideoExtensionCommand<P0, T>(&self, pdesc: *const D3D12_VIDEO_EXTENSION_COMMAND_DESC, pcreationparameters: *const ::core::ffi::c_void, creationparametersdatasizeinbytes: usize, pprotectedresourcesession: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.CreateVideoExtensionCommand)(::windows::core::Interface::as_raw(self), pdesc, pcreationparameters, creationparametersdatasizeinbytes, pprotectedresourcesession.into_param().abi(), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ExecuteExtensionCommand<P0>(&self, pextensioncommand: P0, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize, poutputdata: *mut ::core::ffi::c_void, outputdatasizeinbytes: usize) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self).base__.ExecuteExtensionCommand)(::windows::core::Interface::as_raw(self), pextensioncommand.into_param().abi(), pexecutionparameters, executionparameterssizeinbytes, poutputdata, outputdatasizeinbytes).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(feature = "Win32_Graphics_Dxgi_Common")]
    pub unsafe fn CreateVideoEncoder<T>(&self, pdesc: *const D3D12_VIDEO_ENCODER_DESC) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateVideoEncoder)(::windows::core::Interface::as_raw(self), pdesc, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    pub unsafe fn CreateVideoEncoderHeap<T>(&self, pdesc: *const D3D12_VIDEO_ENCODER_HEAP_DESC) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateVideoEncoderHeap)(::windows::core::Interface::as_raw(self), pdesc, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(ID3D12VideoDevice3, ::windows::core::IUnknown, ID3D12VideoDevice, ID3D12VideoDevice1, ID3D12VideoDevice2);
impl ::core::cmp::PartialEq for ID3D12VideoDevice3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoDevice3 {}
impl ::core::fmt::Debug for ID3D12VideoDevice3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDevice3").field(&self.0).finish()
    }
}
unsafe impl ::core::marker::Send for ID3D12VideoDevice3 {}
unsafe impl ::core::marker::Sync for ID3D12VideoDevice3 {}
unsafe impl ::windows::core::Interface for ID3D12VideoDevice3 {
    type Vtable = ID3D12VideoDevice3_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoDevice3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoDevice3 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4243adb4_3a32_4666_973c_0ccc5625dc44);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDevice3_Vtbl {
    pub base__: ID3D12VideoDevice2_Vtbl,
    #[cfg(feature = "Win32_Graphics_Dxgi_Common")]
    pub CreateVideoEncoder: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdesc: *const D3D12_VIDEO_ENCODER_DESC, riid: *const ::windows::core::GUID, ppvideoencoder: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Dxgi_Common"))]
    CreateVideoEncoder: usize,
    pub CreateVideoEncoderHeap: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdesc: *const D3D12_VIDEO_ENCODER_HEAP_DESC, riid: *const ::windows::core::GUID, ppvideoencoderheap: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(transparent)]
pub struct ID3D12VideoEncodeCommandList(::windows::core::IUnknown);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoEncodeCommandList {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetPrivateData(&self, guid: *const ::windows::core::GUID, pdatasize: *mut u32, pdata: ::core::option::Option<*mut ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.GetPrivateData)(::windows::core::Interface::as_raw(self), guid, pdatasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateData(&self, guid: *const ::windows::core::GUID, datasize: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPrivateData)(::windows::core::Interface::as_raw(self), guid, datasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateDataInterface<P0>(&self, guid: *const ::windows::core::GUID, pdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPrivateDataInterface)(::windows::core::Interface::as_raw(self), guid, pdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetName)(::windows::core::Interface::as_raw(self), name.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetDevice<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.base__.GetDevice)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetType(&self) -> super::super::Graphics::Direct3D12::D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self).base__.GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Close)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self).Reset)(::windows::core::Interface::as_raw(self), pallocator.into_param().abi()).ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self).ClearState)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self).ResourceBarrier)(::windows::core::Interface::as_raw(self), pbarriers.len() as _, ::core::mem::transmute(pbarriers.as_ptr()))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub unsafe fn DiscardResource<P0>(&self, presource: P0, pregion: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION>)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).DiscardResource)(::windows::core::Interface::as_raw(self), presource.into_param().abi(), ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).BeginQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).EndQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResolveQueryData<P0, P1>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: P1, aligneddestinationbufferoffset: u64)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).ResolveQueryData)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, startindex, numqueries, pdestinationbuffer.into_param().abi(), aligneddestinationbufferoffset)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPredication<P0>(&self, pbuffer: P0, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).SetPredication)(::windows::core::Interface::as_raw(self), pbuffer.into_param().abi(), alignedbufferoffset, operation)
    }
    pub unsafe fn SetMarker(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).SetMarker)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn BeginEvent(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).BeginEvent)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self).EndEvent)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn EstimateMotion<P0>(&self, pmotionestimator: P0, poutputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT, pinputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoMotionEstimator>,
    {
        (::windows::core::Interface::vtable(self).EstimateMotion)(::windows::core::Interface::as_raw(self), pmotionestimator.into_param().abi(), poutputarguments, pinputarguments)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResolveMotionVectorHeap(&self, poutputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT, pinputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT) {
        (::windows::core::Interface::vtable(self).ResolveMotionVectorHeap)(::windows::core::Interface::as_raw(self), poutputarguments, pinputarguments)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn WriteBufferImmediate(&self, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE>) {
        (::windows::core::Interface::vtable(self).WriteBufferImmediate)(::windows::core::Interface::as_raw(self), count, pparams, ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self).SetProtectedResourceSession)(::windows::core::Interface::as_raw(self), pprotectedresourcesession.into_param().abi())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
::windows::imp::interface_hierarchy!(ID3D12VideoEncodeCommandList, ::windows::core::IUnknown, super::super::Graphics::Direct3D12::ID3D12Object, super::super::Graphics::Direct3D12::ID3D12DeviceChild, super::super::Graphics::Direct3D12::ID3D12CommandList);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for ID3D12VideoEncodeCommandList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for ID3D12VideoEncodeCommandList {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for ID3D12VideoEncodeCommandList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoEncodeCommandList").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Send for ID3D12VideoEncodeCommandList {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Sync for ID3D12VideoEncodeCommandList {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::Interface for ID3D12VideoEncodeCommandList {
    type Vtable = ID3D12VideoEncodeCommandList_Vtbl;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for ID3D12VideoEncodeCommandList {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::ComInterface for ID3D12VideoEncodeCommandList {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8455293a_0cbd_4831_9b39_fbdbab724723);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoEncodeCommandList_Vtbl {
    pub base__: super::super::Graphics::Direct3D12::ID3D12CommandList_Vtbl,
    pub Close: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub Reset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pallocator: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    Reset: usize,
    pub ClearState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub ResourceBarrier: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, numbarriers: u32, pbarriers: *const super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    ResourceBarrier: usize,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub DiscardResource: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presource: *mut ::core::ffi::c_void, pregion: *const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION),
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12")))]
    DiscardResource: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub BeginQuery: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pqueryheap: *mut ::core::ffi::c_void, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    BeginQuery: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub EndQuery: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pqueryheap: *mut ::core::ffi::c_void, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    EndQuery: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub ResolveQueryData: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pqueryheap: *mut ::core::ffi::c_void, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: *mut ::core::ffi::c_void, aligneddestinationbufferoffset: u64),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    ResolveQueryData: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub SetPredication: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbuffer: *mut ::core::ffi::c_void, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    SetPredication: usize,
    pub SetMarker: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32),
    pub BeginEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32),
    pub EndEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub EstimateMotion: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pmotionestimator: *mut ::core::ffi::c_void, poutputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT, pinputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    EstimateMotion: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub ResolveMotionVectorHeap: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, poutputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT, pinputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    ResolveMotionVectorHeap: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub WriteBufferImmediate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    WriteBufferImmediate: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub SetProtectedResourceSession: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pprotectedresourcesession: *mut ::core::ffi::c_void),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    SetProtectedResourceSession: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(transparent)]
pub struct ID3D12VideoEncodeCommandList1(::windows::core::IUnknown);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoEncodeCommandList1 {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetPrivateData(&self, guid: *const ::windows::core::GUID, pdatasize: *mut u32, pdata: ::core::option::Option<*mut ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.GetPrivateData)(::windows::core::Interface::as_raw(self), guid, pdatasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateData(&self, guid: *const ::windows::core::GUID, datasize: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.SetPrivateData)(::windows::core::Interface::as_raw(self), guid, datasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateDataInterface<P0>(&self, guid: *const ::windows::core::GUID, pdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.SetPrivateDataInterface)(::windows::core::Interface::as_raw(self), guid, pdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.SetName)(::windows::core::Interface::as_raw(self), name.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetDevice<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.GetDevice)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetType(&self) -> super::super::Graphics::Direct3D12::D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self).base__.base__.GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Close)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self).base__.Reset)(::windows::core::Interface::as_raw(self), pallocator.into_param().abi()).ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self).base__.ClearState)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self).base__.ResourceBarrier)(::windows::core::Interface::as_raw(self), pbarriers.len() as _, ::core::mem::transmute(pbarriers.as_ptr()))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub unsafe fn DiscardResource<P0>(&self, presource: P0, pregion: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION>)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.DiscardResource)(::windows::core::Interface::as_raw(self), presource.into_param().abi(), ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.BeginQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.EndQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResolveQueryData<P0, P1>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: P1, aligneddestinationbufferoffset: u64)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.ResolveQueryData)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, startindex, numqueries, pdestinationbuffer.into_param().abi(), aligneddestinationbufferoffset)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPredication<P0>(&self, pbuffer: P0, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.SetPredication)(::windows::core::Interface::as_raw(self), pbuffer.into_param().abi(), alignedbufferoffset, operation)
    }
    pub unsafe fn SetMarker(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).base__.SetMarker)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn BeginEvent(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).base__.BeginEvent)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self).base__.EndEvent)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn EstimateMotion<P0>(&self, pmotionestimator: P0, poutputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT, pinputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoMotionEstimator>,
    {
        (::windows::core::Interface::vtable(self).base__.EstimateMotion)(::windows::core::Interface::as_raw(self), pmotionestimator.into_param().abi(), poutputarguments, pinputarguments)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResolveMotionVectorHeap(&self, poutputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT, pinputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT) {
        (::windows::core::Interface::vtable(self).base__.ResolveMotionVectorHeap)(::windows::core::Interface::as_raw(self), poutputarguments, pinputarguments)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn WriteBufferImmediate(&self, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE>) {
        (::windows::core::Interface::vtable(self).base__.WriteBufferImmediate)(::windows::core::Interface::as_raw(self), count, pparams, ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self).base__.SetProtectedResourceSession)(::windows::core::Interface::as_raw(self), pprotectedresourcesession.into_param().abi())
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn InitializeExtensionCommand<P0>(&self, pextensioncommand: P0, pinitializationparameters: *const ::core::ffi::c_void, initializationparameterssizeinbytes: usize)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self).InitializeExtensionCommand)(::windows::core::Interface::as_raw(self), pextensioncommand.into_param().abi(), pinitializationparameters, initializationparameterssizeinbytes)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ExecuteExtensionCommand<P0>(&self, pextensioncommand: P0, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self).ExecuteExtensionCommand)(::windows::core::Interface::as_raw(self), pextensioncommand.into_param().abi(), pexecutionparameters, executionparameterssizeinbytes)
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
::windows::imp::interface_hierarchy!(ID3D12VideoEncodeCommandList1, ::windows::core::IUnknown, super::super::Graphics::Direct3D12::ID3D12Object, super::super::Graphics::Direct3D12::ID3D12DeviceChild, super::super::Graphics::Direct3D12::ID3D12CommandList, ID3D12VideoEncodeCommandList);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for ID3D12VideoEncodeCommandList1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for ID3D12VideoEncodeCommandList1 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for ID3D12VideoEncodeCommandList1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoEncodeCommandList1").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Send for ID3D12VideoEncodeCommandList1 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Sync for ID3D12VideoEncodeCommandList1 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::Interface for ID3D12VideoEncodeCommandList1 {
    type Vtable = ID3D12VideoEncodeCommandList1_Vtbl;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for ID3D12VideoEncodeCommandList1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::ComInterface for ID3D12VideoEncodeCommandList1 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x94971eca_2bdb_4769_88cf_3675ea757ebc);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoEncodeCommandList1_Vtbl {
    pub base__: ID3D12VideoEncodeCommandList_Vtbl,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub InitializeExtensionCommand: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pextensioncommand: *mut ::core::ffi::c_void, pinitializationparameters: *const ::core::ffi::c_void, initializationparameterssizeinbytes: usize),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    InitializeExtensionCommand: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub ExecuteExtensionCommand: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pextensioncommand: *mut ::core::ffi::c_void, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    ExecuteExtensionCommand: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(transparent)]
pub struct ID3D12VideoEncodeCommandList2(::windows::core::IUnknown);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoEncodeCommandList2 {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetPrivateData(&self, guid: *const ::windows::core::GUID, pdatasize: *mut u32, pdata: ::core::option::Option<*mut ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.GetPrivateData)(::windows::core::Interface::as_raw(self), guid, pdatasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateData(&self, guid: *const ::windows::core::GUID, datasize: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.SetPrivateData)(::windows::core::Interface::as_raw(self), guid, datasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateDataInterface<P0>(&self, guid: *const ::windows::core::GUID, pdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.SetPrivateDataInterface)(::windows::core::Interface::as_raw(self), guid, pdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.SetName)(::windows::core::Interface::as_raw(self), name.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetDevice<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.GetDevice)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetType(&self) -> super::super::Graphics::Direct3D12::D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self).base__.base__.base__.GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.Close)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.Reset)(::windows::core::Interface::as_raw(self), pallocator.into_param().abi()).ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self).base__.base__.ClearState)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self).base__.base__.ResourceBarrier)(::windows::core::Interface::as_raw(self), pbarriers.len() as _, ::core::mem::transmute(pbarriers.as_ptr()))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub unsafe fn DiscardResource<P0>(&self, presource: P0, pregion: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION>)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.DiscardResource)(::windows::core::Interface::as_raw(self), presource.into_param().abi(), ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.BeginQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.EndQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResolveQueryData<P0, P1>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: P1, aligneddestinationbufferoffset: u64)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.ResolveQueryData)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, startindex, numqueries, pdestinationbuffer.into_param().abi(), aligneddestinationbufferoffset)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPredication<P0>(&self, pbuffer: P0, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.SetPredication)(::windows::core::Interface::as_raw(self), pbuffer.into_param().abi(), alignedbufferoffset, operation)
    }
    pub unsafe fn SetMarker(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).base__.base__.SetMarker)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn BeginEvent(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).base__.base__.BeginEvent)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self).base__.base__.EndEvent)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn EstimateMotion<P0>(&self, pmotionestimator: P0, poutputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT, pinputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoMotionEstimator>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.EstimateMotion)(::windows::core::Interface::as_raw(self), pmotionestimator.into_param().abi(), poutputarguments, pinputarguments)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResolveMotionVectorHeap(&self, poutputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT, pinputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT) {
        (::windows::core::Interface::vtable(self).base__.base__.ResolveMotionVectorHeap)(::windows::core::Interface::as_raw(self), poutputarguments, pinputarguments)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn WriteBufferImmediate(&self, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE>) {
        (::windows::core::Interface::vtable(self).base__.base__.WriteBufferImmediate)(::windows::core::Interface::as_raw(self), count, pparams, ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.SetProtectedResourceSession)(::windows::core::Interface::as_raw(self), pprotectedresourcesession.into_param().abi())
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn InitializeExtensionCommand<P0>(&self, pextensioncommand: P0, pinitializationparameters: *const ::core::ffi::c_void, initializationparameterssizeinbytes: usize)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self).base__.InitializeExtensionCommand)(::windows::core::Interface::as_raw(self), pextensioncommand.into_param().abi(), pinitializationparameters, initializationparameterssizeinbytes)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ExecuteExtensionCommand<P0>(&self, pextensioncommand: P0, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self).base__.ExecuteExtensionCommand)(::windows::core::Interface::as_raw(self), pextensioncommand.into_param().abi(), pexecutionparameters, executionparameterssizeinbytes)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn EncodeFrame<P0, P1>(&self, pencoder: P0, pheap: P1, pinputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS, poutputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoEncoder>,
        P1: ::windows::core::IntoParam<ID3D12VideoEncoderHeap>,
    {
        (::windows::core::Interface::vtable(self).EncodeFrame)(::windows::core::Interface::as_raw(self), pencoder.into_param().abi(), pheap.into_param().abi(), pinputarguments, poutputarguments)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn ResolveEncoderOutputMetadata(&self, pinputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS, poutputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS) {
        (::windows::core::Interface::vtable(self).ResolveEncoderOutputMetadata)(::windows::core::Interface::as_raw(self), pinputarguments, poutputarguments)
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
::windows::imp::interface_hierarchy!(ID3D12VideoEncodeCommandList2, ::windows::core::IUnknown, super::super::Graphics::Direct3D12::ID3D12Object, super::super::Graphics::Direct3D12::ID3D12DeviceChild, super::super::Graphics::Direct3D12::ID3D12CommandList, ID3D12VideoEncodeCommandList, ID3D12VideoEncodeCommandList1);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for ID3D12VideoEncodeCommandList2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for ID3D12VideoEncodeCommandList2 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for ID3D12VideoEncodeCommandList2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoEncodeCommandList2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Send for ID3D12VideoEncodeCommandList2 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Sync for ID3D12VideoEncodeCommandList2 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::Interface for ID3D12VideoEncodeCommandList2 {
    type Vtable = ID3D12VideoEncodeCommandList2_Vtbl;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for ID3D12VideoEncodeCommandList2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::ComInterface for ID3D12VideoEncodeCommandList2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x895491e2_e701_46a9_9a1f_8d3480ed867a);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoEncodeCommandList2_Vtbl {
    pub base__: ID3D12VideoEncodeCommandList1_Vtbl,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub EncodeFrame: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pencoder: *mut ::core::ffi::c_void, pheap: *mut ::core::ffi::c_void, pinputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS, poutputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS),
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common")))]
    EncodeFrame: usize,
    #[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub ResolveEncoderOutputMetadata: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pinputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS, poutputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS),
    #[cfg(not(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common")))]
    ResolveEncoderOutputMetadata: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(transparent)]
pub struct ID3D12VideoEncodeCommandList3(::windows::core::IUnknown);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoEncodeCommandList3 {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetPrivateData(&self, guid: *const ::windows::core::GUID, pdatasize: *mut u32, pdata: ::core::option::Option<*mut ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.base__.GetPrivateData)(::windows::core::Interface::as_raw(self), guid, pdatasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateData(&self, guid: *const ::windows::core::GUID, datasize: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.base__.SetPrivateData)(::windows::core::Interface::as_raw(self), guid, datasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateDataInterface<P0>(&self, guid: *const ::windows::core::GUID, pdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.base__.SetPrivateDataInterface)(::windows::core::Interface::as_raw(self), guid, pdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.base__.SetName)(::windows::core::Interface::as_raw(self), name.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetDevice<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.GetDevice)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetType(&self) -> super::super::Graphics::Direct3D12::D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.Close)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.Reset)(::windows::core::Interface::as_raw(self), pallocator.into_param().abi()).ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self).base__.base__.base__.ClearState)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self).base__.base__.base__.ResourceBarrier)(::windows::core::Interface::as_raw(self), pbarriers.len() as _, ::core::mem::transmute(pbarriers.as_ptr()))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub unsafe fn DiscardResource<P0>(&self, presource: P0, pregion: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION>)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.DiscardResource)(::windows::core::Interface::as_raw(self), presource.into_param().abi(), ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.BeginQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.EndQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResolveQueryData<P0, P1>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: P1, aligneddestinationbufferoffset: u64)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.ResolveQueryData)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, startindex, numqueries, pdestinationbuffer.into_param().abi(), aligneddestinationbufferoffset)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPredication<P0>(&self, pbuffer: P0, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPredication)(::windows::core::Interface::as_raw(self), pbuffer.into_param().abi(), alignedbufferoffset, operation)
    }
    pub unsafe fn SetMarker(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetMarker)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn BeginEvent(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).base__.base__.base__.BeginEvent)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self).base__.base__.base__.EndEvent)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn EstimateMotion<P0>(&self, pmotionestimator: P0, poutputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT, pinputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoMotionEstimator>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.EstimateMotion)(::windows::core::Interface::as_raw(self), pmotionestimator.into_param().abi(), poutputarguments, pinputarguments)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResolveMotionVectorHeap(&self, poutputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT, pinputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT) {
        (::windows::core::Interface::vtable(self).base__.base__.base__.ResolveMotionVectorHeap)(::windows::core::Interface::as_raw(self), poutputarguments, pinputarguments)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn WriteBufferImmediate(&self, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE>) {
        (::windows::core::Interface::vtable(self).base__.base__.base__.WriteBufferImmediate)(::windows::core::Interface::as_raw(self), count, pparams, ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetProtectedResourceSession)(::windows::core::Interface::as_raw(self), pprotectedresourcesession.into_param().abi())
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn InitializeExtensionCommand<P0>(&self, pextensioncommand: P0, pinitializationparameters: *const ::core::ffi::c_void, initializationparameterssizeinbytes: usize)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.InitializeExtensionCommand)(::windows::core::Interface::as_raw(self), pextensioncommand.into_param().abi(), pinitializationparameters, initializationparameterssizeinbytes)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ExecuteExtensionCommand<P0>(&self, pextensioncommand: P0, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.ExecuteExtensionCommand)(::windows::core::Interface::as_raw(self), pextensioncommand.into_param().abi(), pexecutionparameters, executionparameterssizeinbytes)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn EncodeFrame<P0, P1>(&self, pencoder: P0, pheap: P1, pinputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS, poutputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoEncoder>,
        P1: ::windows::core::IntoParam<ID3D12VideoEncoderHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.EncodeFrame)(::windows::core::Interface::as_raw(self), pencoder.into_param().abi(), pheap.into_param().abi(), pinputarguments, poutputarguments)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn ResolveEncoderOutputMetadata(&self, pinputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS, poutputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS) {
        (::windows::core::Interface::vtable(self).base__.ResolveEncoderOutputMetadata)(::windows::core::Interface::as_raw(self), pinputarguments, poutputarguments)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn Barrier(&self, pbarriergroups: &[super::super::Graphics::Direct3D12::D3D12_BARRIER_GROUP]) {
        (::windows::core::Interface::vtable(self).Barrier)(::windows::core::Interface::as_raw(self), pbarriergroups.len() as _, ::core::mem::transmute(pbarriergroups.as_ptr()))
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
::windows::imp::interface_hierarchy!(ID3D12VideoEncodeCommandList3, ::windows::core::IUnknown, super::super::Graphics::Direct3D12::ID3D12Object, super::super::Graphics::Direct3D12::ID3D12DeviceChild, super::super::Graphics::Direct3D12::ID3D12CommandList, ID3D12VideoEncodeCommandList, ID3D12VideoEncodeCommandList1, ID3D12VideoEncodeCommandList2);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for ID3D12VideoEncodeCommandList3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for ID3D12VideoEncodeCommandList3 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for ID3D12VideoEncodeCommandList3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoEncodeCommandList3").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Send for ID3D12VideoEncodeCommandList3 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Sync for ID3D12VideoEncodeCommandList3 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::Interface for ID3D12VideoEncodeCommandList3 {
    type Vtable = ID3D12VideoEncodeCommandList3_Vtbl;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for ID3D12VideoEncodeCommandList3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::ComInterface for ID3D12VideoEncodeCommandList3 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7f027b22_1515_4e85_aa0d_026486580576);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoEncodeCommandList3_Vtbl {
    pub base__: ID3D12VideoEncodeCommandList2_Vtbl,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub Barrier: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, numbarriergroups: u32, pbarriergroups: *const super::super::Graphics::Direct3D12::D3D12_BARRIER_GROUP),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    Barrier: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(transparent)]
pub struct ID3D12VideoEncoder(::windows::core::IUnknown);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoEncoder {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetPrivateData(&self, guid: *const ::windows::core::GUID, pdatasize: *mut u32, pdata: ::core::option::Option<*mut ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.GetPrivateData)(::windows::core::Interface::as_raw(self), guid, pdatasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateData(&self, guid: *const ::windows::core::GUID, datasize: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPrivateData)(::windows::core::Interface::as_raw(self), guid, datasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateDataInterface<P0>(&self, guid: *const ::windows::core::GUID, pdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPrivateDataInterface)(::windows::core::Interface::as_raw(self), guid, pdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetName)(::windows::core::Interface::as_raw(self), name.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetDevice<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.base__.GetDevice)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
    pub unsafe fn GetNodeMask(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetNodeMask)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetEncoderFlags(&self) -> D3D12_VIDEO_ENCODER_FLAGS {
        (::windows::core::Interface::vtable(self).GetEncoderFlags)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetCodec(&self) -> D3D12_VIDEO_ENCODER_CODEC {
        (::windows::core::Interface::vtable(self).GetCodec)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetCodecProfile(&self, dstprofile: D3D12_VIDEO_ENCODER_PROFILE_DESC) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetCodecProfile)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(dstprofile)).ok()
    }
    pub unsafe fn GetCodecConfiguration(&self, dstcodecconfig: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetCodecConfiguration)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(dstcodecconfig)).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(feature = "Win32_Graphics_Dxgi_Common")]
    pub unsafe fn GetInputFormat(&self) -> super::super::Graphics::Dxgi::Common::DXGI_FORMAT {
        (::windows::core::Interface::vtable(self).GetInputFormat)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetMaxMotionEstimationPrecision(&self) -> D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE {
        (::windows::core::Interface::vtable(self).GetMaxMotionEstimationPrecision)(::windows::core::Interface::as_raw(self))
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
::windows::imp::interface_hierarchy!(ID3D12VideoEncoder, ::windows::core::IUnknown, super::super::Graphics::Direct3D12::ID3D12Object, super::super::Graphics::Direct3D12::ID3D12DeviceChild, super::super::Graphics::Direct3D12::ID3D12Pageable);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for ID3D12VideoEncoder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for ID3D12VideoEncoder {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for ID3D12VideoEncoder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoEncoder").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Send for ID3D12VideoEncoder {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Sync for ID3D12VideoEncoder {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::Interface for ID3D12VideoEncoder {
    type Vtable = ID3D12VideoEncoder_Vtbl;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for ID3D12VideoEncoder {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::ComInterface for ID3D12VideoEncoder {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2e0d212d_8df9_44a6_a770_bb289b182737);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoEncoder_Vtbl {
    pub base__: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl,
    pub GetNodeMask: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetEncoderFlags: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> D3D12_VIDEO_ENCODER_FLAGS,
    pub GetCodec: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> D3D12_VIDEO_ENCODER_CODEC,
    pub GetCodecProfile: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dstprofile: D3D12_VIDEO_ENCODER_PROFILE_DESC) -> ::windows::core::HRESULT,
    pub GetCodecConfiguration: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dstcodecconfig: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Dxgi_Common")]
    pub GetInputFormat: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> super::super::Graphics::Dxgi::Common::DXGI_FORMAT,
    #[cfg(not(feature = "Win32_Graphics_Dxgi_Common"))]
    GetInputFormat: usize,
    pub GetMaxMotionEstimationPrecision: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(transparent)]
pub struct ID3D12VideoEncoderHeap(::windows::core::IUnknown);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoEncoderHeap {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetPrivateData(&self, guid: *const ::windows::core::GUID, pdatasize: *mut u32, pdata: ::core::option::Option<*mut ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.GetPrivateData)(::windows::core::Interface::as_raw(self), guid, pdatasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateData(&self, guid: *const ::windows::core::GUID, datasize: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPrivateData)(::windows::core::Interface::as_raw(self), guid, datasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateDataInterface<P0>(&self, guid: *const ::windows::core::GUID, pdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPrivateDataInterface)(::windows::core::Interface::as_raw(self), guid, pdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetName)(::windows::core::Interface::as_raw(self), name.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetDevice<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.base__.GetDevice)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
    pub unsafe fn GetNodeMask(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetNodeMask)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetEncoderHeapFlags(&self) -> D3D12_VIDEO_ENCODER_HEAP_FLAGS {
        (::windows::core::Interface::vtable(self).GetEncoderHeapFlags)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetCodec(&self) -> D3D12_VIDEO_ENCODER_CODEC {
        (::windows::core::Interface::vtable(self).GetCodec)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetCodecProfile(&self, dstprofile: D3D12_VIDEO_ENCODER_PROFILE_DESC) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetCodecProfile)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(dstprofile)).ok()
    }
    pub unsafe fn GetCodecLevel(&self, dstlevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetCodecLevel)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(dstlevel)).ok()
    }
    pub unsafe fn GetResolutionListCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetResolutionListCount)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetResolutionList(&self, presolutionlist: &mut [D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetResolutionList)(::windows::core::Interface::as_raw(self), presolutionlist.len() as _, ::core::mem::transmute(presolutionlist.as_ptr())).ok()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
::windows::imp::interface_hierarchy!(ID3D12VideoEncoderHeap, ::windows::core::IUnknown, super::super::Graphics::Direct3D12::ID3D12Object, super::super::Graphics::Direct3D12::ID3D12DeviceChild, super::super::Graphics::Direct3D12::ID3D12Pageable);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for ID3D12VideoEncoderHeap {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for ID3D12VideoEncoderHeap {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for ID3D12VideoEncoderHeap {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoEncoderHeap").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Send for ID3D12VideoEncoderHeap {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Sync for ID3D12VideoEncoderHeap {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::Interface for ID3D12VideoEncoderHeap {
    type Vtable = ID3D12VideoEncoderHeap_Vtbl;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for ID3D12VideoEncoderHeap {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::ComInterface for ID3D12VideoEncoderHeap {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x22b35d96_876a_44c0_b25e_fb8c9c7f1c4a);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoEncoderHeap_Vtbl {
    pub base__: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl,
    pub GetNodeMask: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetEncoderHeapFlags: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> D3D12_VIDEO_ENCODER_HEAP_FLAGS,
    pub GetCodec: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> D3D12_VIDEO_ENCODER_CODEC,
    pub GetCodecProfile: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dstprofile: D3D12_VIDEO_ENCODER_PROFILE_DESC) -> ::windows::core::HRESULT,
    pub GetCodecLevel: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dstlevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING) -> ::windows::core::HRESULT,
    pub GetResolutionListCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetResolutionList: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, resolutionslistcount: u32, presolutionlist: *mut D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(transparent)]
pub struct ID3D12VideoExtensionCommand(::windows::core::IUnknown);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoExtensionCommand {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetPrivateData(&self, guid: *const ::windows::core::GUID, pdatasize: *mut u32, pdata: ::core::option::Option<*mut ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.GetPrivateData)(::windows::core::Interface::as_raw(self), guid, pdatasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateData(&self, guid: *const ::windows::core::GUID, datasize: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPrivateData)(::windows::core::Interface::as_raw(self), guid, datasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateDataInterface<P0>(&self, guid: *const ::windows::core::GUID, pdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPrivateDataInterface)(::windows::core::Interface::as_raw(self), guid, pdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetName)(::windows::core::Interface::as_raw(self), name.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetDevice<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.base__.GetDevice)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
    pub unsafe fn GetDesc(&self) -> D3D12_VIDEO_EXTENSION_COMMAND_DESC {
        let mut result__: D3D12_VIDEO_EXTENSION_COMMAND_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetDesc)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
    pub unsafe fn GetProtectedResourceSession<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).GetProtectedResourceSession)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
::windows::imp::interface_hierarchy!(ID3D12VideoExtensionCommand, ::windows::core::IUnknown, super::super::Graphics::Direct3D12::ID3D12Object, super::super::Graphics::Direct3D12::ID3D12DeviceChild, super::super::Graphics::Direct3D12::ID3D12Pageable);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for ID3D12VideoExtensionCommand {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for ID3D12VideoExtensionCommand {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for ID3D12VideoExtensionCommand {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoExtensionCommand").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Send for ID3D12VideoExtensionCommand {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Sync for ID3D12VideoExtensionCommand {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::Interface for ID3D12VideoExtensionCommand {
    type Vtable = ID3D12VideoExtensionCommand_Vtbl;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for ID3D12VideoExtensionCommand {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::ComInterface for ID3D12VideoExtensionCommand {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x554e41e8_ae8e_4a8c_b7d2_5b4f274a30e4);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoExtensionCommand_Vtbl {
    pub base__: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl,
    pub GetDesc: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, result__: *mut D3D12_VIDEO_EXTENSION_COMMAND_DESC),
    pub GetProtectedResourceSession: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(transparent)]
pub struct ID3D12VideoMotionEstimator(::windows::core::IUnknown);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoMotionEstimator {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetPrivateData(&self, guid: *const ::windows::core::GUID, pdatasize: *mut u32, pdata: ::core::option::Option<*mut ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.GetPrivateData)(::windows::core::Interface::as_raw(self), guid, pdatasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateData(&self, guid: *const ::windows::core::GUID, datasize: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPrivateData)(::windows::core::Interface::as_raw(self), guid, datasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateDataInterface<P0>(&self, guid: *const ::windows::core::GUID, pdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPrivateDataInterface)(::windows::core::Interface::as_raw(self), guid, pdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetName)(::windows::core::Interface::as_raw(self), name.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetDevice<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.base__.GetDevice)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(feature = "Win32_Graphics_Dxgi_Common")]
    pub unsafe fn GetDesc(&self) -> D3D12_VIDEO_MOTION_ESTIMATOR_DESC {
        let mut result__: D3D12_VIDEO_MOTION_ESTIMATOR_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetDesc)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
    pub unsafe fn GetProtectedResourceSession<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).GetProtectedResourceSession)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
::windows::imp::interface_hierarchy!(ID3D12VideoMotionEstimator, ::windows::core::IUnknown, super::super::Graphics::Direct3D12::ID3D12Object, super::super::Graphics::Direct3D12::ID3D12DeviceChild, super::super::Graphics::Direct3D12::ID3D12Pageable);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for ID3D12VideoMotionEstimator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for ID3D12VideoMotionEstimator {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for ID3D12VideoMotionEstimator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoMotionEstimator").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Send for ID3D12VideoMotionEstimator {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Sync for ID3D12VideoMotionEstimator {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::Interface for ID3D12VideoMotionEstimator {
    type Vtable = ID3D12VideoMotionEstimator_Vtbl;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for ID3D12VideoMotionEstimator {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::ComInterface for ID3D12VideoMotionEstimator {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x33fdae0e_098b_428f_87bb_34b695de08f8);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoMotionEstimator_Vtbl {
    pub base__: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl,
    #[cfg(feature = "Win32_Graphics_Dxgi_Common")]
    pub GetDesc: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, result__: *mut D3D12_VIDEO_MOTION_ESTIMATOR_DESC),
    #[cfg(not(feature = "Win32_Graphics_Dxgi_Common"))]
    GetDesc: usize,
    pub GetProtectedResourceSession: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(transparent)]
pub struct ID3D12VideoMotionVectorHeap(::windows::core::IUnknown);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoMotionVectorHeap {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetPrivateData(&self, guid: *const ::windows::core::GUID, pdatasize: *mut u32, pdata: ::core::option::Option<*mut ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.GetPrivateData)(::windows::core::Interface::as_raw(self), guid, pdatasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateData(&self, guid: *const ::windows::core::GUID, datasize: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPrivateData)(::windows::core::Interface::as_raw(self), guid, datasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateDataInterface<P0>(&self, guid: *const ::windows::core::GUID, pdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPrivateDataInterface)(::windows::core::Interface::as_raw(self), guid, pdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetName)(::windows::core::Interface::as_raw(self), name.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetDevice<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.base__.GetDevice)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(feature = "Win32_Graphics_Dxgi_Common")]
    pub unsafe fn GetDesc(&self) -> D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC {
        let mut result__: D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetDesc)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
    pub unsafe fn GetProtectedResourceSession<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).GetProtectedResourceSession)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
::windows::imp::interface_hierarchy!(ID3D12VideoMotionVectorHeap, ::windows::core::IUnknown, super::super::Graphics::Direct3D12::ID3D12Object, super::super::Graphics::Direct3D12::ID3D12DeviceChild, super::super::Graphics::Direct3D12::ID3D12Pageable);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for ID3D12VideoMotionVectorHeap {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for ID3D12VideoMotionVectorHeap {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for ID3D12VideoMotionVectorHeap {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoMotionVectorHeap").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Send for ID3D12VideoMotionVectorHeap {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Sync for ID3D12VideoMotionVectorHeap {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::Interface for ID3D12VideoMotionVectorHeap {
    type Vtable = ID3D12VideoMotionVectorHeap_Vtbl;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for ID3D12VideoMotionVectorHeap {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::ComInterface for ID3D12VideoMotionVectorHeap {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5be17987_743a_4061_834b_23d22daea505);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoMotionVectorHeap_Vtbl {
    pub base__: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl,
    #[cfg(feature = "Win32_Graphics_Dxgi_Common")]
    pub GetDesc: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, result__: *mut D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC),
    #[cfg(not(feature = "Win32_Graphics_Dxgi_Common"))]
    GetDesc: usize,
    pub GetProtectedResourceSession: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(transparent)]
pub struct ID3D12VideoProcessCommandList(::windows::core::IUnknown);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoProcessCommandList {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetPrivateData(&self, guid: *const ::windows::core::GUID, pdatasize: *mut u32, pdata: ::core::option::Option<*mut ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.GetPrivateData)(::windows::core::Interface::as_raw(self), guid, pdatasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateData(&self, guid: *const ::windows::core::GUID, datasize: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPrivateData)(::windows::core::Interface::as_raw(self), guid, datasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateDataInterface<P0>(&self, guid: *const ::windows::core::GUID, pdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPrivateDataInterface)(::windows::core::Interface::as_raw(self), guid, pdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetName)(::windows::core::Interface::as_raw(self), name.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetDevice<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.base__.GetDevice)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetType(&self) -> super::super::Graphics::Direct3D12::D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self).base__.GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Close)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self).Reset)(::windows::core::Interface::as_raw(self), pallocator.into_param().abi()).ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self).ClearState)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self).ResourceBarrier)(::windows::core::Interface::as_raw(self), pbarriers.len() as _, ::core::mem::transmute(pbarriers.as_ptr()))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub unsafe fn DiscardResource<P0>(&self, presource: P0, pregion: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION>)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).DiscardResource)(::windows::core::Interface::as_raw(self), presource.into_param().abi(), ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).BeginQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).EndQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResolveQueryData<P0, P1>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: P1, aligneddestinationbufferoffset: u64)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).ResolveQueryData)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, startindex, numqueries, pdestinationbuffer.into_param().abi(), aligneddestinationbufferoffset)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPredication<P0>(&self, pbuffer: P0, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).SetPredication)(::windows::core::Interface::as_raw(self), pbuffer.into_param().abi(), alignedbufferoffset, operation)
    }
    pub unsafe fn SetMarker(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).SetMarker)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn BeginEvent(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).BeginEvent)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self).EndEvent)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub unsafe fn ProcessFrames<P0>(&self, pvideoprocessor: P0, poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS, pinputarguments: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS])
    where
        P0: ::windows::core::IntoParam<ID3D12VideoProcessor>,
    {
        (::windows::core::Interface::vtable(self).ProcessFrames)(::windows::core::Interface::as_raw(self), pvideoprocessor.into_param().abi(), poutputarguments, pinputarguments.len() as _, ::core::mem::transmute(pinputarguments.as_ptr()))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn WriteBufferImmediate(&self, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE>) {
        (::windows::core::Interface::vtable(self).WriteBufferImmediate)(::windows::core::Interface::as_raw(self), count, pparams, ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())))
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
::windows::imp::interface_hierarchy!(ID3D12VideoProcessCommandList, ::windows::core::IUnknown, super::super::Graphics::Direct3D12::ID3D12Object, super::super::Graphics::Direct3D12::ID3D12DeviceChild, super::super::Graphics::Direct3D12::ID3D12CommandList);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for ID3D12VideoProcessCommandList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for ID3D12VideoProcessCommandList {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for ID3D12VideoProcessCommandList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoProcessCommandList").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Send for ID3D12VideoProcessCommandList {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Sync for ID3D12VideoProcessCommandList {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::Interface for ID3D12VideoProcessCommandList {
    type Vtable = ID3D12VideoProcessCommandList_Vtbl;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for ID3D12VideoProcessCommandList {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::ComInterface for ID3D12VideoProcessCommandList {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xaeb2543a_167f_4682_acc8_d159ed4a6209);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoProcessCommandList_Vtbl {
    pub base__: super::super::Graphics::Direct3D12::ID3D12CommandList_Vtbl,
    pub Close: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub Reset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pallocator: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    Reset: usize,
    pub ClearState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub ResourceBarrier: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, numbarriers: u32, pbarriers: *const super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    ResourceBarrier: usize,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub DiscardResource: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presource: *mut ::core::ffi::c_void, pregion: *const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION),
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12")))]
    DiscardResource: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub BeginQuery: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pqueryheap: *mut ::core::ffi::c_void, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    BeginQuery: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub EndQuery: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pqueryheap: *mut ::core::ffi::c_void, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    EndQuery: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub ResolveQueryData: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pqueryheap: *mut ::core::ffi::c_void, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: *mut ::core::ffi::c_void, aligneddestinationbufferoffset: u64),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    ResolveQueryData: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub SetPredication: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbuffer: *mut ::core::ffi::c_void, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    SetPredication: usize,
    pub SetMarker: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32),
    pub BeginEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32),
    pub EndEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub ProcessFrames: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pvideoprocessor: *mut ::core::ffi::c_void, poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS, numinputstreams: u32, pinputarguments: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS),
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12")))]
    ProcessFrames: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub WriteBufferImmediate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    WriteBufferImmediate: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(transparent)]
pub struct ID3D12VideoProcessCommandList1(::windows::core::IUnknown);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoProcessCommandList1 {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetPrivateData(&self, guid: *const ::windows::core::GUID, pdatasize: *mut u32, pdata: ::core::option::Option<*mut ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.GetPrivateData)(::windows::core::Interface::as_raw(self), guid, pdatasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateData(&self, guid: *const ::windows::core::GUID, datasize: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.SetPrivateData)(::windows::core::Interface::as_raw(self), guid, datasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateDataInterface<P0>(&self, guid: *const ::windows::core::GUID, pdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.SetPrivateDataInterface)(::windows::core::Interface::as_raw(self), guid, pdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.SetName)(::windows::core::Interface::as_raw(self), name.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetDevice<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.GetDevice)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetType(&self) -> super::super::Graphics::Direct3D12::D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self).base__.base__.GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Close)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self).base__.Reset)(::windows::core::Interface::as_raw(self), pallocator.into_param().abi()).ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self).base__.ClearState)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self).base__.ResourceBarrier)(::windows::core::Interface::as_raw(self), pbarriers.len() as _, ::core::mem::transmute(pbarriers.as_ptr()))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub unsafe fn DiscardResource<P0>(&self, presource: P0, pregion: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION>)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.DiscardResource)(::windows::core::Interface::as_raw(self), presource.into_param().abi(), ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.BeginQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.EndQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResolveQueryData<P0, P1>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: P1, aligneddestinationbufferoffset: u64)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.ResolveQueryData)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, startindex, numqueries, pdestinationbuffer.into_param().abi(), aligneddestinationbufferoffset)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPredication<P0>(&self, pbuffer: P0, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.SetPredication)(::windows::core::Interface::as_raw(self), pbuffer.into_param().abi(), alignedbufferoffset, operation)
    }
    pub unsafe fn SetMarker(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).base__.SetMarker)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn BeginEvent(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).base__.BeginEvent)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self).base__.EndEvent)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub unsafe fn ProcessFrames<P0>(&self, pvideoprocessor: P0, poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS, pinputarguments: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS])
    where
        P0: ::windows::core::IntoParam<ID3D12VideoProcessor>,
    {
        (::windows::core::Interface::vtable(self).base__.ProcessFrames)(::windows::core::Interface::as_raw(self), pvideoprocessor.into_param().abi(), poutputarguments, pinputarguments.len() as _, ::core::mem::transmute(pinputarguments.as_ptr()))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn WriteBufferImmediate(&self, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE>) {
        (::windows::core::Interface::vtable(self).base__.WriteBufferImmediate)(::windows::core::Interface::as_raw(self), count, pparams, ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub unsafe fn ProcessFrames1<P0>(&self, pvideoprocessor: P0, poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS, pinputarguments: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1])
    where
        P0: ::windows::core::IntoParam<ID3D12VideoProcessor>,
    {
        (::windows::core::Interface::vtable(self).ProcessFrames1)(::windows::core::Interface::as_raw(self), pvideoprocessor.into_param().abi(), poutputarguments, pinputarguments.len() as _, ::core::mem::transmute(pinputarguments.as_ptr()))
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
::windows::imp::interface_hierarchy!(ID3D12VideoProcessCommandList1, ::windows::core::IUnknown, super::super::Graphics::Direct3D12::ID3D12Object, super::super::Graphics::Direct3D12::ID3D12DeviceChild, super::super::Graphics::Direct3D12::ID3D12CommandList, ID3D12VideoProcessCommandList);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for ID3D12VideoProcessCommandList1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for ID3D12VideoProcessCommandList1 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for ID3D12VideoProcessCommandList1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoProcessCommandList1").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Send for ID3D12VideoProcessCommandList1 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Sync for ID3D12VideoProcessCommandList1 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::Interface for ID3D12VideoProcessCommandList1 {
    type Vtable = ID3D12VideoProcessCommandList1_Vtbl;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for ID3D12VideoProcessCommandList1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::ComInterface for ID3D12VideoProcessCommandList1 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x542c5c4d_7596_434f_8c93_4efa6766f267);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoProcessCommandList1_Vtbl {
    pub base__: ID3D12VideoProcessCommandList_Vtbl,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub ProcessFrames1: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pvideoprocessor: *mut ::core::ffi::c_void, poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS, numinputstreams: u32, pinputarguments: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1),
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12")))]
    ProcessFrames1: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(transparent)]
pub struct ID3D12VideoProcessCommandList2(::windows::core::IUnknown);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoProcessCommandList2 {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetPrivateData(&self, guid: *const ::windows::core::GUID, pdatasize: *mut u32, pdata: ::core::option::Option<*mut ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.GetPrivateData)(::windows::core::Interface::as_raw(self), guid, pdatasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateData(&self, guid: *const ::windows::core::GUID, datasize: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.SetPrivateData)(::windows::core::Interface::as_raw(self), guid, datasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateDataInterface<P0>(&self, guid: *const ::windows::core::GUID, pdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.SetPrivateDataInterface)(::windows::core::Interface::as_raw(self), guid, pdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.SetName)(::windows::core::Interface::as_raw(self), name.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetDevice<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.GetDevice)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetType(&self) -> super::super::Graphics::Direct3D12::D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self).base__.base__.base__.GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.Close)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.Reset)(::windows::core::Interface::as_raw(self), pallocator.into_param().abi()).ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self).base__.base__.ClearState)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self).base__.base__.ResourceBarrier)(::windows::core::Interface::as_raw(self), pbarriers.len() as _, ::core::mem::transmute(pbarriers.as_ptr()))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub unsafe fn DiscardResource<P0>(&self, presource: P0, pregion: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION>)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.DiscardResource)(::windows::core::Interface::as_raw(self), presource.into_param().abi(), ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.BeginQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.EndQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResolveQueryData<P0, P1>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: P1, aligneddestinationbufferoffset: u64)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.ResolveQueryData)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, startindex, numqueries, pdestinationbuffer.into_param().abi(), aligneddestinationbufferoffset)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPredication<P0>(&self, pbuffer: P0, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.SetPredication)(::windows::core::Interface::as_raw(self), pbuffer.into_param().abi(), alignedbufferoffset, operation)
    }
    pub unsafe fn SetMarker(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).base__.base__.SetMarker)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn BeginEvent(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).base__.base__.BeginEvent)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self).base__.base__.EndEvent)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub unsafe fn ProcessFrames<P0>(&self, pvideoprocessor: P0, poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS, pinputarguments: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS])
    where
        P0: ::windows::core::IntoParam<ID3D12VideoProcessor>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.ProcessFrames)(::windows::core::Interface::as_raw(self), pvideoprocessor.into_param().abi(), poutputarguments, pinputarguments.len() as _, ::core::mem::transmute(pinputarguments.as_ptr()))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn WriteBufferImmediate(&self, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE>) {
        (::windows::core::Interface::vtable(self).base__.base__.WriteBufferImmediate)(::windows::core::Interface::as_raw(self), count, pparams, ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub unsafe fn ProcessFrames1<P0>(&self, pvideoprocessor: P0, poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS, pinputarguments: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1])
    where
        P0: ::windows::core::IntoParam<ID3D12VideoProcessor>,
    {
        (::windows::core::Interface::vtable(self).base__.ProcessFrames1)(::windows::core::Interface::as_raw(self), pvideoprocessor.into_param().abi(), poutputarguments, pinputarguments.len() as _, ::core::mem::transmute(pinputarguments.as_ptr()))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self).SetProtectedResourceSession)(::windows::core::Interface::as_raw(self), pprotectedresourcesession.into_param().abi())
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn InitializeExtensionCommand<P0>(&self, pextensioncommand: P0, pinitializationparameters: *const ::core::ffi::c_void, initializationparameterssizeinbytes: usize)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self).InitializeExtensionCommand)(::windows::core::Interface::as_raw(self), pextensioncommand.into_param().abi(), pinitializationparameters, initializationparameterssizeinbytes)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ExecuteExtensionCommand<P0>(&self, pextensioncommand: P0, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self).ExecuteExtensionCommand)(::windows::core::Interface::as_raw(self), pextensioncommand.into_param().abi(), pexecutionparameters, executionparameterssizeinbytes)
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
::windows::imp::interface_hierarchy!(ID3D12VideoProcessCommandList2, ::windows::core::IUnknown, super::super::Graphics::Direct3D12::ID3D12Object, super::super::Graphics::Direct3D12::ID3D12DeviceChild, super::super::Graphics::Direct3D12::ID3D12CommandList, ID3D12VideoProcessCommandList, ID3D12VideoProcessCommandList1);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for ID3D12VideoProcessCommandList2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for ID3D12VideoProcessCommandList2 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for ID3D12VideoProcessCommandList2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoProcessCommandList2").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Send for ID3D12VideoProcessCommandList2 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Sync for ID3D12VideoProcessCommandList2 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::Interface for ID3D12VideoProcessCommandList2 {
    type Vtable = ID3D12VideoProcessCommandList2_Vtbl;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for ID3D12VideoProcessCommandList2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::ComInterface for ID3D12VideoProcessCommandList2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdb525ae4_6ad6_473c_baa7_59b2e37082e4);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoProcessCommandList2_Vtbl {
    pub base__: ID3D12VideoProcessCommandList1_Vtbl,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub SetProtectedResourceSession: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pprotectedresourcesession: *mut ::core::ffi::c_void),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    SetProtectedResourceSession: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub InitializeExtensionCommand: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pextensioncommand: *mut ::core::ffi::c_void, pinitializationparameters: *const ::core::ffi::c_void, initializationparameterssizeinbytes: usize),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    InitializeExtensionCommand: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub ExecuteExtensionCommand: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pextensioncommand: *mut ::core::ffi::c_void, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    ExecuteExtensionCommand: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(transparent)]
pub struct ID3D12VideoProcessCommandList3(::windows::core::IUnknown);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoProcessCommandList3 {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetPrivateData(&self, guid: *const ::windows::core::GUID, pdatasize: *mut u32, pdata: ::core::option::Option<*mut ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.base__.GetPrivateData)(::windows::core::Interface::as_raw(self), guid, pdatasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateData(&self, guid: *const ::windows::core::GUID, datasize: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.base__.SetPrivateData)(::windows::core::Interface::as_raw(self), guid, datasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateDataInterface<P0>(&self, guid: *const ::windows::core::GUID, pdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.base__.SetPrivateDataInterface)(::windows::core::Interface::as_raw(self), guid, pdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.base__.SetName)(::windows::core::Interface::as_raw(self), name.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetDevice<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.base__.GetDevice)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetType(&self) -> super::super::Graphics::Direct3D12::D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.Close)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.Reset)(::windows::core::Interface::as_raw(self), pallocator.into_param().abi()).ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self).base__.base__.base__.ClearState)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self).base__.base__.base__.ResourceBarrier)(::windows::core::Interface::as_raw(self), pbarriers.len() as _, ::core::mem::transmute(pbarriers.as_ptr()))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub unsafe fn DiscardResource<P0>(&self, presource: P0, pregion: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION>)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.DiscardResource)(::windows::core::Interface::as_raw(self), presource.into_param().abi(), ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.BeginQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.EndQuery)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, index)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ResolveQueryData<P0, P1>(&self, pqueryheap: P0, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: P1, aligneddestinationbufferoffset: u64)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.ResolveQueryData)(::windows::core::Interface::as_raw(self), pqueryheap.into_param().abi(), r#type, startindex, numqueries, pdestinationbuffer.into_param().abi(), aligneddestinationbufferoffset)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPredication<P0>(&self, pbuffer: P0, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPredication)(::windows::core::Interface::as_raw(self), pbuffer.into_param().abi(), alignedbufferoffset, operation)
    }
    pub unsafe fn SetMarker(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetMarker)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn BeginEvent(&self, metadata: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>, size: u32) {
        (::windows::core::Interface::vtable(self).base__.base__.base__.BeginEvent)(::windows::core::Interface::as_raw(self), metadata, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())), size)
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self).base__.base__.base__.EndEvent)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub unsafe fn ProcessFrames<P0>(&self, pvideoprocessor: P0, poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS, pinputarguments: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS])
    where
        P0: ::windows::core::IntoParam<ID3D12VideoProcessor>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.ProcessFrames)(::windows::core::Interface::as_raw(self), pvideoprocessor.into_param().abi(), poutputarguments, pinputarguments.len() as _, ::core::mem::transmute(pinputarguments.as_ptr()))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn WriteBufferImmediate(&self, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: ::core::option::Option<*const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE>) {
        (::windows::core::Interface::vtable(self).base__.base__.base__.WriteBufferImmediate)(::windows::core::Interface::as_raw(self), count, pparams, ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
    pub unsafe fn ProcessFrames1<P0>(&self, pvideoprocessor: P0, poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS, pinputarguments: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1])
    where
        P0: ::windows::core::IntoParam<ID3D12VideoProcessor>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.ProcessFrames1)(::windows::core::Interface::as_raw(self), pvideoprocessor.into_param().abi(), poutputarguments, pinputarguments.len() as _, ::core::mem::transmute(pinputarguments.as_ptr()))
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self).base__.SetProtectedResourceSession)(::windows::core::Interface::as_raw(self), pprotectedresourcesession.into_param().abi())
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn InitializeExtensionCommand<P0>(&self, pextensioncommand: P0, pinitializationparameters: *const ::core::ffi::c_void, initializationparameterssizeinbytes: usize)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self).base__.InitializeExtensionCommand)(::windows::core::Interface::as_raw(self), pextensioncommand.into_param().abi(), pinitializationparameters, initializationparameterssizeinbytes)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn ExecuteExtensionCommand<P0>(&self, pextensioncommand: P0, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize)
    where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self).base__.ExecuteExtensionCommand)(::windows::core::Interface::as_raw(self), pextensioncommand.into_param().abi(), pexecutionparameters, executionparameterssizeinbytes)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn Barrier(&self, pbarriergroups: &[super::super::Graphics::Direct3D12::D3D12_BARRIER_GROUP]) {
        (::windows::core::Interface::vtable(self).Barrier)(::windows::core::Interface::as_raw(self), pbarriergroups.len() as _, ::core::mem::transmute(pbarriergroups.as_ptr()))
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
::windows::imp::interface_hierarchy!(ID3D12VideoProcessCommandList3, ::windows::core::IUnknown, super::super::Graphics::Direct3D12::ID3D12Object, super::super::Graphics::Direct3D12::ID3D12DeviceChild, super::super::Graphics::Direct3D12::ID3D12CommandList, ID3D12VideoProcessCommandList, ID3D12VideoProcessCommandList1, ID3D12VideoProcessCommandList2);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for ID3D12VideoProcessCommandList3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for ID3D12VideoProcessCommandList3 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for ID3D12VideoProcessCommandList3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoProcessCommandList3").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Send for ID3D12VideoProcessCommandList3 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Sync for ID3D12VideoProcessCommandList3 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::Interface for ID3D12VideoProcessCommandList3 {
    type Vtable = ID3D12VideoProcessCommandList3_Vtbl;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for ID3D12VideoProcessCommandList3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::ComInterface for ID3D12VideoProcessCommandList3 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1a0a4ca4_9f08_40ce_9558_b411fd2666ff);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoProcessCommandList3_Vtbl {
    pub base__: ID3D12VideoProcessCommandList2_Vtbl,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub Barrier: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, numbarriergroups: u32, pbarriergroups: *const super::super::Graphics::Direct3D12::D3D12_BARRIER_GROUP),
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    Barrier: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(transparent)]
pub struct ID3D12VideoProcessor(::windows::core::IUnknown);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoProcessor {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetPrivateData(&self, guid: *const ::windows::core::GUID, pdatasize: *mut u32, pdata: ::core::option::Option<*mut ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.GetPrivateData)(::windows::core::Interface::as_raw(self), guid, pdatasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateData(&self, guid: *const ::windows::core::GUID, datasize: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPrivateData)(::windows::core::Interface::as_raw(self), guid, datasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateDataInterface<P0>(&self, guid: *const ::windows::core::GUID, pdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetPrivateDataInterface)(::windows::core::Interface::as_raw(self), guid, pdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.SetName)(::windows::core::Interface::as_raw(self), name.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetDevice<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.base__.GetDevice)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
    pub unsafe fn GetNodeMask(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetNodeMask)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetNumInputStreamDescs(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetNumInputStreamDescs)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn GetInputStreamDescs(&self, pinputstreamdescs: &mut [D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetInputStreamDescs)(::windows::core::Interface::as_raw(self), pinputstreamdescs.len() as _, ::core::mem::transmute(pinputstreamdescs.as_ptr())).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn GetOutputStreamDesc(&self) -> D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC {
        let mut result__: D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetOutputStreamDesc)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
::windows::imp::interface_hierarchy!(ID3D12VideoProcessor, ::windows::core::IUnknown, super::super::Graphics::Direct3D12::ID3D12Object, super::super::Graphics::Direct3D12::ID3D12DeviceChild, super::super::Graphics::Direct3D12::ID3D12Pageable);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for ID3D12VideoProcessor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for ID3D12VideoProcessor {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for ID3D12VideoProcessor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoProcessor").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Send for ID3D12VideoProcessor {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Sync for ID3D12VideoProcessor {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::Interface for ID3D12VideoProcessor {
    type Vtable = ID3D12VideoProcessor_Vtbl;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for ID3D12VideoProcessor {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::ComInterface for ID3D12VideoProcessor {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x304fdb32_bede_410a_8545_943ac6a46138);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoProcessor_Vtbl {
    pub base__: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl,
    pub GetNodeMask: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetNumInputStreamDescs: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
    pub GetInputStreamDescs: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, numinputstreamdescs: u32, pinputstreamdescs: *mut D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common")))]
    GetInputStreamDescs: usize,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
    pub GetOutputStreamDesc: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, result__: *mut D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC),
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common")))]
    GetOutputStreamDesc: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(transparent)]
pub struct ID3D12VideoProcessor1(::windows::core::IUnknown);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoProcessor1 {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetPrivateData(&self, guid: *const ::windows::core::GUID, pdatasize: *mut u32, pdata: ::core::option::Option<*mut ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.GetPrivateData)(::windows::core::Interface::as_raw(self), guid, pdatasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateData(&self, guid: *const ::windows::core::GUID, datasize: u32, pdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.SetPrivateData)(::windows::core::Interface::as_raw(self), guid, datasize, ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetPrivateDataInterface<P0>(&self, guid: *const ::windows::core::GUID, pdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.SetPrivateDataInterface)(::windows::core::Interface::as_raw(self), guid, pdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.base__.SetName)(::windows::core::Interface::as_raw(self), name.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn GetDevice<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.GetDevice)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
    pub unsafe fn GetNodeMask(&self) -> u32 {
        (::windows::core::Interface::vtable(self).base__.GetNodeMask)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetNumInputStreamDescs(&self) -> u32 {
        (::windows::core::Interface::vtable(self).base__.GetNumInputStreamDescs)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn GetInputStreamDescs(&self, pinputstreamdescs: &mut [D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetInputStreamDescs)(::windows::core::Interface::as_raw(self), pinputstreamdescs.len() as _, ::core::mem::transmute(pinputstreamdescs.as_ptr())).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
    pub unsafe fn GetOutputStreamDesc(&self) -> D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC {
        let mut result__: D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).base__.GetOutputStreamDesc)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
    pub unsafe fn GetProtectedResourceSession<T>(&self, result__: *mut ::core::option::Option<T>) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).GetProtectedResourceSession)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, result__ as *mut _ as *mut _).ok()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
::windows::imp::interface_hierarchy!(ID3D12VideoProcessor1, ::windows::core::IUnknown, super::super::Graphics::Direct3D12::ID3D12Object, super::super::Graphics::Direct3D12::ID3D12DeviceChild, super::super::Graphics::Direct3D12::ID3D12Pageable, ID3D12VideoProcessor);
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for ID3D12VideoProcessor1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for ID3D12VideoProcessor1 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for ID3D12VideoProcessor1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoProcessor1").field(&self.0).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Send for ID3D12VideoProcessor1 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::core::marker::Sync for ID3D12VideoProcessor1 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::Interface for ID3D12VideoProcessor1 {
    type Vtable = ID3D12VideoProcessor1_Vtbl;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for ID3D12VideoProcessor1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
unsafe impl ::windows::core::ComInterface for ID3D12VideoProcessor1 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf3cfe615_553f_425c_86d8_ee8c1b1fb01c);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoProcessor1_Vtbl {
    pub base__: ID3D12VideoProcessor_Vtbl,
    pub GetProtectedResourceSession: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IDXVAHD_Device(::windows::core::IUnknown);
impl IDXVAHD_Device {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
    pub unsafe fn CreateVideoSurface(&self, width: u32, height: u32, format: super::super::Graphics::Direct3D9::D3DFORMAT, pool: super::super::Graphics::Direct3D9::D3DPOOL, usage: u32, r#type: DXVAHD_SURFACE_TYPE, ppsurfaces: &mut [::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>], psharedhandle: ::core::option::Option<*mut super::super::Foundation::HANDLE>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).CreateVideoSurface)(::windows::core::Interface::as_raw(self), width, height, format, pool, usage, r#type, ppsurfaces.len() as _, ::core::mem::transmute(ppsurfaces.as_ptr()), ::core::mem::transmute(psharedhandle.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn GetVideoProcessorDeviceCaps(&self, pcaps: *mut DXVAHD_VPDEVCAPS) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetVideoProcessorDeviceCaps)(::windows::core::Interface::as_raw(self), pcaps).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn GetVideoProcessorOutputFormats(&self, pformats: &mut [super::super::Graphics::Direct3D9::D3DFORMAT]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetVideoProcessorOutputFormats)(::windows::core::Interface::as_raw(self), pformats.len() as _, ::core::mem::transmute(pformats.as_ptr())).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn GetVideoProcessorInputFormats(&self, pformats: &mut [super::super::Graphics::Direct3D9::D3DFORMAT]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetVideoProcessorInputFormats)(::windows::core::Interface::as_raw(self), pformats.len() as _, ::core::mem::transmute(pformats.as_ptr())).ok()
    }
    pub unsafe fn GetVideoProcessorCaps(&self, pcaps: &mut [DXVAHD_VPCAPS]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetVideoProcessorCaps)(::windows::core::Interface::as_raw(self), pcaps.len() as _, ::core::mem::transmute(pcaps.as_ptr())).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetVideoProcessorCustomRates(&self, pvpguid: *const ::windows::core::GUID, prates: &mut [DXVAHD_CUSTOM_RATE_DATA]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetVideoProcessorCustomRates)(::windows::core::Interface::as_raw(self), pvpguid, prates.len() as _, ::core::mem::transmute(prates.as_ptr())).ok()
    }
    pub unsafe fn GetVideoProcessorFilterRange(&self, filter: DXVAHD_FILTER) -> ::windows::core::Result<DXVAHD_FILTER_RANGE_DATA> {
        let mut result__ = ::windows::core::zeroed::<DXVAHD_FILTER_RANGE_DATA>();
        (::windows::core::Interface::vtable(self).GetVideoProcessorFilterRange)(::windows::core::Interface::as_raw(self), filter, &mut result__).from_abi(result__)
    }
    pub unsafe fn CreateVideoProcessor(&self, pvpguid: *const ::windows::core::GUID) -> ::windows::core::Result<IDXVAHD_VideoProcessor> {
        let mut result__ = ::windows::core::zeroed::<IDXVAHD_VideoProcessor>();
        (::windows::core::Interface::vtable(self).CreateVideoProcessor)(::windows::core::Interface::as_raw(self), pvpguid, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IDXVAHD_Device, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IDXVAHD_Device {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDXVAHD_Device {}
impl ::core::fmt::Debug for IDXVAHD_Device {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDXVAHD_Device").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IDXVAHD_Device {
    type Vtable = IDXVAHD_Device_Vtbl;
}
impl ::core::clone::Clone for IDXVAHD_Device {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IDXVAHD_Device {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x95f12dfd_d77e_49be_815f_57d579634d6d);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDXVAHD_Device_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
    pub CreateVideoSurface: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, width: u32, height: u32, format: super::super::Graphics::Direct3D9::D3DFORMAT, pool: super::super::Graphics::Direct3D9::D3DPOOL, usage: u32, r#type: DXVAHD_SURFACE_TYPE, numsurfaces: u32, ppsurfaces: *mut *mut ::core::ffi::c_void, psharedhandle: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9")))]
    CreateVideoSurface: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub GetVideoProcessorDeviceCaps: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcaps: *mut DXVAHD_VPDEVCAPS) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    GetVideoProcessorDeviceCaps: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub GetVideoProcessorOutputFormats: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, count: u32, pformats: *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    GetVideoProcessorOutputFormats: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub GetVideoProcessorInputFormats: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, count: u32, pformats: *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    GetVideoProcessorInputFormats: usize,
    pub GetVideoProcessorCaps: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, count: u32, pcaps: *mut DXVAHD_VPCAPS) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub GetVideoProcessorCustomRates: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pvpguid: *const ::windows::core::GUID, count: u32, prates: *mut DXVAHD_CUSTOM_RATE_DATA) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetVideoProcessorCustomRates: usize,
    pub GetVideoProcessorFilterRange: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, filter: DXVAHD_FILTER, prange: *mut DXVAHD_FILTER_RANGE_DATA) -> ::windows::core::HRESULT,
    pub CreateVideoProcessor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pvpguid: *const ::windows::core::GUID, ppvideoprocessor: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IDXVAHD_VideoProcessor(::windows::core::IUnknown);
impl IDXVAHD_VideoProcessor {
    pub unsafe fn SetVideoProcessBltState(&self, state: DXVAHD_BLT_STATE, datasize: u32, pdata: *const ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetVideoProcessBltState)(::windows::core::Interface::as_raw(self), state, datasize, pdata).ok()
    }
    pub unsafe fn GetVideoProcessBltState(&self, state: DXVAHD_BLT_STATE, datasize: u32, pdata: *mut ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetVideoProcessBltState)(::windows::core::Interface::as_raw(self), state, datasize, pdata).ok()
    }
    pub unsafe fn SetVideoProcessStreamState(&self, streamnumber: u32, state: DXVAHD_STREAM_STATE, datasize: u32, pdata: *const ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetVideoProcessStreamState)(::windows::core::Interface::as_raw(self), streamnumber, state, datasize, pdata).ok()
    }
    pub unsafe fn GetVideoProcessStreamState(&self, streamnumber: u32, state: DXVAHD_STREAM_STATE, datasize: u32, pdata: *mut ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetVideoProcessStreamState)(::windows::core::Interface::as_raw(self), streamnumber, state, datasize, pdata).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
    pub unsafe fn VideoProcessBltHD<P0>(&self, poutputsurface: P0, outputframe: u32, pstreams: &[DXVAHD_STREAM_DATA]) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D9::IDirect3DSurface9>,
    {
        (::windows::core::Interface::vtable(self).VideoProcessBltHD)(::windows::core::Interface::as_raw(self), poutputsurface.into_param().abi(), outputframe, pstreams.len() as _, ::core::mem::transmute(pstreams.as_ptr())).ok()
    }
}
::windows::imp::interface_hierarchy!(IDXVAHD_VideoProcessor, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IDXVAHD_VideoProcessor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDXVAHD_VideoProcessor {}
impl ::core::fmt::Debug for IDXVAHD_VideoProcessor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDXVAHD_VideoProcessor").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IDXVAHD_VideoProcessor {
    type Vtable = IDXVAHD_VideoProcessor_Vtbl;
}
impl ::core::clone::Clone for IDXVAHD_VideoProcessor {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IDXVAHD_VideoProcessor {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x95f4edf4_6e03_4cd7_be1b_3075d665aa52);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDXVAHD_VideoProcessor_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetVideoProcessBltState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, state: DXVAHD_BLT_STATE, datasize: u32, pdata: *const ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetVideoProcessBltState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, state: DXVAHD_BLT_STATE, datasize: u32, pdata: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetVideoProcessStreamState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, streamnumber: u32, state: DXVAHD_STREAM_STATE, datasize: u32, pdata: *const ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetVideoProcessStreamState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, streamnumber: u32, state: DXVAHD_STREAM_STATE, datasize: u32, pdata: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
    pub VideoProcessBltHD: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, poutputsurface: *mut ::core::ffi::c_void, outputframe: u32, streamcount: u32, pstreams: *const DXVAHD_STREAM_DATA) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9")))]
    VideoProcessBltHD: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IDirect3D9ExOverlayExtension(::windows::core::IUnknown);
impl IDirect3D9ExOverlayExtension {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn CheckDeviceOverlayType(&self, adapter: u32, devtype: super::super::Graphics::Direct3D9::D3DDEVTYPE, overlaywidth: u32, overlayheight: u32, overlayformat: super::super::Graphics::Direct3D9::D3DFORMAT, pdisplaymode: *mut super::super::Graphics::Direct3D9::D3DDISPLAYMODEEX, displayrotation: super::super::Graphics::Direct3D9::D3DDISPLAYROTATION, poverlaycaps: *mut D3DOVERLAYCAPS) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).CheckDeviceOverlayType)(::windows::core::Interface::as_raw(self), adapter, devtype, overlaywidth, overlayheight, overlayformat, pdisplaymode, displayrotation, poverlaycaps).ok()
    }
}
::windows::imp::interface_hierarchy!(IDirect3D9ExOverlayExtension, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IDirect3D9ExOverlayExtension {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirect3D9ExOverlayExtension {}
impl ::core::fmt::Debug for IDirect3D9ExOverlayExtension {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirect3D9ExOverlayExtension").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IDirect3D9ExOverlayExtension {
    type Vtable = IDirect3D9ExOverlayExtension_Vtbl;
}
impl ::core::clone::Clone for IDirect3D9ExOverlayExtension {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IDirect3D9ExOverlayExtension {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x187aeb13_aaf5_4c59_876d_e059088c0df8);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDirect3D9ExOverlayExtension_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub CheckDeviceOverlayType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, adapter: u32, devtype: super::super::Graphics::Direct3D9::D3DDEVTYPE, overlaywidth: u32, overlayheight: u32, overlayformat: super::super::Graphics::Direct3D9::D3DFORMAT, pdisplaymode: *mut super::super::Graphics::Direct3D9::D3DDISPLAYMODEEX, displayrotation: super::super::Graphics::Direct3D9::D3DDISPLAYROTATION, poverlaycaps: *mut D3DOVERLAYCAPS) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    CheckDeviceOverlayType: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IDirect3DAuthenticatedChannel9(::windows::core::IUnknown);
impl IDirect3DAuthenticatedChannel9 {
    pub unsafe fn GetCertificateSize(&self, pcertificatesize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetCertificateSize)(::windows::core::Interface::as_raw(self), pcertificatesize).ok()
    }
    pub unsafe fn GetCertificate(&self, certifactesize: u32, ppcertificate: *mut u8) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetCertificate)(::windows::core::Interface::as_raw(self), certifactesize, ppcertificate).ok()
    }
    pub unsafe fn NegotiateKeyExchange(&self, datasize: u32, pdata: *mut ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).NegotiateKeyExchange)(::windows::core::Interface::as_raw(self), datasize, pdata).ok()
    }
    pub unsafe fn Query(&self, inputsize: u32, pinput: *const ::core::ffi::c_void, outputsize: u32, poutput: *mut ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Query)(::windows::core::Interface::as_raw(self), inputsize, pinput, outputsize, poutput).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
    pub unsafe fn Configure(&self, inputsize: u32, pinput: *const ::core::ffi::c_void, poutput: *mut super::super::Graphics::Direct3D9::D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Configure)(::windows::core::Interface::as_raw(self), inputsize, pinput, poutput).ok()
    }
}
::windows::imp::interface_hierarchy!(IDirect3DAuthenticatedChannel9, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IDirect3DAuthenticatedChannel9 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirect3DAuthenticatedChannel9 {}
impl ::core::fmt::Debug for IDirect3DAuthenticatedChannel9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirect3DAuthenticatedChannel9").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IDirect3DAuthenticatedChannel9 {
    type Vtable = IDirect3DAuthenticatedChannel9_Vtbl;
}
impl ::core::clone::Clone for IDirect3DAuthenticatedChannel9 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IDirect3DAuthenticatedChannel9 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xff24beee_da21_4beb_98b5_d2f899f98af9);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDirect3DAuthenticatedChannel9_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetCertificateSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcertificatesize: *mut u32) -> ::windows::core::HRESULT,
    pub GetCertificate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, certifactesize: u32, ppcertificate: *mut u8) -> ::windows::core::HRESULT,
    pub NegotiateKeyExchange: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, datasize: u32, pdata: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Query: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, inputsize: u32, pinput: *const ::core::ffi::c_void, outputsize: u32, poutput: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
    pub Configure: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, inputsize: u32, pinput: *const ::core::ffi::c_void, poutput: *mut super::super::Graphics::Direct3D9::D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9")))]
    Configure: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IDirect3DCryptoSession9(::windows::core::IUnknown);
impl IDirect3DCryptoSession9 {
    pub unsafe fn GetCertificateSize(&self, pcertificatesize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetCertificateSize)(::windows::core::Interface::as_raw(self), pcertificatesize).ok()
    }
    pub unsafe fn GetCertificate(&self, certifactesize: u32, ppcertificate: *mut u8) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetCertificate)(::windows::core::Interface::as_raw(self), certifactesize, ppcertificate).ok()
    }
    pub unsafe fn NegotiateKeyExchange(&self, datasize: u32, pdata: *mut ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).NegotiateKeyExchange)(::windows::core::Interface::as_raw(self), datasize, pdata).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn EncryptionBlt<P0, P1>(&self, psrcsurface: P0, pdstsurface: P1, dstsurfacesize: u32, piv: *mut ::core::ffi::c_void) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D9::IDirect3DSurface9>,
        P1: ::windows::core::IntoParam<super::super::Graphics::Direct3D9::IDirect3DSurface9>,
    {
        (::windows::core::Interface::vtable(self).EncryptionBlt)(::windows::core::Interface::as_raw(self), psrcsurface.into_param().abi(), pdstsurface.into_param().abi(), dstsurfacesize, piv).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn DecryptionBlt<P0, P1>(&self, psrcsurface: P0, pdstsurface: P1, srcsurfacesize: u32, pencryptedblockinfo: *mut super::super::Graphics::Direct3D9::D3DENCRYPTED_BLOCK_INFO, pcontentkey: *mut ::core::ffi::c_void, piv: *mut ::core::ffi::c_void) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D9::IDirect3DSurface9>,
        P1: ::windows::core::IntoParam<super::super::Graphics::Direct3D9::IDirect3DSurface9>,
    {
        (::windows::core::Interface::vtable(self).DecryptionBlt)(::windows::core::Interface::as_raw(self), psrcsurface.into_param().abi(), pdstsurface.into_param().abi(), srcsurfacesize, pencryptedblockinfo, pcontentkey, piv).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn GetSurfacePitch<P0>(&self, psrcsurface: P0, psurfacepitch: *mut u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D9::IDirect3DSurface9>,
    {
        (::windows::core::Interface::vtable(self).GetSurfacePitch)(::windows::core::Interface::as_raw(self), psrcsurface.into_param().abi(), psurfacepitch).ok()
    }
    pub unsafe fn StartSessionKeyRefresh(&self, prandomnumber: *mut ::core::ffi::c_void, randomnumbersize: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).StartSessionKeyRefresh)(::windows::core::Interface::as_raw(self), prandomnumber, randomnumbersize).ok()
    }
    pub unsafe fn FinishSessionKeyRefresh(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).FinishSessionKeyRefresh)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetEncryptionBltKey(&self, preadbackkey: *mut ::core::ffi::c_void, keysize: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetEncryptionBltKey)(::windows::core::Interface::as_raw(self), preadbackkey, keysize).ok()
    }
}
::windows::imp::interface_hierarchy!(IDirect3DCryptoSession9, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IDirect3DCryptoSession9 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirect3DCryptoSession9 {}
impl ::core::fmt::Debug for IDirect3DCryptoSession9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirect3DCryptoSession9").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IDirect3DCryptoSession9 {
    type Vtable = IDirect3DCryptoSession9_Vtbl;
}
impl ::core::clone::Clone for IDirect3DCryptoSession9 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IDirect3DCryptoSession9 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfa0ab799_7a9c_48ca_8c5b_237e71a54434);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDirect3DCryptoSession9_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetCertificateSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcertificatesize: *mut u32) -> ::windows::core::HRESULT,
    pub GetCertificate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, certifactesize: u32, ppcertificate: *mut u8) -> ::windows::core::HRESULT,
    pub NegotiateKeyExchange: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, datasize: u32, pdata: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub EncryptionBlt: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, psrcsurface: *mut ::core::ffi::c_void, pdstsurface: *mut ::core::ffi::c_void, dstsurfacesize: u32, piv: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    EncryptionBlt: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub DecryptionBlt: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, psrcsurface: *mut ::core::ffi::c_void, pdstsurface: *mut ::core::ffi::c_void, srcsurfacesize: u32, pencryptedblockinfo: *mut super::super::Graphics::Direct3D9::D3DENCRYPTED_BLOCK_INFO, pcontentkey: *mut ::core::ffi::c_void, piv: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    DecryptionBlt: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub GetSurfacePitch: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, psrcsurface: *mut ::core::ffi::c_void, psurfacepitch: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    GetSurfacePitch: usize,
    pub StartSessionKeyRefresh: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, prandomnumber: *mut ::core::ffi::c_void, randomnumbersize: u32) -> ::windows::core::HRESULT,
    pub FinishSessionKeyRefresh: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetEncryptionBltKey: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, preadbackkey: *mut ::core::ffi::c_void, keysize: u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IDirect3DDevice9Video(::windows::core::IUnknown);
impl IDirect3DDevice9Video {
    pub unsafe fn GetContentProtectionCaps(&self, pcryptotype: *const ::windows::core::GUID, pdecodeprofile: *const ::windows::core::GUID, pcaps: *mut D3DCONTENTPROTECTIONCAPS) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetContentProtectionCaps)(::windows::core::Interface::as_raw(self), pcryptotype, pdecodeprofile, pcaps).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
    pub unsafe fn CreateAuthenticatedChannel(&self, channeltype: super::super::Graphics::Direct3D9::D3DAUTHENTICATEDCHANNELTYPE, ppauthenticatedchannel: *mut ::core::option::Option<IDirect3DAuthenticatedChannel9>, pchannelhandle: *mut super::super::Foundation::HANDLE) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).CreateAuthenticatedChannel)(::windows::core::Interface::as_raw(self), channeltype, ::core::mem::transmute(ppauthenticatedchannel), pchannelhandle).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn CreateCryptoSession(&self, pcryptotype: *const ::windows::core::GUID, pdecodeprofile: *const ::windows::core::GUID, ppcryptosession: *mut ::core::option::Option<IDirect3DCryptoSession9>, pcryptohandle: *mut super::super::Foundation::HANDLE) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).CreateCryptoSession)(::windows::core::Interface::as_raw(self), pcryptotype, pdecodeprofile, ::core::mem::transmute(ppcryptosession), pcryptohandle).ok()
    }
}
::windows::imp::interface_hierarchy!(IDirect3DDevice9Video, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IDirect3DDevice9Video {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirect3DDevice9Video {}
impl ::core::fmt::Debug for IDirect3DDevice9Video {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirect3DDevice9Video").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IDirect3DDevice9Video {
    type Vtable = IDirect3DDevice9Video_Vtbl;
}
impl ::core::clone::Clone for IDirect3DDevice9Video {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IDirect3DDevice9Video {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x26dc4561_a1ee_4ae7_96da_118a36c0ec95);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDirect3DDevice9Video_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetContentProtectionCaps: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcryptotype: *const ::windows::core::GUID, pdecodeprofile: *const ::windows::core::GUID, pcaps: *mut D3DCONTENTPROTECTIONCAPS) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
    pub CreateAuthenticatedChannel: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, channeltype: super::super::Graphics::Direct3D9::D3DAUTHENTICATEDCHANNELTYPE, ppauthenticatedchannel: *mut *mut ::core::ffi::c_void, pchannelhandle: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9")))]
    CreateAuthenticatedChannel: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub CreateCryptoSession: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcryptotype: *const ::windows::core::GUID, pdecodeprofile: *const ::windows::core::GUID, ppcryptosession: *mut *mut ::core::ffi::c_void, pcryptohandle: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    CreateCryptoSession: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IDirect3DDeviceManager9(::windows::core::IUnknown);
impl IDirect3DDeviceManager9 {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn ResetDevice<P0>(&self, pdevice: P0, resettoken: u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D9::IDirect3DDevice9>,
    {
        (::windows::core::Interface::vtable(self).ResetDevice)(::windows::core::Interface::as_raw(self), pdevice.into_param().abi(), resettoken).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn OpenDeviceHandle(&self) -> ::windows::core::Result<super::super::Foundation::HANDLE> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self).OpenDeviceHandle)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn CloseDeviceHandle<P0>(&self, hdevice: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self).CloseDeviceHandle)(::windows::core::Interface::as_raw(self), hdevice.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn TestDevice<P0>(&self, hdevice: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self).TestDevice)(::windows::core::Interface::as_raw(self), hdevice.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
    pub unsafe fn LockDevice<P0, P1>(&self, hdevice: P0, ppdevice: *mut ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DDevice9>, fblock: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::HANDLE>,
        P1: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).LockDevice)(::windows::core::Interface::as_raw(self), hdevice.into_param().abi(), ::core::mem::transmute(ppdevice), fblock.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn UnlockDevice<P0, P1>(&self, hdevice: P0, fsavestate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::HANDLE>,
        P1: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).UnlockDevice)(::windows::core::Interface::as_raw(self), hdevice.into_param().abi(), fsavestate.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetVideoService<P0>(&self, hdevice: P0, riid: *const ::windows::core::GUID, ppservice: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self).GetVideoService)(::windows::core::Interface::as_raw(self), hdevice.into_param().abi(), riid, ppservice).ok()
    }
}
::windows::imp::interface_hierarchy!(IDirect3DDeviceManager9, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IDirect3DDeviceManager9 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirect3DDeviceManager9 {}
impl ::core::fmt::Debug for IDirect3DDeviceManager9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirect3DDeviceManager9").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IDirect3DDeviceManager9 {
    type Vtable = IDirect3DDeviceManager9_Vtbl;
}
impl ::core::clone::Clone for IDirect3DDeviceManager9 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IDirect3DDeviceManager9 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa0cade0f_06d5_4cf4_a1c7_f3cdd725aa75);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDirect3DDeviceManager9_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub ResetDevice: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdevice: *mut ::core::ffi::c_void, resettoken: u32) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    ResetDevice: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub OpenDeviceHandle: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, phdevice: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    OpenDeviceHandle: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub CloseDeviceHandle: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    CloseDeviceHandle: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub TestDevice: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    TestDevice: usize,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
    pub LockDevice: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, ppdevice: *mut *mut ::core::ffi::c_void, fblock: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9")))]
    LockDevice: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub UnlockDevice: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, fsavestate: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    UnlockDevice: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub GetVideoService: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, riid: *const ::windows::core::GUID, ppservice: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetVideoService: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IDirectXVideoAccelerationService(::windows::core::IUnknown);
impl IDirectXVideoAccelerationService {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
    pub unsafe fn CreateSurface(&self, width: u32, height: u32, backbuffers: u32, format: super::super::Graphics::Direct3D9::D3DFORMAT, pool: super::super::Graphics::Direct3D9::D3DPOOL, usage: u32, dxvatype: DXVA2_VideoRenderTargetType, ppsurface: *mut ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, psharedhandle: ::core::option::Option<*mut super::super::Foundation::HANDLE>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).CreateSurface)(::windows::core::Interface::as_raw(self), width, height, backbuffers, format, pool, usage, dxvatype, ::core::mem::transmute(ppsurface), ::core::mem::transmute(psharedhandle.unwrap_or(::std::ptr::null_mut()))).ok()
    }
}
::windows::imp::interface_hierarchy!(IDirectXVideoAccelerationService, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IDirectXVideoAccelerationService {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectXVideoAccelerationService {}
impl ::core::fmt::Debug for IDirectXVideoAccelerationService {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectXVideoAccelerationService").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IDirectXVideoAccelerationService {
    type Vtable = IDirectXVideoAccelerationService_Vtbl;
}
impl ::core::clone::Clone for IDirectXVideoAccelerationService {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IDirectXVideoAccelerationService {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfc51a550_d5e7_11d9_af55_00054e43ff02);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDirectXVideoAccelerationService_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
    pub CreateSurface: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, width: u32, height: u32, backbuffers: u32, format: super::super::Graphics::Direct3D9::D3DFORMAT, pool: super::super::Graphics::Direct3D9::D3DPOOL, usage: u32, dxvatype: DXVA2_VideoRenderTargetType, ppsurface: *mut *mut ::core::ffi::c_void, psharedhandle: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9")))]
    CreateSurface: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IDirectXVideoDecoder(::windows::core::IUnknown);
impl IDirectXVideoDecoder {
    pub unsafe fn GetVideoDecoderService(&self) -> ::windows::core::Result<IDirectXVideoDecoderService> {
        let mut result__ = ::windows::core::zeroed::<IDirectXVideoDecoderService>();
        (::windows::core::Interface::vtable(self).GetVideoDecoderService)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn GetCreationParameters(&self, pdeviceguid: ::core::option::Option<*mut ::windows::core::GUID>, pvideodesc: ::core::option::Option<*mut DXVA2_VideoDesc>, pconfig: ::core::option::Option<*mut DXVA2_ConfigPictureDecode>, pdecoderrendertargets: *mut *mut ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, pnumsurfaces: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetCreationParameters)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pdeviceguid.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(pvideodesc.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(pconfig.unwrap_or(::std::ptr::null_mut())), pdecoderrendertargets, ::core::mem::transmute(pnumsurfaces.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetBuffer(&self, buffertype: DXVA2_BufferfType, ppbuffer: *mut *mut ::core::ffi::c_void, pbuffersize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetBuffer)(::windows::core::Interface::as_raw(self), buffertype, ppbuffer, pbuffersize).ok()
    }
    pub unsafe fn ReleaseBuffer(&self, buffertype: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ReleaseBuffer)(::windows::core::Interface::as_raw(self), buffertype).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn BeginFrame<P0>(&self, prendertarget: P0, pvpvpdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D9::IDirect3DSurface9>,
    {
        (::windows::core::Interface::vtable(self).BeginFrame)(::windows::core::Interface::as_raw(self), prendertarget.into_param().abi(), ::core::mem::transmute(pvpvpdata.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn EndFrame(&self, phandlecomplete: ::core::option::Option<*mut super::super::Foundation::HANDLE>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).EndFrame)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(phandlecomplete.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn Execute(&self, pexecuteparams: *const DXVA2_DecodeExecuteParams) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Execute)(::windows::core::Interface::as_raw(self), pexecuteparams).ok()
    }
}
::windows::imp::interface_hierarchy!(IDirectXVideoDecoder, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IDirectXVideoDecoder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectXVideoDecoder {}
impl ::core::fmt::Debug for IDirectXVideoDecoder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectXVideoDecoder").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IDirectXVideoDecoder {
    type Vtable = IDirectXVideoDecoder_Vtbl;
}
impl ::core::clone::Clone for IDirectXVideoDecoder {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IDirectXVideoDecoder {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf2b0810a_fd00_43c9_918c_df94e2d8ef7d);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDirectXVideoDecoder_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetVideoDecoderService: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppservice: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub GetCreationParameters: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdeviceguid: *mut ::windows::core::GUID, pvideodesc: *mut DXVA2_VideoDesc, pconfig: *mut DXVA2_ConfigPictureDecode, pdecoderrendertargets: *mut *mut ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, pnumsurfaces: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    GetCreationParameters: usize,
    pub GetBuffer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, buffertype: DXVA2_BufferfType, ppbuffer: *mut *mut ::core::ffi::c_void, pbuffersize: *mut u32) -> ::windows::core::HRESULT,
    pub ReleaseBuffer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, buffertype: u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub BeginFrame: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, prendertarget: *mut ::core::ffi::c_void, pvpvpdata: *const ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    BeginFrame: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub EndFrame: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, phandlecomplete: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    EndFrame: usize,
    pub Execute: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pexecuteparams: *const DXVA2_DecodeExecuteParams) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IDirectXVideoDecoderService(::windows::core::IUnknown);
impl IDirectXVideoDecoderService {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
    pub unsafe fn CreateSurface(&self, width: u32, height: u32, backbuffers: u32, format: super::super::Graphics::Direct3D9::D3DFORMAT, pool: super::super::Graphics::Direct3D9::D3DPOOL, usage: u32, dxvatype: DXVA2_VideoRenderTargetType, ppsurface: *mut ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, psharedhandle: ::core::option::Option<*mut super::super::Foundation::HANDLE>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.CreateSurface)(::windows::core::Interface::as_raw(self), width, height, backbuffers, format, pool, usage, dxvatype, ::core::mem::transmute(ppsurface), ::core::mem::transmute(psharedhandle.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetDecoderDeviceGuids(&self, pcount: *mut u32, pguids: *mut *mut ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDecoderDeviceGuids)(::windows::core::Interface::as_raw(self), pcount, pguids).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn GetDecoderRenderTargets(&self, guid: *const ::windows::core::GUID, pcount: *mut u32, pformats: *mut *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDecoderRenderTargets)(::windows::core::Interface::as_raw(self), guid, pcount, pformats).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn GetDecoderConfigurations(&self, guid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, preserved: ::core::option::Option<*const ::core::ffi::c_void>, pcount: *mut u32, ppconfigs: *mut *mut DXVA2_ConfigPictureDecode) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDecoderConfigurations)(::windows::core::Interface::as_raw(self), guid, pvideodesc, ::core::mem::transmute(preserved.unwrap_or(::std::ptr::null())), pcount, ppconfigs).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn CreateVideoDecoder(&self, guid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, pconfig: *const DXVA2_ConfigPictureDecode, ppdecoderrendertargets: &[::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>]) -> ::windows::core::Result<IDirectXVideoDecoder> {
        let mut result__ = ::windows::core::zeroed::<IDirectXVideoDecoder>();
        (::windows::core::Interface::vtable(self).CreateVideoDecoder)(::windows::core::Interface::as_raw(self), guid, pvideodesc, pconfig, ::core::mem::transmute(ppdecoderrendertargets.as_ptr()), ppdecoderrendertargets.len() as _, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IDirectXVideoDecoderService, ::windows::core::IUnknown, IDirectXVideoAccelerationService);
impl ::core::cmp::PartialEq for IDirectXVideoDecoderService {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectXVideoDecoderService {}
impl ::core::fmt::Debug for IDirectXVideoDecoderService {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectXVideoDecoderService").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IDirectXVideoDecoderService {
    type Vtable = IDirectXVideoDecoderService_Vtbl;
}
impl ::core::clone::Clone for IDirectXVideoDecoderService {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IDirectXVideoDecoderService {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfc51a551_d5e7_11d9_af55_00054e43ff02);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDirectXVideoDecoderService_Vtbl {
    pub base__: IDirectXVideoAccelerationService_Vtbl,
    pub GetDecoderDeviceGuids: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcount: *mut u32, pguids: *mut *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub GetDecoderRenderTargets: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guid: *const ::windows::core::GUID, pcount: *mut u32, pformats: *mut *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    GetDecoderRenderTargets: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub GetDecoderConfigurations: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, preserved: *const ::core::ffi::c_void, pcount: *mut u32, ppconfigs: *mut *mut DXVA2_ConfigPictureDecode) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    GetDecoderConfigurations: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub CreateVideoDecoder: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, pconfig: *const DXVA2_ConfigPictureDecode, ppdecoderrendertargets: *const *mut ::core::ffi::c_void, numrendertargets: u32, ppdecode: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    CreateVideoDecoder: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IDirectXVideoMemoryConfiguration(::windows::core::IUnknown);
impl IDirectXVideoMemoryConfiguration {
    pub unsafe fn GetAvailableSurfaceTypeByIndex(&self, dwtypeindex: u32) -> ::windows::core::Result<DXVA2_SurfaceType> {
        let mut result__ = ::windows::core::zeroed::<DXVA2_SurfaceType>();
        (::windows::core::Interface::vtable(self).GetAvailableSurfaceTypeByIndex)(::windows::core::Interface::as_raw(self), dwtypeindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetSurfaceType(&self, dwtype: DXVA2_SurfaceType) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetSurfaceType)(::windows::core::Interface::as_raw(self), dwtype).ok()
    }
}
::windows::imp::interface_hierarchy!(IDirectXVideoMemoryConfiguration, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IDirectXVideoMemoryConfiguration {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectXVideoMemoryConfiguration {}
impl ::core::fmt::Debug for IDirectXVideoMemoryConfiguration {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectXVideoMemoryConfiguration").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IDirectXVideoMemoryConfiguration {
    type Vtable = IDirectXVideoMemoryConfiguration_Vtbl;
}
impl ::core::clone::Clone for IDirectXVideoMemoryConfiguration {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IDirectXVideoMemoryConfiguration {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb7f916dd_db3b_49c1_84d7_e45ef99ec726);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDirectXVideoMemoryConfiguration_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetAvailableSurfaceTypeByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwtypeindex: u32, pdwtype: *mut DXVA2_SurfaceType) -> ::windows::core::HRESULT,
    pub SetSurfaceType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwtype: DXVA2_SurfaceType) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IDirectXVideoProcessor(::windows::core::IUnknown);
impl IDirectXVideoProcessor {
    pub unsafe fn GetVideoProcessorService(&self) -> ::windows::core::Result<IDirectXVideoProcessorService> {
        let mut result__ = ::windows::core::zeroed::<IDirectXVideoProcessorService>();
        (::windows::core::Interface::vtable(self).GetVideoProcessorService)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn GetCreationParameters(&self, pdeviceguid: ::core::option::Option<*mut ::windows::core::GUID>, pvideodesc: ::core::option::Option<*mut DXVA2_VideoDesc>, prendertargetformat: ::core::option::Option<*mut super::super::Graphics::Direct3D9::D3DFORMAT>, pmaxnumsubstreams: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetCreationParameters)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pdeviceguid.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(pvideodesc.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(prendertargetformat.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(pmaxnumsubstreams.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn GetVideoProcessorCaps(&self, pcaps: *mut DXVA2_VideoProcessorCaps) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetVideoProcessorCaps)(::windows::core::Interface::as_raw(self), pcaps).ok()
    }
    pub unsafe fn GetProcAmpRange(&self, procampcap: u32) -> ::windows::core::Result<DXVA2_ValueRange> {
        let mut result__ = ::windows::core::zeroed::<DXVA2_ValueRange>();
        (::windows::core::Interface::vtable(self).GetProcAmpRange)(::windows::core::Interface::as_raw(self), procampcap, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetFilterPropertyRange(&self, filtersetting: u32) -> ::windows::core::Result<DXVA2_ValueRange> {
        let mut result__ = ::windows::core::zeroed::<DXVA2_ValueRange>();
        (::windows::core::Interface::vtable(self).GetFilterPropertyRange)(::windows::core::Interface::as_raw(self), filtersetting, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
    pub unsafe fn VideoProcessBlt<P0>(&self, prendertarget: P0, pbltparams: *const DXVA2_VideoProcessBltParams, psamples: &[DXVA2_VideoSample], phandlecomplete: ::core::option::Option<*mut super::super::Foundation::HANDLE>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D9::IDirect3DSurface9>,
    {
        (::windows::core::Interface::vtable(self).VideoProcessBlt)(::windows::core::Interface::as_raw(self), prendertarget.into_param().abi(), pbltparams, ::core::mem::transmute(psamples.as_ptr()), psamples.len() as _, ::core::mem::transmute(phandlecomplete.unwrap_or(::std::ptr::null_mut()))).ok()
    }
}
::windows::imp::interface_hierarchy!(IDirectXVideoProcessor, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IDirectXVideoProcessor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectXVideoProcessor {}
impl ::core::fmt::Debug for IDirectXVideoProcessor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectXVideoProcessor").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IDirectXVideoProcessor {
    type Vtable = IDirectXVideoProcessor_Vtbl;
}
impl ::core::clone::Clone for IDirectXVideoProcessor {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IDirectXVideoProcessor {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8c3a39f0_916e_4690_804f_4c8001355d25);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDirectXVideoProcessor_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetVideoProcessorService: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppservice: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub GetCreationParameters: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdeviceguid: *mut ::windows::core::GUID, pvideodesc: *mut DXVA2_VideoDesc, prendertargetformat: *mut super::super::Graphics::Direct3D9::D3DFORMAT, pmaxnumsubstreams: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    GetCreationParameters: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub GetVideoProcessorCaps: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcaps: *mut DXVA2_VideoProcessorCaps) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    GetVideoProcessorCaps: usize,
    pub GetProcAmpRange: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, procampcap: u32, prange: *mut DXVA2_ValueRange) -> ::windows::core::HRESULT,
    pub GetFilterPropertyRange: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, filtersetting: u32, prange: *mut DXVA2_ValueRange) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
    pub VideoProcessBlt: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, prendertarget: *mut ::core::ffi::c_void, pbltparams: *const DXVA2_VideoProcessBltParams, psamples: *const DXVA2_VideoSample, numsamples: u32, phandlecomplete: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9")))]
    VideoProcessBlt: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IDirectXVideoProcessorService(::windows::core::IUnknown);
impl IDirectXVideoProcessorService {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
    pub unsafe fn CreateSurface(&self, width: u32, height: u32, backbuffers: u32, format: super::super::Graphics::Direct3D9::D3DFORMAT, pool: super::super::Graphics::Direct3D9::D3DPOOL, usage: u32, dxvatype: DXVA2_VideoRenderTargetType, ppsurface: *mut ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, psharedhandle: ::core::option::Option<*mut super::super::Foundation::HANDLE>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.CreateSurface)(::windows::core::Interface::as_raw(self), width, height, backbuffers, format, pool, usage, dxvatype, ::core::mem::transmute(ppsurface), ::core::mem::transmute(psharedhandle.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn RegisterVideoProcessorSoftwareDevice(&self, pcallbacks: *const ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RegisterVideoProcessorSoftwareDevice)(::windows::core::Interface::as_raw(self), pcallbacks).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn GetVideoProcessorDeviceGuids(&self, pvideodesc: *const DXVA2_VideoDesc, pcount: *mut u32, pguids: *mut *mut ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetVideoProcessorDeviceGuids)(::windows::core::Interface::as_raw(self), pvideodesc, pcount, pguids).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn GetVideoProcessorRenderTargets(&self, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, pcount: *mut u32, pformats: *mut *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetVideoProcessorRenderTargets)(::windows::core::Interface::as_raw(self), videoprocdeviceguid, pvideodesc, pcount, pformats).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn GetVideoProcessorSubStreamFormats(&self, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, pcount: *mut u32, pformats: *mut *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetVideoProcessorSubStreamFormats)(::windows::core::Interface::as_raw(self), videoprocdeviceguid, pvideodesc, rendertargetformat, pcount, pformats).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn GetVideoProcessorCaps(&self, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, pcaps: *mut DXVA2_VideoProcessorCaps) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetVideoProcessorCaps)(::windows::core::Interface::as_raw(self), videoprocdeviceguid, pvideodesc, rendertargetformat, pcaps).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn GetProcAmpRange(&self, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, procampcap: u32) -> ::windows::core::Result<DXVA2_ValueRange> {
        let mut result__ = ::windows::core::zeroed::<DXVA2_ValueRange>();
        (::windows::core::Interface::vtable(self).GetProcAmpRange)(::windows::core::Interface::as_raw(self), videoprocdeviceguid, pvideodesc, rendertargetformat, procampcap, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn GetFilterPropertyRange(&self, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, filtersetting: u32) -> ::windows::core::Result<DXVA2_ValueRange> {
        let mut result__ = ::windows::core::zeroed::<DXVA2_ValueRange>();
        (::windows::core::Interface::vtable(self).GetFilterPropertyRange)(::windows::core::Interface::as_raw(self), videoprocdeviceguid, pvideodesc, rendertargetformat, filtersetting, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn CreateVideoProcessor(&self, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, maxnumsubstreams: u32) -> ::windows::core::Result<IDirectXVideoProcessor> {
        let mut result__ = ::windows::core::zeroed::<IDirectXVideoProcessor>();
        (::windows::core::Interface::vtable(self).CreateVideoProcessor)(::windows::core::Interface::as_raw(self), videoprocdeviceguid, pvideodesc, rendertargetformat, maxnumsubstreams, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IDirectXVideoProcessorService, ::windows::core::IUnknown, IDirectXVideoAccelerationService);
impl ::core::cmp::PartialEq for IDirectXVideoProcessorService {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IDirectXVideoProcessorService {}
impl ::core::fmt::Debug for IDirectXVideoProcessorService {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IDirectXVideoProcessorService").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IDirectXVideoProcessorService {
    type Vtable = IDirectXVideoProcessorService_Vtbl;
}
impl ::core::clone::Clone for IDirectXVideoProcessorService {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IDirectXVideoProcessorService {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfc51a552_d5e7_11d9_af55_00054e43ff02);
}
#[repr(C)]
#[doc(hidden)]
pub struct IDirectXVideoProcessorService_Vtbl {
    pub base__: IDirectXVideoAccelerationService_Vtbl,
    pub RegisterVideoProcessorSoftwareDevice: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcallbacks: *const ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub GetVideoProcessorDeviceGuids: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pvideodesc: *const DXVA2_VideoDesc, pcount: *mut u32, pguids: *mut *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    GetVideoProcessorDeviceGuids: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub GetVideoProcessorRenderTargets: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, pcount: *mut u32, pformats: *mut *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    GetVideoProcessorRenderTargets: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub GetVideoProcessorSubStreamFormats: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, pcount: *mut u32, pformats: *mut *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    GetVideoProcessorSubStreamFormats: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub GetVideoProcessorCaps: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, pcaps: *mut DXVA2_VideoProcessorCaps) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    GetVideoProcessorCaps: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub GetProcAmpRange: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, procampcap: u32, prange: *mut DXVA2_ValueRange) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    GetProcAmpRange: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub GetFilterPropertyRange: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, filtersetting: u32, prange: *mut DXVA2_ValueRange) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    GetFilterPropertyRange: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub CreateVideoProcessor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, maxnumsubstreams: u32, ppvidprocess: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    CreateVideoProcessor: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IEVRFilterConfig(::windows::core::IUnknown);
impl IEVRFilterConfig {
    pub unsafe fn SetNumberOfStreams(&self, dwmaxstreams: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetNumberOfStreams)(::windows::core::Interface::as_raw(self), dwmaxstreams).ok()
    }
    pub unsafe fn GetNumberOfStreams(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetNumberOfStreams)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IEVRFilterConfig, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IEVRFilterConfig {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEVRFilterConfig {}
impl ::core::fmt::Debug for IEVRFilterConfig {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEVRFilterConfig").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IEVRFilterConfig {
    type Vtable = IEVRFilterConfig_Vtbl;
}
impl ::core::clone::Clone for IEVRFilterConfig {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IEVRFilterConfig {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x83e91e85_82c1_4ea7_801d_85dc50b75086);
}
#[repr(C)]
#[doc(hidden)]
pub struct IEVRFilterConfig_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetNumberOfStreams: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwmaxstreams: u32) -> ::windows::core::HRESULT,
    pub GetNumberOfStreams: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwmaxstreams: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IEVRFilterConfigEx(::windows::core::IUnknown);
impl IEVRFilterConfigEx {
    pub unsafe fn SetNumberOfStreams(&self, dwmaxstreams: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetNumberOfStreams)(::windows::core::Interface::as_raw(self), dwmaxstreams).ok()
    }
    pub unsafe fn GetNumberOfStreams(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetNumberOfStreams)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetConfigPrefs(&self, dwconfigflags: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetConfigPrefs)(::windows::core::Interface::as_raw(self), dwconfigflags).ok()
    }
    pub unsafe fn GetConfigPrefs(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetConfigPrefs)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IEVRFilterConfigEx, ::windows::core::IUnknown, IEVRFilterConfig);
impl ::core::cmp::PartialEq for IEVRFilterConfigEx {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEVRFilterConfigEx {}
impl ::core::fmt::Debug for IEVRFilterConfigEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEVRFilterConfigEx").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IEVRFilterConfigEx {
    type Vtable = IEVRFilterConfigEx_Vtbl;
}
impl ::core::clone::Clone for IEVRFilterConfigEx {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IEVRFilterConfigEx {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xaea36028_796d_454f_beee_b48071e24304);
}
#[repr(C)]
#[doc(hidden)]
pub struct IEVRFilterConfigEx_Vtbl {
    pub base__: IEVRFilterConfig_Vtbl,
    pub SetConfigPrefs: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwconfigflags: u32) -> ::windows::core::HRESULT,
    pub GetConfigPrefs: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwconfigflags: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IEVRTrustedVideoPlugin(::windows::core::IUnknown);
impl IEVRTrustedVideoPlugin {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsInTrustedVideoMode(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).IsInTrustedVideoMode)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn CanConstrict(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).CanConstrict)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetConstriction(&self, dwkpix: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetConstriction)(::windows::core::Interface::as_raw(self), dwkpix).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn DisableImageExport<P0>(&self, bdisable: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).DisableImageExport)(::windows::core::Interface::as_raw(self), bdisable.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IEVRTrustedVideoPlugin, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IEVRTrustedVideoPlugin {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEVRTrustedVideoPlugin {}
impl ::core::fmt::Debug for IEVRTrustedVideoPlugin {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEVRTrustedVideoPlugin").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IEVRTrustedVideoPlugin {
    type Vtable = IEVRTrustedVideoPlugin_Vtbl;
}
impl ::core::clone::Clone for IEVRTrustedVideoPlugin {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IEVRTrustedVideoPlugin {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x83a4ce40_7710_494b_a893_a472049af630);
}
#[repr(C)]
#[doc(hidden)]
pub struct IEVRTrustedVideoPlugin_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub IsInTrustedVideoMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pyes: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsInTrustedVideoMode: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub CanConstrict: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pyes: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    CanConstrict: usize,
    pub SetConstriction: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwkpix: u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub DisableImageExport: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, bdisable: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    DisableImageExport: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IEVRVideoStreamControl(::windows::core::IUnknown);
impl IEVRVideoStreamControl {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetStreamActiveState<P0>(&self, factive: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetStreamActiveState)(::windows::core::Interface::as_raw(self), factive.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetStreamActiveState(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).GetStreamActiveState)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IEVRVideoStreamControl, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IEVRVideoStreamControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IEVRVideoStreamControl {}
impl ::core::fmt::Debug for IEVRVideoStreamControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IEVRVideoStreamControl").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IEVRVideoStreamControl {
    type Vtable = IEVRVideoStreamControl_Vtbl;
}
impl ::core::clone::Clone for IEVRVideoStreamControl {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IEVRVideoStreamControl {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd0cfe38b_93e7_4772_8957_0400c49a4485);
}
#[repr(C)]
#[doc(hidden)]
pub struct IEVRVideoStreamControl_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub SetStreamActiveState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, factive: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetStreamActiveState: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub GetStreamActiveState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, lpfactive: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetStreamActiveState: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IFileClient(::windows::core::IUnknown);
impl IFileClient {
    pub unsafe fn GetObjectDiskSize(&self, pqwsize: *mut u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetObjectDiskSize)(::windows::core::Interface::as_raw(self), pqwsize).ok()
    }
    pub unsafe fn Write<P0>(&self, pfio: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IFileIo>,
    {
        (::windows::core::Interface::vtable(self).Write)(::windows::core::Interface::as_raw(self), pfio.into_param().abi()).ok()
    }
    pub unsafe fn Read<P0>(&self, pfio: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IFileIo>,
    {
        (::windows::core::Interface::vtable(self).Read)(::windows::core::Interface::as_raw(self), pfio.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IFileClient, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IFileClient {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFileClient {}
impl ::core::fmt::Debug for IFileClient {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFileClient").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IFileClient {
    type Vtable = IFileClient_Vtbl;
}
impl ::core::clone::Clone for IFileClient {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IFileClient {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbfccd196_1244_4840_ab44_480975c4ffe4);
}
#[repr(C)]
#[doc(hidden)]
pub struct IFileClient_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetObjectDiskSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pqwsize: *mut u64) -> ::windows::core::HRESULT,
    pub Write: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pfio: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Read: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pfio: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IFileIo(::windows::core::IUnknown);
impl IFileIo {
    pub unsafe fn Initialize<P0>(&self, eaccessmode: FILE_ACCESSMODE, eopenmode: FILE_OPENMODE, pwszfilename: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).Initialize)(::windows::core::Interface::as_raw(self), eaccessmode, eopenmode, pwszfilename.into_param().abi()).ok()
    }
    pub unsafe fn GetLength(&self, pqwlength: *mut u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetLength)(::windows::core::Interface::as_raw(self), pqwlength).ok()
    }
    pub unsafe fn SetLength(&self, qwlength: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetLength)(::windows::core::Interface::as_raw(self), qwlength).ok()
    }
    pub unsafe fn GetCurrentPosition(&self, pqwposition: *mut u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetCurrentPosition)(::windows::core::Interface::as_raw(self), pqwposition).ok()
    }
    pub unsafe fn SetCurrentPosition(&self, qwposition: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetCurrentPosition)(::windows::core::Interface::as_raw(self), qwposition).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsEndOfStream(&self, pbendofstream: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).IsEndOfStream)(::windows::core::Interface::as_raw(self), pbendofstream).ok()
    }
    pub unsafe fn Read(&self, pbt: *mut u8, ul: u32, pulread: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Read)(::windows::core::Interface::as_raw(self), pbt, ul, pulread).ok()
    }
    pub unsafe fn Write(&self, pbt: *mut u8, ul: u32, pulwritten: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Write)(::windows::core::Interface::as_raw(self), pbt, ul, pulwritten).ok()
    }
    pub unsafe fn Seek(&self, eseekorigin: SEEK_ORIGIN, qwseekoffset: u64, dwseekflags: u32, pqwcurrentposition: *mut u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Seek)(::windows::core::Interface::as_raw(self), eseekorigin, qwseekoffset, dwseekflags, pqwcurrentposition).ok()
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Close)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IFileIo, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IFileIo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IFileIo {}
impl ::core::fmt::Debug for IFileIo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IFileIo").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IFileIo {
    type Vtable = IFileIo_Vtbl;
}
impl ::core::clone::Clone for IFileIo {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IFileIo {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x11993196_1244_4840_ab44_480975c4ffe4);
}
#[repr(C)]
#[doc(hidden)]
pub struct IFileIo_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub Initialize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, eaccessmode: FILE_ACCESSMODE, eopenmode: FILE_OPENMODE, pwszfilename: ::windows::core::PCWSTR) -> ::windows::core::HRESULT,
    pub GetLength: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pqwlength: *mut u64) -> ::windows::core::HRESULT,
    pub SetLength: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, qwlength: u64) -> ::windows::core::HRESULT,
    pub GetCurrentPosition: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pqwposition: *mut u64) -> ::windows::core::HRESULT,
    pub SetCurrentPosition: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, qwposition: u64) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub IsEndOfStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbendofstream: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsEndOfStream: usize,
    pub Read: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbt: *mut u8, ul: u32, pulread: *mut u32) -> ::windows::core::HRESULT,
    pub Write: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbt: *mut u8, ul: u32, pulwritten: *mut u32) -> ::windows::core::HRESULT,
    pub Seek: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, eseekorigin: SEEK_ORIGIN, qwseekoffset: u64, dwseekflags: u32, pqwcurrentposition: *mut u64) -> ::windows::core::HRESULT,
    pub Close: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMF2DBuffer(::windows::core::IUnknown);
impl IMF2DBuffer {
    pub unsafe fn Lock2D(&self, ppbscanline0: *mut *mut u8, plpitch: *mut i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Lock2D)(::windows::core::Interface::as_raw(self), ppbscanline0, plpitch).ok()
    }
    pub unsafe fn Unlock2D(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Unlock2D)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetScanline0AndPitch(&self, pbscanline0: *mut *mut u8, plpitch: *mut i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetScanline0AndPitch)(::windows::core::Interface::as_raw(self), pbscanline0, plpitch).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsContiguousFormat(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).IsContiguousFormat)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetContiguousLength(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetContiguousLength)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn ContiguousCopyTo(&self, pbdestbuffer: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ContiguousCopyTo)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pbdestbuffer.as_ptr()), pbdestbuffer.len() as _).ok()
    }
    pub unsafe fn ContiguousCopyFrom(&self, pbsrcbuffer: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ContiguousCopyFrom)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pbsrcbuffer.as_ptr()), pbsrcbuffer.len() as _).ok()
    }
}
::windows::imp::interface_hierarchy!(IMF2DBuffer, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMF2DBuffer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMF2DBuffer {}
impl ::core::fmt::Debug for IMF2DBuffer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMF2DBuffer").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMF2DBuffer {
    type Vtable = IMF2DBuffer_Vtbl;
}
impl ::core::clone::Clone for IMF2DBuffer {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMF2DBuffer {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7dc9d5f9_9ed9_44ec_9bbf_0600bb589fbb);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMF2DBuffer_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub Lock2D: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppbscanline0: *mut *mut u8, plpitch: *mut i32) -> ::windows::core::HRESULT,
    pub Unlock2D: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetScanline0AndPitch: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbscanline0: *mut *mut u8, plpitch: *mut i32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub IsContiguousFormat: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pfiscontiguous: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsContiguousFormat: usize,
    pub GetContiguousLength: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcblength: *mut u32) -> ::windows::core::HRESULT,
    pub ContiguousCopyTo: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbdestbuffer: *mut u8, cbdestbuffer: u32) -> ::windows::core::HRESULT,
    pub ContiguousCopyFrom: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbsrcbuffer: *const u8, cbsrcbuffer: u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMF2DBuffer2(::windows::core::IUnknown);
impl IMF2DBuffer2 {
    pub unsafe fn Lock2D(&self, ppbscanline0: *mut *mut u8, plpitch: *mut i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Lock2D)(::windows::core::Interface::as_raw(self), ppbscanline0, plpitch).ok()
    }
    pub unsafe fn Unlock2D(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Unlock2D)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetScanline0AndPitch(&self, pbscanline0: *mut *mut u8, plpitch: *mut i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetScanline0AndPitch)(::windows::core::Interface::as_raw(self), pbscanline0, plpitch).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsContiguousFormat(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.IsContiguousFormat)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetContiguousLength(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetContiguousLength)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn ContiguousCopyTo(&self, pbdestbuffer: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.ContiguousCopyTo)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pbdestbuffer.as_ptr()), pbdestbuffer.len() as _).ok()
    }
    pub unsafe fn ContiguousCopyFrom(&self, pbsrcbuffer: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.ContiguousCopyFrom)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pbsrcbuffer.as_ptr()), pbsrcbuffer.len() as _).ok()
    }
    pub unsafe fn Lock2DSize(&self, lockflags: MF2DBuffer_LockFlags, ppbscanline0: *mut *mut u8, plpitch: *mut i32, ppbbufferstart: *mut *mut u8, pcbbufferlength: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Lock2DSize)(::windows::core::Interface::as_raw(self), lockflags, ppbscanline0, plpitch, ppbbufferstart, pcbbufferlength).ok()
    }
    pub unsafe fn Copy2DTo<P0>(&self, pdestbuffer: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMF2DBuffer2>,
    {
        (::windows::core::Interface::vtable(self).Copy2DTo)(::windows::core::Interface::as_raw(self), pdestbuffer.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMF2DBuffer2, ::windows::core::IUnknown, IMF2DBuffer);
impl ::core::cmp::PartialEq for IMF2DBuffer2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMF2DBuffer2 {}
impl ::core::fmt::Debug for IMF2DBuffer2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMF2DBuffer2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMF2DBuffer2 {
    type Vtable = IMF2DBuffer2_Vtbl;
}
impl ::core::clone::Clone for IMF2DBuffer2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMF2DBuffer2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x33ae5ea6_4316_436f_8ddd_d73d22f829ec);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMF2DBuffer2_Vtbl {
    pub base__: IMF2DBuffer_Vtbl,
    pub Lock2DSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, lockflags: MF2DBuffer_LockFlags, ppbscanline0: *mut *mut u8, plpitch: *mut i32, ppbbufferstart: *mut *mut u8, pcbbufferlength: *mut u32) -> ::windows::core::HRESULT,
    pub Copy2DTo: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdestbuffer: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFASFContentInfo(::windows::core::IUnknown);
impl IMFASFContentInfo {
    pub unsafe fn GetHeaderSize<P0>(&self, pistartofcontent: P0) -> ::windows::core::Result<u64>
    where
        P0: ::windows::core::IntoParam<IMFMediaBuffer>,
    {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).GetHeaderSize)(::windows::core::Interface::as_raw(self), pistartofcontent.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn ParseHeader<P0>(&self, piheaderbuffer: P0, cboffsetwithinheader: u64) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaBuffer>,
    {
        (::windows::core::Interface::vtable(self).ParseHeader)(::windows::core::Interface::as_raw(self), piheaderbuffer.into_param().abi(), cboffsetwithinheader).ok()
    }
    pub unsafe fn GenerateHeader<P0>(&self, piheader: P0) -> ::windows::core::Result<u32>
    where
        P0: ::windows::core::IntoParam<IMFMediaBuffer>,
    {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GenerateHeader)(::windows::core::Interface::as_raw(self), piheader.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetProfile(&self) -> ::windows::core::Result<IMFASFProfile> {
        let mut result__ = ::windows::core::zeroed::<IMFASFProfile>();
        (::windows::core::Interface::vtable(self).GetProfile)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetProfile<P0>(&self, piprofile: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFASFProfile>,
    {
        (::windows::core::Interface::vtable(self).SetProfile)(::windows::core::Interface::as_raw(self), piprofile.into_param().abi()).ok()
    }
    pub unsafe fn GeneratePresentationDescriptor(&self) -> ::windows::core::Result<IMFPresentationDescriptor> {
        let mut result__ = ::windows::core::zeroed::<IMFPresentationDescriptor>();
        (::windows::core::Interface::vtable(self).GeneratePresentationDescriptor)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_UI_Shell_PropertiesSystem\"`*"]
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub unsafe fn GetEncodingConfigurationPropertyStore(&self, wstreamnumber: u16) -> ::windows::core::Result<super::super::UI::Shell::PropertiesSystem::IPropertyStore> {
        let mut result__ = ::windows::core::zeroed::<super::super::UI::Shell::PropertiesSystem::IPropertyStore>();
        (::windows::core::Interface::vtable(self).GetEncodingConfigurationPropertyStore)(::windows::core::Interface::as_raw(self), wstreamnumber, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFASFContentInfo, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFASFContentInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFASFContentInfo {}
impl ::core::fmt::Debug for IMFASFContentInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFASFContentInfo").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFASFContentInfo {
    type Vtable = IMFASFContentInfo_Vtbl;
}
impl ::core::clone::Clone for IMFASFContentInfo {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFASFContentInfo {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb1dca5cd_d5da_4451_8e9e_db5c59914ead);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFASFContentInfo_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetHeaderSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pistartofcontent: *mut ::core::ffi::c_void, cbheadersize: *mut u64) -> ::windows::core::HRESULT,
    pub ParseHeader: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, piheaderbuffer: *mut ::core::ffi::c_void, cboffsetwithinheader: u64) -> ::windows::core::HRESULT,
    pub GenerateHeader: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, piheader: *mut ::core::ffi::c_void, pcbheader: *mut u32) -> ::windows::core::HRESULT,
    pub GetProfile: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppiprofile: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetProfile: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, piprofile: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GeneratePresentationDescriptor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppipresentationdescriptor: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub GetEncodingConfigurationPropertyStore: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, wstreamnumber: u16, ppistore: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_UI_Shell_PropertiesSystem"))]
    GetEncodingConfigurationPropertyStore: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFASFIndexer(::windows::core::IUnknown);
impl IMFASFIndexer {
    pub unsafe fn SetFlags(&self, dwflags: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetFlags)(::windows::core::Interface::as_raw(self), dwflags).ok()
    }
    pub unsafe fn GetFlags(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetFlags)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn Initialize<P0>(&self, picontentinfo: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFASFContentInfo>,
    {
        (::windows::core::Interface::vtable(self).Initialize)(::windows::core::Interface::as_raw(self), picontentinfo.into_param().abi()).ok()
    }
    pub unsafe fn GetIndexPosition<P0>(&self, picontentinfo: P0) -> ::windows::core::Result<u64>
    where
        P0: ::windows::core::IntoParam<IMFASFContentInfo>,
    {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).GetIndexPosition)(::windows::core::Interface::as_raw(self), picontentinfo.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetIndexByteStreams(&self, ppibytestreams: *const ::core::option::Option<IMFByteStream>, cbytestreams: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetIndexByteStreams)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(ppibytestreams), cbytestreams).ok()
    }
    pub unsafe fn GetIndexByteStreamCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetIndexByteStreamCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetIndexStatus(&self, pindexidentifier: *const ASF_INDEX_IDENTIFIER, pfisindexed: *mut super::super::Foundation::BOOL, pbindexdescriptor: *mut u8, pcbindexdescriptor: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetIndexStatus)(::windows::core::Interface::as_raw(self), pindexidentifier, pfisindexed, pbindexdescriptor, pcbindexdescriptor).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetIndexStatus<P0>(&self, pbindexdescriptor: *const u8, cbindexdescriptor: u32, fgenerateindex: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetIndexStatus)(::windows::core::Interface::as_raw(self), pbindexdescriptor, cbindexdescriptor, fgenerateindex.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetSeekPositionForValue(&self, pvarvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pindexidentifier: *const ASF_INDEX_IDENTIFIER, pcboffsetwithindata: *mut u64, phnsapproxtime: *mut i64, pdwpayloadnumberofstreamwithinpacket: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetSeekPositionForValue)(::windows::core::Interface::as_raw(self), pvarvalue, pindexidentifier, pcboffsetwithindata, phnsapproxtime, pdwpayloadnumberofstreamwithinpacket).ok()
    }
    pub unsafe fn GenerateIndexEntries<P0>(&self, piasfpacketsample: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFSample>,
    {
        (::windows::core::Interface::vtable(self).GenerateIndexEntries)(::windows::core::Interface::as_raw(self), piasfpacketsample.into_param().abi()).ok()
    }
    pub unsafe fn CommitIndex<P0>(&self, picontentinfo: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFASFContentInfo>,
    {
        (::windows::core::Interface::vtable(self).CommitIndex)(::windows::core::Interface::as_raw(self), picontentinfo.into_param().abi()).ok()
    }
    pub unsafe fn GetIndexWriteSpace(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).GetIndexWriteSpace)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetCompletedIndex<P0>(&self, piindexbuffer: P0, cboffsetwithinindex: u64) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaBuffer>,
    {
        (::windows::core::Interface::vtable(self).GetCompletedIndex)(::windows::core::Interface::as_raw(self), piindexbuffer.into_param().abi(), cboffsetwithinindex).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFASFIndexer, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFASFIndexer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFASFIndexer {}
impl ::core::fmt::Debug for IMFASFIndexer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFASFIndexer").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFASFIndexer {
    type Vtable = IMFASFIndexer_Vtbl;
}
impl ::core::clone::Clone for IMFASFIndexer {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFASFIndexer {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x53590f48_dc3b_4297_813f_787761ad7b3e);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFASFIndexer_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetFlags: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::HRESULT,
    pub GetFlags: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwflags: *mut u32) -> ::windows::core::HRESULT,
    pub Initialize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, picontentinfo: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetIndexPosition: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, picontentinfo: *mut ::core::ffi::c_void, pcbindexoffset: *mut u64) -> ::windows::core::HRESULT,
    pub SetIndexByteStreams: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppibytestreams: *const *mut ::core::ffi::c_void, cbytestreams: u32) -> ::windows::core::HRESULT,
    pub GetIndexByteStreamCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcbytestreams: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub GetIndexStatus: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pindexidentifier: *const ASF_INDEX_IDENTIFIER, pfisindexed: *mut super::super::Foundation::BOOL, pbindexdescriptor: *mut u8, pcbindexdescriptor: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetIndexStatus: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub SetIndexStatus: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbindexdescriptor: *const u8, cbindexdescriptor: u32, fgenerateindex: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetIndexStatus: usize,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub GetSeekPositionForValue: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pvarvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pindexidentifier: *const ASF_INDEX_IDENTIFIER, pcboffsetwithindata: *mut u64, phnsapproxtime: *mut i64, pdwpayloadnumberofstreamwithinpacket: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    GetSeekPositionForValue: usize,
    pub GenerateIndexEntries: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, piasfpacketsample: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub CommitIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, picontentinfo: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetIndexWriteSpace: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcbindexwritespace: *mut u64) -> ::windows::core::HRESULT,
    pub GetCompletedIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, piindexbuffer: *mut ::core::ffi::c_void, cboffsetwithinindex: u64) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFASFMultiplexer(::windows::core::IUnknown);
impl IMFASFMultiplexer {
    pub unsafe fn Initialize<P0>(&self, picontentinfo: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFASFContentInfo>,
    {
        (::windows::core::Interface::vtable(self).Initialize)(::windows::core::Interface::as_raw(self), picontentinfo.into_param().abi()).ok()
    }
    pub unsafe fn SetFlags(&self, dwflags: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetFlags)(::windows::core::Interface::as_raw(self), dwflags).ok()
    }
    pub unsafe fn GetFlags(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetFlags)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn ProcessSample<P0>(&self, wstreamnumber: u16, pisample: P0, hnstimestampadjust: i64) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFSample>,
    {
        (::windows::core::Interface::vtable(self).ProcessSample)(::windows::core::Interface::as_raw(self), wstreamnumber, pisample.into_param().abi(), hnstimestampadjust).ok()
    }
    pub unsafe fn GetNextPacket(&self, pdwstatusflags: *mut u32, ppipacket: *mut ::core::option::Option<IMFSample>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetNextPacket)(::windows::core::Interface::as_raw(self), pdwstatusflags, ::core::mem::transmute(ppipacket)).ok()
    }
    pub unsafe fn Flush(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Flush)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn End<P0>(&self, picontentinfo: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFASFContentInfo>,
    {
        (::windows::core::Interface::vtable(self).End)(::windows::core::Interface::as_raw(self), picontentinfo.into_param().abi()).ok()
    }
    pub unsafe fn GetStatistics(&self, wstreamnumber: u16) -> ::windows::core::Result<ASF_MUX_STATISTICS> {
        let mut result__ = ::windows::core::zeroed::<ASF_MUX_STATISTICS>();
        (::windows::core::Interface::vtable(self).GetStatistics)(::windows::core::Interface::as_raw(self), wstreamnumber, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetSyncTolerance(&self, mssynctolerance: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetSyncTolerance)(::windows::core::Interface::as_raw(self), mssynctolerance).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFASFMultiplexer, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFASFMultiplexer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFASFMultiplexer {}
impl ::core::fmt::Debug for IMFASFMultiplexer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFASFMultiplexer").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFASFMultiplexer {
    type Vtable = IMFASFMultiplexer_Vtbl;
}
impl ::core::clone::Clone for IMFASFMultiplexer {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFASFMultiplexer {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x57bdd80a_9b38_4838_b737_c58f670d7d4f);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFASFMultiplexer_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub Initialize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, picontentinfo: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetFlags: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::HRESULT,
    pub GetFlags: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwflags: *mut u32) -> ::windows::core::HRESULT,
    pub ProcessSample: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, wstreamnumber: u16, pisample: *mut ::core::ffi::c_void, hnstimestampadjust: i64) -> ::windows::core::HRESULT,
    pub GetNextPacket: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwstatusflags: *mut u32, ppipacket: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Flush: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub End: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, picontentinfo: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetStatistics: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, wstreamnumber: u16, pmuxstats: *mut ASF_MUX_STATISTICS) -> ::windows::core::HRESULT,
    pub SetSyncTolerance: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, mssynctolerance: u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFASFMutualExclusion(::windows::core::IUnknown);
impl IMFASFMutualExclusion {
    pub unsafe fn GetType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).GetType)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetType(&self, guidtype: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetType)(::windows::core::Interface::as_raw(self), guidtype).ok()
    }
    pub unsafe fn GetRecordCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetRecordCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStreamsForRecord(&self, dwrecordnumber: u32, pwstreamnumarray: *mut u16, pcstreams: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetStreamsForRecord)(::windows::core::Interface::as_raw(self), dwrecordnumber, pwstreamnumarray, pcstreams).ok()
    }
    pub unsafe fn AddStreamForRecord(&self, dwrecordnumber: u32, wstreamnumber: u16) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).AddStreamForRecord)(::windows::core::Interface::as_raw(self), dwrecordnumber, wstreamnumber).ok()
    }
    pub unsafe fn RemoveStreamFromRecord(&self, dwrecordnumber: u32, wstreamnumber: u16) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveStreamFromRecord)(::windows::core::Interface::as_raw(self), dwrecordnumber, wstreamnumber).ok()
    }
    pub unsafe fn RemoveRecord(&self, dwrecordnumber: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveRecord)(::windows::core::Interface::as_raw(self), dwrecordnumber).ok()
    }
    pub unsafe fn AddRecord(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).AddRecord)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IMFASFMutualExclusion> {
        let mut result__ = ::windows::core::zeroed::<IMFASFMutualExclusion>();
        (::windows::core::Interface::vtable(self).Clone)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFASFMutualExclusion, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFASFMutualExclusion {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFASFMutualExclusion {}
impl ::core::fmt::Debug for IMFASFMutualExclusion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFASFMutualExclusion").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFASFMutualExclusion {
    type Vtable = IMFASFMutualExclusion_Vtbl;
}
impl ::core::clone::Clone for IMFASFMutualExclusion {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFASFMutualExclusion {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x12558291_e399_11d5_bc2a_00b0d0f3f4ab);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFASFMutualExclusion_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pguidtype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub SetType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidtype: *const ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub GetRecordCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwrecordcount: *mut u32) -> ::windows::core::HRESULT,
    pub GetStreamsForRecord: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwrecordnumber: u32, pwstreamnumarray: *mut u16, pcstreams: *mut u32) -> ::windows::core::HRESULT,
    pub AddStreamForRecord: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwrecordnumber: u32, wstreamnumber: u16) -> ::windows::core::HRESULT,
    pub RemoveStreamFromRecord: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwrecordnumber: u32, wstreamnumber: u16) -> ::windows::core::HRESULT,
    pub RemoveRecord: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwrecordnumber: u32) -> ::windows::core::HRESULT,
    pub AddRecord: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwrecordnumber: *mut u32) -> ::windows::core::HRESULT,
    pub Clone: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppimutex: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFASFProfile(::windows::core::IUnknown);
impl IMFASFProfile {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItem(&self, guidkey: *const ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItem)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetItemType(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<MF_ATTRIBUTE_TYPE> {
        let mut result__ = ::windows::core::zeroed::<MF_ATTRIBUTE_TYPE>();
        (::windows::core::Interface::vtable(self).base__.GetItemType)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn CompareItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.CompareItem)(::windows::core::Interface::as_raw(self), guidkey, value, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Compare<P0>(&self, ptheirs: P0, matchtype: MF_ATTRIBUTES_MATCH_TYPE) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.Compare)(::windows::core::Interface::as_raw(self), ptheirs.into_param().abi(), matchtype, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT32(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetUINT32)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT64(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).base__.GetUINT64)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDouble(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).base__.GetDouble)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetGUID(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).base__.GetGUID)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStringLength(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetStringLength)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetString(&self, guidkey: *const ::windows::core::GUID, pwszvalue: &mut [u16], pcchlength: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetString)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pwszvalue.as_ptr()), pwszvalue.len() as _, ::core::mem::transmute(pcchlength.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedString(&self, guidkey: *const ::windows::core::GUID, ppwszvalue: *mut ::windows::core::PWSTR, pcchlength: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedString)(::windows::core::Interface::as_raw(self), guidkey, ppwszvalue, pcchlength).ok()
    }
    pub unsafe fn GetBlobSize(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetBlobSize)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &mut [u8], pcbblobsize: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _, ::core::mem::transmute(pcbblobsize.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedBlob(&self, guidkey: *const ::windows::core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedBlob)(::windows::core::Interface::as_raw(self), guidkey, ppbuf, pcbsize).ok()
    }
    pub unsafe fn GetUnknown<T>(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.GetUnknown)(::windows::core::Interface::as_raw(self), guidkey, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetItem)(::windows::core::Interface::as_raw(self), guidkey, value).ok()
    }
    pub unsafe fn DeleteItem(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteItem)(::windows::core::Interface::as_raw(self), guidkey).ok()
    }
    pub unsafe fn DeleteAllItems(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteAllItems)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetUINT32(&self, guidkey: *const ::windows::core::GUID, unvalue: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT32)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetUINT64(&self, guidkey: *const ::windows::core::GUID, unvalue: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT64)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetDouble(&self, guidkey: *const ::windows::core::GUID, fvalue: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetDouble)(::windows::core::Interface::as_raw(self), guidkey, fvalue).ok()
    }
    pub unsafe fn SetGUID(&self, guidkey: *const ::windows::core::GUID, guidvalue: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetGUID)(::windows::core::Interface::as_raw(self), guidkey, guidvalue).ok()
    }
    pub unsafe fn SetString<P0>(&self, guidkey: *const ::windows::core::GUID, wszvalue: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.SetString)(::windows::core::Interface::as_raw(self), guidkey, wszvalue.into_param().abi()).ok()
    }
    pub unsafe fn SetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _).ok()
    }
    pub unsafe fn SetUnknown<P0>(&self, guidkey: *const ::windows::core::GUID, punknown: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.SetUnknown)(::windows::core::Interface::as_raw(self), guidkey, punknown.into_param().abi()).ok()
    }
    pub unsafe fn LockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.LockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn UnlockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.UnlockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItemByIndex(&self, unindex: u32, pguidkey: *mut ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItemByIndex)(::windows::core::Interface::as_raw(self), unindex, pguidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn CopyAllItems<P0>(&self, pdest: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).base__.CopyAllItems)(::windows::core::Interface::as_raw(self), pdest.into_param().abi()).ok()
    }
    pub unsafe fn GetStreamCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetStreamCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStream(&self, dwstreamindex: u32, pwstreamnumber: *mut u16, ppistream: *mut ::core::option::Option<IMFASFStreamConfig>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetStream)(::windows::core::Interface::as_raw(self), dwstreamindex, pwstreamnumber, ::core::mem::transmute(ppistream)).ok()
    }
    pub unsafe fn GetStreamByNumber(&self, wstreamnumber: u16) -> ::windows::core::Result<IMFASFStreamConfig> {
        let mut result__ = ::windows::core::zeroed::<IMFASFStreamConfig>();
        (::windows::core::Interface::vtable(self).GetStreamByNumber)(::windows::core::Interface::as_raw(self), wstreamnumber, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetStream<P0>(&self, pistream: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFASFStreamConfig>,
    {
        (::windows::core::Interface::vtable(self).SetStream)(::windows::core::Interface::as_raw(self), pistream.into_param().abi()).ok()
    }
    pub unsafe fn RemoveStream(&self, wstreamnumber: u16) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveStream)(::windows::core::Interface::as_raw(self), wstreamnumber).ok()
    }
    pub unsafe fn CreateStream<P0>(&self, pimediatype: P0) -> ::windows::core::Result<IMFASFStreamConfig>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFASFStreamConfig>();
        (::windows::core::Interface::vtable(self).CreateStream)(::windows::core::Interface::as_raw(self), pimediatype.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetMutualExclusionCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetMutualExclusionCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetMutualExclusion(&self, dwmutexindex: u32) -> ::windows::core::Result<IMFASFMutualExclusion> {
        let mut result__ = ::windows::core::zeroed::<IMFASFMutualExclusion>();
        (::windows::core::Interface::vtable(self).GetMutualExclusion)(::windows::core::Interface::as_raw(self), dwmutexindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn AddMutualExclusion<P0>(&self, pimutex: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFASFMutualExclusion>,
    {
        (::windows::core::Interface::vtable(self).AddMutualExclusion)(::windows::core::Interface::as_raw(self), pimutex.into_param().abi()).ok()
    }
    pub unsafe fn RemoveMutualExclusion(&self, dwmutexindex: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveMutualExclusion)(::windows::core::Interface::as_raw(self), dwmutexindex).ok()
    }
    pub unsafe fn CreateMutualExclusion(&self) -> ::windows::core::Result<IMFASFMutualExclusion> {
        let mut result__ = ::windows::core::zeroed::<IMFASFMutualExclusion>();
        (::windows::core::Interface::vtable(self).CreateMutualExclusion)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStreamPrioritization(&self) -> ::windows::core::Result<IMFASFStreamPrioritization> {
        let mut result__ = ::windows::core::zeroed::<IMFASFStreamPrioritization>();
        (::windows::core::Interface::vtable(self).GetStreamPrioritization)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn AddStreamPrioritization<P0>(&self, pistreamprioritization: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFASFStreamPrioritization>,
    {
        (::windows::core::Interface::vtable(self).AddStreamPrioritization)(::windows::core::Interface::as_raw(self), pistreamprioritization.into_param().abi()).ok()
    }
    pub unsafe fn RemoveStreamPrioritization(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveStreamPrioritization)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn CreateStreamPrioritization(&self) -> ::windows::core::Result<IMFASFStreamPrioritization> {
        let mut result__ = ::windows::core::zeroed::<IMFASFStreamPrioritization>();
        (::windows::core::Interface::vtable(self).CreateStreamPrioritization)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IMFASFProfile> {
        let mut result__ = ::windows::core::zeroed::<IMFASFProfile>();
        (::windows::core::Interface::vtable(self).Clone)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFASFProfile, ::windows::core::IUnknown, IMFAttributes);
impl ::core::cmp::PartialEq for IMFASFProfile {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFASFProfile {}
impl ::core::fmt::Debug for IMFASFProfile {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFASFProfile").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFASFProfile {
    type Vtable = IMFASFProfile_Vtbl;
}
impl ::core::clone::Clone for IMFASFProfile {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFASFProfile {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd267bf6a_028b_4e0d_903d_43f0ef82d0d4);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFASFProfile_Vtbl {
    pub base__: IMFAttributes_Vtbl,
    pub GetStreamCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcstreams: *mut u32) -> ::windows::core::HRESULT,
    pub GetStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pwstreamnumber: *mut u16, ppistream: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetStreamByNumber: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, wstreamnumber: u16, ppistream: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pistream: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RemoveStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, wstreamnumber: u16) -> ::windows::core::HRESULT,
    pub CreateStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pimediatype: *mut ::core::ffi::c_void, ppistream: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetMutualExclusionCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcmutexs: *mut u32) -> ::windows::core::HRESULT,
    pub GetMutualExclusion: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwmutexindex: u32, ppimutex: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub AddMutualExclusion: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pimutex: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RemoveMutualExclusion: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwmutexindex: u32) -> ::windows::core::HRESULT,
    pub CreateMutualExclusion: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppimutex: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetStreamPrioritization: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppistreamprioritization: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub AddStreamPrioritization: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pistreamprioritization: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RemoveStreamPrioritization: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub CreateStreamPrioritization: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppistreamprioritization: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Clone: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppiprofile: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFASFSplitter(::windows::core::IUnknown);
impl IMFASFSplitter {
    pub unsafe fn Initialize<P0>(&self, picontentinfo: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFASFContentInfo>,
    {
        (::windows::core::Interface::vtable(self).Initialize)(::windows::core::Interface::as_raw(self), picontentinfo.into_param().abi()).ok()
    }
    pub unsafe fn SetFlags(&self, dwflags: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetFlags)(::windows::core::Interface::as_raw(self), dwflags).ok()
    }
    pub unsafe fn GetFlags(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetFlags)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SelectStreams(&self, pwstreamnumbers: *const u16, wnumstreams: u16) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SelectStreams)(::windows::core::Interface::as_raw(self), pwstreamnumbers, wnumstreams).ok()
    }
    pub unsafe fn GetSelectedStreams(&self, pwstreamnumbers: *mut u16, pwnumstreams: *mut u16) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetSelectedStreams)(::windows::core::Interface::as_raw(self), pwstreamnumbers, pwnumstreams).ok()
    }
    pub unsafe fn ParseData<P0>(&self, pibuffer: P0, cbbufferoffset: u32, cblength: u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaBuffer>,
    {
        (::windows::core::Interface::vtable(self).ParseData)(::windows::core::Interface::as_raw(self), pibuffer.into_param().abi(), cbbufferoffset, cblength).ok()
    }
    pub unsafe fn GetNextSample(&self, pdwstatusflags: *mut ASF_STATUSFLAGS, pwstreamnumber: *mut u16, ppisample: *mut ::core::option::Option<IMFSample>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetNextSample)(::windows::core::Interface::as_raw(self), pdwstatusflags, pwstreamnumber, ::core::mem::transmute(ppisample)).ok()
    }
    pub unsafe fn Flush(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Flush)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetLastSendTime(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetLastSendTime)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFASFSplitter, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFASFSplitter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFASFSplitter {}
impl ::core::fmt::Debug for IMFASFSplitter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFASFSplitter").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFASFSplitter {
    type Vtable = IMFASFSplitter_Vtbl;
}
impl ::core::clone::Clone for IMFASFSplitter {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFASFSplitter {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x12558295_e399_11d5_bc2a_00b0d0f3f4ab);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFASFSplitter_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub Initialize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, picontentinfo: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetFlags: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::HRESULT,
    pub GetFlags: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwflags: *mut u32) -> ::windows::core::HRESULT,
    pub SelectStreams: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pwstreamnumbers: *const u16, wnumstreams: u16) -> ::windows::core::HRESULT,
    pub GetSelectedStreams: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pwstreamnumbers: *mut u16, pwnumstreams: *mut u16) -> ::windows::core::HRESULT,
    pub ParseData: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pibuffer: *mut ::core::ffi::c_void, cbbufferoffset: u32, cblength: u32) -> ::windows::core::HRESULT,
    pub GetNextSample: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwstatusflags: *mut ASF_STATUSFLAGS, pwstreamnumber: *mut u16, ppisample: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Flush: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetLastSendTime: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwlastsendtime: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFASFStreamConfig(::windows::core::IUnknown);
impl IMFASFStreamConfig {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItem(&self, guidkey: *const ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItem)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetItemType(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<MF_ATTRIBUTE_TYPE> {
        let mut result__ = ::windows::core::zeroed::<MF_ATTRIBUTE_TYPE>();
        (::windows::core::Interface::vtable(self).base__.GetItemType)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn CompareItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.CompareItem)(::windows::core::Interface::as_raw(self), guidkey, value, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Compare<P0>(&self, ptheirs: P0, matchtype: MF_ATTRIBUTES_MATCH_TYPE) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.Compare)(::windows::core::Interface::as_raw(self), ptheirs.into_param().abi(), matchtype, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT32(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetUINT32)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT64(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).base__.GetUINT64)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDouble(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).base__.GetDouble)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetGUID(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).base__.GetGUID)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStringLength(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetStringLength)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetString(&self, guidkey: *const ::windows::core::GUID, pwszvalue: &mut [u16], pcchlength: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetString)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pwszvalue.as_ptr()), pwszvalue.len() as _, ::core::mem::transmute(pcchlength.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedString(&self, guidkey: *const ::windows::core::GUID, ppwszvalue: *mut ::windows::core::PWSTR, pcchlength: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedString)(::windows::core::Interface::as_raw(self), guidkey, ppwszvalue, pcchlength).ok()
    }
    pub unsafe fn GetBlobSize(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetBlobSize)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &mut [u8], pcbblobsize: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _, ::core::mem::transmute(pcbblobsize.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedBlob(&self, guidkey: *const ::windows::core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedBlob)(::windows::core::Interface::as_raw(self), guidkey, ppbuf, pcbsize).ok()
    }
    pub unsafe fn GetUnknown<T>(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.GetUnknown)(::windows::core::Interface::as_raw(self), guidkey, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetItem)(::windows::core::Interface::as_raw(self), guidkey, value).ok()
    }
    pub unsafe fn DeleteItem(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteItem)(::windows::core::Interface::as_raw(self), guidkey).ok()
    }
    pub unsafe fn DeleteAllItems(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteAllItems)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetUINT32(&self, guidkey: *const ::windows::core::GUID, unvalue: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT32)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetUINT64(&self, guidkey: *const ::windows::core::GUID, unvalue: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT64)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetDouble(&self, guidkey: *const ::windows::core::GUID, fvalue: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetDouble)(::windows::core::Interface::as_raw(self), guidkey, fvalue).ok()
    }
    pub unsafe fn SetGUID(&self, guidkey: *const ::windows::core::GUID, guidvalue: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetGUID)(::windows::core::Interface::as_raw(self), guidkey, guidvalue).ok()
    }
    pub unsafe fn SetString<P0>(&self, guidkey: *const ::windows::core::GUID, wszvalue: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.SetString)(::windows::core::Interface::as_raw(self), guidkey, wszvalue.into_param().abi()).ok()
    }
    pub unsafe fn SetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _).ok()
    }
    pub unsafe fn SetUnknown<P0>(&self, guidkey: *const ::windows::core::GUID, punknown: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.SetUnknown)(::windows::core::Interface::as_raw(self), guidkey, punknown.into_param().abi()).ok()
    }
    pub unsafe fn LockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.LockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn UnlockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.UnlockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItemByIndex(&self, unindex: u32, pguidkey: *mut ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItemByIndex)(::windows::core::Interface::as_raw(self), unindex, pguidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn CopyAllItems<P0>(&self, pdest: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).base__.CopyAllItems)(::windows::core::Interface::as_raw(self), pdest.into_param().abi()).ok()
    }
    pub unsafe fn GetStreamType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).GetStreamType)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStreamNumber(&self) -> u16 {
        (::windows::core::Interface::vtable(self).GetStreamNumber)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetStreamNumber(&self, wstreamnum: u16) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetStreamNumber)(::windows::core::Interface::as_raw(self), wstreamnum).ok()
    }
    pub unsafe fn GetMediaType(&self) -> ::windows::core::Result<IMFMediaType> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
        (::windows::core::Interface::vtable(self).GetMediaType)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetMediaType<P0>(&self, pimediatype: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        (::windows::core::Interface::vtable(self).SetMediaType)(::windows::core::Interface::as_raw(self), pimediatype.into_param().abi()).ok()
    }
    pub unsafe fn GetPayloadExtensionCount(&self) -> ::windows::core::Result<u16> {
        let mut result__ = ::windows::core::zeroed::<u16>();
        (::windows::core::Interface::vtable(self).GetPayloadExtensionCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetPayloadExtension(&self, wpayloadextensionnumber: u16, pguidextensionsystemid: *mut ::windows::core::GUID, pcbextensiondatasize: *mut u16, pbextensionsysteminfo: *mut u8, pcbextensionsysteminfo: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetPayloadExtension)(::windows::core::Interface::as_raw(self), wpayloadextensionnumber, pguidextensionsystemid, pcbextensiondatasize, pbextensionsysteminfo, pcbextensionsysteminfo).ok()
    }
    pub unsafe fn AddPayloadExtension(&self, guidextensionsystemid: ::windows::core::GUID, cbextensiondatasize: u16, pbextensionsysteminfo: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).AddPayloadExtension)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(guidextensionsystemid), cbextensiondatasize, ::core::mem::transmute(pbextensionsysteminfo.as_ptr()), pbextensionsysteminfo.len() as _).ok()
    }
    pub unsafe fn RemoveAllPayloadExtensions(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveAllPayloadExtensions)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IMFASFStreamConfig> {
        let mut result__ = ::windows::core::zeroed::<IMFASFStreamConfig>();
        (::windows::core::Interface::vtable(self).Clone)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFASFStreamConfig, ::windows::core::IUnknown, IMFAttributes);
impl ::core::cmp::PartialEq for IMFASFStreamConfig {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFASFStreamConfig {}
impl ::core::fmt::Debug for IMFASFStreamConfig {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFASFStreamConfig").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFASFStreamConfig {
    type Vtable = IMFASFStreamConfig_Vtbl;
}
impl ::core::clone::Clone for IMFASFStreamConfig {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFASFStreamConfig {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9e8ae8d2_dbbd_4200_9aca_06e6df484913);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFASFStreamConfig_Vtbl {
    pub base__: IMFAttributes_Vtbl,
    pub GetStreamType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pguidstreamtype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub GetStreamNumber: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u16,
    pub SetStreamNumber: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, wstreamnum: u16) -> ::windows::core::HRESULT,
    pub GetMediaType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppimediatype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetMediaType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pimediatype: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetPayloadExtensionCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcpayloadextensions: *mut u16) -> ::windows::core::HRESULT,
    pub GetPayloadExtension: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, wpayloadextensionnumber: u16, pguidextensionsystemid: *mut ::windows::core::GUID, pcbextensiondatasize: *mut u16, pbextensionsysteminfo: *mut u8, pcbextensionsysteminfo: *mut u32) -> ::windows::core::HRESULT,
    pub AddPayloadExtension: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidextensionsystemid: ::windows::core::GUID, cbextensiondatasize: u16, pbextensionsysteminfo: *const u8, cbextensionsysteminfo: u32) -> ::windows::core::HRESULT,
    pub RemoveAllPayloadExtensions: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Clone: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppistreamconfig: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFASFStreamPrioritization(::windows::core::IUnknown);
impl IMFASFStreamPrioritization {
    pub unsafe fn GetStreamCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetStreamCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStream(&self, dwstreamindex: u32, pwstreamnumber: *mut u16, pwstreamflags: *mut u16) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetStream)(::windows::core::Interface::as_raw(self), dwstreamindex, pwstreamnumber, pwstreamflags).ok()
    }
    pub unsafe fn AddStream(&self, wstreamnumber: u16, wstreamflags: u16) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).AddStream)(::windows::core::Interface::as_raw(self), wstreamnumber, wstreamflags).ok()
    }
    pub unsafe fn RemoveStream(&self, dwstreamindex: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveStream)(::windows::core::Interface::as_raw(self), dwstreamindex).ok()
    }
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IMFASFStreamPrioritization> {
        let mut result__ = ::windows::core::zeroed::<IMFASFStreamPrioritization>();
        (::windows::core::Interface::vtable(self).Clone)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFASFStreamPrioritization, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFASFStreamPrioritization {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFASFStreamPrioritization {}
impl ::core::fmt::Debug for IMFASFStreamPrioritization {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFASFStreamPrioritization").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFASFStreamPrioritization {
    type Vtable = IMFASFStreamPrioritization_Vtbl;
}
impl ::core::clone::Clone for IMFASFStreamPrioritization {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFASFStreamPrioritization {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x699bdc27_bbaf_49ff_8e38_9c39c9b5e088);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFASFStreamPrioritization_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetStreamCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwstreamcount: *mut u32) -> ::windows::core::HRESULT,
    pub GetStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pwstreamnumber: *mut u16, pwstreamflags: *mut u16) -> ::windows::core::HRESULT,
    pub AddStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, wstreamnumber: u16, wstreamflags: u16) -> ::windows::core::HRESULT,
    pub RemoveStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32) -> ::windows::core::HRESULT,
    pub Clone: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppistreamprioritization: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFASFStreamSelector(::windows::core::IUnknown);
impl IMFASFStreamSelector {
    pub unsafe fn GetStreamCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetStreamCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetOutputCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetOutputCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetOutputStreamCount(&self, dwoutputnum: u32) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetOutputStreamCount)(::windows::core::Interface::as_raw(self), dwoutputnum, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetOutputStreamNumbers(&self, dwoutputnum: u32) -> ::windows::core::Result<u16> {
        let mut result__ = ::windows::core::zeroed::<u16>();
        (::windows::core::Interface::vtable(self).GetOutputStreamNumbers)(::windows::core::Interface::as_raw(self), dwoutputnum, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetOutputFromStream(&self, wstreamnum: u16) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetOutputFromStream)(::windows::core::Interface::as_raw(self), wstreamnum, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetOutputOverride(&self, dwoutputnum: u32) -> ::windows::core::Result<ASF_SELECTION_STATUS> {
        let mut result__ = ::windows::core::zeroed::<ASF_SELECTION_STATUS>();
        (::windows::core::Interface::vtable(self).GetOutputOverride)(::windows::core::Interface::as_raw(self), dwoutputnum, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetOutputOverride(&self, dwoutputnum: u32, selection: ASF_SELECTION_STATUS) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetOutputOverride)(::windows::core::Interface::as_raw(self), dwoutputnum, selection).ok()
    }
    pub unsafe fn GetOutputMutexCount(&self, dwoutputnum: u32) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetOutputMutexCount)(::windows::core::Interface::as_raw(self), dwoutputnum, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetOutputMutex(&self, dwoutputnum: u32, dwmutexnum: u32) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::IUnknown>();
        (::windows::core::Interface::vtable(self).GetOutputMutex)(::windows::core::Interface::as_raw(self), dwoutputnum, dwmutexnum, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetOutputMutexSelection(&self, dwoutputnum: u32, dwmutexnum: u32, wselectedrecord: u16) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetOutputMutexSelection)(::windows::core::Interface::as_raw(self), dwoutputnum, dwmutexnum, wselectedrecord).ok()
    }
    pub unsafe fn GetBandwidthStepCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetBandwidthStepCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBandwidthStep(&self, dwstepnum: u32, pdwbitrate: *mut u32, rgwstreamnumbers: *mut u16, rgselections: *mut ASF_SELECTION_STATUS) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetBandwidthStep)(::windows::core::Interface::as_raw(self), dwstepnum, pdwbitrate, rgwstreamnumbers, rgselections).ok()
    }
    pub unsafe fn BitrateToStepNumber(&self, dwbitrate: u32) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).BitrateToStepNumber)(::windows::core::Interface::as_raw(self), dwbitrate, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetStreamSelectorFlags(&self, dwstreamselectorflags: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetStreamSelectorFlags)(::windows::core::Interface::as_raw(self), dwstreamselectorflags).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFASFStreamSelector, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFASFStreamSelector {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFASFStreamSelector {}
impl ::core::fmt::Debug for IMFASFStreamSelector {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFASFStreamSelector").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFASFStreamSelector {
    type Vtable = IMFASFStreamSelector_Vtbl;
}
impl ::core::clone::Clone for IMFASFStreamSelector {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFASFStreamSelector {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd01bad4a_4fa0_4a60_9349_c27e62da9d41);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFASFStreamSelector_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetStreamCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcstreams: *mut u32) -> ::windows::core::HRESULT,
    pub GetOutputCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcoutputs: *mut u32) -> ::windows::core::HRESULT,
    pub GetOutputStreamCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwoutputnum: u32, pcstreams: *mut u32) -> ::windows::core::HRESULT,
    pub GetOutputStreamNumbers: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwoutputnum: u32, rgwstreamnumbers: *mut u16) -> ::windows::core::HRESULT,
    pub GetOutputFromStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, wstreamnum: u16, pdwoutput: *mut u32) -> ::windows::core::HRESULT,
    pub GetOutputOverride: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwoutputnum: u32, pselection: *mut ASF_SELECTION_STATUS) -> ::windows::core::HRESULT,
    pub SetOutputOverride: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwoutputnum: u32, selection: ASF_SELECTION_STATUS) -> ::windows::core::HRESULT,
    pub GetOutputMutexCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwoutputnum: u32, pcmutexes: *mut u32) -> ::windows::core::HRESULT,
    pub GetOutputMutex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwoutputnum: u32, dwmutexnum: u32, ppmutex: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetOutputMutexSelection: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwoutputnum: u32, dwmutexnum: u32, wselectedrecord: u16) -> ::windows::core::HRESULT,
    pub GetBandwidthStepCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcstepcount: *mut u32) -> ::windows::core::HRESULT,
    pub GetBandwidthStep: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstepnum: u32, pdwbitrate: *mut u32, rgwstreamnumbers: *mut u16, rgselections: *mut ASF_SELECTION_STATUS) -> ::windows::core::HRESULT,
    pub BitrateToStepNumber: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwbitrate: u32, pdwstepnum: *mut u32) -> ::windows::core::HRESULT,
    pub SetStreamSelectorFlags: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamselectorflags: u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFActivate(::windows::core::IUnknown);
impl IMFActivate {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItem(&self, guidkey: *const ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItem)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetItemType(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<MF_ATTRIBUTE_TYPE> {
        let mut result__ = ::windows::core::zeroed::<MF_ATTRIBUTE_TYPE>();
        (::windows::core::Interface::vtable(self).base__.GetItemType)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn CompareItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.CompareItem)(::windows::core::Interface::as_raw(self), guidkey, value, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Compare<P0>(&self, ptheirs: P0, matchtype: MF_ATTRIBUTES_MATCH_TYPE) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.Compare)(::windows::core::Interface::as_raw(self), ptheirs.into_param().abi(), matchtype, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT32(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetUINT32)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT64(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).base__.GetUINT64)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDouble(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).base__.GetDouble)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetGUID(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).base__.GetGUID)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStringLength(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetStringLength)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetString(&self, guidkey: *const ::windows::core::GUID, pwszvalue: &mut [u16], pcchlength: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetString)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pwszvalue.as_ptr()), pwszvalue.len() as _, ::core::mem::transmute(pcchlength.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedString(&self, guidkey: *const ::windows::core::GUID, ppwszvalue: *mut ::windows::core::PWSTR, pcchlength: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedString)(::windows::core::Interface::as_raw(self), guidkey, ppwszvalue, pcchlength).ok()
    }
    pub unsafe fn GetBlobSize(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetBlobSize)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &mut [u8], pcbblobsize: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _, ::core::mem::transmute(pcbblobsize.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedBlob(&self, guidkey: *const ::windows::core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedBlob)(::windows::core::Interface::as_raw(self), guidkey, ppbuf, pcbsize).ok()
    }
    pub unsafe fn GetUnknown<T>(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.GetUnknown)(::windows::core::Interface::as_raw(self), guidkey, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetItem)(::windows::core::Interface::as_raw(self), guidkey, value).ok()
    }
    pub unsafe fn DeleteItem(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteItem)(::windows::core::Interface::as_raw(self), guidkey).ok()
    }
    pub unsafe fn DeleteAllItems(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteAllItems)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetUINT32(&self, guidkey: *const ::windows::core::GUID, unvalue: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT32)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetUINT64(&self, guidkey: *const ::windows::core::GUID, unvalue: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT64)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetDouble(&self, guidkey: *const ::windows::core::GUID, fvalue: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetDouble)(::windows::core::Interface::as_raw(self), guidkey, fvalue).ok()
    }
    pub unsafe fn SetGUID(&self, guidkey: *const ::windows::core::GUID, guidvalue: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetGUID)(::windows::core::Interface::as_raw(self), guidkey, guidvalue).ok()
    }
    pub unsafe fn SetString<P0>(&self, guidkey: *const ::windows::core::GUID, wszvalue: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.SetString)(::windows::core::Interface::as_raw(self), guidkey, wszvalue.into_param().abi()).ok()
    }
    pub unsafe fn SetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _).ok()
    }
    pub unsafe fn SetUnknown<P0>(&self, guidkey: *const ::windows::core::GUID, punknown: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.SetUnknown)(::windows::core::Interface::as_raw(self), guidkey, punknown.into_param().abi()).ok()
    }
    pub unsafe fn LockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.LockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn UnlockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.UnlockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItemByIndex(&self, unindex: u32, pguidkey: *mut ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItemByIndex)(::windows::core::Interface::as_raw(self), unindex, pguidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn CopyAllItems<P0>(&self, pdest: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).base__.CopyAllItems)(::windows::core::Interface::as_raw(self), pdest.into_param().abi()).ok()
    }
    pub unsafe fn ActivateObject<T>(&self) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).ActivateObject)(::windows::core::Interface::as_raw(self), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    pub unsafe fn ShutdownObject(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ShutdownObject)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn DetachObject(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).DetachObject)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFActivate, ::windows::core::IUnknown, IMFAttributes);
impl ::core::cmp::PartialEq for IMFActivate {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFActivate {}
impl ::core::fmt::Debug for IMFActivate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFActivate").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFActivate {
    type Vtable = IMFActivate_Vtbl;
}
impl ::core::clone::Clone for IMFActivate {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFActivate {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7fee9e9a_4a89_47a6_899c_b6a53a70fb67);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFActivate_Vtbl {
    pub base__: IMFAttributes_Vtbl,
    pub ActivateObject: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub ShutdownObject: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub DetachObject: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFAsyncCallback(::windows::core::IUnknown);
impl IMFAsyncCallback {
    pub unsafe fn GetParameters(&self, pdwflags: *mut u32, pdwqueue: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetParameters)(::windows::core::Interface::as_raw(self), pdwflags, pdwqueue).ok()
    }
    pub unsafe fn Invoke<P0>(&self, pasyncresult: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        (::windows::core::Interface::vtable(self).Invoke)(::windows::core::Interface::as_raw(self), pasyncresult.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFAsyncCallback, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFAsyncCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFAsyncCallback {}
impl ::core::fmt::Debug for IMFAsyncCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFAsyncCallback").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFAsyncCallback {
    type Vtable = IMFAsyncCallback_Vtbl;
}
impl ::core::clone::Clone for IMFAsyncCallback {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFAsyncCallback {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa27003cf_2354_4f2a_8d6a_ab7cff15437e);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFAsyncCallback_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetParameters: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwflags: *mut u32, pdwqueue: *mut u32) -> ::windows::core::HRESULT,
    pub Invoke: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pasyncresult: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFAsyncCallbackLogging(::windows::core::IUnknown);
impl IMFAsyncCallbackLogging {
    pub unsafe fn GetParameters(&self, pdwflags: *mut u32, pdwqueue: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetParameters)(::windows::core::Interface::as_raw(self), pdwflags, pdwqueue).ok()
    }
    pub unsafe fn Invoke<P0>(&self, pasyncresult: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        (::windows::core::Interface::vtable(self).base__.Invoke)(::windows::core::Interface::as_raw(self), pasyncresult.into_param().abi()).ok()
    }
    pub unsafe fn GetObjectPointer(&self) -> *mut ::core::ffi::c_void {
        (::windows::core::Interface::vtable(self).GetObjectPointer)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetObjectTag(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetObjectTag)(::windows::core::Interface::as_raw(self))
    }
}
::windows::imp::interface_hierarchy!(IMFAsyncCallbackLogging, ::windows::core::IUnknown, IMFAsyncCallback);
impl ::core::cmp::PartialEq for IMFAsyncCallbackLogging {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFAsyncCallbackLogging {}
impl ::core::fmt::Debug for IMFAsyncCallbackLogging {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFAsyncCallbackLogging").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFAsyncCallbackLogging {
    type Vtable = IMFAsyncCallbackLogging_Vtbl;
}
impl ::core::clone::Clone for IMFAsyncCallbackLogging {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFAsyncCallbackLogging {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc7a4dca1_f5f0_47b6_b92b_bf0106d25791);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFAsyncCallbackLogging_Vtbl {
    pub base__: IMFAsyncCallback_Vtbl,
    pub GetObjectPointer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void,
    pub GetObjectTag: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFAsyncResult(::windows::core::IUnknown);
impl IMFAsyncResult {
    pub unsafe fn GetState(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::IUnknown>();
        (::windows::core::Interface::vtable(self).GetState)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStatus(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetStatus)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetStatus(&self, hrstatus: ::windows::core::HRESULT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetStatus)(::windows::core::Interface::as_raw(self), hrstatus).ok()
    }
    pub unsafe fn GetObject(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::IUnknown>();
        (::windows::core::Interface::vtable(self).GetObject)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStateNoAddRef(&self) -> ::core::option::Option<::windows::core::IUnknown> {
        (::windows::core::Interface::vtable(self).GetStateNoAddRef)(::windows::core::Interface::as_raw(self))
    }
}
::windows::imp::interface_hierarchy!(IMFAsyncResult, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFAsyncResult {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFAsyncResult {}
impl ::core::fmt::Debug for IMFAsyncResult {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFAsyncResult").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFAsyncResult {
    type Vtable = IMFAsyncResult_Vtbl;
}
impl ::core::clone::Clone for IMFAsyncResult {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFAsyncResult {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xac6b7889_0740_4d51_8619_905994a55cc6);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFAsyncResult_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppunkstate: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetStatus: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetStatus: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hrstatus: ::windows::core::HRESULT) -> ::windows::core::HRESULT,
    pub GetObject: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetStateNoAddRef: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::core::option::Option<::windows::core::IUnknown>,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFAttributes(::windows::core::IUnknown);
impl IMFAttributes {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItem(&self, guidkey: *const ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetItem)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetItemType(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<MF_ATTRIBUTE_TYPE> {
        let mut result__ = ::windows::core::zeroed::<MF_ATTRIBUTE_TYPE>();
        (::windows::core::Interface::vtable(self).GetItemType)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn CompareItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).CompareItem)(::windows::core::Interface::as_raw(self), guidkey, value, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Compare<P0>(&self, ptheirs: P0, matchtype: MF_ATTRIBUTES_MATCH_TYPE) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).Compare)(::windows::core::Interface::as_raw(self), ptheirs.into_param().abi(), matchtype, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT32(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetUINT32)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT64(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).GetUINT64)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDouble(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).GetDouble)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetGUID(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).GetGUID)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStringLength(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetStringLength)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetString(&self, guidkey: *const ::windows::core::GUID, pwszvalue: &mut [u16], pcchlength: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetString)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pwszvalue.as_ptr()), pwszvalue.len() as _, ::core::mem::transmute(pcchlength.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedString(&self, guidkey: *const ::windows::core::GUID, ppwszvalue: *mut ::windows::core::PWSTR, pcchlength: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetAllocatedString)(::windows::core::Interface::as_raw(self), guidkey, ppwszvalue, pcchlength).ok()
    }
    pub unsafe fn GetBlobSize(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetBlobSize)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &mut [u8], pcbblobsize: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _, ::core::mem::transmute(pcbblobsize.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedBlob(&self, guidkey: *const ::windows::core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetAllocatedBlob)(::windows::core::Interface::as_raw(self), guidkey, ppbuf, pcbsize).ok()
    }
    pub unsafe fn GetUnknown<T>(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).GetUnknown)(::windows::core::Interface::as_raw(self), guidkey, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetItem)(::windows::core::Interface::as_raw(self), guidkey, value).ok()
    }
    pub unsafe fn DeleteItem(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).DeleteItem)(::windows::core::Interface::as_raw(self), guidkey).ok()
    }
    pub unsafe fn DeleteAllItems(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).DeleteAllItems)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetUINT32(&self, guidkey: *const ::windows::core::GUID, unvalue: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetUINT32)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetUINT64(&self, guidkey: *const ::windows::core::GUID, unvalue: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetUINT64)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetDouble(&self, guidkey: *const ::windows::core::GUID, fvalue: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetDouble)(::windows::core::Interface::as_raw(self), guidkey, fvalue).ok()
    }
    pub unsafe fn SetGUID(&self, guidkey: *const ::windows::core::GUID, guidvalue: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetGUID)(::windows::core::Interface::as_raw(self), guidkey, guidvalue).ok()
    }
    pub unsafe fn SetString<P0>(&self, guidkey: *const ::windows::core::GUID, wszvalue: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).SetString)(::windows::core::Interface::as_raw(self), guidkey, wszvalue.into_param().abi()).ok()
    }
    pub unsafe fn SetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _).ok()
    }
    pub unsafe fn SetUnknown<P0>(&self, guidkey: *const ::windows::core::GUID, punknown: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).SetUnknown)(::windows::core::Interface::as_raw(self), guidkey, punknown.into_param().abi()).ok()
    }
    pub unsafe fn LockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).LockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn UnlockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).UnlockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItemByIndex(&self, unindex: u32, pguidkey: *mut ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetItemByIndex)(::windows::core::Interface::as_raw(self), unindex, pguidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn CopyAllItems<P0>(&self, pdest: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).CopyAllItems)(::windows::core::Interface::as_raw(self), pdest.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFAttributes, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFAttributes {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFAttributes {}
impl ::core::fmt::Debug for IMFAttributes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFAttributes").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFAttributes {
    type Vtable = IMFAttributes_Vtbl;
}
impl ::core::clone::Clone for IMFAttributes {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFAttributes {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2cd2d921_c447_44a7_a13c_4adabfc247e3);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFAttributes_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub GetItem: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    GetItem: usize,
    pub GetItemType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, ptype: *mut MF_ATTRIBUTE_TYPE) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub CompareItem: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pbresult: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    CompareItem: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub Compare: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ptheirs: *mut ::core::ffi::c_void, matchtype: MF_ATTRIBUTES_MATCH_TYPE, pbresult: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    Compare: usize,
    pub GetUINT32: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, punvalue: *mut u32) -> ::windows::core::HRESULT,
    pub GetUINT64: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, punvalue: *mut u64) -> ::windows::core::HRESULT,
    pub GetDouble: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pfvalue: *mut f64) -> ::windows::core::HRESULT,
    pub GetGUID: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pguidvalue: *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub GetStringLength: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pcchlength: *mut u32) -> ::windows::core::HRESULT,
    pub GetString: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pwszvalue: ::windows::core::PWSTR, cchbufsize: u32, pcchlength: *mut u32) -> ::windows::core::HRESULT,
    pub GetAllocatedString: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, ppwszvalue: *mut ::windows::core::PWSTR, pcchlength: *mut u32) -> ::windows::core::HRESULT,
    pub GetBlobSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pcbblobsize: *mut u32) -> ::windows::core::HRESULT,
    pub GetBlob: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pbuf: *mut u8, cbbufsize: u32, pcbblobsize: *mut u32) -> ::windows::core::HRESULT,
    pub GetAllocatedBlob: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> ::windows::core::HRESULT,
    pub GetUnknown: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub SetItem: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    SetItem: usize,
    pub DeleteItem: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub DeleteAllItems: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetUINT32: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, unvalue: u32) -> ::windows::core::HRESULT,
    pub SetUINT64: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, unvalue: u64) -> ::windows::core::HRESULT,
    pub SetDouble: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, fvalue: f64) -> ::windows::core::HRESULT,
    pub SetGUID: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, guidvalue: *const ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub SetString: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, wszvalue: ::windows::core::PCWSTR) -> ::windows::core::HRESULT,
    pub SetBlob: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pbuf: *const u8, cbbufsize: u32) -> ::windows::core::HRESULT,
    pub SetUnknown: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, punknown: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub LockStore: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub UnlockStore: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcitems: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub GetItemByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, unindex: u32, pguidkey: *mut ::windows::core::GUID, pvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    GetItemByIndex: usize,
    pub CopyAllItems: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdest: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFAudioMediaType(::windows::core::IUnknown);
impl IMFAudioMediaType {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItem(&self, guidkey: *const ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.GetItem)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetItemType(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<MF_ATTRIBUTE_TYPE> {
        let mut result__ = ::windows::core::zeroed::<MF_ATTRIBUTE_TYPE>();
        (::windows::core::Interface::vtable(self).base__.base__.GetItemType)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn CompareItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.base__.CompareItem)(::windows::core::Interface::as_raw(self), guidkey, value, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Compare<P0>(&self, ptheirs: P0, matchtype: MF_ATTRIBUTES_MATCH_TYPE) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.base__.Compare)(::windows::core::Interface::as_raw(self), ptheirs.into_param().abi(), matchtype, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT32(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.base__.GetUINT32)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT64(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).base__.base__.GetUINT64)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDouble(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).base__.base__.GetDouble)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetGUID(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).base__.base__.GetGUID)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStringLength(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.base__.GetStringLength)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetString(&self, guidkey: *const ::windows::core::GUID, pwszvalue: &mut [u16], pcchlength: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.GetString)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pwszvalue.as_ptr()), pwszvalue.len() as _, ::core::mem::transmute(pcchlength.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedString(&self, guidkey: *const ::windows::core::GUID, ppwszvalue: *mut ::windows::core::PWSTR, pcchlength: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.GetAllocatedString)(::windows::core::Interface::as_raw(self), guidkey, ppwszvalue, pcchlength).ok()
    }
    pub unsafe fn GetBlobSize(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.base__.GetBlobSize)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &mut [u8], pcbblobsize: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.GetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _, ::core::mem::transmute(pcbblobsize.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedBlob(&self, guidkey: *const ::windows::core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.GetAllocatedBlob)(::windows::core::Interface::as_raw(self), guidkey, ppbuf, pcbsize).ok()
    }
    pub unsafe fn GetUnknown<T>(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.base__.GetUnknown)(::windows::core::Interface::as_raw(self), guidkey, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetItem)(::windows::core::Interface::as_raw(self), guidkey, value).ok()
    }
    pub unsafe fn DeleteItem(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.DeleteItem)(::windows::core::Interface::as_raw(self), guidkey).ok()
    }
    pub unsafe fn DeleteAllItems(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.DeleteAllItems)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetUINT32(&self, guidkey: *const ::windows::core::GUID, unvalue: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetUINT32)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetUINT64(&self, guidkey: *const ::windows::core::GUID, unvalue: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetUINT64)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetDouble(&self, guidkey: *const ::windows::core::GUID, fvalue: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetDouble)(::windows::core::Interface::as_raw(self), guidkey, fvalue).ok()
    }
    pub unsafe fn SetGUID(&self, guidkey: *const ::windows::core::GUID, guidvalue: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetGUID)(::windows::core::Interface::as_raw(self), guidkey, guidvalue).ok()
    }
    pub unsafe fn SetString<P0>(&self, guidkey: *const ::windows::core::GUID, wszvalue: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.SetString)(::windows::core::Interface::as_raw(self), guidkey, wszvalue.into_param().abi()).ok()
    }
    pub unsafe fn SetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _).ok()
    }
    pub unsafe fn SetUnknown<P0>(&self, guidkey: *const ::windows::core::GUID, punknown: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.SetUnknown)(::windows::core::Interface::as_raw(self), guidkey, punknown.into_param().abi()).ok()
    }
    pub unsafe fn LockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.LockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn UnlockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.UnlockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.base__.GetCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItemByIndex(&self, unindex: u32, pguidkey: *mut ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.GetItemByIndex)(::windows::core::Interface::as_raw(self), unindex, pguidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn CopyAllItems<P0>(&self, pdest: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.CopyAllItems)(::windows::core::Interface::as_raw(self), pdest.into_param().abi()).ok()
    }
    pub unsafe fn GetMajorType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).base__.GetMajorType)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsCompressedFormat(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.IsCompressedFormat)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn IsEqual<P0>(&self, pimediatype: P0) -> ::windows::core::Result<u32>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.IsEqual)(::windows::core::Interface::as_raw(self), pimediatype.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetRepresentation(&self, guidrepresentation: ::windows::core::GUID, ppvrepresentation: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetRepresentation)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(guidrepresentation), ppvrepresentation).ok()
    }
    pub unsafe fn FreeRepresentation(&self, guidrepresentation: ::windows::core::GUID, pvrepresentation: *const ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.FreeRepresentation)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(guidrepresentation), pvrepresentation).ok()
    }
    #[doc = "*Required features: `\"Win32_Media_Audio\"`*"]
    #[cfg(feature = "Win32_Media_Audio")]
    pub unsafe fn GetAudioFormat(&self) -> *mut super::Audio::WAVEFORMATEX {
        (::windows::core::Interface::vtable(self).GetAudioFormat)(::windows::core::Interface::as_raw(self))
    }
}
::windows::imp::interface_hierarchy!(IMFAudioMediaType, ::windows::core::IUnknown, IMFAttributes, IMFMediaType);
impl ::core::cmp::PartialEq for IMFAudioMediaType {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFAudioMediaType {}
impl ::core::fmt::Debug for IMFAudioMediaType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFAudioMediaType").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFAudioMediaType {
    type Vtable = IMFAudioMediaType_Vtbl;
}
impl ::core::clone::Clone for IMFAudioMediaType {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFAudioMediaType {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x26a0adc3_ce26_4672_9304_69552edd3faf);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFAudioMediaType_Vtbl {
    pub base__: IMFMediaType_Vtbl,
    #[cfg(feature = "Win32_Media_Audio")]
    pub GetAudioFormat: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> *mut super::Audio::WAVEFORMATEX,
    #[cfg(not(feature = "Win32_Media_Audio"))]
    GetAudioFormat: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFAudioPolicy(::windows::core::IUnknown);
impl IMFAudioPolicy {
    pub unsafe fn SetGroupingParam(&self, rguidclass: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetGroupingParam)(::windows::core::Interface::as_raw(self), rguidclass).ok()
    }
    pub unsafe fn GetGroupingParam(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).GetGroupingParam)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetDisplayName<P0>(&self, pszname: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).SetDisplayName)(::windows::core::Interface::as_raw(self), pszname.into_param().abi()).ok()
    }
    pub unsafe fn GetDisplayName(&self) -> ::windows::core::Result<::windows::core::PWSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::PWSTR>();
        (::windows::core::Interface::vtable(self).GetDisplayName)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetIconPath<P0>(&self, pszpath: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).SetIconPath)(::windows::core::Interface::as_raw(self), pszpath.into_param().abi()).ok()
    }
    pub unsafe fn GetIconPath(&self) -> ::windows::core::Result<::windows::core::PWSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::PWSTR>();
        (::windows::core::Interface::vtable(self).GetIconPath)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFAudioPolicy, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFAudioPolicy {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFAudioPolicy {}
impl ::core::fmt::Debug for IMFAudioPolicy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFAudioPolicy").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFAudioPolicy {
    type Vtable = IMFAudioPolicy_Vtbl;
}
impl ::core::clone::Clone for IMFAudioPolicy {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFAudioPolicy {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa0638c2b_6465_4395_9ae7_a321a9fd2856);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFAudioPolicy_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetGroupingParam: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, rguidclass: *const ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub GetGroupingParam: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pguidclass: *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub SetDisplayName: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pszname: ::windows::core::PCWSTR) -> ::windows::core::HRESULT,
    pub GetDisplayName: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pszname: *mut ::windows::core::PWSTR) -> ::windows::core::HRESULT,
    pub SetIconPath: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pszpath: ::windows::core::PCWSTR) -> ::windows::core::HRESULT,
    pub GetIconPath: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pszpath: *mut ::windows::core::PWSTR) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFAudioStreamVolume(::windows::core::IUnknown);
impl IMFAudioStreamVolume {
    pub unsafe fn GetChannelCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetChannelCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetChannelVolume(&self, dwindex: u32, flevel: f32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetChannelVolume)(::windows::core::Interface::as_raw(self), dwindex, flevel).ok()
    }
    pub unsafe fn GetChannelVolume(&self, dwindex: u32) -> ::windows::core::Result<f32> {
        let mut result__ = ::windows::core::zeroed::<f32>();
        (::windows::core::Interface::vtable(self).GetChannelVolume)(::windows::core::Interface::as_raw(self), dwindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetAllVolumes(&self, pfvolumes: &[f32]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetAllVolumes)(::windows::core::Interface::as_raw(self), pfvolumes.len() as _, ::core::mem::transmute(pfvolumes.as_ptr())).ok()
    }
    pub unsafe fn GetAllVolumes(&self, pfvolumes: &mut [f32]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetAllVolumes)(::windows::core::Interface::as_raw(self), pfvolumes.len() as _, ::core::mem::transmute(pfvolumes.as_ptr())).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFAudioStreamVolume, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFAudioStreamVolume {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFAudioStreamVolume {}
impl ::core::fmt::Debug for IMFAudioStreamVolume {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFAudioStreamVolume").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFAudioStreamVolume {
    type Vtable = IMFAudioStreamVolume_Vtbl;
}
impl ::core::clone::Clone for IMFAudioStreamVolume {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFAudioStreamVolume {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x76b1bbdb_4ec8_4f36_b106_70a9316df593);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFAudioStreamVolume_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetChannelCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwcount: *mut u32) -> ::windows::core::HRESULT,
    pub SetChannelVolume: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwindex: u32, flevel: f32) -> ::windows::core::HRESULT,
    pub GetChannelVolume: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwindex: u32, pflevel: *mut f32) -> ::windows::core::HRESULT,
    pub SetAllVolumes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwcount: u32, pfvolumes: *const f32) -> ::windows::core::HRESULT,
    pub GetAllVolumes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwcount: u32, pfvolumes: *mut f32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFBufferListNotify(::windows::core::IUnknown);
impl IMFBufferListNotify {
    pub unsafe fn OnAddSourceBuffer(&self) {
        (::windows::core::Interface::vtable(self).OnAddSourceBuffer)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn OnRemoveSourceBuffer(&self) {
        (::windows::core::Interface::vtable(self).OnRemoveSourceBuffer)(::windows::core::Interface::as_raw(self))
    }
}
::windows::imp::interface_hierarchy!(IMFBufferListNotify, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFBufferListNotify {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFBufferListNotify {}
impl ::core::fmt::Debug for IMFBufferListNotify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFBufferListNotify").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFBufferListNotify {
    type Vtable = IMFBufferListNotify_Vtbl;
}
impl ::core::clone::Clone for IMFBufferListNotify {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFBufferListNotify {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x24cd47f7_81d8_4785_adb2_af697a963cd2);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFBufferListNotify_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub OnAddSourceBuffer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub OnRemoveSourceBuffer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFByteStream(::windows::core::IUnknown);
impl IMFByteStream {
    pub unsafe fn GetCapabilities(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetCapabilities)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetLength(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).GetLength)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetLength(&self, qwlength: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetLength)(::windows::core::Interface::as_raw(self), qwlength).ok()
    }
    pub unsafe fn GetCurrentPosition(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).GetCurrentPosition)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetCurrentPosition(&self, qwposition: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetCurrentPosition)(::windows::core::Interface::as_raw(self), qwposition).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsEndOfStream(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).IsEndOfStream)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn Read(&self, pb: &mut [u8], pcbread: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Read)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pb.as_ptr()), pb.len() as _, pcbread).ok()
    }
    pub unsafe fn BeginRead<P0, P1>(&self, pb: &mut [u8], pcallback: P0, punkstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginRead)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pb.as_ptr()), pb.len() as _, pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    pub unsafe fn EndRead<P0>(&self, presult: P0) -> ::windows::core::Result<u32>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).EndRead)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn Write(&self, pb: &[u8]) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).Write)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pb.as_ptr()), pb.len() as _, &mut result__).from_abi(result__)
    }
    pub unsafe fn BeginWrite<P0, P1>(&self, pb: &[u8], pcallback: P0, punkstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginWrite)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pb.as_ptr()), pb.len() as _, pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    pub unsafe fn EndWrite<P0>(&self, presult: P0) -> ::windows::core::Result<u32>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).EndWrite)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn Seek(&self, seekorigin: MFBYTESTREAM_SEEK_ORIGIN, llseekoffset: i64, dwseekflags: u32) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).Seek)(::windows::core::Interface::as_raw(self), seekorigin, llseekoffset, dwseekflags, &mut result__).from_abi(result__)
    }
    pub unsafe fn Flush(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Flush)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Close)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFByteStream, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFByteStream {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFByteStream {}
impl ::core::fmt::Debug for IMFByteStream {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFByteStream").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFByteStream {
    type Vtable = IMFByteStream_Vtbl;
}
impl ::core::clone::Clone for IMFByteStream {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFByteStream {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xad4c1b00_4bf7_422f_9175_756693d9130d);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFByteStream_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetCapabilities: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwcapabilities: *mut u32) -> ::windows::core::HRESULT,
    pub GetLength: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pqwlength: *mut u64) -> ::windows::core::HRESULT,
    pub SetLength: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, qwlength: u64) -> ::windows::core::HRESULT,
    pub GetCurrentPosition: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pqwposition: *mut u64) -> ::windows::core::HRESULT,
    pub SetCurrentPosition: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, qwposition: u64) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub IsEndOfStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pfendofstream: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsEndOfStream: usize,
    pub Read: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pb: *mut u8, cb: u32, pcbread: *mut u32) -> ::windows::core::HRESULT,
    pub BeginRead: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pb: *mut u8, cb: u32, pcallback: *mut ::core::ffi::c_void, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub EndRead: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void, pcbread: *mut u32) -> ::windows::core::HRESULT,
    pub Write: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pb: *const u8, cb: u32, pcbwritten: *mut u32) -> ::windows::core::HRESULT,
    pub BeginWrite: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pb: *const u8, cb: u32, pcallback: *mut ::core::ffi::c_void, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub EndWrite: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void, pcbwritten: *mut u32) -> ::windows::core::HRESULT,
    pub Seek: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, seekorigin: MFBYTESTREAM_SEEK_ORIGIN, llseekoffset: i64, dwseekflags: u32, pqwcurrentposition: *mut u64) -> ::windows::core::HRESULT,
    pub Flush: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Close: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFByteStreamBuffering(::windows::core::IUnknown);
impl IMFByteStreamBuffering {
    pub unsafe fn SetBufferingParams(&self, pparams: *const MFBYTESTREAM_BUFFERING_PARAMS) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetBufferingParams)(::windows::core::Interface::as_raw(self), pparams).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn EnableBuffering<P0>(&self, fenable: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).EnableBuffering)(::windows::core::Interface::as_raw(self), fenable.into_param().abi()).ok()
    }
    pub unsafe fn StopBuffering(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).StopBuffering)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFByteStreamBuffering, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFByteStreamBuffering {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFByteStreamBuffering {}
impl ::core::fmt::Debug for IMFByteStreamBuffering {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFByteStreamBuffering").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFByteStreamBuffering {
    type Vtable = IMFByteStreamBuffering_Vtbl;
}
impl ::core::clone::Clone for IMFByteStreamBuffering {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFByteStreamBuffering {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6d66d782_1d4f_4db7_8c63_cb8c77f1ef5e);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFByteStreamBuffering_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetBufferingParams: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pparams: *const MFBYTESTREAM_BUFFERING_PARAMS) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub EnableBuffering: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fenable: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    EnableBuffering: usize,
    pub StopBuffering: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFByteStreamCacheControl(::windows::core::IUnknown);
impl IMFByteStreamCacheControl {
    pub unsafe fn StopBackgroundTransfer(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).StopBackgroundTransfer)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFByteStreamCacheControl, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFByteStreamCacheControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFByteStreamCacheControl {}
impl ::core::fmt::Debug for IMFByteStreamCacheControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFByteStreamCacheControl").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFByteStreamCacheControl {
    type Vtable = IMFByteStreamCacheControl_Vtbl;
}
impl ::core::clone::Clone for IMFByteStreamCacheControl {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFByteStreamCacheControl {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf5042ea4_7a96_4a75_aa7b_2be1ef7f88d5);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFByteStreamCacheControl_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub StopBackgroundTransfer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFByteStreamCacheControl2(::windows::core::IUnknown);
impl IMFByteStreamCacheControl2 {
    pub unsafe fn StopBackgroundTransfer(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.StopBackgroundTransfer)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetByteRanges(&self, pcranges: *mut u32, ppranges: *mut *mut MF_BYTE_STREAM_CACHE_RANGE) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetByteRanges)(::windows::core::Interface::as_raw(self), pcranges, ppranges).ok()
    }
    pub unsafe fn SetCacheLimit(&self, qwbytes: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetCacheLimit)(::windows::core::Interface::as_raw(self), qwbytes).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsBackgroundTransferActive(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).IsBackgroundTransferActive)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFByteStreamCacheControl2, ::windows::core::IUnknown, IMFByteStreamCacheControl);
impl ::core::cmp::PartialEq for IMFByteStreamCacheControl2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFByteStreamCacheControl2 {}
impl ::core::fmt::Debug for IMFByteStreamCacheControl2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFByteStreamCacheControl2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFByteStreamCacheControl2 {
    type Vtable = IMFByteStreamCacheControl2_Vtbl;
}
impl ::core::clone::Clone for IMFByteStreamCacheControl2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFByteStreamCacheControl2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x71ce469c_f34b_49ea_a56b_2d2a10e51149);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFByteStreamCacheControl2_Vtbl {
    pub base__: IMFByteStreamCacheControl_Vtbl,
    pub GetByteRanges: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcranges: *mut u32, ppranges: *mut *mut MF_BYTE_STREAM_CACHE_RANGE) -> ::windows::core::HRESULT,
    pub SetCacheLimit: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, qwbytes: u64) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub IsBackgroundTransferActive: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pfactive: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsBackgroundTransferActive: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFByteStreamHandler(::windows::core::IUnknown);
impl IMFByteStreamHandler {
    #[doc = "*Required features: `\"Win32_UI_Shell_PropertiesSystem\"`*"]
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub unsafe fn BeginCreateObject<P0, P1, P2, P3, P4>(&self, pbytestream: P0, pwszurl: P1, dwflags: u32, pprops: P2, ppiunknowncancelcookie: ::core::option::Option<*mut ::core::option::Option<::windows::core::IUnknown>>, pcallback: P3, punkstate: P4) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFByteStream>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P2: ::windows::core::IntoParam<super::super::UI::Shell::PropertiesSystem::IPropertyStore>,
        P3: ::windows::core::IntoParam<IMFAsyncCallback>,
        P4: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginCreateObject)(::windows::core::Interface::as_raw(self), pbytestream.into_param().abi(), pwszurl.into_param().abi(), dwflags, pprops.into_param().abi(), ::core::mem::transmute(ppiunknowncancelcookie.unwrap_or(::std::ptr::null_mut())), pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    pub unsafe fn EndCreateObject<P0>(&self, presult: P0, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        (::windows::core::Interface::vtable(self).EndCreateObject)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), pobjecttype, ::core::mem::transmute(ppobject)).ok()
    }
    pub unsafe fn CancelObjectCreation<P0>(&self, piunknowncancelcookie: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).CancelObjectCreation)(::windows::core::Interface::as_raw(self), piunknowncancelcookie.into_param().abi()).ok()
    }
    pub unsafe fn GetMaxNumberOfBytesRequiredForResolution(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).GetMaxNumberOfBytesRequiredForResolution)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFByteStreamHandler, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFByteStreamHandler {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFByteStreamHandler {}
impl ::core::fmt::Debug for IMFByteStreamHandler {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFByteStreamHandler").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFByteStreamHandler {
    type Vtable = IMFByteStreamHandler_Vtbl;
}
impl ::core::clone::Clone for IMFByteStreamHandler {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFByteStreamHandler {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbb420aa4_765b_4a1f_91fe_d6a8a143924c);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFByteStreamHandler_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub BeginCreateObject: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbytestream: *mut ::core::ffi::c_void, pwszurl: ::windows::core::PCWSTR, dwflags: u32, pprops: *mut ::core::ffi::c_void, ppiunknowncancelcookie: *mut *mut ::core::ffi::c_void, pcallback: *mut ::core::ffi::c_void, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_UI_Shell_PropertiesSystem"))]
    BeginCreateObject: usize,
    pub EndCreateObject: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub CancelObjectCreation: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, piunknowncancelcookie: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetMaxNumberOfBytesRequiredForResolution: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pqwbytes: *mut u64) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFByteStreamProxyClassFactory(::windows::core::IUnknown);
impl IMFByteStreamProxyClassFactory {
    pub unsafe fn CreateByteStreamProxy<P0, P1, T>(&self, pbytestream: P0, pattributes: P1) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<IMFByteStream>,
        P1: ::windows::core::IntoParam<IMFAttributes>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateByteStreamProxy)(::windows::core::Interface::as_raw(self), pbytestream.into_param().abi(), pattributes.into_param().abi(), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFByteStreamProxyClassFactory, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFByteStreamProxyClassFactory {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFByteStreamProxyClassFactory {}
impl ::core::fmt::Debug for IMFByteStreamProxyClassFactory {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFByteStreamProxyClassFactory").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFByteStreamProxyClassFactory {
    type Vtable = IMFByteStreamProxyClassFactory_Vtbl;
}
impl ::core::clone::Clone for IMFByteStreamProxyClassFactory {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFByteStreamProxyClassFactory {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa6b43f84_5c0a_42e8_a44d_b1857a76992f);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFByteStreamProxyClassFactory_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub CreateByteStreamProxy: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbytestream: *mut ::core::ffi::c_void, pattributes: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFByteStreamTimeSeek(::windows::core::IUnknown);
impl IMFByteStreamTimeSeek {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsTimeSeekSupported(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).IsTimeSeekSupported)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn TimeSeek(&self, qwtimeposition: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).TimeSeek)(::windows::core::Interface::as_raw(self), qwtimeposition).ok()
    }
    pub unsafe fn GetTimeSeekResult(&self, pqwstarttime: *mut u64, pqwstoptime: *mut u64, pqwduration: *mut u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetTimeSeekResult)(::windows::core::Interface::as_raw(self), pqwstarttime, pqwstoptime, pqwduration).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFByteStreamTimeSeek, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFByteStreamTimeSeek {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFByteStreamTimeSeek {}
impl ::core::fmt::Debug for IMFByteStreamTimeSeek {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFByteStreamTimeSeek").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFByteStreamTimeSeek {
    type Vtable = IMFByteStreamTimeSeek_Vtbl;
}
impl ::core::clone::Clone for IMFByteStreamTimeSeek {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFByteStreamTimeSeek {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x64976bfa_fb61_4041_9069_8c9a5f659beb);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFByteStreamTimeSeek_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub IsTimeSeekSupported: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pftimeseekissupported: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsTimeSeekSupported: usize,
    pub TimeSeek: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, qwtimeposition: u64) -> ::windows::core::HRESULT,
    pub GetTimeSeekResult: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pqwstarttime: *mut u64, pqwstoptime: *mut u64, pqwduration: *mut u64) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFCameraConfigurationManager(::windows::core::IUnknown);
impl IMFCameraConfigurationManager {
    pub unsafe fn LoadDefaults<P0>(&self, cameraattributes: P0) -> ::windows::core::Result<IMFCameraControlDefaultsCollection>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFCameraControlDefaultsCollection>();
        (::windows::core::Interface::vtable(self).LoadDefaults)(::windows::core::Interface::as_raw(self), cameraattributes.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn SaveDefaults<P0>(&self, configurations: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFCameraControlDefaultsCollection>,
    {
        (::windows::core::Interface::vtable(self).SaveDefaults)(::windows::core::Interface::as_raw(self), configurations.into_param().abi()).ok()
    }
    pub unsafe fn Shutdown(&self) {
        (::windows::core::Interface::vtable(self).Shutdown)(::windows::core::Interface::as_raw(self))
    }
}
::windows::imp::interface_hierarchy!(IMFCameraConfigurationManager, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFCameraConfigurationManager {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFCameraConfigurationManager {}
impl ::core::fmt::Debug for IMFCameraConfigurationManager {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFCameraConfigurationManager").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFCameraConfigurationManager {
    type Vtable = IMFCameraConfigurationManager_Vtbl;
}
impl ::core::clone::Clone for IMFCameraConfigurationManager {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFCameraConfigurationManager {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa624f617_4704_4206_8a6d_ebda4a093985);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFCameraConfigurationManager_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub LoadDefaults: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cameraattributes: *mut ::core::ffi::c_void, configurations: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SaveDefaults: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, configurations: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Shutdown: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFCameraControlDefaults(::windows::core::IUnknown);
impl IMFCameraControlDefaults {
    pub unsafe fn GetType(&self) -> MF_CAMERA_CONTROL_CONFIGURATION_TYPE {
        (::windows::core::Interface::vtable(self).GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetRangeInfo(&self) -> ::windows::core::Result<MF_CAMERA_CONTROL_RANGE_INFO> {
        let mut result__ = ::windows::core::zeroed::<MF_CAMERA_CONTROL_RANGE_INFO>();
        (::windows::core::Interface::vtable(self).GetRangeInfo)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn LockControlData(&self, control: *mut *mut ::core::ffi::c_void, controlsize: *mut u32, data: ::core::option::Option<*mut *mut ::core::ffi::c_void>, datasize: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).LockControlData)(::windows::core::Interface::as_raw(self), control, controlsize, ::core::mem::transmute(data.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(datasize.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn UnlockControlData(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).UnlockControlData)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFCameraControlDefaults, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFCameraControlDefaults {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFCameraControlDefaults {}
impl ::core::fmt::Debug for IMFCameraControlDefaults {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFCameraControlDefaults").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFCameraControlDefaults {
    type Vtable = IMFCameraControlDefaults_Vtbl;
}
impl ::core::clone::Clone for IMFCameraControlDefaults {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFCameraControlDefaults {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x75510662_b034_48f4_88a7_8de61daa4af9);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFCameraControlDefaults_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> MF_CAMERA_CONTROL_CONFIGURATION_TYPE,
    pub GetRangeInfo: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, rangeinfo: *mut MF_CAMERA_CONTROL_RANGE_INFO) -> ::windows::core::HRESULT,
    pub LockControlData: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, control: *mut *mut ::core::ffi::c_void, controlsize: *mut u32, data: *mut *mut ::core::ffi::c_void, datasize: *mut u32) -> ::windows::core::HRESULT,
    pub UnlockControlData: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFCameraControlDefaultsCollection(::windows::core::IUnknown);
impl IMFCameraControlDefaultsCollection {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItem(&self, guidkey: *const ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItem)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetItemType(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<MF_ATTRIBUTE_TYPE> {
        let mut result__ = ::windows::core::zeroed::<MF_ATTRIBUTE_TYPE>();
        (::windows::core::Interface::vtable(self).base__.GetItemType)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn CompareItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.CompareItem)(::windows::core::Interface::as_raw(self), guidkey, value, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Compare<P0>(&self, ptheirs: P0, matchtype: MF_ATTRIBUTES_MATCH_TYPE) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.Compare)(::windows::core::Interface::as_raw(self), ptheirs.into_param().abi(), matchtype, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT32(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetUINT32)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT64(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).base__.GetUINT64)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDouble(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).base__.GetDouble)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetGUID(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).base__.GetGUID)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStringLength(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetStringLength)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetString(&self, guidkey: *const ::windows::core::GUID, pwszvalue: &mut [u16], pcchlength: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetString)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pwszvalue.as_ptr()), pwszvalue.len() as _, ::core::mem::transmute(pcchlength.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedString(&self, guidkey: *const ::windows::core::GUID, ppwszvalue: *mut ::windows::core::PWSTR, pcchlength: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedString)(::windows::core::Interface::as_raw(self), guidkey, ppwszvalue, pcchlength).ok()
    }
    pub unsafe fn GetBlobSize(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetBlobSize)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &mut [u8], pcbblobsize: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _, ::core::mem::transmute(pcbblobsize.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedBlob(&self, guidkey: *const ::windows::core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedBlob)(::windows::core::Interface::as_raw(self), guidkey, ppbuf, pcbsize).ok()
    }
    pub unsafe fn GetUnknown<T>(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.GetUnknown)(::windows::core::Interface::as_raw(self), guidkey, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetItem)(::windows::core::Interface::as_raw(self), guidkey, value).ok()
    }
    pub unsafe fn DeleteItem(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteItem)(::windows::core::Interface::as_raw(self), guidkey).ok()
    }
    pub unsafe fn DeleteAllItems(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteAllItems)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetUINT32(&self, guidkey: *const ::windows::core::GUID, unvalue: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT32)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetUINT64(&self, guidkey: *const ::windows::core::GUID, unvalue: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT64)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetDouble(&self, guidkey: *const ::windows::core::GUID, fvalue: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetDouble)(::windows::core::Interface::as_raw(self), guidkey, fvalue).ok()
    }
    pub unsafe fn SetGUID(&self, guidkey: *const ::windows::core::GUID, guidvalue: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetGUID)(::windows::core::Interface::as_raw(self), guidkey, guidvalue).ok()
    }
    pub unsafe fn SetString<P0>(&self, guidkey: *const ::windows::core::GUID, wszvalue: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.SetString)(::windows::core::Interface::as_raw(self), guidkey, wszvalue.into_param().abi()).ok()
    }
    pub unsafe fn SetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _).ok()
    }
    pub unsafe fn SetUnknown<P0>(&self, guidkey: *const ::windows::core::GUID, punknown: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.SetUnknown)(::windows::core::Interface::as_raw(self), guidkey, punknown.into_param().abi()).ok()
    }
    pub unsafe fn LockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.LockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn UnlockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.UnlockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItemByIndex(&self, unindex: u32, pguidkey: *mut ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItemByIndex)(::windows::core::Interface::as_raw(self), unindex, pguidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn CopyAllItems<P0>(&self, pdest: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).base__.CopyAllItems)(::windows::core::Interface::as_raw(self), pdest.into_param().abi()).ok()
    }
    pub unsafe fn GetControlCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetControlCount)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetControl(&self, index: u32) -> ::windows::core::Result<IMFCameraControlDefaults> {
        let mut result__ = ::windows::core::zeroed::<IMFCameraControlDefaults>();
        (::windows::core::Interface::vtable(self).GetControl)(::windows::core::Interface::as_raw(self), index, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetOrAddExtendedControl(&self, configtype: MF_CAMERA_CONTROL_CONFIGURATION_TYPE, constrolid: u32, streamid: u32, datasize: u32) -> ::windows::core::Result<IMFCameraControlDefaults> {
        let mut result__ = ::windows::core::zeroed::<IMFCameraControlDefaults>();
        (::windows::core::Interface::vtable(self).GetOrAddExtendedControl)(::windows::core::Interface::as_raw(self), configtype, constrolid, streamid, datasize, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetOrAddControl(&self, configtype: MF_CAMERA_CONTROL_CONFIGURATION_TYPE, controlset: *const ::windows::core::GUID, constrolid: u32, controlsize: u32, datasize: u32) -> ::windows::core::Result<IMFCameraControlDefaults> {
        let mut result__ = ::windows::core::zeroed::<IMFCameraControlDefaults>();
        (::windows::core::Interface::vtable(self).GetOrAddControl)(::windows::core::Interface::as_raw(self), configtype, controlset, constrolid, controlsize, datasize, &mut result__).from_abi(result__)
    }
    pub unsafe fn RemoveControl(&self, controlset: *const ::windows::core::GUID, constrolid: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveControl)(::windows::core::Interface::as_raw(self), controlset, constrolid).ok()
    }
    pub unsafe fn RemoveAllControls(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveAllControls)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFCameraControlDefaultsCollection, ::windows::core::IUnknown, IMFAttributes);
impl ::core::cmp::PartialEq for IMFCameraControlDefaultsCollection {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFCameraControlDefaultsCollection {}
impl ::core::fmt::Debug for IMFCameraControlDefaultsCollection {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFCameraControlDefaultsCollection").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFCameraControlDefaultsCollection {
    type Vtable = IMFCameraControlDefaultsCollection_Vtbl;
}
impl ::core::clone::Clone for IMFCameraControlDefaultsCollection {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFCameraControlDefaultsCollection {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x92d43d0f_54a8_4bae_96da_356d259a5c26);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFCameraControlDefaultsCollection_Vtbl {
    pub base__: IMFAttributes_Vtbl,
    pub GetControlCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetControl: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, configuration: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetOrAddExtendedControl: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, configtype: MF_CAMERA_CONTROL_CONFIGURATION_TYPE, constrolid: u32, streamid: u32, datasize: u32, defaults: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetOrAddControl: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, configtype: MF_CAMERA_CONTROL_CONFIGURATION_TYPE, controlset: *const ::windows::core::GUID, constrolid: u32, controlsize: u32, datasize: u32, defaults: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RemoveControl: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, controlset: *const ::windows::core::GUID, constrolid: u32) -> ::windows::core::HRESULT,
    pub RemoveAllControls: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFCameraControlMonitor(::windows::core::IUnknown);
impl IMFCameraControlMonitor {
    pub unsafe fn Start(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Start)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Stop(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Stop)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn AddControlSubscription(&self, controlset: ::windows::core::GUID, id: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).AddControlSubscription)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(controlset), id).ok()
    }
    pub unsafe fn RemoveControlSubscription(&self, controlset: ::windows::core::GUID, id: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveControlSubscription)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(controlset), id).ok()
    }
    pub unsafe fn Shutdown(&self) {
        (::windows::core::Interface::vtable(self).Shutdown)(::windows::core::Interface::as_raw(self))
    }
}
::windows::imp::interface_hierarchy!(IMFCameraControlMonitor, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFCameraControlMonitor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFCameraControlMonitor {}
impl ::core::fmt::Debug for IMFCameraControlMonitor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFCameraControlMonitor").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFCameraControlMonitor {
    type Vtable = IMFCameraControlMonitor_Vtbl;
}
impl ::core::clone::Clone for IMFCameraControlMonitor {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFCameraControlMonitor {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4d46f2c9_28ba_4970_8c7b_1f0c9d80af69);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFCameraControlMonitor_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub Start: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Stop: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub AddControlSubscription: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, controlset: ::windows::core::GUID, id: u32) -> ::windows::core::HRESULT,
    pub RemoveControlSubscription: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, controlset: ::windows::core::GUID, id: u32) -> ::windows::core::HRESULT,
    pub Shutdown: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFCameraControlNotify(::windows::core::IUnknown);
impl IMFCameraControlNotify {
    pub unsafe fn OnChange(&self, controlset: *const ::windows::core::GUID, id: u32) {
        (::windows::core::Interface::vtable(self).OnChange)(::windows::core::Interface::as_raw(self), controlset, id)
    }
    pub unsafe fn OnError(&self, hrstatus: ::windows::core::HRESULT) {
        (::windows::core::Interface::vtable(self).OnError)(::windows::core::Interface::as_raw(self), hrstatus)
    }
}
::windows::imp::interface_hierarchy!(IMFCameraControlNotify, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFCameraControlNotify {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFCameraControlNotify {}
impl ::core::fmt::Debug for IMFCameraControlNotify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFCameraControlNotify").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFCameraControlNotify {
    type Vtable = IMFCameraControlNotify_Vtbl;
}
impl ::core::clone::Clone for IMFCameraControlNotify {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFCameraControlNotify {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe8f2540d_558a_4449_8b64_4863467a9fe8);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFCameraControlNotify_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub OnChange: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, controlset: *const ::windows::core::GUID, id: u32),
    pub OnError: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hrstatus: ::windows::core::HRESULT),
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFCameraOcclusionStateMonitor(::windows::core::IUnknown);
impl IMFCameraOcclusionStateMonitor {
    pub unsafe fn Start(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Start)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Stop(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Stop)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetSupportedStates(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetSupportedStates)(::windows::core::Interface::as_raw(self))
    }
}
::windows::imp::interface_hierarchy!(IMFCameraOcclusionStateMonitor, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFCameraOcclusionStateMonitor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFCameraOcclusionStateMonitor {}
impl ::core::fmt::Debug for IMFCameraOcclusionStateMonitor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFCameraOcclusionStateMonitor").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFCameraOcclusionStateMonitor {
    type Vtable = IMFCameraOcclusionStateMonitor_Vtbl;
}
impl ::core::clone::Clone for IMFCameraOcclusionStateMonitor {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFCameraOcclusionStateMonitor {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xcc692f46_c697_47e2_a72d_7b064617749b);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFCameraOcclusionStateMonitor_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub Start: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Stop: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetSupportedStates: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFCameraOcclusionStateReport(::windows::core::IUnknown);
impl IMFCameraOcclusionStateReport {
    pub unsafe fn GetOcclusionState(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetOcclusionState)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFCameraOcclusionStateReport, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFCameraOcclusionStateReport {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFCameraOcclusionStateReport {}
impl ::core::fmt::Debug for IMFCameraOcclusionStateReport {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFCameraOcclusionStateReport").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFCameraOcclusionStateReport {
    type Vtable = IMFCameraOcclusionStateReport_Vtbl;
}
impl ::core::clone::Clone for IMFCameraOcclusionStateReport {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFCameraOcclusionStateReport {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1640b2cf_74da_4462_a43b_b76d3bdc1434);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFCameraOcclusionStateReport_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetOcclusionState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, occlusionstate: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFCameraOcclusionStateReportCallback(::windows::core::IUnknown);
impl IMFCameraOcclusionStateReportCallback {
    pub unsafe fn OnOcclusionStateReport<P0>(&self, occlusionstatereport: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFCameraOcclusionStateReport>,
    {
        (::windows::core::Interface::vtable(self).OnOcclusionStateReport)(::windows::core::Interface::as_raw(self), occlusionstatereport.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFCameraOcclusionStateReportCallback, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFCameraOcclusionStateReportCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFCameraOcclusionStateReportCallback {}
impl ::core::fmt::Debug for IMFCameraOcclusionStateReportCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFCameraOcclusionStateReportCallback").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFCameraOcclusionStateReportCallback {
    type Vtable = IMFCameraOcclusionStateReportCallback_Vtbl;
}
impl ::core::clone::Clone for IMFCameraOcclusionStateReportCallback {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFCameraOcclusionStateReportCallback {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6e5841c7_3889_4019_9035_783fb19b5948);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFCameraOcclusionStateReportCallback_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub OnOcclusionStateReport: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, occlusionstatereport: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFCameraSyncObject(::windows::core::IUnknown);
impl IMFCameraSyncObject {
    pub unsafe fn WaitOnSignal(&self, timeoutinms: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).WaitOnSignal)(::windows::core::Interface::as_raw(self), timeoutinms).ok()
    }
    pub unsafe fn Shutdown(&self) {
        (::windows::core::Interface::vtable(self).Shutdown)(::windows::core::Interface::as_raw(self))
    }
}
::windows::imp::interface_hierarchy!(IMFCameraSyncObject, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFCameraSyncObject {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFCameraSyncObject {}
impl ::core::fmt::Debug for IMFCameraSyncObject {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFCameraSyncObject").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFCameraSyncObject {
    type Vtable = IMFCameraSyncObject_Vtbl;
}
impl ::core::clone::Clone for IMFCameraSyncObject {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFCameraSyncObject {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6338b23a_3042_49d2_a3ea_ec0fed815407);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFCameraSyncObject_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub WaitOnSignal: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, timeoutinms: u32) -> ::windows::core::HRESULT,
    pub Shutdown: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFCaptureEngine(::windows::core::IUnknown);
impl IMFCaptureEngine {
    pub unsafe fn Initialize<P0, P1, P2, P3>(&self, peventcallback: P0, pattributes: P1, paudiosource: P2, pvideosource: P3) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFCaptureEngineOnEventCallback>,
        P1: ::windows::core::IntoParam<IMFAttributes>,
        P2: ::windows::core::IntoParam<::windows::core::IUnknown>,
        P3: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).Initialize)(::windows::core::Interface::as_raw(self), peventcallback.into_param().abi(), pattributes.into_param().abi(), paudiosource.into_param().abi(), pvideosource.into_param().abi()).ok()
    }
    pub unsafe fn StartPreview(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).StartPreview)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn StopPreview(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).StopPreview)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn StartRecord(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).StartRecord)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn StopRecord<P0, P1>(&self, bfinalize: P0, bflushunprocessedsamples: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
        P1: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).StopRecord)(::windows::core::Interface::as_raw(self), bfinalize.into_param().abi(), bflushunprocessedsamples.into_param().abi()).ok()
    }
    pub unsafe fn TakePhoto(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).TakePhoto)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetSink(&self, mfcaptureenginesinktype: MF_CAPTURE_ENGINE_SINK_TYPE) -> ::windows::core::Result<IMFCaptureSink> {
        let mut result__ = ::windows::core::zeroed::<IMFCaptureSink>();
        (::windows::core::Interface::vtable(self).GetSink)(::windows::core::Interface::as_raw(self), mfcaptureenginesinktype, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetSource(&self) -> ::windows::core::Result<IMFCaptureSource> {
        let mut result__ = ::windows::core::zeroed::<IMFCaptureSource>();
        (::windows::core::Interface::vtable(self).GetSource)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFCaptureEngine, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFCaptureEngine {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFCaptureEngine {}
impl ::core::fmt::Debug for IMFCaptureEngine {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFCaptureEngine").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFCaptureEngine {
    type Vtable = IMFCaptureEngine_Vtbl;
}
impl ::core::clone::Clone for IMFCaptureEngine {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFCaptureEngine {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa6bba433_176b_48b2_b375_53aa03473207);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFCaptureEngine_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub Initialize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, peventcallback: *mut ::core::ffi::c_void, pattributes: *mut ::core::ffi::c_void, paudiosource: *mut ::core::ffi::c_void, pvideosource: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub StartPreview: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub StopPreview: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub StartRecord: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub StopRecord: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, bfinalize: super::super::Foundation::BOOL, bflushunprocessedsamples: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    StopRecord: usize,
    pub TakePhoto: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetSink: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, mfcaptureenginesinktype: MF_CAPTURE_ENGINE_SINK_TYPE, ppsink: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetSource: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppsource: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFCaptureEngineClassFactory(::windows::core::IUnknown);
impl IMFCaptureEngineClassFactory {
    pub unsafe fn CreateInstance<T>(&self, clsid: *const ::windows::core::GUID) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateInstance)(::windows::core::Interface::as_raw(self), clsid, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFCaptureEngineClassFactory, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFCaptureEngineClassFactory {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFCaptureEngineClassFactory {}
impl ::core::fmt::Debug for IMFCaptureEngineClassFactory {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFCaptureEngineClassFactory").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFCaptureEngineClassFactory {
    type Vtable = IMFCaptureEngineClassFactory_Vtbl;
}
impl ::core::clone::Clone for IMFCaptureEngineClassFactory {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFCaptureEngineClassFactory {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8f02d140_56fc_4302_a705_3a97c78be779);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFCaptureEngineClassFactory_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub CreateInstance: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, clsid: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFCaptureEngineOnEventCallback(::windows::core::IUnknown);
impl IMFCaptureEngineOnEventCallback {
    pub unsafe fn OnEvent<P0>(&self, pevent: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaEvent>,
    {
        (::windows::core::Interface::vtable(self).OnEvent)(::windows::core::Interface::as_raw(self), pevent.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFCaptureEngineOnEventCallback, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFCaptureEngineOnEventCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFCaptureEngineOnEventCallback {}
impl ::core::fmt::Debug for IMFCaptureEngineOnEventCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFCaptureEngineOnEventCallback").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFCaptureEngineOnEventCallback {
    type Vtable = IMFCaptureEngineOnEventCallback_Vtbl;
}
impl ::core::clone::Clone for IMFCaptureEngineOnEventCallback {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFCaptureEngineOnEventCallback {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xaeda51c0_9025_4983_9012_de597b88b089);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFCaptureEngineOnEventCallback_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub OnEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pevent: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFCaptureEngineOnSampleCallback(::windows::core::IUnknown);
impl IMFCaptureEngineOnSampleCallback {
    pub unsafe fn OnSample<P0>(&self, psample: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFSample>,
    {
        (::windows::core::Interface::vtable(self).OnSample)(::windows::core::Interface::as_raw(self), psample.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFCaptureEngineOnSampleCallback, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFCaptureEngineOnSampleCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFCaptureEngineOnSampleCallback {}
impl ::core::fmt::Debug for IMFCaptureEngineOnSampleCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFCaptureEngineOnSampleCallback").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFCaptureEngineOnSampleCallback {
    type Vtable = IMFCaptureEngineOnSampleCallback_Vtbl;
}
impl ::core::clone::Clone for IMFCaptureEngineOnSampleCallback {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFCaptureEngineOnSampleCallback {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x52150b82_ab39_4467_980f_e48bf0822ecd);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFCaptureEngineOnSampleCallback_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub OnSample: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, psample: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFCaptureEngineOnSampleCallback2(::windows::core::IUnknown);
impl IMFCaptureEngineOnSampleCallback2 {
    pub unsafe fn OnSample<P0>(&self, psample: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFSample>,
    {
        (::windows::core::Interface::vtable(self).base__.OnSample)(::windows::core::Interface::as_raw(self), psample.into_param().abi()).ok()
    }
    pub unsafe fn OnSynchronizedEvent<P0>(&self, pevent: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaEvent>,
    {
        (::windows::core::Interface::vtable(self).OnSynchronizedEvent)(::windows::core::Interface::as_raw(self), pevent.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFCaptureEngineOnSampleCallback2, ::windows::core::IUnknown, IMFCaptureEngineOnSampleCallback);
impl ::core::cmp::PartialEq for IMFCaptureEngineOnSampleCallback2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFCaptureEngineOnSampleCallback2 {}
impl ::core::fmt::Debug for IMFCaptureEngineOnSampleCallback2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFCaptureEngineOnSampleCallback2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFCaptureEngineOnSampleCallback2 {
    type Vtable = IMFCaptureEngineOnSampleCallback2_Vtbl;
}
impl ::core::clone::Clone for IMFCaptureEngineOnSampleCallback2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFCaptureEngineOnSampleCallback2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe37ceed7_340f_4514_9f4d_9c2ae026100b);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFCaptureEngineOnSampleCallback2_Vtbl {
    pub base__: IMFCaptureEngineOnSampleCallback_Vtbl,
    pub OnSynchronizedEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pevent: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFCapturePhotoConfirmation(::windows::core::IUnknown);
impl IMFCapturePhotoConfirmation {
    pub unsafe fn SetPhotoConfirmationCallback<P0>(&self, pnotificationcallback: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
    {
        (::windows::core::Interface::vtable(self).SetPhotoConfirmationCallback)(::windows::core::Interface::as_raw(self), pnotificationcallback.into_param().abi()).ok()
    }
    pub unsafe fn SetPixelFormat(&self, subtype: ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetPixelFormat)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(subtype)).ok()
    }
    pub unsafe fn GetPixelFormat(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).GetPixelFormat)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFCapturePhotoConfirmation, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFCapturePhotoConfirmation {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFCapturePhotoConfirmation {}
impl ::core::fmt::Debug for IMFCapturePhotoConfirmation {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFCapturePhotoConfirmation").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFCapturePhotoConfirmation {
    type Vtable = IMFCapturePhotoConfirmation_Vtbl;
}
impl ::core::clone::Clone for IMFCapturePhotoConfirmation {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFCapturePhotoConfirmation {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x19f68549_ca8a_4706_a4ef_481dbc95e12c);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFCapturePhotoConfirmation_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetPhotoConfirmationCallback: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pnotificationcallback: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetPixelFormat: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, subtype: ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub GetPixelFormat: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, subtype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFCapturePhotoSink(::windows::core::IUnknown);
impl IMFCapturePhotoSink {
    pub unsafe fn GetOutputMediaType(&self, dwsinkstreamindex: u32, ppmediatype: ::core::option::Option<*mut ::core::option::Option<IMFMediaType>>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetOutputMediaType)(::windows::core::Interface::as_raw(self), dwsinkstreamindex, ::core::mem::transmute(ppmediatype.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetService(&self, dwsinkstreamindex: u32, rguidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppunknown: ::core::option::Option<*mut ::core::option::Option<::windows::core::IUnknown>>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetService)(::windows::core::Interface::as_raw(self), dwsinkstreamindex, rguidservice, riid, ::core::mem::transmute(ppunknown.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn AddStream<P0, P1>(&self, dwsourcestreamindex: u32, pmediatype: P0, pattributes: P1, pdwsinkstreamindex: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
        P1: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).base__.AddStream)(::windows::core::Interface::as_raw(self), dwsourcestreamindex, pmediatype.into_param().abi(), pattributes.into_param().abi(), ::core::mem::transmute(pdwsinkstreamindex.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn Prepare(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Prepare)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn RemoveAllStreams(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.RemoveAllStreams)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetOutputFileName<P0>(&self, filename: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).SetOutputFileName)(::windows::core::Interface::as_raw(self), filename.into_param().abi()).ok()
    }
    pub unsafe fn SetSampleCallback<P0>(&self, pcallback: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFCaptureEngineOnSampleCallback>,
    {
        (::windows::core::Interface::vtable(self).SetSampleCallback)(::windows::core::Interface::as_raw(self), pcallback.into_param().abi()).ok()
    }
    pub unsafe fn SetOutputByteStream<P0>(&self, pbytestream: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFByteStream>,
    {
        (::windows::core::Interface::vtable(self).SetOutputByteStream)(::windows::core::Interface::as_raw(self), pbytestream.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFCapturePhotoSink, ::windows::core::IUnknown, IMFCaptureSink);
impl ::core::cmp::PartialEq for IMFCapturePhotoSink {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFCapturePhotoSink {}
impl ::core::fmt::Debug for IMFCapturePhotoSink {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFCapturePhotoSink").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFCapturePhotoSink {
    type Vtable = IMFCapturePhotoSink_Vtbl;
}
impl ::core::clone::Clone for IMFCapturePhotoSink {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFCapturePhotoSink {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd2d43cc8_48bb_4aa7_95db_10c06977e777);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFCapturePhotoSink_Vtbl {
    pub base__: IMFCaptureSink_Vtbl,
    pub SetOutputFileName: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, filename: ::windows::core::PCWSTR) -> ::windows::core::HRESULT,
    pub SetSampleCallback: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcallback: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetOutputByteStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbytestream: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFCapturePreviewSink(::windows::core::IUnknown);
impl IMFCapturePreviewSink {
    pub unsafe fn GetOutputMediaType(&self, dwsinkstreamindex: u32, ppmediatype: ::core::option::Option<*mut ::core::option::Option<IMFMediaType>>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetOutputMediaType)(::windows::core::Interface::as_raw(self), dwsinkstreamindex, ::core::mem::transmute(ppmediatype.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetService(&self, dwsinkstreamindex: u32, rguidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppunknown: ::core::option::Option<*mut ::core::option::Option<::windows::core::IUnknown>>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetService)(::windows::core::Interface::as_raw(self), dwsinkstreamindex, rguidservice, riid, ::core::mem::transmute(ppunknown.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn AddStream<P0, P1>(&self, dwsourcestreamindex: u32, pmediatype: P0, pattributes: P1, pdwsinkstreamindex: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
        P1: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).base__.AddStream)(::windows::core::Interface::as_raw(self), dwsourcestreamindex, pmediatype.into_param().abi(), pattributes.into_param().abi(), ::core::mem::transmute(pdwsinkstreamindex.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn Prepare(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Prepare)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn RemoveAllStreams(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.RemoveAllStreams)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetRenderHandle<P0>(&self, handle: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self).SetRenderHandle)(::windows::core::Interface::as_raw(self), handle.into_param().abi()).ok()
    }
    pub unsafe fn SetRenderSurface<P0>(&self, psurface: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).SetRenderSurface)(::windows::core::Interface::as_raw(self), psurface.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn UpdateVideo(&self, psrc: ::core::option::Option<*const MFVideoNormalizedRect>, pdst: ::core::option::Option<*const super::super::Foundation::RECT>, pborderclr: ::core::option::Option<*const super::super::Foundation::COLORREF>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).UpdateVideo)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(psrc.unwrap_or(::std::ptr::null())), ::core::mem::transmute(pdst.unwrap_or(::std::ptr::null())), ::core::mem::transmute(pborderclr.unwrap_or(::std::ptr::null()))).ok()
    }
    pub unsafe fn SetSampleCallback<P0>(&self, dwstreamsinkindex: u32, pcallback: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFCaptureEngineOnSampleCallback>,
    {
        (::windows::core::Interface::vtable(self).SetSampleCallback)(::windows::core::Interface::as_raw(self), dwstreamsinkindex, pcallback.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetMirrorState(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).GetMirrorState)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetMirrorState<P0>(&self, fmirrorstate: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetMirrorState)(::windows::core::Interface::as_raw(self), fmirrorstate.into_param().abi()).ok()
    }
    pub unsafe fn GetRotation(&self, dwstreamindex: u32) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetRotation)(::windows::core::Interface::as_raw(self), dwstreamindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetRotation(&self, dwstreamindex: u32, dwrotationvalue: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetRotation)(::windows::core::Interface::as_raw(self), dwstreamindex, dwrotationvalue).ok()
    }
    pub unsafe fn SetCustomSink<P0>(&self, pmediasink: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaSink>,
    {
        (::windows::core::Interface::vtable(self).SetCustomSink)(::windows::core::Interface::as_raw(self), pmediasink.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFCapturePreviewSink, ::windows::core::IUnknown, IMFCaptureSink);
impl ::core::cmp::PartialEq for IMFCapturePreviewSink {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFCapturePreviewSink {}
impl ::core::fmt::Debug for IMFCapturePreviewSink {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFCapturePreviewSink").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFCapturePreviewSink {
    type Vtable = IMFCapturePreviewSink_Vtbl;
}
impl ::core::clone::Clone for IMFCapturePreviewSink {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFCapturePreviewSink {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x77346cfd_5b49_4d73_ace0_5b52a859f2e0);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFCapturePreviewSink_Vtbl {
    pub base__: IMFCaptureSink_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub SetRenderHandle: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, handle: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetRenderHandle: usize,
    pub SetRenderSurface: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, psurface: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub UpdateVideo: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const super::super::Foundation::COLORREF) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    UpdateVideo: usize,
    pub SetSampleCallback: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamsinkindex: u32, pcallback: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub GetMirrorState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pfmirrorstate: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetMirrorState: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub SetMirrorState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fmirrorstate: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetMirrorState: usize,
    pub GetRotation: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pdwrotationvalue: *mut u32) -> ::windows::core::HRESULT,
    pub SetRotation: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, dwrotationvalue: u32) -> ::windows::core::HRESULT,
    pub SetCustomSink: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pmediasink: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFCaptureRecordSink(::windows::core::IUnknown);
impl IMFCaptureRecordSink {
    pub unsafe fn GetOutputMediaType(&self, dwsinkstreamindex: u32, ppmediatype: ::core::option::Option<*mut ::core::option::Option<IMFMediaType>>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetOutputMediaType)(::windows::core::Interface::as_raw(self), dwsinkstreamindex, ::core::mem::transmute(ppmediatype.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetService(&self, dwsinkstreamindex: u32, rguidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppunknown: ::core::option::Option<*mut ::core::option::Option<::windows::core::IUnknown>>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetService)(::windows::core::Interface::as_raw(self), dwsinkstreamindex, rguidservice, riid, ::core::mem::transmute(ppunknown.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn AddStream<P0, P1>(&self, dwsourcestreamindex: u32, pmediatype: P0, pattributes: P1, pdwsinkstreamindex: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
        P1: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).base__.AddStream)(::windows::core::Interface::as_raw(self), dwsourcestreamindex, pmediatype.into_param().abi(), pattributes.into_param().abi(), ::core::mem::transmute(pdwsinkstreamindex.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn Prepare(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Prepare)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn RemoveAllStreams(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.RemoveAllStreams)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetOutputByteStream<P0>(&self, pbytestream: P0, guidcontainertype: *const ::windows::core::GUID) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFByteStream>,
    {
        (::windows::core::Interface::vtable(self).SetOutputByteStream)(::windows::core::Interface::as_raw(self), pbytestream.into_param().abi(), guidcontainertype).ok()
    }
    pub unsafe fn SetOutputFileName<P0>(&self, filename: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).SetOutputFileName)(::windows::core::Interface::as_raw(self), filename.into_param().abi()).ok()
    }
    pub unsafe fn SetSampleCallback<P0>(&self, dwstreamsinkindex: u32, pcallback: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFCaptureEngineOnSampleCallback>,
    {
        (::windows::core::Interface::vtable(self).SetSampleCallback)(::windows::core::Interface::as_raw(self), dwstreamsinkindex, pcallback.into_param().abi()).ok()
    }
    pub unsafe fn SetCustomSink<P0>(&self, pmediasink: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaSink>,
    {
        (::windows::core::Interface::vtable(self).SetCustomSink)(::windows::core::Interface::as_raw(self), pmediasink.into_param().abi()).ok()
    }
    pub unsafe fn GetRotation(&self, dwstreamindex: u32) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetRotation)(::windows::core::Interface::as_raw(self), dwstreamindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetRotation(&self, dwstreamindex: u32, dwrotationvalue: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetRotation)(::windows::core::Interface::as_raw(self), dwstreamindex, dwrotationvalue).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFCaptureRecordSink, ::windows::core::IUnknown, IMFCaptureSink);
impl ::core::cmp::PartialEq for IMFCaptureRecordSink {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFCaptureRecordSink {}
impl ::core::fmt::Debug for IMFCaptureRecordSink {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFCaptureRecordSink").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFCaptureRecordSink {
    type Vtable = IMFCaptureRecordSink_Vtbl;
}
impl ::core::clone::Clone for IMFCaptureRecordSink {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFCaptureRecordSink {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3323b55a_f92a_4fe2_8edc_e9bfc0634d77);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFCaptureRecordSink_Vtbl {
    pub base__: IMFCaptureSink_Vtbl,
    pub SetOutputByteStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbytestream: *mut ::core::ffi::c_void, guidcontainertype: *const ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub SetOutputFileName: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, filename: ::windows::core::PCWSTR) -> ::windows::core::HRESULT,
    pub SetSampleCallback: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamsinkindex: u32, pcallback: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetCustomSink: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pmediasink: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetRotation: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pdwrotationvalue: *mut u32) -> ::windows::core::HRESULT,
    pub SetRotation: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, dwrotationvalue: u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFCaptureSink(::windows::core::IUnknown);
impl IMFCaptureSink {
    pub unsafe fn GetOutputMediaType(&self, dwsinkstreamindex: u32, ppmediatype: ::core::option::Option<*mut ::core::option::Option<IMFMediaType>>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetOutputMediaType)(::windows::core::Interface::as_raw(self), dwsinkstreamindex, ::core::mem::transmute(ppmediatype.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetService(&self, dwsinkstreamindex: u32, rguidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppunknown: ::core::option::Option<*mut ::core::option::Option<::windows::core::IUnknown>>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetService)(::windows::core::Interface::as_raw(self), dwsinkstreamindex, rguidservice, riid, ::core::mem::transmute(ppunknown.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn AddStream<P0, P1>(&self, dwsourcestreamindex: u32, pmediatype: P0, pattributes: P1, pdwsinkstreamindex: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
        P1: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).AddStream)(::windows::core::Interface::as_raw(self), dwsourcestreamindex, pmediatype.into_param().abi(), pattributes.into_param().abi(), ::core::mem::transmute(pdwsinkstreamindex.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn Prepare(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Prepare)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn RemoveAllStreams(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveAllStreams)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFCaptureSink, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFCaptureSink {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFCaptureSink {}
impl ::core::fmt::Debug for IMFCaptureSink {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFCaptureSink").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFCaptureSink {
    type Vtable = IMFCaptureSink_Vtbl;
}
impl ::core::clone::Clone for IMFCaptureSink {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFCaptureSink {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x72d6135b_35e9_412c_b926_fd5265f2a885);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFCaptureSink_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetOutputMediaType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwsinkstreamindex: u32, ppmediatype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetService: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwsinkstreamindex: u32, rguidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppunknown: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub AddStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32, pmediatype: *mut ::core::ffi::c_void, pattributes: *mut ::core::ffi::c_void, pdwsinkstreamindex: *mut u32) -> ::windows::core::HRESULT,
    pub Prepare: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RemoveAllStreams: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFCaptureSink2(::windows::core::IUnknown);
impl IMFCaptureSink2 {
    pub unsafe fn GetOutputMediaType(&self, dwsinkstreamindex: u32, ppmediatype: ::core::option::Option<*mut ::core::option::Option<IMFMediaType>>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetOutputMediaType)(::windows::core::Interface::as_raw(self), dwsinkstreamindex, ::core::mem::transmute(ppmediatype.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetService(&self, dwsinkstreamindex: u32, rguidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppunknown: ::core::option::Option<*mut ::core::option::Option<::windows::core::IUnknown>>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetService)(::windows::core::Interface::as_raw(self), dwsinkstreamindex, rguidservice, riid, ::core::mem::transmute(ppunknown.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn AddStream<P0, P1>(&self, dwsourcestreamindex: u32, pmediatype: P0, pattributes: P1, pdwsinkstreamindex: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
        P1: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).base__.AddStream)(::windows::core::Interface::as_raw(self), dwsourcestreamindex, pmediatype.into_param().abi(), pattributes.into_param().abi(), ::core::mem::transmute(pdwsinkstreamindex.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn Prepare(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Prepare)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn RemoveAllStreams(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.RemoveAllStreams)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetOutputMediaType<P0, P1>(&self, dwstreamindex: u32, pmediatype: P0, pencodingattributes: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
        P1: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).SetOutputMediaType)(::windows::core::Interface::as_raw(self), dwstreamindex, pmediatype.into_param().abi(), pencodingattributes.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFCaptureSink2, ::windows::core::IUnknown, IMFCaptureSink);
impl ::core::cmp::PartialEq for IMFCaptureSink2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFCaptureSink2 {}
impl ::core::fmt::Debug for IMFCaptureSink2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFCaptureSink2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFCaptureSink2 {
    type Vtable = IMFCaptureSink2_Vtbl;
}
impl ::core::clone::Clone for IMFCaptureSink2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFCaptureSink2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf9e4219e_6197_4b5e_b888_bee310ab2c59);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFCaptureSink2_Vtbl {
    pub base__: IMFCaptureSink_Vtbl,
    pub SetOutputMediaType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pmediatype: *mut ::core::ffi::c_void, pencodingattributes: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFCaptureSource(::windows::core::IUnknown);
impl IMFCaptureSource {
    pub unsafe fn GetCaptureDeviceSource(&self, mfcaptureenginedevicetype: MF_CAPTURE_ENGINE_DEVICE_TYPE, ppmediasource: ::core::option::Option<*mut ::core::option::Option<IMFMediaSource>>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetCaptureDeviceSource)(::windows::core::Interface::as_raw(self), mfcaptureenginedevicetype, ::core::mem::transmute(ppmediasource.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetCaptureDeviceActivate(&self, mfcaptureenginedevicetype: MF_CAPTURE_ENGINE_DEVICE_TYPE, ppactivate: ::core::option::Option<*mut ::core::option::Option<IMFActivate>>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetCaptureDeviceActivate)(::windows::core::Interface::as_raw(self), mfcaptureenginedevicetype, ::core::mem::transmute(ppactivate.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetService(&self, rguidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppunknown: ::core::option::Option<*mut ::core::option::Option<::windows::core::IUnknown>>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetService)(::windows::core::Interface::as_raw(self), rguidservice, riid, ::core::mem::transmute(ppunknown.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn AddEffect<P0>(&self, dwsourcestreamindex: u32, punknown: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).AddEffect)(::windows::core::Interface::as_raw(self), dwsourcestreamindex, punknown.into_param().abi()).ok()
    }
    pub unsafe fn RemoveEffect<P0>(&self, dwsourcestreamindex: u32, punknown: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).RemoveEffect)(::windows::core::Interface::as_raw(self), dwsourcestreamindex, punknown.into_param().abi()).ok()
    }
    pub unsafe fn RemoveAllEffects(&self, dwsourcestreamindex: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveAllEffects)(::windows::core::Interface::as_raw(self), dwsourcestreamindex).ok()
    }
    pub unsafe fn GetAvailableDeviceMediaType(&self, dwsourcestreamindex: u32, dwmediatypeindex: u32, ppmediatype: ::core::option::Option<*mut ::core::option::Option<IMFMediaType>>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetAvailableDeviceMediaType)(::windows::core::Interface::as_raw(self), dwsourcestreamindex, dwmediatypeindex, ::core::mem::transmute(ppmediatype.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn SetCurrentDeviceMediaType<P0>(&self, dwsourcestreamindex: u32, pmediatype: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        (::windows::core::Interface::vtable(self).SetCurrentDeviceMediaType)(::windows::core::Interface::as_raw(self), dwsourcestreamindex, pmediatype.into_param().abi()).ok()
    }
    pub unsafe fn GetCurrentDeviceMediaType(&self, dwsourcestreamindex: u32) -> ::windows::core::Result<IMFMediaType> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
        (::windows::core::Interface::vtable(self).GetCurrentDeviceMediaType)(::windows::core::Interface::as_raw(self), dwsourcestreamindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDeviceStreamCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetDeviceStreamCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDeviceStreamCategory(&self, dwsourcestreamindex: u32) -> ::windows::core::Result<MF_CAPTURE_ENGINE_STREAM_CATEGORY> {
        let mut result__ = ::windows::core::zeroed::<MF_CAPTURE_ENGINE_STREAM_CATEGORY>();
        (::windows::core::Interface::vtable(self).GetDeviceStreamCategory)(::windows::core::Interface::as_raw(self), dwsourcestreamindex, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetMirrorState(&self, dwstreamindex: u32) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).GetMirrorState)(::windows::core::Interface::as_raw(self), dwstreamindex, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetMirrorState<P0>(&self, dwstreamindex: u32, fmirrorstate: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetMirrorState)(::windows::core::Interface::as_raw(self), dwstreamindex, fmirrorstate.into_param().abi()).ok()
    }
    pub unsafe fn GetStreamIndexFromFriendlyName(&self, uifriendlyname: u32) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetStreamIndexFromFriendlyName)(::windows::core::Interface::as_raw(self), uifriendlyname, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFCaptureSource, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFCaptureSource {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFCaptureSource {}
impl ::core::fmt::Debug for IMFCaptureSource {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFCaptureSource").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFCaptureSource {
    type Vtable = IMFCaptureSource_Vtbl;
}
impl ::core::clone::Clone for IMFCaptureSource {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFCaptureSource {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x439a42a8_0d2c_4505_be83_f79b2a05d5c4);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFCaptureSource_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetCaptureDeviceSource: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, mfcaptureenginedevicetype: MF_CAPTURE_ENGINE_DEVICE_TYPE, ppmediasource: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetCaptureDeviceActivate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, mfcaptureenginedevicetype: MF_CAPTURE_ENGINE_DEVICE_TYPE, ppactivate: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetService: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, rguidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppunknown: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub AddEffect: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32, punknown: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RemoveEffect: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32, punknown: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RemoveAllEffects: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32) -> ::windows::core::HRESULT,
    pub GetAvailableDeviceMediaType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32, dwmediatypeindex: u32, ppmediatype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetCurrentDeviceMediaType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32, pmediatype: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetCurrentDeviceMediaType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32, ppmediatype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetDeviceStreamCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwstreamcount: *mut u32) -> ::windows::core::HRESULT,
    pub GetDeviceStreamCategory: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32, pstreamcategory: *mut MF_CAPTURE_ENGINE_STREAM_CATEGORY) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub GetMirrorState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pfmirrorstate: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetMirrorState: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub SetMirrorState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, fmirrorstate: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetMirrorState: usize,
    pub GetStreamIndexFromFriendlyName: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, uifriendlyname: u32, pdwactualstreamindex: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFCdmSuspendNotify(::windows::core::IUnknown);
impl IMFCdmSuspendNotify {
    pub unsafe fn Begin(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Begin)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn End(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).End)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFCdmSuspendNotify, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFCdmSuspendNotify {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFCdmSuspendNotify {}
impl ::core::fmt::Debug for IMFCdmSuspendNotify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFCdmSuspendNotify").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFCdmSuspendNotify {
    type Vtable = IMFCdmSuspendNotify_Vtbl;
}
impl ::core::clone::Clone for IMFCdmSuspendNotify {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFCdmSuspendNotify {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7a5645d2_43bd_47fd_87b7_dcd24cc7d692);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFCdmSuspendNotify_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub Begin: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub End: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFClock(::windows::core::IUnknown);
impl IMFClock {
    pub unsafe fn GetClockCharacteristics(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetClockCharacteristics)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetCorrelatedTime(&self, dwreserved: u32, pllclocktime: *mut i64, phnssystemtime: *mut i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetCorrelatedTime)(::windows::core::Interface::as_raw(self), dwreserved, pllclocktime, phnssystemtime).ok()
    }
    pub unsafe fn GetContinuityKey(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetContinuityKey)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetState(&self, dwreserved: u32) -> ::windows::core::Result<MFCLOCK_STATE> {
        let mut result__ = ::windows::core::zeroed::<MFCLOCK_STATE>();
        (::windows::core::Interface::vtable(self).GetState)(::windows::core::Interface::as_raw(self), dwreserved, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetProperties(&self, pclockproperties: *mut MFCLOCK_PROPERTIES) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetProperties)(::windows::core::Interface::as_raw(self), pclockproperties).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFClock, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFClock {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFClock {}
impl ::core::fmt::Debug for IMFClock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFClock").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFClock {
    type Vtable = IMFClock_Vtbl;
}
impl ::core::clone::Clone for IMFClock {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFClock {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2eb1e945_18b8_4139_9b1a_d5d584818530);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFClock_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetClockCharacteristics: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwcharacteristics: *mut u32) -> ::windows::core::HRESULT,
    pub GetCorrelatedTime: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwreserved: u32, pllclocktime: *mut i64, phnssystemtime: *mut i64) -> ::windows::core::HRESULT,
    pub GetContinuityKey: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwcontinuitykey: *mut u32) -> ::windows::core::HRESULT,
    pub GetState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwreserved: u32, peclockstate: *mut MFCLOCK_STATE) -> ::windows::core::HRESULT,
    pub GetProperties: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pclockproperties: *mut MFCLOCK_PROPERTIES) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFClockConsumer(::windows::core::IUnknown);
impl IMFClockConsumer {
    pub unsafe fn SetPresentationClock<P0>(&self, ppresentationclock: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFPresentationClock>,
    {
        (::windows::core::Interface::vtable(self).SetPresentationClock)(::windows::core::Interface::as_raw(self), ppresentationclock.into_param().abi()).ok()
    }
    pub unsafe fn GetPresentationClock(&self) -> ::windows::core::Result<IMFPresentationClock> {
        let mut result__ = ::windows::core::zeroed::<IMFPresentationClock>();
        (::windows::core::Interface::vtable(self).GetPresentationClock)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFClockConsumer, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFClockConsumer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFClockConsumer {}
impl ::core::fmt::Debug for IMFClockConsumer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFClockConsumer").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFClockConsumer {
    type Vtable = IMFClockConsumer_Vtbl;
}
impl ::core::clone::Clone for IMFClockConsumer {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFClockConsumer {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6ef2a662_47c0_4666_b13d_cbb717f2fa2c);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFClockConsumer_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetPresentationClock: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppresentationclock: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetPresentationClock: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pppresentationclock: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFClockStateSink(::windows::core::IUnknown);
impl IMFClockStateSink {
    pub unsafe fn OnClockStart(&self, hnssystemtime: i64, llclockstartoffset: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).OnClockStart)(::windows::core::Interface::as_raw(self), hnssystemtime, llclockstartoffset).ok()
    }
    pub unsafe fn OnClockStop(&self, hnssystemtime: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).OnClockStop)(::windows::core::Interface::as_raw(self), hnssystemtime).ok()
    }
    pub unsafe fn OnClockPause(&self, hnssystemtime: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).OnClockPause)(::windows::core::Interface::as_raw(self), hnssystemtime).ok()
    }
    pub unsafe fn OnClockRestart(&self, hnssystemtime: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).OnClockRestart)(::windows::core::Interface::as_raw(self), hnssystemtime).ok()
    }
    pub unsafe fn OnClockSetRate(&self, hnssystemtime: i64, flrate: f32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).OnClockSetRate)(::windows::core::Interface::as_raw(self), hnssystemtime, flrate).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFClockStateSink, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFClockStateSink {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFClockStateSink {}
impl ::core::fmt::Debug for IMFClockStateSink {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFClockStateSink").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFClockStateSink {
    type Vtable = IMFClockStateSink_Vtbl;
}
impl ::core::clone::Clone for IMFClockStateSink {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFClockStateSink {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf6696e82_74f7_4f3d_a178_8a5e09c3659f);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFClockStateSink_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub OnClockStart: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hnssystemtime: i64, llclockstartoffset: i64) -> ::windows::core::HRESULT,
    pub OnClockStop: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hnssystemtime: i64) -> ::windows::core::HRESULT,
    pub OnClockPause: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hnssystemtime: i64) -> ::windows::core::HRESULT,
    pub OnClockRestart: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hnssystemtime: i64) -> ::windows::core::HRESULT,
    pub OnClockSetRate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hnssystemtime: i64, flrate: f32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFCollection(::windows::core::IUnknown);
impl IMFCollection {
    pub unsafe fn GetElementCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetElementCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetElement(&self, dwelementindex: u32) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::IUnknown>();
        (::windows::core::Interface::vtable(self).GetElement)(::windows::core::Interface::as_raw(self), dwelementindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn AddElement<P0>(&self, punkelement: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).AddElement)(::windows::core::Interface::as_raw(self), punkelement.into_param().abi()).ok()
    }
    pub unsafe fn RemoveElement(&self, dwelementindex: u32) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::IUnknown>();
        (::windows::core::Interface::vtable(self).RemoveElement)(::windows::core::Interface::as_raw(self), dwelementindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn InsertElementAt<P0>(&self, dwindex: u32, punknown: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).InsertElementAt)(::windows::core::Interface::as_raw(self), dwindex, punknown.into_param().abi()).ok()
    }
    pub unsafe fn RemoveAllElements(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveAllElements)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFCollection, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFCollection {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFCollection {}
impl ::core::fmt::Debug for IMFCollection {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFCollection").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFCollection {
    type Vtable = IMFCollection_Vtbl;
}
impl ::core::clone::Clone for IMFCollection {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFCollection {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5bc8a76b_869a_46a3_9b03_fa218a66aebe);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFCollection_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetElementCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcelements: *mut u32) -> ::windows::core::HRESULT,
    pub GetElement: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwelementindex: u32, ppunkelement: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub AddElement: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, punkelement: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RemoveElement: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwelementindex: u32, ppunkelement: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub InsertElementAt: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwindex: u32, punknown: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RemoveAllElements: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFContentDecryptionModule(::windows::core::IUnknown);
impl IMFContentDecryptionModule {
    pub unsafe fn SetContentEnabler<P0, P1>(&self, contentenabler: P0, result: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFContentEnabler>,
        P1: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        (::windows::core::Interface::vtable(self).SetContentEnabler)(::windows::core::Interface::as_raw(self), contentenabler.into_param().abi(), result.into_param().abi()).ok()
    }
    pub unsafe fn GetSuspendNotify(&self) -> ::windows::core::Result<IMFCdmSuspendNotify> {
        let mut result__ = ::windows::core::zeroed::<IMFCdmSuspendNotify>();
        (::windows::core::Interface::vtable(self).GetSuspendNotify)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetPMPHostApp<P0>(&self, pmphostapp: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFPMPHostApp>,
    {
        (::windows::core::Interface::vtable(self).SetPMPHostApp)(::windows::core::Interface::as_raw(self), pmphostapp.into_param().abi()).ok()
    }
    pub unsafe fn CreateSession<P0>(&self, sessiontype: MF_MEDIAKEYSESSION_TYPE, callbacks: P0) -> ::windows::core::Result<IMFContentDecryptionModuleSession>
    where
        P0: ::windows::core::IntoParam<IMFContentDecryptionModuleSessionCallbacks>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFContentDecryptionModuleSession>();
        (::windows::core::Interface::vtable(self).CreateSession)(::windows::core::Interface::as_raw(self), sessiontype, callbacks.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetServerCertificate(&self, certificate: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetServerCertificate)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(certificate.as_ptr()), certificate.len() as _).ok()
    }
    pub unsafe fn CreateTrustedInput(&self, contentinitdata: &[u8]) -> ::windows::core::Result<IMFTrustedInput> {
        let mut result__ = ::windows::core::zeroed::<IMFTrustedInput>();
        (::windows::core::Interface::vtable(self).CreateTrustedInput)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(contentinitdata.as_ptr()), contentinitdata.len() as _, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetProtectionSystemIds(&self, systemids: *mut *mut ::windows::core::GUID, count: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetProtectionSystemIds)(::windows::core::Interface::as_raw(self), systemids, count).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFContentDecryptionModule, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFContentDecryptionModule {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFContentDecryptionModule {}
impl ::core::fmt::Debug for IMFContentDecryptionModule {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFContentDecryptionModule").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFContentDecryptionModule {
    type Vtable = IMFContentDecryptionModule_Vtbl;
}
impl ::core::clone::Clone for IMFContentDecryptionModule {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFContentDecryptionModule {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x87be986c_10be_4943_bf48_4b54ce1983a2);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFContentDecryptionModule_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetContentEnabler: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, contentenabler: *mut ::core::ffi::c_void, result: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetSuspendNotify: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, notify: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetPMPHostApp: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pmphostapp: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub CreateSession: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, sessiontype: MF_MEDIAKEYSESSION_TYPE, callbacks: *mut ::core::ffi::c_void, session: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetServerCertificate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, certificate: *const u8, certificatesize: u32) -> ::windows::core::HRESULT,
    pub CreateTrustedInput: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, contentinitdata: *const u8, contentinitdatasize: u32, trustedinput: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetProtectionSystemIds: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, systemids: *mut *mut ::windows::core::GUID, count: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFContentDecryptionModuleAccess(::windows::core::IUnknown);
impl IMFContentDecryptionModuleAccess {
    #[doc = "*Required features: `\"Win32_UI_Shell_PropertiesSystem\"`*"]
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub unsafe fn CreateContentDecryptionModule<P0>(&self, contentdecryptionmoduleproperties: P0) -> ::windows::core::Result<IMFContentDecryptionModule>
    where
        P0: ::windows::core::IntoParam<super::super::UI::Shell::PropertiesSystem::IPropertyStore>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFContentDecryptionModule>();
        (::windows::core::Interface::vtable(self).CreateContentDecryptionModule)(::windows::core::Interface::as_raw(self), contentdecryptionmoduleproperties.into_param().abi(), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_UI_Shell_PropertiesSystem\"`*"]
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub unsafe fn GetConfiguration(&self) -> ::windows::core::Result<super::super::UI::Shell::PropertiesSystem::IPropertyStore> {
        let mut result__ = ::windows::core::zeroed::<super::super::UI::Shell::PropertiesSystem::IPropertyStore>();
        (::windows::core::Interface::vtable(self).GetConfiguration)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetKeySystem(&self) -> ::windows::core::Result<::windows::core::PWSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::PWSTR>();
        (::windows::core::Interface::vtable(self).GetKeySystem)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFContentDecryptionModuleAccess, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFContentDecryptionModuleAccess {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFContentDecryptionModuleAccess {}
impl ::core::fmt::Debug for IMFContentDecryptionModuleAccess {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFContentDecryptionModuleAccess").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFContentDecryptionModuleAccess {
    type Vtable = IMFContentDecryptionModuleAccess_Vtbl;
}
impl ::core::clone::Clone for IMFContentDecryptionModuleAccess {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFContentDecryptionModuleAccess {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa853d1f4_e2a0_4303_9edc_f1a68ee43136);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFContentDecryptionModuleAccess_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub CreateContentDecryptionModule: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, contentdecryptionmoduleproperties: *mut ::core::ffi::c_void, contentdecryptionmodule: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_UI_Shell_PropertiesSystem"))]
    CreateContentDecryptionModule: usize,
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub GetConfiguration: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, configuration: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_UI_Shell_PropertiesSystem"))]
    GetConfiguration: usize,
    pub GetKeySystem: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, keysystem: *mut ::windows::core::PWSTR) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFContentDecryptionModuleFactory(::windows::core::IUnknown);
impl IMFContentDecryptionModuleFactory {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsTypeSupported<P0, P1>(&self, keysystem: P0, contenttype: P1) -> super::super::Foundation::BOOL
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).IsTypeSupported)(::windows::core::Interface::as_raw(self), keysystem.into_param().abi(), contenttype.into_param().abi())
    }
    #[doc = "*Required features: `\"Win32_UI_Shell_PropertiesSystem\"`*"]
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub unsafe fn CreateContentDecryptionModuleAccess<P0>(&self, keysystem: P0, configurations: &[::core::option::Option<super::super::UI::Shell::PropertiesSystem::IPropertyStore>]) -> ::windows::core::Result<IMFContentDecryptionModuleAccess>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFContentDecryptionModuleAccess>();
        (::windows::core::Interface::vtable(self).CreateContentDecryptionModuleAccess)(::windows::core::Interface::as_raw(self), keysystem.into_param().abi(), ::core::mem::transmute(configurations.as_ptr()), configurations.len() as _, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFContentDecryptionModuleFactory, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFContentDecryptionModuleFactory {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFContentDecryptionModuleFactory {}
impl ::core::fmt::Debug for IMFContentDecryptionModuleFactory {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFContentDecryptionModuleFactory").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFContentDecryptionModuleFactory {
    type Vtable = IMFContentDecryptionModuleFactory_Vtbl;
}
impl ::core::clone::Clone for IMFContentDecryptionModuleFactory {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFContentDecryptionModuleFactory {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7d5abf16_4cbb_4e08_b977_9ba59049943e);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFContentDecryptionModuleFactory_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub IsTypeSupported: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, keysystem: ::windows::core::PCWSTR, contenttype: ::windows::core::PCWSTR) -> super::super::Foundation::BOOL,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsTypeSupported: usize,
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub CreateContentDecryptionModuleAccess: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, keysystem: ::windows::core::PCWSTR, configurations: *const *mut ::core::ffi::c_void, numconfigurations: u32, contentdecryptionmoduleaccess: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_UI_Shell_PropertiesSystem"))]
    CreateContentDecryptionModuleAccess: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFContentDecryptionModuleSession(::windows::core::IUnknown);
impl IMFContentDecryptionModuleSession {
    pub unsafe fn GetSessionId(&self) -> ::windows::core::Result<::windows::core::PWSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::PWSTR>();
        (::windows::core::Interface::vtable(self).GetSessionId)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetExpiration(&self) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).GetExpiration)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetKeyStatuses(&self, keystatuses: *mut *mut MFMediaKeyStatus, numkeystatuses: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetKeyStatuses)(::windows::core::Interface::as_raw(self), keystatuses, numkeystatuses).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Load<P0>(&self, sessionid: P0) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).Load)(::windows::core::Interface::as_raw(self), sessionid.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn GenerateRequest<P0>(&self, initdatatype: P0, initdata: &[u8]) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).GenerateRequest)(::windows::core::Interface::as_raw(self), initdatatype.into_param().abi(), ::core::mem::transmute(initdata.as_ptr()), initdata.len() as _).ok()
    }
    pub unsafe fn Update(&self, response: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Update)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(response.as_ptr()), response.len() as _).ok()
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Close)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Remove(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Remove)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFContentDecryptionModuleSession, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFContentDecryptionModuleSession {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFContentDecryptionModuleSession {}
impl ::core::fmt::Debug for IMFContentDecryptionModuleSession {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFContentDecryptionModuleSession").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFContentDecryptionModuleSession {
    type Vtable = IMFContentDecryptionModuleSession_Vtbl;
}
impl ::core::clone::Clone for IMFContentDecryptionModuleSession {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFContentDecryptionModuleSession {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4e233efd_1dd2_49e8_b577_d63eee4c0d33);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFContentDecryptionModuleSession_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetSessionId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, sessionid: *mut ::windows::core::PWSTR) -> ::windows::core::HRESULT,
    pub GetExpiration: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, expiration: *mut f64) -> ::windows::core::HRESULT,
    pub GetKeyStatuses: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, keystatuses: *mut *mut MFMediaKeyStatus, numkeystatuses: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub Load: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, sessionid: ::windows::core::PCWSTR, loaded: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    Load: usize,
    pub GenerateRequest: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, initdatatype: ::windows::core::PCWSTR, initdata: *const u8, initdatasize: u32) -> ::windows::core::HRESULT,
    pub Update: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, response: *const u8, responsesize: u32) -> ::windows::core::HRESULT,
    pub Close: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Remove: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFContentDecryptionModuleSessionCallbacks(::windows::core::IUnknown);
impl IMFContentDecryptionModuleSessionCallbacks {
    pub unsafe fn KeyMessage<P0>(&self, messagetype: MF_MEDIAKEYSESSION_MESSAGETYPE, message: &[u8], destinationurl: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).KeyMessage)(::windows::core::Interface::as_raw(self), messagetype, ::core::mem::transmute(message.as_ptr()), message.len() as _, destinationurl.into_param().abi()).ok()
    }
    pub unsafe fn KeyStatusChanged(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).KeyStatusChanged)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFContentDecryptionModuleSessionCallbacks, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFContentDecryptionModuleSessionCallbacks {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFContentDecryptionModuleSessionCallbacks {}
impl ::core::fmt::Debug for IMFContentDecryptionModuleSessionCallbacks {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFContentDecryptionModuleSessionCallbacks").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFContentDecryptionModuleSessionCallbacks {
    type Vtable = IMFContentDecryptionModuleSessionCallbacks_Vtbl;
}
impl ::core::clone::Clone for IMFContentDecryptionModuleSessionCallbacks {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFContentDecryptionModuleSessionCallbacks {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3f96ee40_ad81_4096_8470_59a4b770f89a);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFContentDecryptionModuleSessionCallbacks_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub KeyMessage: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, messagetype: MF_MEDIAKEYSESSION_MESSAGETYPE, message: *const u8, messagesize: u32, destinationurl: ::windows::core::PCWSTR) -> ::windows::core::HRESULT,
    pub KeyStatusChanged: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFContentDecryptorContext(::windows::core::IUnknown);
impl IMFContentDecryptorContext {
    pub unsafe fn InitializeHardwareKey(&self, inputprivatedata: ::core::option::Option<&[u8]>) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).InitializeHardwareKey)(::windows::core::Interface::as_raw(self), inputprivatedata.as_deref().map_or(0, |slice| slice.len() as _), ::core::mem::transmute(inputprivatedata.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr())), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFContentDecryptorContext, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFContentDecryptorContext {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFContentDecryptorContext {}
impl ::core::fmt::Debug for IMFContentDecryptorContext {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFContentDecryptorContext").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFContentDecryptorContext {
    type Vtable = IMFContentDecryptorContext_Vtbl;
}
impl ::core::clone::Clone for IMFContentDecryptorContext {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFContentDecryptorContext {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7ec4b1bd_43fb_4763_85d2_64fcb5c5f4cb);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFContentDecryptorContext_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub InitializeHardwareKey: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, inputprivatedatabytecount: u32, inputprivatedata: *const ::core::ffi::c_void, outputprivatedata: *mut u64) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFContentEnabler(::windows::core::IUnknown);
impl IMFContentEnabler {
    pub unsafe fn GetEnableType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).GetEnableType)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetEnableURL(&self, ppwszurl: *mut ::windows::core::PWSTR, pcchurl: *mut u32, ptruststatus: *mut MF_URL_TRUST_STATUS) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetEnableURL)(::windows::core::Interface::as_raw(self), ppwszurl, pcchurl, ptruststatus).ok()
    }
    pub unsafe fn GetEnableData(&self, ppbdata: *mut *mut u8, pcbdata: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetEnableData)(::windows::core::Interface::as_raw(self), ppbdata, pcbdata).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsAutomaticSupported(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).IsAutomaticSupported)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn AutomaticEnable(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).AutomaticEnable)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn MonitorEnable(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).MonitorEnable)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Cancel(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Cancel)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFContentEnabler, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFContentEnabler {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFContentEnabler {}
impl ::core::fmt::Debug for IMFContentEnabler {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFContentEnabler").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFContentEnabler {
    type Vtable = IMFContentEnabler_Vtbl;
}
impl ::core::clone::Clone for IMFContentEnabler {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFContentEnabler {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd3c4ef59_49ce_4381_9071_d5bcd044c770);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFContentEnabler_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetEnableType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ptype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub GetEnableURL: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppwszurl: *mut ::windows::core::PWSTR, pcchurl: *mut u32, ptruststatus: *mut MF_URL_TRUST_STATUS) -> ::windows::core::HRESULT,
    pub GetEnableData: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppbdata: *mut *mut u8, pcbdata: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub IsAutomaticSupported: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pfautomatic: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsAutomaticSupported: usize,
    pub AutomaticEnable: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub MonitorEnable: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Cancel: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFContentProtectionDevice(::windows::core::IUnknown);
impl IMFContentProtectionDevice {
    pub unsafe fn InvokeFunction(&self, functionid: u32, inputbuffer: &[u8], outputbufferbytecount: *mut u32, outputbuffer: *mut u8) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).InvokeFunction)(::windows::core::Interface::as_raw(self), functionid, inputbuffer.len() as _, ::core::mem::transmute(inputbuffer.as_ptr()), outputbufferbytecount, outputbuffer).ok()
    }
    pub unsafe fn GetPrivateDataByteCount(&self, privateinputbytecount: *mut u32, privateoutputbytecount: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetPrivateDataByteCount)(::windows::core::Interface::as_raw(self), privateinputbytecount, privateoutputbytecount).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFContentProtectionDevice, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFContentProtectionDevice {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFContentProtectionDevice {}
impl ::core::fmt::Debug for IMFContentProtectionDevice {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFContentProtectionDevice").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFContentProtectionDevice {
    type Vtable = IMFContentProtectionDevice_Vtbl;
}
impl ::core::clone::Clone for IMFContentProtectionDevice {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFContentProtectionDevice {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe6257174_a060_4c9a_a088_3b1b471cad28);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFContentProtectionDevice_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub InvokeFunction: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, functionid: u32, inputbufferbytecount: u32, inputbuffer: *const u8, outputbufferbytecount: *mut u32, outputbuffer: *mut u8) -> ::windows::core::HRESULT,
    pub GetPrivateDataByteCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, privateinputbytecount: *mut u32, privateoutputbytecount: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFContentProtectionManager(::windows::core::IUnknown);
impl IMFContentProtectionManager {
    pub unsafe fn BeginEnableContent<P0, P1, P2, P3>(&self, penableractivate: P0, ptopo: P1, pcallback: P2, punkstate: P3) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFActivate>,
        P1: ::windows::core::IntoParam<IMFTopology>,
        P2: ::windows::core::IntoParam<IMFAsyncCallback>,
        P3: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginEnableContent)(::windows::core::Interface::as_raw(self), penableractivate.into_param().abi(), ptopo.into_param().abi(), pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    pub unsafe fn EndEnableContent<P0>(&self, presult: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        (::windows::core::Interface::vtable(self).EndEnableContent)(::windows::core::Interface::as_raw(self), presult.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFContentProtectionManager, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFContentProtectionManager {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFContentProtectionManager {}
impl ::core::fmt::Debug for IMFContentProtectionManager {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFContentProtectionManager").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFContentProtectionManager {
    type Vtable = IMFContentProtectionManager_Vtbl;
}
impl ::core::clone::Clone for IMFContentProtectionManager {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFContentProtectionManager {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xacf92459_6a61_42bd_b57c_b43e51203cb0);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFContentProtectionManager_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub BeginEnableContent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, penableractivate: *mut ::core::ffi::c_void, ptopo: *mut ::core::ffi::c_void, pcallback: *mut ::core::ffi::c_void, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub EndEnableContent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFD3D12SynchronizationObject(::windows::core::IUnknown);
impl IMFD3D12SynchronizationObject {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SignalEventOnFinalResourceRelease<P0>(&self, hevent: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self).SignalEventOnFinalResourceRelease)(::windows::core::Interface::as_raw(self), hevent.into_param().abi()).ok()
    }
    pub unsafe fn Reset(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Reset)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFD3D12SynchronizationObject, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFD3D12SynchronizationObject {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFD3D12SynchronizationObject {}
impl ::core::fmt::Debug for IMFD3D12SynchronizationObject {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFD3D12SynchronizationObject").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFD3D12SynchronizationObject {
    type Vtable = IMFD3D12SynchronizationObject_Vtbl;
}
impl ::core::clone::Clone for IMFD3D12SynchronizationObject {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFD3D12SynchronizationObject {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x802302b0_82de_45e1_b421_f19ee5bdaf23);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFD3D12SynchronizationObject_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub SignalEventOnFinalResourceRelease: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hevent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SignalEventOnFinalResourceRelease: usize,
    pub Reset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFD3D12SynchronizationObjectCommands(::windows::core::IUnknown);
impl IMFD3D12SynchronizationObjectCommands {
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn EnqueueResourceReady<P0>(&self, pproducercommandqueue: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12CommandQueue>,
    {
        (::windows::core::Interface::vtable(self).EnqueueResourceReady)(::windows::core::Interface::as_raw(self), pproducercommandqueue.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn EnqueueResourceReadyWait<P0>(&self, pconsumercommandqueue: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12CommandQueue>,
    {
        (::windows::core::Interface::vtable(self).EnqueueResourceReadyWait)(::windows::core::Interface::as_raw(self), pconsumercommandqueue.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SignalEventOnResourceReady<P0>(&self, hevent: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self).SignalEventOnResourceReady)(::windows::core::Interface::as_raw(self), hevent.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D12\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub unsafe fn EnqueueResourceRelease<P0>(&self, pconsumercommandqueue: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Graphics::Direct3D12::ID3D12CommandQueue>,
    {
        (::windows::core::Interface::vtable(self).EnqueueResourceRelease)(::windows::core::Interface::as_raw(self), pconsumercommandqueue.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFD3D12SynchronizationObjectCommands, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFD3D12SynchronizationObjectCommands {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFD3D12SynchronizationObjectCommands {}
impl ::core::fmt::Debug for IMFD3D12SynchronizationObjectCommands {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFD3D12SynchronizationObjectCommands").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFD3D12SynchronizationObjectCommands {
    type Vtable = IMFD3D12SynchronizationObjectCommands_Vtbl;
}
impl ::core::clone::Clone for IMFD3D12SynchronizationObjectCommands {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFD3D12SynchronizationObjectCommands {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x09d0f835_92ff_4e53_8efa_40faa551f233);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFD3D12SynchronizationObjectCommands_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub EnqueueResourceReady: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pproducercommandqueue: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    EnqueueResourceReady: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub EnqueueResourceReadyWait: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pconsumercommandqueue: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    EnqueueResourceReadyWait: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub SignalEventOnResourceReady: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hevent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SignalEventOnResourceReady: usize,
    #[cfg(feature = "Win32_Graphics_Direct3D12")]
    pub EnqueueResourceRelease: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pconsumercommandqueue: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D12"))]
    EnqueueResourceRelease: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFDLNASinkInit(::windows::core::IUnknown);
impl IMFDLNASinkInit {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Initialize<P0, P1>(&self, pbytestream: P0, fpal: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFByteStream>,
        P1: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).Initialize)(::windows::core::Interface::as_raw(self), pbytestream.into_param().abi(), fpal.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFDLNASinkInit, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFDLNASinkInit {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFDLNASinkInit {}
impl ::core::fmt::Debug for IMFDLNASinkInit {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFDLNASinkInit").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFDLNASinkInit {
    type Vtable = IMFDLNASinkInit_Vtbl;
}
impl ::core::clone::Clone for IMFDLNASinkInit {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFDLNASinkInit {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0c012799_1b61_4c10_bda9_04445be5f561);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFDLNASinkInit_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub Initialize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbytestream: *mut ::core::ffi::c_void, fpal: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    Initialize: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFDRMNetHelper(::windows::core::IUnknown);
impl IMFDRMNetHelper {
    pub unsafe fn ProcessLicenseRequest(&self, plicenserequest: &[u8], pplicenseresponse: *mut *mut u8, pcblicenseresponse: *mut u32, pbstrkid: *mut ::windows::core::BSTR) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ProcessLicenseRequest)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(plicenserequest.as_ptr()), plicenserequest.len() as _, pplicenseresponse, pcblicenseresponse, ::core::mem::transmute(pbstrkid)).ok()
    }
    pub unsafe fn GetChainedLicenseResponse(&self, pplicenseresponse: *mut *mut u8, pcblicenseresponse: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetChainedLicenseResponse)(::windows::core::Interface::as_raw(self), pplicenseresponse, pcblicenseresponse).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFDRMNetHelper, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFDRMNetHelper {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFDRMNetHelper {}
impl ::core::fmt::Debug for IMFDRMNetHelper {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFDRMNetHelper").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFDRMNetHelper {
    type Vtable = IMFDRMNetHelper_Vtbl;
}
impl ::core::clone::Clone for IMFDRMNetHelper {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFDRMNetHelper {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3d1ff0ea_679a_4190_8d46_7fa69e8c7e15);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFDRMNetHelper_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub ProcessLicenseRequest: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, plicenserequest: *const u8, cblicenserequest: u32, pplicenseresponse: *mut *mut u8, pcblicenseresponse: *mut u32, pbstrkid: *mut ::std::mem::MaybeUninit<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub GetChainedLicenseResponse: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pplicenseresponse: *mut *mut u8, pcblicenseresponse: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFDXGIBuffer(::windows::core::IUnknown);
impl IMFDXGIBuffer {
    pub unsafe fn GetResource(&self, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetResource)(::windows::core::Interface::as_raw(self), riid, ppvobject).ok()
    }
    pub unsafe fn GetSubresourceIndex(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetSubresourceIndex)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUnknown(&self, guid: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetUnknown)(::windows::core::Interface::as_raw(self), guid, riid, ppvobject).ok()
    }
    pub unsafe fn SetUnknown<P0>(&self, guid: *const ::windows::core::GUID, punkdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).SetUnknown)(::windows::core::Interface::as_raw(self), guid, punkdata.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFDXGIBuffer, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFDXGIBuffer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFDXGIBuffer {}
impl ::core::fmt::Debug for IMFDXGIBuffer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFDXGIBuffer").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFDXGIBuffer {
    type Vtable = IMFDXGIBuffer_Vtbl;
}
impl ::core::clone::Clone for IMFDXGIBuffer {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFDXGIBuffer {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe7174cfa_1c9e_48b1_8866_626226bfc258);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFDXGIBuffer_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetResource: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetSubresourceIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pusubresource: *mut u32) -> ::windows::core::HRESULT,
    pub GetUnknown: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guid: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetUnknown: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guid: *const ::windows::core::GUID, punkdata: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFDXGIDeviceManager(::windows::core::IUnknown);
impl IMFDXGIDeviceManager {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn CloseDeviceHandle<P0>(&self, hdevice: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self).CloseDeviceHandle)(::windows::core::Interface::as_raw(self), hdevice.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetVideoService<P0>(&self, hdevice: P0, riid: *const ::windows::core::GUID, ppservice: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self).GetVideoService)(::windows::core::Interface::as_raw(self), hdevice.into_param().abi(), riid, ppservice).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn LockDevice<P0, P1>(&self, hdevice: P0, riid: *const ::windows::core::GUID, ppunkdevice: *mut *mut ::core::ffi::c_void, fblock: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::HANDLE>,
        P1: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).LockDevice)(::windows::core::Interface::as_raw(self), hdevice.into_param().abi(), riid, ppunkdevice, fblock.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn OpenDeviceHandle(&self) -> ::windows::core::Result<super::super::Foundation::HANDLE> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self).OpenDeviceHandle)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn ResetDevice<P0>(&self, punkdevice: P0, resettoken: u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).ResetDevice)(::windows::core::Interface::as_raw(self), punkdevice.into_param().abi(), resettoken).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn TestDevice<P0>(&self, hdevice: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self).TestDevice)(::windows::core::Interface::as_raw(self), hdevice.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn UnlockDevice<P0, P1>(&self, hdevice: P0, fsavestate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::HANDLE>,
        P1: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).UnlockDevice)(::windows::core::Interface::as_raw(self), hdevice.into_param().abi(), fsavestate.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFDXGIDeviceManager, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFDXGIDeviceManager {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFDXGIDeviceManager {}
impl ::core::fmt::Debug for IMFDXGIDeviceManager {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFDXGIDeviceManager").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFDXGIDeviceManager {
    type Vtable = IMFDXGIDeviceManager_Vtbl;
}
impl ::core::clone::Clone for IMFDXGIDeviceManager {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFDXGIDeviceManager {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xeb533d5d_2db6_40f8_97a9_494692014f07);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFDXGIDeviceManager_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub CloseDeviceHandle: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    CloseDeviceHandle: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub GetVideoService: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, riid: *const ::windows::core::GUID, ppservice: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetVideoService: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub LockDevice: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, riid: *const ::windows::core::GUID, ppunkdevice: *mut *mut ::core::ffi::c_void, fblock: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    LockDevice: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub OpenDeviceHandle: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, phdevice: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    OpenDeviceHandle: usize,
    pub ResetDevice: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, punkdevice: *mut ::core::ffi::c_void, resettoken: u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub TestDevice: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    TestDevice: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub UnlockDevice: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, fsavestate: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    UnlockDevice: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFDXGIDeviceManagerSource(::windows::core::IUnknown);
impl IMFDXGIDeviceManagerSource {
    pub unsafe fn GetManager(&self) -> ::windows::core::Result<IMFDXGIDeviceManager> {
        let mut result__ = ::windows::core::zeroed::<IMFDXGIDeviceManager>();
        (::windows::core::Interface::vtable(self).GetManager)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFDXGIDeviceManagerSource, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFDXGIDeviceManagerSource {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFDXGIDeviceManagerSource {}
impl ::core::fmt::Debug for IMFDXGIDeviceManagerSource {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFDXGIDeviceManagerSource").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFDXGIDeviceManagerSource {
    type Vtable = IMFDXGIDeviceManagerSource_Vtbl;
}
impl ::core::clone::Clone for IMFDXGIDeviceManagerSource {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFDXGIDeviceManagerSource {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x20bc074b_7a8d_4609_8c3b_64a0a3b5d7ce);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFDXGIDeviceManagerSource_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetManager: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppmanager: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFDesiredSample(::windows::core::IUnknown);
impl IMFDesiredSample {
    pub unsafe fn GetDesiredSampleTimeAndDuration(&self, phnssampletime: *mut i64, phnssampleduration: *mut i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDesiredSampleTimeAndDuration)(::windows::core::Interface::as_raw(self), phnssampletime, phnssampleduration).ok()
    }
    pub unsafe fn SetDesiredSampleTimeAndDuration(&self, hnssampletime: i64, hnssampleduration: i64) {
        (::windows::core::Interface::vtable(self).SetDesiredSampleTimeAndDuration)(::windows::core::Interface::as_raw(self), hnssampletime, hnssampleduration)
    }
    pub unsafe fn Clear(&self) {
        (::windows::core::Interface::vtable(self).Clear)(::windows::core::Interface::as_raw(self))
    }
}
::windows::imp::interface_hierarchy!(IMFDesiredSample, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFDesiredSample {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFDesiredSample {}
impl ::core::fmt::Debug for IMFDesiredSample {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFDesiredSample").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFDesiredSample {
    type Vtable = IMFDesiredSample_Vtbl;
}
impl ::core::clone::Clone for IMFDesiredSample {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFDesiredSample {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x56c294d0_753e_4260_8d61_a3d8820b1d54);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFDesiredSample_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetDesiredSampleTimeAndDuration: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, phnssampletime: *mut i64, phnssampleduration: *mut i64) -> ::windows::core::HRESULT,
    pub SetDesiredSampleTimeAndDuration: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hnssampletime: i64, hnssampleduration: i64),
    pub Clear: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFDeviceTransform(::windows::core::IUnknown);
impl IMFDeviceTransform {
    pub unsafe fn InitializeTransform<P0>(&self, pattributes: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).InitializeTransform)(::windows::core::Interface::as_raw(self), pattributes.into_param().abi()).ok()
    }
    pub unsafe fn GetInputAvailableType(&self, dwinputstreamid: u32, dwtypeindex: u32) -> ::windows::core::Result<IMFMediaType> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
        (::windows::core::Interface::vtable(self).GetInputAvailableType)(::windows::core::Interface::as_raw(self), dwinputstreamid, dwtypeindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetInputCurrentType(&self, dwinputstreamid: u32) -> ::windows::core::Result<IMFMediaType> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
        (::windows::core::Interface::vtable(self).GetInputCurrentType)(::windows::core::Interface::as_raw(self), dwinputstreamid, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetInputStreamAttributes(&self, dwinputstreamid: u32) -> ::windows::core::Result<IMFAttributes> {
        let mut result__ = ::windows::core::zeroed::<IMFAttributes>();
        (::windows::core::Interface::vtable(self).GetInputStreamAttributes)(::windows::core::Interface::as_raw(self), dwinputstreamid, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetOutputAvailableType(&self, dwoutputstreamid: u32, dwtypeindex: u32) -> ::windows::core::Result<IMFMediaType> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
        (::windows::core::Interface::vtable(self).GetOutputAvailableType)(::windows::core::Interface::as_raw(self), dwoutputstreamid, dwtypeindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetOutputCurrentType(&self, dwoutputstreamid: u32) -> ::windows::core::Result<IMFMediaType> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
        (::windows::core::Interface::vtable(self).GetOutputCurrentType)(::windows::core::Interface::as_raw(self), dwoutputstreamid, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetOutputStreamAttributes(&self, dwoutputstreamid: u32) -> ::windows::core::Result<IMFAttributes> {
        let mut result__ = ::windows::core::zeroed::<IMFAttributes>();
        (::windows::core::Interface::vtable(self).GetOutputStreamAttributes)(::windows::core::Interface::as_raw(self), dwoutputstreamid, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStreamCount(&self, pcinputstreams: *mut u32, pcoutputstreams: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetStreamCount)(::windows::core::Interface::as_raw(self), pcinputstreams, pcoutputstreams).ok()
    }
    pub unsafe fn GetStreamIDs(&self, dwinputidarraysize: u32, pdwinputstreamids: *mut u32, dwoutputidarraysize: u32, pdwoutputstreamids: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetStreamIDs)(::windows::core::Interface::as_raw(self), dwinputidarraysize, pdwinputstreamids, dwoutputidarraysize, pdwoutputstreamids).ok()
    }
    pub unsafe fn ProcessEvent<P0>(&self, dwinputstreamid: u32, pevent: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaEvent>,
    {
        (::windows::core::Interface::vtable(self).ProcessEvent)(::windows::core::Interface::as_raw(self), dwinputstreamid, pevent.into_param().abi()).ok()
    }
    pub unsafe fn ProcessInput<P0>(&self, dwinputstreamid: u32, psample: P0, dwflags: u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFSample>,
    {
        (::windows::core::Interface::vtable(self).ProcessInput)(::windows::core::Interface::as_raw(self), dwinputstreamid, psample.into_param().abi(), dwflags).ok()
    }
    pub unsafe fn ProcessMessage(&self, emessage: MFT_MESSAGE_TYPE, ulparam: usize) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ProcessMessage)(::windows::core::Interface::as_raw(self), emessage, ulparam).ok()
    }
    pub unsafe fn ProcessOutput(&self, dwflags: u32, coutputbuffercount: u32, poutputsample: *mut MFT_OUTPUT_DATA_BUFFER, pdwstatus: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ProcessOutput)(::windows::core::Interface::as_raw(self), dwflags, coutputbuffercount, poutputsample, pdwstatus).ok()
    }
    pub unsafe fn SetInputStreamState<P0>(&self, dwstreamid: u32, pmediatype: P0, value: DeviceStreamState, dwflags: u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        (::windows::core::Interface::vtable(self).SetInputStreamState)(::windows::core::Interface::as_raw(self), dwstreamid, pmediatype.into_param().abi(), value, dwflags).ok()
    }
    pub unsafe fn GetInputStreamState(&self, dwstreamid: u32) -> ::windows::core::Result<DeviceStreamState> {
        let mut result__ = ::windows::core::zeroed::<DeviceStreamState>();
        (::windows::core::Interface::vtable(self).GetInputStreamState)(::windows::core::Interface::as_raw(self), dwstreamid, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetOutputStreamState<P0>(&self, dwstreamid: u32, pmediatype: P0, value: DeviceStreamState, dwflags: u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        (::windows::core::Interface::vtable(self).SetOutputStreamState)(::windows::core::Interface::as_raw(self), dwstreamid, pmediatype.into_param().abi(), value, dwflags).ok()
    }
    pub unsafe fn GetOutputStreamState(&self, dwstreamid: u32) -> ::windows::core::Result<DeviceStreamState> {
        let mut result__ = ::windows::core::zeroed::<DeviceStreamState>();
        (::windows::core::Interface::vtable(self).GetOutputStreamState)(::windows::core::Interface::as_raw(self), dwstreamid, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetInputStreamPreferredState(&self, dwstreamid: u32, value: *mut DeviceStreamState, ppmediatype: *mut ::core::option::Option<IMFMediaType>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetInputStreamPreferredState)(::windows::core::Interface::as_raw(self), dwstreamid, value, ::core::mem::transmute(ppmediatype)).ok()
    }
    pub unsafe fn FlushInputStream(&self, dwstreamindex: u32, dwflags: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).FlushInputStream)(::windows::core::Interface::as_raw(self), dwstreamindex, dwflags).ok()
    }
    pub unsafe fn FlushOutputStream(&self, dwstreamindex: u32, dwflags: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).FlushOutputStream)(::windows::core::Interface::as_raw(self), dwstreamindex, dwflags).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFDeviceTransform, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFDeviceTransform {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFDeviceTransform {}
impl ::core::fmt::Debug for IMFDeviceTransform {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFDeviceTransform").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFDeviceTransform {
    type Vtable = IMFDeviceTransform_Vtbl;
}
impl ::core::clone::Clone for IMFDeviceTransform {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFDeviceTransform {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd818fbd8_fc46_42f2_87ac_1ea2d1f9bf32);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFDeviceTransform_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub InitializeTransform: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pattributes: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetInputAvailableType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, dwtypeindex: u32, pmediatype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetInputCurrentType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, pmediatype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetInputStreamAttributes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, ppattributes: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetOutputAvailableType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, dwtypeindex: u32, pmediatype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetOutputCurrentType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, pmediatype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetOutputStreamAttributes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, ppattributes: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetStreamCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcinputstreams: *mut u32, pcoutputstreams: *mut u32) -> ::windows::core::HRESULT,
    pub GetStreamIDs: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwinputidarraysize: u32, pdwinputstreamids: *mut u32, dwoutputidarraysize: u32, pdwoutputstreamids: *mut u32) -> ::windows::core::HRESULT,
    pub ProcessEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, pevent: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub ProcessInput: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, psample: *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::HRESULT,
    pub ProcessMessage: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, emessage: MFT_MESSAGE_TYPE, ulparam: usize) -> ::windows::core::HRESULT,
    pub ProcessOutput: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwflags: u32, coutputbuffercount: u32, poutputsample: *mut MFT_OUTPUT_DATA_BUFFER, pdwstatus: *mut u32) -> ::windows::core::HRESULT,
    pub SetInputStreamState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamid: u32, pmediatype: *mut ::core::ffi::c_void, value: DeviceStreamState, dwflags: u32) -> ::windows::core::HRESULT,
    pub GetInputStreamState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamid: u32, value: *mut DeviceStreamState) -> ::windows::core::HRESULT,
    pub SetOutputStreamState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamid: u32, pmediatype: *mut ::core::ffi::c_void, value: DeviceStreamState, dwflags: u32) -> ::windows::core::HRESULT,
    pub GetOutputStreamState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamid: u32, value: *mut DeviceStreamState) -> ::windows::core::HRESULT,
    pub GetInputStreamPreferredState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamid: u32, value: *mut DeviceStreamState, ppmediatype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub FlushInputStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, dwflags: u32) -> ::windows::core::HRESULT,
    pub FlushOutputStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, dwflags: u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFDeviceTransformCallback(::windows::core::IUnknown);
impl IMFDeviceTransformCallback {
    pub unsafe fn OnBufferSent<P0>(&self, pcallbackattributes: P0, pinid: u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).OnBufferSent)(::windows::core::Interface::as_raw(self), pcallbackattributes.into_param().abi(), pinid).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFDeviceTransformCallback, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFDeviceTransformCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFDeviceTransformCallback {}
impl ::core::fmt::Debug for IMFDeviceTransformCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFDeviceTransformCallback").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFDeviceTransformCallback {
    type Vtable = IMFDeviceTransformCallback_Vtbl;
}
impl ::core::clone::Clone for IMFDeviceTransformCallback {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFDeviceTransformCallback {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6d5cb646_29ec_41fb_8179_8c4c6d750811);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFDeviceTransformCallback_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub OnBufferSent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcallbackattributes: *mut ::core::ffi::c_void, pinid: u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFExtendedCameraControl(::windows::core::IUnknown);
impl IMFExtendedCameraControl {
    pub unsafe fn GetCapabilities(&self) -> u64 {
        (::windows::core::Interface::vtable(self).GetCapabilities)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetFlags(&self, ulflags: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetFlags)(::windows::core::Interface::as_raw(self), ulflags).ok()
    }
    pub unsafe fn GetFlags(&self) -> u64 {
        (::windows::core::Interface::vtable(self).GetFlags)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn LockPayload(&self, pppayload: *mut *mut u8, pulpayload: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).LockPayload)(::windows::core::Interface::as_raw(self), pppayload, pulpayload).ok()
    }
    pub unsafe fn UnlockPayload(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).UnlockPayload)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn CommitSettings(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).CommitSettings)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFExtendedCameraControl, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFExtendedCameraControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFExtendedCameraControl {}
impl ::core::fmt::Debug for IMFExtendedCameraControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFExtendedCameraControl").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFExtendedCameraControl {
    type Vtable = IMFExtendedCameraControl_Vtbl;
}
impl ::core::clone::Clone for IMFExtendedCameraControl {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFExtendedCameraControl {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x38e33520_fca1_4845_a27a_68b7c6ab3789);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFExtendedCameraControl_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetCapabilities: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u64,
    pub SetFlags: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ulflags: u64) -> ::windows::core::HRESULT,
    pub GetFlags: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u64,
    pub LockPayload: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pppayload: *mut *mut u8, pulpayload: *mut u32) -> ::windows::core::HRESULT,
    pub UnlockPayload: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub CommitSettings: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFExtendedCameraController(::windows::core::IUnknown);
impl IMFExtendedCameraController {
    pub unsafe fn GetExtendedCameraControl(&self, dwstreamindex: u32, ulpropertyid: u32) -> ::windows::core::Result<IMFExtendedCameraControl> {
        let mut result__ = ::windows::core::zeroed::<IMFExtendedCameraControl>();
        (::windows::core::Interface::vtable(self).GetExtendedCameraControl)(::windows::core::Interface::as_raw(self), dwstreamindex, ulpropertyid, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFExtendedCameraController, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFExtendedCameraController {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFExtendedCameraController {}
impl ::core::fmt::Debug for IMFExtendedCameraController {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFExtendedCameraController").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFExtendedCameraController {
    type Vtable = IMFExtendedCameraController_Vtbl;
}
impl ::core::clone::Clone for IMFExtendedCameraController {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFExtendedCameraController {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb91ebfee_ca03_4af4_8a82_a31752f4a0fc);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFExtendedCameraController_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetExtendedCameraControl: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, ulpropertyid: u32, ppcontrol: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFExtendedCameraIntrinsicModel(::windows::core::IUnknown);
impl IMFExtendedCameraIntrinsicModel {
    pub unsafe fn GetModel(&self, pintrinsicmodel: *mut MFExtendedCameraIntrinsic_IntrinsicModel) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetModel)(::windows::core::Interface::as_raw(self), pintrinsicmodel).ok()
    }
    pub unsafe fn SetModel(&self, pintrinsicmodel: *const MFExtendedCameraIntrinsic_IntrinsicModel) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetModel)(::windows::core::Interface::as_raw(self), pintrinsicmodel).ok()
    }
    pub unsafe fn GetDistortionModelType(&self) -> ::windows::core::Result<MFCameraIntrinsic_DistortionModelType> {
        let mut result__ = ::windows::core::zeroed::<MFCameraIntrinsic_DistortionModelType>();
        (::windows::core::Interface::vtable(self).GetDistortionModelType)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFExtendedCameraIntrinsicModel, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFExtendedCameraIntrinsicModel {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFExtendedCameraIntrinsicModel {}
impl ::core::fmt::Debug for IMFExtendedCameraIntrinsicModel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFExtendedCameraIntrinsicModel").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFExtendedCameraIntrinsicModel {
    type Vtable = IMFExtendedCameraIntrinsicModel_Vtbl;
}
impl ::core::clone::Clone for IMFExtendedCameraIntrinsicModel {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFExtendedCameraIntrinsicModel {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5c595e64_4630_4231_855a_12842f733245);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFExtendedCameraIntrinsicModel_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetModel: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pintrinsicmodel: *mut MFExtendedCameraIntrinsic_IntrinsicModel) -> ::windows::core::HRESULT,
    pub SetModel: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pintrinsicmodel: *const MFExtendedCameraIntrinsic_IntrinsicModel) -> ::windows::core::HRESULT,
    pub GetDistortionModelType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdistortionmodeltype: *mut MFCameraIntrinsic_DistortionModelType) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFExtendedCameraIntrinsics(::windows::core::IUnknown);
impl IMFExtendedCameraIntrinsics {
    pub unsafe fn InitializeFromBuffer(&self, pbbuffer: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).InitializeFromBuffer)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pbbuffer.as_ptr()), pbbuffer.len() as _).ok()
    }
    pub unsafe fn GetBufferSize(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetBufferSize)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SerializeToBuffer(&self, pbbuffer: *mut u8, pdwbuffersize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SerializeToBuffer)(::windows::core::Interface::as_raw(self), pbbuffer, pdwbuffersize).ok()
    }
    pub unsafe fn GetIntrinsicModelCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetIntrinsicModelCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetIntrinsicModelByIndex(&self, dwindex: u32) -> ::windows::core::Result<IMFExtendedCameraIntrinsicModel> {
        let mut result__ = ::windows::core::zeroed::<IMFExtendedCameraIntrinsicModel>();
        (::windows::core::Interface::vtable(self).GetIntrinsicModelByIndex)(::windows::core::Interface::as_raw(self), dwindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn AddIntrinsicModel<P0>(&self, pintrinsicmodel: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFExtendedCameraIntrinsicModel>,
    {
        (::windows::core::Interface::vtable(self).AddIntrinsicModel)(::windows::core::Interface::as_raw(self), pintrinsicmodel.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFExtendedCameraIntrinsics, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFExtendedCameraIntrinsics {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFExtendedCameraIntrinsics {}
impl ::core::fmt::Debug for IMFExtendedCameraIntrinsics {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFExtendedCameraIntrinsics").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFExtendedCameraIntrinsics {
    type Vtable = IMFExtendedCameraIntrinsics_Vtbl;
}
impl ::core::clone::Clone for IMFExtendedCameraIntrinsics {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFExtendedCameraIntrinsics {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x687f6dac_6987_4750_a16a_734d1e7a10fe);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFExtendedCameraIntrinsics_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub InitializeFromBuffer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbbuffer: *const u8, dwbuffersize: u32) -> ::windows::core::HRESULT,
    pub GetBufferSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwbuffersize: *mut u32) -> ::windows::core::HRESULT,
    pub SerializeToBuffer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbbuffer: *mut u8, pdwbuffersize: *mut u32) -> ::windows::core::HRESULT,
    pub GetIntrinsicModelCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwcount: *mut u32) -> ::windows::core::HRESULT,
    pub GetIntrinsicModelByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwindex: u32, ppintrinsicmodel: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub AddIntrinsicModel: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pintrinsicmodel: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFExtendedCameraIntrinsicsDistortionModel6KT(::windows::core::IUnknown);
impl IMFExtendedCameraIntrinsicsDistortionModel6KT {
    pub unsafe fn GetDistortionModel(&self, pdistortionmodel: *mut MFCameraIntrinsic_DistortionModel6KT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDistortionModel)(::windows::core::Interface::as_raw(self), pdistortionmodel).ok()
    }
    pub unsafe fn SetDistortionModel(&self, pdistortionmodel: *const MFCameraIntrinsic_DistortionModel6KT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetDistortionModel)(::windows::core::Interface::as_raw(self), pdistortionmodel).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFExtendedCameraIntrinsicsDistortionModel6KT, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFExtendedCameraIntrinsicsDistortionModel6KT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFExtendedCameraIntrinsicsDistortionModel6KT {}
impl ::core::fmt::Debug for IMFExtendedCameraIntrinsicsDistortionModel6KT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFExtendedCameraIntrinsicsDistortionModel6KT").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFExtendedCameraIntrinsicsDistortionModel6KT {
    type Vtable = IMFExtendedCameraIntrinsicsDistortionModel6KT_Vtbl;
}
impl ::core::clone::Clone for IMFExtendedCameraIntrinsicsDistortionModel6KT {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFExtendedCameraIntrinsicsDistortionModel6KT {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x74c2653b_5f55_4eb1_9f0f_18b8f68b7d3d);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFExtendedCameraIntrinsicsDistortionModel6KT_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetDistortionModel: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdistortionmodel: *mut MFCameraIntrinsic_DistortionModel6KT) -> ::windows::core::HRESULT,
    pub SetDistortionModel: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdistortionmodel: *const MFCameraIntrinsic_DistortionModel6KT) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFExtendedCameraIntrinsicsDistortionModelArcTan(::windows::core::IUnknown);
impl IMFExtendedCameraIntrinsicsDistortionModelArcTan {
    pub unsafe fn GetDistortionModel(&self, pdistortionmodel: *mut MFCameraIntrinsic_DistortionModelArcTan) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDistortionModel)(::windows::core::Interface::as_raw(self), pdistortionmodel).ok()
    }
    pub unsafe fn SetDistortionModel(&self, pdistortionmodel: *const MFCameraIntrinsic_DistortionModelArcTan) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetDistortionModel)(::windows::core::Interface::as_raw(self), pdistortionmodel).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFExtendedCameraIntrinsicsDistortionModelArcTan, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFExtendedCameraIntrinsicsDistortionModelArcTan {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFExtendedCameraIntrinsicsDistortionModelArcTan {}
impl ::core::fmt::Debug for IMFExtendedCameraIntrinsicsDistortionModelArcTan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFExtendedCameraIntrinsicsDistortionModelArcTan").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFExtendedCameraIntrinsicsDistortionModelArcTan {
    type Vtable = IMFExtendedCameraIntrinsicsDistortionModelArcTan_Vtbl;
}
impl ::core::clone::Clone for IMFExtendedCameraIntrinsicsDistortionModelArcTan {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFExtendedCameraIntrinsicsDistortionModelArcTan {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x812d5f95_b572_45dc_bafc_ae24199ddda8);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFExtendedCameraIntrinsicsDistortionModelArcTan_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetDistortionModel: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdistortionmodel: *mut MFCameraIntrinsic_DistortionModelArcTan) -> ::windows::core::HRESULT,
    pub SetDistortionModel: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdistortionmodel: *const MFCameraIntrinsic_DistortionModelArcTan) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFExtendedDRMTypeSupport(::windows::core::IUnknown);
impl IMFExtendedDRMTypeSupport {
    pub unsafe fn IsTypeSupportedEx<P0, P1>(&self, r#type: P0, keysystem: P1) -> ::windows::core::Result<MF_MEDIA_ENGINE_CANPLAY>
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
        P1: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<MF_MEDIA_ENGINE_CANPLAY>();
        (::windows::core::Interface::vtable(self).IsTypeSupportedEx)(::windows::core::Interface::as_raw(self), r#type.into_param().abi(), keysystem.into_param().abi(), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFExtendedDRMTypeSupport, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFExtendedDRMTypeSupport {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFExtendedDRMTypeSupport {}
impl ::core::fmt::Debug for IMFExtendedDRMTypeSupport {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFExtendedDRMTypeSupport").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFExtendedDRMTypeSupport {
    type Vtable = IMFExtendedDRMTypeSupport_Vtbl;
}
impl ::core::clone::Clone for IMFExtendedDRMTypeSupport {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFExtendedDRMTypeSupport {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x332ec562_3758_468d_a784_e38f23552128);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFExtendedDRMTypeSupport_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub IsTypeSupportedEx: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, r#type: ::std::mem::MaybeUninit<::windows::core::BSTR>, keysystem: ::std::mem::MaybeUninit<::windows::core::BSTR>, panswer: *mut MF_MEDIA_ENGINE_CANPLAY) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFFieldOfUseMFTUnlock(::windows::core::IUnknown);
impl IMFFieldOfUseMFTUnlock {
    pub unsafe fn Unlock<P0>(&self, punkmft: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).Unlock)(::windows::core::Interface::as_raw(self), punkmft.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFFieldOfUseMFTUnlock, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFFieldOfUseMFTUnlock {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFFieldOfUseMFTUnlock {}
impl ::core::fmt::Debug for IMFFieldOfUseMFTUnlock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFFieldOfUseMFTUnlock").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFFieldOfUseMFTUnlock {
    type Vtable = IMFFieldOfUseMFTUnlock_Vtbl;
}
impl ::core::clone::Clone for IMFFieldOfUseMFTUnlock {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFFieldOfUseMFTUnlock {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x508e71d3_ec66_4fc3_8775_b4b9ed6ba847);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFFieldOfUseMFTUnlock_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub Unlock: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, punkmft: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFFinalizableMediaSink(::windows::core::IUnknown);
impl IMFFinalizableMediaSink {
    pub unsafe fn GetCharacteristics(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetCharacteristics)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn AddStreamSink<P0>(&self, dwstreamsinkidentifier: u32, pmediatype: P0) -> ::windows::core::Result<IMFStreamSink>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFStreamSink>();
        (::windows::core::Interface::vtable(self).base__.AddStreamSink)(::windows::core::Interface::as_raw(self), dwstreamsinkidentifier, pmediatype.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn RemoveStreamSink(&self, dwstreamsinkidentifier: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.RemoveStreamSink)(::windows::core::Interface::as_raw(self), dwstreamsinkidentifier).ok()
    }
    pub unsafe fn GetStreamSinkCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetStreamSinkCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStreamSinkByIndex(&self, dwindex: u32) -> ::windows::core::Result<IMFStreamSink> {
        let mut result__ = ::windows::core::zeroed::<IMFStreamSink>();
        (::windows::core::Interface::vtable(self).base__.GetStreamSinkByIndex)(::windows::core::Interface::as_raw(self), dwindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStreamSinkById(&self, dwstreamsinkidentifier: u32) -> ::windows::core::Result<IMFStreamSink> {
        let mut result__ = ::windows::core::zeroed::<IMFStreamSink>();
        (::windows::core::Interface::vtable(self).base__.GetStreamSinkById)(::windows::core::Interface::as_raw(self), dwstreamsinkidentifier, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetPresentationClock<P0>(&self, ppresentationclock: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFPresentationClock>,
    {
        (::windows::core::Interface::vtable(self).base__.SetPresentationClock)(::windows::core::Interface::as_raw(self), ppresentationclock.into_param().abi()).ok()
    }
    pub unsafe fn GetPresentationClock(&self) -> ::windows::core::Result<IMFPresentationClock> {
        let mut result__ = ::windows::core::zeroed::<IMFPresentationClock>();
        (::windows::core::Interface::vtable(self).base__.GetPresentationClock)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn Shutdown(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Shutdown)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn BeginFinalize<P0, P1>(&self, pcallback: P0, punkstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginFinalize)(::windows::core::Interface::as_raw(self), pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    pub unsafe fn EndFinalize<P0>(&self, presult: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        (::windows::core::Interface::vtable(self).EndFinalize)(::windows::core::Interface::as_raw(self), presult.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFFinalizableMediaSink, ::windows::core::IUnknown, IMFMediaSink);
impl ::core::cmp::PartialEq for IMFFinalizableMediaSink {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFFinalizableMediaSink {}
impl ::core::fmt::Debug for IMFFinalizableMediaSink {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFFinalizableMediaSink").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFFinalizableMediaSink {
    type Vtable = IMFFinalizableMediaSink_Vtbl;
}
impl ::core::clone::Clone for IMFFinalizableMediaSink {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFFinalizableMediaSink {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xeaecb74a_9a50_42ce_9541_6a7f57aa4ad7);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFFinalizableMediaSink_Vtbl {
    pub base__: IMFMediaSink_Vtbl,
    pub BeginFinalize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcallback: *mut ::core::ffi::c_void, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub EndFinalize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFGetService(::windows::core::IUnknown);
impl IMFGetService {
    pub unsafe fn GetService<T>(&self, guidservice: *const ::windows::core::GUID) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).GetService)(::windows::core::Interface::as_raw(self), guidservice, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFGetService, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFGetService {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFGetService {}
impl ::core::fmt::Debug for IMFGetService {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFGetService").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFGetService {
    type Vtable = IMFGetService_Vtbl;
}
impl ::core::clone::Clone for IMFGetService {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFGetService {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfa993888_4383_415a_a930_dd472a8cf6f7);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFGetService_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetService: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFHDCPStatus(::windows::core::IUnknown);
impl IMFHDCPStatus {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Query(&self, pstatus: *mut MF_HDCP_STATUS, pfstatus: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Query)(::windows::core::Interface::as_raw(self), pstatus, pfstatus).ok()
    }
    pub unsafe fn Set(&self, status: MF_HDCP_STATUS) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Set)(::windows::core::Interface::as_raw(self), status).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFHDCPStatus, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFHDCPStatus {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFHDCPStatus {}
impl ::core::fmt::Debug for IMFHDCPStatus {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFHDCPStatus").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFHDCPStatus {
    type Vtable = IMFHDCPStatus_Vtbl;
}
impl ::core::clone::Clone for IMFHDCPStatus {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFHDCPStatus {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xde400f54_5bf1_40cf_8964_0bea136b1e3d);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFHDCPStatus_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub Query: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pstatus: *mut MF_HDCP_STATUS, pfstatus: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    Query: usize,
    pub Set: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, status: MF_HDCP_STATUS) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFHttpDownloadRequest(::windows::core::IUnknown);
impl IMFHttpDownloadRequest {
    pub unsafe fn AddHeader<P0>(&self, szheader: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).AddHeader)(::windows::core::Interface::as_raw(self), szheader.into_param().abi()).ok()
    }
    pub unsafe fn BeginSendRequest<P0, P1>(&self, pbpayload: ::core::option::Option<&[u8]>, pcallback: P0, punkstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginSendRequest)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pbpayload.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr())), pbpayload.as_deref().map_or(0, |slice| slice.len() as _), pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    pub unsafe fn EndSendRequest<P0>(&self, presult: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        (::windows::core::Interface::vtable(self).EndSendRequest)(::windows::core::Interface::as_raw(self), presult.into_param().abi()).ok()
    }
    pub unsafe fn BeginReceiveResponse<P0, P1>(&self, pcallback: P0, punkstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginReceiveResponse)(::windows::core::Interface::as_raw(self), pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    pub unsafe fn EndReceiveResponse<P0>(&self, presult: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        (::windows::core::Interface::vtable(self).EndReceiveResponse)(::windows::core::Interface::as_raw(self), presult.into_param().abi()).ok()
    }
    pub unsafe fn BeginReadPayload<P0, P1>(&self, pb: &mut [u8], pcallback: P0, punkstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginReadPayload)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pb.as_ptr()), pb.len() as _, pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    pub unsafe fn EndReadPayload<P0>(&self, presult: P0, pqwoffset: *mut u64, pcbread: *mut u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        (::windows::core::Interface::vtable(self).EndReadPayload)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), pqwoffset, pcbread).ok()
    }
    pub unsafe fn QueryHeader<P0>(&self, szheadername: P0, dwindex: u32) -> ::windows::core::Result<::windows::core::PWSTR>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::core::PWSTR>();
        (::windows::core::Interface::vtable(self).QueryHeader)(::windows::core::Interface::as_raw(self), szheadername.into_param().abi(), dwindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetURL(&self) -> ::windows::core::Result<::windows::core::PWSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::PWSTR>();
        (::windows::core::Interface::vtable(self).GetURL)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn HasNullSourceOrigin(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).HasNullSourceOrigin)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetTimeSeekResult(&self, pqwstarttime: *mut u64, pqwstoptime: *mut u64, pqwduration: *mut u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetTimeSeekResult)(::windows::core::Interface::as_raw(self), pqwstarttime, pqwstoptime, pqwduration).ok()
    }
    pub unsafe fn GetHttpStatus(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetHttpStatus)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetAtEndOfPayload(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).GetAtEndOfPayload)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetTotalLength(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).GetTotalLength)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetRangeEndOffset(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).GetRangeEndOffset)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Close)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFHttpDownloadRequest, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFHttpDownloadRequest {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFHttpDownloadRequest {}
impl ::core::fmt::Debug for IMFHttpDownloadRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFHttpDownloadRequest").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFHttpDownloadRequest {
    type Vtable = IMFHttpDownloadRequest_Vtbl;
}
impl ::core::clone::Clone for IMFHttpDownloadRequest {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFHttpDownloadRequest {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf779fddf_26e7_4270_8a8b_b983d1859de0);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFHttpDownloadRequest_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub AddHeader: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, szheader: ::windows::core::PCWSTR) -> ::windows::core::HRESULT,
    pub BeginSendRequest: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbpayload: *const u8, cbpayload: u32, pcallback: *mut ::core::ffi::c_void, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub EndSendRequest: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub BeginReceiveResponse: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcallback: *mut ::core::ffi::c_void, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub EndReceiveResponse: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub BeginReadPayload: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pb: *mut u8, cb: u32, pcallback: *mut ::core::ffi::c_void, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub EndReadPayload: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void, pqwoffset: *mut u64, pcbread: *mut u32) -> ::windows::core::HRESULT,
    pub QueryHeader: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, szheadername: ::windows::core::PCWSTR, dwindex: u32, ppszheadervalue: *mut ::windows::core::PWSTR) -> ::windows::core::HRESULT,
    pub GetURL: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppszurl: *mut ::windows::core::PWSTR) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub HasNullSourceOrigin: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pfnullsourceorigin: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    HasNullSourceOrigin: usize,
    pub GetTimeSeekResult: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pqwstarttime: *mut u64, pqwstoptime: *mut u64, pqwduration: *mut u64) -> ::windows::core::HRESULT,
    pub GetHttpStatus: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwhttpstatus: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub GetAtEndOfPayload: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pfatendofpayload: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetAtEndOfPayload: usize,
    pub GetTotalLength: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pqwtotallength: *mut u64) -> ::windows::core::HRESULT,
    pub GetRangeEndOffset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pqwrangeend: *mut u64) -> ::windows::core::HRESULT,
    pub Close: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFHttpDownloadSession(::windows::core::IUnknown);
impl IMFHttpDownloadSession {
    pub unsafe fn SetServer<P0>(&self, szservername: P0, nport: u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).SetServer)(::windows::core::Interface::as_raw(self), szservername.into_param().abi(), nport).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn CreateRequest<P0, P1, P2, P3, P4>(&self, szobjectname: P0, fbypassproxycache: P1, fsecure: P2, szverb: P3, szreferrer: P4) -> ::windows::core::Result<IMFHttpDownloadRequest>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P1: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
        P2: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
        P3: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P4: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFHttpDownloadRequest>();
        (::windows::core::Interface::vtable(self).CreateRequest)(::windows::core::Interface::as_raw(self), szobjectname.into_param().abi(), fbypassproxycache.into_param().abi(), fsecure.into_param().abi(), szverb.into_param().abi(), szreferrer.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Close)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFHttpDownloadSession, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFHttpDownloadSession {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFHttpDownloadSession {}
impl ::core::fmt::Debug for IMFHttpDownloadSession {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFHttpDownloadSession").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFHttpDownloadSession {
    type Vtable = IMFHttpDownloadSession_Vtbl;
}
impl ::core::clone::Clone for IMFHttpDownloadSession {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFHttpDownloadSession {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x71fa9a2c_53ce_4662_a132_1a7e8cbf62db);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFHttpDownloadSession_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetServer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, szservername: ::windows::core::PCWSTR, nport: u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub CreateRequest: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, szobjectname: ::windows::core::PCWSTR, fbypassproxycache: super::super::Foundation::BOOL, fsecure: super::super::Foundation::BOOL, szverb: ::windows::core::PCWSTR, szreferrer: ::windows::core::PCWSTR, pprequest: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    CreateRequest: usize,
    pub Close: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFHttpDownloadSessionProvider(::windows::core::IUnknown);
impl IMFHttpDownloadSessionProvider {
    pub unsafe fn CreateHttpDownloadSession<P0>(&self, wszscheme: P0) -> ::windows::core::Result<IMFHttpDownloadSession>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFHttpDownloadSession>();
        (::windows::core::Interface::vtable(self).CreateHttpDownloadSession)(::windows::core::Interface::as_raw(self), wszscheme.into_param().abi(), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFHttpDownloadSessionProvider, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFHttpDownloadSessionProvider {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFHttpDownloadSessionProvider {}
impl ::core::fmt::Debug for IMFHttpDownloadSessionProvider {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFHttpDownloadSessionProvider").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFHttpDownloadSessionProvider {
    type Vtable = IMFHttpDownloadSessionProvider_Vtbl;
}
impl ::core::clone::Clone for IMFHttpDownloadSessionProvider {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFHttpDownloadSessionProvider {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b4cf4b9_3a16_4115_839d_03cc5c99df01);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFHttpDownloadSessionProvider_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub CreateHttpDownloadSession: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, wszscheme: ::windows::core::PCWSTR, ppdownloadsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFImageSharingEngine(::windows::core::IUnknown);
impl IMFImageSharingEngine {
    pub unsafe fn SetSource<P0>(&self, pstream: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).SetSource)(::windows::core::Interface::as_raw(self), pstream.into_param().abi()).ok()
    }
    pub unsafe fn GetDevice(&self, pdevice: *mut DEVICE_INFO) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDevice)(::windows::core::Interface::as_raw(self), pdevice).ok()
    }
    pub unsafe fn Shutdown(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Shutdown)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFImageSharingEngine, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFImageSharingEngine {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFImageSharingEngine {}
impl ::core::fmt::Debug for IMFImageSharingEngine {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFImageSharingEngine").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFImageSharingEngine {
    type Vtable = IMFImageSharingEngine_Vtbl;
}
impl ::core::clone::Clone for IMFImageSharingEngine {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFImageSharingEngine {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xcfa0ae8e_7e1c_44d2_ae68_fc4c148a6354);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFImageSharingEngine_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetSource: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pstream: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetDevice: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdevice: *mut DEVICE_INFO) -> ::windows::core::HRESULT,
    pub Shutdown: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFImageSharingEngineClassFactory(::windows::core::IUnknown);
impl IMFImageSharingEngineClassFactory {
    pub unsafe fn CreateInstanceFromUDN<P0>(&self, puniquedevicename: P0) -> ::windows::core::Result<IMFImageSharingEngine>
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFImageSharingEngine>();
        (::windows::core::Interface::vtable(self).CreateInstanceFromUDN)(::windows::core::Interface::as_raw(self), puniquedevicename.into_param().abi(), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFImageSharingEngineClassFactory, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFImageSharingEngineClassFactory {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFImageSharingEngineClassFactory {}
impl ::core::fmt::Debug for IMFImageSharingEngineClassFactory {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFImageSharingEngineClassFactory").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFImageSharingEngineClassFactory {
    type Vtable = IMFImageSharingEngineClassFactory_Vtbl;
}
impl ::core::clone::Clone for IMFImageSharingEngineClassFactory {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFImageSharingEngineClassFactory {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1fc55727_a7fb_4fc8_83ae_8af024990af1);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFImageSharingEngineClassFactory_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub CreateInstanceFromUDN: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, puniquedevicename: ::std::mem::MaybeUninit<::windows::core::BSTR>, ppengine: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFInputTrustAuthority(::windows::core::IUnknown);
impl IMFInputTrustAuthority {
    pub unsafe fn GetDecrypter(&self, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDecrypter)(::windows::core::Interface::as_raw(self), riid, ppv).ok()
    }
    pub unsafe fn RequestAccess(&self, action: MFPOLICYMANAGER_ACTION) -> ::windows::core::Result<IMFActivate> {
        let mut result__ = ::windows::core::zeroed::<IMFActivate>();
        (::windows::core::Interface::vtable(self).RequestAccess)(::windows::core::Interface::as_raw(self), action, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetPolicy(&self, action: MFPOLICYMANAGER_ACTION) -> ::windows::core::Result<IMFOutputPolicy> {
        let mut result__ = ::windows::core::zeroed::<IMFOutputPolicy>();
        (::windows::core::Interface::vtable(self).GetPolicy)(::windows::core::Interface::as_raw(self), action, &mut result__).from_abi(result__)
    }
    pub unsafe fn BindAccess(&self, pparam: *const MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).BindAccess)(::windows::core::Interface::as_raw(self), pparam).ok()
    }
    pub unsafe fn UpdateAccess(&self, pparam: *const MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).UpdateAccess)(::windows::core::Interface::as_raw(self), pparam).ok()
    }
    pub unsafe fn Reset(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Reset)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFInputTrustAuthority, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFInputTrustAuthority {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFInputTrustAuthority {}
impl ::core::fmt::Debug for IMFInputTrustAuthority {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFInputTrustAuthority").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFInputTrustAuthority {
    type Vtable = IMFInputTrustAuthority_Vtbl;
}
impl ::core::clone::Clone for IMFInputTrustAuthority {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFInputTrustAuthority {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd19f8e98_b126_4446_890c_5dcb7ad71453);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFInputTrustAuthority_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetDecrypter: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RequestAccess: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, action: MFPOLICYMANAGER_ACTION, ppcontentenableractivate: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetPolicy: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, action: MFPOLICYMANAGER_ACTION, pppolicy: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub BindAccess: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pparam: *const MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS) -> ::windows::core::HRESULT,
    pub UpdateAccess: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pparam: *const MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS) -> ::windows::core::HRESULT,
    pub Reset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFLocalMFTRegistration(::windows::core::IUnknown);
impl IMFLocalMFTRegistration {
    pub unsafe fn RegisterMFTs(&self, pmfts: &[MFT_REGISTRATION_INFO]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RegisterMFTs)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pmfts.as_ptr()), pmfts.len() as _).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFLocalMFTRegistration, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFLocalMFTRegistration {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFLocalMFTRegistration {}
impl ::core::fmt::Debug for IMFLocalMFTRegistration {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFLocalMFTRegistration").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFLocalMFTRegistration {
    type Vtable = IMFLocalMFTRegistration_Vtbl;
}
impl ::core::clone::Clone for IMFLocalMFTRegistration {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFLocalMFTRegistration {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x149c4d73_b4be_4f8d_8b87_079e926b6add);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFLocalMFTRegistration_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub RegisterMFTs: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pmfts: *const MFT_REGISTRATION_INFO, cmfts: u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaBuffer(::windows::core::IUnknown);
impl IMFMediaBuffer {
    pub unsafe fn Lock(&self, ppbbuffer: *mut *mut u8, pcbmaxlength: ::core::option::Option<*mut u32>, pcbcurrentlength: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Lock)(::windows::core::Interface::as_raw(self), ppbbuffer, ::core::mem::transmute(pcbmaxlength.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(pcbcurrentlength.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn Unlock(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Unlock)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetCurrentLength(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetCurrentLength)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetCurrentLength(&self, cbcurrentlength: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetCurrentLength)(::windows::core::Interface::as_raw(self), cbcurrentlength).ok()
    }
    pub unsafe fn GetMaxLength(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetMaxLength)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFMediaBuffer, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaBuffer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaBuffer {}
impl ::core::fmt::Debug for IMFMediaBuffer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaBuffer").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaBuffer {
    type Vtable = IMFMediaBuffer_Vtbl;
}
impl ::core::clone::Clone for IMFMediaBuffer {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaBuffer {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x045fa593_8799_42b8_bc8d_8968c6453507);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaBuffer_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub Lock: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppbbuffer: *mut *mut u8, pcbmaxlength: *mut u32, pcbcurrentlength: *mut u32) -> ::windows::core::HRESULT,
    pub Unlock: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetCurrentLength: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcbcurrentlength: *mut u32) -> ::windows::core::HRESULT,
    pub SetCurrentLength: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cbcurrentlength: u32) -> ::windows::core::HRESULT,
    pub GetMaxLength: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcbmaxlength: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaEngine(::windows::core::IUnknown);
impl IMFMediaEngine {
    pub unsafe fn GetError(&self) -> ::windows::core::Result<IMFMediaError> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaError>();
        (::windows::core::Interface::vtable(self).GetError)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetErrorCode(&self, error: MF_MEDIA_ENGINE_ERR) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetErrorCode)(::windows::core::Interface::as_raw(self), error).ok()
    }
    pub unsafe fn SetSourceElements<P0>(&self, psrcelements: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaEngineSrcElements>,
    {
        (::windows::core::Interface::vtable(self).SetSourceElements)(::windows::core::Interface::as_raw(self), psrcelements.into_param().abi()).ok()
    }
    pub unsafe fn SetSource<P0>(&self, purl: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        (::windows::core::Interface::vtable(self).SetSource)(::windows::core::Interface::as_raw(self), purl.into_param().abi()).ok()
    }
    pub unsafe fn GetCurrentSource(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::BSTR>();
        (::windows::core::Interface::vtable(self).GetCurrentSource)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetNetworkState(&self) -> u16 {
        (::windows::core::Interface::vtable(self).GetNetworkState)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetPreload(&self) -> MF_MEDIA_ENGINE_PRELOAD {
        (::windows::core::Interface::vtable(self).GetPreload)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetPreload(&self, preload: MF_MEDIA_ENGINE_PRELOAD) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetPreload)(::windows::core::Interface::as_raw(self), preload).ok()
    }
    pub unsafe fn GetBuffered(&self) -> ::windows::core::Result<IMFMediaTimeRange> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaTimeRange>();
        (::windows::core::Interface::vtable(self).GetBuffered)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn Load(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Load)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn CanPlayType<P0>(&self, r#type: P0) -> ::windows::core::Result<MF_MEDIA_ENGINE_CANPLAY>
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<MF_MEDIA_ENGINE_CANPLAY>();
        (::windows::core::Interface::vtable(self).CanPlayType)(::windows::core::Interface::as_raw(self), r#type.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetReadyState(&self) -> u16 {
        (::windows::core::Interface::vtable(self).GetReadyState)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsSeeking(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).IsSeeking)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetCurrentTime(&self) -> f64 {
        (::windows::core::Interface::vtable(self).GetCurrentTime)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetCurrentTime(&self, seektime: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetCurrentTime)(::windows::core::Interface::as_raw(self), seektime).ok()
    }
    pub unsafe fn GetStartTime(&self) -> f64 {
        (::windows::core::Interface::vtable(self).GetStartTime)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetDuration(&self) -> f64 {
        (::windows::core::Interface::vtable(self).GetDuration)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsPaused(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).IsPaused)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetDefaultPlaybackRate(&self) -> f64 {
        (::windows::core::Interface::vtable(self).GetDefaultPlaybackRate)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetDefaultPlaybackRate(&self, rate: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetDefaultPlaybackRate)(::windows::core::Interface::as_raw(self), rate).ok()
    }
    pub unsafe fn GetPlaybackRate(&self) -> f64 {
        (::windows::core::Interface::vtable(self).GetPlaybackRate)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetPlaybackRate(&self, rate: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetPlaybackRate)(::windows::core::Interface::as_raw(self), rate).ok()
    }
    pub unsafe fn GetPlayed(&self) -> ::windows::core::Result<IMFMediaTimeRange> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaTimeRange>();
        (::windows::core::Interface::vtable(self).GetPlayed)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetSeekable(&self) -> ::windows::core::Result<IMFMediaTimeRange> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaTimeRange>();
        (::windows::core::Interface::vtable(self).GetSeekable)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsEnded(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).IsEnded)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetAutoPlay(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).GetAutoPlay)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetAutoPlay<P0>(&self, autoplay: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetAutoPlay)(::windows::core::Interface::as_raw(self), autoplay.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetLoop(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).GetLoop)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetLoop<P0>(&self, r#loop: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetLoop)(::windows::core::Interface::as_raw(self), r#loop.into_param().abi()).ok()
    }
    pub unsafe fn Play(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Play)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Pause(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Pause)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetMuted(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).GetMuted)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetMuted<P0>(&self, muted: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetMuted)(::windows::core::Interface::as_raw(self), muted.into_param().abi()).ok()
    }
    pub unsafe fn GetVolume(&self) -> f64 {
        (::windows::core::Interface::vtable(self).GetVolume)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetVolume(&self, volume: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetVolume)(::windows::core::Interface::as_raw(self), volume).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn HasVideo(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).HasVideo)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn HasAudio(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).HasAudio)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetNativeVideoSize(&self, cx: ::core::option::Option<*mut u32>, cy: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetNativeVideoSize)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(cx.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(cy.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetVideoAspectRatio(&self, cx: ::core::option::Option<*mut u32>, cy: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetVideoAspectRatio)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(cx.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(cy.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn Shutdown(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Shutdown)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn TransferVideoFrame<P0>(&self, pdstsurf: P0, psrc: ::core::option::Option<*const MFVideoNormalizedRect>, pdst: *const super::super::Foundation::RECT, pborderclr: ::core::option::Option<*const MFARGB>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).TransferVideoFrame)(::windows::core::Interface::as_raw(self), pdstsurf.into_param().abi(), ::core::mem::transmute(psrc.unwrap_or(::std::ptr::null())), pdst, ::core::mem::transmute(pborderclr.unwrap_or(::std::ptr::null()))).ok()
    }
    pub unsafe fn OnVideoStreamTick(&self) -> ::windows::core::Result<i64> {
        let mut result__ = ::windows::core::zeroed::<i64>();
        (::windows::core::Interface::vtable(self).OnVideoStreamTick)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFMediaEngine, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaEngine {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaEngine {}
impl ::core::fmt::Debug for IMFMediaEngine {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaEngine").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaEngine {
    type Vtable = IMFMediaEngine_Vtbl;
}
impl ::core::clone::Clone for IMFMediaEngine {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaEngine {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x98a1b0bb_03eb_4935_ae7c_93c1fa0e1c93);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaEngine_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetError: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pperror: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetErrorCode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, error: MF_MEDIA_ENGINE_ERR) -> ::windows::core::HRESULT,
    pub SetSourceElements: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, psrcelements: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetSource: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, purl: ::std::mem::MaybeUninit<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub GetCurrentSource: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppurl: *mut ::std::mem::MaybeUninit<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub GetNetworkState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u16,
    pub GetPreload: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> MF_MEDIA_ENGINE_PRELOAD,
    pub SetPreload: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, preload: MF_MEDIA_ENGINE_PRELOAD) -> ::windows::core::HRESULT,
    pub GetBuffered: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppbuffered: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Load: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub CanPlayType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, r#type: ::std::mem::MaybeUninit<::windows::core::BSTR>, panswer: *mut MF_MEDIA_ENGINE_CANPLAY) -> ::windows::core::HRESULT,
    pub GetReadyState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u16,
    #[cfg(feature = "Win32_Foundation")]
    pub IsSeeking: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsSeeking: usize,
    pub GetCurrentTime: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> f64,
    pub SetCurrentTime: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, seektime: f64) -> ::windows::core::HRESULT,
    pub GetStartTime: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> f64,
    pub GetDuration: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> f64,
    #[cfg(feature = "Win32_Foundation")]
    pub IsPaused: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsPaused: usize,
    pub GetDefaultPlaybackRate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> f64,
    pub SetDefaultPlaybackRate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, rate: f64) -> ::windows::core::HRESULT,
    pub GetPlaybackRate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> f64,
    pub SetPlaybackRate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, rate: f64) -> ::windows::core::HRESULT,
    pub GetPlayed: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppplayed: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetSeekable: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppseekable: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub IsEnded: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsEnded: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub GetAutoPlay: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetAutoPlay: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub SetAutoPlay: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, autoplay: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetAutoPlay: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub GetLoop: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetLoop: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub SetLoop: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, r#loop: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetLoop: usize,
    pub Play: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Pause: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub GetMuted: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetMuted: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub SetMuted: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, muted: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetMuted: usize,
    pub GetVolume: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> f64,
    pub SetVolume: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, volume: f64) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub HasVideo: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL,
    #[cfg(not(feature = "Win32_Foundation"))]
    HasVideo: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub HasAudio: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL,
    #[cfg(not(feature = "Win32_Foundation"))]
    HasAudio: usize,
    pub GetNativeVideoSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cx: *mut u32, cy: *mut u32) -> ::windows::core::HRESULT,
    pub GetVideoAspectRatio: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cx: *mut u32, cy: *mut u32) -> ::windows::core::HRESULT,
    pub Shutdown: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub TransferVideoFrame: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdstsurf: *mut ::core::ffi::c_void, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const MFARGB) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    TransferVideoFrame: usize,
    pub OnVideoStreamTick: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppts: *mut i64) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaEngineAudioEndpointId(::windows::core::IUnknown);
impl IMFMediaEngineAudioEndpointId {
    pub unsafe fn SetAudioEndpointId<P0>(&self, pszendpointid: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).SetAudioEndpointId)(::windows::core::Interface::as_raw(self), pszendpointid.into_param().abi()).ok()
    }
    pub unsafe fn GetAudioEndpointId(&self) -> ::windows::core::Result<::windows::core::PWSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::PWSTR>();
        (::windows::core::Interface::vtable(self).GetAudioEndpointId)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFMediaEngineAudioEndpointId, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaEngineAudioEndpointId {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaEngineAudioEndpointId {}
impl ::core::fmt::Debug for IMFMediaEngineAudioEndpointId {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaEngineAudioEndpointId").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaEngineAudioEndpointId {
    type Vtable = IMFMediaEngineAudioEndpointId_Vtbl;
}
impl ::core::clone::Clone for IMFMediaEngineAudioEndpointId {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaEngineAudioEndpointId {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7a3bac98_0e76_49fb_8c20_8a86fd98eaf2);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaEngineAudioEndpointId_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetAudioEndpointId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pszendpointid: ::windows::core::PCWSTR) -> ::windows::core::HRESULT,
    pub GetAudioEndpointId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppszendpointid: *mut ::windows::core::PWSTR) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaEngineClassFactory(::windows::core::IUnknown);
impl IMFMediaEngineClassFactory {
    pub unsafe fn CreateInstance<P0>(&self, dwflags: u32, pattr: P0) -> ::windows::core::Result<IMFMediaEngine>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFMediaEngine>();
        (::windows::core::Interface::vtable(self).CreateInstance)(::windows::core::Interface::as_raw(self), dwflags, pattr.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn CreateTimeRange(&self) -> ::windows::core::Result<IMFMediaTimeRange> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaTimeRange>();
        (::windows::core::Interface::vtable(self).CreateTimeRange)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn CreateError(&self) -> ::windows::core::Result<IMFMediaError> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaError>();
        (::windows::core::Interface::vtable(self).CreateError)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFMediaEngineClassFactory, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaEngineClassFactory {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaEngineClassFactory {}
impl ::core::fmt::Debug for IMFMediaEngineClassFactory {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaEngineClassFactory").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaEngineClassFactory {
    type Vtable = IMFMediaEngineClassFactory_Vtbl;
}
impl ::core::clone::Clone for IMFMediaEngineClassFactory {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaEngineClassFactory {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4d645ace_26aa_4688_9be1_df3516990b93);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaEngineClassFactory_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub CreateInstance: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwflags: u32, pattr: *mut ::core::ffi::c_void, ppplayer: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub CreateTimeRange: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pptimerange: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub CreateError: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pperror: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaEngineClassFactory2(::windows::core::IUnknown);
impl IMFMediaEngineClassFactory2 {
    pub unsafe fn CreateMediaKeys2<P0, P1, P2>(&self, keysystem: P0, defaultcdmstorepath: P1, inprivatecdmstorepath: P2) -> ::windows::core::Result<IMFMediaKeys>
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
        P1: ::windows::core::IntoParam<::windows::core::BSTR>,
        P2: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFMediaKeys>();
        (::windows::core::Interface::vtable(self).CreateMediaKeys2)(::windows::core::Interface::as_raw(self), keysystem.into_param().abi(), defaultcdmstorepath.into_param().abi(), inprivatecdmstorepath.into_param().abi(), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFMediaEngineClassFactory2, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaEngineClassFactory2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaEngineClassFactory2 {}
impl ::core::fmt::Debug for IMFMediaEngineClassFactory2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaEngineClassFactory2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaEngineClassFactory2 {
    type Vtable = IMFMediaEngineClassFactory2_Vtbl;
}
impl ::core::clone::Clone for IMFMediaEngineClassFactory2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaEngineClassFactory2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x09083cef_867f_4bf6_8776_dee3a7b42fca);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaEngineClassFactory2_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub CreateMediaKeys2: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, keysystem: ::std::mem::MaybeUninit<::windows::core::BSTR>, defaultcdmstorepath: ::std::mem::MaybeUninit<::windows::core::BSTR>, inprivatecdmstorepath: ::std::mem::MaybeUninit<::windows::core::BSTR>, ppkeys: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaEngineClassFactory3(::windows::core::IUnknown);
impl IMFMediaEngineClassFactory3 {
    #[doc = "*Required features: `\"Win32_UI_Shell_PropertiesSystem\"`*"]
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub unsafe fn CreateMediaKeySystemAccess<P0>(&self, keysystem: P0, ppsupportedconfigurationsarray: &[::core::option::Option<super::super::UI::Shell::PropertiesSystem::IPropertyStore>]) -> ::windows::core::Result<IMFMediaKeySystemAccess>
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFMediaKeySystemAccess>();
        (::windows::core::Interface::vtable(self).CreateMediaKeySystemAccess)(::windows::core::Interface::as_raw(self), keysystem.into_param().abi(), ::core::mem::transmute(ppsupportedconfigurationsarray.as_ptr()), ppsupportedconfigurationsarray.len() as _, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFMediaEngineClassFactory3, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaEngineClassFactory3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaEngineClassFactory3 {}
impl ::core::fmt::Debug for IMFMediaEngineClassFactory3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaEngineClassFactory3").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaEngineClassFactory3 {
    type Vtable = IMFMediaEngineClassFactory3_Vtbl;
}
impl ::core::clone::Clone for IMFMediaEngineClassFactory3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaEngineClassFactory3 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3787614f_65f7_4003_b673_ead8293a0e60);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaEngineClassFactory3_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub CreateMediaKeySystemAccess: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, keysystem: ::std::mem::MaybeUninit<::windows::core::BSTR>, ppsupportedconfigurationsarray: *const *mut ::core::ffi::c_void, usize: u32, ppkeyaccess: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_UI_Shell_PropertiesSystem"))]
    CreateMediaKeySystemAccess: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaEngineClassFactory4(::windows::core::IUnknown);
impl IMFMediaEngineClassFactory4 {
    pub unsafe fn CreateContentDecryptionModuleFactory<P0>(&self, keysystem: P0, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).CreateContentDecryptionModuleFactory)(::windows::core::Interface::as_raw(self), keysystem.into_param().abi(), riid, ppvobject).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaEngineClassFactory4, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaEngineClassFactory4 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaEngineClassFactory4 {}
impl ::core::fmt::Debug for IMFMediaEngineClassFactory4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaEngineClassFactory4").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaEngineClassFactory4 {
    type Vtable = IMFMediaEngineClassFactory4_Vtbl;
}
impl ::core::clone::Clone for IMFMediaEngineClassFactory4 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaEngineClassFactory4 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfbe256c1_43cf_4a9b_8cb8_ce8632a34186);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaEngineClassFactory4_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub CreateContentDecryptionModuleFactory: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, keysystem: ::windows::core::PCWSTR, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaEngineClassFactoryEx(::windows::core::IUnknown);
impl IMFMediaEngineClassFactoryEx {
    pub unsafe fn CreateInstance<P0>(&self, dwflags: u32, pattr: P0) -> ::windows::core::Result<IMFMediaEngine>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFMediaEngine>();
        (::windows::core::Interface::vtable(self).base__.CreateInstance)(::windows::core::Interface::as_raw(self), dwflags, pattr.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn CreateTimeRange(&self) -> ::windows::core::Result<IMFMediaTimeRange> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaTimeRange>();
        (::windows::core::Interface::vtable(self).base__.CreateTimeRange)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn CreateError(&self) -> ::windows::core::Result<IMFMediaError> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaError>();
        (::windows::core::Interface::vtable(self).base__.CreateError)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn CreateMediaSourceExtension<P0>(&self, dwflags: u32, pattr: P0) -> ::windows::core::Result<IMFMediaSourceExtension>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFMediaSourceExtension>();
        (::windows::core::Interface::vtable(self).CreateMediaSourceExtension)(::windows::core::Interface::as_raw(self), dwflags, pattr.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn CreateMediaKeys<P0, P1>(&self, keysystem: P0, cdmstorepath: P1) -> ::windows::core::Result<IMFMediaKeys>
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
        P1: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFMediaKeys>();
        (::windows::core::Interface::vtable(self).CreateMediaKeys)(::windows::core::Interface::as_raw(self), keysystem.into_param().abi(), cdmstorepath.into_param().abi(), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsTypeSupported<P0, P1>(&self, r#type: P0, keysystem: P1) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
        P1: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).IsTypeSupported)(::windows::core::Interface::as_raw(self), r#type.into_param().abi(), keysystem.into_param().abi(), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFMediaEngineClassFactoryEx, ::windows::core::IUnknown, IMFMediaEngineClassFactory);
impl ::core::cmp::PartialEq for IMFMediaEngineClassFactoryEx {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaEngineClassFactoryEx {}
impl ::core::fmt::Debug for IMFMediaEngineClassFactoryEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaEngineClassFactoryEx").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaEngineClassFactoryEx {
    type Vtable = IMFMediaEngineClassFactoryEx_Vtbl;
}
impl ::core::clone::Clone for IMFMediaEngineClassFactoryEx {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaEngineClassFactoryEx {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc56156c6_ea5b_48a5_9df8_fbe035d0929e);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaEngineClassFactoryEx_Vtbl {
    pub base__: IMFMediaEngineClassFactory_Vtbl,
    pub CreateMediaSourceExtension: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwflags: u32, pattr: *mut ::core::ffi::c_void, ppmse: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub CreateMediaKeys: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, keysystem: ::std::mem::MaybeUninit<::windows::core::BSTR>, cdmstorepath: ::std::mem::MaybeUninit<::windows::core::BSTR>, ppkeys: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub IsTypeSupported: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, r#type: ::std::mem::MaybeUninit<::windows::core::BSTR>, keysystem: ::std::mem::MaybeUninit<::windows::core::BSTR>, issupported: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsTypeSupported: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaEngineEME(::windows::core::IUnknown);
impl IMFMediaEngineEME {
    pub unsafe fn Keys(&self) -> ::windows::core::Result<IMFMediaKeys> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaKeys>();
        (::windows::core::Interface::vtable(self).Keys)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetMediaKeys<P0>(&self, keys: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaKeys>,
    {
        (::windows::core::Interface::vtable(self).SetMediaKeys)(::windows::core::Interface::as_raw(self), keys.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaEngineEME, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaEngineEME {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaEngineEME {}
impl ::core::fmt::Debug for IMFMediaEngineEME {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaEngineEME").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaEngineEME {
    type Vtable = IMFMediaEngineEME_Vtbl;
}
impl ::core::clone::Clone for IMFMediaEngineEME {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaEngineEME {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x50dc93e4_ba4f_4275_ae66_83e836e57469);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaEngineEME_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub Keys: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, keys: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetMediaKeys: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, keys: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaEngineEMENotify(::windows::core::IUnknown);
impl IMFMediaEngineEMENotify {
    pub unsafe fn Encrypted<P0>(&self, pbinitdata: ::core::option::Option<&[u8]>, bstrinitdatatype: P0)
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        (::windows::core::Interface::vtable(self).Encrypted)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pbinitdata.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr())), pbinitdata.as_deref().map_or(0, |slice| slice.len() as _), bstrinitdatatype.into_param().abi())
    }
    pub unsafe fn WaitingForKey(&self) {
        (::windows::core::Interface::vtable(self).WaitingForKey)(::windows::core::Interface::as_raw(self))
    }
}
::windows::imp::interface_hierarchy!(IMFMediaEngineEMENotify, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaEngineEMENotify {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaEngineEMENotify {}
impl ::core::fmt::Debug for IMFMediaEngineEMENotify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaEngineEMENotify").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaEngineEMENotify {
    type Vtable = IMFMediaEngineEMENotify_Vtbl;
}
impl ::core::clone::Clone for IMFMediaEngineEMENotify {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaEngineEMENotify {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9e184d15_cdb7_4f86_b49e_566689f4a601);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaEngineEMENotify_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub Encrypted: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbinitdata: *const u8, cb: u32, bstrinitdatatype: ::std::mem::MaybeUninit<::windows::core::BSTR>),
    pub WaitingForKey: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaEngineEx(::windows::core::IUnknown);
impl IMFMediaEngineEx {
    pub unsafe fn GetError(&self) -> ::windows::core::Result<IMFMediaError> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaError>();
        (::windows::core::Interface::vtable(self).base__.GetError)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetErrorCode(&self, error: MF_MEDIA_ENGINE_ERR) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetErrorCode)(::windows::core::Interface::as_raw(self), error).ok()
    }
    pub unsafe fn SetSourceElements<P0>(&self, psrcelements: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaEngineSrcElements>,
    {
        (::windows::core::Interface::vtable(self).base__.SetSourceElements)(::windows::core::Interface::as_raw(self), psrcelements.into_param().abi()).ok()
    }
    pub unsafe fn SetSource<P0>(&self, purl: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.SetSource)(::windows::core::Interface::as_raw(self), purl.into_param().abi()).ok()
    }
    pub unsafe fn GetCurrentSource(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::BSTR>();
        (::windows::core::Interface::vtable(self).base__.GetCurrentSource)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetNetworkState(&self) -> u16 {
        (::windows::core::Interface::vtable(self).base__.GetNetworkState)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetPreload(&self) -> MF_MEDIA_ENGINE_PRELOAD {
        (::windows::core::Interface::vtable(self).base__.GetPreload)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetPreload(&self, preload: MF_MEDIA_ENGINE_PRELOAD) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetPreload)(::windows::core::Interface::as_raw(self), preload).ok()
    }
    pub unsafe fn GetBuffered(&self) -> ::windows::core::Result<IMFMediaTimeRange> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaTimeRange>();
        (::windows::core::Interface::vtable(self).base__.GetBuffered)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn Load(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Load)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn CanPlayType<P0>(&self, r#type: P0) -> ::windows::core::Result<MF_MEDIA_ENGINE_CANPLAY>
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<MF_MEDIA_ENGINE_CANPLAY>();
        (::windows::core::Interface::vtable(self).base__.CanPlayType)(::windows::core::Interface::as_raw(self), r#type.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetReadyState(&self) -> u16 {
        (::windows::core::Interface::vtable(self).base__.GetReadyState)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsSeeking(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).base__.IsSeeking)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetCurrentTime(&self) -> f64 {
        (::windows::core::Interface::vtable(self).base__.GetCurrentTime)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetCurrentTime(&self, seektime: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetCurrentTime)(::windows::core::Interface::as_raw(self), seektime).ok()
    }
    pub unsafe fn GetStartTime(&self) -> f64 {
        (::windows::core::Interface::vtable(self).base__.GetStartTime)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetDuration(&self) -> f64 {
        (::windows::core::Interface::vtable(self).base__.GetDuration)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsPaused(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).base__.IsPaused)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetDefaultPlaybackRate(&self) -> f64 {
        (::windows::core::Interface::vtable(self).base__.GetDefaultPlaybackRate)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetDefaultPlaybackRate(&self, rate: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetDefaultPlaybackRate)(::windows::core::Interface::as_raw(self), rate).ok()
    }
    pub unsafe fn GetPlaybackRate(&self) -> f64 {
        (::windows::core::Interface::vtable(self).base__.GetPlaybackRate)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetPlaybackRate(&self, rate: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetPlaybackRate)(::windows::core::Interface::as_raw(self), rate).ok()
    }
    pub unsafe fn GetPlayed(&self) -> ::windows::core::Result<IMFMediaTimeRange> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaTimeRange>();
        (::windows::core::Interface::vtable(self).base__.GetPlayed)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetSeekable(&self) -> ::windows::core::Result<IMFMediaTimeRange> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaTimeRange>();
        (::windows::core::Interface::vtable(self).base__.GetSeekable)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsEnded(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).base__.IsEnded)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetAutoPlay(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).base__.GetAutoPlay)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetAutoPlay<P0>(&self, autoplay: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).base__.SetAutoPlay)(::windows::core::Interface::as_raw(self), autoplay.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetLoop(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).base__.GetLoop)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetLoop<P0>(&self, r#loop: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).base__.SetLoop)(::windows::core::Interface::as_raw(self), r#loop.into_param().abi()).ok()
    }
    pub unsafe fn Play(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Play)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Pause(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Pause)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetMuted(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).base__.GetMuted)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetMuted<P0>(&self, muted: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).base__.SetMuted)(::windows::core::Interface::as_raw(self), muted.into_param().abi()).ok()
    }
    pub unsafe fn GetVolume(&self) -> f64 {
        (::windows::core::Interface::vtable(self).base__.GetVolume)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetVolume(&self, volume: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetVolume)(::windows::core::Interface::as_raw(self), volume).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn HasVideo(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).base__.HasVideo)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn HasAudio(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).base__.HasAudio)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetNativeVideoSize(&self, cx: ::core::option::Option<*mut u32>, cy: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetNativeVideoSize)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(cx.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(cy.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetVideoAspectRatio(&self, cx: ::core::option::Option<*mut u32>, cy: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetVideoAspectRatio)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(cx.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(cy.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn Shutdown(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Shutdown)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn TransferVideoFrame<P0>(&self, pdstsurf: P0, psrc: ::core::option::Option<*const MFVideoNormalizedRect>, pdst: *const super::super::Foundation::RECT, pborderclr: ::core::option::Option<*const MFARGB>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.TransferVideoFrame)(::windows::core::Interface::as_raw(self), pdstsurf.into_param().abi(), ::core::mem::transmute(psrc.unwrap_or(::std::ptr::null())), pdst, ::core::mem::transmute(pborderclr.unwrap_or(::std::ptr::null()))).ok()
    }
    pub unsafe fn OnVideoStreamTick(&self) -> ::windows::core::Result<i64> {
        let mut result__ = ::windows::core::zeroed::<i64>();
        (::windows::core::Interface::vtable(self).base__.OnVideoStreamTick)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetSourceFromByteStream<P0, P1>(&self, pbytestream: P0, purl: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFByteStream>,
        P1: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        (::windows::core::Interface::vtable(self).SetSourceFromByteStream)(::windows::core::Interface::as_raw(self), pbytestream.into_param().abi(), purl.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetStatistics(&self, statisticid: MF_MEDIA_ENGINE_STATISTIC) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT> {
        let mut result__ = ::windows::core::zeroed::<super::super::System::Com::StructuredStorage::PROPVARIANT>();
        (::windows::core::Interface::vtable(self).GetStatistics)(::windows::core::Interface::as_raw(self), statisticid, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn UpdateVideoStream(&self, psrc: ::core::option::Option<*const MFVideoNormalizedRect>, pdst: ::core::option::Option<*const super::super::Foundation::RECT>, pborderclr: ::core::option::Option<*const MFARGB>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).UpdateVideoStream)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(psrc.unwrap_or(::std::ptr::null())), ::core::mem::transmute(pdst.unwrap_or(::std::ptr::null())), ::core::mem::transmute(pborderclr.unwrap_or(::std::ptr::null()))).ok()
    }
    pub unsafe fn GetBalance(&self) -> f64 {
        (::windows::core::Interface::vtable(self).GetBalance)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetBalance(&self, balance: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetBalance)(::windows::core::Interface::as_raw(self), balance).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsPlaybackRateSupported(&self, rate: f64) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).IsPlaybackRateSupported)(::windows::core::Interface::as_raw(self), rate)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn FrameStep<P0>(&self, forward: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).FrameStep)(::windows::core::Interface::as_raw(self), forward.into_param().abi()).ok()
    }
    pub unsafe fn GetResourceCharacteristics(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetResourceCharacteristics)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetPresentationAttribute(&self, guidmfattribute: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT> {
        let mut result__ = ::windows::core::zeroed::<super::super::System::Com::StructuredStorage::PROPVARIANT>();
        (::windows::core::Interface::vtable(self).GetPresentationAttribute)(::windows::core::Interface::as_raw(self), guidmfattribute, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetNumberOfStreams(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetNumberOfStreams)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetStreamAttribute(&self, dwstreamindex: u32, guidmfattribute: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT> {
        let mut result__ = ::windows::core::zeroed::<super::super::System::Com::StructuredStorage::PROPVARIANT>();
        (::windows::core::Interface::vtable(self).GetStreamAttribute)(::windows::core::Interface::as_raw(self), dwstreamindex, guidmfattribute, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetStreamSelection(&self, dwstreamindex: u32) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).GetStreamSelection)(::windows::core::Interface::as_raw(self), dwstreamindex, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetStreamSelection<P0>(&self, dwstreamindex: u32, enabled: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetStreamSelection)(::windows::core::Interface::as_raw(self), dwstreamindex, enabled.into_param().abi()).ok()
    }
    pub unsafe fn ApplyStreamSelections(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ApplyStreamSelections)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsProtected(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).IsProtected)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn InsertVideoEffect<P0, P1>(&self, peffect: P0, foptional: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
        P1: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).InsertVideoEffect)(::windows::core::Interface::as_raw(self), peffect.into_param().abi(), foptional.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn InsertAudioEffect<P0, P1>(&self, peffect: P0, foptional: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
        P1: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).InsertAudioEffect)(::windows::core::Interface::as_raw(self), peffect.into_param().abi(), foptional.into_param().abi()).ok()
    }
    pub unsafe fn RemoveAllEffects(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveAllEffects)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetTimelineMarkerTimer(&self, timetofire: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetTimelineMarkerTimer)(::windows::core::Interface::as_raw(self), timetofire).ok()
    }
    pub unsafe fn GetTimelineMarkerTimer(&self) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).GetTimelineMarkerTimer)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn CancelTimelineMarkerTimer(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).CancelTimelineMarkerTimer)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsStereo3D(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).IsStereo3D)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetStereo3DFramePackingMode(&self) -> ::windows::core::Result<MF_MEDIA_ENGINE_S3D_PACKING_MODE> {
        let mut result__ = ::windows::core::zeroed::<MF_MEDIA_ENGINE_S3D_PACKING_MODE>();
        (::windows::core::Interface::vtable(self).GetStereo3DFramePackingMode)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetStereo3DFramePackingMode(&self, packmode: MF_MEDIA_ENGINE_S3D_PACKING_MODE) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetStereo3DFramePackingMode)(::windows::core::Interface::as_raw(self), packmode).ok()
    }
    pub unsafe fn GetStereo3DRenderMode(&self) -> ::windows::core::Result<MF3DVideoOutputType> {
        let mut result__ = ::windows::core::zeroed::<MF3DVideoOutputType>();
        (::windows::core::Interface::vtable(self).GetStereo3DRenderMode)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetStereo3DRenderMode(&self, outputtype: MF3DVideoOutputType) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetStereo3DRenderMode)(::windows::core::Interface::as_raw(self), outputtype).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn EnableWindowlessSwapchainMode<P0>(&self, fenable: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).EnableWindowlessSwapchainMode)(::windows::core::Interface::as_raw(self), fenable.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetVideoSwapchainHandle(&self) -> ::windows::core::Result<super::super::Foundation::HANDLE> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self).GetVideoSwapchainHandle)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn EnableHorizontalMirrorMode<P0>(&self, fenable: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).EnableHorizontalMirrorMode)(::windows::core::Interface::as_raw(self), fenable.into_param().abi()).ok()
    }
    pub unsafe fn GetAudioStreamCategory(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetAudioStreamCategory)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetAudioStreamCategory(&self, category: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetAudioStreamCategory)(::windows::core::Interface::as_raw(self), category).ok()
    }
    pub unsafe fn GetAudioEndpointRole(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetAudioEndpointRole)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetAudioEndpointRole(&self, role: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetAudioEndpointRole)(::windows::core::Interface::as_raw(self), role).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetRealTimeMode(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).GetRealTimeMode)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetRealTimeMode<P0>(&self, fenable: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetRealTimeMode)(::windows::core::Interface::as_raw(self), fenable.into_param().abi()).ok()
    }
    pub unsafe fn SetCurrentTimeEx(&self, seektime: f64, seekmode: MF_MEDIA_ENGINE_SEEK_MODE) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetCurrentTimeEx)(::windows::core::Interface::as_raw(self), seektime, seekmode).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn EnableTimeUpdateTimer<P0>(&self, fenabletimer: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).EnableTimeUpdateTimer)(::windows::core::Interface::as_raw(self), fenabletimer.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaEngineEx, ::windows::core::IUnknown, IMFMediaEngine);
impl ::core::cmp::PartialEq for IMFMediaEngineEx {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaEngineEx {}
impl ::core::fmt::Debug for IMFMediaEngineEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaEngineEx").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaEngineEx {
    type Vtable = IMFMediaEngineEx_Vtbl;
}
impl ::core::clone::Clone for IMFMediaEngineEx {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaEngineEx {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x83015ead_b1e6_40d0_a98a_37145ffe1ad1);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaEngineEx_Vtbl {
    pub base__: IMFMediaEngine_Vtbl,
    pub SetSourceFromByteStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbytestream: *mut ::core::ffi::c_void, purl: ::std::mem::MaybeUninit<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub GetStatistics: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, statisticid: MF_MEDIA_ENGINE_STATISTIC, pstatistic: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    GetStatistics: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub UpdateVideoStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const MFARGB) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    UpdateVideoStream: usize,
    pub GetBalance: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> f64,
    pub SetBalance: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, balance: f64) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub IsPlaybackRateSupported: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, rate: f64) -> super::super::Foundation::BOOL,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsPlaybackRateSupported: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub FrameStep: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, forward: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    FrameStep: usize,
    pub GetResourceCharacteristics: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcharacteristics: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub GetPresentationAttribute: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidmfattribute: *const ::windows::core::GUID, pvvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    GetPresentationAttribute: usize,
    pub GetNumberOfStreams: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwstreamcount: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub GetStreamAttribute: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, guidmfattribute: *const ::windows::core::GUID, pvvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    GetStreamAttribute: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub GetStreamSelection: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, penabled: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetStreamSelection: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub SetStreamSelection: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, enabled: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetStreamSelection: usize,
    pub ApplyStreamSelections: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub IsProtected: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pprotected: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsProtected: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub InsertVideoEffect: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, peffect: *mut ::core::ffi::c_void, foptional: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    InsertVideoEffect: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub InsertAudioEffect: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, peffect: *mut ::core::ffi::c_void, foptional: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    InsertAudioEffect: usize,
    pub RemoveAllEffects: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetTimelineMarkerTimer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, timetofire: f64) -> ::windows::core::HRESULT,
    pub GetTimelineMarkerTimer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ptimetofire: *mut f64) -> ::windows::core::HRESULT,
    pub CancelTimelineMarkerTimer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub IsStereo3D: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsStereo3D: usize,
    pub GetStereo3DFramePackingMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, packmode: *mut MF_MEDIA_ENGINE_S3D_PACKING_MODE) -> ::windows::core::HRESULT,
    pub SetStereo3DFramePackingMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, packmode: MF_MEDIA_ENGINE_S3D_PACKING_MODE) -> ::windows::core::HRESULT,
    pub GetStereo3DRenderMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, outputtype: *mut MF3DVideoOutputType) -> ::windows::core::HRESULT,
    pub SetStereo3DRenderMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, outputtype: MF3DVideoOutputType) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub EnableWindowlessSwapchainMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fenable: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    EnableWindowlessSwapchainMode: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub GetVideoSwapchainHandle: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, phswapchain: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetVideoSwapchainHandle: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub EnableHorizontalMirrorMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fenable: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    EnableHorizontalMirrorMode: usize,
    pub GetAudioStreamCategory: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcategory: *mut u32) -> ::windows::core::HRESULT,
    pub SetAudioStreamCategory: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, category: u32) -> ::windows::core::HRESULT,
    pub GetAudioEndpointRole: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, prole: *mut u32) -> ::windows::core::HRESULT,
    pub SetAudioEndpointRole: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, role: u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub GetRealTimeMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pfenabled: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetRealTimeMode: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub SetRealTimeMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fenable: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetRealTimeMode: usize,
    pub SetCurrentTimeEx: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, seektime: f64, seekmode: MF_MEDIA_ENGINE_SEEK_MODE) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub EnableTimeUpdateTimer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fenabletimer: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    EnableTimeUpdateTimer: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaEngineExtension(::windows::core::IUnknown);
impl IMFMediaEngineExtension {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn CanPlayType<P0, P1>(&self, audioonly: P0, mimetype: P1) -> ::windows::core::Result<MF_MEDIA_ENGINE_CANPLAY>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
        P1: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<MF_MEDIA_ENGINE_CANPLAY>();
        (::windows::core::Interface::vtable(self).CanPlayType)(::windows::core::Interface::as_raw(self), audioonly.into_param().abi(), mimetype.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn BeginCreateObject<P0, P1, P2, P3>(&self, bstrurl: P0, pbytestream: P1, r#type: MF_OBJECT_TYPE, ppiunknowncancelcookie: *mut ::core::option::Option<::windows::core::IUnknown>, pcallback: P2, punkstate: P3) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
        P1: ::windows::core::IntoParam<IMFByteStream>,
        P2: ::windows::core::IntoParam<IMFAsyncCallback>,
        P3: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginCreateObject)(::windows::core::Interface::as_raw(self), bstrurl.into_param().abi(), pbytestream.into_param().abi(), r#type, ::core::mem::transmute(ppiunknowncancelcookie), pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    pub unsafe fn CancelObjectCreation<P0>(&self, piunknowncancelcookie: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).CancelObjectCreation)(::windows::core::Interface::as_raw(self), piunknowncancelcookie.into_param().abi()).ok()
    }
    pub unsafe fn EndCreateObject<P0>(&self, presult: P0) -> ::windows::core::Result<::windows::core::IUnknown>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::core::IUnknown>();
        (::windows::core::Interface::vtable(self).EndCreateObject)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFMediaEngineExtension, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaEngineExtension {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaEngineExtension {}
impl ::core::fmt::Debug for IMFMediaEngineExtension {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaEngineExtension").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaEngineExtension {
    type Vtable = IMFMediaEngineExtension_Vtbl;
}
impl ::core::clone::Clone for IMFMediaEngineExtension {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaEngineExtension {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2f69d622_20b5_41e9_afdf_89ced1dda04e);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaEngineExtension_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub CanPlayType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, audioonly: super::super::Foundation::BOOL, mimetype: ::std::mem::MaybeUninit<::windows::core::BSTR>, panswer: *mut MF_MEDIA_ENGINE_CANPLAY) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    CanPlayType: usize,
    pub BeginCreateObject: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, bstrurl: ::std::mem::MaybeUninit<::windows::core::BSTR>, pbytestream: *mut ::core::ffi::c_void, r#type: MF_OBJECT_TYPE, ppiunknowncancelcookie: *mut *mut ::core::ffi::c_void, pcallback: *mut ::core::ffi::c_void, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub CancelObjectCreation: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, piunknowncancelcookie: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub EndCreateObject: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaEngineNeedKeyNotify(::windows::core::IUnknown);
impl IMFMediaEngineNeedKeyNotify {
    pub unsafe fn NeedKey(&self, initdata: ::core::option::Option<&[u8]>) {
        (::windows::core::Interface::vtable(self).NeedKey)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(initdata.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr())), initdata.as_deref().map_or(0, |slice| slice.len() as _))
    }
}
::windows::imp::interface_hierarchy!(IMFMediaEngineNeedKeyNotify, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaEngineNeedKeyNotify {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaEngineNeedKeyNotify {}
impl ::core::fmt::Debug for IMFMediaEngineNeedKeyNotify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaEngineNeedKeyNotify").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaEngineNeedKeyNotify {
    type Vtable = IMFMediaEngineNeedKeyNotify_Vtbl;
}
impl ::core::clone::Clone for IMFMediaEngineNeedKeyNotify {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaEngineNeedKeyNotify {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x46a30204_a696_4b18_8804_246b8f031bb1);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaEngineNeedKeyNotify_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub NeedKey: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, initdata: *const u8, cb: u32),
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaEngineNotify(::windows::core::IUnknown);
impl IMFMediaEngineNotify {
    pub unsafe fn EventNotify(&self, event: u32, param1: usize, param2: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).EventNotify)(::windows::core::Interface::as_raw(self), event, param1, param2).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaEngineNotify, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaEngineNotify {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaEngineNotify {}
impl ::core::fmt::Debug for IMFMediaEngineNotify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaEngineNotify").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaEngineNotify {
    type Vtable = IMFMediaEngineNotify_Vtbl;
}
impl ::core::clone::Clone for IMFMediaEngineNotify {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaEngineNotify {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfee7c112_e776_42b5_9bbf_0048524e2bd5);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaEngineNotify_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub EventNotify: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, event: u32, param1: usize, param2: u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaEngineOPMInfo(::windows::core::IUnknown);
impl IMFMediaEngineOPMInfo {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetOPMInfo(&self, pstatus: *mut MF_MEDIA_ENGINE_OPM_STATUS, pconstricted: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetOPMInfo)(::windows::core::Interface::as_raw(self), pstatus, pconstricted).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaEngineOPMInfo, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaEngineOPMInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaEngineOPMInfo {}
impl ::core::fmt::Debug for IMFMediaEngineOPMInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaEngineOPMInfo").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaEngineOPMInfo {
    type Vtable = IMFMediaEngineOPMInfo_Vtbl;
}
impl ::core::clone::Clone for IMFMediaEngineOPMInfo {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaEngineOPMInfo {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x765763e6_6c01_4b01_bb0f_b829f60ed28c);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaEngineOPMInfo_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub GetOPMInfo: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pstatus: *mut MF_MEDIA_ENGINE_OPM_STATUS, pconstricted: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetOPMInfo: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaEngineProtectedContent(::windows::core::IUnknown);
impl IMFMediaEngineProtectedContent {
    pub unsafe fn ShareResources<P0>(&self, punkdevicecontext: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).ShareResources)(::windows::core::Interface::as_raw(self), punkdevicecontext.into_param().abi()).ok()
    }
    pub unsafe fn GetRequiredProtections(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetRequiredProtections)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetOPMWindow<P0>(&self, hwnd: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::HWND>,
    {
        (::windows::core::Interface::vtable(self).SetOPMWindow)(::windows::core::Interface::as_raw(self), hwnd.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn TransferVideoFrame<P0>(&self, pdstsurf: P0, psrc: ::core::option::Option<*const MFVideoNormalizedRect>, pdst: *const super::super::Foundation::RECT, pborderclr: ::core::option::Option<*const MFARGB>) -> ::windows::core::Result<u32>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).TransferVideoFrame)(::windows::core::Interface::as_raw(self), pdstsurf.into_param().abi(), ::core::mem::transmute(psrc.unwrap_or(::std::ptr::null())), pdst, ::core::mem::transmute(pborderclr.unwrap_or(::std::ptr::null())), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetContentProtectionManager<P0>(&self, pcpm: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFContentProtectionManager>,
    {
        (::windows::core::Interface::vtable(self).SetContentProtectionManager)(::windows::core::Interface::as_raw(self), pcpm.into_param().abi()).ok()
    }
    pub unsafe fn SetApplicationCertificate(&self, pbblob: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetApplicationCertificate)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pbblob.as_ptr()), pbblob.len() as _).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaEngineProtectedContent, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaEngineProtectedContent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaEngineProtectedContent {}
impl ::core::fmt::Debug for IMFMediaEngineProtectedContent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaEngineProtectedContent").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaEngineProtectedContent {
    type Vtable = IMFMediaEngineProtectedContent_Vtbl;
}
impl ::core::clone::Clone for IMFMediaEngineProtectedContent {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaEngineProtectedContent {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9f8021e8_9c8c_487e_bb5c_79aa4779938c);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaEngineProtectedContent_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub ShareResources: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, punkdevicecontext: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetRequiredProtections: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pframeprotectionflags: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub SetOPMWindow: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hwnd: super::super::Foundation::HWND) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetOPMWindow: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub TransferVideoFrame: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdstsurf: *mut ::core::ffi::c_void, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const MFARGB, pframeprotectionflags: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    TransferVideoFrame: usize,
    pub SetContentProtectionManager: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcpm: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetApplicationCertificate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbblob: *const u8, cbblob: u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaEngineSrcElements(::windows::core::IUnknown);
impl IMFMediaEngineSrcElements {
    pub unsafe fn GetLength(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetLength)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetURL(&self, index: u32) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::BSTR>();
        (::windows::core::Interface::vtable(self).GetURL)(::windows::core::Interface::as_raw(self), index, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetType(&self, index: u32) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::BSTR>();
        (::windows::core::Interface::vtable(self).GetType)(::windows::core::Interface::as_raw(self), index, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetMedia(&self, index: u32) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::BSTR>();
        (::windows::core::Interface::vtable(self).GetMedia)(::windows::core::Interface::as_raw(self), index, &mut result__).from_abi(result__)
    }
    pub unsafe fn AddElement<P0, P1, P2>(&self, purl: P0, ptype: P1, pmedia: P2) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
        P1: ::windows::core::IntoParam<::windows::core::BSTR>,
        P2: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        (::windows::core::Interface::vtable(self).AddElement)(::windows::core::Interface::as_raw(self), purl.into_param().abi(), ptype.into_param().abi(), pmedia.into_param().abi()).ok()
    }
    pub unsafe fn RemoveAllElements(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveAllElements)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaEngineSrcElements, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaEngineSrcElements {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaEngineSrcElements {}
impl ::core::fmt::Debug for IMFMediaEngineSrcElements {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaEngineSrcElements").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaEngineSrcElements {
    type Vtable = IMFMediaEngineSrcElements_Vtbl;
}
impl ::core::clone::Clone for IMFMediaEngineSrcElements {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaEngineSrcElements {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7a5e5354_b114_4c72_b991_3131d75032ea);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaEngineSrcElements_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetLength: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetURL: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, purl: *mut ::std::mem::MaybeUninit<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub GetType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, ptype: *mut ::std::mem::MaybeUninit<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub GetMedia: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, pmedia: *mut ::std::mem::MaybeUninit<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub AddElement: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, purl: ::std::mem::MaybeUninit<::windows::core::BSTR>, ptype: ::std::mem::MaybeUninit<::windows::core::BSTR>, pmedia: ::std::mem::MaybeUninit<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub RemoveAllElements: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaEngineSrcElementsEx(::windows::core::IUnknown);
impl IMFMediaEngineSrcElementsEx {
    pub unsafe fn GetLength(&self) -> u32 {
        (::windows::core::Interface::vtable(self).base__.GetLength)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetURL(&self, index: u32) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::BSTR>();
        (::windows::core::Interface::vtable(self).base__.GetURL)(::windows::core::Interface::as_raw(self), index, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetType(&self, index: u32) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::BSTR>();
        (::windows::core::Interface::vtable(self).base__.GetType)(::windows::core::Interface::as_raw(self), index, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetMedia(&self, index: u32) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::BSTR>();
        (::windows::core::Interface::vtable(self).base__.GetMedia)(::windows::core::Interface::as_raw(self), index, &mut result__).from_abi(result__)
    }
    pub unsafe fn AddElement<P0, P1, P2>(&self, purl: P0, ptype: P1, pmedia: P2) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
        P1: ::windows::core::IntoParam<::windows::core::BSTR>,
        P2: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.AddElement)(::windows::core::Interface::as_raw(self), purl.into_param().abi(), ptype.into_param().abi(), pmedia.into_param().abi()).ok()
    }
    pub unsafe fn RemoveAllElements(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.RemoveAllElements)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn AddElementEx<P0, P1, P2, P3>(&self, purl: P0, ptype: P1, pmedia: P2, keysystem: P3) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
        P1: ::windows::core::IntoParam<::windows::core::BSTR>,
        P2: ::windows::core::IntoParam<::windows::core::BSTR>,
        P3: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        (::windows::core::Interface::vtable(self).AddElementEx)(::windows::core::Interface::as_raw(self), purl.into_param().abi(), ptype.into_param().abi(), pmedia.into_param().abi(), keysystem.into_param().abi()).ok()
    }
    pub unsafe fn GetKeySystem(&self, index: u32) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::BSTR>();
        (::windows::core::Interface::vtable(self).GetKeySystem)(::windows::core::Interface::as_raw(self), index, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFMediaEngineSrcElementsEx, ::windows::core::IUnknown, IMFMediaEngineSrcElements);
impl ::core::cmp::PartialEq for IMFMediaEngineSrcElementsEx {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaEngineSrcElementsEx {}
impl ::core::fmt::Debug for IMFMediaEngineSrcElementsEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaEngineSrcElementsEx").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaEngineSrcElementsEx {
    type Vtable = IMFMediaEngineSrcElementsEx_Vtbl;
}
impl ::core::clone::Clone for IMFMediaEngineSrcElementsEx {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaEngineSrcElementsEx {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x654a6bb3_e1a3_424a_9908_53a43a0dfda0);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaEngineSrcElementsEx_Vtbl {
    pub base__: IMFMediaEngineSrcElements_Vtbl,
    pub AddElementEx: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, purl: ::std::mem::MaybeUninit<::windows::core::BSTR>, ptype: ::std::mem::MaybeUninit<::windows::core::BSTR>, pmedia: ::std::mem::MaybeUninit<::windows::core::BSTR>, keysystem: ::std::mem::MaybeUninit<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub GetKeySystem: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, ptype: *mut ::std::mem::MaybeUninit<::windows::core::BSTR>) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaEngineSupportsSourceTransfer(::windows::core::IUnknown);
impl IMFMediaEngineSupportsSourceTransfer {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn ShouldTransferSource(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).ShouldTransferSource)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn DetachMediaSource(&self, ppbytestream: *mut ::core::option::Option<IMFByteStream>, ppmediasource: *mut ::core::option::Option<IMFMediaSource>, ppmse: *mut ::core::option::Option<IMFMediaSourceExtension>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).DetachMediaSource)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(ppbytestream), ::core::mem::transmute(ppmediasource), ::core::mem::transmute(ppmse)).ok()
    }
    pub unsafe fn AttachMediaSource<P0, P1, P2>(&self, pbytestream: P0, pmediasource: P1, pmse: P2) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFByteStream>,
        P1: ::windows::core::IntoParam<IMFMediaSource>,
        P2: ::windows::core::IntoParam<IMFMediaSourceExtension>,
    {
        (::windows::core::Interface::vtable(self).AttachMediaSource)(::windows::core::Interface::as_raw(self), pbytestream.into_param().abi(), pmediasource.into_param().abi(), pmse.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaEngineSupportsSourceTransfer, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaEngineSupportsSourceTransfer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaEngineSupportsSourceTransfer {}
impl ::core::fmt::Debug for IMFMediaEngineSupportsSourceTransfer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaEngineSupportsSourceTransfer").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaEngineSupportsSourceTransfer {
    type Vtable = IMFMediaEngineSupportsSourceTransfer_Vtbl;
}
impl ::core::clone::Clone for IMFMediaEngineSupportsSourceTransfer {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaEngineSupportsSourceTransfer {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa724b056_1b2e_4642_a6f3_db9420c52908);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaEngineSupportsSourceTransfer_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub ShouldTransferSource: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pfshouldtransfer: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    ShouldTransferSource: usize,
    pub DetachMediaSource: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppbytestream: *mut *mut ::core::ffi::c_void, ppmediasource: *mut *mut ::core::ffi::c_void, ppmse: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub AttachMediaSource: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbytestream: *mut ::core::ffi::c_void, pmediasource: *mut ::core::ffi::c_void, pmse: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaEngineTransferSource(::windows::core::IUnknown);
impl IMFMediaEngineTransferSource {
    pub unsafe fn TransferSourceToMediaEngine<P0>(&self, destination: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaEngine>,
    {
        (::windows::core::Interface::vtable(self).TransferSourceToMediaEngine)(::windows::core::Interface::as_raw(self), destination.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaEngineTransferSource, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaEngineTransferSource {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaEngineTransferSource {}
impl ::core::fmt::Debug for IMFMediaEngineTransferSource {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaEngineTransferSource").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaEngineTransferSource {
    type Vtable = IMFMediaEngineTransferSource_Vtbl;
}
impl ::core::clone::Clone for IMFMediaEngineTransferSource {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaEngineTransferSource {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x24230452_fe54_40cc_94f3_fcc394c340d6);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaEngineTransferSource_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub TransferSourceToMediaEngine: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, destination: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaEngineWebSupport(::windows::core::IUnknown);
impl IMFMediaEngineWebSupport {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn ShouldDelayTheLoadEvent(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).ShouldDelayTheLoadEvent)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn ConnectWebAudio(&self, dwsamplerate: u32) -> ::windows::core::Result<IAudioSourceProvider> {
        let mut result__ = ::windows::core::zeroed::<IAudioSourceProvider>();
        (::windows::core::Interface::vtable(self).ConnectWebAudio)(::windows::core::Interface::as_raw(self), dwsamplerate, &mut result__).from_abi(result__)
    }
    pub unsafe fn DisconnectWebAudio(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).DisconnectWebAudio)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaEngineWebSupport, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaEngineWebSupport {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaEngineWebSupport {}
impl ::core::fmt::Debug for IMFMediaEngineWebSupport {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaEngineWebSupport").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaEngineWebSupport {
    type Vtable = IMFMediaEngineWebSupport_Vtbl;
}
impl ::core::clone::Clone for IMFMediaEngineWebSupport {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaEngineWebSupport {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xba2743a1_07e0_48ef_84b6_9a2ed023ca6c);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaEngineWebSupport_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub ShouldDelayTheLoadEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL,
    #[cfg(not(feature = "Win32_Foundation"))]
    ShouldDelayTheLoadEvent: usize,
    pub ConnectWebAudio: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwsamplerate: u32, ppsourceprovider: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub DisconnectWebAudio: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaError(::windows::core::IUnknown);
impl IMFMediaError {
    pub unsafe fn GetErrorCode(&self) -> u16 {
        (::windows::core::Interface::vtable(self).GetErrorCode)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetExtendedErrorCode(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetExtendedErrorCode)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetErrorCode(&self, error: MF_MEDIA_ENGINE_ERR) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetErrorCode)(::windows::core::Interface::as_raw(self), error).ok()
    }
    pub unsafe fn SetExtendedErrorCode(&self, error: ::windows::core::HRESULT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetExtendedErrorCode)(::windows::core::Interface::as_raw(self), error).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaError, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaError {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaError {}
impl ::core::fmt::Debug for IMFMediaError {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaError").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaError {
    type Vtable = IMFMediaError_Vtbl;
}
impl ::core::clone::Clone for IMFMediaError {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaError {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfc0e10d2_ab2a_4501_a951_06bb1075184c);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaError_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetErrorCode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u16,
    pub GetExtendedErrorCode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetErrorCode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, error: MF_MEDIA_ENGINE_ERR) -> ::windows::core::HRESULT,
    pub SetExtendedErrorCode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, error: ::windows::core::HRESULT) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaEvent(::windows::core::IUnknown);
impl IMFMediaEvent {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItem(&self, guidkey: *const ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItem)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetItemType(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<MF_ATTRIBUTE_TYPE> {
        let mut result__ = ::windows::core::zeroed::<MF_ATTRIBUTE_TYPE>();
        (::windows::core::Interface::vtable(self).base__.GetItemType)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn CompareItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.CompareItem)(::windows::core::Interface::as_raw(self), guidkey, value, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Compare<P0>(&self, ptheirs: P0, matchtype: MF_ATTRIBUTES_MATCH_TYPE) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.Compare)(::windows::core::Interface::as_raw(self), ptheirs.into_param().abi(), matchtype, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT32(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetUINT32)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT64(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).base__.GetUINT64)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDouble(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).base__.GetDouble)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetGUID(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).base__.GetGUID)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStringLength(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetStringLength)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetString(&self, guidkey: *const ::windows::core::GUID, pwszvalue: &mut [u16], pcchlength: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetString)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pwszvalue.as_ptr()), pwszvalue.len() as _, ::core::mem::transmute(pcchlength.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedString(&self, guidkey: *const ::windows::core::GUID, ppwszvalue: *mut ::windows::core::PWSTR, pcchlength: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedString)(::windows::core::Interface::as_raw(self), guidkey, ppwszvalue, pcchlength).ok()
    }
    pub unsafe fn GetBlobSize(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetBlobSize)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &mut [u8], pcbblobsize: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _, ::core::mem::transmute(pcbblobsize.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedBlob(&self, guidkey: *const ::windows::core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedBlob)(::windows::core::Interface::as_raw(self), guidkey, ppbuf, pcbsize).ok()
    }
    pub unsafe fn GetUnknown<T>(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.GetUnknown)(::windows::core::Interface::as_raw(self), guidkey, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetItem)(::windows::core::Interface::as_raw(self), guidkey, value).ok()
    }
    pub unsafe fn DeleteItem(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteItem)(::windows::core::Interface::as_raw(self), guidkey).ok()
    }
    pub unsafe fn DeleteAllItems(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteAllItems)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetUINT32(&self, guidkey: *const ::windows::core::GUID, unvalue: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT32)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetUINT64(&self, guidkey: *const ::windows::core::GUID, unvalue: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT64)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetDouble(&self, guidkey: *const ::windows::core::GUID, fvalue: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetDouble)(::windows::core::Interface::as_raw(self), guidkey, fvalue).ok()
    }
    pub unsafe fn SetGUID(&self, guidkey: *const ::windows::core::GUID, guidvalue: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetGUID)(::windows::core::Interface::as_raw(self), guidkey, guidvalue).ok()
    }
    pub unsafe fn SetString<P0>(&self, guidkey: *const ::windows::core::GUID, wszvalue: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.SetString)(::windows::core::Interface::as_raw(self), guidkey, wszvalue.into_param().abi()).ok()
    }
    pub unsafe fn SetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _).ok()
    }
    pub unsafe fn SetUnknown<P0>(&self, guidkey: *const ::windows::core::GUID, punknown: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.SetUnknown)(::windows::core::Interface::as_raw(self), guidkey, punknown.into_param().abi()).ok()
    }
    pub unsafe fn LockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.LockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn UnlockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.UnlockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItemByIndex(&self, unindex: u32, pguidkey: *mut ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItemByIndex)(::windows::core::Interface::as_raw(self), unindex, pguidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn CopyAllItems<P0>(&self, pdest: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).base__.CopyAllItems)(::windows::core::Interface::as_raw(self), pdest.into_param().abi()).ok()
    }
    pub unsafe fn GetType(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetType)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetExtendedType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).GetExtendedType)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStatus(&self) -> ::windows::core::Result<::windows::core::HRESULT> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::HRESULT>();
        (::windows::core::Interface::vtable(self).GetStatus)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetValue(&self) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT> {
        let mut result__ = ::windows::core::zeroed::<super::super::System::Com::StructuredStorage::PROPVARIANT>();
        (::windows::core::Interface::vtable(self).GetValue)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFMediaEvent, ::windows::core::IUnknown, IMFAttributes);
impl ::core::cmp::PartialEq for IMFMediaEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaEvent {}
impl ::core::fmt::Debug for IMFMediaEvent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaEvent").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaEvent {
    type Vtable = IMFMediaEvent_Vtbl;
}
impl ::core::clone::Clone for IMFMediaEvent {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaEvent {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdf598932_f10c_4e39_bba2_c308f101daa3);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaEvent_Vtbl {
    pub base__: IMFAttributes_Vtbl,
    pub GetType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pmet: *mut u32) -> ::windows::core::HRESULT,
    pub GetExtendedType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pguidextendedtype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub GetStatus: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, phrstatus: *mut ::windows::core::HRESULT) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub GetValue: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pvvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    GetValue: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaEventGenerator(::windows::core::IUnknown);
impl IMFMediaEventGenerator {
    pub unsafe fn GetEvent(&self, dwflags: MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS) -> ::windows::core::Result<IMFMediaEvent> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaEvent>();
        (::windows::core::Interface::vtable(self).GetEvent)(::windows::core::Interface::as_raw(self), dwflags, &mut result__).from_abi(result__)
    }
    pub unsafe fn BeginGetEvent<P0, P1>(&self, pcallback: P0, punkstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginGetEvent)(::windows::core::Interface::as_raw(self), pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    pub unsafe fn EndGetEvent<P0>(&self, presult: P0) -> ::windows::core::Result<IMFMediaEvent>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFMediaEvent>();
        (::windows::core::Interface::vtable(self).EndGetEvent)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn QueueEvent(&self, met: u32, guidextendedtype: *const ::windows::core::GUID, hrstatus: ::windows::core::HRESULT, pvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).QueueEvent)(::windows::core::Interface::as_raw(self), met, guidextendedtype, hrstatus, pvvalue).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaEventGenerator, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaEventGenerator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaEventGenerator {}
impl ::core::fmt::Debug for IMFMediaEventGenerator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaEventGenerator").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaEventGenerator {
    type Vtable = IMFMediaEventGenerator_Vtbl;
}
impl ::core::clone::Clone for IMFMediaEventGenerator {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaEventGenerator {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2cd0bd52_bcd5_4b89_b62c_eadc0c031e7d);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaEventGenerator_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwflags: MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS, ppevent: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub BeginGetEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcallback: *mut ::core::ffi::c_void, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub EndGetEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void, ppevent: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub QueueEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, met: u32, guidextendedtype: *const ::windows::core::GUID, hrstatus: ::windows::core::HRESULT, pvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    QueueEvent: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaEventQueue(::windows::core::IUnknown);
impl IMFMediaEventQueue {
    pub unsafe fn GetEvent(&self, dwflags: u32) -> ::windows::core::Result<IMFMediaEvent> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaEvent>();
        (::windows::core::Interface::vtable(self).GetEvent)(::windows::core::Interface::as_raw(self), dwflags, &mut result__).from_abi(result__)
    }
    pub unsafe fn BeginGetEvent<P0, P1>(&self, pcallback: P0, punkstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginGetEvent)(::windows::core::Interface::as_raw(self), pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    pub unsafe fn EndGetEvent<P0>(&self, presult: P0) -> ::windows::core::Result<IMFMediaEvent>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFMediaEvent>();
        (::windows::core::Interface::vtable(self).EndGetEvent)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn QueueEvent<P0>(&self, pevent: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaEvent>,
    {
        (::windows::core::Interface::vtable(self).QueueEvent)(::windows::core::Interface::as_raw(self), pevent.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn QueueEventParamVar(&self, met: u32, guidextendedtype: *const ::windows::core::GUID, hrstatus: ::windows::core::HRESULT, pvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).QueueEventParamVar)(::windows::core::Interface::as_raw(self), met, guidextendedtype, hrstatus, pvvalue).ok()
    }
    pub unsafe fn QueueEventParamUnk<P0>(&self, met: u32, guidextendedtype: *const ::windows::core::GUID, hrstatus: ::windows::core::HRESULT, punk: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).QueueEventParamUnk)(::windows::core::Interface::as_raw(self), met, guidextendedtype, hrstatus, punk.into_param().abi()).ok()
    }
    pub unsafe fn Shutdown(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Shutdown)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaEventQueue, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaEventQueue {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaEventQueue {}
impl ::core::fmt::Debug for IMFMediaEventQueue {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaEventQueue").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaEventQueue {
    type Vtable = IMFMediaEventQueue_Vtbl;
}
impl ::core::clone::Clone for IMFMediaEventQueue {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaEventQueue {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x36f846fc_2256_48b6_b58e_e2b638316581);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaEventQueue_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwflags: u32, ppevent: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub BeginGetEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcallback: *mut ::core::ffi::c_void, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub EndGetEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void, ppevent: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub QueueEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pevent: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub QueueEventParamVar: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, met: u32, guidextendedtype: *const ::windows::core::GUID, hrstatus: ::windows::core::HRESULT, pvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    QueueEventParamVar: usize,
    pub QueueEventParamUnk: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, met: u32, guidextendedtype: *const ::windows::core::GUID, hrstatus: ::windows::core::HRESULT, punk: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Shutdown: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaKeySession(::windows::core::IUnknown);
impl IMFMediaKeySession {
    pub unsafe fn GetError(&self, code: *mut u16, systemcode: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetError)(::windows::core::Interface::as_raw(self), code, systemcode).ok()
    }
    pub unsafe fn KeySystem(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::BSTR>();
        (::windows::core::Interface::vtable(self).KeySystem)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SessionId(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::BSTR>();
        (::windows::core::Interface::vtable(self).SessionId)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn Update(&self, key: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Update)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(key.as_ptr()), key.len() as _).ok()
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Close)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaKeySession, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaKeySession {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaKeySession {}
impl ::core::fmt::Debug for IMFMediaKeySession {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaKeySession").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaKeySession {
    type Vtable = IMFMediaKeySession_Vtbl;
}
impl ::core::clone::Clone for IMFMediaKeySession {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaKeySession {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x24fa67d5_d1d0_4dc5_995c_c0efdc191fb5);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaKeySession_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetError: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, code: *mut u16, systemcode: *mut u32) -> ::windows::core::HRESULT,
    pub KeySystem: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, keysystem: *mut ::std::mem::MaybeUninit<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub SessionId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, sessionid: *mut ::std::mem::MaybeUninit<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub Update: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, key: *const u8, cb: u32) -> ::windows::core::HRESULT,
    pub Close: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaKeySession2(::windows::core::IUnknown);
impl IMFMediaKeySession2 {
    pub unsafe fn GetError(&self, code: *mut u16, systemcode: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetError)(::windows::core::Interface::as_raw(self), code, systemcode).ok()
    }
    pub unsafe fn KeySystem(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::BSTR>();
        (::windows::core::Interface::vtable(self).base__.KeySystem)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SessionId(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::BSTR>();
        (::windows::core::Interface::vtable(self).base__.SessionId)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn Update(&self, key: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Update)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(key.as_ptr()), key.len() as _).ok()
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Close)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn get_KeyStatuses(&self, pkeystatusesarray: *mut *mut MFMediaKeyStatus, pusize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).get_KeyStatuses)(::windows::core::Interface::as_raw(self), pkeystatusesarray, pusize).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Load<P0>(&self, bstrsessionid: P0) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).Load)(::windows::core::Interface::as_raw(self), bstrsessionid.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn GenerateRequest<P0>(&self, initdatatype: P0, pbinitdata: &[u8]) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        (::windows::core::Interface::vtable(self).GenerateRequest)(::windows::core::Interface::as_raw(self), initdatatype.into_param().abi(), ::core::mem::transmute(pbinitdata.as_ptr()), pbinitdata.len() as _).ok()
    }
    pub unsafe fn Expiration(&self) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).Expiration)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn Remove(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Remove)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Shutdown(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Shutdown)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaKeySession2, ::windows::core::IUnknown, IMFMediaKeySession);
impl ::core::cmp::PartialEq for IMFMediaKeySession2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaKeySession2 {}
impl ::core::fmt::Debug for IMFMediaKeySession2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaKeySession2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaKeySession2 {
    type Vtable = IMFMediaKeySession2_Vtbl;
}
impl ::core::clone::Clone for IMFMediaKeySession2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaKeySession2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe9707e05_6d55_4636_b185_3de21210bd75);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaKeySession2_Vtbl {
    pub base__: IMFMediaKeySession_Vtbl,
    pub get_KeyStatuses: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pkeystatusesarray: *mut *mut MFMediaKeyStatus, pusize: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub Load: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, bstrsessionid: ::std::mem::MaybeUninit<::windows::core::BSTR>, pfloaded: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    Load: usize,
    pub GenerateRequest: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, initdatatype: ::std::mem::MaybeUninit<::windows::core::BSTR>, pbinitdata: *const u8, cb: u32) -> ::windows::core::HRESULT,
    pub Expiration: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dblexpiration: *mut f64) -> ::windows::core::HRESULT,
    pub Remove: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Shutdown: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaKeySessionNotify(::windows::core::IUnknown);
impl IMFMediaKeySessionNotify {
    pub unsafe fn KeyMessage<P0>(&self, destinationurl: P0, message: &[u8])
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        (::windows::core::Interface::vtable(self).KeyMessage)(::windows::core::Interface::as_raw(self), destinationurl.into_param().abi(), ::core::mem::transmute(message.as_ptr()), message.len() as _)
    }
    pub unsafe fn KeyAdded(&self) {
        (::windows::core::Interface::vtable(self).KeyAdded)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn KeyError(&self, code: u16, systemcode: u32) {
        (::windows::core::Interface::vtable(self).KeyError)(::windows::core::Interface::as_raw(self), code, systemcode)
    }
}
::windows::imp::interface_hierarchy!(IMFMediaKeySessionNotify, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaKeySessionNotify {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaKeySessionNotify {}
impl ::core::fmt::Debug for IMFMediaKeySessionNotify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaKeySessionNotify").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaKeySessionNotify {
    type Vtable = IMFMediaKeySessionNotify_Vtbl;
}
impl ::core::clone::Clone for IMFMediaKeySessionNotify {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaKeySessionNotify {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6a0083f9_8947_4c1d_9ce0_cdee22b23135);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaKeySessionNotify_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub KeyMessage: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, destinationurl: ::std::mem::MaybeUninit<::windows::core::BSTR>, message: *const u8, cb: u32),
    pub KeyAdded: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub KeyError: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, code: u16, systemcode: u32),
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaKeySessionNotify2(::windows::core::IUnknown);
impl IMFMediaKeySessionNotify2 {
    pub unsafe fn KeyMessage<P0>(&self, destinationurl: P0, message: &[u8])
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.KeyMessage)(::windows::core::Interface::as_raw(self), destinationurl.into_param().abi(), ::core::mem::transmute(message.as_ptr()), message.len() as _)
    }
    pub unsafe fn KeyAdded(&self) {
        (::windows::core::Interface::vtable(self).base__.KeyAdded)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn KeyError(&self, code: u16, systemcode: u32) {
        (::windows::core::Interface::vtable(self).base__.KeyError)(::windows::core::Interface::as_raw(self), code, systemcode)
    }
    pub unsafe fn KeyMessage2<P0>(&self, emessagetype: MF_MEDIAKEYSESSION_MESSAGETYPE, destinationurl: P0, pbmessage: &[u8])
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        (::windows::core::Interface::vtable(self).KeyMessage2)(::windows::core::Interface::as_raw(self), emessagetype, destinationurl.into_param().abi(), ::core::mem::transmute(pbmessage.as_ptr()), pbmessage.len() as _)
    }
    pub unsafe fn KeyStatusChange(&self) {
        (::windows::core::Interface::vtable(self).KeyStatusChange)(::windows::core::Interface::as_raw(self))
    }
}
::windows::imp::interface_hierarchy!(IMFMediaKeySessionNotify2, ::windows::core::IUnknown, IMFMediaKeySessionNotify);
impl ::core::cmp::PartialEq for IMFMediaKeySessionNotify2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaKeySessionNotify2 {}
impl ::core::fmt::Debug for IMFMediaKeySessionNotify2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaKeySessionNotify2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaKeySessionNotify2 {
    type Vtable = IMFMediaKeySessionNotify2_Vtbl;
}
impl ::core::clone::Clone for IMFMediaKeySessionNotify2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaKeySessionNotify2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc3a9e92a_da88_46b0_a110_6cf953026cb9);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaKeySessionNotify2_Vtbl {
    pub base__: IMFMediaKeySessionNotify_Vtbl,
    pub KeyMessage2: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, emessagetype: MF_MEDIAKEYSESSION_MESSAGETYPE, destinationurl: ::std::mem::MaybeUninit<::windows::core::BSTR>, pbmessage: *const u8, cbmessage: u32),
    pub KeyStatusChange: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaKeySystemAccess(::windows::core::IUnknown);
impl IMFMediaKeySystemAccess {
    #[doc = "*Required features: `\"Win32_UI_Shell_PropertiesSystem\"`*"]
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub unsafe fn CreateMediaKeys<P0>(&self, pcdmcustomconfig: P0) -> ::windows::core::Result<IMFMediaKeys2>
    where
        P0: ::windows::core::IntoParam<super::super::UI::Shell::PropertiesSystem::IPropertyStore>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFMediaKeys2>();
        (::windows::core::Interface::vtable(self).CreateMediaKeys)(::windows::core::Interface::as_raw(self), pcdmcustomconfig.into_param().abi(), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_UI_Shell_PropertiesSystem\"`*"]
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub unsafe fn SupportedConfiguration(&self) -> ::windows::core::Result<super::super::UI::Shell::PropertiesSystem::IPropertyStore> {
        let mut result__ = ::windows::core::zeroed::<super::super::UI::Shell::PropertiesSystem::IPropertyStore>();
        (::windows::core::Interface::vtable(self).SupportedConfiguration)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn KeySystem(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::BSTR>();
        (::windows::core::Interface::vtable(self).KeySystem)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFMediaKeySystemAccess, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaKeySystemAccess {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaKeySystemAccess {}
impl ::core::fmt::Debug for IMFMediaKeySystemAccess {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaKeySystemAccess").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaKeySystemAccess {
    type Vtable = IMFMediaKeySystemAccess_Vtbl;
}
impl ::core::clone::Clone for IMFMediaKeySystemAccess {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaKeySystemAccess {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xaec63fda_7a97_4944_b35c_6c6df8085cc3);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaKeySystemAccess_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub CreateMediaKeys: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcdmcustomconfig: *mut ::core::ffi::c_void, ppkeys: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_UI_Shell_PropertiesSystem"))]
    CreateMediaKeys: usize,
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub SupportedConfiguration: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppsupportedconfiguration: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_UI_Shell_PropertiesSystem"))]
    SupportedConfiguration: usize,
    pub KeySystem: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pkeysystem: *mut ::std::mem::MaybeUninit<::windows::core::BSTR>) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaKeys(::windows::core::IUnknown);
impl IMFMediaKeys {
    pub unsafe fn CreateSession<P0, P1>(&self, mimetype: P0, initdata: ::core::option::Option<&[u8]>, customdata: ::core::option::Option<&[u8]>, notify: P1) -> ::windows::core::Result<IMFMediaKeySession>
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
        P1: ::windows::core::IntoParam<IMFMediaKeySessionNotify>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFMediaKeySession>();
        (::windows::core::Interface::vtable(self).CreateSession)(::windows::core::Interface::as_raw(self), mimetype.into_param().abi(), ::core::mem::transmute(initdata.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr())), initdata.as_deref().map_or(0, |slice| slice.len() as _), ::core::mem::transmute(customdata.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr())), customdata.as_deref().map_or(0, |slice| slice.len() as _), notify.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn KeySystem(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::BSTR>();
        (::windows::core::Interface::vtable(self).KeySystem)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn Shutdown(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Shutdown)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetSuspendNotify(&self) -> ::windows::core::Result<IMFCdmSuspendNotify> {
        let mut result__ = ::windows::core::zeroed::<IMFCdmSuspendNotify>();
        (::windows::core::Interface::vtable(self).GetSuspendNotify)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFMediaKeys, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaKeys {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaKeys {}
impl ::core::fmt::Debug for IMFMediaKeys {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaKeys").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaKeys {
    type Vtable = IMFMediaKeys_Vtbl;
}
impl ::core::clone::Clone for IMFMediaKeys {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaKeys {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5cb31c05_61ff_418f_afda_caaf41421a38);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaKeys_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub CreateSession: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, mimetype: ::std::mem::MaybeUninit<::windows::core::BSTR>, initdata: *const u8, cb: u32, customdata: *const u8, cbcustomdata: u32, notify: *mut ::core::ffi::c_void, ppsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub KeySystem: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, keysystem: *mut ::std::mem::MaybeUninit<::windows::core::BSTR>) -> ::windows::core::HRESULT,
    pub Shutdown: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetSuspendNotify: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, notify: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaKeys2(::windows::core::IUnknown);
impl IMFMediaKeys2 {
    pub unsafe fn CreateSession<P0, P1>(&self, mimetype: P0, initdata: ::core::option::Option<&[u8]>, customdata: ::core::option::Option<&[u8]>, notify: P1) -> ::windows::core::Result<IMFMediaKeySession>
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
        P1: ::windows::core::IntoParam<IMFMediaKeySessionNotify>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFMediaKeySession>();
        (::windows::core::Interface::vtable(self).base__.CreateSession)(::windows::core::Interface::as_raw(self), mimetype.into_param().abi(), ::core::mem::transmute(initdata.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr())), initdata.as_deref().map_or(0, |slice| slice.len() as _), ::core::mem::transmute(customdata.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr())), customdata.as_deref().map_or(0, |slice| slice.len() as _), notify.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn KeySystem(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::BSTR>();
        (::windows::core::Interface::vtable(self).base__.KeySystem)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn Shutdown(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Shutdown)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetSuspendNotify(&self) -> ::windows::core::Result<IMFCdmSuspendNotify> {
        let mut result__ = ::windows::core::zeroed::<IMFCdmSuspendNotify>();
        (::windows::core::Interface::vtable(self).base__.GetSuspendNotify)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn CreateSession2<P0>(&self, esessiontype: MF_MEDIAKEYSESSION_TYPE, pmfmediakeysessionnotify2: P0) -> ::windows::core::Result<IMFMediaKeySession2>
    where
        P0: ::windows::core::IntoParam<IMFMediaKeySessionNotify2>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFMediaKeySession2>();
        (::windows::core::Interface::vtable(self).CreateSession2)(::windows::core::Interface::as_raw(self), esessiontype, pmfmediakeysessionnotify2.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetServerCertificate(&self, pbservercertificate: ::core::option::Option<&[u8]>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetServerCertificate)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pbservercertificate.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr())), pbservercertificate.as_deref().map_or(0, |slice| slice.len() as _)).ok()
    }
    pub unsafe fn GetDOMException(&self, systemcode: ::windows::core::HRESULT) -> ::windows::core::Result<::windows::core::HRESULT> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::HRESULT>();
        (::windows::core::Interface::vtable(self).GetDOMException)(::windows::core::Interface::as_raw(self), systemcode, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFMediaKeys2, ::windows::core::IUnknown, IMFMediaKeys);
impl ::core::cmp::PartialEq for IMFMediaKeys2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaKeys2 {}
impl ::core::fmt::Debug for IMFMediaKeys2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaKeys2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaKeys2 {
    type Vtable = IMFMediaKeys2_Vtbl;
}
impl ::core::clone::Clone for IMFMediaKeys2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaKeys2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x45892507_ad66_4de2_83a2_acbb13cd8d43);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaKeys2_Vtbl {
    pub base__: IMFMediaKeys_Vtbl,
    pub CreateSession2: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, esessiontype: MF_MEDIAKEYSESSION_TYPE, pmfmediakeysessionnotify2: *mut ::core::ffi::c_void, ppsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetServerCertificate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbservercertificate: *const u8, cb: u32) -> ::windows::core::HRESULT,
    pub GetDOMException: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, systemcode: ::windows::core::HRESULT, code: *mut ::windows::core::HRESULT) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaSession(::windows::core::IUnknown);
impl IMFMediaSession {
    pub unsafe fn GetEvent(&self, dwflags: MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS) -> ::windows::core::Result<IMFMediaEvent> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaEvent>();
        (::windows::core::Interface::vtable(self).base__.GetEvent)(::windows::core::Interface::as_raw(self), dwflags, &mut result__).from_abi(result__)
    }
    pub unsafe fn BeginGetEvent<P0, P1>(&self, pcallback: P0, punkstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.BeginGetEvent)(::windows::core::Interface::as_raw(self), pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    pub unsafe fn EndGetEvent<P0>(&self, presult: P0) -> ::windows::core::Result<IMFMediaEvent>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFMediaEvent>();
        (::windows::core::Interface::vtable(self).base__.EndGetEvent)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn QueueEvent(&self, met: u32, guidextendedtype: *const ::windows::core::GUID, hrstatus: ::windows::core::HRESULT, pvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.QueueEvent)(::windows::core::Interface::as_raw(self), met, guidextendedtype, hrstatus, pvvalue).ok()
    }
    pub unsafe fn SetTopology<P0>(&self, dwsettopologyflags: u32, ptopology: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFTopology>,
    {
        (::windows::core::Interface::vtable(self).SetTopology)(::windows::core::Interface::as_raw(self), dwsettopologyflags, ptopology.into_param().abi()).ok()
    }
    pub unsafe fn ClearTopologies(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ClearTopologies)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn Start(&self, pguidtimeformat: *const ::windows::core::GUID, pvarstartposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Start)(::windows::core::Interface::as_raw(self), pguidtimeformat, pvarstartposition).ok()
    }
    pub unsafe fn Pause(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Pause)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Stop(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Stop)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Close)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Shutdown(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Shutdown)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetClock(&self) -> ::windows::core::Result<IMFClock> {
        let mut result__ = ::windows::core::zeroed::<IMFClock>();
        (::windows::core::Interface::vtable(self).GetClock)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetSessionCapabilities(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetSessionCapabilities)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetFullTopology(&self, dwgetfulltopologyflags: u32, topoid: u64) -> ::windows::core::Result<IMFTopology> {
        let mut result__ = ::windows::core::zeroed::<IMFTopology>();
        (::windows::core::Interface::vtable(self).GetFullTopology)(::windows::core::Interface::as_raw(self), dwgetfulltopologyflags, topoid, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFMediaSession, ::windows::core::IUnknown, IMFMediaEventGenerator);
impl ::core::cmp::PartialEq for IMFMediaSession {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaSession {}
impl ::core::fmt::Debug for IMFMediaSession {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaSession").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaSession {
    type Vtable = IMFMediaSession_Vtbl;
}
impl ::core::clone::Clone for IMFMediaSession {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaSession {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x90377834_21d0_4dee_8214_ba2e3e6c1127);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaSession_Vtbl {
    pub base__: IMFMediaEventGenerator_Vtbl,
    pub SetTopology: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwsettopologyflags: u32, ptopology: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub ClearTopologies: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub Start: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pguidtimeformat: *const ::windows::core::GUID, pvarstartposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    Start: usize,
    pub Pause: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Stop: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Close: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Shutdown: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetClock: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppclock: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetSessionCapabilities: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwcaps: *mut u32) -> ::windows::core::HRESULT,
    pub GetFullTopology: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwgetfulltopologyflags: u32, topoid: u64, ppfulltopology: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaSharingEngine(::windows::core::IUnknown);
impl IMFMediaSharingEngine {
    pub unsafe fn GetError(&self) -> ::windows::core::Result<IMFMediaError> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaError>();
        (::windows::core::Interface::vtable(self).base__.GetError)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetErrorCode(&self, error: MF_MEDIA_ENGINE_ERR) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetErrorCode)(::windows::core::Interface::as_raw(self), error).ok()
    }
    pub unsafe fn SetSourceElements<P0>(&self, psrcelements: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaEngineSrcElements>,
    {
        (::windows::core::Interface::vtable(self).base__.SetSourceElements)(::windows::core::Interface::as_raw(self), psrcelements.into_param().abi()).ok()
    }
    pub unsafe fn SetSource<P0>(&self, purl: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.SetSource)(::windows::core::Interface::as_raw(self), purl.into_param().abi()).ok()
    }
    pub unsafe fn GetCurrentSource(&self) -> ::windows::core::Result<::windows::core::BSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::BSTR>();
        (::windows::core::Interface::vtable(self).base__.GetCurrentSource)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetNetworkState(&self) -> u16 {
        (::windows::core::Interface::vtable(self).base__.GetNetworkState)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetPreload(&self) -> MF_MEDIA_ENGINE_PRELOAD {
        (::windows::core::Interface::vtable(self).base__.GetPreload)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetPreload(&self, preload: MF_MEDIA_ENGINE_PRELOAD) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetPreload)(::windows::core::Interface::as_raw(self), preload).ok()
    }
    pub unsafe fn GetBuffered(&self) -> ::windows::core::Result<IMFMediaTimeRange> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaTimeRange>();
        (::windows::core::Interface::vtable(self).base__.GetBuffered)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn Load(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Load)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn CanPlayType<P0>(&self, r#type: P0) -> ::windows::core::Result<MF_MEDIA_ENGINE_CANPLAY>
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<MF_MEDIA_ENGINE_CANPLAY>();
        (::windows::core::Interface::vtable(self).base__.CanPlayType)(::windows::core::Interface::as_raw(self), r#type.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetReadyState(&self) -> u16 {
        (::windows::core::Interface::vtable(self).base__.GetReadyState)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsSeeking(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).base__.IsSeeking)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetCurrentTime(&self) -> f64 {
        (::windows::core::Interface::vtable(self).base__.GetCurrentTime)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetCurrentTime(&self, seektime: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetCurrentTime)(::windows::core::Interface::as_raw(self), seektime).ok()
    }
    pub unsafe fn GetStartTime(&self) -> f64 {
        (::windows::core::Interface::vtable(self).base__.GetStartTime)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetDuration(&self) -> f64 {
        (::windows::core::Interface::vtable(self).base__.GetDuration)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsPaused(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).base__.IsPaused)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetDefaultPlaybackRate(&self) -> f64 {
        (::windows::core::Interface::vtable(self).base__.GetDefaultPlaybackRate)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetDefaultPlaybackRate(&self, rate: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetDefaultPlaybackRate)(::windows::core::Interface::as_raw(self), rate).ok()
    }
    pub unsafe fn GetPlaybackRate(&self) -> f64 {
        (::windows::core::Interface::vtable(self).base__.GetPlaybackRate)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetPlaybackRate(&self, rate: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetPlaybackRate)(::windows::core::Interface::as_raw(self), rate).ok()
    }
    pub unsafe fn GetPlayed(&self) -> ::windows::core::Result<IMFMediaTimeRange> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaTimeRange>();
        (::windows::core::Interface::vtable(self).base__.GetPlayed)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetSeekable(&self) -> ::windows::core::Result<IMFMediaTimeRange> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaTimeRange>();
        (::windows::core::Interface::vtable(self).base__.GetSeekable)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsEnded(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).base__.IsEnded)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetAutoPlay(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).base__.GetAutoPlay)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetAutoPlay<P0>(&self, autoplay: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).base__.SetAutoPlay)(::windows::core::Interface::as_raw(self), autoplay.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetLoop(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).base__.GetLoop)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetLoop<P0>(&self, r#loop: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).base__.SetLoop)(::windows::core::Interface::as_raw(self), r#loop.into_param().abi()).ok()
    }
    pub unsafe fn Play(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Play)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Pause(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Pause)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetMuted(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).base__.GetMuted)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetMuted<P0>(&self, muted: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).base__.SetMuted)(::windows::core::Interface::as_raw(self), muted.into_param().abi()).ok()
    }
    pub unsafe fn GetVolume(&self) -> f64 {
        (::windows::core::Interface::vtable(self).base__.GetVolume)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetVolume(&self, volume: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetVolume)(::windows::core::Interface::as_raw(self), volume).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn HasVideo(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).base__.HasVideo)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn HasAudio(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).base__.HasAudio)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetNativeVideoSize(&self, cx: ::core::option::Option<*mut u32>, cy: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetNativeVideoSize)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(cx.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(cy.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetVideoAspectRatio(&self, cx: ::core::option::Option<*mut u32>, cy: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetVideoAspectRatio)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(cx.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(cy.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn Shutdown(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Shutdown)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn TransferVideoFrame<P0>(&self, pdstsurf: P0, psrc: ::core::option::Option<*const MFVideoNormalizedRect>, pdst: *const super::super::Foundation::RECT, pborderclr: ::core::option::Option<*const MFARGB>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.TransferVideoFrame)(::windows::core::Interface::as_raw(self), pdstsurf.into_param().abi(), ::core::mem::transmute(psrc.unwrap_or(::std::ptr::null())), pdst, ::core::mem::transmute(pborderclr.unwrap_or(::std::ptr::null()))).ok()
    }
    pub unsafe fn OnVideoStreamTick(&self) -> ::windows::core::Result<i64> {
        let mut result__ = ::windows::core::zeroed::<i64>();
        (::windows::core::Interface::vtable(self).base__.OnVideoStreamTick)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDevice(&self, pdevice: *mut DEVICE_INFO) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDevice)(::windows::core::Interface::as_raw(self), pdevice).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaSharingEngine, ::windows::core::IUnknown, IMFMediaEngine);
impl ::core::cmp::PartialEq for IMFMediaSharingEngine {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaSharingEngine {}
impl ::core::fmt::Debug for IMFMediaSharingEngine {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaSharingEngine").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaSharingEngine {
    type Vtable = IMFMediaSharingEngine_Vtbl;
}
impl ::core::clone::Clone for IMFMediaSharingEngine {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaSharingEngine {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8d3ce1bf_2367_40e0_9eee_40d377cc1b46);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaSharingEngine_Vtbl {
    pub base__: IMFMediaEngine_Vtbl,
    pub GetDevice: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdevice: *mut DEVICE_INFO) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaSharingEngineClassFactory(::windows::core::IUnknown);
impl IMFMediaSharingEngineClassFactory {
    pub unsafe fn CreateInstance<P0>(&self, dwflags: u32, pattr: P0) -> ::windows::core::Result<IMFMediaSharingEngine>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFMediaSharingEngine>();
        (::windows::core::Interface::vtable(self).CreateInstance)(::windows::core::Interface::as_raw(self), dwflags, pattr.into_param().abi(), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFMediaSharingEngineClassFactory, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaSharingEngineClassFactory {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaSharingEngineClassFactory {}
impl ::core::fmt::Debug for IMFMediaSharingEngineClassFactory {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaSharingEngineClassFactory").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaSharingEngineClassFactory {
    type Vtable = IMFMediaSharingEngineClassFactory_Vtbl;
}
impl ::core::clone::Clone for IMFMediaSharingEngineClassFactory {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaSharingEngineClassFactory {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x524d2bc4_b2b1_4fe5_8fac_fa4e4512b4e0);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaSharingEngineClassFactory_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub CreateInstance: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwflags: u32, pattr: *mut ::core::ffi::c_void, ppengine: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaSink(::windows::core::IUnknown);
impl IMFMediaSink {
    pub unsafe fn GetCharacteristics(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetCharacteristics)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn AddStreamSink<P0>(&self, dwstreamsinkidentifier: u32, pmediatype: P0) -> ::windows::core::Result<IMFStreamSink>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFStreamSink>();
        (::windows::core::Interface::vtable(self).AddStreamSink)(::windows::core::Interface::as_raw(self), dwstreamsinkidentifier, pmediatype.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn RemoveStreamSink(&self, dwstreamsinkidentifier: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveStreamSink)(::windows::core::Interface::as_raw(self), dwstreamsinkidentifier).ok()
    }
    pub unsafe fn GetStreamSinkCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetStreamSinkCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStreamSinkByIndex(&self, dwindex: u32) -> ::windows::core::Result<IMFStreamSink> {
        let mut result__ = ::windows::core::zeroed::<IMFStreamSink>();
        (::windows::core::Interface::vtable(self).GetStreamSinkByIndex)(::windows::core::Interface::as_raw(self), dwindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStreamSinkById(&self, dwstreamsinkidentifier: u32) -> ::windows::core::Result<IMFStreamSink> {
        let mut result__ = ::windows::core::zeroed::<IMFStreamSink>();
        (::windows::core::Interface::vtable(self).GetStreamSinkById)(::windows::core::Interface::as_raw(self), dwstreamsinkidentifier, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetPresentationClock<P0>(&self, ppresentationclock: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFPresentationClock>,
    {
        (::windows::core::Interface::vtable(self).SetPresentationClock)(::windows::core::Interface::as_raw(self), ppresentationclock.into_param().abi()).ok()
    }
    pub unsafe fn GetPresentationClock(&self) -> ::windows::core::Result<IMFPresentationClock> {
        let mut result__ = ::windows::core::zeroed::<IMFPresentationClock>();
        (::windows::core::Interface::vtable(self).GetPresentationClock)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn Shutdown(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Shutdown)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaSink, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaSink {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaSink {}
impl ::core::fmt::Debug for IMFMediaSink {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaSink").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaSink {
    type Vtable = IMFMediaSink_Vtbl;
}
impl ::core::clone::Clone for IMFMediaSink {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaSink {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6ef2a660_47c0_4666_b13d_cbb717f2fa2c);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaSink_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetCharacteristics: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwcharacteristics: *mut u32) -> ::windows::core::HRESULT,
    pub AddStreamSink: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamsinkidentifier: u32, pmediatype: *mut ::core::ffi::c_void, ppstreamsink: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RemoveStreamSink: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamsinkidentifier: u32) -> ::windows::core::HRESULT,
    pub GetStreamSinkCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcstreamsinkcount: *mut u32) -> ::windows::core::HRESULT,
    pub GetStreamSinkByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwindex: u32, ppstreamsink: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetStreamSinkById: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamsinkidentifier: u32, ppstreamsink: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetPresentationClock: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppresentationclock: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetPresentationClock: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pppresentationclock: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Shutdown: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaSinkPreroll(::windows::core::IUnknown);
impl IMFMediaSinkPreroll {
    pub unsafe fn NotifyPreroll(&self, hnsupcomingstarttime: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).NotifyPreroll)(::windows::core::Interface::as_raw(self), hnsupcomingstarttime).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaSinkPreroll, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaSinkPreroll {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaSinkPreroll {}
impl ::core::fmt::Debug for IMFMediaSinkPreroll {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaSinkPreroll").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaSinkPreroll {
    type Vtable = IMFMediaSinkPreroll_Vtbl;
}
impl ::core::clone::Clone for IMFMediaSinkPreroll {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaSinkPreroll {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5dfd4b2a_7674_4110_a4e6_8a68fd5f3688);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaSinkPreroll_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub NotifyPreroll: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hnsupcomingstarttime: i64) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaSource(::windows::core::IUnknown);
impl IMFMediaSource {
    pub unsafe fn GetEvent(&self, dwflags: MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS) -> ::windows::core::Result<IMFMediaEvent> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaEvent>();
        (::windows::core::Interface::vtable(self).base__.GetEvent)(::windows::core::Interface::as_raw(self), dwflags, &mut result__).from_abi(result__)
    }
    pub unsafe fn BeginGetEvent<P0, P1>(&self, pcallback: P0, punkstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.BeginGetEvent)(::windows::core::Interface::as_raw(self), pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    pub unsafe fn EndGetEvent<P0>(&self, presult: P0) -> ::windows::core::Result<IMFMediaEvent>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFMediaEvent>();
        (::windows::core::Interface::vtable(self).base__.EndGetEvent)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn QueueEvent(&self, met: u32, guidextendedtype: *const ::windows::core::GUID, hrstatus: ::windows::core::HRESULT, pvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.QueueEvent)(::windows::core::Interface::as_raw(self), met, guidextendedtype, hrstatus, pvvalue).ok()
    }
    pub unsafe fn GetCharacteristics(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetCharacteristics)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn CreatePresentationDescriptor(&self) -> ::windows::core::Result<IMFPresentationDescriptor> {
        let mut result__ = ::windows::core::zeroed::<IMFPresentationDescriptor>();
        (::windows::core::Interface::vtable(self).CreatePresentationDescriptor)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn Start<P0>(&self, ppresentationdescriptor: P0, pguidtimeformat: *const ::windows::core::GUID, pvarstartposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFPresentationDescriptor>,
    {
        (::windows::core::Interface::vtable(self).Start)(::windows::core::Interface::as_raw(self), ppresentationdescriptor.into_param().abi(), pguidtimeformat, pvarstartposition).ok()
    }
    pub unsafe fn Stop(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Stop)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Pause(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Pause)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Shutdown(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Shutdown)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaSource, ::windows::core::IUnknown, IMFMediaEventGenerator);
impl ::core::cmp::PartialEq for IMFMediaSource {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaSource {}
impl ::core::fmt::Debug for IMFMediaSource {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaSource").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaSource {
    type Vtable = IMFMediaSource_Vtbl;
}
impl ::core::clone::Clone for IMFMediaSource {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaSource {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x279a808d_aec7_40c8_9c6b_a6b492c78a66);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaSource_Vtbl {
    pub base__: IMFMediaEventGenerator_Vtbl,
    pub GetCharacteristics: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwcharacteristics: *mut u32) -> ::windows::core::HRESULT,
    pub CreatePresentationDescriptor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pppresentationdescriptor: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub Start: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppresentationdescriptor: *mut ::core::ffi::c_void, pguidtimeformat: *const ::windows::core::GUID, pvarstartposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    Start: usize,
    pub Stop: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Pause: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Shutdown: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaSource2(::windows::core::IUnknown);
impl IMFMediaSource2 {
    pub unsafe fn GetEvent(&self, dwflags: MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS) -> ::windows::core::Result<IMFMediaEvent> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaEvent>();
        (::windows::core::Interface::vtable(self).base__.base__.base__.GetEvent)(::windows::core::Interface::as_raw(self), dwflags, &mut result__).from_abi(result__)
    }
    pub unsafe fn BeginGetEvent<P0, P1>(&self, pcallback: P0, punkstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.base__.BeginGetEvent)(::windows::core::Interface::as_raw(self), pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    pub unsafe fn EndGetEvent<P0>(&self, presult: P0) -> ::windows::core::Result<IMFMediaEvent>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFMediaEvent>();
        (::windows::core::Interface::vtable(self).base__.base__.base__.EndGetEvent)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn QueueEvent(&self, met: u32, guidextendedtype: *const ::windows::core::GUID, hrstatus: ::windows::core::HRESULT, pvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.base__.QueueEvent)(::windows::core::Interface::as_raw(self), met, guidextendedtype, hrstatus, pvvalue).ok()
    }
    pub unsafe fn GetCharacteristics(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.base__.GetCharacteristics)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn CreatePresentationDescriptor(&self) -> ::windows::core::Result<IMFPresentationDescriptor> {
        let mut result__ = ::windows::core::zeroed::<IMFPresentationDescriptor>();
        (::windows::core::Interface::vtable(self).base__.base__.CreatePresentationDescriptor)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn Start<P0>(&self, ppresentationdescriptor: P0, pguidtimeformat: *const ::windows::core::GUID, pvarstartposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFPresentationDescriptor>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.Start)(::windows::core::Interface::as_raw(self), ppresentationdescriptor.into_param().abi(), pguidtimeformat, pvarstartposition).ok()
    }
    pub unsafe fn Stop(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.Stop)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Pause(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.Pause)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Shutdown(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.Shutdown)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetSourceAttributes(&self) -> ::windows::core::Result<IMFAttributes> {
        let mut result__ = ::windows::core::zeroed::<IMFAttributes>();
        (::windows::core::Interface::vtable(self).base__.GetSourceAttributes)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStreamAttributes(&self, dwstreamidentifier: u32) -> ::windows::core::Result<IMFAttributes> {
        let mut result__ = ::windows::core::zeroed::<IMFAttributes>();
        (::windows::core::Interface::vtable(self).base__.GetStreamAttributes)(::windows::core::Interface::as_raw(self), dwstreamidentifier, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetD3DManager<P0>(&self, pmanager: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.SetD3DManager)(::windows::core::Interface::as_raw(self), pmanager.into_param().abi()).ok()
    }
    pub unsafe fn SetMediaType<P0>(&self, dwstreamid: u32, pmediatype: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        (::windows::core::Interface::vtable(self).SetMediaType)(::windows::core::Interface::as_raw(self), dwstreamid, pmediatype.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaSource2, ::windows::core::IUnknown, IMFMediaEventGenerator, IMFMediaSource, IMFMediaSourceEx);
impl ::core::cmp::PartialEq for IMFMediaSource2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaSource2 {}
impl ::core::fmt::Debug for IMFMediaSource2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaSource2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaSource2 {
    type Vtable = IMFMediaSource2_Vtbl;
}
impl ::core::clone::Clone for IMFMediaSource2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaSource2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfbb03414_d13b_4786_8319_5ac51fc0a136);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaSource2_Vtbl {
    pub base__: IMFMediaSourceEx_Vtbl,
    pub SetMediaType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamid: u32, pmediatype: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaSourceEx(::windows::core::IUnknown);
impl IMFMediaSourceEx {
    pub unsafe fn GetEvent(&self, dwflags: MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS) -> ::windows::core::Result<IMFMediaEvent> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaEvent>();
        (::windows::core::Interface::vtable(self).base__.base__.GetEvent)(::windows::core::Interface::as_raw(self), dwflags, &mut result__).from_abi(result__)
    }
    pub unsafe fn BeginGetEvent<P0, P1>(&self, pcallback: P0, punkstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.BeginGetEvent)(::windows::core::Interface::as_raw(self), pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    pub unsafe fn EndGetEvent<P0>(&self, presult: P0) -> ::windows::core::Result<IMFMediaEvent>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFMediaEvent>();
        (::windows::core::Interface::vtable(self).base__.base__.EndGetEvent)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn QueueEvent(&self, met: u32, guidextendedtype: *const ::windows::core::GUID, hrstatus: ::windows::core::HRESULT, pvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.QueueEvent)(::windows::core::Interface::as_raw(self), met, guidextendedtype, hrstatus, pvvalue).ok()
    }
    pub unsafe fn GetCharacteristics(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetCharacteristics)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn CreatePresentationDescriptor(&self) -> ::windows::core::Result<IMFPresentationDescriptor> {
        let mut result__ = ::windows::core::zeroed::<IMFPresentationDescriptor>();
        (::windows::core::Interface::vtable(self).base__.CreatePresentationDescriptor)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn Start<P0>(&self, ppresentationdescriptor: P0, pguidtimeformat: *const ::windows::core::GUID, pvarstartposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFPresentationDescriptor>,
    {
        (::windows::core::Interface::vtable(self).base__.Start)(::windows::core::Interface::as_raw(self), ppresentationdescriptor.into_param().abi(), pguidtimeformat, pvarstartposition).ok()
    }
    pub unsafe fn Stop(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Stop)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Pause(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Pause)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Shutdown(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Shutdown)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetSourceAttributes(&self) -> ::windows::core::Result<IMFAttributes> {
        let mut result__ = ::windows::core::zeroed::<IMFAttributes>();
        (::windows::core::Interface::vtable(self).GetSourceAttributes)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStreamAttributes(&self, dwstreamidentifier: u32) -> ::windows::core::Result<IMFAttributes> {
        let mut result__ = ::windows::core::zeroed::<IMFAttributes>();
        (::windows::core::Interface::vtable(self).GetStreamAttributes)(::windows::core::Interface::as_raw(self), dwstreamidentifier, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetD3DManager<P0>(&self, pmanager: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).SetD3DManager)(::windows::core::Interface::as_raw(self), pmanager.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaSourceEx, ::windows::core::IUnknown, IMFMediaEventGenerator, IMFMediaSource);
impl ::core::cmp::PartialEq for IMFMediaSourceEx {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaSourceEx {}
impl ::core::fmt::Debug for IMFMediaSourceEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaSourceEx").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaSourceEx {
    type Vtable = IMFMediaSourceEx_Vtbl;
}
impl ::core::clone::Clone for IMFMediaSourceEx {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaSourceEx {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3c9b2eb9_86d5_4514_a394_f56664f9f0d8);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaSourceEx_Vtbl {
    pub base__: IMFMediaSource_Vtbl,
    pub GetSourceAttributes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppattributes: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetStreamAttributes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamidentifier: u32, ppattributes: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetD3DManager: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pmanager: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaSourceExtension(::windows::core::IUnknown);
impl IMFMediaSourceExtension {
    pub unsafe fn GetSourceBuffers(&self) -> ::core::option::Option<IMFSourceBufferList> {
        (::windows::core::Interface::vtable(self).GetSourceBuffers)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetActiveSourceBuffers(&self) -> ::core::option::Option<IMFSourceBufferList> {
        (::windows::core::Interface::vtable(self).GetActiveSourceBuffers)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetReadyState(&self) -> MF_MSE_READY {
        (::windows::core::Interface::vtable(self).GetReadyState)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetDuration(&self) -> f64 {
        (::windows::core::Interface::vtable(self).GetDuration)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetDuration(&self, duration: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetDuration)(::windows::core::Interface::as_raw(self), duration).ok()
    }
    pub unsafe fn AddSourceBuffer<P0, P1>(&self, r#type: P0, pnotify: P1) -> ::windows::core::Result<IMFSourceBuffer>
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
        P1: ::windows::core::IntoParam<IMFSourceBufferNotify>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFSourceBuffer>();
        (::windows::core::Interface::vtable(self).AddSourceBuffer)(::windows::core::Interface::as_raw(self), r#type.into_param().abi(), pnotify.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn RemoveSourceBuffer<P0>(&self, psourcebuffer: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFSourceBuffer>,
    {
        (::windows::core::Interface::vtable(self).RemoveSourceBuffer)(::windows::core::Interface::as_raw(self), psourcebuffer.into_param().abi()).ok()
    }
    pub unsafe fn SetEndOfStream(&self, error: MF_MSE_ERROR) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetEndOfStream)(::windows::core::Interface::as_raw(self), error).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsTypeSupported<P0>(&self, r#type: P0) -> super::super::Foundation::BOOL
    where
        P0: ::windows::core::IntoParam<::windows::core::BSTR>,
    {
        (::windows::core::Interface::vtable(self).IsTypeSupported)(::windows::core::Interface::as_raw(self), r#type.into_param().abi())
    }
    pub unsafe fn GetSourceBuffer(&self, dwstreamindex: u32) -> ::core::option::Option<IMFSourceBuffer> {
        (::windows::core::Interface::vtable(self).GetSourceBuffer)(::windows::core::Interface::as_raw(self), dwstreamindex)
    }
}
::windows::imp::interface_hierarchy!(IMFMediaSourceExtension, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaSourceExtension {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaSourceExtension {}
impl ::core::fmt::Debug for IMFMediaSourceExtension {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaSourceExtension").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaSourceExtension {
    type Vtable = IMFMediaSourceExtension_Vtbl;
}
impl ::core::clone::Clone for IMFMediaSourceExtension {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaSourceExtension {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe467b94e_a713_4562_a802_816a42e9008a);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaSourceExtension_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetSourceBuffers: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::core::option::Option<IMFSourceBufferList>,
    pub GetActiveSourceBuffers: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::core::option::Option<IMFSourceBufferList>,
    pub GetReadyState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> MF_MSE_READY,
    pub GetDuration: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> f64,
    pub SetDuration: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, duration: f64) -> ::windows::core::HRESULT,
    pub AddSourceBuffer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, r#type: ::std::mem::MaybeUninit<::windows::core::BSTR>, pnotify: *mut ::core::ffi::c_void, ppsourcebuffer: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RemoveSourceBuffer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, psourcebuffer: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetEndOfStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, error: MF_MSE_ERROR) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub IsTypeSupported: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, r#type: ::std::mem::MaybeUninit<::windows::core::BSTR>) -> super::super::Foundation::BOOL,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsTypeSupported: usize,
    pub GetSourceBuffer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32) -> ::core::option::Option<IMFSourceBuffer>,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaSourceExtensionLiveSeekableRange(::windows::core::IUnknown);
impl IMFMediaSourceExtensionLiveSeekableRange {
    pub unsafe fn SetLiveSeekableRange(&self, start: f64, end: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetLiveSeekableRange)(::windows::core::Interface::as_raw(self), start, end).ok()
    }
    pub unsafe fn ClearLiveSeekableRange(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ClearLiveSeekableRange)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaSourceExtensionLiveSeekableRange, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaSourceExtensionLiveSeekableRange {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaSourceExtensionLiveSeekableRange {}
impl ::core::fmt::Debug for IMFMediaSourceExtensionLiveSeekableRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaSourceExtensionLiveSeekableRange").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaSourceExtensionLiveSeekableRange {
    type Vtable = IMFMediaSourceExtensionLiveSeekableRange_Vtbl;
}
impl ::core::clone::Clone for IMFMediaSourceExtensionLiveSeekableRange {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaSourceExtensionLiveSeekableRange {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5d1abfd6_450a_4d92_9efc_d6b6cbc1f4da);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaSourceExtensionLiveSeekableRange_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetLiveSeekableRange: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, start: f64, end: f64) -> ::windows::core::HRESULT,
    pub ClearLiveSeekableRange: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaSourceExtensionNotify(::windows::core::IUnknown);
impl IMFMediaSourceExtensionNotify {
    pub unsafe fn OnSourceOpen(&self) {
        (::windows::core::Interface::vtable(self).OnSourceOpen)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn OnSourceEnded(&self) {
        (::windows::core::Interface::vtable(self).OnSourceEnded)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn OnSourceClose(&self) {
        (::windows::core::Interface::vtable(self).OnSourceClose)(::windows::core::Interface::as_raw(self))
    }
}
::windows::imp::interface_hierarchy!(IMFMediaSourceExtensionNotify, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaSourceExtensionNotify {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaSourceExtensionNotify {}
impl ::core::fmt::Debug for IMFMediaSourceExtensionNotify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaSourceExtensionNotify").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaSourceExtensionNotify {
    type Vtable = IMFMediaSourceExtensionNotify_Vtbl;
}
impl ::core::clone::Clone for IMFMediaSourceExtensionNotify {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaSourceExtensionNotify {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa7901327_05dd_4469_a7b7_0e01979e361d);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaSourceExtensionNotify_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub OnSourceOpen: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub OnSourceEnded: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub OnSourceClose: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaSourcePresentationProvider(::windows::core::IUnknown);
impl IMFMediaSourcePresentationProvider {
    pub unsafe fn ForceEndOfPresentation<P0>(&self, ppresentationdescriptor: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFPresentationDescriptor>,
    {
        (::windows::core::Interface::vtable(self).ForceEndOfPresentation)(::windows::core::Interface::as_raw(self), ppresentationdescriptor.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaSourcePresentationProvider, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaSourcePresentationProvider {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaSourcePresentationProvider {}
impl ::core::fmt::Debug for IMFMediaSourcePresentationProvider {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaSourcePresentationProvider").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaSourcePresentationProvider {
    type Vtable = IMFMediaSourcePresentationProvider_Vtbl;
}
impl ::core::clone::Clone for IMFMediaSourcePresentationProvider {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaSourcePresentationProvider {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0e1d600a_c9f3_442d_8c51_a42d2d49452f);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaSourcePresentationProvider_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub ForceEndOfPresentation: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppresentationdescriptor: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaSourceTopologyProvider(::windows::core::IUnknown);
impl IMFMediaSourceTopologyProvider {
    pub unsafe fn GetMediaSourceTopology<P0>(&self, ppresentationdescriptor: P0) -> ::windows::core::Result<IMFTopology>
    where
        P0: ::windows::core::IntoParam<IMFPresentationDescriptor>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFTopology>();
        (::windows::core::Interface::vtable(self).GetMediaSourceTopology)(::windows::core::Interface::as_raw(self), ppresentationdescriptor.into_param().abi(), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFMediaSourceTopologyProvider, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaSourceTopologyProvider {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaSourceTopologyProvider {}
impl ::core::fmt::Debug for IMFMediaSourceTopologyProvider {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaSourceTopologyProvider").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaSourceTopologyProvider {
    type Vtable = IMFMediaSourceTopologyProvider_Vtbl;
}
impl ::core::clone::Clone for IMFMediaSourceTopologyProvider {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaSourceTopologyProvider {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0e1d6009_c9f3_442d_8c51_a42d2d49452f);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaSourceTopologyProvider_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetMediaSourceTopology: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppresentationdescriptor: *mut ::core::ffi::c_void, pptopology: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaStream(::windows::core::IUnknown);
impl IMFMediaStream {
    pub unsafe fn GetEvent(&self, dwflags: MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS) -> ::windows::core::Result<IMFMediaEvent> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaEvent>();
        (::windows::core::Interface::vtable(self).base__.GetEvent)(::windows::core::Interface::as_raw(self), dwflags, &mut result__).from_abi(result__)
    }
    pub unsafe fn BeginGetEvent<P0, P1>(&self, pcallback: P0, punkstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.BeginGetEvent)(::windows::core::Interface::as_raw(self), pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    pub unsafe fn EndGetEvent<P0>(&self, presult: P0) -> ::windows::core::Result<IMFMediaEvent>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFMediaEvent>();
        (::windows::core::Interface::vtable(self).base__.EndGetEvent)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn QueueEvent(&self, met: u32, guidextendedtype: *const ::windows::core::GUID, hrstatus: ::windows::core::HRESULT, pvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.QueueEvent)(::windows::core::Interface::as_raw(self), met, guidextendedtype, hrstatus, pvvalue).ok()
    }
    pub unsafe fn GetMediaSource(&self) -> ::windows::core::Result<IMFMediaSource> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaSource>();
        (::windows::core::Interface::vtable(self).GetMediaSource)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStreamDescriptor(&self) -> ::windows::core::Result<IMFStreamDescriptor> {
        let mut result__ = ::windows::core::zeroed::<IMFStreamDescriptor>();
        (::windows::core::Interface::vtable(self).GetStreamDescriptor)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn RequestSample<P0>(&self, ptoken: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).RequestSample)(::windows::core::Interface::as_raw(self), ptoken.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaStream, ::windows::core::IUnknown, IMFMediaEventGenerator);
impl ::core::cmp::PartialEq for IMFMediaStream {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaStream {}
impl ::core::fmt::Debug for IMFMediaStream {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaStream").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaStream {
    type Vtable = IMFMediaStream_Vtbl;
}
impl ::core::clone::Clone for IMFMediaStream {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaStream {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd182108f_4ec6_443f_aa42_a71106ec825f);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaStream_Vtbl {
    pub base__: IMFMediaEventGenerator_Vtbl,
    pub GetMediaSource: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppmediasource: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetStreamDescriptor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppstreamdescriptor: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RequestSample: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ptoken: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaStream2(::windows::core::IUnknown);
impl IMFMediaStream2 {
    pub unsafe fn GetEvent(&self, dwflags: MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS) -> ::windows::core::Result<IMFMediaEvent> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaEvent>();
        (::windows::core::Interface::vtable(self).base__.base__.GetEvent)(::windows::core::Interface::as_raw(self), dwflags, &mut result__).from_abi(result__)
    }
    pub unsafe fn BeginGetEvent<P0, P1>(&self, pcallback: P0, punkstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.BeginGetEvent)(::windows::core::Interface::as_raw(self), pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    pub unsafe fn EndGetEvent<P0>(&self, presult: P0) -> ::windows::core::Result<IMFMediaEvent>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFMediaEvent>();
        (::windows::core::Interface::vtable(self).base__.base__.EndGetEvent)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn QueueEvent(&self, met: u32, guidextendedtype: *const ::windows::core::GUID, hrstatus: ::windows::core::HRESULT, pvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.QueueEvent)(::windows::core::Interface::as_raw(self), met, guidextendedtype, hrstatus, pvvalue).ok()
    }
    pub unsafe fn GetMediaSource(&self) -> ::windows::core::Result<IMFMediaSource> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaSource>();
        (::windows::core::Interface::vtable(self).base__.GetMediaSource)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStreamDescriptor(&self) -> ::windows::core::Result<IMFStreamDescriptor> {
        let mut result__ = ::windows::core::zeroed::<IMFStreamDescriptor>();
        (::windows::core::Interface::vtable(self).base__.GetStreamDescriptor)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn RequestSample<P0>(&self, ptoken: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.RequestSample)(::windows::core::Interface::as_raw(self), ptoken.into_param().abi()).ok()
    }
    pub unsafe fn SetStreamState(&self, value: MF_STREAM_STATE) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetStreamState)(::windows::core::Interface::as_raw(self), value).ok()
    }
    pub unsafe fn GetStreamState(&self) -> ::windows::core::Result<MF_STREAM_STATE> {
        let mut result__ = ::windows::core::zeroed::<MF_STREAM_STATE>();
        (::windows::core::Interface::vtable(self).GetStreamState)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFMediaStream2, ::windows::core::IUnknown, IMFMediaEventGenerator, IMFMediaStream);
impl ::core::cmp::PartialEq for IMFMediaStream2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaStream2 {}
impl ::core::fmt::Debug for IMFMediaStream2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaStream2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaStream2 {
    type Vtable = IMFMediaStream2_Vtbl;
}
impl ::core::clone::Clone for IMFMediaStream2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaStream2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc5bc37d6_75c7_46a1_a132_81b5f723c20f);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaStream2_Vtbl {
    pub base__: IMFMediaStream_Vtbl,
    pub SetStreamState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, value: MF_STREAM_STATE) -> ::windows::core::HRESULT,
    pub GetStreamState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, value: *mut MF_STREAM_STATE) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaStreamSourceSampleRequest(::windows::core::IUnknown);
impl IMFMediaStreamSourceSampleRequest {
    pub unsafe fn SetSample<P0>(&self, value: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFSample>,
    {
        (::windows::core::Interface::vtable(self).SetSample)(::windows::core::Interface::as_raw(self), value.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaStreamSourceSampleRequest, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaStreamSourceSampleRequest {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaStreamSourceSampleRequest {}
impl ::core::fmt::Debug for IMFMediaStreamSourceSampleRequest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaStreamSourceSampleRequest").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaStreamSourceSampleRequest {
    type Vtable = IMFMediaStreamSourceSampleRequest_Vtbl;
}
impl ::core::clone::Clone for IMFMediaStreamSourceSampleRequest {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaStreamSourceSampleRequest {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x380b9af9_a85b_4e78_a2af_ea5ce645c6b4);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaStreamSourceSampleRequest_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetSample: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, value: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaTimeRange(::windows::core::IUnknown);
impl IMFMediaTimeRange {
    pub unsafe fn GetLength(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetLength)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetStart(&self, index: u32) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).GetStart)(::windows::core::Interface::as_raw(self), index, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetEnd(&self, index: u32) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).GetEnd)(::windows::core::Interface::as_raw(self), index, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn ContainsTime(&self, time: f64) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).ContainsTime)(::windows::core::Interface::as_raw(self), time)
    }
    pub unsafe fn AddRange(&self, starttime: f64, endtime: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).AddRange)(::windows::core::Interface::as_raw(self), starttime, endtime).ok()
    }
    pub unsafe fn Clear(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Clear)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaTimeRange, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaTimeRange {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaTimeRange {}
impl ::core::fmt::Debug for IMFMediaTimeRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaTimeRange").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaTimeRange {
    type Vtable = IMFMediaTimeRange_Vtbl;
}
impl ::core::clone::Clone for IMFMediaTimeRange {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaTimeRange {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdb71a2fc_078a_414e_9df9_8c2531b0aa6c);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaTimeRange_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetLength: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetStart: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, pstart: *mut f64) -> ::windows::core::HRESULT,
    pub GetEnd: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, pend: *mut f64) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub ContainsTime: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, time: f64) -> super::super::Foundation::BOOL,
    #[cfg(not(feature = "Win32_Foundation"))]
    ContainsTime: usize,
    pub AddRange: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, starttime: f64, endtime: f64) -> ::windows::core::HRESULT,
    pub Clear: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaType(::windows::core::IUnknown);
impl IMFMediaType {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItem(&self, guidkey: *const ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItem)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetItemType(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<MF_ATTRIBUTE_TYPE> {
        let mut result__ = ::windows::core::zeroed::<MF_ATTRIBUTE_TYPE>();
        (::windows::core::Interface::vtable(self).base__.GetItemType)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn CompareItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.CompareItem)(::windows::core::Interface::as_raw(self), guidkey, value, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Compare<P0>(&self, ptheirs: P0, matchtype: MF_ATTRIBUTES_MATCH_TYPE) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.Compare)(::windows::core::Interface::as_raw(self), ptheirs.into_param().abi(), matchtype, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT32(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetUINT32)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT64(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).base__.GetUINT64)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDouble(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).base__.GetDouble)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetGUID(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).base__.GetGUID)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStringLength(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetStringLength)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetString(&self, guidkey: *const ::windows::core::GUID, pwszvalue: &mut [u16], pcchlength: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetString)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pwszvalue.as_ptr()), pwszvalue.len() as _, ::core::mem::transmute(pcchlength.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedString(&self, guidkey: *const ::windows::core::GUID, ppwszvalue: *mut ::windows::core::PWSTR, pcchlength: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedString)(::windows::core::Interface::as_raw(self), guidkey, ppwszvalue, pcchlength).ok()
    }
    pub unsafe fn GetBlobSize(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetBlobSize)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &mut [u8], pcbblobsize: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _, ::core::mem::transmute(pcbblobsize.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedBlob(&self, guidkey: *const ::windows::core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedBlob)(::windows::core::Interface::as_raw(self), guidkey, ppbuf, pcbsize).ok()
    }
    pub unsafe fn GetUnknown<T>(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.GetUnknown)(::windows::core::Interface::as_raw(self), guidkey, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetItem)(::windows::core::Interface::as_raw(self), guidkey, value).ok()
    }
    pub unsafe fn DeleteItem(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteItem)(::windows::core::Interface::as_raw(self), guidkey).ok()
    }
    pub unsafe fn DeleteAllItems(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteAllItems)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetUINT32(&self, guidkey: *const ::windows::core::GUID, unvalue: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT32)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetUINT64(&self, guidkey: *const ::windows::core::GUID, unvalue: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT64)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetDouble(&self, guidkey: *const ::windows::core::GUID, fvalue: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetDouble)(::windows::core::Interface::as_raw(self), guidkey, fvalue).ok()
    }
    pub unsafe fn SetGUID(&self, guidkey: *const ::windows::core::GUID, guidvalue: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetGUID)(::windows::core::Interface::as_raw(self), guidkey, guidvalue).ok()
    }
    pub unsafe fn SetString<P0>(&self, guidkey: *const ::windows::core::GUID, wszvalue: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.SetString)(::windows::core::Interface::as_raw(self), guidkey, wszvalue.into_param().abi()).ok()
    }
    pub unsafe fn SetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _).ok()
    }
    pub unsafe fn SetUnknown<P0>(&self, guidkey: *const ::windows::core::GUID, punknown: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.SetUnknown)(::windows::core::Interface::as_raw(self), guidkey, punknown.into_param().abi()).ok()
    }
    pub unsafe fn LockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.LockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn UnlockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.UnlockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItemByIndex(&self, unindex: u32, pguidkey: *mut ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItemByIndex)(::windows::core::Interface::as_raw(self), unindex, pguidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn CopyAllItems<P0>(&self, pdest: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).base__.CopyAllItems)(::windows::core::Interface::as_raw(self), pdest.into_param().abi()).ok()
    }
    pub unsafe fn GetMajorType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).GetMajorType)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsCompressedFormat(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).IsCompressedFormat)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn IsEqual<P0>(&self, pimediatype: P0) -> ::windows::core::Result<u32>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).IsEqual)(::windows::core::Interface::as_raw(self), pimediatype.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetRepresentation(&self, guidrepresentation: ::windows::core::GUID, ppvrepresentation: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetRepresentation)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(guidrepresentation), ppvrepresentation).ok()
    }
    pub unsafe fn FreeRepresentation(&self, guidrepresentation: ::windows::core::GUID, pvrepresentation: *const ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).FreeRepresentation)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(guidrepresentation), pvrepresentation).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFMediaType, ::windows::core::IUnknown, IMFAttributes);
impl ::core::cmp::PartialEq for IMFMediaType {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaType {}
impl ::core::fmt::Debug for IMFMediaType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaType").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaType {
    type Vtable = IMFMediaType_Vtbl;
}
impl ::core::clone::Clone for IMFMediaType {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaType {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x44ae0fa8_ea31_4109_8d2e_4cae4997c555);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaType_Vtbl {
    pub base__: IMFAttributes_Vtbl,
    pub GetMajorType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pguidmajortype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub IsCompressedFormat: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pfcompressed: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsCompressedFormat: usize,
    pub IsEqual: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pimediatype: *mut ::core::ffi::c_void, pdwflags: *mut u32) -> ::windows::core::HRESULT,
    pub GetRepresentation: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidrepresentation: ::windows::core::GUID, ppvrepresentation: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub FreeRepresentation: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidrepresentation: ::windows::core::GUID, pvrepresentation: *const ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMediaTypeHandler(::windows::core::IUnknown);
impl IMFMediaTypeHandler {
    pub unsafe fn IsMediaTypeSupported<P0>(&self, pmediatype: P0, ppmediatype: ::core::option::Option<*mut ::core::option::Option<IMFMediaType>>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        (::windows::core::Interface::vtable(self).IsMediaTypeSupported)(::windows::core::Interface::as_raw(self), pmediatype.into_param().abi(), ::core::mem::transmute(ppmediatype.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetMediaTypeCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetMediaTypeCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetMediaTypeByIndex(&self, dwindex: u32) -> ::windows::core::Result<IMFMediaType> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
        (::windows::core::Interface::vtable(self).GetMediaTypeByIndex)(::windows::core::Interface::as_raw(self), dwindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetCurrentMediaType<P0>(&self, pmediatype: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        (::windows::core::Interface::vtable(self).SetCurrentMediaType)(::windows::core::Interface::as_raw(self), pmediatype.into_param().abi()).ok()
    }
    pub unsafe fn GetCurrentMediaType(&self) -> ::windows::core::Result<IMFMediaType> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
        (::windows::core::Interface::vtable(self).GetCurrentMediaType)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetMajorType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).GetMajorType)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFMediaTypeHandler, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMediaTypeHandler {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMediaTypeHandler {}
impl ::core::fmt::Debug for IMFMediaTypeHandler {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMediaTypeHandler").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMediaTypeHandler {
    type Vtable = IMFMediaTypeHandler_Vtbl;
}
impl ::core::clone::Clone for IMFMediaTypeHandler {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMediaTypeHandler {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe93dcf6c_4b07_4e1e_8123_aa16ed6eadf5);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMediaTypeHandler_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub IsMediaTypeSupported: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pmediatype: *mut ::core::ffi::c_void, ppmediatype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetMediaTypeCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwtypecount: *mut u32) -> ::windows::core::HRESULT,
    pub GetMediaTypeByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwindex: u32, pptype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetCurrentMediaType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pmediatype: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetCurrentMediaType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppmediatype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetMajorType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pguidmajortype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMetadata(::windows::core::IUnknown);
impl IMFMetadata {
    pub unsafe fn SetLanguage<P0>(&self, pwszrfc1766: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).SetLanguage)(::windows::core::Interface::as_raw(self), pwszrfc1766.into_param().abi()).ok()
    }
    pub unsafe fn GetLanguage(&self) -> ::windows::core::Result<::windows::core::PWSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::PWSTR>();
        (::windows::core::Interface::vtable(self).GetLanguage)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetAllLanguages(&self) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT> {
        let mut result__ = ::windows::core::zeroed::<super::super::System::Com::StructuredStorage::PROPVARIANT>();
        (::windows::core::Interface::vtable(self).GetAllLanguages)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetProperty<P0>(&self, pwszname: P0, ppvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).SetProperty)(::windows::core::Interface::as_raw(self), pwszname.into_param().abi(), ppvvalue).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetProperty<P0>(&self, pwszname: P0) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::System::Com::StructuredStorage::PROPVARIANT>();
        (::windows::core::Interface::vtable(self).GetProperty)(::windows::core::Interface::as_raw(self), pwszname.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn DeleteProperty<P0>(&self, pwszname: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).DeleteProperty)(::windows::core::Interface::as_raw(self), pwszname.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetAllPropertyNames(&self) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT> {
        let mut result__ = ::windows::core::zeroed::<super::super::System::Com::StructuredStorage::PROPVARIANT>();
        (::windows::core::Interface::vtable(self).GetAllPropertyNames)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFMetadata, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMetadata {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMetadata {}
impl ::core::fmt::Debug for IMFMetadata {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMetadata").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMetadata {
    type Vtable = IMFMetadata_Vtbl;
}
impl ::core::clone::Clone for IMFMetadata {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMetadata {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf88cfb8c_ef16_4991_b450_cb8c69e51704);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMetadata_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetLanguage: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pwszrfc1766: ::windows::core::PCWSTR) -> ::windows::core::HRESULT,
    pub GetLanguage: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppwszrfc1766: *mut ::windows::core::PWSTR) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub GetAllLanguages: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppvlanguages: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    GetAllLanguages: usize,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub SetProperty: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pwszname: ::windows::core::PCWSTR, ppvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    SetProperty: usize,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub GetProperty: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pwszname: ::windows::core::PCWSTR, ppvvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    GetProperty: usize,
    pub DeleteProperty: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pwszname: ::windows::core::PCWSTR) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub GetAllPropertyNames: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppvnames: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    GetAllPropertyNames: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMetadataProvider(::windows::core::IUnknown);
impl IMFMetadataProvider {
    pub unsafe fn GetMFMetadata<P0>(&self, ppresentationdescriptor: P0, dwstreamidentifier: u32, dwflags: u32) -> ::windows::core::Result<IMFMetadata>
    where
        P0: ::windows::core::IntoParam<IMFPresentationDescriptor>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFMetadata>();
        (::windows::core::Interface::vtable(self).GetMFMetadata)(::windows::core::Interface::as_raw(self), ppresentationdescriptor.into_param().abi(), dwstreamidentifier, dwflags, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFMetadataProvider, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMetadataProvider {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMetadataProvider {}
impl ::core::fmt::Debug for IMFMetadataProvider {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMetadataProvider").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMetadataProvider {
    type Vtable = IMFMetadataProvider_Vtbl;
}
impl ::core::clone::Clone for IMFMetadataProvider {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMetadataProvider {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x56181d2d_e221_4adb_b1c8_3cee6a53f76f);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMetadataProvider_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetMFMetadata: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppresentationdescriptor: *mut ::core::ffi::c_void, dwstreamidentifier: u32, dwflags: u32, ppmfmetadata: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMuxStreamAttributesManager(::windows::core::IUnknown);
impl IMFMuxStreamAttributesManager {
    pub unsafe fn GetStreamCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetStreamCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetAttributes(&self, dwmuxstreamindex: u32) -> ::windows::core::Result<IMFAttributes> {
        let mut result__ = ::windows::core::zeroed::<IMFAttributes>();
        (::windows::core::Interface::vtable(self).GetAttributes)(::windows::core::Interface::as_raw(self), dwmuxstreamindex, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFMuxStreamAttributesManager, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMuxStreamAttributesManager {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMuxStreamAttributesManager {}
impl ::core::fmt::Debug for IMFMuxStreamAttributesManager {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMuxStreamAttributesManager").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMuxStreamAttributesManager {
    type Vtable = IMFMuxStreamAttributesManager_Vtbl;
}
impl ::core::clone::Clone for IMFMuxStreamAttributesManager {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMuxStreamAttributesManager {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xce8bd576_e440_43b3_be34_1e53f565f7e8);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMuxStreamAttributesManager_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetStreamCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwmuxstreamcount: *mut u32) -> ::windows::core::HRESULT,
    pub GetAttributes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwmuxstreamindex: u32, ppstreamattributes: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMuxStreamMediaTypeManager(::windows::core::IUnknown);
impl IMFMuxStreamMediaTypeManager {
    pub unsafe fn GetStreamCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetStreamCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetMediaType(&self, dwmuxstreamindex: u32) -> ::windows::core::Result<IMFMediaType> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
        (::windows::core::Interface::vtable(self).GetMediaType)(::windows::core::Interface::as_raw(self), dwmuxstreamindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStreamConfigurationCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetStreamConfigurationCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn AddStreamConfiguration(&self, ullstreammask: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).AddStreamConfiguration)(::windows::core::Interface::as_raw(self), ullstreammask).ok()
    }
    pub unsafe fn RemoveStreamConfiguration(&self, ullstreammask: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveStreamConfiguration)(::windows::core::Interface::as_raw(self), ullstreammask).ok()
    }
    pub unsafe fn GetStreamConfiguration(&self, ulindex: u32) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).GetStreamConfiguration)(::windows::core::Interface::as_raw(self), ulindex, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFMuxStreamMediaTypeManager, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMuxStreamMediaTypeManager {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMuxStreamMediaTypeManager {}
impl ::core::fmt::Debug for IMFMuxStreamMediaTypeManager {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMuxStreamMediaTypeManager").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMuxStreamMediaTypeManager {
    type Vtable = IMFMuxStreamMediaTypeManager_Vtbl;
}
impl ::core::clone::Clone for IMFMuxStreamMediaTypeManager {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMuxStreamMediaTypeManager {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x505a2c72_42f7_4690_aeab_8f513d0ffdb8);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMuxStreamMediaTypeManager_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetStreamCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwmuxstreamcount: *mut u32) -> ::windows::core::HRESULT,
    pub GetMediaType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwmuxstreamindex: u32, ppmediatype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetStreamConfigurationCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwcount: *mut u32) -> ::windows::core::HRESULT,
    pub AddStreamConfiguration: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ullstreammask: u64) -> ::windows::core::HRESULT,
    pub RemoveStreamConfiguration: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ullstreammask: u64) -> ::windows::core::HRESULT,
    pub GetStreamConfiguration: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ulindex: u32, pullstreammask: *mut u64) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFMuxStreamSampleManager(::windows::core::IUnknown);
impl IMFMuxStreamSampleManager {
    pub unsafe fn GetStreamCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetStreamCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetSample(&self, dwmuxstreamindex: u32) -> ::windows::core::Result<IMFSample> {
        let mut result__ = ::windows::core::zeroed::<IMFSample>();
        (::windows::core::Interface::vtable(self).GetSample)(::windows::core::Interface::as_raw(self), dwmuxstreamindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStreamConfiguration(&self) -> u64 {
        (::windows::core::Interface::vtable(self).GetStreamConfiguration)(::windows::core::Interface::as_raw(self))
    }
}
::windows::imp::interface_hierarchy!(IMFMuxStreamSampleManager, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFMuxStreamSampleManager {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFMuxStreamSampleManager {}
impl ::core::fmt::Debug for IMFMuxStreamSampleManager {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFMuxStreamSampleManager").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFMuxStreamSampleManager {
    type Vtable = IMFMuxStreamSampleManager_Vtbl;
}
impl ::core::clone::Clone for IMFMuxStreamSampleManager {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFMuxStreamSampleManager {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x74abbc19_b1cc_4e41_bb8b_9d9b86a8f6ca);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFMuxStreamSampleManager_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetStreamCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwmuxstreamcount: *mut u32) -> ::windows::core::HRESULT,
    pub GetSample: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwmuxstreamindex: u32, ppsample: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetStreamConfiguration: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u64,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFNetCredential(::windows::core::IUnknown);
impl IMFNetCredential {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetUser<P0>(&self, pbdata: &[u8], fdataisencrypted: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetUser)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pbdata.as_ptr()), pbdata.len() as _, fdataisencrypted.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetPassword<P0>(&self, pbdata: &[u8], fdataisencrypted: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetPassword)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pbdata.as_ptr()), pbdata.len() as _, fdataisencrypted.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetUser<P0>(&self, pbdata: ::core::option::Option<*mut u8>, pcbdata: *mut u32, fencryptdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).GetUser)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pbdata.unwrap_or(::std::ptr::null_mut())), pcbdata, fencryptdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetPassword<P0>(&self, pbdata: ::core::option::Option<*mut u8>, pcbdata: *mut u32, fencryptdata: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).GetPassword)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pbdata.unwrap_or(::std::ptr::null_mut())), pcbdata, fencryptdata.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn LoggedOnUser(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).LoggedOnUser)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFNetCredential, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFNetCredential {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFNetCredential {}
impl ::core::fmt::Debug for IMFNetCredential {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFNetCredential").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFNetCredential {
    type Vtable = IMFNetCredential_Vtbl;
}
impl ::core::clone::Clone for IMFNetCredential {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFNetCredential {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5b87ef6a_7ed8_434f_ba0e_184fac1628d1);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFNetCredential_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub SetUser: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbdata: *const u8, cbdata: u32, fdataisencrypted: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetUser: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub SetPassword: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbdata: *const u8, cbdata: u32, fdataisencrypted: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetPassword: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub GetUser: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbdata: *mut u8, pcbdata: *mut u32, fencryptdata: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetUser: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub GetPassword: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbdata: *mut u8, pcbdata: *mut u32, fencryptdata: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetPassword: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub LoggedOnUser: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pfloggedonuser: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    LoggedOnUser: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFNetCredentialCache(::windows::core::IUnknown);
impl IMFNetCredentialCache {
    pub unsafe fn GetCredential<P0, P1>(&self, pszurl: P0, pszrealm: P1, dwauthenticationflags: u32, ppcred: *mut ::core::option::Option<IMFNetCredential>, pdwrequirementsflags: *mut u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).GetCredential)(::windows::core::Interface::as_raw(self), pszurl.into_param().abi(), pszrealm.into_param().abi(), dwauthenticationflags, ::core::mem::transmute(ppcred), pdwrequirementsflags).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetGood<P0, P1>(&self, pcred: P0, fgood: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFNetCredential>,
        P1: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetGood)(::windows::core::Interface::as_raw(self), pcred.into_param().abi(), fgood.into_param().abi()).ok()
    }
    pub unsafe fn SetUserOptions<P0>(&self, pcred: P0, dwoptionsflags: u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFNetCredential>,
    {
        (::windows::core::Interface::vtable(self).SetUserOptions)(::windows::core::Interface::as_raw(self), pcred.into_param().abi(), dwoptionsflags).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFNetCredentialCache, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFNetCredentialCache {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFNetCredentialCache {}
impl ::core::fmt::Debug for IMFNetCredentialCache {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFNetCredentialCache").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFNetCredentialCache {
    type Vtable = IMFNetCredentialCache_Vtbl;
}
impl ::core::clone::Clone for IMFNetCredentialCache {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFNetCredentialCache {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5b87ef6c_7ed8_434f_ba0e_184fac1628d1);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFNetCredentialCache_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetCredential: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pszurl: ::windows::core::PCWSTR, pszrealm: ::windows::core::PCWSTR, dwauthenticationflags: u32, ppcred: *mut *mut ::core::ffi::c_void, pdwrequirementsflags: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub SetGood: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcred: *mut ::core::ffi::c_void, fgood: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetGood: usize,
    pub SetUserOptions: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcred: *mut ::core::ffi::c_void, dwoptionsflags: u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFNetCredentialManager(::windows::core::IUnknown);
impl IMFNetCredentialManager {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn BeginGetCredentials<P0, P1>(&self, pparam: *const MFNetCredentialManagerGetParam, pcallback: P0, pstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginGetCredentials)(::windows::core::Interface::as_raw(self), pparam, pcallback.into_param().abi(), pstate.into_param().abi()).ok()
    }
    pub unsafe fn EndGetCredentials<P0>(&self, presult: P0) -> ::windows::core::Result<IMFNetCredential>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFNetCredential>();
        (::windows::core::Interface::vtable(self).EndGetCredentials)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetGood<P0, P1>(&self, pcred: P0, fgood: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFNetCredential>,
        P1: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetGood)(::windows::core::Interface::as_raw(self), pcred.into_param().abi(), fgood.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFNetCredentialManager, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFNetCredentialManager {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFNetCredentialManager {}
impl ::core::fmt::Debug for IMFNetCredentialManager {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFNetCredentialManager").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFNetCredentialManager {
    type Vtable = IMFNetCredentialManager_Vtbl;
}
impl ::core::clone::Clone for IMFNetCredentialManager {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFNetCredentialManager {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5b87ef6b_7ed8_434f_ba0e_184fac1628d1);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFNetCredentialManager_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub BeginGetCredentials: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pparam: *const MFNetCredentialManagerGetParam, pcallback: *mut ::core::ffi::c_void, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    BeginGetCredentials: usize,
    pub EndGetCredentials: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void, ppcred: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub SetGood: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcred: *mut ::core::ffi::c_void, fgood: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetGood: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFNetCrossOriginSupport(::windows::core::IUnknown);
impl IMFNetCrossOriginSupport {
    pub unsafe fn GetCrossOriginPolicy(&self) -> ::windows::core::Result<MF_CROSS_ORIGIN_POLICY> {
        let mut result__ = ::windows::core::zeroed::<MF_CROSS_ORIGIN_POLICY>();
        (::windows::core::Interface::vtable(self).GetCrossOriginPolicy)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetSourceOrigin(&self) -> ::windows::core::Result<::windows::core::PWSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::PWSTR>();
        (::windows::core::Interface::vtable(self).GetSourceOrigin)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsSameOrigin<P0>(&self, wszurl: P0) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).IsSameOrigin)(::windows::core::Interface::as_raw(self), wszurl.into_param().abi(), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFNetCrossOriginSupport, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFNetCrossOriginSupport {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFNetCrossOriginSupport {}
impl ::core::fmt::Debug for IMFNetCrossOriginSupport {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFNetCrossOriginSupport").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFNetCrossOriginSupport {
    type Vtable = IMFNetCrossOriginSupport_Vtbl;
}
impl ::core::clone::Clone for IMFNetCrossOriginSupport {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFNetCrossOriginSupport {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbc2b7d44_a72d_49d5_8376_1480dee58b22);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFNetCrossOriginSupport_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetCrossOriginPolicy: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppolicy: *mut MF_CROSS_ORIGIN_POLICY) -> ::windows::core::HRESULT,
    pub GetSourceOrigin: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, wszsourceorigin: *mut ::windows::core::PWSTR) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub IsSameOrigin: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, wszurl: ::windows::core::PCWSTR, pfissameorigin: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsSameOrigin: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFNetProxyLocator(::windows::core::IUnknown);
impl IMFNetProxyLocator {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn FindFirstProxy<P0, P1, P2>(&self, pszhost: P0, pszurl: P1, freserved: P2) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P2: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).FindFirstProxy)(::windows::core::Interface::as_raw(self), pszhost.into_param().abi(), pszurl.into_param().abi(), freserved.into_param().abi()).ok()
    }
    pub unsafe fn FindNextProxy(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).FindNextProxy)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn RegisterProxyResult(&self, hrop: ::windows::core::HRESULT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RegisterProxyResult)(::windows::core::Interface::as_raw(self), hrop).ok()
    }
    pub unsafe fn GetCurrentProxy(&self, pszstr: ::windows::core::PWSTR, pcchstr: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetCurrentProxy)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pszstr), pcchstr).ok()
    }
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IMFNetProxyLocator> {
        let mut result__ = ::windows::core::zeroed::<IMFNetProxyLocator>();
        (::windows::core::Interface::vtable(self).Clone)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFNetProxyLocator, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFNetProxyLocator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFNetProxyLocator {}
impl ::core::fmt::Debug for IMFNetProxyLocator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFNetProxyLocator").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFNetProxyLocator {
    type Vtable = IMFNetProxyLocator_Vtbl;
}
impl ::core::clone::Clone for IMFNetProxyLocator {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFNetProxyLocator {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe9cd0383_a268_4bb4_82de_658d53574d41);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFNetProxyLocator_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub FindFirstProxy: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pszhost: ::windows::core::PCWSTR, pszurl: ::windows::core::PCWSTR, freserved: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    FindFirstProxy: usize,
    pub FindNextProxy: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RegisterProxyResult: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hrop: ::windows::core::HRESULT) -> ::windows::core::HRESULT,
    pub GetCurrentProxy: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pszstr: ::windows::core::PWSTR, pcchstr: *mut u32) -> ::windows::core::HRESULT,
    pub Clone: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppproxylocator: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFNetProxyLocatorFactory(::windows::core::IUnknown);
impl IMFNetProxyLocatorFactory {
    pub unsafe fn CreateProxyLocator<P0>(&self, pszprotocol: P0) -> ::windows::core::Result<IMFNetProxyLocator>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFNetProxyLocator>();
        (::windows::core::Interface::vtable(self).CreateProxyLocator)(::windows::core::Interface::as_raw(self), pszprotocol.into_param().abi(), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFNetProxyLocatorFactory, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFNetProxyLocatorFactory {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFNetProxyLocatorFactory {}
impl ::core::fmt::Debug for IMFNetProxyLocatorFactory {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFNetProxyLocatorFactory").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFNetProxyLocatorFactory {
    type Vtable = IMFNetProxyLocatorFactory_Vtbl;
}
impl ::core::clone::Clone for IMFNetProxyLocatorFactory {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFNetProxyLocatorFactory {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe9cd0384_a268_4bb4_82de_658d53574d41);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFNetProxyLocatorFactory_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub CreateProxyLocator: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pszprotocol: ::windows::core::PCWSTR, ppproxylocator: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFNetResourceFilter(::windows::core::IUnknown);
impl IMFNetResourceFilter {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn OnRedirect<P0>(&self, pszurl: P0) -> ::windows::core::Result<super::super::Foundation::VARIANT_BOOL>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::VARIANT_BOOL>();
        (::windows::core::Interface::vtable(self).OnRedirect)(::windows::core::Interface::as_raw(self), pszurl.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn OnSendingRequest<P0>(&self, pszurl: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).OnSendingRequest)(::windows::core::Interface::as_raw(self), pszurl.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFNetResourceFilter, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFNetResourceFilter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFNetResourceFilter {}
impl ::core::fmt::Debug for IMFNetResourceFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFNetResourceFilter").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFNetResourceFilter {
    type Vtable = IMFNetResourceFilter_Vtbl;
}
impl ::core::clone::Clone for IMFNetResourceFilter {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFNetResourceFilter {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x091878a3_bf11_4a5c_bc9f_33995b06ef2d);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFNetResourceFilter_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub OnRedirect: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pszurl: ::windows::core::PCWSTR, pvbcancel: *mut super::super::Foundation::VARIANT_BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    OnRedirect: usize,
    pub OnSendingRequest: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pszurl: ::windows::core::PCWSTR) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFNetSchemeHandlerConfig(::windows::core::IUnknown);
impl IMFNetSchemeHandlerConfig {
    pub unsafe fn GetNumberOfSupportedProtocols(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetNumberOfSupportedProtocols)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetSupportedProtocolType(&self, nprotocolindex: u32) -> ::windows::core::Result<MFNETSOURCE_PROTOCOL_TYPE> {
        let mut result__ = ::windows::core::zeroed::<MFNETSOURCE_PROTOCOL_TYPE>();
        (::windows::core::Interface::vtable(self).GetSupportedProtocolType)(::windows::core::Interface::as_raw(self), nprotocolindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn ResetProtocolRolloverSettings(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ResetProtocolRolloverSettings)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFNetSchemeHandlerConfig, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFNetSchemeHandlerConfig {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFNetSchemeHandlerConfig {}
impl ::core::fmt::Debug for IMFNetSchemeHandlerConfig {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFNetSchemeHandlerConfig").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFNetSchemeHandlerConfig {
    type Vtable = IMFNetSchemeHandlerConfig_Vtbl;
}
impl ::core::clone::Clone for IMFNetSchemeHandlerConfig {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFNetSchemeHandlerConfig {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7be19e73_c9bf_468a_ac5a_a5e8653bec87);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFNetSchemeHandlerConfig_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetNumberOfSupportedProtocols: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcprotocols: *mut u32) -> ::windows::core::HRESULT,
    pub GetSupportedProtocolType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, nprotocolindex: u32, pnprotocoltype: *mut MFNETSOURCE_PROTOCOL_TYPE) -> ::windows::core::HRESULT,
    pub ResetProtocolRolloverSettings: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFObjectReferenceStream(::windows::core::IUnknown);
impl IMFObjectReferenceStream {
    pub unsafe fn SaveReference<P0>(&self, riid: *const ::windows::core::GUID, punk: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).SaveReference)(::windows::core::Interface::as_raw(self), riid, punk.into_param().abi()).ok()
    }
    pub unsafe fn LoadReference(&self, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).LoadReference)(::windows::core::Interface::as_raw(self), riid, ppv).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFObjectReferenceStream, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFObjectReferenceStream {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFObjectReferenceStream {}
impl ::core::fmt::Debug for IMFObjectReferenceStream {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFObjectReferenceStream").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFObjectReferenceStream {
    type Vtable = IMFObjectReferenceStream_Vtbl;
}
impl ::core::clone::Clone for IMFObjectReferenceStream {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFObjectReferenceStream {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x09ef5be3_c8a7_469e_8b70_73bf25bb193f);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFObjectReferenceStream_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SaveReference: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, punk: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub LoadReference: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFOutputPolicy(::windows::core::IUnknown);
impl IMFOutputPolicy {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItem(&self, guidkey: *const ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItem)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetItemType(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<MF_ATTRIBUTE_TYPE> {
        let mut result__ = ::windows::core::zeroed::<MF_ATTRIBUTE_TYPE>();
        (::windows::core::Interface::vtable(self).base__.GetItemType)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn CompareItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.CompareItem)(::windows::core::Interface::as_raw(self), guidkey, value, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Compare<P0>(&self, ptheirs: P0, matchtype: MF_ATTRIBUTES_MATCH_TYPE) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.Compare)(::windows::core::Interface::as_raw(self), ptheirs.into_param().abi(), matchtype, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT32(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetUINT32)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT64(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).base__.GetUINT64)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDouble(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).base__.GetDouble)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetGUID(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).base__.GetGUID)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStringLength(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetStringLength)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetString(&self, guidkey: *const ::windows::core::GUID, pwszvalue: &mut [u16], pcchlength: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetString)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pwszvalue.as_ptr()), pwszvalue.len() as _, ::core::mem::transmute(pcchlength.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedString(&self, guidkey: *const ::windows::core::GUID, ppwszvalue: *mut ::windows::core::PWSTR, pcchlength: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedString)(::windows::core::Interface::as_raw(self), guidkey, ppwszvalue, pcchlength).ok()
    }
    pub unsafe fn GetBlobSize(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetBlobSize)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &mut [u8], pcbblobsize: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _, ::core::mem::transmute(pcbblobsize.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedBlob(&self, guidkey: *const ::windows::core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedBlob)(::windows::core::Interface::as_raw(self), guidkey, ppbuf, pcbsize).ok()
    }
    pub unsafe fn GetUnknown<T>(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.GetUnknown)(::windows::core::Interface::as_raw(self), guidkey, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetItem)(::windows::core::Interface::as_raw(self), guidkey, value).ok()
    }
    pub unsafe fn DeleteItem(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteItem)(::windows::core::Interface::as_raw(self), guidkey).ok()
    }
    pub unsafe fn DeleteAllItems(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteAllItems)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetUINT32(&self, guidkey: *const ::windows::core::GUID, unvalue: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT32)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetUINT64(&self, guidkey: *const ::windows::core::GUID, unvalue: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT64)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetDouble(&self, guidkey: *const ::windows::core::GUID, fvalue: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetDouble)(::windows::core::Interface::as_raw(self), guidkey, fvalue).ok()
    }
    pub unsafe fn SetGUID(&self, guidkey: *const ::windows::core::GUID, guidvalue: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetGUID)(::windows::core::Interface::as_raw(self), guidkey, guidvalue).ok()
    }
    pub unsafe fn SetString<P0>(&self, guidkey: *const ::windows::core::GUID, wszvalue: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.SetString)(::windows::core::Interface::as_raw(self), guidkey, wszvalue.into_param().abi()).ok()
    }
    pub unsafe fn SetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _).ok()
    }
    pub unsafe fn SetUnknown<P0>(&self, guidkey: *const ::windows::core::GUID, punknown: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.SetUnknown)(::windows::core::Interface::as_raw(self), guidkey, punknown.into_param().abi()).ok()
    }
    pub unsafe fn LockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.LockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn UnlockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.UnlockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItemByIndex(&self, unindex: u32, pguidkey: *mut ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItemByIndex)(::windows::core::Interface::as_raw(self), unindex, pguidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn CopyAllItems<P0>(&self, pdest: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).base__.CopyAllItems)(::windows::core::Interface::as_raw(self), pdest.into_param().abi()).ok()
    }
    pub unsafe fn GenerateRequiredSchemas(&self, dwattributes: u32, guidoutputsubtype: ::windows::core::GUID, rgguidprotectionschemassupported: *const ::windows::core::GUID, cprotectionschemassupported: u32) -> ::windows::core::Result<IMFCollection> {
        let mut result__ = ::windows::core::zeroed::<IMFCollection>();
        (::windows::core::Interface::vtable(self).GenerateRequiredSchemas)(::windows::core::Interface::as_raw(self), dwattributes, ::core::mem::transmute(guidoutputsubtype), rgguidprotectionschemassupported, cprotectionschemassupported, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetOriginatorID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).GetOriginatorID)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetMinimumGRLVersion(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetMinimumGRLVersion)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFOutputPolicy, ::windows::core::IUnknown, IMFAttributes);
impl ::core::cmp::PartialEq for IMFOutputPolicy {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFOutputPolicy {}
impl ::core::fmt::Debug for IMFOutputPolicy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFOutputPolicy").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFOutputPolicy {
    type Vtable = IMFOutputPolicy_Vtbl;
}
impl ::core::clone::Clone for IMFOutputPolicy {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFOutputPolicy {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7f00f10a_daed_41af_ab26_5fdfa4dfba3c);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFOutputPolicy_Vtbl {
    pub base__: IMFAttributes_Vtbl,
    pub GenerateRequiredSchemas: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwattributes: u32, guidoutputsubtype: ::windows::core::GUID, rgguidprotectionschemassupported: *const ::windows::core::GUID, cprotectionschemassupported: u32, pprequiredprotectionschemas: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetOriginatorID: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pguidoriginatorid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub GetMinimumGRLVersion: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwminimumgrlversion: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFOutputSchema(::windows::core::IUnknown);
impl IMFOutputSchema {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItem(&self, guidkey: *const ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItem)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetItemType(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<MF_ATTRIBUTE_TYPE> {
        let mut result__ = ::windows::core::zeroed::<MF_ATTRIBUTE_TYPE>();
        (::windows::core::Interface::vtable(self).base__.GetItemType)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn CompareItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.CompareItem)(::windows::core::Interface::as_raw(self), guidkey, value, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Compare<P0>(&self, ptheirs: P0, matchtype: MF_ATTRIBUTES_MATCH_TYPE) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.Compare)(::windows::core::Interface::as_raw(self), ptheirs.into_param().abi(), matchtype, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT32(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetUINT32)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT64(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).base__.GetUINT64)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDouble(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).base__.GetDouble)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetGUID(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).base__.GetGUID)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStringLength(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetStringLength)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetString(&self, guidkey: *const ::windows::core::GUID, pwszvalue: &mut [u16], pcchlength: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetString)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pwszvalue.as_ptr()), pwszvalue.len() as _, ::core::mem::transmute(pcchlength.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedString(&self, guidkey: *const ::windows::core::GUID, ppwszvalue: *mut ::windows::core::PWSTR, pcchlength: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedString)(::windows::core::Interface::as_raw(self), guidkey, ppwszvalue, pcchlength).ok()
    }
    pub unsafe fn GetBlobSize(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetBlobSize)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &mut [u8], pcbblobsize: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _, ::core::mem::transmute(pcbblobsize.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedBlob(&self, guidkey: *const ::windows::core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedBlob)(::windows::core::Interface::as_raw(self), guidkey, ppbuf, pcbsize).ok()
    }
    pub unsafe fn GetUnknown<T>(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.GetUnknown)(::windows::core::Interface::as_raw(self), guidkey, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetItem)(::windows::core::Interface::as_raw(self), guidkey, value).ok()
    }
    pub unsafe fn DeleteItem(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteItem)(::windows::core::Interface::as_raw(self), guidkey).ok()
    }
    pub unsafe fn DeleteAllItems(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteAllItems)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetUINT32(&self, guidkey: *const ::windows::core::GUID, unvalue: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT32)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetUINT64(&self, guidkey: *const ::windows::core::GUID, unvalue: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT64)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetDouble(&self, guidkey: *const ::windows::core::GUID, fvalue: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetDouble)(::windows::core::Interface::as_raw(self), guidkey, fvalue).ok()
    }
    pub unsafe fn SetGUID(&self, guidkey: *const ::windows::core::GUID, guidvalue: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetGUID)(::windows::core::Interface::as_raw(self), guidkey, guidvalue).ok()
    }
    pub unsafe fn SetString<P0>(&self, guidkey: *const ::windows::core::GUID, wszvalue: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.SetString)(::windows::core::Interface::as_raw(self), guidkey, wszvalue.into_param().abi()).ok()
    }
    pub unsafe fn SetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _).ok()
    }
    pub unsafe fn SetUnknown<P0>(&self, guidkey: *const ::windows::core::GUID, punknown: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.SetUnknown)(::windows::core::Interface::as_raw(self), guidkey, punknown.into_param().abi()).ok()
    }
    pub unsafe fn LockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.LockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn UnlockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.UnlockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItemByIndex(&self, unindex: u32, pguidkey: *mut ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItemByIndex)(::windows::core::Interface::as_raw(self), unindex, pguidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn CopyAllItems<P0>(&self, pdest: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).base__.CopyAllItems)(::windows::core::Interface::as_raw(self), pdest.into_param().abi()).ok()
    }
    pub unsafe fn GetSchemaType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).GetSchemaType)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetConfigurationData(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetConfigurationData)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetOriginatorID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).GetOriginatorID)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFOutputSchema, ::windows::core::IUnknown, IMFAttributes);
impl ::core::cmp::PartialEq for IMFOutputSchema {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFOutputSchema {}
impl ::core::fmt::Debug for IMFOutputSchema {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFOutputSchema").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFOutputSchema {
    type Vtable = IMFOutputSchema_Vtbl;
}
impl ::core::clone::Clone for IMFOutputSchema {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFOutputSchema {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7be0fc5b_abd9_44fb_a5c8_f50136e71599);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFOutputSchema_Vtbl {
    pub base__: IMFAttributes_Vtbl,
    pub GetSchemaType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pguidschematype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub GetConfigurationData: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT,
    pub GetOriginatorID: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pguidoriginatorid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFOutputTrustAuthority(::windows::core::IUnknown);
impl IMFOutputTrustAuthority {
    pub unsafe fn GetAction(&self) -> ::windows::core::Result<MFPOLICYMANAGER_ACTION> {
        let mut result__ = ::windows::core::zeroed::<MFPOLICYMANAGER_ACTION>();
        (::windows::core::Interface::vtable(self).GetAction)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetPolicy(&self, pppolicy: ::core::option::Option<&[::core::option::Option<IMFOutputPolicy>]>, ppbticket: ::core::option::Option<*mut *mut u8>, pcbticket: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetPolicy)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pppolicy.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr())), pppolicy.as_deref().map_or(0, |slice| slice.len() as _), ::core::mem::transmute(ppbticket.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(pcbticket.unwrap_or(::std::ptr::null_mut()))).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFOutputTrustAuthority, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFOutputTrustAuthority {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFOutputTrustAuthority {}
impl ::core::fmt::Debug for IMFOutputTrustAuthority {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFOutputTrustAuthority").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFOutputTrustAuthority {
    type Vtable = IMFOutputTrustAuthority_Vtbl;
}
impl ::core::clone::Clone for IMFOutputTrustAuthority {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFOutputTrustAuthority {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd19f8e94_b126_4446_890c_5dcb7ad71453);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFOutputTrustAuthority_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetAction: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, paction: *mut MFPOLICYMANAGER_ACTION) -> ::windows::core::HRESULT,
    pub SetPolicy: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pppolicy: *const *mut ::core::ffi::c_void, npolicy: u32, ppbticket: *mut *mut u8, pcbticket: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFPMPClient(::windows::core::IUnknown);
impl IMFPMPClient {
    pub unsafe fn SetPMPHost<P0>(&self, ppmphost: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFPMPHost>,
    {
        (::windows::core::Interface::vtable(self).SetPMPHost)(::windows::core::Interface::as_raw(self), ppmphost.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFPMPClient, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFPMPClient {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFPMPClient {}
impl ::core::fmt::Debug for IMFPMPClient {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFPMPClient").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFPMPClient {
    type Vtable = IMFPMPClient_Vtbl;
}
impl ::core::clone::Clone for IMFPMPClient {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFPMPClient {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6c4e655d_ead8_4421_b6b9_54dcdbbdf820);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFPMPClient_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetPMPHost: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppmphost: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFPMPClientApp(::windows::core::IUnknown);
impl IMFPMPClientApp {
    pub unsafe fn SetPMPHost<P0>(&self, ppmphost: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFPMPHostApp>,
    {
        (::windows::core::Interface::vtable(self).SetPMPHost)(::windows::core::Interface::as_raw(self), ppmphost.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFPMPClientApp, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFPMPClientApp {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFPMPClientApp {}
impl ::core::fmt::Debug for IMFPMPClientApp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFPMPClientApp").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFPMPClientApp {
    type Vtable = IMFPMPClientApp_Vtbl;
}
impl ::core::clone::Clone for IMFPMPClientApp {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFPMPClientApp {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc004f646_be2c_48f3_93a2_a0983eba1108);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFPMPClientApp_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetPMPHost: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppmphost: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFPMPHost(::windows::core::IUnknown);
impl IMFPMPHost {
    pub unsafe fn LockProcess(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).LockProcess)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn UnlockProcess(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).UnlockProcess)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn CreateObjectByCLSID<P0, T>(&self, clsid: *const ::windows::core::GUID, pstream: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<super::super::System::Com::IStream>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateObjectByCLSID)(::windows::core::Interface::as_raw(self), clsid, pstream.into_param().abi(), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFPMPHost, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFPMPHost {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFPMPHost {}
impl ::core::fmt::Debug for IMFPMPHost {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFPMPHost").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFPMPHost {
    type Vtable = IMFPMPHost_Vtbl;
}
impl ::core::clone::Clone for IMFPMPHost {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFPMPHost {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf70ca1a9_fdc7_4782_b994_adffb1c98606);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFPMPHost_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub LockProcess: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub UnlockProcess: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_System_Com")]
    pub CreateObjectByCLSID: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, clsid: *const ::windows::core::GUID, pstream: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    CreateObjectByCLSID: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFPMPHostApp(::windows::core::IUnknown);
impl IMFPMPHostApp {
    pub unsafe fn LockProcess(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).LockProcess)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn UnlockProcess(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).UnlockProcess)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_System_Com\"`*"]
    #[cfg(feature = "Win32_System_Com")]
    pub unsafe fn ActivateClassById<P0, P1, T>(&self, id: P0, pstream: P1) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P1: ::windows::core::IntoParam<super::super::System::Com::IStream>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).ActivateClassById)(::windows::core::Interface::as_raw(self), id.into_param().abi(), pstream.into_param().abi(), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFPMPHostApp, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFPMPHostApp {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFPMPHostApp {}
impl ::core::fmt::Debug for IMFPMPHostApp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFPMPHostApp").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFPMPHostApp {
    type Vtable = IMFPMPHostApp_Vtbl;
}
impl ::core::clone::Clone for IMFPMPHostApp {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFPMPHostApp {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x84d2054a_3aa1_4728_a3b0_440a418cf49c);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFPMPHostApp_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub LockProcess: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub UnlockProcess: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_System_Com")]
    pub ActivateClassById: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, id: ::windows::core::PCWSTR, pstream: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_System_Com"))]
    ActivateClassById: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFPMPServer(::windows::core::IUnknown);
impl IMFPMPServer {
    pub unsafe fn LockProcess(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).LockProcess)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn UnlockProcess(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).UnlockProcess)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn CreateObjectByCLSID<T>(&self, clsid: *const ::windows::core::GUID) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateObjectByCLSID)(::windows::core::Interface::as_raw(self), clsid, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFPMPServer, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFPMPServer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFPMPServer {}
impl ::core::fmt::Debug for IMFPMPServer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFPMPServer").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFPMPServer {
    type Vtable = IMFPMPServer_Vtbl;
}
impl ::core::clone::Clone for IMFPMPServer {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFPMPServer {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x994e23af_1cc2_493c_b9fa_46f1cb040fa4);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFPMPServer_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub LockProcess: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub UnlockProcess: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub CreateObjectByCLSID: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, clsid: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFPMediaItem(::windows::core::IUnknown);
impl IMFPMediaItem {
    pub unsafe fn GetMediaPlayer(&self) -> ::windows::core::Result<IMFPMediaPlayer> {
        let mut result__ = ::windows::core::zeroed::<IMFPMediaPlayer>();
        (::windows::core::Interface::vtable(self).GetMediaPlayer)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetURL(&self) -> ::windows::core::Result<::windows::core::PWSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::PWSTR>();
        (::windows::core::Interface::vtable(self).GetURL)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetObject(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::IUnknown>();
        (::windows::core::Interface::vtable(self).GetObject)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUserData(&self) -> ::windows::core::Result<usize> {
        let mut result__ = ::windows::core::zeroed::<usize>();
        (::windows::core::Interface::vtable(self).GetUserData)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetUserData(&self, dwuserdata: usize) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetUserData)(::windows::core::Interface::as_raw(self), dwuserdata).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetStartStopPosition(&self, pguidstartpositiontype: ::core::option::Option<*mut ::windows::core::GUID>, pvstartvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>, pguidstoppositiontype: ::core::option::Option<*mut ::windows::core::GUID>, pvstopvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetStartStopPosition)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pguidstartpositiontype.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(pvstartvalue.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(pguidstoppositiontype.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(pvstopvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetStartStopPosition(&self, pguidstartpositiontype: ::core::option::Option<*const ::windows::core::GUID>, pvstartvalue: ::core::option::Option<*const super::super::System::Com::StructuredStorage::PROPVARIANT>, pguidstoppositiontype: ::core::option::Option<*const ::windows::core::GUID>, pvstopvalue: ::core::option::Option<*const super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetStartStopPosition)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pguidstartpositiontype.unwrap_or(::std::ptr::null())), ::core::mem::transmute(pvstartvalue.unwrap_or(::std::ptr::null())), ::core::mem::transmute(pguidstoppositiontype.unwrap_or(::std::ptr::null())), ::core::mem::transmute(pvstopvalue.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn HasVideo(&self, pfhasvideo: ::core::option::Option<*mut super::super::Foundation::BOOL>, pfselected: ::core::option::Option<*mut super::super::Foundation::BOOL>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).HasVideo)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pfhasvideo.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(pfselected.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn HasAudio(&self, pfhasaudio: ::core::option::Option<*mut super::super::Foundation::BOOL>, pfselected: ::core::option::Option<*mut super::super::Foundation::BOOL>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).HasAudio)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pfhasaudio.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(pfselected.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsProtected(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).IsProtected)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetDuration(&self, guidpositiontype: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT> {
        let mut result__ = ::windows::core::zeroed::<super::super::System::Com::StructuredStorage::PROPVARIANT>();
        (::windows::core::Interface::vtable(self).GetDuration)(::windows::core::Interface::as_raw(self), guidpositiontype, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetNumberOfStreams(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetNumberOfStreams)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetStreamSelection(&self, dwstreamindex: u32) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).GetStreamSelection)(::windows::core::Interface::as_raw(self), dwstreamindex, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetStreamSelection<P0>(&self, dwstreamindex: u32, fenabled: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetStreamSelection)(::windows::core::Interface::as_raw(self), dwstreamindex, fenabled.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetStreamAttribute(&self, dwstreamindex: u32, guidmfattribute: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT> {
        let mut result__ = ::windows::core::zeroed::<super::super::System::Com::StructuredStorage::PROPVARIANT>();
        (::windows::core::Interface::vtable(self).GetStreamAttribute)(::windows::core::Interface::as_raw(self), dwstreamindex, guidmfattribute, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetPresentationAttribute(&self, guidmfattribute: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT> {
        let mut result__ = ::windows::core::zeroed::<super::super::System::Com::StructuredStorage::PROPVARIANT>();
        (::windows::core::Interface::vtable(self).GetPresentationAttribute)(::windows::core::Interface::as_raw(self), guidmfattribute, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetCharacteristics(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetCharacteristics)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetStreamSink<P0>(&self, dwstreamindex: u32, pmediasink: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).SetStreamSink)(::windows::core::Interface::as_raw(self), dwstreamindex, pmediasink.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_UI_Shell_PropertiesSystem\"`*"]
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub unsafe fn GetMetadata(&self) -> ::windows::core::Result<super::super::UI::Shell::PropertiesSystem::IPropertyStore> {
        let mut result__ = ::windows::core::zeroed::<super::super::UI::Shell::PropertiesSystem::IPropertyStore>();
        (::windows::core::Interface::vtable(self).GetMetadata)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFPMediaItem, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFPMediaItem {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFPMediaItem {}
impl ::core::fmt::Debug for IMFPMediaItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFPMediaItem").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFPMediaItem {
    type Vtable = IMFPMediaItem_Vtbl;
}
impl ::core::clone::Clone for IMFPMediaItem {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFPMediaItem {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x90eb3e6b_ecbf_45cc_b1da_c6fe3ea70d57);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFPMediaItem_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetMediaPlayer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppmediaplayer: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetURL: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppwszurl: *mut ::windows::core::PWSTR) -> ::windows::core::HRESULT,
    pub GetObject: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppiunknown: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetUserData: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwuserdata: *mut usize) -> ::windows::core::HRESULT,
    pub SetUserData: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwuserdata: usize) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub GetStartStopPosition: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pguidstartpositiontype: *mut ::windows::core::GUID, pvstartvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT, pguidstoppositiontype: *mut ::windows::core::GUID, pvstopvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    GetStartStopPosition: usize,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub SetStartStopPosition: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pguidstartpositiontype: *const ::windows::core::GUID, pvstartvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pguidstoppositiontype: *const ::windows::core::GUID, pvstopvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    SetStartStopPosition: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub HasVideo: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pfhasvideo: *mut super::super::Foundation::BOOL, pfselected: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    HasVideo: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub HasAudio: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pfhasaudio: *mut super::super::Foundation::BOOL, pfselected: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    HasAudio: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub IsProtected: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pfprotected: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsProtected: usize,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub GetDuration: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidpositiontype: *const ::windows::core::GUID, pvdurationvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    GetDuration: usize,
    pub GetNumberOfStreams: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwstreamcount: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub GetStreamSelection: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pfenabled: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetStreamSelection: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub SetStreamSelection: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, fenabled: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetStreamSelection: usize,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub GetStreamAttribute: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, guidmfattribute: *const ::windows::core::GUID, pvvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    GetStreamAttribute: usize,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub GetPresentationAttribute: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidmfattribute: *const ::windows::core::GUID, pvvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    GetPresentationAttribute: usize,
    pub GetCharacteristics: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcharacteristics: *mut u32) -> ::windows::core::HRESULT,
    pub SetStreamSink: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pmediasink: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub GetMetadata: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppmetadatastore: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_UI_Shell_PropertiesSystem"))]
    GetMetadata: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFPMediaPlayer(::windows::core::IUnknown);
impl IMFPMediaPlayer {
    pub unsafe fn Play(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Play)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Pause(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Pause)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Stop(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Stop)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn FrameStep(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).FrameStep)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetPosition(&self, guidpositiontype: *const ::windows::core::GUID, pvpositionvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetPosition)(::windows::core::Interface::as_raw(self), guidpositiontype, pvpositionvalue).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetPosition(&self, guidpositiontype: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT> {
        let mut result__ = ::windows::core::zeroed::<super::super::System::Com::StructuredStorage::PROPVARIANT>();
        (::windows::core::Interface::vtable(self).GetPosition)(::windows::core::Interface::as_raw(self), guidpositiontype, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetDuration(&self, guidpositiontype: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT> {
        let mut result__ = ::windows::core::zeroed::<super::super::System::Com::StructuredStorage::PROPVARIANT>();
        (::windows::core::Interface::vtable(self).GetDuration)(::windows::core::Interface::as_raw(self), guidpositiontype, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetRate(&self, flrate: f32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetRate)(::windows::core::Interface::as_raw(self), flrate).ok()
    }
    pub unsafe fn GetRate(&self) -> ::windows::core::Result<f32> {
        let mut result__ = ::windows::core::zeroed::<f32>();
        (::windows::core::Interface::vtable(self).GetRate)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetSupportedRates<P0>(&self, fforwarddirection: P0, pflslowestrate: *mut f32, pflfastestrate: *mut f32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).GetSupportedRates)(::windows::core::Interface::as_raw(self), fforwarddirection.into_param().abi(), pflslowestrate, pflfastestrate).ok()
    }
    pub unsafe fn GetState(&self) -> ::windows::core::Result<MFP_MEDIAPLAYER_STATE> {
        let mut result__ = ::windows::core::zeroed::<MFP_MEDIAPLAYER_STATE>();
        (::windows::core::Interface::vtable(self).GetState)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn CreateMediaItemFromURL<P0, P1>(&self, pwszurl: P0, fsync: P1, dwuserdata: usize, ppmediaitem: ::core::option::Option<*mut ::core::option::Option<IMFPMediaItem>>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P1: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).CreateMediaItemFromURL)(::windows::core::Interface::as_raw(self), pwszurl.into_param().abi(), fsync.into_param().abi(), dwuserdata, ::core::mem::transmute(ppmediaitem.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn CreateMediaItemFromObject<P0, P1>(&self, piunknownobj: P0, fsync: P1, dwuserdata: usize, ppmediaitem: ::core::option::Option<*mut ::core::option::Option<IMFPMediaItem>>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
        P1: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).CreateMediaItemFromObject)(::windows::core::Interface::as_raw(self), piunknownobj.into_param().abi(), fsync.into_param().abi(), dwuserdata, ::core::mem::transmute(ppmediaitem.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn SetMediaItem<P0>(&self, pimfpmediaitem: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFPMediaItem>,
    {
        (::windows::core::Interface::vtable(self).SetMediaItem)(::windows::core::Interface::as_raw(self), pimfpmediaitem.into_param().abi()).ok()
    }
    pub unsafe fn ClearMediaItem(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ClearMediaItem)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetMediaItem(&self) -> ::windows::core::Result<IMFPMediaItem> {
        let mut result__ = ::windows::core::zeroed::<IMFPMediaItem>();
        (::windows::core::Interface::vtable(self).GetMediaItem)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetVolume(&self) -> ::windows::core::Result<f32> {
        let mut result__ = ::windows::core::zeroed::<f32>();
        (::windows::core::Interface::vtable(self).GetVolume)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetVolume(&self, flvolume: f32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetVolume)(::windows::core::Interface::as_raw(self), flvolume).ok()
    }
    pub unsafe fn GetBalance(&self) -> ::windows::core::Result<f32> {
        let mut result__ = ::windows::core::zeroed::<f32>();
        (::windows::core::Interface::vtable(self).GetBalance)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetBalance(&self, flbalance: f32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetBalance)(::windows::core::Interface::as_raw(self), flbalance).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetMute(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).GetMute)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetMute<P0>(&self, fmute: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetMute)(::windows::core::Interface::as_raw(self), fmute.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetNativeVideoSize(&self, pszvideo: ::core::option::Option<*mut super::super::Foundation::SIZE>, pszarvideo: ::core::option::Option<*mut super::super::Foundation::SIZE>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetNativeVideoSize)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pszvideo.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(pszarvideo.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetIdealVideoSize(&self, pszmin: ::core::option::Option<*mut super::super::Foundation::SIZE>, pszmax: ::core::option::Option<*mut super::super::Foundation::SIZE>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetIdealVideoSize)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pszmin.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(pszmax.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn SetVideoSourceRect(&self, pnrcsource: *const MFVideoNormalizedRect) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetVideoSourceRect)(::windows::core::Interface::as_raw(self), pnrcsource).ok()
    }
    pub unsafe fn GetVideoSourceRect(&self) -> ::windows::core::Result<MFVideoNormalizedRect> {
        let mut result__ = ::windows::core::zeroed::<MFVideoNormalizedRect>();
        (::windows::core::Interface::vtable(self).GetVideoSourceRect)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetAspectRatioMode(&self, dwaspectratiomode: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetAspectRatioMode)(::windows::core::Interface::as_raw(self), dwaspectratiomode).ok()
    }
    pub unsafe fn GetAspectRatioMode(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetAspectRatioMode)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetVideoWindow(&self) -> ::windows::core::Result<super::super::Foundation::HWND> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::HWND>();
        (::windows::core::Interface::vtable(self).GetVideoWindow)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn UpdateVideo(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).UpdateVideo)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetBorderColor<P0>(&self, clr: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::COLORREF>,
    {
        (::windows::core::Interface::vtable(self).SetBorderColor)(::windows::core::Interface::as_raw(self), clr.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetBorderColor(&self) -> ::windows::core::Result<super::super::Foundation::COLORREF> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::COLORREF>();
        (::windows::core::Interface::vtable(self).GetBorderColor)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn InsertEffect<P0, P1>(&self, peffect: P0, foptional: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
        P1: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).InsertEffect)(::windows::core::Interface::as_raw(self), peffect.into_param().abi(), foptional.into_param().abi()).ok()
    }
    pub unsafe fn RemoveEffect<P0>(&self, peffect: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).RemoveEffect)(::windows::core::Interface::as_raw(self), peffect.into_param().abi()).ok()
    }
    pub unsafe fn RemoveAllEffects(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveAllEffects)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Shutdown(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Shutdown)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFPMediaPlayer, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFPMediaPlayer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFPMediaPlayer {}
impl ::core::fmt::Debug for IMFPMediaPlayer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFPMediaPlayer").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFPMediaPlayer {
    type Vtable = IMFPMediaPlayer_Vtbl;
}
impl ::core::clone::Clone for IMFPMediaPlayer {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFPMediaPlayer {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa714590a_58af_430a_85bf_44f5ec838d85);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFPMediaPlayer_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub Play: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Pause: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Stop: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub FrameStep: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub SetPosition: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidpositiontype: *const ::windows::core::GUID, pvpositionvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    SetPosition: usize,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub GetPosition: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidpositiontype: *const ::windows::core::GUID, pvpositionvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    GetPosition: usize,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub GetDuration: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidpositiontype: *const ::windows::core::GUID, pvdurationvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    GetDuration: usize,
    pub SetRate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, flrate: f32) -> ::windows::core::HRESULT,
    pub GetRate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pflrate: *mut f32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub GetSupportedRates: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fforwarddirection: super::super::Foundation::BOOL, pflslowestrate: *mut f32, pflfastestrate: *mut f32) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetSupportedRates: usize,
    pub GetState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pestate: *mut MFP_MEDIAPLAYER_STATE) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub CreateMediaItemFromURL: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pwszurl: ::windows::core::PCWSTR, fsync: super::super::Foundation::BOOL, dwuserdata: usize, ppmediaitem: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    CreateMediaItemFromURL: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub CreateMediaItemFromObject: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, piunknownobj: *mut ::core::ffi::c_void, fsync: super::super::Foundation::BOOL, dwuserdata: usize, ppmediaitem: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    CreateMediaItemFromObject: usize,
    pub SetMediaItem: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pimfpmediaitem: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub ClearMediaItem: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetMediaItem: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppimfpmediaitem: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetVolume: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pflvolume: *mut f32) -> ::windows::core::HRESULT,
    pub SetVolume: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, flvolume: f32) -> ::windows::core::HRESULT,
    pub GetBalance: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pflbalance: *mut f32) -> ::windows::core::HRESULT,
    pub SetBalance: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, flbalance: f32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub GetMute: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pfmute: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetMute: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub SetMute: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fmute: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetMute: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub GetNativeVideoSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pszvideo: *mut super::super::Foundation::SIZE, pszarvideo: *mut super::super::Foundation::SIZE) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetNativeVideoSize: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub GetIdealVideoSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pszmin: *mut super::super::Foundation::SIZE, pszmax: *mut super::super::Foundation::SIZE) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetIdealVideoSize: usize,
    pub SetVideoSourceRect: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pnrcsource: *const MFVideoNormalizedRect) -> ::windows::core::HRESULT,
    pub GetVideoSourceRect: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pnrcsource: *mut MFVideoNormalizedRect) -> ::windows::core::HRESULT,
    pub SetAspectRatioMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwaspectratiomode: u32) -> ::windows::core::HRESULT,
    pub GetAspectRatioMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwaspectratiomode: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub GetVideoWindow: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, phwndvideo: *mut super::super::Foundation::HWND) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetVideoWindow: usize,
    pub UpdateVideo: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub SetBorderColor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, clr: super::super::Foundation::COLORREF) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetBorderColor: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub GetBorderColor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pclr: *mut super::super::Foundation::COLORREF) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetBorderColor: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub InsertEffect: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, peffect: *mut ::core::ffi::c_void, foptional: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    InsertEffect: usize,
    pub RemoveEffect: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, peffect: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RemoveAllEffects: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Shutdown: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFPMediaPlayerCallback(::windows::core::IUnknown);
impl IMFPMediaPlayerCallback {
    #[doc = "*Required features: `\"Win32_UI_Shell_PropertiesSystem\"`*"]
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub unsafe fn OnMediaPlayerEvent(&self, peventheader: *const MFP_EVENT_HEADER) {
        (::windows::core::Interface::vtable(self).OnMediaPlayerEvent)(::windows::core::Interface::as_raw(self), peventheader)
    }
}
::windows::imp::interface_hierarchy!(IMFPMediaPlayerCallback, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFPMediaPlayerCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFPMediaPlayerCallback {}
impl ::core::fmt::Debug for IMFPMediaPlayerCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFPMediaPlayerCallback").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFPMediaPlayerCallback {
    type Vtable = IMFPMediaPlayerCallback_Vtbl;
}
impl ::core::clone::Clone for IMFPMediaPlayerCallback {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFPMediaPlayerCallback {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x766c8ffb_5fdb_4fea_a28d_b912996f51bd);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFPMediaPlayerCallback_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub OnMediaPlayerEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, peventheader: *const MFP_EVENT_HEADER),
    #[cfg(not(feature = "Win32_UI_Shell_PropertiesSystem"))]
    OnMediaPlayerEvent: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFPluginControl(::windows::core::IUnknown);
impl IMFPluginControl {
    pub unsafe fn GetPreferredClsid<P0>(&self, plugintype: u32, selector: P0) -> ::windows::core::Result<::windows::core::GUID>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).GetPreferredClsid)(::windows::core::Interface::as_raw(self), plugintype, selector.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetPreferredClsidByIndex(&self, plugintype: u32, index: u32, selector: *mut ::windows::core::PWSTR, clsid: *mut ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetPreferredClsidByIndex)(::windows::core::Interface::as_raw(self), plugintype, index, selector, clsid).ok()
    }
    pub unsafe fn SetPreferredClsid<P0>(&self, plugintype: u32, selector: P0, clsid: ::core::option::Option<*const ::windows::core::GUID>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).SetPreferredClsid)(::windows::core::Interface::as_raw(self), plugintype, selector.into_param().abi(), ::core::mem::transmute(clsid.unwrap_or(::std::ptr::null()))).ok()
    }
    pub unsafe fn IsDisabled(&self, plugintype: u32, clsid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).IsDisabled)(::windows::core::Interface::as_raw(self), plugintype, clsid).ok()
    }
    pub unsafe fn GetDisabledByIndex(&self, plugintype: u32, index: u32) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).GetDisabledByIndex)(::windows::core::Interface::as_raw(self), plugintype, index, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetDisabled<P0>(&self, plugintype: u32, clsid: *const ::windows::core::GUID, disabled: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetDisabled)(::windows::core::Interface::as_raw(self), plugintype, clsid, disabled.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFPluginControl, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFPluginControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFPluginControl {}
impl ::core::fmt::Debug for IMFPluginControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFPluginControl").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFPluginControl {
    type Vtable = IMFPluginControl_Vtbl;
}
impl ::core::clone::Clone for IMFPluginControl {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFPluginControl {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5c6c44bf_1db6_435b_9249_e8cd10fdec96);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFPluginControl_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetPreferredClsid: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, plugintype: u32, selector: ::windows::core::PCWSTR, clsid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub GetPreferredClsidByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, plugintype: u32, index: u32, selector: *mut ::windows::core::PWSTR, clsid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub SetPreferredClsid: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, plugintype: u32, selector: ::windows::core::PCWSTR, clsid: *const ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub IsDisabled: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, plugintype: u32, clsid: *const ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub GetDisabledByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, plugintype: u32, index: u32, clsid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub SetDisabled: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, plugintype: u32, clsid: *const ::windows::core::GUID, disabled: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetDisabled: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFPluginControl2(::windows::core::IUnknown);
impl IMFPluginControl2 {
    pub unsafe fn GetPreferredClsid<P0>(&self, plugintype: u32, selector: P0) -> ::windows::core::Result<::windows::core::GUID>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).base__.GetPreferredClsid)(::windows::core::Interface::as_raw(self), plugintype, selector.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetPreferredClsidByIndex(&self, plugintype: u32, index: u32, selector: *mut ::windows::core::PWSTR, clsid: *mut ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetPreferredClsidByIndex)(::windows::core::Interface::as_raw(self), plugintype, index, selector, clsid).ok()
    }
    pub unsafe fn SetPreferredClsid<P0>(&self, plugintype: u32, selector: P0, clsid: ::core::option::Option<*const ::windows::core::GUID>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.SetPreferredClsid)(::windows::core::Interface::as_raw(self), plugintype, selector.into_param().abi(), ::core::mem::transmute(clsid.unwrap_or(::std::ptr::null()))).ok()
    }
    pub unsafe fn IsDisabled(&self, plugintype: u32, clsid: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.IsDisabled)(::windows::core::Interface::as_raw(self), plugintype, clsid).ok()
    }
    pub unsafe fn GetDisabledByIndex(&self, plugintype: u32, index: u32) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).base__.GetDisabledByIndex)(::windows::core::Interface::as_raw(self), plugintype, index, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetDisabled<P0>(&self, plugintype: u32, clsid: *const ::windows::core::GUID, disabled: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).base__.SetDisabled)(::windows::core::Interface::as_raw(self), plugintype, clsid, disabled.into_param().abi()).ok()
    }
    pub unsafe fn SetPolicy(&self, policy: MF_PLUGIN_CONTROL_POLICY) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetPolicy)(::windows::core::Interface::as_raw(self), policy).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFPluginControl2, ::windows::core::IUnknown, IMFPluginControl);
impl ::core::cmp::PartialEq for IMFPluginControl2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFPluginControl2 {}
impl ::core::fmt::Debug for IMFPluginControl2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFPluginControl2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFPluginControl2 {
    type Vtable = IMFPluginControl2_Vtbl;
}
impl ::core::clone::Clone for IMFPluginControl2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFPluginControl2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc6982083_3ddc_45cb_af5e_0f7a8ce4de77);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFPluginControl2_Vtbl {
    pub base__: IMFPluginControl_Vtbl,
    pub SetPolicy: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, policy: MF_PLUGIN_CONTROL_POLICY) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFPresentationClock(::windows::core::IUnknown);
impl IMFPresentationClock {
    pub unsafe fn GetClockCharacteristics(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetClockCharacteristics)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetCorrelatedTime(&self, dwreserved: u32, pllclocktime: *mut i64, phnssystemtime: *mut i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetCorrelatedTime)(::windows::core::Interface::as_raw(self), dwreserved, pllclocktime, phnssystemtime).ok()
    }
    pub unsafe fn GetContinuityKey(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetContinuityKey)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetState(&self, dwreserved: u32) -> ::windows::core::Result<MFCLOCK_STATE> {
        let mut result__ = ::windows::core::zeroed::<MFCLOCK_STATE>();
        (::windows::core::Interface::vtable(self).base__.GetState)(::windows::core::Interface::as_raw(self), dwreserved, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetProperties(&self, pclockproperties: *mut MFCLOCK_PROPERTIES) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetProperties)(::windows::core::Interface::as_raw(self), pclockproperties).ok()
    }
    pub unsafe fn SetTimeSource<P0>(&self, ptimesource: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFPresentationTimeSource>,
    {
        (::windows::core::Interface::vtable(self).SetTimeSource)(::windows::core::Interface::as_raw(self), ptimesource.into_param().abi()).ok()
    }
    pub unsafe fn GetTimeSource(&self) -> ::windows::core::Result<IMFPresentationTimeSource> {
        let mut result__ = ::windows::core::zeroed::<IMFPresentationTimeSource>();
        (::windows::core::Interface::vtable(self).GetTimeSource)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetTime(&self) -> ::windows::core::Result<i64> {
        let mut result__ = ::windows::core::zeroed::<i64>();
        (::windows::core::Interface::vtable(self).GetTime)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn AddClockStateSink<P0>(&self, pstatesink: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFClockStateSink>,
    {
        (::windows::core::Interface::vtable(self).AddClockStateSink)(::windows::core::Interface::as_raw(self), pstatesink.into_param().abi()).ok()
    }
    pub unsafe fn RemoveClockStateSink<P0>(&self, pstatesink: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFClockStateSink>,
    {
        (::windows::core::Interface::vtable(self).RemoveClockStateSink)(::windows::core::Interface::as_raw(self), pstatesink.into_param().abi()).ok()
    }
    pub unsafe fn Start(&self, llclockstartoffset: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Start)(::windows::core::Interface::as_raw(self), llclockstartoffset).ok()
    }
    pub unsafe fn Stop(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Stop)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Pause(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Pause)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFPresentationClock, ::windows::core::IUnknown, IMFClock);
impl ::core::cmp::PartialEq for IMFPresentationClock {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFPresentationClock {}
impl ::core::fmt::Debug for IMFPresentationClock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFPresentationClock").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFPresentationClock {
    type Vtable = IMFPresentationClock_Vtbl;
}
impl ::core::clone::Clone for IMFPresentationClock {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFPresentationClock {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x868ce85c_8ea9_4f55_ab82_b009a910a805);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFPresentationClock_Vtbl {
    pub base__: IMFClock_Vtbl,
    pub SetTimeSource: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ptimesource: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetTimeSource: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pptimesource: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetTime: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, phnsclocktime: *mut i64) -> ::windows::core::HRESULT,
    pub AddClockStateSink: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pstatesink: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RemoveClockStateSink: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pstatesink: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Start: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, llclockstartoffset: i64) -> ::windows::core::HRESULT,
    pub Stop: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Pause: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFPresentationDescriptor(::windows::core::IUnknown);
impl IMFPresentationDescriptor {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItem(&self, guidkey: *const ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItem)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetItemType(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<MF_ATTRIBUTE_TYPE> {
        let mut result__ = ::windows::core::zeroed::<MF_ATTRIBUTE_TYPE>();
        (::windows::core::Interface::vtable(self).base__.GetItemType)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn CompareItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.CompareItem)(::windows::core::Interface::as_raw(self), guidkey, value, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Compare<P0>(&self, ptheirs: P0, matchtype: MF_ATTRIBUTES_MATCH_TYPE) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.Compare)(::windows::core::Interface::as_raw(self), ptheirs.into_param().abi(), matchtype, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT32(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetUINT32)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT64(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).base__.GetUINT64)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDouble(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).base__.GetDouble)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetGUID(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).base__.GetGUID)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStringLength(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetStringLength)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetString(&self, guidkey: *const ::windows::core::GUID, pwszvalue: &mut [u16], pcchlength: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetString)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pwszvalue.as_ptr()), pwszvalue.len() as _, ::core::mem::transmute(pcchlength.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedString(&self, guidkey: *const ::windows::core::GUID, ppwszvalue: *mut ::windows::core::PWSTR, pcchlength: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedString)(::windows::core::Interface::as_raw(self), guidkey, ppwszvalue, pcchlength).ok()
    }
    pub unsafe fn GetBlobSize(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetBlobSize)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &mut [u8], pcbblobsize: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _, ::core::mem::transmute(pcbblobsize.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedBlob(&self, guidkey: *const ::windows::core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedBlob)(::windows::core::Interface::as_raw(self), guidkey, ppbuf, pcbsize).ok()
    }
    pub unsafe fn GetUnknown<T>(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.GetUnknown)(::windows::core::Interface::as_raw(self), guidkey, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetItem)(::windows::core::Interface::as_raw(self), guidkey, value).ok()
    }
    pub unsafe fn DeleteItem(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteItem)(::windows::core::Interface::as_raw(self), guidkey).ok()
    }
    pub unsafe fn DeleteAllItems(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteAllItems)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetUINT32(&self, guidkey: *const ::windows::core::GUID, unvalue: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT32)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetUINT64(&self, guidkey: *const ::windows::core::GUID, unvalue: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT64)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetDouble(&self, guidkey: *const ::windows::core::GUID, fvalue: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetDouble)(::windows::core::Interface::as_raw(self), guidkey, fvalue).ok()
    }
    pub unsafe fn SetGUID(&self, guidkey: *const ::windows::core::GUID, guidvalue: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetGUID)(::windows::core::Interface::as_raw(self), guidkey, guidvalue).ok()
    }
    pub unsafe fn SetString<P0>(&self, guidkey: *const ::windows::core::GUID, wszvalue: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.SetString)(::windows::core::Interface::as_raw(self), guidkey, wszvalue.into_param().abi()).ok()
    }
    pub unsafe fn SetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _).ok()
    }
    pub unsafe fn SetUnknown<P0>(&self, guidkey: *const ::windows::core::GUID, punknown: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.SetUnknown)(::windows::core::Interface::as_raw(self), guidkey, punknown.into_param().abi()).ok()
    }
    pub unsafe fn LockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.LockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn UnlockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.UnlockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItemByIndex(&self, unindex: u32, pguidkey: *mut ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItemByIndex)(::windows::core::Interface::as_raw(self), unindex, pguidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn CopyAllItems<P0>(&self, pdest: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).base__.CopyAllItems)(::windows::core::Interface::as_raw(self), pdest.into_param().abi()).ok()
    }
    pub unsafe fn GetStreamDescriptorCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetStreamDescriptorCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetStreamDescriptorByIndex(&self, dwindex: u32, pfselected: *mut super::super::Foundation::BOOL, ppdescriptor: *mut ::core::option::Option<IMFStreamDescriptor>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetStreamDescriptorByIndex)(::windows::core::Interface::as_raw(self), dwindex, pfselected, ::core::mem::transmute(ppdescriptor)).ok()
    }
    pub unsafe fn SelectStream(&self, dwdescriptorindex: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SelectStream)(::windows::core::Interface::as_raw(self), dwdescriptorindex).ok()
    }
    pub unsafe fn DeselectStream(&self, dwdescriptorindex: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).DeselectStream)(::windows::core::Interface::as_raw(self), dwdescriptorindex).ok()
    }
    pub unsafe fn Clone(&self) -> ::windows::core::Result<IMFPresentationDescriptor> {
        let mut result__ = ::windows::core::zeroed::<IMFPresentationDescriptor>();
        (::windows::core::Interface::vtable(self).Clone)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFPresentationDescriptor, ::windows::core::IUnknown, IMFAttributes);
impl ::core::cmp::PartialEq for IMFPresentationDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFPresentationDescriptor {}
impl ::core::fmt::Debug for IMFPresentationDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFPresentationDescriptor").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFPresentationDescriptor {
    type Vtable = IMFPresentationDescriptor_Vtbl;
}
impl ::core::clone::Clone for IMFPresentationDescriptor {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFPresentationDescriptor {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x03cb2711_24d7_4db6_a17f_f3a7a479a536);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFPresentationDescriptor_Vtbl {
    pub base__: IMFAttributes_Vtbl,
    pub GetStreamDescriptorCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwdescriptorcount: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub GetStreamDescriptorByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwindex: u32, pfselected: *mut super::super::Foundation::BOOL, ppdescriptor: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetStreamDescriptorByIndex: usize,
    pub SelectStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwdescriptorindex: u32) -> ::windows::core::HRESULT,
    pub DeselectStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwdescriptorindex: u32) -> ::windows::core::HRESULT,
    pub Clone: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pppresentationdescriptor: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFPresentationTimeSource(::windows::core::IUnknown);
impl IMFPresentationTimeSource {
    pub unsafe fn GetClockCharacteristics(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetClockCharacteristics)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetCorrelatedTime(&self, dwreserved: u32, pllclocktime: *mut i64, phnssystemtime: *mut i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetCorrelatedTime)(::windows::core::Interface::as_raw(self), dwreserved, pllclocktime, phnssystemtime).ok()
    }
    pub unsafe fn GetContinuityKey(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetContinuityKey)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetState(&self, dwreserved: u32) -> ::windows::core::Result<MFCLOCK_STATE> {
        let mut result__ = ::windows::core::zeroed::<MFCLOCK_STATE>();
        (::windows::core::Interface::vtable(self).base__.GetState)(::windows::core::Interface::as_raw(self), dwreserved, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetProperties(&self, pclockproperties: *mut MFCLOCK_PROPERTIES) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetProperties)(::windows::core::Interface::as_raw(self), pclockproperties).ok()
    }
    pub unsafe fn GetUnderlyingClock(&self) -> ::windows::core::Result<IMFClock> {
        let mut result__ = ::windows::core::zeroed::<IMFClock>();
        (::windows::core::Interface::vtable(self).GetUnderlyingClock)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFPresentationTimeSource, ::windows::core::IUnknown, IMFClock);
impl ::core::cmp::PartialEq for IMFPresentationTimeSource {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFPresentationTimeSource {}
impl ::core::fmt::Debug for IMFPresentationTimeSource {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFPresentationTimeSource").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFPresentationTimeSource {
    type Vtable = IMFPresentationTimeSource_Vtbl;
}
impl ::core::clone::Clone for IMFPresentationTimeSource {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFPresentationTimeSource {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7ff12cce_f76f_41c2_863b_1666c8e5e139);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFPresentationTimeSource_Vtbl {
    pub base__: IMFClock_Vtbl,
    pub GetUnderlyingClock: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppclock: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFProtectedEnvironmentAccess(::windows::core::IUnknown);
impl IMFProtectedEnvironmentAccess {
    pub unsafe fn Call(&self, input: &[u8], output: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Call)(::windows::core::Interface::as_raw(self), input.len() as _, ::core::mem::transmute(input.as_ptr()), output.len() as _, ::core::mem::transmute(output.as_ptr())).ok()
    }
    pub unsafe fn ReadGRL(&self, outputlength: *mut u32, output: *mut *mut u8) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ReadGRL)(::windows::core::Interface::as_raw(self), outputlength, output).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFProtectedEnvironmentAccess, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFProtectedEnvironmentAccess {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFProtectedEnvironmentAccess {}
impl ::core::fmt::Debug for IMFProtectedEnvironmentAccess {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFProtectedEnvironmentAccess").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFProtectedEnvironmentAccess {
    type Vtable = IMFProtectedEnvironmentAccess_Vtbl;
}
impl ::core::clone::Clone for IMFProtectedEnvironmentAccess {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFProtectedEnvironmentAccess {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xef5dc845_f0d9_4ec9_b00c_cb5183d38434);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFProtectedEnvironmentAccess_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub Call: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, inputlength: u32, input: *const u8, outputlength: u32, output: *mut u8) -> ::windows::core::HRESULT,
    pub ReadGRL: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, outputlength: *mut u32, output: *mut *mut u8) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFQualityAdvise(::windows::core::IUnknown);
impl IMFQualityAdvise {
    pub unsafe fn SetDropMode(&self, edropmode: MF_QUALITY_DROP_MODE) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetDropMode)(::windows::core::Interface::as_raw(self), edropmode).ok()
    }
    pub unsafe fn SetQualityLevel(&self, equalitylevel: MF_QUALITY_LEVEL) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetQualityLevel)(::windows::core::Interface::as_raw(self), equalitylevel).ok()
    }
    pub unsafe fn GetDropMode(&self) -> ::windows::core::Result<MF_QUALITY_DROP_MODE> {
        let mut result__ = ::windows::core::zeroed::<MF_QUALITY_DROP_MODE>();
        (::windows::core::Interface::vtable(self).GetDropMode)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetQualityLevel(&self) -> ::windows::core::Result<MF_QUALITY_LEVEL> {
        let mut result__ = ::windows::core::zeroed::<MF_QUALITY_LEVEL>();
        (::windows::core::Interface::vtable(self).GetQualityLevel)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn DropTime(&self, hnsamounttodrop: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).DropTime)(::windows::core::Interface::as_raw(self), hnsamounttodrop).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFQualityAdvise, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFQualityAdvise {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFQualityAdvise {}
impl ::core::fmt::Debug for IMFQualityAdvise {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFQualityAdvise").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFQualityAdvise {
    type Vtable = IMFQualityAdvise_Vtbl;
}
impl ::core::clone::Clone for IMFQualityAdvise {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFQualityAdvise {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xec15e2e9_e36b_4f7c_8758_77d452ef4ce7);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFQualityAdvise_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetDropMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, edropmode: MF_QUALITY_DROP_MODE) -> ::windows::core::HRESULT,
    pub SetQualityLevel: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, equalitylevel: MF_QUALITY_LEVEL) -> ::windows::core::HRESULT,
    pub GetDropMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pedropmode: *mut MF_QUALITY_DROP_MODE) -> ::windows::core::HRESULT,
    pub GetQualityLevel: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pequalitylevel: *mut MF_QUALITY_LEVEL) -> ::windows::core::HRESULT,
    pub DropTime: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hnsamounttodrop: i64) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFQualityAdvise2(::windows::core::IUnknown);
impl IMFQualityAdvise2 {
    pub unsafe fn SetDropMode(&self, edropmode: MF_QUALITY_DROP_MODE) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetDropMode)(::windows::core::Interface::as_raw(self), edropmode).ok()
    }
    pub unsafe fn SetQualityLevel(&self, equalitylevel: MF_QUALITY_LEVEL) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetQualityLevel)(::windows::core::Interface::as_raw(self), equalitylevel).ok()
    }
    pub unsafe fn GetDropMode(&self) -> ::windows::core::Result<MF_QUALITY_DROP_MODE> {
        let mut result__ = ::windows::core::zeroed::<MF_QUALITY_DROP_MODE>();
        (::windows::core::Interface::vtable(self).base__.GetDropMode)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetQualityLevel(&self) -> ::windows::core::Result<MF_QUALITY_LEVEL> {
        let mut result__ = ::windows::core::zeroed::<MF_QUALITY_LEVEL>();
        (::windows::core::Interface::vtable(self).base__.GetQualityLevel)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn DropTime(&self, hnsamounttodrop: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DropTime)(::windows::core::Interface::as_raw(self), hnsamounttodrop).ok()
    }
    pub unsafe fn NotifyQualityEvent<P0>(&self, pevent: P0) -> ::windows::core::Result<u32>
    where
        P0: ::windows::core::IntoParam<IMFMediaEvent>,
    {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).NotifyQualityEvent)(::windows::core::Interface::as_raw(self), pevent.into_param().abi(), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFQualityAdvise2, ::windows::core::IUnknown, IMFQualityAdvise);
impl ::core::cmp::PartialEq for IMFQualityAdvise2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFQualityAdvise2 {}
impl ::core::fmt::Debug for IMFQualityAdvise2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFQualityAdvise2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFQualityAdvise2 {
    type Vtable = IMFQualityAdvise2_Vtbl;
}
impl ::core::clone::Clone for IMFQualityAdvise2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFQualityAdvise2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf3706f0d_8ea2_4886_8000_7155e9ec2eae);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFQualityAdvise2_Vtbl {
    pub base__: IMFQualityAdvise_Vtbl,
    pub NotifyQualityEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pevent: *mut ::core::ffi::c_void, pdwflags: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFQualityAdviseLimits(::windows::core::IUnknown);
impl IMFQualityAdviseLimits {
    pub unsafe fn GetMaximumDropMode(&self) -> ::windows::core::Result<MF_QUALITY_DROP_MODE> {
        let mut result__ = ::windows::core::zeroed::<MF_QUALITY_DROP_MODE>();
        (::windows::core::Interface::vtable(self).GetMaximumDropMode)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetMinimumQualityLevel(&self) -> ::windows::core::Result<MF_QUALITY_LEVEL> {
        let mut result__ = ::windows::core::zeroed::<MF_QUALITY_LEVEL>();
        (::windows::core::Interface::vtable(self).GetMinimumQualityLevel)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFQualityAdviseLimits, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFQualityAdviseLimits {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFQualityAdviseLimits {}
impl ::core::fmt::Debug for IMFQualityAdviseLimits {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFQualityAdviseLimits").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFQualityAdviseLimits {
    type Vtable = IMFQualityAdviseLimits_Vtbl;
}
impl ::core::clone::Clone for IMFQualityAdviseLimits {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFQualityAdviseLimits {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdfcd8e4d_30b5_4567_acaa_8eb5b7853dc9);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFQualityAdviseLimits_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetMaximumDropMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pedropmode: *mut MF_QUALITY_DROP_MODE) -> ::windows::core::HRESULT,
    pub GetMinimumQualityLevel: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pequalitylevel: *mut MF_QUALITY_LEVEL) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFQualityManager(::windows::core::IUnknown);
impl IMFQualityManager {
    pub unsafe fn NotifyTopology<P0>(&self, ptopology: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFTopology>,
    {
        (::windows::core::Interface::vtable(self).NotifyTopology)(::windows::core::Interface::as_raw(self), ptopology.into_param().abi()).ok()
    }
    pub unsafe fn NotifyPresentationClock<P0>(&self, pclock: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFPresentationClock>,
    {
        (::windows::core::Interface::vtable(self).NotifyPresentationClock)(::windows::core::Interface::as_raw(self), pclock.into_param().abi()).ok()
    }
    pub unsafe fn NotifyProcessInput<P0, P1>(&self, pnode: P0, linputindex: i32, psample: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFTopologyNode>,
        P1: ::windows::core::IntoParam<IMFSample>,
    {
        (::windows::core::Interface::vtable(self).NotifyProcessInput)(::windows::core::Interface::as_raw(self), pnode.into_param().abi(), linputindex, psample.into_param().abi()).ok()
    }
    pub unsafe fn NotifyProcessOutput<P0, P1>(&self, pnode: P0, loutputindex: i32, psample: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFTopologyNode>,
        P1: ::windows::core::IntoParam<IMFSample>,
    {
        (::windows::core::Interface::vtable(self).NotifyProcessOutput)(::windows::core::Interface::as_raw(self), pnode.into_param().abi(), loutputindex, psample.into_param().abi()).ok()
    }
    pub unsafe fn NotifyQualityEvent<P0, P1>(&self, pobject: P0, pevent: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
        P1: ::windows::core::IntoParam<IMFMediaEvent>,
    {
        (::windows::core::Interface::vtable(self).NotifyQualityEvent)(::windows::core::Interface::as_raw(self), pobject.into_param().abi(), pevent.into_param().abi()).ok()
    }
    pub unsafe fn Shutdown(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Shutdown)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFQualityManager, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFQualityManager {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFQualityManager {}
impl ::core::fmt::Debug for IMFQualityManager {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFQualityManager").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFQualityManager {
    type Vtable = IMFQualityManager_Vtbl;
}
impl ::core::clone::Clone for IMFQualityManager {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFQualityManager {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8d009d86_5b9f_4115_b1fc_9f80d52ab8ab);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFQualityManager_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub NotifyTopology: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ptopology: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub NotifyPresentationClock: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pclock: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub NotifyProcessInput: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pnode: *mut ::core::ffi::c_void, linputindex: i32, psample: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub NotifyProcessOutput: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pnode: *mut ::core::ffi::c_void, loutputindex: i32, psample: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub NotifyQualityEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pobject: *mut ::core::ffi::c_void, pevent: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Shutdown: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFRateControl(::windows::core::IUnknown);
impl IMFRateControl {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetRate<P0>(&self, fthin: P0, flrate: f32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetRate)(::windows::core::Interface::as_raw(self), fthin.into_param().abi(), flrate).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetRate(&self, pfthin: *mut super::super::Foundation::BOOL, pflrate: *mut f32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetRate)(::windows::core::Interface::as_raw(self), pfthin, pflrate).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFRateControl, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFRateControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFRateControl {}
impl ::core::fmt::Debug for IMFRateControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFRateControl").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFRateControl {
    type Vtable = IMFRateControl_Vtbl;
}
impl ::core::clone::Clone for IMFRateControl {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFRateControl {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x88ddcd21_03c3_4275_91ed_55ee3929328f);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFRateControl_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub SetRate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fthin: super::super::Foundation::BOOL, flrate: f32) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetRate: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub GetRate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pfthin: *mut super::super::Foundation::BOOL, pflrate: *mut f32) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetRate: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFRateSupport(::windows::core::IUnknown);
impl IMFRateSupport {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetSlowestRate<P0>(&self, edirection: MFRATE_DIRECTION, fthin: P0) -> ::windows::core::Result<f32>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        let mut result__ = ::windows::core::zeroed::<f32>();
        (::windows::core::Interface::vtable(self).GetSlowestRate)(::windows::core::Interface::as_raw(self), edirection, fthin.into_param().abi(), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetFastestRate<P0>(&self, edirection: MFRATE_DIRECTION, fthin: P0) -> ::windows::core::Result<f32>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        let mut result__ = ::windows::core::zeroed::<f32>();
        (::windows::core::Interface::vtable(self).GetFastestRate)(::windows::core::Interface::as_raw(self), edirection, fthin.into_param().abi(), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsRateSupported<P0>(&self, fthin: P0, flrate: f32, pflnearestsupportedrate: *mut f32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).IsRateSupported)(::windows::core::Interface::as_raw(self), fthin.into_param().abi(), flrate, pflnearestsupportedrate).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFRateSupport, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFRateSupport {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFRateSupport {}
impl ::core::fmt::Debug for IMFRateSupport {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFRateSupport").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFRateSupport {
    type Vtable = IMFRateSupport_Vtbl;
}
impl ::core::clone::Clone for IMFRateSupport {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFRateSupport {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0a9ccdbc_d797_4563_9667_94ec5d79292d);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFRateSupport_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub GetSlowestRate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, edirection: MFRATE_DIRECTION, fthin: super::super::Foundation::BOOL, pflrate: *mut f32) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetSlowestRate: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub GetFastestRate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, edirection: MFRATE_DIRECTION, fthin: super::super::Foundation::BOOL, pflrate: *mut f32) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetFastestRate: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub IsRateSupported: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fthin: super::super::Foundation::BOOL, flrate: f32, pflnearestsupportedrate: *mut f32) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsRateSupported: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFReadWriteClassFactory(::windows::core::IUnknown);
impl IMFReadWriteClassFactory {
    pub unsafe fn CreateInstanceFromURL<P0, P1, T>(&self, clsid: *const ::windows::core::GUID, pwszurl: P0, pattributes: P1) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P1: ::windows::core::IntoParam<IMFAttributes>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateInstanceFromURL)(::windows::core::Interface::as_raw(self), clsid, pwszurl.into_param().abi(), pattributes.into_param().abi(), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    pub unsafe fn CreateInstanceFromObject<P0, P1, T>(&self, clsid: *const ::windows::core::GUID, punkobject: P0, pattributes: P1) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
        P1: ::windows::core::IntoParam<IMFAttributes>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateInstanceFromObject)(::windows::core::Interface::as_raw(self), clsid, punkobject.into_param().abi(), pattributes.into_param().abi(), &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFReadWriteClassFactory, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFReadWriteClassFactory {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFReadWriteClassFactory {}
impl ::core::fmt::Debug for IMFReadWriteClassFactory {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFReadWriteClassFactory").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFReadWriteClassFactory {
    type Vtable = IMFReadWriteClassFactory_Vtbl;
}
impl ::core::clone::Clone for IMFReadWriteClassFactory {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFReadWriteClassFactory {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe7fe2e12_661c_40da_92f9_4f002ab67627);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFReadWriteClassFactory_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub CreateInstanceFromURL: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, clsid: *const ::windows::core::GUID, pwszurl: ::windows::core::PCWSTR, pattributes: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub CreateInstanceFromObject: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, clsid: *const ::windows::core::GUID, punkobject: *mut ::core::ffi::c_void, pattributes: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFRealTimeClient(::windows::core::IUnknown);
impl IMFRealTimeClient {
    pub unsafe fn RegisterThreads<P0>(&self, dwtaskindex: u32, wszclass: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).RegisterThreads)(::windows::core::Interface::as_raw(self), dwtaskindex, wszclass.into_param().abi()).ok()
    }
    pub unsafe fn UnregisterThreads(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).UnregisterThreads)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetWorkQueue(&self, dwworkqueueid: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetWorkQueue)(::windows::core::Interface::as_raw(self), dwworkqueueid).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFRealTimeClient, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFRealTimeClient {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFRealTimeClient {}
impl ::core::fmt::Debug for IMFRealTimeClient {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFRealTimeClient").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFRealTimeClient {
    type Vtable = IMFRealTimeClient_Vtbl;
}
impl ::core::clone::Clone for IMFRealTimeClient {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFRealTimeClient {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2347d60b_3fb5_480c_8803_8df3adcd3ef0);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFRealTimeClient_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub RegisterThreads: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwtaskindex: u32, wszclass: ::windows::core::PCWSTR) -> ::windows::core::HRESULT,
    pub UnregisterThreads: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetWorkQueue: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwworkqueueid: u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFRealTimeClientEx(::windows::core::IUnknown);
impl IMFRealTimeClientEx {
    pub unsafe fn RegisterThreadsEx<P0>(&self, pdwtaskindex: *mut u32, wszclassname: P0, lbasepriority: i32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).RegisterThreadsEx)(::windows::core::Interface::as_raw(self), pdwtaskindex, wszclassname.into_param().abi(), lbasepriority).ok()
    }
    pub unsafe fn UnregisterThreads(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).UnregisterThreads)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetWorkQueueEx(&self, dwmultithreadedworkqueueid: u32, lworkitembasepriority: i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetWorkQueueEx)(::windows::core::Interface::as_raw(self), dwmultithreadedworkqueueid, lworkitembasepriority).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFRealTimeClientEx, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFRealTimeClientEx {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFRealTimeClientEx {}
impl ::core::fmt::Debug for IMFRealTimeClientEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFRealTimeClientEx").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFRealTimeClientEx {
    type Vtable = IMFRealTimeClientEx_Vtbl;
}
impl ::core::clone::Clone for IMFRealTimeClientEx {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFRealTimeClientEx {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x03910848_ab16_4611_b100_17b88ae2f248);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFRealTimeClientEx_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub RegisterThreadsEx: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwtaskindex: *mut u32, wszclassname: ::windows::core::PCWSTR, lbasepriority: i32) -> ::windows::core::HRESULT,
    pub UnregisterThreads: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetWorkQueueEx: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwmultithreadedworkqueueid: u32, lworkitembasepriority: i32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFRelativePanelReport(::windows::core::IUnknown);
impl IMFRelativePanelReport {
    pub unsafe fn GetRelativePanel(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetRelativePanel)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFRelativePanelReport, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFRelativePanelReport {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFRelativePanelReport {}
impl ::core::fmt::Debug for IMFRelativePanelReport {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFRelativePanelReport").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFRelativePanelReport {
    type Vtable = IMFRelativePanelReport_Vtbl;
}
impl ::core::clone::Clone for IMFRelativePanelReport {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFRelativePanelReport {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf25362ea_2c0e_447f_81e2_755914cdc0c3);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFRelativePanelReport_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetRelativePanel: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, panel: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFRelativePanelWatcher(::windows::core::IUnknown);
impl IMFRelativePanelWatcher {
    pub unsafe fn Shutdown(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Shutdown)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetShutdownStatus(&self) -> ::windows::core::Result<MFSHUTDOWN_STATUS> {
        let mut result__ = ::windows::core::zeroed::<MFSHUTDOWN_STATUS>();
        (::windows::core::Interface::vtable(self).base__.GetShutdownStatus)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn BeginGetReport<P0, P1>(&self, pcallback: P0, pstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginGetReport)(::windows::core::Interface::as_raw(self), pcallback.into_param().abi(), pstate.into_param().abi()).ok()
    }
    pub unsafe fn EndGetReport<P0>(&self, presult: P0) -> ::windows::core::Result<IMFRelativePanelReport>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFRelativePanelReport>();
        (::windows::core::Interface::vtable(self).EndGetReport)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetReport(&self) -> ::windows::core::Result<IMFRelativePanelReport> {
        let mut result__ = ::windows::core::zeroed::<IMFRelativePanelReport>();
        (::windows::core::Interface::vtable(self).GetReport)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFRelativePanelWatcher, ::windows::core::IUnknown, IMFShutdown);
impl ::core::cmp::PartialEq for IMFRelativePanelWatcher {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFRelativePanelWatcher {}
impl ::core::fmt::Debug for IMFRelativePanelWatcher {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFRelativePanelWatcher").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFRelativePanelWatcher {
    type Vtable = IMFRelativePanelWatcher_Vtbl;
}
impl ::core::clone::Clone for IMFRelativePanelWatcher {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFRelativePanelWatcher {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x421af7f6_573e_4ad0_8fda_2e57cedb18c6);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFRelativePanelWatcher_Vtbl {
    pub base__: IMFShutdown_Vtbl,
    pub BeginGetReport: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcallback: *mut ::core::ffi::c_void, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub EndGetReport: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void, pprelativepanelreport: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetReport: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pprelativepanelreport: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFRemoteAsyncCallback(::windows::core::IUnknown);
impl IMFRemoteAsyncCallback {
    pub unsafe fn Invoke<P0>(&self, hr: ::windows::core::HRESULT, premoteresult: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).Invoke)(::windows::core::Interface::as_raw(self), hr, premoteresult.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFRemoteAsyncCallback, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFRemoteAsyncCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFRemoteAsyncCallback {}
impl ::core::fmt::Debug for IMFRemoteAsyncCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFRemoteAsyncCallback").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFRemoteAsyncCallback {
    type Vtable = IMFRemoteAsyncCallback_Vtbl;
}
impl ::core::clone::Clone for IMFRemoteAsyncCallback {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFRemoteAsyncCallback {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa27003d0_2354_4f2a_8d6a_ab7cff15437e);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFRemoteAsyncCallback_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub Invoke: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hr: ::windows::core::HRESULT, premoteresult: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFRemoteDesktopPlugin(::windows::core::IUnknown);
impl IMFRemoteDesktopPlugin {
    pub unsafe fn UpdateTopology<P0>(&self, ptopology: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFTopology>,
    {
        (::windows::core::Interface::vtable(self).UpdateTopology)(::windows::core::Interface::as_raw(self), ptopology.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFRemoteDesktopPlugin, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFRemoteDesktopPlugin {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFRemoteDesktopPlugin {}
impl ::core::fmt::Debug for IMFRemoteDesktopPlugin {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFRemoteDesktopPlugin").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFRemoteDesktopPlugin {
    type Vtable = IMFRemoteDesktopPlugin_Vtbl;
}
impl ::core::clone::Clone for IMFRemoteDesktopPlugin {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFRemoteDesktopPlugin {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1cde6309_cae0_4940_907e_c1ec9c3d1d4a);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFRemoteDesktopPlugin_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub UpdateTopology: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ptopology: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFRemoteProxy(::windows::core::IUnknown);
impl IMFRemoteProxy {
    pub unsafe fn GetRemoteObject(&self, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetRemoteObject)(::windows::core::Interface::as_raw(self), riid, ppv).ok()
    }
    pub unsafe fn GetRemoteHost(&self, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetRemoteHost)(::windows::core::Interface::as_raw(self), riid, ppv).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFRemoteProxy, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFRemoteProxy {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFRemoteProxy {}
impl ::core::fmt::Debug for IMFRemoteProxy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFRemoteProxy").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFRemoteProxy {
    type Vtable = IMFRemoteProxy_Vtbl;
}
impl ::core::clone::Clone for IMFRemoteProxy {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFRemoteProxy {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x994e23ad_1cc2_493c_b9fa_46f1cb040fa4);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFRemoteProxy_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetRemoteObject: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetRemoteHost: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSAMIStyle(::windows::core::IUnknown);
impl IMFSAMIStyle {
    pub unsafe fn GetStyleCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetStyleCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetStyles(&self) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT> {
        let mut result__ = ::windows::core::zeroed::<super::super::System::Com::StructuredStorage::PROPVARIANT>();
        (::windows::core::Interface::vtable(self).GetStyles)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetSelectedStyle<P0>(&self, pwszstyle: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).SetSelectedStyle)(::windows::core::Interface::as_raw(self), pwszstyle.into_param().abi()).ok()
    }
    pub unsafe fn GetSelectedStyle(&self) -> ::windows::core::Result<::windows::core::PWSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::PWSTR>();
        (::windows::core::Interface::vtable(self).GetSelectedStyle)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFSAMIStyle, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSAMIStyle {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSAMIStyle {}
impl ::core::fmt::Debug for IMFSAMIStyle {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSAMIStyle").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSAMIStyle {
    type Vtable = IMFSAMIStyle_Vtbl;
}
impl ::core::clone::Clone for IMFSAMIStyle {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSAMIStyle {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa7e025dd_5303_4a62_89d6_e747e1efac73);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSAMIStyle_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetStyleCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwcount: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub GetStyles: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppropvarstylearray: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    GetStyles: usize,
    pub SetSelectedStyle: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pwszstyle: ::windows::core::PCWSTR) -> ::windows::core::HRESULT,
    pub GetSelectedStyle: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppwszstyle: *mut ::windows::core::PWSTR) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSSLCertificateManager(::windows::core::IUnknown);
impl IMFSSLCertificateManager {
    pub unsafe fn GetClientCertificate<P0>(&self, pszurl: P0, ppbdata: *mut *mut u8, pcbdata: *mut u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).GetClientCertificate)(::windows::core::Interface::as_raw(self), pszurl.into_param().abi(), ppbdata, pcbdata).ok()
    }
    pub unsafe fn BeginGetClientCertificate<P0, P1, P2>(&self, pszurl: P0, pcallback: P1, pstate: P2) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P1: ::windows::core::IntoParam<IMFAsyncCallback>,
        P2: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginGetClientCertificate)(::windows::core::Interface::as_raw(self), pszurl.into_param().abi(), pcallback.into_param().abi(), pstate.into_param().abi()).ok()
    }
    pub unsafe fn EndGetClientCertificate<P0>(&self, presult: P0, ppbdata: *mut *mut u8, pcbdata: *mut u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        (::windows::core::Interface::vtable(self).EndGetClientCertificate)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), ppbdata, pcbdata).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetCertificatePolicy<P0>(&self, pszurl: P0, pfoverrideautomaticcheck: *mut super::super::Foundation::BOOL, pfclientcertificateavailable: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).GetCertificatePolicy)(::windows::core::Interface::as_raw(self), pszurl.into_param().abi(), pfoverrideautomaticcheck, pfclientcertificateavailable).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn OnServerCertificate<P0>(&self, pszurl: P0, pbdata: &[u8]) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).OnServerCertificate)(::windows::core::Interface::as_raw(self), pszurl.into_param().abi(), ::core::mem::transmute(pbdata.as_ptr()), pbdata.len() as _, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFSSLCertificateManager, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSSLCertificateManager {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSSLCertificateManager {}
impl ::core::fmt::Debug for IMFSSLCertificateManager {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSSLCertificateManager").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSSLCertificateManager {
    type Vtable = IMFSSLCertificateManager_Vtbl;
}
impl ::core::clone::Clone for IMFSSLCertificateManager {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSSLCertificateManager {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x61f7d887_1230_4a8b_aeba_8ad434d1a64d);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSSLCertificateManager_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetClientCertificate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pszurl: ::windows::core::PCWSTR, ppbdata: *mut *mut u8, pcbdata: *mut u32) -> ::windows::core::HRESULT,
    pub BeginGetClientCertificate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pszurl: ::windows::core::PCWSTR, pcallback: *mut ::core::ffi::c_void, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub EndGetClientCertificate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void, ppbdata: *mut *mut u8, pcbdata: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub GetCertificatePolicy: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pszurl: ::windows::core::PCWSTR, pfoverrideautomaticcheck: *mut super::super::Foundation::BOOL, pfclientcertificateavailable: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetCertificatePolicy: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub OnServerCertificate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pszurl: ::windows::core::PCWSTR, pbdata: *const u8, cbdata: u32, pfisgood: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    OnServerCertificate: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSample(::windows::core::IUnknown);
impl IMFSample {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItem(&self, guidkey: *const ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItem)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetItemType(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<MF_ATTRIBUTE_TYPE> {
        let mut result__ = ::windows::core::zeroed::<MF_ATTRIBUTE_TYPE>();
        (::windows::core::Interface::vtable(self).base__.GetItemType)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn CompareItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.CompareItem)(::windows::core::Interface::as_raw(self), guidkey, value, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Compare<P0>(&self, ptheirs: P0, matchtype: MF_ATTRIBUTES_MATCH_TYPE) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.Compare)(::windows::core::Interface::as_raw(self), ptheirs.into_param().abi(), matchtype, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT32(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetUINT32)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT64(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).base__.GetUINT64)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDouble(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).base__.GetDouble)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetGUID(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).base__.GetGUID)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStringLength(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetStringLength)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetString(&self, guidkey: *const ::windows::core::GUID, pwszvalue: &mut [u16], pcchlength: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetString)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pwszvalue.as_ptr()), pwszvalue.len() as _, ::core::mem::transmute(pcchlength.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedString(&self, guidkey: *const ::windows::core::GUID, ppwszvalue: *mut ::windows::core::PWSTR, pcchlength: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedString)(::windows::core::Interface::as_raw(self), guidkey, ppwszvalue, pcchlength).ok()
    }
    pub unsafe fn GetBlobSize(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetBlobSize)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &mut [u8], pcbblobsize: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _, ::core::mem::transmute(pcbblobsize.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedBlob(&self, guidkey: *const ::windows::core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedBlob)(::windows::core::Interface::as_raw(self), guidkey, ppbuf, pcbsize).ok()
    }
    pub unsafe fn GetUnknown<T>(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.GetUnknown)(::windows::core::Interface::as_raw(self), guidkey, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetItem)(::windows::core::Interface::as_raw(self), guidkey, value).ok()
    }
    pub unsafe fn DeleteItem(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteItem)(::windows::core::Interface::as_raw(self), guidkey).ok()
    }
    pub unsafe fn DeleteAllItems(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteAllItems)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetUINT32(&self, guidkey: *const ::windows::core::GUID, unvalue: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT32)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetUINT64(&self, guidkey: *const ::windows::core::GUID, unvalue: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT64)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetDouble(&self, guidkey: *const ::windows::core::GUID, fvalue: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetDouble)(::windows::core::Interface::as_raw(self), guidkey, fvalue).ok()
    }
    pub unsafe fn SetGUID(&self, guidkey: *const ::windows::core::GUID, guidvalue: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetGUID)(::windows::core::Interface::as_raw(self), guidkey, guidvalue).ok()
    }
    pub unsafe fn SetString<P0>(&self, guidkey: *const ::windows::core::GUID, wszvalue: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.SetString)(::windows::core::Interface::as_raw(self), guidkey, wszvalue.into_param().abi()).ok()
    }
    pub unsafe fn SetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _).ok()
    }
    pub unsafe fn SetUnknown<P0>(&self, guidkey: *const ::windows::core::GUID, punknown: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.SetUnknown)(::windows::core::Interface::as_raw(self), guidkey, punknown.into_param().abi()).ok()
    }
    pub unsafe fn LockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.LockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn UnlockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.UnlockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItemByIndex(&self, unindex: u32, pguidkey: *mut ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItemByIndex)(::windows::core::Interface::as_raw(self), unindex, pguidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn CopyAllItems<P0>(&self, pdest: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).base__.CopyAllItems)(::windows::core::Interface::as_raw(self), pdest.into_param().abi()).ok()
    }
    pub unsafe fn GetSampleFlags(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetSampleFlags)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetSampleFlags(&self, dwsampleflags: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetSampleFlags)(::windows::core::Interface::as_raw(self), dwsampleflags).ok()
    }
    pub unsafe fn GetSampleTime(&self) -> ::windows::core::Result<i64> {
        let mut result__ = ::windows::core::zeroed::<i64>();
        (::windows::core::Interface::vtable(self).GetSampleTime)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetSampleTime(&self, hnssampletime: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetSampleTime)(::windows::core::Interface::as_raw(self), hnssampletime).ok()
    }
    pub unsafe fn GetSampleDuration(&self) -> ::windows::core::Result<i64> {
        let mut result__ = ::windows::core::zeroed::<i64>();
        (::windows::core::Interface::vtable(self).GetSampleDuration)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetSampleDuration(&self, hnssampleduration: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetSampleDuration)(::windows::core::Interface::as_raw(self), hnssampleduration).ok()
    }
    pub unsafe fn GetBufferCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetBufferCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBufferByIndex(&self, dwindex: u32) -> ::windows::core::Result<IMFMediaBuffer> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaBuffer>();
        (::windows::core::Interface::vtable(self).GetBufferByIndex)(::windows::core::Interface::as_raw(self), dwindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn ConvertToContiguousBuffer(&self) -> ::windows::core::Result<IMFMediaBuffer> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaBuffer>();
        (::windows::core::Interface::vtable(self).ConvertToContiguousBuffer)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn AddBuffer<P0>(&self, pbuffer: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaBuffer>,
    {
        (::windows::core::Interface::vtable(self).AddBuffer)(::windows::core::Interface::as_raw(self), pbuffer.into_param().abi()).ok()
    }
    pub unsafe fn RemoveBufferByIndex(&self, dwindex: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveBufferByIndex)(::windows::core::Interface::as_raw(self), dwindex).ok()
    }
    pub unsafe fn RemoveAllBuffers(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveAllBuffers)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetTotalLength(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetTotalLength)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn CopyToBuffer<P0>(&self, pbuffer: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaBuffer>,
    {
        (::windows::core::Interface::vtable(self).CopyToBuffer)(::windows::core::Interface::as_raw(self), pbuffer.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSample, ::windows::core::IUnknown, IMFAttributes);
impl ::core::cmp::PartialEq for IMFSample {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSample {}
impl ::core::fmt::Debug for IMFSample {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSample").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSample {
    type Vtable = IMFSample_Vtbl;
}
impl ::core::clone::Clone for IMFSample {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSample {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc40a00f2_b93a_4d80_ae8c_5a1c634f58e4);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSample_Vtbl {
    pub base__: IMFAttributes_Vtbl,
    pub GetSampleFlags: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwsampleflags: *mut u32) -> ::windows::core::HRESULT,
    pub SetSampleFlags: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwsampleflags: u32) -> ::windows::core::HRESULT,
    pub GetSampleTime: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, phnssampletime: *mut i64) -> ::windows::core::HRESULT,
    pub SetSampleTime: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hnssampletime: i64) -> ::windows::core::HRESULT,
    pub GetSampleDuration: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, phnssampleduration: *mut i64) -> ::windows::core::HRESULT,
    pub SetSampleDuration: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hnssampleduration: i64) -> ::windows::core::HRESULT,
    pub GetBufferCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwbuffercount: *mut u32) -> ::windows::core::HRESULT,
    pub GetBufferByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwindex: u32, ppbuffer: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub ConvertToContiguousBuffer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppbuffer: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub AddBuffer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbuffer: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RemoveBufferByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwindex: u32) -> ::windows::core::HRESULT,
    pub RemoveAllBuffers: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetTotalLength: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcbtotallength: *mut u32) -> ::windows::core::HRESULT,
    pub CopyToBuffer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbuffer: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSampleAllocatorControl(::windows::core::IUnknown);
impl IMFSampleAllocatorControl {
    pub unsafe fn SetDefaultAllocator<P0>(&self, dwoutputstreamid: u32, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).SetDefaultAllocator)(::windows::core::Interface::as_raw(self), dwoutputstreamid, pallocator.into_param().abi()).ok()
    }
    pub unsafe fn GetAllocatorUsage(&self, dwoutputstreamid: u32, pdwinputstreamid: *mut u32, peusage: *mut MFSampleAllocatorUsage) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetAllocatorUsage)(::windows::core::Interface::as_raw(self), dwoutputstreamid, pdwinputstreamid, peusage).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSampleAllocatorControl, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSampleAllocatorControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSampleAllocatorControl {}
impl ::core::fmt::Debug for IMFSampleAllocatorControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSampleAllocatorControl").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSampleAllocatorControl {
    type Vtable = IMFSampleAllocatorControl_Vtbl;
}
impl ::core::clone::Clone for IMFSampleAllocatorControl {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSampleAllocatorControl {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xda62b958_3a38_4a97_bd27_149c640c0771);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSampleAllocatorControl_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetDefaultAllocator: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, pallocator: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetAllocatorUsage: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, pdwinputstreamid: *mut u32, peusage: *mut MFSampleAllocatorUsage) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSampleGrabberSinkCallback(::windows::core::IUnknown);
impl IMFSampleGrabberSinkCallback {
    pub unsafe fn OnClockStart(&self, hnssystemtime: i64, llclockstartoffset: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.OnClockStart)(::windows::core::Interface::as_raw(self), hnssystemtime, llclockstartoffset).ok()
    }
    pub unsafe fn OnClockStop(&self, hnssystemtime: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.OnClockStop)(::windows::core::Interface::as_raw(self), hnssystemtime).ok()
    }
    pub unsafe fn OnClockPause(&self, hnssystemtime: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.OnClockPause)(::windows::core::Interface::as_raw(self), hnssystemtime).ok()
    }
    pub unsafe fn OnClockRestart(&self, hnssystemtime: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.OnClockRestart)(::windows::core::Interface::as_raw(self), hnssystemtime).ok()
    }
    pub unsafe fn OnClockSetRate(&self, hnssystemtime: i64, flrate: f32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.OnClockSetRate)(::windows::core::Interface::as_raw(self), hnssystemtime, flrate).ok()
    }
    pub unsafe fn OnSetPresentationClock<P0>(&self, ppresentationclock: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFPresentationClock>,
    {
        (::windows::core::Interface::vtable(self).OnSetPresentationClock)(::windows::core::Interface::as_raw(self), ppresentationclock.into_param().abi()).ok()
    }
    pub unsafe fn OnProcessSample(&self, guidmajormediatype: *const ::windows::core::GUID, dwsampleflags: u32, llsampletime: i64, llsampleduration: i64, psamplebuffer: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).OnProcessSample)(::windows::core::Interface::as_raw(self), guidmajormediatype, dwsampleflags, llsampletime, llsampleduration, ::core::mem::transmute(psamplebuffer.as_ptr()), psamplebuffer.len() as _).ok()
    }
    pub unsafe fn OnShutdown(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).OnShutdown)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSampleGrabberSinkCallback, ::windows::core::IUnknown, IMFClockStateSink);
impl ::core::cmp::PartialEq for IMFSampleGrabberSinkCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSampleGrabberSinkCallback {}
impl ::core::fmt::Debug for IMFSampleGrabberSinkCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSampleGrabberSinkCallback").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSampleGrabberSinkCallback {
    type Vtable = IMFSampleGrabberSinkCallback_Vtbl;
}
impl ::core::clone::Clone for IMFSampleGrabberSinkCallback {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSampleGrabberSinkCallback {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8c7b80bf_ee42_4b59_b1df_55668e1bdca8);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSampleGrabberSinkCallback_Vtbl {
    pub base__: IMFClockStateSink_Vtbl,
    pub OnSetPresentationClock: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppresentationclock: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub OnProcessSample: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidmajormediatype: *const ::windows::core::GUID, dwsampleflags: u32, llsampletime: i64, llsampleduration: i64, psamplebuffer: *const u8, dwsamplesize: u32) -> ::windows::core::HRESULT,
    pub OnShutdown: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSampleGrabberSinkCallback2(::windows::core::IUnknown);
impl IMFSampleGrabberSinkCallback2 {
    pub unsafe fn OnClockStart(&self, hnssystemtime: i64, llclockstartoffset: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.OnClockStart)(::windows::core::Interface::as_raw(self), hnssystemtime, llclockstartoffset).ok()
    }
    pub unsafe fn OnClockStop(&self, hnssystemtime: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.OnClockStop)(::windows::core::Interface::as_raw(self), hnssystemtime).ok()
    }
    pub unsafe fn OnClockPause(&self, hnssystemtime: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.OnClockPause)(::windows::core::Interface::as_raw(self), hnssystemtime).ok()
    }
    pub unsafe fn OnClockRestart(&self, hnssystemtime: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.OnClockRestart)(::windows::core::Interface::as_raw(self), hnssystemtime).ok()
    }
    pub unsafe fn OnClockSetRate(&self, hnssystemtime: i64, flrate: f32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.OnClockSetRate)(::windows::core::Interface::as_raw(self), hnssystemtime, flrate).ok()
    }
    pub unsafe fn OnSetPresentationClock<P0>(&self, ppresentationclock: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFPresentationClock>,
    {
        (::windows::core::Interface::vtable(self).base__.OnSetPresentationClock)(::windows::core::Interface::as_raw(self), ppresentationclock.into_param().abi()).ok()
    }
    pub unsafe fn OnProcessSample(&self, guidmajormediatype: *const ::windows::core::GUID, dwsampleflags: u32, llsampletime: i64, llsampleduration: i64, psamplebuffer: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.OnProcessSample)(::windows::core::Interface::as_raw(self), guidmajormediatype, dwsampleflags, llsampletime, llsampleduration, ::core::mem::transmute(psamplebuffer.as_ptr()), psamplebuffer.len() as _).ok()
    }
    pub unsafe fn OnShutdown(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.OnShutdown)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn OnProcessSampleEx<P0>(&self, guidmajormediatype: *const ::windows::core::GUID, dwsampleflags: u32, llsampletime: i64, llsampleduration: i64, psamplebuffer: &[u8], pattributes: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).OnProcessSampleEx)(::windows::core::Interface::as_raw(self), guidmajormediatype, dwsampleflags, llsampletime, llsampleduration, ::core::mem::transmute(psamplebuffer.as_ptr()), psamplebuffer.len() as _, pattributes.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSampleGrabberSinkCallback2, ::windows::core::IUnknown, IMFClockStateSink, IMFSampleGrabberSinkCallback);
impl ::core::cmp::PartialEq for IMFSampleGrabberSinkCallback2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSampleGrabberSinkCallback2 {}
impl ::core::fmt::Debug for IMFSampleGrabberSinkCallback2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSampleGrabberSinkCallback2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSampleGrabberSinkCallback2 {
    type Vtable = IMFSampleGrabberSinkCallback2_Vtbl;
}
impl ::core::clone::Clone for IMFSampleGrabberSinkCallback2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSampleGrabberSinkCallback2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xca86aa50_c46e_429e_ab27_16d6ac6844cb);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSampleGrabberSinkCallback2_Vtbl {
    pub base__: IMFSampleGrabberSinkCallback_Vtbl,
    pub OnProcessSampleEx: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidmajormediatype: *const ::windows::core::GUID, dwsampleflags: u32, llsampletime: i64, llsampleduration: i64, psamplebuffer: *const u8, dwsamplesize: u32, pattributes: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSampleOutputStream(::windows::core::IUnknown);
impl IMFSampleOutputStream {
    pub unsafe fn BeginWriteSample<P0, P1, P2>(&self, psample: P0, pcallback: P1, punkstate: P2) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFSample>,
        P1: ::windows::core::IntoParam<IMFAsyncCallback>,
        P2: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginWriteSample)(::windows::core::Interface::as_raw(self), psample.into_param().abi(), pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    pub unsafe fn EndWriteSample<P0>(&self, presult: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        (::windows::core::Interface::vtable(self).EndWriteSample)(::windows::core::Interface::as_raw(self), presult.into_param().abi()).ok()
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Close)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSampleOutputStream, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSampleOutputStream {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSampleOutputStream {}
impl ::core::fmt::Debug for IMFSampleOutputStream {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSampleOutputStream").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSampleOutputStream {
    type Vtable = IMFSampleOutputStream_Vtbl;
}
impl ::core::clone::Clone for IMFSampleOutputStream {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSampleOutputStream {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8feed468_6f7e_440d_869a_49bdd283ad0d);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSampleOutputStream_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub BeginWriteSample: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, psample: *mut ::core::ffi::c_void, pcallback: *mut ::core::ffi::c_void, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub EndWriteSample: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Close: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSampleProtection(::windows::core::IUnknown);
impl IMFSampleProtection {
    pub unsafe fn GetInputProtectionVersion(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetInputProtectionVersion)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetOutputProtectionVersion(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetOutputProtectionVersion)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetProtectionCertificate(&self, dwversion: u32, ppcert: *mut *mut u8, pcbcert: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetProtectionCertificate)(::windows::core::Interface::as_raw(self), dwversion, ppcert, pcbcert).ok()
    }
    pub unsafe fn InitOutputProtection(&self, dwversion: u32, dwoutputid: u32, pbcert: *const u8, cbcert: u32, ppbseed: *mut *mut u8, pcbseed: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).InitOutputProtection)(::windows::core::Interface::as_raw(self), dwversion, dwoutputid, pbcert, cbcert, ppbseed, pcbseed).ok()
    }
    pub unsafe fn InitInputProtection(&self, dwversion: u32, dwinputid: u32, pbseed: *const u8, cbseed: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).InitInputProtection)(::windows::core::Interface::as_raw(self), dwversion, dwinputid, pbseed, cbseed).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSampleProtection, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSampleProtection {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSampleProtection {}
impl ::core::fmt::Debug for IMFSampleProtection {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSampleProtection").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSampleProtection {
    type Vtable = IMFSampleProtection_Vtbl;
}
impl ::core::clone::Clone for IMFSampleProtection {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSampleProtection {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8e36395f_c7b9_43c4_a54d_512b4af63c95);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSampleProtection_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetInputProtectionVersion: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwversion: *mut u32) -> ::windows::core::HRESULT,
    pub GetOutputProtectionVersion: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwversion: *mut u32) -> ::windows::core::HRESULT,
    pub GetProtectionCertificate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwversion: u32, ppcert: *mut *mut u8, pcbcert: *mut u32) -> ::windows::core::HRESULT,
    pub InitOutputProtection: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwversion: u32, dwoutputid: u32, pbcert: *const u8, cbcert: u32, ppbseed: *mut *mut u8, pcbseed: *mut u32) -> ::windows::core::HRESULT,
    pub InitInputProtection: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwversion: u32, dwinputid: u32, pbseed: *const u8, cbseed: u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSaveJob(::windows::core::IUnknown);
impl IMFSaveJob {
    pub unsafe fn BeginSave<P0, P1, P2>(&self, pstream: P0, pcallback: P1, pstate: P2) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFByteStream>,
        P1: ::windows::core::IntoParam<IMFAsyncCallback>,
        P2: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginSave)(::windows::core::Interface::as_raw(self), pstream.into_param().abi(), pcallback.into_param().abi(), pstate.into_param().abi()).ok()
    }
    pub unsafe fn EndSave<P0>(&self, presult: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        (::windows::core::Interface::vtable(self).EndSave)(::windows::core::Interface::as_raw(self), presult.into_param().abi()).ok()
    }
    pub unsafe fn CancelSave(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).CancelSave)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetProgress(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetProgress)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFSaveJob, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSaveJob {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSaveJob {}
impl ::core::fmt::Debug for IMFSaveJob {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSaveJob").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSaveJob {
    type Vtable = IMFSaveJob_Vtbl;
}
impl ::core::clone::Clone for IMFSaveJob {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSaveJob {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe9931663_80bf_4c6e_98af_5dcf58747d1f);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSaveJob_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub BeginSave: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pstream: *mut ::core::ffi::c_void, pcallback: *mut ::core::ffi::c_void, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub EndSave: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub CancelSave: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetProgress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwpercentcomplete: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSchemeHandler(::windows::core::IUnknown);
impl IMFSchemeHandler {
    #[doc = "*Required features: `\"Win32_UI_Shell_PropertiesSystem\"`*"]
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub unsafe fn BeginCreateObject<P0, P1, P2, P3>(&self, pwszurl: P0, dwflags: u32, pprops: P1, ppiunknowncancelcookie: ::core::option::Option<*mut ::core::option::Option<::windows::core::IUnknown>>, pcallback: P2, punkstate: P3) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P1: ::windows::core::IntoParam<super::super::UI::Shell::PropertiesSystem::IPropertyStore>,
        P2: ::windows::core::IntoParam<IMFAsyncCallback>,
        P3: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginCreateObject)(::windows::core::Interface::as_raw(self), pwszurl.into_param().abi(), dwflags, pprops.into_param().abi(), ::core::mem::transmute(ppiunknowncancelcookie.unwrap_or(::std::ptr::null_mut())), pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    pub unsafe fn EndCreateObject<P0>(&self, presult: P0, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        (::windows::core::Interface::vtable(self).EndCreateObject)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), pobjecttype, ::core::mem::transmute(ppobject)).ok()
    }
    pub unsafe fn CancelObjectCreation<P0>(&self, piunknowncancelcookie: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).CancelObjectCreation)(::windows::core::Interface::as_raw(self), piunknowncancelcookie.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSchemeHandler, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSchemeHandler {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSchemeHandler {}
impl ::core::fmt::Debug for IMFSchemeHandler {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSchemeHandler").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSchemeHandler {
    type Vtable = IMFSchemeHandler_Vtbl;
}
impl ::core::clone::Clone for IMFSchemeHandler {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSchemeHandler {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6d4c7b74_52a0_4bb7_b0db_55f29f47a668);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSchemeHandler_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub BeginCreateObject: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pwszurl: ::windows::core::PCWSTR, dwflags: u32, pprops: *mut ::core::ffi::c_void, ppiunknowncancelcookie: *mut *mut ::core::ffi::c_void, pcallback: *mut ::core::ffi::c_void, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_UI_Shell_PropertiesSystem"))]
    BeginCreateObject: usize,
    pub EndCreateObject: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub CancelObjectCreation: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, piunknowncancelcookie: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSecureBuffer(::windows::core::IUnknown);
impl IMFSecureBuffer {
    pub unsafe fn GetIdentifier(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).GetIdentifier)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFSecureBuffer, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSecureBuffer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSecureBuffer {}
impl ::core::fmt::Debug for IMFSecureBuffer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSecureBuffer").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSecureBuffer {
    type Vtable = IMFSecureBuffer_Vtbl;
}
impl ::core::clone::Clone for IMFSecureBuffer {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSecureBuffer {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc1209904_e584_4752_a2d6_7f21693f8b21);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSecureBuffer_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetIdentifier: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pguididentifier: *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSecureChannel(::windows::core::IUnknown);
impl IMFSecureChannel {
    pub unsafe fn GetCertificate(&self, ppcert: *mut *mut u8, pcbcert: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetCertificate)(::windows::core::Interface::as_raw(self), ppcert, pcbcert).ok()
    }
    pub unsafe fn SetupSession(&self, pbencryptedsessionkey: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetupSession)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pbencryptedsessionkey.as_ptr()), pbencryptedsessionkey.len() as _).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSecureChannel, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSecureChannel {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSecureChannel {}
impl ::core::fmt::Debug for IMFSecureChannel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSecureChannel").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSecureChannel {
    type Vtable = IMFSecureChannel_Vtbl;
}
impl ::core::clone::Clone for IMFSecureChannel {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSecureChannel {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd0ae555d_3b12_4d97_b060_0990bc5aeb67);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSecureChannel_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetCertificate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppcert: *mut *mut u8, pcbcert: *mut u32) -> ::windows::core::HRESULT,
    pub SetupSession: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbencryptedsessionkey: *const u8, cbsessionkey: u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSeekInfo(::windows::core::IUnknown);
impl IMFSeekInfo {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetNearestKeyFrames(&self, pguidtimeformat: *const ::windows::core::GUID, pvarstartposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pvarpreviouskeyframe: *mut super::super::System::Com::StructuredStorage::PROPVARIANT, pvarnextkeyframe: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetNearestKeyFrames)(::windows::core::Interface::as_raw(self), pguidtimeformat, pvarstartposition, pvarpreviouskeyframe, pvarnextkeyframe).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSeekInfo, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSeekInfo {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSeekInfo {}
impl ::core::fmt::Debug for IMFSeekInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSeekInfo").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSeekInfo {
    type Vtable = IMFSeekInfo_Vtbl;
}
impl ::core::clone::Clone for IMFSeekInfo {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSeekInfo {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x26afea53_d9ed_42b5_ab80_e64f9ee34779);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSeekInfo_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub GetNearestKeyFrames: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pguidtimeformat: *const ::windows::core::GUID, pvarstartposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pvarpreviouskeyframe: *mut super::super::System::Com::StructuredStorage::PROPVARIANT, pvarnextkeyframe: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    GetNearestKeyFrames: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSensorActivitiesReport(::windows::core::IUnknown);
impl IMFSensorActivitiesReport {
    pub unsafe fn GetCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetActivityReport(&self, index: u32) -> ::windows::core::Result<IMFSensorActivityReport> {
        let mut result__ = ::windows::core::zeroed::<IMFSensorActivityReport>();
        (::windows::core::Interface::vtable(self).GetActivityReport)(::windows::core::Interface::as_raw(self), index, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetActivityReportByDeviceName<P0>(&self, symbolicname: P0) -> ::windows::core::Result<IMFSensorActivityReport>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFSensorActivityReport>();
        (::windows::core::Interface::vtable(self).GetActivityReportByDeviceName)(::windows::core::Interface::as_raw(self), symbolicname.into_param().abi(), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFSensorActivitiesReport, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSensorActivitiesReport {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSensorActivitiesReport {}
impl ::core::fmt::Debug for IMFSensorActivitiesReport {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSensorActivitiesReport").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSensorActivitiesReport {
    type Vtable = IMFSensorActivitiesReport_Vtbl;
}
impl ::core::clone::Clone for IMFSensorActivitiesReport {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSensorActivitiesReport {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x683f7a5e_4a19_43cd_b1a9_dbf4ab3f7777);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSensorActivitiesReport_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pccount: *mut u32) -> ::windows::core::HRESULT,
    pub GetActivityReport: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, sensoractivityreport: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetActivityReportByDeviceName: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, symbolicname: ::windows::core::PCWSTR, sensoractivityreport: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSensorActivitiesReportCallback(::windows::core::IUnknown);
impl IMFSensorActivitiesReportCallback {
    pub unsafe fn OnActivitiesReport<P0>(&self, sensoractivitiesreport: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFSensorActivitiesReport>,
    {
        (::windows::core::Interface::vtable(self).OnActivitiesReport)(::windows::core::Interface::as_raw(self), sensoractivitiesreport.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSensorActivitiesReportCallback, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSensorActivitiesReportCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSensorActivitiesReportCallback {}
impl ::core::fmt::Debug for IMFSensorActivitiesReportCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSensorActivitiesReportCallback").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSensorActivitiesReportCallback {
    type Vtable = IMFSensorActivitiesReportCallback_Vtbl;
}
impl ::core::clone::Clone for IMFSensorActivitiesReportCallback {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSensorActivitiesReportCallback {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xde5072ee_dbe3_46dc_8a87_b6f631194751);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSensorActivitiesReportCallback_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub OnActivitiesReport: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, sensoractivitiesreport: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSensorActivityMonitor(::windows::core::IUnknown);
impl IMFSensorActivityMonitor {
    pub unsafe fn Start(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Start)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Stop(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Stop)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSensorActivityMonitor, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSensorActivityMonitor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSensorActivityMonitor {}
impl ::core::fmt::Debug for IMFSensorActivityMonitor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSensorActivityMonitor").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSensorActivityMonitor {
    type Vtable = IMFSensorActivityMonitor_Vtbl;
}
impl ::core::clone::Clone for IMFSensorActivityMonitor {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSensorActivityMonitor {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd0cef145_b3f4_4340_a2e5_7a5080ca05cb);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSensorActivityMonitor_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub Start: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Stop: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSensorActivityReport(::windows::core::IUnknown);
impl IMFSensorActivityReport {
    pub unsafe fn GetFriendlyName(&self, friendlyname: &mut [u16], pcchwritten: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetFriendlyName)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(friendlyname.as_ptr()), friendlyname.len() as _, pcchwritten).ok()
    }
    pub unsafe fn GetSymbolicLink(&self, symboliclink: &mut [u16], pcchwritten: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetSymbolicLink)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(symboliclink.as_ptr()), symboliclink.len() as _, pcchwritten).ok()
    }
    pub unsafe fn GetProcessCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetProcessCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetProcessActivity(&self, index: u32) -> ::windows::core::Result<IMFSensorProcessActivity> {
        let mut result__ = ::windows::core::zeroed::<IMFSensorProcessActivity>();
        (::windows::core::Interface::vtable(self).GetProcessActivity)(::windows::core::Interface::as_raw(self), index, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFSensorActivityReport, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSensorActivityReport {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSensorActivityReport {}
impl ::core::fmt::Debug for IMFSensorActivityReport {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSensorActivityReport").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSensorActivityReport {
    type Vtable = IMFSensorActivityReport_Vtbl;
}
impl ::core::clone::Clone for IMFSensorActivityReport {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSensorActivityReport {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3e8c4be1_a8c2_4528_90de_2851bde5fead);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSensorActivityReport_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetFriendlyName: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, friendlyname: ::windows::core::PWSTR, cchfriendlyname: u32, pcchwritten: *mut u32) -> ::windows::core::HRESULT,
    pub GetSymbolicLink: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, symboliclink: ::windows::core::PWSTR, cchsymboliclink: u32, pcchwritten: *mut u32) -> ::windows::core::HRESULT,
    pub GetProcessCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pccount: *mut u32) -> ::windows::core::HRESULT,
    pub GetProcessActivity: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, ppprocessactivity: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSensorDevice(::windows::core::IUnknown);
impl IMFSensorDevice {
    pub unsafe fn GetDeviceId(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).GetDeviceId)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDeviceType(&self) -> ::windows::core::Result<MFSensorDeviceType> {
        let mut result__ = ::windows::core::zeroed::<MFSensorDeviceType>();
        (::windows::core::Interface::vtable(self).GetDeviceType)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetFlags(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).GetFlags)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetSymbolicLink(&self, symboliclink: &mut [u16], pcchwritten: *mut i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetSymbolicLink)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(symboliclink.as_ptr()), symboliclink.len() as _, pcchwritten).ok()
    }
    pub unsafe fn GetDeviceAttributes(&self) -> ::windows::core::Result<IMFAttributes> {
        let mut result__ = ::windows::core::zeroed::<IMFAttributes>();
        (::windows::core::Interface::vtable(self).GetDeviceAttributes)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStreamAttributesCount(&self, etype: MFSensorStreamType) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetStreamAttributesCount)(::windows::core::Interface::as_raw(self), etype, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStreamAttributes(&self, etype: MFSensorStreamType, dwindex: u32) -> ::windows::core::Result<IMFAttributes> {
        let mut result__ = ::windows::core::zeroed::<IMFAttributes>();
        (::windows::core::Interface::vtable(self).GetStreamAttributes)(::windows::core::Interface::as_raw(self), etype, dwindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetSensorDeviceMode(&self, emode: MFSensorDeviceMode) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetSensorDeviceMode)(::windows::core::Interface::as_raw(self), emode).ok()
    }
    pub unsafe fn GetSensorDeviceMode(&self) -> ::windows::core::Result<MFSensorDeviceMode> {
        let mut result__ = ::windows::core::zeroed::<MFSensorDeviceMode>();
        (::windows::core::Interface::vtable(self).GetSensorDeviceMode)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFSensorDevice, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSensorDevice {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSensorDevice {}
impl ::core::fmt::Debug for IMFSensorDevice {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSensorDevice").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSensorDevice {
    type Vtable = IMFSensorDevice_Vtbl;
}
impl ::core::clone::Clone for IMFSensorDevice {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSensorDevice {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfb9f48f2_2a18_4e28_9730_786f30f04dc4);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSensorDevice_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetDeviceId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdeviceid: *mut u64) -> ::windows::core::HRESULT,
    pub GetDeviceType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ptype: *mut MFSensorDeviceType) -> ::windows::core::HRESULT,
    pub GetFlags: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pflags: *mut u64) -> ::windows::core::HRESULT,
    pub GetSymbolicLink: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, symboliclink: ::windows::core::PWSTR, cchsymboliclink: i32, pcchwritten: *mut i32) -> ::windows::core::HRESULT,
    pub GetDeviceAttributes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppattributes: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetStreamAttributesCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, etype: MFSensorStreamType, pdwcount: *mut u32) -> ::windows::core::HRESULT,
    pub GetStreamAttributes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, etype: MFSensorStreamType, dwindex: u32, ppattributes: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetSensorDeviceMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, emode: MFSensorDeviceMode) -> ::windows::core::HRESULT,
    pub GetSensorDeviceMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pemode: *mut MFSensorDeviceMode) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSensorGroup(::windows::core::IUnknown);
impl IMFSensorGroup {
    pub unsafe fn GetSymbolicLink(&self, symboliclink: &mut [u16], pcchwritten: *mut i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetSymbolicLink)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(symboliclink.as_ptr()), symboliclink.len() as _, pcchwritten).ok()
    }
    pub unsafe fn GetFlags(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).GetFlags)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetSensorGroupAttributes(&self) -> ::windows::core::Result<IMFAttributes> {
        let mut result__ = ::windows::core::zeroed::<IMFAttributes>();
        (::windows::core::Interface::vtable(self).GetSensorGroupAttributes)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetSensorDeviceCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetSensorDeviceCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetSensorDevice(&self, dwindex: u32) -> ::windows::core::Result<IMFSensorDevice> {
        let mut result__ = ::windows::core::zeroed::<IMFSensorDevice>();
        (::windows::core::Interface::vtable(self).GetSensorDevice)(::windows::core::Interface::as_raw(self), dwindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetDefaultSensorDeviceIndex(&self, dwindex: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetDefaultSensorDeviceIndex)(::windows::core::Interface::as_raw(self), dwindex).ok()
    }
    pub unsafe fn GetDefaultSensorDeviceIndex(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetDefaultSensorDeviceIndex)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn CreateMediaSource(&self) -> ::windows::core::Result<IMFMediaSource> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaSource>();
        (::windows::core::Interface::vtable(self).CreateMediaSource)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFSensorGroup, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSensorGroup {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSensorGroup {}
impl ::core::fmt::Debug for IMFSensorGroup {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSensorGroup").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSensorGroup {
    type Vtable = IMFSensorGroup_Vtbl;
}
impl ::core::clone::Clone for IMFSensorGroup {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSensorGroup {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4110243a_9757_461f_89f1_f22345bcab4e);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSensorGroup_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetSymbolicLink: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, symboliclink: ::windows::core::PWSTR, cchsymboliclink: i32, pcchwritten: *mut i32) -> ::windows::core::HRESULT,
    pub GetFlags: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pflags: *mut u64) -> ::windows::core::HRESULT,
    pub GetSensorGroupAttributes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppattributes: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetSensorDeviceCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwcount: *mut u32) -> ::windows::core::HRESULT,
    pub GetSensorDevice: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwindex: u32, ppdevice: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetDefaultSensorDeviceIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwindex: u32) -> ::windows::core::HRESULT,
    pub GetDefaultSensorDeviceIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwindex: *mut u32) -> ::windows::core::HRESULT,
    pub CreateMediaSource: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppsource: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSensorProcessActivity(::windows::core::IUnknown);
impl IMFSensorProcessActivity {
    pub unsafe fn GetProcessId(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetProcessId)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetStreamingState(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).GetStreamingState)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStreamingMode(&self) -> ::windows::core::Result<MFSensorDeviceMode> {
        let mut result__ = ::windows::core::zeroed::<MFSensorDeviceMode>();
        (::windows::core::Interface::vtable(self).GetStreamingMode)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetReportTime(&self) -> ::windows::core::Result<super::super::Foundation::FILETIME> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::FILETIME>();
        (::windows::core::Interface::vtable(self).GetReportTime)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFSensorProcessActivity, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSensorProcessActivity {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSensorProcessActivity {}
impl ::core::fmt::Debug for IMFSensorProcessActivity {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSensorProcessActivity").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSensorProcessActivity {
    type Vtable = IMFSensorProcessActivity_Vtbl;
}
impl ::core::clone::Clone for IMFSensorProcessActivity {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSensorProcessActivity {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x39dc7f4a_b141_4719_813c_a7f46162a2b8);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSensorProcessActivity_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetProcessId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppid: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub GetStreamingState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pfstreaming: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetStreamingState: usize,
    pub GetStreamingMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pmode: *mut MFSensorDeviceMode) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub GetReportTime: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pft: *mut super::super::Foundation::FILETIME) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetReportTime: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSensorProfile(::windows::core::IUnknown);
impl IMFSensorProfile {
    pub unsafe fn GetProfileId(&self, pid: *mut SENSORPROFILEID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetProfileId)(::windows::core::Interface::as_raw(self), pid).ok()
    }
    pub unsafe fn AddProfileFilter<P0>(&self, streamid: u32, wzfiltersetstring: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).AddProfileFilter)(::windows::core::Interface::as_raw(self), streamid, wzfiltersetstring.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsMediaTypeSupported<P0>(&self, streamid: u32, pmediatype: P0) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).IsMediaTypeSupported)(::windows::core::Interface::as_raw(self), streamid, pmediatype.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn AddBlockedControl<P0>(&self, wzblockedcontrol: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).AddBlockedControl)(::windows::core::Interface::as_raw(self), wzblockedcontrol.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSensorProfile, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSensorProfile {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSensorProfile {}
impl ::core::fmt::Debug for IMFSensorProfile {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSensorProfile").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSensorProfile {
    type Vtable = IMFSensorProfile_Vtbl;
}
impl ::core::clone::Clone for IMFSensorProfile {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSensorProfile {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x22f765d1_8dab_4107_846d_56baf72215e7);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSensorProfile_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetProfileId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pid: *mut SENSORPROFILEID) -> ::windows::core::HRESULT,
    pub AddProfileFilter: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, streamid: u32, wzfiltersetstring: ::windows::core::PCWSTR) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub IsMediaTypeSupported: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, streamid: u32, pmediatype: *mut ::core::ffi::c_void, pfsupported: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsMediaTypeSupported: usize,
    pub AddBlockedControl: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, wzblockedcontrol: ::windows::core::PCWSTR) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSensorProfileCollection(::windows::core::IUnknown);
impl IMFSensorProfileCollection {
    pub unsafe fn GetProfileCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetProfileCount)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetProfile(&self, index: u32) -> ::windows::core::Result<IMFSensorProfile> {
        let mut result__ = ::windows::core::zeroed::<IMFSensorProfile>();
        (::windows::core::Interface::vtable(self).GetProfile)(::windows::core::Interface::as_raw(self), index, &mut result__).from_abi(result__)
    }
    pub unsafe fn AddProfile<P0>(&self, pprofile: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFSensorProfile>,
    {
        (::windows::core::Interface::vtable(self).AddProfile)(::windows::core::Interface::as_raw(self), pprofile.into_param().abi()).ok()
    }
    pub unsafe fn FindProfile(&self, profileid: *const SENSORPROFILEID) -> ::windows::core::Result<IMFSensorProfile> {
        let mut result__ = ::windows::core::zeroed::<IMFSensorProfile>();
        (::windows::core::Interface::vtable(self).FindProfile)(::windows::core::Interface::as_raw(self), profileid, &mut result__).from_abi(result__)
    }
    pub unsafe fn RemoveProfileByIndex(&self, index: u32) {
        (::windows::core::Interface::vtable(self).RemoveProfileByIndex)(::windows::core::Interface::as_raw(self), index)
    }
    pub unsafe fn RemoveProfile(&self, profileid: *const SENSORPROFILEID) {
        (::windows::core::Interface::vtable(self).RemoveProfile)(::windows::core::Interface::as_raw(self), profileid)
    }
}
::windows::imp::interface_hierarchy!(IMFSensorProfileCollection, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSensorProfileCollection {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSensorProfileCollection {}
impl ::core::fmt::Debug for IMFSensorProfileCollection {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSensorProfileCollection").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSensorProfileCollection {
    type Vtable = IMFSensorProfileCollection_Vtbl;
}
impl ::core::clone::Clone for IMFSensorProfileCollection {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSensorProfileCollection {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc95ea55b_0187_48be_9353_8d2507662351);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSensorProfileCollection_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetProfileCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetProfile: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, ppprofile: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub AddProfile: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pprofile: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub FindProfile: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, profileid: *const SENSORPROFILEID, ppprofile: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RemoveProfileByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32),
    pub RemoveProfile: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, profileid: *const SENSORPROFILEID),
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSensorStream(::windows::core::IUnknown);
impl IMFSensorStream {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItem(&self, guidkey: *const ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItem)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetItemType(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<MF_ATTRIBUTE_TYPE> {
        let mut result__ = ::windows::core::zeroed::<MF_ATTRIBUTE_TYPE>();
        (::windows::core::Interface::vtable(self).base__.GetItemType)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn CompareItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.CompareItem)(::windows::core::Interface::as_raw(self), guidkey, value, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Compare<P0>(&self, ptheirs: P0, matchtype: MF_ATTRIBUTES_MATCH_TYPE) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.Compare)(::windows::core::Interface::as_raw(self), ptheirs.into_param().abi(), matchtype, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT32(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetUINT32)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT64(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).base__.GetUINT64)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDouble(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).base__.GetDouble)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetGUID(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).base__.GetGUID)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStringLength(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetStringLength)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetString(&self, guidkey: *const ::windows::core::GUID, pwszvalue: &mut [u16], pcchlength: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetString)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pwszvalue.as_ptr()), pwszvalue.len() as _, ::core::mem::transmute(pcchlength.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedString(&self, guidkey: *const ::windows::core::GUID, ppwszvalue: *mut ::windows::core::PWSTR, pcchlength: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedString)(::windows::core::Interface::as_raw(self), guidkey, ppwszvalue, pcchlength).ok()
    }
    pub unsafe fn GetBlobSize(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetBlobSize)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &mut [u8], pcbblobsize: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _, ::core::mem::transmute(pcbblobsize.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedBlob(&self, guidkey: *const ::windows::core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedBlob)(::windows::core::Interface::as_raw(self), guidkey, ppbuf, pcbsize).ok()
    }
    pub unsafe fn GetUnknown<T>(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.GetUnknown)(::windows::core::Interface::as_raw(self), guidkey, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetItem)(::windows::core::Interface::as_raw(self), guidkey, value).ok()
    }
    pub unsafe fn DeleteItem(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteItem)(::windows::core::Interface::as_raw(self), guidkey).ok()
    }
    pub unsafe fn DeleteAllItems(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteAllItems)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetUINT32(&self, guidkey: *const ::windows::core::GUID, unvalue: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT32)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetUINT64(&self, guidkey: *const ::windows::core::GUID, unvalue: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT64)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetDouble(&self, guidkey: *const ::windows::core::GUID, fvalue: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetDouble)(::windows::core::Interface::as_raw(self), guidkey, fvalue).ok()
    }
    pub unsafe fn SetGUID(&self, guidkey: *const ::windows::core::GUID, guidvalue: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetGUID)(::windows::core::Interface::as_raw(self), guidkey, guidvalue).ok()
    }
    pub unsafe fn SetString<P0>(&self, guidkey: *const ::windows::core::GUID, wszvalue: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.SetString)(::windows::core::Interface::as_raw(self), guidkey, wszvalue.into_param().abi()).ok()
    }
    pub unsafe fn SetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _).ok()
    }
    pub unsafe fn SetUnknown<P0>(&self, guidkey: *const ::windows::core::GUID, punknown: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.SetUnknown)(::windows::core::Interface::as_raw(self), guidkey, punknown.into_param().abi()).ok()
    }
    pub unsafe fn LockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.LockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn UnlockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.UnlockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItemByIndex(&self, unindex: u32, pguidkey: *mut ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItemByIndex)(::windows::core::Interface::as_raw(self), unindex, pguidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn CopyAllItems<P0>(&self, pdest: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).base__.CopyAllItems)(::windows::core::Interface::as_raw(self), pdest.into_param().abi()).ok()
    }
    pub unsafe fn GetMediaTypeCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetMediaTypeCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetMediaType(&self, dwindex: u32) -> ::windows::core::Result<IMFMediaType> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
        (::windows::core::Interface::vtable(self).GetMediaType)(::windows::core::Interface::as_raw(self), dwindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn CloneSensorStream(&self) -> ::windows::core::Result<IMFSensorStream> {
        let mut result__ = ::windows::core::zeroed::<IMFSensorStream>();
        (::windows::core::Interface::vtable(self).CloneSensorStream)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFSensorStream, ::windows::core::IUnknown, IMFAttributes);
impl ::core::cmp::PartialEq for IMFSensorStream {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSensorStream {}
impl ::core::fmt::Debug for IMFSensorStream {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSensorStream").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSensorStream {
    type Vtable = IMFSensorStream_Vtbl;
}
impl ::core::clone::Clone for IMFSensorStream {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSensorStream {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe9a42171_c56e_498a_8b39_eda5a070b7fc);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSensorStream_Vtbl {
    pub base__: IMFAttributes_Vtbl,
    pub GetMediaTypeCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwcount: *mut u32) -> ::windows::core::HRESULT,
    pub GetMediaType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwindex: u32, ppmediatype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub CloneSensorStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppstream: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSensorTransformFactory(::windows::core::IUnknown);
impl IMFSensorTransformFactory {
    pub unsafe fn GetFactoryAttributes(&self) -> ::windows::core::Result<IMFAttributes> {
        let mut result__ = ::windows::core::zeroed::<IMFAttributes>();
        (::windows::core::Interface::vtable(self).GetFactoryAttributes)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn InitializeFactory<P0, P1>(&self, dwmaxtransformcount: u32, psensordevices: P0, pattributes: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFCollection>,
        P1: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).InitializeFactory)(::windows::core::Interface::as_raw(self), dwmaxtransformcount, psensordevices.into_param().abi(), pattributes.into_param().abi()).ok()
    }
    pub unsafe fn GetTransformCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetTransformCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetTransformInformation(&self, transformindex: u32, pguidtransformid: *mut ::windows::core::GUID, ppattributes: *mut ::core::option::Option<IMFAttributes>, ppstreaminformation: *mut ::core::option::Option<IMFCollection>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetTransformInformation)(::windows::core::Interface::as_raw(self), transformindex, pguidtransformid, ::core::mem::transmute(ppattributes), ::core::mem::transmute(ppstreaminformation)).ok()
    }
    pub unsafe fn CreateTransform<P0>(&self, guidsensortransformid: *const ::windows::core::GUID, pattributes: P0) -> ::windows::core::Result<IMFDeviceTransform>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFDeviceTransform>();
        (::windows::core::Interface::vtable(self).CreateTransform)(::windows::core::Interface::as_raw(self), guidsensortransformid, pattributes.into_param().abi(), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFSensorTransformFactory, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSensorTransformFactory {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSensorTransformFactory {}
impl ::core::fmt::Debug for IMFSensorTransformFactory {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSensorTransformFactory").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSensorTransformFactory {
    type Vtable = IMFSensorTransformFactory_Vtbl;
}
impl ::core::clone::Clone for IMFSensorTransformFactory {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSensorTransformFactory {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xeed9c2ee_66b4_4f18_a697_ac7d3960215c);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSensorTransformFactory_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetFactoryAttributes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppattributes: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub InitializeFactory: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwmaxtransformcount: u32, psensordevices: *mut ::core::ffi::c_void, pattributes: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetTransformCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwcount: *mut u32) -> ::windows::core::HRESULT,
    pub GetTransformInformation: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, transformindex: u32, pguidtransformid: *mut ::windows::core::GUID, ppattributes: *mut *mut ::core::ffi::c_void, ppstreaminformation: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub CreateTransform: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidsensortransformid: *const ::windows::core::GUID, pattributes: *mut ::core::ffi::c_void, ppdevicemft: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSequencerSource(::windows::core::IUnknown);
impl IMFSequencerSource {
    pub unsafe fn AppendTopology<P0>(&self, ptopology: P0, dwflags: u32) -> ::windows::core::Result<u32>
    where
        P0: ::windows::core::IntoParam<IMFTopology>,
    {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).AppendTopology)(::windows::core::Interface::as_raw(self), ptopology.into_param().abi(), dwflags, &mut result__).from_abi(result__)
    }
    pub unsafe fn DeleteTopology(&self, dwid: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).DeleteTopology)(::windows::core::Interface::as_raw(self), dwid).ok()
    }
    pub unsafe fn GetPresentationContext<P0>(&self, ppd: P0, pid: ::core::option::Option<*mut u32>, pptopology: ::core::option::Option<*mut ::core::option::Option<IMFTopology>>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFPresentationDescriptor>,
    {
        (::windows::core::Interface::vtable(self).GetPresentationContext)(::windows::core::Interface::as_raw(self), ppd.into_param().abi(), ::core::mem::transmute(pid.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(pptopology.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn UpdateTopology<P0>(&self, dwid: u32, ptopology: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFTopology>,
    {
        (::windows::core::Interface::vtable(self).UpdateTopology)(::windows::core::Interface::as_raw(self), dwid, ptopology.into_param().abi()).ok()
    }
    pub unsafe fn UpdateTopologyFlags(&self, dwid: u32, dwflags: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).UpdateTopologyFlags)(::windows::core::Interface::as_raw(self), dwid, dwflags).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSequencerSource, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSequencerSource {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSequencerSource {}
impl ::core::fmt::Debug for IMFSequencerSource {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSequencerSource").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSequencerSource {
    type Vtable = IMFSequencerSource_Vtbl;
}
impl ::core::clone::Clone for IMFSequencerSource {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSequencerSource {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x197cd219_19cb_4de1_a64c_acf2edcbe59e);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSequencerSource_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub AppendTopology: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ptopology: *mut ::core::ffi::c_void, dwflags: u32, pdwid: *mut u32) -> ::windows::core::HRESULT,
    pub DeleteTopology: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwid: u32) -> ::windows::core::HRESULT,
    pub GetPresentationContext: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppd: *mut ::core::ffi::c_void, pid: *mut u32, pptopology: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub UpdateTopology: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwid: u32, ptopology: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub UpdateTopologyFlags: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwid: u32, dwflags: u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSharingEngineClassFactory(::windows::core::IUnknown);
impl IMFSharingEngineClassFactory {
    pub unsafe fn CreateInstance<P0>(&self, dwflags: u32, pattr: P0) -> ::windows::core::Result<::windows::core::IUnknown>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::core::IUnknown>();
        (::windows::core::Interface::vtable(self).CreateInstance)(::windows::core::Interface::as_raw(self), dwflags, pattr.into_param().abi(), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFSharingEngineClassFactory, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSharingEngineClassFactory {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSharingEngineClassFactory {}
impl ::core::fmt::Debug for IMFSharingEngineClassFactory {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSharingEngineClassFactory").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSharingEngineClassFactory {
    type Vtable = IMFSharingEngineClassFactory_Vtbl;
}
impl ::core::clone::Clone for IMFSharingEngineClassFactory {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSharingEngineClassFactory {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2ba61f92_8305_413b_9733_faf15f259384);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSharingEngineClassFactory_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub CreateInstance: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwflags: u32, pattr: *mut ::core::ffi::c_void, ppengine: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFShutdown(::windows::core::IUnknown);
impl IMFShutdown {
    pub unsafe fn Shutdown(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Shutdown)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetShutdownStatus(&self) -> ::windows::core::Result<MFSHUTDOWN_STATUS> {
        let mut result__ = ::windows::core::zeroed::<MFSHUTDOWN_STATUS>();
        (::windows::core::Interface::vtable(self).GetShutdownStatus)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFShutdown, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFShutdown {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFShutdown {}
impl ::core::fmt::Debug for IMFShutdown {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFShutdown").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFShutdown {
    type Vtable = IMFShutdown_Vtbl;
}
impl ::core::clone::Clone for IMFShutdown {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFShutdown {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x97ec2ea4_0e42_4937_97ac_9d6d328824e1);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFShutdown_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub Shutdown: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetShutdownStatus: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pstatus: *mut MFSHUTDOWN_STATUS) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSignedLibrary(::windows::core::IUnknown);
impl IMFSignedLibrary {
    pub unsafe fn GetProcedureAddress<P0>(&self, name: P0, address: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCSTR>,
    {
        (::windows::core::Interface::vtable(self).GetProcedureAddress)(::windows::core::Interface::as_raw(self), name.into_param().abi(), address).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSignedLibrary, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSignedLibrary {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSignedLibrary {}
impl ::core::fmt::Debug for IMFSignedLibrary {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSignedLibrary").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSignedLibrary {
    type Vtable = IMFSignedLibrary_Vtbl;
}
impl ::core::clone::Clone for IMFSignedLibrary {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSignedLibrary {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4a724bca_ff6a_4c07_8e0d_7a358421cf06);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSignedLibrary_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetProcedureAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, name: ::windows::core::PCSTR, address: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSimpleAudioVolume(::windows::core::IUnknown);
impl IMFSimpleAudioVolume {
    pub unsafe fn SetMasterVolume(&self, flevel: f32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetMasterVolume)(::windows::core::Interface::as_raw(self), flevel).ok()
    }
    pub unsafe fn GetMasterVolume(&self) -> ::windows::core::Result<f32> {
        let mut result__ = ::windows::core::zeroed::<f32>();
        (::windows::core::Interface::vtable(self).GetMasterVolume)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetMute<P0>(&self, bmute: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetMute)(::windows::core::Interface::as_raw(self), bmute.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetMute(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).GetMute)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFSimpleAudioVolume, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSimpleAudioVolume {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSimpleAudioVolume {}
impl ::core::fmt::Debug for IMFSimpleAudioVolume {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSimpleAudioVolume").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSimpleAudioVolume {
    type Vtable = IMFSimpleAudioVolume_Vtbl;
}
impl ::core::clone::Clone for IMFSimpleAudioVolume {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSimpleAudioVolume {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x089edf13_cf71_4338_8d13_9e569dbdc319);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSimpleAudioVolume_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetMasterVolume: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, flevel: f32) -> ::windows::core::HRESULT,
    pub GetMasterVolume: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pflevel: *mut f32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub SetMute: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, bmute: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetMute: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub GetMute: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbmute: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetMute: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSinkWriter(::windows::core::IUnknown);
impl IMFSinkWriter {
    pub unsafe fn AddStream<P0>(&self, ptargetmediatype: P0) -> ::windows::core::Result<u32>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).AddStream)(::windows::core::Interface::as_raw(self), ptargetmediatype.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetInputMediaType<P0, P1>(&self, dwstreamindex: u32, pinputmediatype: P0, pencodingparameters: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
        P1: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).SetInputMediaType)(::windows::core::Interface::as_raw(self), dwstreamindex, pinputmediatype.into_param().abi(), pencodingparameters.into_param().abi()).ok()
    }
    pub unsafe fn BeginWriting(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).BeginWriting)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn WriteSample<P0>(&self, dwstreamindex: u32, psample: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFSample>,
    {
        (::windows::core::Interface::vtable(self).WriteSample)(::windows::core::Interface::as_raw(self), dwstreamindex, psample.into_param().abi()).ok()
    }
    pub unsafe fn SendStreamTick(&self, dwstreamindex: u32, lltimestamp: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SendStreamTick)(::windows::core::Interface::as_raw(self), dwstreamindex, lltimestamp).ok()
    }
    pub unsafe fn PlaceMarker(&self, dwstreamindex: u32, pvcontext: *const ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).PlaceMarker)(::windows::core::Interface::as_raw(self), dwstreamindex, pvcontext).ok()
    }
    pub unsafe fn NotifyEndOfSegment(&self, dwstreamindex: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).NotifyEndOfSegment)(::windows::core::Interface::as_raw(self), dwstreamindex).ok()
    }
    pub unsafe fn Flush(&self, dwstreamindex: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Flush)(::windows::core::Interface::as_raw(self), dwstreamindex).ok()
    }
    pub unsafe fn Finalize(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Finalize)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetServiceForStream(&self, dwstreamindex: u32, guidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetServiceForStream)(::windows::core::Interface::as_raw(self), dwstreamindex, guidservice, riid, ppvobject).ok()
    }
    pub unsafe fn GetStatistics(&self, dwstreamindex: u32, pstats: *mut MF_SINK_WRITER_STATISTICS) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetStatistics)(::windows::core::Interface::as_raw(self), dwstreamindex, pstats).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSinkWriter, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSinkWriter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSinkWriter {}
impl ::core::fmt::Debug for IMFSinkWriter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSinkWriter").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSinkWriter {
    type Vtable = IMFSinkWriter_Vtbl;
}
impl ::core::clone::Clone for IMFSinkWriter {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSinkWriter {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3137f1cd_fe5e_4805_a5d8_fb477448cb3d);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSinkWriter_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub AddStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ptargetmediatype: *mut ::core::ffi::c_void, pdwstreamindex: *mut u32) -> ::windows::core::HRESULT,
    pub SetInputMediaType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pinputmediatype: *mut ::core::ffi::c_void, pencodingparameters: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub BeginWriting: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub WriteSample: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, psample: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SendStreamTick: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, lltimestamp: i64) -> ::windows::core::HRESULT,
    pub PlaceMarker: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pvcontext: *const ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub NotifyEndOfSegment: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32) -> ::windows::core::HRESULT,
    pub Flush: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32) -> ::windows::core::HRESULT,
    pub Finalize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetServiceForStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, guidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetStatistics: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pstats: *mut MF_SINK_WRITER_STATISTICS) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSinkWriterCallback(::windows::core::IUnknown);
impl IMFSinkWriterCallback {
    pub unsafe fn OnFinalize(&self, hrstatus: ::windows::core::HRESULT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).OnFinalize)(::windows::core::Interface::as_raw(self), hrstatus).ok()
    }
    pub unsafe fn OnMarker(&self, dwstreamindex: u32, pvcontext: *const ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).OnMarker)(::windows::core::Interface::as_raw(self), dwstreamindex, pvcontext).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSinkWriterCallback, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSinkWriterCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSinkWriterCallback {}
impl ::core::fmt::Debug for IMFSinkWriterCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSinkWriterCallback").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSinkWriterCallback {
    type Vtable = IMFSinkWriterCallback_Vtbl;
}
impl ::core::clone::Clone for IMFSinkWriterCallback {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSinkWriterCallback {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x666f76de_33d2_41b9_a458_29ed0a972c58);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSinkWriterCallback_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub OnFinalize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hrstatus: ::windows::core::HRESULT) -> ::windows::core::HRESULT,
    pub OnMarker: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pvcontext: *const ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSinkWriterCallback2(::windows::core::IUnknown);
impl IMFSinkWriterCallback2 {
    pub unsafe fn OnFinalize(&self, hrstatus: ::windows::core::HRESULT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.OnFinalize)(::windows::core::Interface::as_raw(self), hrstatus).ok()
    }
    pub unsafe fn OnMarker(&self, dwstreamindex: u32, pvcontext: *const ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.OnMarker)(::windows::core::Interface::as_raw(self), dwstreamindex, pvcontext).ok()
    }
    pub unsafe fn OnTransformChange(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).OnTransformChange)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn OnStreamError(&self, dwstreamindex: u32, hrstatus: ::windows::core::HRESULT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).OnStreamError)(::windows::core::Interface::as_raw(self), dwstreamindex, hrstatus).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSinkWriterCallback2, ::windows::core::IUnknown, IMFSinkWriterCallback);
impl ::core::cmp::PartialEq for IMFSinkWriterCallback2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSinkWriterCallback2 {}
impl ::core::fmt::Debug for IMFSinkWriterCallback2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSinkWriterCallback2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSinkWriterCallback2 {
    type Vtable = IMFSinkWriterCallback2_Vtbl;
}
impl ::core::clone::Clone for IMFSinkWriterCallback2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSinkWriterCallback2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2456bd58_c067_4513_84fe_8d0c88ffdc61);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSinkWriterCallback2_Vtbl {
    pub base__: IMFSinkWriterCallback_Vtbl,
    pub OnTransformChange: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub OnStreamError: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, hrstatus: ::windows::core::HRESULT) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSinkWriterEncoderConfig(::windows::core::IUnknown);
impl IMFSinkWriterEncoderConfig {
    pub unsafe fn SetTargetMediaType<P0, P1>(&self, dwstreamindex: u32, ptargetmediatype: P0, pencodingparameters: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
        P1: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).SetTargetMediaType)(::windows::core::Interface::as_raw(self), dwstreamindex, ptargetmediatype.into_param().abi(), pencodingparameters.into_param().abi()).ok()
    }
    pub unsafe fn PlaceEncodingParameters<P0>(&self, dwstreamindex: u32, pencodingparameters: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).PlaceEncodingParameters)(::windows::core::Interface::as_raw(self), dwstreamindex, pencodingparameters.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSinkWriterEncoderConfig, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSinkWriterEncoderConfig {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSinkWriterEncoderConfig {}
impl ::core::fmt::Debug for IMFSinkWriterEncoderConfig {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSinkWriterEncoderConfig").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSinkWriterEncoderConfig {
    type Vtable = IMFSinkWriterEncoderConfig_Vtbl;
}
impl ::core::clone::Clone for IMFSinkWriterEncoderConfig {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSinkWriterEncoderConfig {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x17c3779e_3cde_4ede_8c60_3899f5f53ad6);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSinkWriterEncoderConfig_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetTargetMediaType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, ptargetmediatype: *mut ::core::ffi::c_void, pencodingparameters: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub PlaceEncodingParameters: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pencodingparameters: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSinkWriterEx(::windows::core::IUnknown);
impl IMFSinkWriterEx {
    pub unsafe fn AddStream<P0>(&self, ptargetmediatype: P0) -> ::windows::core::Result<u32>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.AddStream)(::windows::core::Interface::as_raw(self), ptargetmediatype.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetInputMediaType<P0, P1>(&self, dwstreamindex: u32, pinputmediatype: P0, pencodingparameters: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
        P1: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).base__.SetInputMediaType)(::windows::core::Interface::as_raw(self), dwstreamindex, pinputmediatype.into_param().abi(), pencodingparameters.into_param().abi()).ok()
    }
    pub unsafe fn BeginWriting(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.BeginWriting)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn WriteSample<P0>(&self, dwstreamindex: u32, psample: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFSample>,
    {
        (::windows::core::Interface::vtable(self).base__.WriteSample)(::windows::core::Interface::as_raw(self), dwstreamindex, psample.into_param().abi()).ok()
    }
    pub unsafe fn SendStreamTick(&self, dwstreamindex: u32, lltimestamp: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SendStreamTick)(::windows::core::Interface::as_raw(self), dwstreamindex, lltimestamp).ok()
    }
    pub unsafe fn PlaceMarker(&self, dwstreamindex: u32, pvcontext: *const ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.PlaceMarker)(::windows::core::Interface::as_raw(self), dwstreamindex, pvcontext).ok()
    }
    pub unsafe fn NotifyEndOfSegment(&self, dwstreamindex: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.NotifyEndOfSegment)(::windows::core::Interface::as_raw(self), dwstreamindex).ok()
    }
    pub unsafe fn Flush(&self, dwstreamindex: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Flush)(::windows::core::Interface::as_raw(self), dwstreamindex).ok()
    }
    pub unsafe fn Finalize(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Finalize)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetServiceForStream(&self, dwstreamindex: u32, guidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetServiceForStream)(::windows::core::Interface::as_raw(self), dwstreamindex, guidservice, riid, ppvobject).ok()
    }
    pub unsafe fn GetStatistics(&self, dwstreamindex: u32, pstats: *mut MF_SINK_WRITER_STATISTICS) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetStatistics)(::windows::core::Interface::as_raw(self), dwstreamindex, pstats).ok()
    }
    pub unsafe fn GetTransformForStream(&self, dwstreamindex: u32, dwtransformindex: u32, pguidcategory: ::core::option::Option<*mut ::windows::core::GUID>, pptransform: *mut ::core::option::Option<IMFTransform>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetTransformForStream)(::windows::core::Interface::as_raw(self), dwstreamindex, dwtransformindex, ::core::mem::transmute(pguidcategory.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(pptransform)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSinkWriterEx, ::windows::core::IUnknown, IMFSinkWriter);
impl ::core::cmp::PartialEq for IMFSinkWriterEx {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSinkWriterEx {}
impl ::core::fmt::Debug for IMFSinkWriterEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSinkWriterEx").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSinkWriterEx {
    type Vtable = IMFSinkWriterEx_Vtbl;
}
impl ::core::clone::Clone for IMFSinkWriterEx {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSinkWriterEx {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x588d72ab_5bc1_496a_8714_b70617141b25);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSinkWriterEx_Vtbl {
    pub base__: IMFSinkWriter_Vtbl,
    pub GetTransformForStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, dwtransformindex: u32, pguidcategory: *mut ::windows::core::GUID, pptransform: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSourceBuffer(::windows::core::IUnknown);
impl IMFSourceBuffer {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetUpdating(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).GetUpdating)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetBuffered(&self) -> ::windows::core::Result<IMFMediaTimeRange> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaTimeRange>();
        (::windows::core::Interface::vtable(self).GetBuffered)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetTimeStampOffset(&self) -> f64 {
        (::windows::core::Interface::vtable(self).GetTimeStampOffset)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetTimeStampOffset(&self, offset: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetTimeStampOffset)(::windows::core::Interface::as_raw(self), offset).ok()
    }
    pub unsafe fn GetAppendWindowStart(&self) -> f64 {
        (::windows::core::Interface::vtable(self).GetAppendWindowStart)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetAppendWindowStart(&self, time: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetAppendWindowStart)(::windows::core::Interface::as_raw(self), time).ok()
    }
    pub unsafe fn GetAppendWindowEnd(&self) -> f64 {
        (::windows::core::Interface::vtable(self).GetAppendWindowEnd)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetAppendWindowEnd(&self, time: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetAppendWindowEnd)(::windows::core::Interface::as_raw(self), time).ok()
    }
    pub unsafe fn Append(&self, pdata: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Append)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pdata.as_ptr()), pdata.len() as _).ok()
    }
    pub unsafe fn AppendByteStream<P0>(&self, pstream: P0, pmaxlen: ::core::option::Option<*const u64>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFByteStream>,
    {
        (::windows::core::Interface::vtable(self).AppendByteStream)(::windows::core::Interface::as_raw(self), pstream.into_param().abi(), ::core::mem::transmute(pmaxlen.unwrap_or(::std::ptr::null()))).ok()
    }
    pub unsafe fn Abort(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Abort)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Remove(&self, start: f64, end: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Remove)(::windows::core::Interface::as_raw(self), start, end).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSourceBuffer, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSourceBuffer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSourceBuffer {}
impl ::core::fmt::Debug for IMFSourceBuffer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSourceBuffer").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSourceBuffer {
    type Vtable = IMFSourceBuffer_Vtbl;
}
impl ::core::clone::Clone for IMFSourceBuffer {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSourceBuffer {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe2cd3a4b_af25_4d3d_9110_da0e6f8ee877);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSourceBuffer_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub GetUpdating: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetUpdating: usize,
    pub GetBuffered: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppbuffered: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetTimeStampOffset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> f64,
    pub SetTimeStampOffset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, offset: f64) -> ::windows::core::HRESULT,
    pub GetAppendWindowStart: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> f64,
    pub SetAppendWindowStart: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, time: f64) -> ::windows::core::HRESULT,
    pub GetAppendWindowEnd: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> f64,
    pub SetAppendWindowEnd: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, time: f64) -> ::windows::core::HRESULT,
    pub Append: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdata: *const u8, len: u32) -> ::windows::core::HRESULT,
    pub AppendByteStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pstream: *mut ::core::ffi::c_void, pmaxlen: *const u64) -> ::windows::core::HRESULT,
    pub Abort: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Remove: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, start: f64, end: f64) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSourceBufferAppendMode(::windows::core::IUnknown);
impl IMFSourceBufferAppendMode {
    pub unsafe fn GetAppendMode(&self) -> MF_MSE_APPEND_MODE {
        (::windows::core::Interface::vtable(self).GetAppendMode)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetAppendMode(&self, mode: MF_MSE_APPEND_MODE) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetAppendMode)(::windows::core::Interface::as_raw(self), mode).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSourceBufferAppendMode, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSourceBufferAppendMode {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSourceBufferAppendMode {}
impl ::core::fmt::Debug for IMFSourceBufferAppendMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSourceBufferAppendMode").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSourceBufferAppendMode {
    type Vtable = IMFSourceBufferAppendMode_Vtbl;
}
impl ::core::clone::Clone for IMFSourceBufferAppendMode {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSourceBufferAppendMode {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x19666fb4_babe_4c55_bc03_0a074da37e2a);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSourceBufferAppendMode_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetAppendMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> MF_MSE_APPEND_MODE,
    pub SetAppendMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, mode: MF_MSE_APPEND_MODE) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSourceBufferList(::windows::core::IUnknown);
impl IMFSourceBufferList {
    pub unsafe fn GetLength(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetLength)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetSourceBuffer(&self, index: u32) -> ::core::option::Option<IMFSourceBuffer> {
        (::windows::core::Interface::vtable(self).GetSourceBuffer)(::windows::core::Interface::as_raw(self), index)
    }
}
::windows::imp::interface_hierarchy!(IMFSourceBufferList, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSourceBufferList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSourceBufferList {}
impl ::core::fmt::Debug for IMFSourceBufferList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSourceBufferList").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSourceBufferList {
    type Vtable = IMFSourceBufferList_Vtbl;
}
impl ::core::clone::Clone for IMFSourceBufferList {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSourceBufferList {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x249981f8_8325_41f3_b80c_3b9e3aad0cbe);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSourceBufferList_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetLength: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetSourceBuffer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32) -> ::core::option::Option<IMFSourceBuffer>,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSourceBufferNotify(::windows::core::IUnknown);
impl IMFSourceBufferNotify {
    pub unsafe fn OnUpdateStart(&self) {
        (::windows::core::Interface::vtable(self).OnUpdateStart)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn OnAbort(&self) {
        (::windows::core::Interface::vtable(self).OnAbort)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn OnError(&self, hr: ::windows::core::HRESULT) {
        (::windows::core::Interface::vtable(self).OnError)(::windows::core::Interface::as_raw(self), hr)
    }
    pub unsafe fn OnUpdate(&self) {
        (::windows::core::Interface::vtable(self).OnUpdate)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn OnUpdateEnd(&self) {
        (::windows::core::Interface::vtable(self).OnUpdateEnd)(::windows::core::Interface::as_raw(self))
    }
}
::windows::imp::interface_hierarchy!(IMFSourceBufferNotify, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSourceBufferNotify {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSourceBufferNotify {}
impl ::core::fmt::Debug for IMFSourceBufferNotify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSourceBufferNotify").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSourceBufferNotify {
    type Vtable = IMFSourceBufferNotify_Vtbl;
}
impl ::core::clone::Clone for IMFSourceBufferNotify {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSourceBufferNotify {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x87e47623_2ceb_45d6_9b88_d8520c4dcbbc);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSourceBufferNotify_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub OnUpdateStart: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub OnAbort: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub OnError: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hr: ::windows::core::HRESULT),
    pub OnUpdate: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub OnUpdateEnd: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSourceOpenMonitor(::windows::core::IUnknown);
impl IMFSourceOpenMonitor {
    pub unsafe fn OnSourceEvent<P0>(&self, pevent: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaEvent>,
    {
        (::windows::core::Interface::vtable(self).OnSourceEvent)(::windows::core::Interface::as_raw(self), pevent.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSourceOpenMonitor, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSourceOpenMonitor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSourceOpenMonitor {}
impl ::core::fmt::Debug for IMFSourceOpenMonitor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSourceOpenMonitor").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSourceOpenMonitor {
    type Vtable = IMFSourceOpenMonitor_Vtbl;
}
impl ::core::clone::Clone for IMFSourceOpenMonitor {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSourceOpenMonitor {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x059054b3_027c_494c_a27d_9113291cf87f);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSourceOpenMonitor_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub OnSourceEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pevent: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSourceReader(::windows::core::IUnknown);
impl IMFSourceReader {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetStreamSelection(&self, dwstreamindex: u32) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).GetStreamSelection)(::windows::core::Interface::as_raw(self), dwstreamindex, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetStreamSelection<P0>(&self, dwstreamindex: u32, fselected: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetStreamSelection)(::windows::core::Interface::as_raw(self), dwstreamindex, fselected.into_param().abi()).ok()
    }
    pub unsafe fn GetNativeMediaType(&self, dwstreamindex: u32, dwmediatypeindex: u32) -> ::windows::core::Result<IMFMediaType> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
        (::windows::core::Interface::vtable(self).GetNativeMediaType)(::windows::core::Interface::as_raw(self), dwstreamindex, dwmediatypeindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetCurrentMediaType(&self, dwstreamindex: u32) -> ::windows::core::Result<IMFMediaType> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
        (::windows::core::Interface::vtable(self).GetCurrentMediaType)(::windows::core::Interface::as_raw(self), dwstreamindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetCurrentMediaType<P0>(&self, dwstreamindex: u32, pdwreserved: ::core::option::Option<*const u32>, pmediatype: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        (::windows::core::Interface::vtable(self).SetCurrentMediaType)(::windows::core::Interface::as_raw(self), dwstreamindex, ::core::mem::transmute(pdwreserved.unwrap_or(::std::ptr::null())), pmediatype.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetCurrentPosition(&self, guidtimeformat: *const ::windows::core::GUID, varposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetCurrentPosition)(::windows::core::Interface::as_raw(self), guidtimeformat, varposition).ok()
    }
    pub unsafe fn ReadSample(&self, dwstreamindex: u32, dwcontrolflags: u32, pdwactualstreamindex: ::core::option::Option<*mut u32>, pdwstreamflags: ::core::option::Option<*mut u32>, plltimestamp: ::core::option::Option<*mut i64>, ppsample: ::core::option::Option<*mut ::core::option::Option<IMFSample>>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ReadSample)(::windows::core::Interface::as_raw(self), dwstreamindex, dwcontrolflags, ::core::mem::transmute(pdwactualstreamindex.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(pdwstreamflags.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(plltimestamp.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(ppsample.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn Flush(&self, dwstreamindex: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Flush)(::windows::core::Interface::as_raw(self), dwstreamindex).ok()
    }
    pub unsafe fn GetServiceForStream(&self, dwstreamindex: u32, guidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetServiceForStream)(::windows::core::Interface::as_raw(self), dwstreamindex, guidservice, riid, ppvobject).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetPresentationAttribute(&self, dwstreamindex: u32, guidattribute: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT> {
        let mut result__ = ::windows::core::zeroed::<super::super::System::Com::StructuredStorage::PROPVARIANT>();
        (::windows::core::Interface::vtable(self).GetPresentationAttribute)(::windows::core::Interface::as_raw(self), dwstreamindex, guidattribute, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFSourceReader, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSourceReader {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSourceReader {}
impl ::core::fmt::Debug for IMFSourceReader {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSourceReader").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSourceReader {
    type Vtable = IMFSourceReader_Vtbl;
}
impl ::core::clone::Clone for IMFSourceReader {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSourceReader {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x70ae66f2_c809_4e4f_8915_bdcb406b7993);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSourceReader_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub GetStreamSelection: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pfselected: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetStreamSelection: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub SetStreamSelection: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, fselected: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetStreamSelection: usize,
    pub GetNativeMediaType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, dwmediatypeindex: u32, ppmediatype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetCurrentMediaType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, ppmediatype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetCurrentMediaType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pdwreserved: *const u32, pmediatype: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub SetCurrentPosition: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidtimeformat: *const ::windows::core::GUID, varposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    SetCurrentPosition: usize,
    pub ReadSample: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, dwcontrolflags: u32, pdwactualstreamindex: *mut u32, pdwstreamflags: *mut u32, plltimestamp: *mut i64, ppsample: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Flush: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32) -> ::windows::core::HRESULT,
    pub GetServiceForStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, guidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub GetPresentationAttribute: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, guidattribute: *const ::windows::core::GUID, pvarattribute: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    GetPresentationAttribute: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSourceReaderCallback(::windows::core::IUnknown);
impl IMFSourceReaderCallback {
    pub unsafe fn OnReadSample<P0>(&self, hrstatus: ::windows::core::HRESULT, dwstreamindex: u32, dwstreamflags: u32, lltimestamp: i64, psample: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFSample>,
    {
        (::windows::core::Interface::vtable(self).OnReadSample)(::windows::core::Interface::as_raw(self), hrstatus, dwstreamindex, dwstreamflags, lltimestamp, psample.into_param().abi()).ok()
    }
    pub unsafe fn OnFlush(&self, dwstreamindex: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).OnFlush)(::windows::core::Interface::as_raw(self), dwstreamindex).ok()
    }
    pub unsafe fn OnEvent<P0>(&self, dwstreamindex: u32, pevent: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaEvent>,
    {
        (::windows::core::Interface::vtable(self).OnEvent)(::windows::core::Interface::as_raw(self), dwstreamindex, pevent.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSourceReaderCallback, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSourceReaderCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSourceReaderCallback {}
impl ::core::fmt::Debug for IMFSourceReaderCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSourceReaderCallback").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSourceReaderCallback {
    type Vtable = IMFSourceReaderCallback_Vtbl;
}
impl ::core::clone::Clone for IMFSourceReaderCallback {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSourceReaderCallback {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdeec8d99_fa1d_4d82_84c2_2c8969944867);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSourceReaderCallback_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub OnReadSample: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hrstatus: ::windows::core::HRESULT, dwstreamindex: u32, dwstreamflags: u32, lltimestamp: i64, psample: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub OnFlush: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32) -> ::windows::core::HRESULT,
    pub OnEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pevent: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSourceReaderCallback2(::windows::core::IUnknown);
impl IMFSourceReaderCallback2 {
    pub unsafe fn OnReadSample<P0>(&self, hrstatus: ::windows::core::HRESULT, dwstreamindex: u32, dwstreamflags: u32, lltimestamp: i64, psample: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFSample>,
    {
        (::windows::core::Interface::vtable(self).base__.OnReadSample)(::windows::core::Interface::as_raw(self), hrstatus, dwstreamindex, dwstreamflags, lltimestamp, psample.into_param().abi()).ok()
    }
    pub unsafe fn OnFlush(&self, dwstreamindex: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.OnFlush)(::windows::core::Interface::as_raw(self), dwstreamindex).ok()
    }
    pub unsafe fn OnEvent<P0>(&self, dwstreamindex: u32, pevent: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaEvent>,
    {
        (::windows::core::Interface::vtable(self).base__.OnEvent)(::windows::core::Interface::as_raw(self), dwstreamindex, pevent.into_param().abi()).ok()
    }
    pub unsafe fn OnTransformChange(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).OnTransformChange)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn OnStreamError(&self, dwstreamindex: u32, hrstatus: ::windows::core::HRESULT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).OnStreamError)(::windows::core::Interface::as_raw(self), dwstreamindex, hrstatus).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSourceReaderCallback2, ::windows::core::IUnknown, IMFSourceReaderCallback);
impl ::core::cmp::PartialEq for IMFSourceReaderCallback2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSourceReaderCallback2 {}
impl ::core::fmt::Debug for IMFSourceReaderCallback2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSourceReaderCallback2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSourceReaderCallback2 {
    type Vtable = IMFSourceReaderCallback2_Vtbl;
}
impl ::core::clone::Clone for IMFSourceReaderCallback2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSourceReaderCallback2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xcf839fe6_8c2a_4dd2_b6ea_c22d6961af05);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSourceReaderCallback2_Vtbl {
    pub base__: IMFSourceReaderCallback_Vtbl,
    pub OnTransformChange: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub OnStreamError: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, hrstatus: ::windows::core::HRESULT) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSourceReaderEx(::windows::core::IUnknown);
impl IMFSourceReaderEx {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetStreamSelection(&self, dwstreamindex: u32) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.GetStreamSelection)(::windows::core::Interface::as_raw(self), dwstreamindex, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetStreamSelection<P0>(&self, dwstreamindex: u32, fselected: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).base__.SetStreamSelection)(::windows::core::Interface::as_raw(self), dwstreamindex, fselected.into_param().abi()).ok()
    }
    pub unsafe fn GetNativeMediaType(&self, dwstreamindex: u32, dwmediatypeindex: u32) -> ::windows::core::Result<IMFMediaType> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
        (::windows::core::Interface::vtable(self).base__.GetNativeMediaType)(::windows::core::Interface::as_raw(self), dwstreamindex, dwmediatypeindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetCurrentMediaType(&self, dwstreamindex: u32) -> ::windows::core::Result<IMFMediaType> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
        (::windows::core::Interface::vtable(self).base__.GetCurrentMediaType)(::windows::core::Interface::as_raw(self), dwstreamindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetCurrentMediaType<P0>(&self, dwstreamindex: u32, pdwreserved: ::core::option::Option<*const u32>, pmediatype: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        (::windows::core::Interface::vtable(self).base__.SetCurrentMediaType)(::windows::core::Interface::as_raw(self), dwstreamindex, ::core::mem::transmute(pdwreserved.unwrap_or(::std::ptr::null())), pmediatype.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetCurrentPosition(&self, guidtimeformat: *const ::windows::core::GUID, varposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetCurrentPosition)(::windows::core::Interface::as_raw(self), guidtimeformat, varposition).ok()
    }
    pub unsafe fn ReadSample(&self, dwstreamindex: u32, dwcontrolflags: u32, pdwactualstreamindex: ::core::option::Option<*mut u32>, pdwstreamflags: ::core::option::Option<*mut u32>, plltimestamp: ::core::option::Option<*mut i64>, ppsample: ::core::option::Option<*mut ::core::option::Option<IMFSample>>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.ReadSample)(::windows::core::Interface::as_raw(self), dwstreamindex, dwcontrolflags, ::core::mem::transmute(pdwactualstreamindex.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(pdwstreamflags.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(plltimestamp.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(ppsample.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn Flush(&self, dwstreamindex: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Flush)(::windows::core::Interface::as_raw(self), dwstreamindex).ok()
    }
    pub unsafe fn GetServiceForStream(&self, dwstreamindex: u32, guidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetServiceForStream)(::windows::core::Interface::as_raw(self), dwstreamindex, guidservice, riid, ppvobject).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetPresentationAttribute(&self, dwstreamindex: u32, guidattribute: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT> {
        let mut result__ = ::windows::core::zeroed::<super::super::System::Com::StructuredStorage::PROPVARIANT>();
        (::windows::core::Interface::vtable(self).base__.GetPresentationAttribute)(::windows::core::Interface::as_raw(self), dwstreamindex, guidattribute, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetNativeMediaType<P0>(&self, dwstreamindex: u32, pmediatype: P0) -> ::windows::core::Result<u32>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).SetNativeMediaType)(::windows::core::Interface::as_raw(self), dwstreamindex, pmediatype.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn AddTransformForStream<P0>(&self, dwstreamindex: u32, ptransformoractivate: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).AddTransformForStream)(::windows::core::Interface::as_raw(self), dwstreamindex, ptransformoractivate.into_param().abi()).ok()
    }
    pub unsafe fn RemoveAllTransformsForStream(&self, dwstreamindex: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveAllTransformsForStream)(::windows::core::Interface::as_raw(self), dwstreamindex).ok()
    }
    pub unsafe fn GetTransformForStream(&self, dwstreamindex: u32, dwtransformindex: u32, pguidcategory: ::core::option::Option<*mut ::windows::core::GUID>, pptransform: *mut ::core::option::Option<IMFTransform>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetTransformForStream)(::windows::core::Interface::as_raw(self), dwstreamindex, dwtransformindex, ::core::mem::transmute(pguidcategory.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(pptransform)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSourceReaderEx, ::windows::core::IUnknown, IMFSourceReader);
impl ::core::cmp::PartialEq for IMFSourceReaderEx {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSourceReaderEx {}
impl ::core::fmt::Debug for IMFSourceReaderEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSourceReaderEx").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSourceReaderEx {
    type Vtable = IMFSourceReaderEx_Vtbl;
}
impl ::core::clone::Clone for IMFSourceReaderEx {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSourceReaderEx {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7b981cf0_560e_4116_9875_b099895f23d7);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSourceReaderEx_Vtbl {
    pub base__: IMFSourceReader_Vtbl,
    pub SetNativeMediaType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pmediatype: *mut ::core::ffi::c_void, pdwstreamflags: *mut u32) -> ::windows::core::HRESULT,
    pub AddTransformForStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, ptransformoractivate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RemoveAllTransformsForStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32) -> ::windows::core::HRESULT,
    pub GetTransformForStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamindex: u32, dwtransformindex: u32, pguidcategory: *mut ::windows::core::GUID, pptransform: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSourceResolver(::windows::core::IUnknown);
impl IMFSourceResolver {
    #[doc = "*Required features: `\"Win32_UI_Shell_PropertiesSystem\"`*"]
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub unsafe fn CreateObjectFromURL<P0, P1>(&self, pwszurl: P0, dwflags: u32, pprops: P1, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P1: ::windows::core::IntoParam<super::super::UI::Shell::PropertiesSystem::IPropertyStore>,
    {
        (::windows::core::Interface::vtable(self).CreateObjectFromURL)(::windows::core::Interface::as_raw(self), pwszurl.into_param().abi(), dwflags, pprops.into_param().abi(), pobjecttype, ::core::mem::transmute(ppobject)).ok()
    }
    #[doc = "*Required features: `\"Win32_UI_Shell_PropertiesSystem\"`*"]
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub unsafe fn CreateObjectFromByteStream<P0, P1, P2>(&self, pbytestream: P0, pwszurl: P1, dwflags: u32, pprops: P2, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFByteStream>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P2: ::windows::core::IntoParam<super::super::UI::Shell::PropertiesSystem::IPropertyStore>,
    {
        (::windows::core::Interface::vtable(self).CreateObjectFromByteStream)(::windows::core::Interface::as_raw(self), pbytestream.into_param().abi(), pwszurl.into_param().abi(), dwflags, pprops.into_param().abi(), pobjecttype, ::core::mem::transmute(ppobject)).ok()
    }
    #[doc = "*Required features: `\"Win32_UI_Shell_PropertiesSystem\"`*"]
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub unsafe fn BeginCreateObjectFromURL<P0, P1, P2, P3>(&self, pwszurl: P0, dwflags: u32, pprops: P1, ppiunknowncancelcookie: ::core::option::Option<*mut ::core::option::Option<::windows::core::IUnknown>>, pcallback: P2, punkstate: P3) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P1: ::windows::core::IntoParam<super::super::UI::Shell::PropertiesSystem::IPropertyStore>,
        P2: ::windows::core::IntoParam<IMFAsyncCallback>,
        P3: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginCreateObjectFromURL)(::windows::core::Interface::as_raw(self), pwszurl.into_param().abi(), dwflags, pprops.into_param().abi(), ::core::mem::transmute(ppiunknowncancelcookie.unwrap_or(::std::ptr::null_mut())), pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    pub unsafe fn EndCreateObjectFromURL<P0>(&self, presult: P0, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        (::windows::core::Interface::vtable(self).EndCreateObjectFromURL)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), pobjecttype, ::core::mem::transmute(ppobject)).ok()
    }
    #[doc = "*Required features: `\"Win32_UI_Shell_PropertiesSystem\"`*"]
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub unsafe fn BeginCreateObjectFromByteStream<P0, P1, P2, P3, P4>(&self, pbytestream: P0, pwszurl: P1, dwflags: u32, pprops: P2, ppiunknowncancelcookie: ::core::option::Option<*mut ::core::option::Option<::windows::core::IUnknown>>, pcallback: P3, punkstate: P4) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFByteStream>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P2: ::windows::core::IntoParam<super::super::UI::Shell::PropertiesSystem::IPropertyStore>,
        P3: ::windows::core::IntoParam<IMFAsyncCallback>,
        P4: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginCreateObjectFromByteStream)(::windows::core::Interface::as_raw(self), pbytestream.into_param().abi(), pwszurl.into_param().abi(), dwflags, pprops.into_param().abi(), ::core::mem::transmute(ppiunknowncancelcookie.unwrap_or(::std::ptr::null_mut())), pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    pub unsafe fn EndCreateObjectFromByteStream<P0>(&self, presult: P0, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        (::windows::core::Interface::vtable(self).EndCreateObjectFromByteStream)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), pobjecttype, ::core::mem::transmute(ppobject)).ok()
    }
    pub unsafe fn CancelObjectCreation<P0>(&self, piunknowncancelcookie: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).CancelObjectCreation)(::windows::core::Interface::as_raw(self), piunknowncancelcookie.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSourceResolver, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSourceResolver {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSourceResolver {}
impl ::core::fmt::Debug for IMFSourceResolver {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSourceResolver").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSourceResolver {
    type Vtable = IMFSourceResolver_Vtbl;
}
impl ::core::clone::Clone for IMFSourceResolver {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSourceResolver {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfbe5a32d_a497_4b61_bb85_97b1a848a6e3);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSourceResolver_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub CreateObjectFromURL: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pwszurl: ::windows::core::PCWSTR, dwflags: u32, pprops: *mut ::core::ffi::c_void, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_UI_Shell_PropertiesSystem"))]
    CreateObjectFromURL: usize,
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub CreateObjectFromByteStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbytestream: *mut ::core::ffi::c_void, pwszurl: ::windows::core::PCWSTR, dwflags: u32, pprops: *mut ::core::ffi::c_void, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_UI_Shell_PropertiesSystem"))]
    CreateObjectFromByteStream: usize,
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub BeginCreateObjectFromURL: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pwszurl: ::windows::core::PCWSTR, dwflags: u32, pprops: *mut ::core::ffi::c_void, ppiunknowncancelcookie: *mut *mut ::core::ffi::c_void, pcallback: *mut ::core::ffi::c_void, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_UI_Shell_PropertiesSystem"))]
    BeginCreateObjectFromURL: usize,
    pub EndCreateObjectFromURL: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
    pub BeginCreateObjectFromByteStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbytestream: *mut ::core::ffi::c_void, pwszurl: ::windows::core::PCWSTR, dwflags: u32, pprops: *mut ::core::ffi::c_void, ppiunknowncancelcookie: *mut *mut ::core::ffi::c_void, pcallback: *mut ::core::ffi::c_void, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_UI_Shell_PropertiesSystem"))]
    BeginCreateObjectFromByteStream: usize,
    pub EndCreateObjectFromByteStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub CancelObjectCreation: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, piunknowncancelcookie: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSpatialAudioObjectBuffer(::windows::core::IUnknown);
impl IMFSpatialAudioObjectBuffer {
    pub unsafe fn Lock(&self, ppbbuffer: *mut *mut u8, pcbmaxlength: ::core::option::Option<*mut u32>, pcbcurrentlength: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Lock)(::windows::core::Interface::as_raw(self), ppbbuffer, ::core::mem::transmute(pcbmaxlength.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(pcbcurrentlength.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn Unlock(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Unlock)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetCurrentLength(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetCurrentLength)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetCurrentLength(&self, cbcurrentlength: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetCurrentLength)(::windows::core::Interface::as_raw(self), cbcurrentlength).ok()
    }
    pub unsafe fn GetMaxLength(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetMaxLength)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetID(&self, u32id: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetID)(::windows::core::Interface::as_raw(self), u32id).ok()
    }
    pub unsafe fn GetID(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetID)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Media_Audio\"`*"]
    #[cfg(feature = "Win32_Media_Audio")]
    pub unsafe fn SetType(&self, r#type: super::Audio::AudioObjectType) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetType)(::windows::core::Interface::as_raw(self), r#type).ok()
    }
    #[doc = "*Required features: `\"Win32_Media_Audio\"`*"]
    #[cfg(feature = "Win32_Media_Audio")]
    pub unsafe fn GetType(&self) -> ::windows::core::Result<super::Audio::AudioObjectType> {
        let mut result__ = ::windows::core::zeroed::<super::Audio::AudioObjectType>();
        (::windows::core::Interface::vtable(self).GetType)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Media_Audio\"`*"]
    #[cfg(feature = "Win32_Media_Audio")]
    pub unsafe fn GetMetadataItems(&self) -> ::windows::core::Result<super::Audio::ISpatialAudioMetadataItems> {
        let mut result__ = ::windows::core::zeroed::<super::Audio::ISpatialAudioMetadataItems>();
        (::windows::core::Interface::vtable(self).GetMetadataItems)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFSpatialAudioObjectBuffer, ::windows::core::IUnknown, IMFMediaBuffer);
impl ::core::cmp::PartialEq for IMFSpatialAudioObjectBuffer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSpatialAudioObjectBuffer {}
impl ::core::fmt::Debug for IMFSpatialAudioObjectBuffer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSpatialAudioObjectBuffer").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSpatialAudioObjectBuffer {
    type Vtable = IMFSpatialAudioObjectBuffer_Vtbl;
}
impl ::core::clone::Clone for IMFSpatialAudioObjectBuffer {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSpatialAudioObjectBuffer {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd396ec8c_605e_4249_978d_72ad1c312872);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSpatialAudioObjectBuffer_Vtbl {
    pub base__: IMFMediaBuffer_Vtbl,
    pub SetID: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, u32id: u32) -> ::windows::core::HRESULT,
    pub GetID: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pu32id: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Media_Audio")]
    pub SetType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, r#type: super::Audio::AudioObjectType) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Media_Audio"))]
    SetType: usize,
    #[cfg(feature = "Win32_Media_Audio")]
    pub GetType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ptype: *mut super::Audio::AudioObjectType) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Media_Audio"))]
    GetType: usize,
    #[cfg(feature = "Win32_Media_Audio")]
    pub GetMetadataItems: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppmetadataitems: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Media_Audio"))]
    GetMetadataItems: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSpatialAudioSample(::windows::core::IUnknown);
impl IMFSpatialAudioSample {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItem(&self, guidkey: *const ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.GetItem)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetItemType(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<MF_ATTRIBUTE_TYPE> {
        let mut result__ = ::windows::core::zeroed::<MF_ATTRIBUTE_TYPE>();
        (::windows::core::Interface::vtable(self).base__.base__.GetItemType)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn CompareItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.base__.CompareItem)(::windows::core::Interface::as_raw(self), guidkey, value, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Compare<P0>(&self, ptheirs: P0, matchtype: MF_ATTRIBUTES_MATCH_TYPE) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.base__.Compare)(::windows::core::Interface::as_raw(self), ptheirs.into_param().abi(), matchtype, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT32(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.base__.GetUINT32)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT64(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).base__.base__.GetUINT64)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDouble(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).base__.base__.GetDouble)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetGUID(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).base__.base__.GetGUID)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStringLength(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.base__.GetStringLength)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetString(&self, guidkey: *const ::windows::core::GUID, pwszvalue: &mut [u16], pcchlength: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.GetString)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pwszvalue.as_ptr()), pwszvalue.len() as _, ::core::mem::transmute(pcchlength.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedString(&self, guidkey: *const ::windows::core::GUID, ppwszvalue: *mut ::windows::core::PWSTR, pcchlength: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.GetAllocatedString)(::windows::core::Interface::as_raw(self), guidkey, ppwszvalue, pcchlength).ok()
    }
    pub unsafe fn GetBlobSize(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.base__.GetBlobSize)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &mut [u8], pcbblobsize: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.GetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _, ::core::mem::transmute(pcbblobsize.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedBlob(&self, guidkey: *const ::windows::core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.GetAllocatedBlob)(::windows::core::Interface::as_raw(self), guidkey, ppbuf, pcbsize).ok()
    }
    pub unsafe fn GetUnknown<T>(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.base__.GetUnknown)(::windows::core::Interface::as_raw(self), guidkey, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetItem)(::windows::core::Interface::as_raw(self), guidkey, value).ok()
    }
    pub unsafe fn DeleteItem(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.DeleteItem)(::windows::core::Interface::as_raw(self), guidkey).ok()
    }
    pub unsafe fn DeleteAllItems(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.DeleteAllItems)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetUINT32(&self, guidkey: *const ::windows::core::GUID, unvalue: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetUINT32)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetUINT64(&self, guidkey: *const ::windows::core::GUID, unvalue: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetUINT64)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetDouble(&self, guidkey: *const ::windows::core::GUID, fvalue: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetDouble)(::windows::core::Interface::as_raw(self), guidkey, fvalue).ok()
    }
    pub unsafe fn SetGUID(&self, guidkey: *const ::windows::core::GUID, guidvalue: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetGUID)(::windows::core::Interface::as_raw(self), guidkey, guidvalue).ok()
    }
    pub unsafe fn SetString<P0>(&self, guidkey: *const ::windows::core::GUID, wszvalue: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.SetString)(::windows::core::Interface::as_raw(self), guidkey, wszvalue.into_param().abi()).ok()
    }
    pub unsafe fn SetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _).ok()
    }
    pub unsafe fn SetUnknown<P0>(&self, guidkey: *const ::windows::core::GUID, punknown: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.SetUnknown)(::windows::core::Interface::as_raw(self), guidkey, punknown.into_param().abi()).ok()
    }
    pub unsafe fn LockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.LockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn UnlockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.UnlockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.base__.GetCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItemByIndex(&self, unindex: u32, pguidkey: *mut ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.GetItemByIndex)(::windows::core::Interface::as_raw(self), unindex, pguidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn CopyAllItems<P0>(&self, pdest: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.CopyAllItems)(::windows::core::Interface::as_raw(self), pdest.into_param().abi()).ok()
    }
    pub unsafe fn GetSampleFlags(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetSampleFlags)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetSampleFlags(&self, dwsampleflags: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetSampleFlags)(::windows::core::Interface::as_raw(self), dwsampleflags).ok()
    }
    pub unsafe fn GetSampleTime(&self) -> ::windows::core::Result<i64> {
        let mut result__ = ::windows::core::zeroed::<i64>();
        (::windows::core::Interface::vtable(self).base__.GetSampleTime)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetSampleTime(&self, hnssampletime: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetSampleTime)(::windows::core::Interface::as_raw(self), hnssampletime).ok()
    }
    pub unsafe fn GetSampleDuration(&self) -> ::windows::core::Result<i64> {
        let mut result__ = ::windows::core::zeroed::<i64>();
        (::windows::core::Interface::vtable(self).base__.GetSampleDuration)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetSampleDuration(&self, hnssampleduration: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetSampleDuration)(::windows::core::Interface::as_raw(self), hnssampleduration).ok()
    }
    pub unsafe fn GetBufferCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetBufferCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBufferByIndex(&self, dwindex: u32) -> ::windows::core::Result<IMFMediaBuffer> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaBuffer>();
        (::windows::core::Interface::vtable(self).base__.GetBufferByIndex)(::windows::core::Interface::as_raw(self), dwindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn ConvertToContiguousBuffer(&self) -> ::windows::core::Result<IMFMediaBuffer> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaBuffer>();
        (::windows::core::Interface::vtable(self).base__.ConvertToContiguousBuffer)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn AddBuffer<P0>(&self, pbuffer: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaBuffer>,
    {
        (::windows::core::Interface::vtable(self).base__.AddBuffer)(::windows::core::Interface::as_raw(self), pbuffer.into_param().abi()).ok()
    }
    pub unsafe fn RemoveBufferByIndex(&self, dwindex: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.RemoveBufferByIndex)(::windows::core::Interface::as_raw(self), dwindex).ok()
    }
    pub unsafe fn RemoveAllBuffers(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.RemoveAllBuffers)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetTotalLength(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetTotalLength)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn CopyToBuffer<P0>(&self, pbuffer: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaBuffer>,
    {
        (::windows::core::Interface::vtable(self).base__.CopyToBuffer)(::windows::core::Interface::as_raw(self), pbuffer.into_param().abi()).ok()
    }
    pub unsafe fn GetObjectCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetObjectCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn AddSpatialAudioObject<P0>(&self, paudioobjbuffer: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFSpatialAudioObjectBuffer>,
    {
        (::windows::core::Interface::vtable(self).AddSpatialAudioObject)(::windows::core::Interface::as_raw(self), paudioobjbuffer.into_param().abi()).ok()
    }
    pub unsafe fn GetSpatialAudioObjectByIndex(&self, dwindex: u32) -> ::windows::core::Result<IMFSpatialAudioObjectBuffer> {
        let mut result__ = ::windows::core::zeroed::<IMFSpatialAudioObjectBuffer>();
        (::windows::core::Interface::vtable(self).GetSpatialAudioObjectByIndex)(::windows::core::Interface::as_raw(self), dwindex, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFSpatialAudioSample, ::windows::core::IUnknown, IMFAttributes, IMFSample);
impl ::core::cmp::PartialEq for IMFSpatialAudioSample {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSpatialAudioSample {}
impl ::core::fmt::Debug for IMFSpatialAudioSample {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSpatialAudioSample").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSpatialAudioSample {
    type Vtable = IMFSpatialAudioSample_Vtbl;
}
impl ::core::clone::Clone for IMFSpatialAudioSample {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSpatialAudioSample {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xabf28a9b_3393_4290_ba79_5ffc46d986b2);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSpatialAudioSample_Vtbl {
    pub base__: IMFSample_Vtbl,
    pub GetObjectCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwobjectcount: *mut u32) -> ::windows::core::HRESULT,
    pub AddSpatialAudioObject: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, paudioobjbuffer: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetSpatialAudioObjectByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwindex: u32, ppaudioobjbuffer: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFStreamDescriptor(::windows::core::IUnknown);
impl IMFStreamDescriptor {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItem(&self, guidkey: *const ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItem)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetItemType(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<MF_ATTRIBUTE_TYPE> {
        let mut result__ = ::windows::core::zeroed::<MF_ATTRIBUTE_TYPE>();
        (::windows::core::Interface::vtable(self).base__.GetItemType)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn CompareItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.CompareItem)(::windows::core::Interface::as_raw(self), guidkey, value, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Compare<P0>(&self, ptheirs: P0, matchtype: MF_ATTRIBUTES_MATCH_TYPE) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.Compare)(::windows::core::Interface::as_raw(self), ptheirs.into_param().abi(), matchtype, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT32(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetUINT32)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT64(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).base__.GetUINT64)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDouble(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).base__.GetDouble)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetGUID(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).base__.GetGUID)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStringLength(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetStringLength)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetString(&self, guidkey: *const ::windows::core::GUID, pwszvalue: &mut [u16], pcchlength: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetString)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pwszvalue.as_ptr()), pwszvalue.len() as _, ::core::mem::transmute(pcchlength.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedString(&self, guidkey: *const ::windows::core::GUID, ppwszvalue: *mut ::windows::core::PWSTR, pcchlength: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedString)(::windows::core::Interface::as_raw(self), guidkey, ppwszvalue, pcchlength).ok()
    }
    pub unsafe fn GetBlobSize(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetBlobSize)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &mut [u8], pcbblobsize: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _, ::core::mem::transmute(pcbblobsize.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedBlob(&self, guidkey: *const ::windows::core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedBlob)(::windows::core::Interface::as_raw(self), guidkey, ppbuf, pcbsize).ok()
    }
    pub unsafe fn GetUnknown<T>(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.GetUnknown)(::windows::core::Interface::as_raw(self), guidkey, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetItem)(::windows::core::Interface::as_raw(self), guidkey, value).ok()
    }
    pub unsafe fn DeleteItem(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteItem)(::windows::core::Interface::as_raw(self), guidkey).ok()
    }
    pub unsafe fn DeleteAllItems(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteAllItems)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetUINT32(&self, guidkey: *const ::windows::core::GUID, unvalue: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT32)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetUINT64(&self, guidkey: *const ::windows::core::GUID, unvalue: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT64)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetDouble(&self, guidkey: *const ::windows::core::GUID, fvalue: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetDouble)(::windows::core::Interface::as_raw(self), guidkey, fvalue).ok()
    }
    pub unsafe fn SetGUID(&self, guidkey: *const ::windows::core::GUID, guidvalue: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetGUID)(::windows::core::Interface::as_raw(self), guidkey, guidvalue).ok()
    }
    pub unsafe fn SetString<P0>(&self, guidkey: *const ::windows::core::GUID, wszvalue: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.SetString)(::windows::core::Interface::as_raw(self), guidkey, wszvalue.into_param().abi()).ok()
    }
    pub unsafe fn SetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _).ok()
    }
    pub unsafe fn SetUnknown<P0>(&self, guidkey: *const ::windows::core::GUID, punknown: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.SetUnknown)(::windows::core::Interface::as_raw(self), guidkey, punknown.into_param().abi()).ok()
    }
    pub unsafe fn LockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.LockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn UnlockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.UnlockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItemByIndex(&self, unindex: u32, pguidkey: *mut ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItemByIndex)(::windows::core::Interface::as_raw(self), unindex, pguidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn CopyAllItems<P0>(&self, pdest: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).base__.CopyAllItems)(::windows::core::Interface::as_raw(self), pdest.into_param().abi()).ok()
    }
    pub unsafe fn GetStreamIdentifier(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetStreamIdentifier)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetMediaTypeHandler(&self) -> ::windows::core::Result<IMFMediaTypeHandler> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaTypeHandler>();
        (::windows::core::Interface::vtable(self).GetMediaTypeHandler)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFStreamDescriptor, ::windows::core::IUnknown, IMFAttributes);
impl ::core::cmp::PartialEq for IMFStreamDescriptor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFStreamDescriptor {}
impl ::core::fmt::Debug for IMFStreamDescriptor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFStreamDescriptor").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFStreamDescriptor {
    type Vtable = IMFStreamDescriptor_Vtbl;
}
impl ::core::clone::Clone for IMFStreamDescriptor {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFStreamDescriptor {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x56c03d9c_9dbb_45f5_ab4b_d80f47c05938);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFStreamDescriptor_Vtbl {
    pub base__: IMFAttributes_Vtbl,
    pub GetStreamIdentifier: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwstreamidentifier: *mut u32) -> ::windows::core::HRESULT,
    pub GetMediaTypeHandler: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppmediatypehandler: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFStreamSink(::windows::core::IUnknown);
impl IMFStreamSink {
    pub unsafe fn GetEvent(&self, dwflags: MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS) -> ::windows::core::Result<IMFMediaEvent> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaEvent>();
        (::windows::core::Interface::vtable(self).base__.GetEvent)(::windows::core::Interface::as_raw(self), dwflags, &mut result__).from_abi(result__)
    }
    pub unsafe fn BeginGetEvent<P0, P1>(&self, pcallback: P0, punkstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.BeginGetEvent)(::windows::core::Interface::as_raw(self), pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    pub unsafe fn EndGetEvent<P0>(&self, presult: P0) -> ::windows::core::Result<IMFMediaEvent>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFMediaEvent>();
        (::windows::core::Interface::vtable(self).base__.EndGetEvent)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn QueueEvent(&self, met: u32, guidextendedtype: *const ::windows::core::GUID, hrstatus: ::windows::core::HRESULT, pvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.QueueEvent)(::windows::core::Interface::as_raw(self), met, guidextendedtype, hrstatus, pvvalue).ok()
    }
    pub unsafe fn GetMediaSink(&self) -> ::windows::core::Result<IMFMediaSink> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaSink>();
        (::windows::core::Interface::vtable(self).GetMediaSink)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetIdentifier(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetIdentifier)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetMediaTypeHandler(&self) -> ::windows::core::Result<IMFMediaTypeHandler> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaTypeHandler>();
        (::windows::core::Interface::vtable(self).GetMediaTypeHandler)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn ProcessSample<P0>(&self, psample: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFSample>,
    {
        (::windows::core::Interface::vtable(self).ProcessSample)(::windows::core::Interface::as_raw(self), psample.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn PlaceMarker(&self, emarkertype: MFSTREAMSINK_MARKER_TYPE, pvarmarkervalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pvarcontextvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).PlaceMarker)(::windows::core::Interface::as_raw(self), emarkertype, pvarmarkervalue, pvarcontextvalue).ok()
    }
    pub unsafe fn Flush(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Flush)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFStreamSink, ::windows::core::IUnknown, IMFMediaEventGenerator);
impl ::core::cmp::PartialEq for IMFStreamSink {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFStreamSink {}
impl ::core::fmt::Debug for IMFStreamSink {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFStreamSink").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFStreamSink {
    type Vtable = IMFStreamSink_Vtbl;
}
impl ::core::clone::Clone for IMFStreamSink {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFStreamSink {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0a97b3cf_8e7c_4a3d_8f8c_0c843dc247fb);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFStreamSink_Vtbl {
    pub base__: IMFMediaEventGenerator_Vtbl,
    pub GetMediaSink: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppmediasink: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetIdentifier: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwidentifier: *mut u32) -> ::windows::core::HRESULT,
    pub GetMediaTypeHandler: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pphandler: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub ProcessSample: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, psample: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub PlaceMarker: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, emarkertype: MFSTREAMSINK_MARKER_TYPE, pvarmarkervalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pvarcontextvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    PlaceMarker: usize,
    pub Flush: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFStreamingSinkConfig(::windows::core::IUnknown);
impl IMFStreamingSinkConfig {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn StartStreaming<P0>(&self, fseekoffsetisbyteoffset: P0, qwseekoffset: u64) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).StartStreaming)(::windows::core::Interface::as_raw(self), fseekoffsetisbyteoffset.into_param().abi(), qwseekoffset).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFStreamingSinkConfig, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFStreamingSinkConfig {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFStreamingSinkConfig {}
impl ::core::fmt::Debug for IMFStreamingSinkConfig {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFStreamingSinkConfig").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFStreamingSinkConfig {
    type Vtable = IMFStreamingSinkConfig_Vtbl;
}
impl ::core::clone::Clone for IMFStreamingSinkConfig {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFStreamingSinkConfig {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9db7aa41_3cc5_40d4_8509_555804ad34cc);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFStreamingSinkConfig_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub StartStreaming: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fseekoffsetisbyteoffset: super::super::Foundation::BOOL, qwseekoffset: u64) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    StartStreaming: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFSystemId(::windows::core::IUnknown);
impl IMFSystemId {
    pub unsafe fn GetData(&self, size: *mut u32, data: *mut *mut u8) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetData)(::windows::core::Interface::as_raw(self), size, data).ok()
    }
    pub unsafe fn Setup(&self, stage: u32, pbin: &[u8], pcbout: *mut u32, ppbout: *mut *mut u8) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Setup)(::windows::core::Interface::as_raw(self), stage, pbin.len() as _, ::core::mem::transmute(pbin.as_ptr()), pcbout, ppbout).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFSystemId, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFSystemId {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFSystemId {}
impl ::core::fmt::Debug for IMFSystemId {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFSystemId").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFSystemId {
    type Vtable = IMFSystemId_Vtbl;
}
impl ::core::clone::Clone for IMFSystemId {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFSystemId {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfff4af3a_1fc1_4ef9_a29b_d26c49e2f31a);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFSystemId_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetData: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, size: *mut u32, data: *mut *mut u8) -> ::windows::core::HRESULT,
    pub Setup: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, stage: u32, cbin: u32, pbin: *const u8, pcbout: *mut u32, ppbout: *mut *mut u8) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTimecodeTranslate(::windows::core::IUnknown);
impl IMFTimecodeTranslate {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn BeginConvertTimecodeToHNS<P0, P1>(&self, ppropvartimecode: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pcallback: P0, punkstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginConvertTimecodeToHNS)(::windows::core::Interface::as_raw(self), ppropvartimecode, pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    pub unsafe fn EndConvertTimecodeToHNS<P0>(&self, presult: P0) -> ::windows::core::Result<i64>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        let mut result__ = ::windows::core::zeroed::<i64>();
        (::windows::core::Interface::vtable(self).EndConvertTimecodeToHNS)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn BeginConvertHNSToTimecode<P0, P1>(&self, hnstime: i64, pcallback: P0, punkstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginConvertHNSToTimecode)(::windows::core::Interface::as_raw(self), hnstime, pcallback.into_param().abi(), punkstate.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn EndConvertHNSToTimecode<P0>(&self, presult: P0) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::System::Com::StructuredStorage::PROPVARIANT>();
        (::windows::core::Interface::vtable(self).EndConvertHNSToTimecode)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFTimecodeTranslate, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTimecodeTranslate {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTimecodeTranslate {}
impl ::core::fmt::Debug for IMFTimecodeTranslate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTimecodeTranslate").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTimecodeTranslate {
    type Vtable = IMFTimecodeTranslate_Vtbl;
}
impl ::core::clone::Clone for IMFTimecodeTranslate {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTimecodeTranslate {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xab9d8661_f7e8_4ef4_9861_89f334f94e74);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTimecodeTranslate_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub BeginConvertTimecodeToHNS: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppropvartimecode: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pcallback: *mut ::core::ffi::c_void, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    BeginConvertTimecodeToHNS: usize,
    pub EndConvertTimecodeToHNS: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void, phnstime: *mut i64) -> ::windows::core::HRESULT,
    pub BeginConvertHNSToTimecode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hnstime: i64, pcallback: *mut ::core::ffi::c_void, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub EndConvertHNSToTimecode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void, ppropvartimecode: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage")))]
    EndConvertHNSToTimecode: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTimedText(::windows::core::IUnknown);
impl IMFTimedText {
    pub unsafe fn RegisterNotifications<P0>(&self, notify: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFTimedTextNotify>,
    {
        (::windows::core::Interface::vtable(self).RegisterNotifications)(::windows::core::Interface::as_raw(self), notify.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SelectTrack<P0>(&self, trackid: u32, selected: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SelectTrack)(::windows::core::Interface::as_raw(self), trackid, selected.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn AddDataSource<P0, P1, P2, P3>(&self, bytestream: P0, label: P1, language: P2, kind: MF_TIMED_TEXT_TRACK_KIND, isdefault: P3) -> ::windows::core::Result<u32>
    where
        P0: ::windows::core::IntoParam<IMFByteStream>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P2: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P3: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).AddDataSource)(::windows::core::Interface::as_raw(self), bytestream.into_param().abi(), label.into_param().abi(), language.into_param().abi(), kind, isdefault.into_param().abi(), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn AddDataSourceFromUrl<P0, P1, P2, P3>(&self, url: P0, label: P1, language: P2, kind: MF_TIMED_TEXT_TRACK_KIND, isdefault: P3) -> ::windows::core::Result<u32>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P2: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P3: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).AddDataSourceFromUrl)(::windows::core::Interface::as_raw(self), url.into_param().abi(), label.into_param().abi(), language.into_param().abi(), kind, isdefault.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn AddTrack<P0, P1>(&self, label: P0, language: P1, kind: MF_TIMED_TEXT_TRACK_KIND) -> ::windows::core::Result<IMFTimedTextTrack>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFTimedTextTrack>();
        (::windows::core::Interface::vtable(self).AddTrack)(::windows::core::Interface::as_raw(self), label.into_param().abi(), language.into_param().abi(), kind, &mut result__).from_abi(result__)
    }
    pub unsafe fn RemoveTrack<P0>(&self, track: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFTimedTextTrack>,
    {
        (::windows::core::Interface::vtable(self).RemoveTrack)(::windows::core::Interface::as_raw(self), track.into_param().abi()).ok()
    }
    pub unsafe fn GetCueTimeOffset(&self) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).GetCueTimeOffset)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetCueTimeOffset(&self, offset: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetCueTimeOffset)(::windows::core::Interface::as_raw(self), offset).ok()
    }
    pub unsafe fn GetTracks(&self) -> ::windows::core::Result<IMFTimedTextTrackList> {
        let mut result__ = ::windows::core::zeroed::<IMFTimedTextTrackList>();
        (::windows::core::Interface::vtable(self).GetTracks)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetActiveTracks(&self) -> ::windows::core::Result<IMFTimedTextTrackList> {
        let mut result__ = ::windows::core::zeroed::<IMFTimedTextTrackList>();
        (::windows::core::Interface::vtable(self).GetActiveTracks)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetTextTracks(&self) -> ::windows::core::Result<IMFTimedTextTrackList> {
        let mut result__ = ::windows::core::zeroed::<IMFTimedTextTrackList>();
        (::windows::core::Interface::vtable(self).GetTextTracks)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetMetadataTracks(&self) -> ::windows::core::Result<IMFTimedTextTrackList> {
        let mut result__ = ::windows::core::zeroed::<IMFTimedTextTrackList>();
        (::windows::core::Interface::vtable(self).GetMetadataTracks)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetInBandEnabled<P0>(&self, enabled: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetInBandEnabled)(::windows::core::Interface::as_raw(self), enabled.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsInBandEnabled(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).IsInBandEnabled)(::windows::core::Interface::as_raw(self))
    }
}
::windows::imp::interface_hierarchy!(IMFTimedText, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTimedText {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTimedText {}
impl ::core::fmt::Debug for IMFTimedText {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTimedText").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTimedText {
    type Vtable = IMFTimedText_Vtbl;
}
impl ::core::clone::Clone for IMFTimedText {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTimedText {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1f2a94c9_a3df_430d_9d0f_acd85ddc29af);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTimedText_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub RegisterNotifications: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, notify: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub SelectTrack: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, trackid: u32, selected: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SelectTrack: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub AddDataSource: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, bytestream: *mut ::core::ffi::c_void, label: ::windows::core::PCWSTR, language: ::windows::core::PCWSTR, kind: MF_TIMED_TEXT_TRACK_KIND, isdefault: super::super::Foundation::BOOL, trackid: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    AddDataSource: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub AddDataSourceFromUrl: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, url: ::windows::core::PCWSTR, label: ::windows::core::PCWSTR, language: ::windows::core::PCWSTR, kind: MF_TIMED_TEXT_TRACK_KIND, isdefault: super::super::Foundation::BOOL, trackid: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    AddDataSourceFromUrl: usize,
    pub AddTrack: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, label: ::windows::core::PCWSTR, language: ::windows::core::PCWSTR, kind: MF_TIMED_TEXT_TRACK_KIND, track: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RemoveTrack: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, track: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetCueTimeOffset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, offset: *mut f64) -> ::windows::core::HRESULT,
    pub SetCueTimeOffset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, offset: f64) -> ::windows::core::HRESULT,
    pub GetTracks: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, tracks: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetActiveTracks: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, activetracks: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetTextTracks: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, texttracks: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetMetadataTracks: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, metadatatracks: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub SetInBandEnabled: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, enabled: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetInBandEnabled: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub IsInBandEnabled: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsInBandEnabled: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTimedTextBinary(::windows::core::IUnknown);
impl IMFTimedTextBinary {
    pub unsafe fn GetData(&self, data: *mut *mut u8, length: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetData)(::windows::core::Interface::as_raw(self), data, length).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFTimedTextBinary, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTimedTextBinary {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTimedTextBinary {}
impl ::core::fmt::Debug for IMFTimedTextBinary {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTimedTextBinary").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTimedTextBinary {
    type Vtable = IMFTimedTextBinary_Vtbl;
}
impl ::core::clone::Clone for IMFTimedTextBinary {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTimedTextBinary {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4ae3a412_0545_43c4_bf6f_6b97a5c6c432);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTimedTextBinary_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetData: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, data: *mut *mut u8, length: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTimedTextBouten(::windows::core::IUnknown);
impl IMFTimedTextBouten {
    pub unsafe fn GetBoutenType(&self) -> ::windows::core::Result<MF_TIMED_TEXT_BOUTEN_TYPE> {
        let mut result__ = ::windows::core::zeroed::<MF_TIMED_TEXT_BOUTEN_TYPE>();
        (::windows::core::Interface::vtable(self).GetBoutenType)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBoutenColor(&self) -> ::windows::core::Result<MFARGB> {
        let mut result__ = ::windows::core::zeroed::<MFARGB>();
        (::windows::core::Interface::vtable(self).GetBoutenColor)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBoutenPosition(&self) -> ::windows::core::Result<MF_TIMED_TEXT_BOUTEN_POSITION> {
        let mut result__ = ::windows::core::zeroed::<MF_TIMED_TEXT_BOUTEN_POSITION>();
        (::windows::core::Interface::vtable(self).GetBoutenPosition)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFTimedTextBouten, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTimedTextBouten {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTimedTextBouten {}
impl ::core::fmt::Debug for IMFTimedTextBouten {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTimedTextBouten").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTimedTextBouten {
    type Vtable = IMFTimedTextBouten_Vtbl;
}
impl ::core::clone::Clone for IMFTimedTextBouten {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTimedTextBouten {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3c5f3e8a_90c0_464e_8136_898d2975f847);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTimedTextBouten_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetBoutenType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, value: *mut MF_TIMED_TEXT_BOUTEN_TYPE) -> ::windows::core::HRESULT,
    pub GetBoutenColor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, value: *mut MFARGB) -> ::windows::core::HRESULT,
    pub GetBoutenPosition: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, value: *mut MF_TIMED_TEXT_BOUTEN_POSITION) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTimedTextCue(::windows::core::IUnknown);
impl IMFTimedTextCue {
    pub unsafe fn GetId(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetId)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetOriginalId(&self) -> ::windows::core::Result<::windows::core::PWSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::PWSTR>();
        (::windows::core::Interface::vtable(self).GetOriginalId)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetCueKind(&self) -> MF_TIMED_TEXT_TRACK_KIND {
        (::windows::core::Interface::vtable(self).GetCueKind)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetStartTime(&self) -> f64 {
        (::windows::core::Interface::vtable(self).GetStartTime)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetDuration(&self) -> f64 {
        (::windows::core::Interface::vtable(self).GetDuration)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetTrackId(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetTrackId)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetData(&self) -> ::windows::core::Result<IMFTimedTextBinary> {
        let mut result__ = ::windows::core::zeroed::<IMFTimedTextBinary>();
        (::windows::core::Interface::vtable(self).GetData)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetRegion(&self) -> ::windows::core::Result<IMFTimedTextRegion> {
        let mut result__ = ::windows::core::zeroed::<IMFTimedTextRegion>();
        (::windows::core::Interface::vtable(self).GetRegion)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStyle(&self) -> ::windows::core::Result<IMFTimedTextStyle> {
        let mut result__ = ::windows::core::zeroed::<IMFTimedTextStyle>();
        (::windows::core::Interface::vtable(self).GetStyle)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetLineCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetLineCount)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetLine(&self, index: u32) -> ::windows::core::Result<IMFTimedTextFormattedText> {
        let mut result__ = ::windows::core::zeroed::<IMFTimedTextFormattedText>();
        (::windows::core::Interface::vtable(self).GetLine)(::windows::core::Interface::as_raw(self), index, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFTimedTextCue, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTimedTextCue {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTimedTextCue {}
impl ::core::fmt::Debug for IMFTimedTextCue {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTimedTextCue").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTimedTextCue {
    type Vtable = IMFTimedTextCue_Vtbl;
}
impl ::core::clone::Clone for IMFTimedTextCue {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTimedTextCue {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1e560447_9a2b_43e1_a94c_b0aaabfbfbc9);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTimedTextCue_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetOriginalId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, originalid: *mut ::windows::core::PWSTR) -> ::windows::core::HRESULT,
    pub GetCueKind: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> MF_TIMED_TEXT_TRACK_KIND,
    pub GetStartTime: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> f64,
    pub GetDuration: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> f64,
    pub GetTrackId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetData: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, data: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetRegion: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, region: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetStyle: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, style: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetLineCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetLine: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, line: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTimedTextCueList(::windows::core::IUnknown);
impl IMFTimedTextCueList {
    pub unsafe fn GetLength(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetLength)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetCueByIndex(&self, index: u32) -> ::windows::core::Result<IMFTimedTextCue> {
        let mut result__ = ::windows::core::zeroed::<IMFTimedTextCue>();
        (::windows::core::Interface::vtable(self).GetCueByIndex)(::windows::core::Interface::as_raw(self), index, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetCueById(&self, id: u32) -> ::windows::core::Result<IMFTimedTextCue> {
        let mut result__ = ::windows::core::zeroed::<IMFTimedTextCue>();
        (::windows::core::Interface::vtable(self).GetCueById)(::windows::core::Interface::as_raw(self), id, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetCueByOriginalId<P0>(&self, originalid: P0) -> ::windows::core::Result<IMFTimedTextCue>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFTimedTextCue>();
        (::windows::core::Interface::vtable(self).GetCueByOriginalId)(::windows::core::Interface::as_raw(self), originalid.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn AddTextCue<P0>(&self, start: f64, duration: f64, text: P0, cue: ::core::option::Option<*mut ::core::option::Option<IMFTimedTextCue>>) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).AddTextCue)(::windows::core::Interface::as_raw(self), start, duration, text.into_param().abi(), ::core::mem::transmute(cue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn AddDataCue(&self, start: f64, duration: f64, data: &[u8], cue: ::core::option::Option<*mut ::core::option::Option<IMFTimedTextCue>>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).AddDataCue)(::windows::core::Interface::as_raw(self), start, duration, ::core::mem::transmute(data.as_ptr()), data.len() as _, ::core::mem::transmute(cue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn RemoveCue<P0>(&self, cue: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFTimedTextCue>,
    {
        (::windows::core::Interface::vtable(self).RemoveCue)(::windows::core::Interface::as_raw(self), cue.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFTimedTextCueList, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTimedTextCueList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTimedTextCueList {}
impl ::core::fmt::Debug for IMFTimedTextCueList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTimedTextCueList").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTimedTextCueList {
    type Vtable = IMFTimedTextCueList_Vtbl;
}
impl ::core::clone::Clone for IMFTimedTextCueList {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTimedTextCueList {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xad128745_211b_40a0_9981_fe65f166d0fd);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTimedTextCueList_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetLength: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetCueByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, cue: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetCueById: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, id: u32, cue: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetCueByOriginalId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, originalid: ::windows::core::PCWSTR, cue: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub AddTextCue: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, start: f64, duration: f64, text: ::windows::core::PCWSTR, cue: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub AddDataCue: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, start: f64, duration: f64, data: *const u8, datasize: u32, cue: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RemoveCue: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cue: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTimedTextFormattedText(::windows::core::IUnknown);
impl IMFTimedTextFormattedText {
    pub unsafe fn GetText(&self) -> ::windows::core::Result<::windows::core::PWSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::PWSTR>();
        (::windows::core::Interface::vtable(self).GetText)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetSubformattingCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetSubformattingCount)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetSubformatting(&self, index: u32, firstchar: *mut u32, charlength: *mut u32, style: *mut ::core::option::Option<IMFTimedTextStyle>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetSubformatting)(::windows::core::Interface::as_raw(self), index, firstchar, charlength, ::core::mem::transmute(style)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFTimedTextFormattedText, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTimedTextFormattedText {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTimedTextFormattedText {}
impl ::core::fmt::Debug for IMFTimedTextFormattedText {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTimedTextFormattedText").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTimedTextFormattedText {
    type Vtable = IMFTimedTextFormattedText_Vtbl;
}
impl ::core::clone::Clone for IMFTimedTextFormattedText {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTimedTextFormattedText {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe13af3c1_4d47_4354_b1f5_e83ae0ecae60);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTimedTextFormattedText_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetText: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, text: *mut ::windows::core::PWSTR) -> ::windows::core::HRESULT,
    pub GetSubformattingCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetSubformatting: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, firstchar: *mut u32, charlength: *mut u32, style: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTimedTextNotify(::windows::core::IUnknown);
impl IMFTimedTextNotify {
    pub unsafe fn TrackAdded(&self, trackid: u32) {
        (::windows::core::Interface::vtable(self).TrackAdded)(::windows::core::Interface::as_raw(self), trackid)
    }
    pub unsafe fn TrackRemoved(&self, trackid: u32) {
        (::windows::core::Interface::vtable(self).TrackRemoved)(::windows::core::Interface::as_raw(self), trackid)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn TrackSelected<P0>(&self, trackid: u32, selected: P0)
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).TrackSelected)(::windows::core::Interface::as_raw(self), trackid, selected.into_param().abi())
    }
    pub unsafe fn TrackReadyStateChanged(&self, trackid: u32) {
        (::windows::core::Interface::vtable(self).TrackReadyStateChanged)(::windows::core::Interface::as_raw(self), trackid)
    }
    pub unsafe fn Error(&self, errorcode: MF_TIMED_TEXT_ERROR_CODE, extendederrorcode: ::windows::core::HRESULT, sourcetrackid: u32) {
        (::windows::core::Interface::vtable(self).Error)(::windows::core::Interface::as_raw(self), errorcode, extendederrorcode, sourcetrackid)
    }
    pub unsafe fn Cue<P0>(&self, cueevent: MF_TIMED_TEXT_CUE_EVENT, currenttime: f64, cue: P0)
    where
        P0: ::windows::core::IntoParam<IMFTimedTextCue>,
    {
        (::windows::core::Interface::vtable(self).Cue)(::windows::core::Interface::as_raw(self), cueevent, currenttime, cue.into_param().abi())
    }
    pub unsafe fn Reset(&self) {
        (::windows::core::Interface::vtable(self).Reset)(::windows::core::Interface::as_raw(self))
    }
}
::windows::imp::interface_hierarchy!(IMFTimedTextNotify, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTimedTextNotify {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTimedTextNotify {}
impl ::core::fmt::Debug for IMFTimedTextNotify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTimedTextNotify").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTimedTextNotify {
    type Vtable = IMFTimedTextNotify_Vtbl;
}
impl ::core::clone::Clone for IMFTimedTextNotify {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTimedTextNotify {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdf6b87b6_ce12_45db_aba7_432fe054e57d);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTimedTextNotify_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub TrackAdded: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, trackid: u32),
    pub TrackRemoved: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, trackid: u32),
    #[cfg(feature = "Win32_Foundation")]
    pub TrackSelected: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, trackid: u32, selected: super::super::Foundation::BOOL),
    #[cfg(not(feature = "Win32_Foundation"))]
    TrackSelected: usize,
    pub TrackReadyStateChanged: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, trackid: u32),
    pub Error: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, errorcode: MF_TIMED_TEXT_ERROR_CODE, extendederrorcode: ::windows::core::HRESULT, sourcetrackid: u32),
    pub Cue: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cueevent: MF_TIMED_TEXT_CUE_EVENT, currenttime: f64, cue: *mut ::core::ffi::c_void),
    pub Reset: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTimedTextRegion(::windows::core::IUnknown);
impl IMFTimedTextRegion {
    pub unsafe fn GetName(&self) -> ::windows::core::Result<::windows::core::PWSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::PWSTR>();
        (::windows::core::Interface::vtable(self).GetName)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetPosition(&self, px: *mut f64, py: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetPosition)(::windows::core::Interface::as_raw(self), px, py, unittype).ok()
    }
    pub unsafe fn GetExtent(&self, pwidth: *mut f64, pheight: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetExtent)(::windows::core::Interface::as_raw(self), pwidth, pheight, unittype).ok()
    }
    pub unsafe fn GetBackgroundColor(&self) -> ::windows::core::Result<MFARGB> {
        let mut result__ = ::windows::core::zeroed::<MFARGB>();
        (::windows::core::Interface::vtable(self).GetBackgroundColor)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetWritingMode(&self) -> ::windows::core::Result<MF_TIMED_TEXT_WRITING_MODE> {
        let mut result__ = ::windows::core::zeroed::<MF_TIMED_TEXT_WRITING_MODE>();
        (::windows::core::Interface::vtable(self).GetWritingMode)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDisplayAlignment(&self) -> ::windows::core::Result<MF_TIMED_TEXT_DISPLAY_ALIGNMENT> {
        let mut result__ = ::windows::core::zeroed::<MF_TIMED_TEXT_DISPLAY_ALIGNMENT>();
        (::windows::core::Interface::vtable(self).GetDisplayAlignment)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetLineHeight(&self, plineheight: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetLineHeight)(::windows::core::Interface::as_raw(self), plineheight, unittype).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetClipOverflow(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).GetClipOverflow)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetPadding(&self, before: *mut f64, start: *mut f64, after: *mut f64, end: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetPadding)(::windows::core::Interface::as_raw(self), before, start, after, end, unittype).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetWrap(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).GetWrap)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetZIndex(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::windows::core::zeroed::<i32>();
        (::windows::core::Interface::vtable(self).GetZIndex)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetScrollMode(&self) -> ::windows::core::Result<MF_TIMED_TEXT_SCROLL_MODE> {
        let mut result__ = ::windows::core::zeroed::<MF_TIMED_TEXT_SCROLL_MODE>();
        (::windows::core::Interface::vtable(self).GetScrollMode)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFTimedTextRegion, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTimedTextRegion {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTimedTextRegion {}
impl ::core::fmt::Debug for IMFTimedTextRegion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTimedTextRegion").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTimedTextRegion {
    type Vtable = IMFTimedTextRegion_Vtbl;
}
impl ::core::clone::Clone for IMFTimedTextRegion {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTimedTextRegion {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc8d22afc_bc47_4bdf_9b04_787e49ce3f58);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTimedTextRegion_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetName: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, name: *mut ::windows::core::PWSTR) -> ::windows::core::HRESULT,
    pub GetPosition: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, px: *mut f64, py: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::HRESULT,
    pub GetExtent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pwidth: *mut f64, pheight: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::HRESULT,
    pub GetBackgroundColor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, bgcolor: *mut MFARGB) -> ::windows::core::HRESULT,
    pub GetWritingMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, writingmode: *mut MF_TIMED_TEXT_WRITING_MODE) -> ::windows::core::HRESULT,
    pub GetDisplayAlignment: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, displayalign: *mut MF_TIMED_TEXT_DISPLAY_ALIGNMENT) -> ::windows::core::HRESULT,
    pub GetLineHeight: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, plineheight: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub GetClipOverflow: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, clipoverflow: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetClipOverflow: usize,
    pub GetPadding: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, before: *mut f64, start: *mut f64, after: *mut f64, end: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub GetWrap: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, wrap: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetWrap: usize,
    pub GetZIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, zindex: *mut i32) -> ::windows::core::HRESULT,
    pub GetScrollMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, scrollmode: *mut MF_TIMED_TEXT_SCROLL_MODE) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTimedTextRuby(::windows::core::IUnknown);
impl IMFTimedTextRuby {
    pub unsafe fn GetRubyText(&self) -> ::windows::core::Result<::windows::core::PWSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::PWSTR>();
        (::windows::core::Interface::vtable(self).GetRubyText)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetRubyPosition(&self) -> ::windows::core::Result<MF_TIMED_TEXT_RUBY_POSITION> {
        let mut result__ = ::windows::core::zeroed::<MF_TIMED_TEXT_RUBY_POSITION>();
        (::windows::core::Interface::vtable(self).GetRubyPosition)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetRubyAlign(&self) -> ::windows::core::Result<MF_TIMED_TEXT_RUBY_ALIGN> {
        let mut result__ = ::windows::core::zeroed::<MF_TIMED_TEXT_RUBY_ALIGN>();
        (::windows::core::Interface::vtable(self).GetRubyAlign)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetRubyReserve(&self) -> ::windows::core::Result<MF_TIMED_TEXT_RUBY_RESERVE> {
        let mut result__ = ::windows::core::zeroed::<MF_TIMED_TEXT_RUBY_RESERVE>();
        (::windows::core::Interface::vtable(self).GetRubyReserve)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFTimedTextRuby, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTimedTextRuby {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTimedTextRuby {}
impl ::core::fmt::Debug for IMFTimedTextRuby {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTimedTextRuby").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTimedTextRuby {
    type Vtable = IMFTimedTextRuby_Vtbl;
}
impl ::core::clone::Clone for IMFTimedTextRuby {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTimedTextRuby {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x76c6a6f5_4955_4de5_b27b_14b734cc14b4);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTimedTextRuby_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetRubyText: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, rubytext: *mut ::windows::core::PWSTR) -> ::windows::core::HRESULT,
    pub GetRubyPosition: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, value: *mut MF_TIMED_TEXT_RUBY_POSITION) -> ::windows::core::HRESULT,
    pub GetRubyAlign: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, value: *mut MF_TIMED_TEXT_RUBY_ALIGN) -> ::windows::core::HRESULT,
    pub GetRubyReserve: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, value: *mut MF_TIMED_TEXT_RUBY_RESERVE) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTimedTextStyle(::windows::core::IUnknown);
impl IMFTimedTextStyle {
    pub unsafe fn GetName(&self) -> ::windows::core::Result<::windows::core::PWSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::PWSTR>();
        (::windows::core::Interface::vtable(self).GetName)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsExternal(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).IsExternal)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetFontFamily(&self) -> ::windows::core::Result<::windows::core::PWSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::PWSTR>();
        (::windows::core::Interface::vtable(self).GetFontFamily)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetFontSize(&self, fontsize: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetFontSize)(::windows::core::Interface::as_raw(self), fontsize, unittype).ok()
    }
    pub unsafe fn GetColor(&self) -> ::windows::core::Result<MFARGB> {
        let mut result__ = ::windows::core::zeroed::<MFARGB>();
        (::windows::core::Interface::vtable(self).GetColor)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBackgroundColor(&self) -> ::windows::core::Result<MFARGB> {
        let mut result__ = ::windows::core::zeroed::<MFARGB>();
        (::windows::core::Interface::vtable(self).GetBackgroundColor)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetShowBackgroundAlways(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).GetShowBackgroundAlways)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetFontStyle(&self) -> ::windows::core::Result<MF_TIMED_TEXT_FONT_STYLE> {
        let mut result__ = ::windows::core::zeroed::<MF_TIMED_TEXT_FONT_STYLE>();
        (::windows::core::Interface::vtable(self).GetFontStyle)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetBold(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).GetBold)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetRightToLeft(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).GetRightToLeft)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetTextAlignment(&self) -> ::windows::core::Result<MF_TIMED_TEXT_ALIGNMENT> {
        let mut result__ = ::windows::core::zeroed::<MF_TIMED_TEXT_ALIGNMENT>();
        (::windows::core::Interface::vtable(self).GetTextAlignment)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetTextDecoration(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetTextDecoration)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetTextOutline(&self, color: *mut MFARGB, thickness: *mut f64, blurradius: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetTextOutline)(::windows::core::Interface::as_raw(self), color, thickness, blurradius, unittype).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFTimedTextStyle, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTimedTextStyle {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTimedTextStyle {}
impl ::core::fmt::Debug for IMFTimedTextStyle {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTimedTextStyle").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTimedTextStyle {
    type Vtable = IMFTimedTextStyle_Vtbl;
}
impl ::core::clone::Clone for IMFTimedTextStyle {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTimedTextStyle {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x09b2455d_b834_4f01_a347_9052e21c450e);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTimedTextStyle_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetName: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, name: *mut ::windows::core::PWSTR) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub IsExternal: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsExternal: usize,
    pub GetFontFamily: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fontfamily: *mut ::windows::core::PWSTR) -> ::windows::core::HRESULT,
    pub GetFontSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fontsize: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::HRESULT,
    pub GetColor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, color: *mut MFARGB) -> ::windows::core::HRESULT,
    pub GetBackgroundColor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, bgcolor: *mut MFARGB) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub GetShowBackgroundAlways: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, showbackgroundalways: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetShowBackgroundAlways: usize,
    pub GetFontStyle: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fontstyle: *mut MF_TIMED_TEXT_FONT_STYLE) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub GetBold: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, bold: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetBold: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub GetRightToLeft: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, righttoleft: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetRightToLeft: usize,
    pub GetTextAlignment: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, textalign: *mut MF_TIMED_TEXT_ALIGNMENT) -> ::windows::core::HRESULT,
    pub GetTextDecoration: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, textdecoration: *mut u32) -> ::windows::core::HRESULT,
    pub GetTextOutline: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, color: *mut MFARGB, thickness: *mut f64, blurradius: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTimedTextStyle2(::windows::core::IUnknown);
impl IMFTimedTextStyle2 {
    pub unsafe fn GetRuby(&self) -> ::windows::core::Result<IMFTimedTextRuby> {
        let mut result__ = ::windows::core::zeroed::<IMFTimedTextRuby>();
        (::windows::core::Interface::vtable(self).GetRuby)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBouten(&self) -> ::windows::core::Result<IMFTimedTextBouten> {
        let mut result__ = ::windows::core::zeroed::<IMFTimedTextBouten>();
        (::windows::core::Interface::vtable(self).GetBouten)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsTextCombined(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).IsTextCombined)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetFontAngleInDegrees(&self) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).GetFontAngleInDegrees)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFTimedTextStyle2, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTimedTextStyle2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTimedTextStyle2 {}
impl ::core::fmt::Debug for IMFTimedTextStyle2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTimedTextStyle2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTimedTextStyle2 {
    type Vtable = IMFTimedTextStyle2_Vtbl;
}
impl ::core::clone::Clone for IMFTimedTextStyle2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTimedTextStyle2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdb639199_c809_4c89_bfca_d0bbb9729d6e);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTimedTextStyle2_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetRuby: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ruby: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetBouten: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, bouten: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub IsTextCombined: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, value: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsTextCombined: usize,
    pub GetFontAngleInDegrees: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, value: *mut f64) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTimedTextTrack(::windows::core::IUnknown);
impl IMFTimedTextTrack {
    pub unsafe fn GetId(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetId)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetLabel(&self) -> ::windows::core::Result<::windows::core::PWSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::PWSTR>();
        (::windows::core::Interface::vtable(self).GetLabel)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetLabel<P0>(&self, label: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).SetLabel)(::windows::core::Interface::as_raw(self), label.into_param().abi()).ok()
    }
    pub unsafe fn GetLanguage(&self) -> ::windows::core::Result<::windows::core::PWSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::PWSTR>();
        (::windows::core::Interface::vtable(self).GetLanguage)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetTrackKind(&self) -> MF_TIMED_TEXT_TRACK_KIND {
        (::windows::core::Interface::vtable(self).GetTrackKind)(::windows::core::Interface::as_raw(self))
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsInBand(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).IsInBand)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetInBandMetadataTrackDispatchType(&self) -> ::windows::core::Result<::windows::core::PWSTR> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::PWSTR>();
        (::windows::core::Interface::vtable(self).GetInBandMetadataTrackDispatchType)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsActive(&self) -> super::super::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).IsActive)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetErrorCode(&self) -> MF_TIMED_TEXT_ERROR_CODE {
        (::windows::core::Interface::vtable(self).GetErrorCode)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetExtendedErrorCode(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetExtendedErrorCode)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetDataFormat(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).GetDataFormat)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetReadyState(&self) -> MF_TIMED_TEXT_TRACK_READY_STATE {
        (::windows::core::Interface::vtable(self).GetReadyState)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetCueList(&self) -> ::windows::core::Result<IMFTimedTextCueList> {
        let mut result__ = ::windows::core::zeroed::<IMFTimedTextCueList>();
        (::windows::core::Interface::vtable(self).GetCueList)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFTimedTextTrack, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTimedTextTrack {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTimedTextTrack {}
impl ::core::fmt::Debug for IMFTimedTextTrack {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTimedTextTrack").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTimedTextTrack {
    type Vtable = IMFTimedTextTrack_Vtbl;
}
impl ::core::clone::Clone for IMFTimedTextTrack {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTimedTextTrack {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8822c32d_654e_4233_bf21_d7f2e67d30d4);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTimedTextTrack_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetLabel: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, label: *mut ::windows::core::PWSTR) -> ::windows::core::HRESULT,
    pub SetLabel: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, label: ::windows::core::PCWSTR) -> ::windows::core::HRESULT,
    pub GetLanguage: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, language: *mut ::windows::core::PWSTR) -> ::windows::core::HRESULT,
    pub GetTrackKind: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> MF_TIMED_TEXT_TRACK_KIND,
    #[cfg(feature = "Win32_Foundation")]
    pub IsInBand: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsInBand: usize,
    pub GetInBandMetadataTrackDispatchType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dispatchtype: *mut ::windows::core::PWSTR) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub IsActive: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsActive: usize,
    pub GetErrorCode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> MF_TIMED_TEXT_ERROR_CODE,
    pub GetExtendedErrorCode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetDataFormat: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, format: *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub GetReadyState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> MF_TIMED_TEXT_TRACK_READY_STATE,
    pub GetCueList: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cues: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTimedTextTrackList(::windows::core::IUnknown);
impl IMFTimedTextTrackList {
    pub unsafe fn GetLength(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetLength)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetTrack(&self, index: u32) -> ::windows::core::Result<IMFTimedTextTrack> {
        let mut result__ = ::windows::core::zeroed::<IMFTimedTextTrack>();
        (::windows::core::Interface::vtable(self).GetTrack)(::windows::core::Interface::as_raw(self), index, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetTrackById(&self, trackid: u32) -> ::windows::core::Result<IMFTimedTextTrack> {
        let mut result__ = ::windows::core::zeroed::<IMFTimedTextTrack>();
        (::windows::core::Interface::vtable(self).GetTrackById)(::windows::core::Interface::as_raw(self), trackid, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFTimedTextTrackList, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTimedTextTrackList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTimedTextTrackList {}
impl ::core::fmt::Debug for IMFTimedTextTrackList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTimedTextTrackList").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTimedTextTrackList {
    type Vtable = IMFTimedTextTrackList_Vtbl;
}
impl ::core::clone::Clone for IMFTimedTextTrackList {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTimedTextTrackList {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x23ff334c_442c_445f_bccc_edc438aa11e2);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTimedTextTrackList_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetLength: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetTrack: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, index: u32, track: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetTrackById: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, trackid: u32, track: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTimer(::windows::core::IUnknown);
impl IMFTimer {
    pub unsafe fn SetTimer<P0, P1>(&self, dwflags: u32, llclocktime: i64, pcallback: P0, punkstate: P1) -> ::windows::core::Result<::windows::core::IUnknown>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::core::IUnknown>();
        (::windows::core::Interface::vtable(self).SetTimer)(::windows::core::Interface::as_raw(self), dwflags, llclocktime, pcallback.into_param().abi(), punkstate.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn CancelTimer<P0>(&self, punkkey: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).CancelTimer)(::windows::core::Interface::as_raw(self), punkkey.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFTimer, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTimer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTimer {}
impl ::core::fmt::Debug for IMFTimer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTimer").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTimer {
    type Vtable = IMFTimer_Vtbl;
}
impl ::core::clone::Clone for IMFTimer {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTimer {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe56e4cbd_8f70_49d8_a0f8_edb3d6ab9bf2);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTimer_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetTimer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwflags: u32, llclocktime: i64, pcallback: *mut ::core::ffi::c_void, punkstate: *mut ::core::ffi::c_void, ppunkkey: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub CancelTimer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, punkkey: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTopoLoader(::windows::core::IUnknown);
impl IMFTopoLoader {
    pub unsafe fn Load<P0, P1>(&self, pinputtopo: P0, ppoutputtopo: *mut ::core::option::Option<IMFTopology>, pcurrenttopo: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFTopology>,
        P1: ::windows::core::IntoParam<IMFTopology>,
    {
        (::windows::core::Interface::vtable(self).Load)(::windows::core::Interface::as_raw(self), pinputtopo.into_param().abi(), ::core::mem::transmute(ppoutputtopo), pcurrenttopo.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFTopoLoader, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTopoLoader {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTopoLoader {}
impl ::core::fmt::Debug for IMFTopoLoader {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTopoLoader").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTopoLoader {
    type Vtable = IMFTopoLoader_Vtbl;
}
impl ::core::clone::Clone for IMFTopoLoader {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTopoLoader {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xde9a6157_f660_4643_b56a_df9f7998c7cd);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTopoLoader_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub Load: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pinputtopo: *mut ::core::ffi::c_void, ppoutputtopo: *mut *mut ::core::ffi::c_void, pcurrenttopo: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTopology(::windows::core::IUnknown);
impl IMFTopology {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItem(&self, guidkey: *const ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItem)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetItemType(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<MF_ATTRIBUTE_TYPE> {
        let mut result__ = ::windows::core::zeroed::<MF_ATTRIBUTE_TYPE>();
        (::windows::core::Interface::vtable(self).base__.GetItemType)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn CompareItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.CompareItem)(::windows::core::Interface::as_raw(self), guidkey, value, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Compare<P0>(&self, ptheirs: P0, matchtype: MF_ATTRIBUTES_MATCH_TYPE) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.Compare)(::windows::core::Interface::as_raw(self), ptheirs.into_param().abi(), matchtype, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT32(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetUINT32)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT64(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).base__.GetUINT64)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDouble(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).base__.GetDouble)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetGUID(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).base__.GetGUID)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStringLength(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetStringLength)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetString(&self, guidkey: *const ::windows::core::GUID, pwszvalue: &mut [u16], pcchlength: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetString)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pwszvalue.as_ptr()), pwszvalue.len() as _, ::core::mem::transmute(pcchlength.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedString(&self, guidkey: *const ::windows::core::GUID, ppwszvalue: *mut ::windows::core::PWSTR, pcchlength: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedString)(::windows::core::Interface::as_raw(self), guidkey, ppwszvalue, pcchlength).ok()
    }
    pub unsafe fn GetBlobSize(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetBlobSize)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &mut [u8], pcbblobsize: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _, ::core::mem::transmute(pcbblobsize.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedBlob(&self, guidkey: *const ::windows::core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedBlob)(::windows::core::Interface::as_raw(self), guidkey, ppbuf, pcbsize).ok()
    }
    pub unsafe fn GetUnknown<T>(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.GetUnknown)(::windows::core::Interface::as_raw(self), guidkey, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetItem)(::windows::core::Interface::as_raw(self), guidkey, value).ok()
    }
    pub unsafe fn DeleteItem(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteItem)(::windows::core::Interface::as_raw(self), guidkey).ok()
    }
    pub unsafe fn DeleteAllItems(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteAllItems)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetUINT32(&self, guidkey: *const ::windows::core::GUID, unvalue: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT32)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetUINT64(&self, guidkey: *const ::windows::core::GUID, unvalue: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT64)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetDouble(&self, guidkey: *const ::windows::core::GUID, fvalue: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetDouble)(::windows::core::Interface::as_raw(self), guidkey, fvalue).ok()
    }
    pub unsafe fn SetGUID(&self, guidkey: *const ::windows::core::GUID, guidvalue: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetGUID)(::windows::core::Interface::as_raw(self), guidkey, guidvalue).ok()
    }
    pub unsafe fn SetString<P0>(&self, guidkey: *const ::windows::core::GUID, wszvalue: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.SetString)(::windows::core::Interface::as_raw(self), guidkey, wszvalue.into_param().abi()).ok()
    }
    pub unsafe fn SetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _).ok()
    }
    pub unsafe fn SetUnknown<P0>(&self, guidkey: *const ::windows::core::GUID, punknown: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.SetUnknown)(::windows::core::Interface::as_raw(self), guidkey, punknown.into_param().abi()).ok()
    }
    pub unsafe fn LockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.LockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn UnlockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.UnlockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItemByIndex(&self, unindex: u32, pguidkey: *mut ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItemByIndex)(::windows::core::Interface::as_raw(self), unindex, pguidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn CopyAllItems<P0>(&self, pdest: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).base__.CopyAllItems)(::windows::core::Interface::as_raw(self), pdest.into_param().abi()).ok()
    }
    pub unsafe fn GetTopologyID(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).GetTopologyID)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn AddNode<P0>(&self, pnode: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFTopologyNode>,
    {
        (::windows::core::Interface::vtable(self).AddNode)(::windows::core::Interface::as_raw(self), pnode.into_param().abi()).ok()
    }
    pub unsafe fn RemoveNode<P0>(&self, pnode: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFTopologyNode>,
    {
        (::windows::core::Interface::vtable(self).RemoveNode)(::windows::core::Interface::as_raw(self), pnode.into_param().abi()).ok()
    }
    pub unsafe fn GetNodeCount(&self) -> ::windows::core::Result<u16> {
        let mut result__ = ::windows::core::zeroed::<u16>();
        (::windows::core::Interface::vtable(self).GetNodeCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetNode(&self, windex: u16) -> ::windows::core::Result<IMFTopologyNode> {
        let mut result__ = ::windows::core::zeroed::<IMFTopologyNode>();
        (::windows::core::Interface::vtable(self).GetNode)(::windows::core::Interface::as_raw(self), windex, &mut result__).from_abi(result__)
    }
    pub unsafe fn Clear(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Clear)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn CloneFrom<P0>(&self, ptopology: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFTopology>,
    {
        (::windows::core::Interface::vtable(self).CloneFrom)(::windows::core::Interface::as_raw(self), ptopology.into_param().abi()).ok()
    }
    pub unsafe fn GetNodeByID(&self, qwtoponodeid: u64) -> ::windows::core::Result<IMFTopologyNode> {
        let mut result__ = ::windows::core::zeroed::<IMFTopologyNode>();
        (::windows::core::Interface::vtable(self).GetNodeByID)(::windows::core::Interface::as_raw(self), qwtoponodeid, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetSourceNodeCollection(&self) -> ::windows::core::Result<IMFCollection> {
        let mut result__ = ::windows::core::zeroed::<IMFCollection>();
        (::windows::core::Interface::vtable(self).GetSourceNodeCollection)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetOutputNodeCollection(&self) -> ::windows::core::Result<IMFCollection> {
        let mut result__ = ::windows::core::zeroed::<IMFCollection>();
        (::windows::core::Interface::vtable(self).GetOutputNodeCollection)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFTopology, ::windows::core::IUnknown, IMFAttributes);
impl ::core::cmp::PartialEq for IMFTopology {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTopology {}
impl ::core::fmt::Debug for IMFTopology {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTopology").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTopology {
    type Vtable = IMFTopology_Vtbl;
}
impl ::core::clone::Clone for IMFTopology {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTopology {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x83cf873a_f6da_4bc8_823f_bacfd55dc433);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTopology_Vtbl {
    pub base__: IMFAttributes_Vtbl,
    pub GetTopologyID: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pid: *mut u64) -> ::windows::core::HRESULT,
    pub AddNode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pnode: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RemoveNode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pnode: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetNodeCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pwnodes: *mut u16) -> ::windows::core::HRESULT,
    pub GetNode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, windex: u16, ppnode: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Clear: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub CloneFrom: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ptopology: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetNodeByID: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, qwtoponodeid: u64, ppnode: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetSourceNodeCollection: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppcollection: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetOutputNodeCollection: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppcollection: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTopologyNode(::windows::core::IUnknown);
impl IMFTopologyNode {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItem(&self, guidkey: *const ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItem)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetItemType(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<MF_ATTRIBUTE_TYPE> {
        let mut result__ = ::windows::core::zeroed::<MF_ATTRIBUTE_TYPE>();
        (::windows::core::Interface::vtable(self).base__.GetItemType)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn CompareItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.CompareItem)(::windows::core::Interface::as_raw(self), guidkey, value, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Compare<P0>(&self, ptheirs: P0, matchtype: MF_ATTRIBUTES_MATCH_TYPE) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.Compare)(::windows::core::Interface::as_raw(self), ptheirs.into_param().abi(), matchtype, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT32(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetUINT32)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT64(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).base__.GetUINT64)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDouble(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).base__.GetDouble)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetGUID(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).base__.GetGUID)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStringLength(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetStringLength)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetString(&self, guidkey: *const ::windows::core::GUID, pwszvalue: &mut [u16], pcchlength: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetString)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pwszvalue.as_ptr()), pwszvalue.len() as _, ::core::mem::transmute(pcchlength.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedString(&self, guidkey: *const ::windows::core::GUID, ppwszvalue: *mut ::windows::core::PWSTR, pcchlength: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedString)(::windows::core::Interface::as_raw(self), guidkey, ppwszvalue, pcchlength).ok()
    }
    pub unsafe fn GetBlobSize(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetBlobSize)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &mut [u8], pcbblobsize: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _, ::core::mem::transmute(pcbblobsize.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedBlob(&self, guidkey: *const ::windows::core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedBlob)(::windows::core::Interface::as_raw(self), guidkey, ppbuf, pcbsize).ok()
    }
    pub unsafe fn GetUnknown<T>(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.GetUnknown)(::windows::core::Interface::as_raw(self), guidkey, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetItem)(::windows::core::Interface::as_raw(self), guidkey, value).ok()
    }
    pub unsafe fn DeleteItem(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteItem)(::windows::core::Interface::as_raw(self), guidkey).ok()
    }
    pub unsafe fn DeleteAllItems(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteAllItems)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetUINT32(&self, guidkey: *const ::windows::core::GUID, unvalue: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT32)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetUINT64(&self, guidkey: *const ::windows::core::GUID, unvalue: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT64)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetDouble(&self, guidkey: *const ::windows::core::GUID, fvalue: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetDouble)(::windows::core::Interface::as_raw(self), guidkey, fvalue).ok()
    }
    pub unsafe fn SetGUID(&self, guidkey: *const ::windows::core::GUID, guidvalue: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetGUID)(::windows::core::Interface::as_raw(self), guidkey, guidvalue).ok()
    }
    pub unsafe fn SetString<P0>(&self, guidkey: *const ::windows::core::GUID, wszvalue: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.SetString)(::windows::core::Interface::as_raw(self), guidkey, wszvalue.into_param().abi()).ok()
    }
    pub unsafe fn SetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _).ok()
    }
    pub unsafe fn SetUnknown<P0>(&self, guidkey: *const ::windows::core::GUID, punknown: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.SetUnknown)(::windows::core::Interface::as_raw(self), guidkey, punknown.into_param().abi()).ok()
    }
    pub unsafe fn LockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.LockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn UnlockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.UnlockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItemByIndex(&self, unindex: u32, pguidkey: *mut ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItemByIndex)(::windows::core::Interface::as_raw(self), unindex, pguidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn CopyAllItems<P0>(&self, pdest: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).base__.CopyAllItems)(::windows::core::Interface::as_raw(self), pdest.into_param().abi()).ok()
    }
    pub unsafe fn SetObject<P0>(&self, pobject: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).SetObject)(::windows::core::Interface::as_raw(self), pobject.into_param().abi()).ok()
    }
    pub unsafe fn GetObject(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::IUnknown>();
        (::windows::core::Interface::vtable(self).GetObject)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetNodeType(&self) -> ::windows::core::Result<MF_TOPOLOGY_TYPE> {
        let mut result__ = ::windows::core::zeroed::<MF_TOPOLOGY_TYPE>();
        (::windows::core::Interface::vtable(self).GetNodeType)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetTopoNodeID(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).GetTopoNodeID)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetTopoNodeID(&self, ulltopoid: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetTopoNodeID)(::windows::core::Interface::as_raw(self), ulltopoid).ok()
    }
    pub unsafe fn GetInputCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetInputCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetOutputCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetOutputCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn ConnectOutput<P0>(&self, dwoutputindex: u32, pdownstreamnode: P0, dwinputindexondownstreamnode: u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFTopologyNode>,
    {
        (::windows::core::Interface::vtable(self).ConnectOutput)(::windows::core::Interface::as_raw(self), dwoutputindex, pdownstreamnode.into_param().abi(), dwinputindexondownstreamnode).ok()
    }
    pub unsafe fn DisconnectOutput(&self, dwoutputindex: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).DisconnectOutput)(::windows::core::Interface::as_raw(self), dwoutputindex).ok()
    }
    pub unsafe fn GetInput(&self, dwinputindex: u32, ppupstreamnode: *mut ::core::option::Option<IMFTopologyNode>, pdwoutputindexonupstreamnode: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetInput)(::windows::core::Interface::as_raw(self), dwinputindex, ::core::mem::transmute(ppupstreamnode), pdwoutputindexonupstreamnode).ok()
    }
    pub unsafe fn GetOutput(&self, dwoutputindex: u32, ppdownstreamnode: *mut ::core::option::Option<IMFTopologyNode>, pdwinputindexondownstreamnode: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetOutput)(::windows::core::Interface::as_raw(self), dwoutputindex, ::core::mem::transmute(ppdownstreamnode), pdwinputindexondownstreamnode).ok()
    }
    pub unsafe fn SetOutputPrefType<P0>(&self, dwoutputindex: u32, ptype: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        (::windows::core::Interface::vtable(self).SetOutputPrefType)(::windows::core::Interface::as_raw(self), dwoutputindex, ptype.into_param().abi()).ok()
    }
    pub unsafe fn GetOutputPrefType(&self, dwoutputindex: u32) -> ::windows::core::Result<IMFMediaType> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
        (::windows::core::Interface::vtable(self).GetOutputPrefType)(::windows::core::Interface::as_raw(self), dwoutputindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetInputPrefType<P0>(&self, dwinputindex: u32, ptype: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        (::windows::core::Interface::vtable(self).SetInputPrefType)(::windows::core::Interface::as_raw(self), dwinputindex, ptype.into_param().abi()).ok()
    }
    pub unsafe fn GetInputPrefType(&self, dwinputindex: u32) -> ::windows::core::Result<IMFMediaType> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
        (::windows::core::Interface::vtable(self).GetInputPrefType)(::windows::core::Interface::as_raw(self), dwinputindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn CloneFrom<P0>(&self, pnode: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFTopologyNode>,
    {
        (::windows::core::Interface::vtable(self).CloneFrom)(::windows::core::Interface::as_raw(self), pnode.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFTopologyNode, ::windows::core::IUnknown, IMFAttributes);
impl ::core::cmp::PartialEq for IMFTopologyNode {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTopologyNode {}
impl ::core::fmt::Debug for IMFTopologyNode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTopologyNode").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTopologyNode {
    type Vtable = IMFTopologyNode_Vtbl;
}
impl ::core::clone::Clone for IMFTopologyNode {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTopologyNode {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x83cf873a_f6da_4bc8_823f_bacfd55dc430);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTopologyNode_Vtbl {
    pub base__: IMFAttributes_Vtbl,
    pub SetObject: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pobject: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetObject: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetNodeType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ptype: *mut MF_TOPOLOGY_TYPE) -> ::windows::core::HRESULT,
    pub GetTopoNodeID: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pid: *mut u64) -> ::windows::core::HRESULT,
    pub SetTopoNodeID: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ulltopoid: u64) -> ::windows::core::HRESULT,
    pub GetInputCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcinputs: *mut u32) -> ::windows::core::HRESULT,
    pub GetOutputCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcoutputs: *mut u32) -> ::windows::core::HRESULT,
    pub ConnectOutput: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwoutputindex: u32, pdownstreamnode: *mut ::core::ffi::c_void, dwinputindexondownstreamnode: u32) -> ::windows::core::HRESULT,
    pub DisconnectOutput: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwoutputindex: u32) -> ::windows::core::HRESULT,
    pub GetInput: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwinputindex: u32, ppupstreamnode: *mut *mut ::core::ffi::c_void, pdwoutputindexonupstreamnode: *mut u32) -> ::windows::core::HRESULT,
    pub GetOutput: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwoutputindex: u32, ppdownstreamnode: *mut *mut ::core::ffi::c_void, pdwinputindexondownstreamnode: *mut u32) -> ::windows::core::HRESULT,
    pub SetOutputPrefType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwoutputindex: u32, ptype: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetOutputPrefType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwoutputindex: u32, pptype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetInputPrefType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwinputindex: u32, ptype: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetInputPrefType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwinputindex: u32, pptype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub CloneFrom: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pnode: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTopologyNodeAttributeEditor(::windows::core::IUnknown);
impl IMFTopologyNodeAttributeEditor {
    pub unsafe fn UpdateNodeAttributes(&self, topoid: u64, pupdates: &[MFTOPONODE_ATTRIBUTE_UPDATE]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).UpdateNodeAttributes)(::windows::core::Interface::as_raw(self), topoid, pupdates.len() as _, ::core::mem::transmute(pupdates.as_ptr())).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFTopologyNodeAttributeEditor, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTopologyNodeAttributeEditor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTopologyNodeAttributeEditor {}
impl ::core::fmt::Debug for IMFTopologyNodeAttributeEditor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTopologyNodeAttributeEditor").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTopologyNodeAttributeEditor {
    type Vtable = IMFTopologyNodeAttributeEditor_Vtbl;
}
impl ::core::clone::Clone for IMFTopologyNodeAttributeEditor {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTopologyNodeAttributeEditor {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x676aa6dd_238a_410d_bb99_65668d01605a);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTopologyNodeAttributeEditor_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub UpdateNodeAttributes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, topoid: u64, cupdates: u32, pupdates: *const MFTOPONODE_ATTRIBUTE_UPDATE) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTopologyServiceLookup(::windows::core::IUnknown);
impl IMFTopologyServiceLookup {
    pub unsafe fn LookupService(&self, r#type: MF_SERVICE_LOOKUP_TYPE, dwindex: u32, guidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobjects: *mut *mut ::core::ffi::c_void, pnobjects: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).LookupService)(::windows::core::Interface::as_raw(self), r#type, dwindex, guidservice, riid, ppvobjects, pnobjects).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFTopologyServiceLookup, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTopologyServiceLookup {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTopologyServiceLookup {}
impl ::core::fmt::Debug for IMFTopologyServiceLookup {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTopologyServiceLookup").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTopologyServiceLookup {
    type Vtable = IMFTopologyServiceLookup_Vtbl;
}
impl ::core::clone::Clone for IMFTopologyServiceLookup {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTopologyServiceLookup {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfa993889_4383_415a_a930_dd472a8cf6f7);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTopologyServiceLookup_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub LookupService: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, r#type: MF_SERVICE_LOOKUP_TYPE, dwindex: u32, guidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobjects: *mut *mut ::core::ffi::c_void, pnobjects: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTopologyServiceLookupClient(::windows::core::IUnknown);
impl IMFTopologyServiceLookupClient {
    pub unsafe fn InitServicePointers<P0>(&self, plookup: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFTopologyServiceLookup>,
    {
        (::windows::core::Interface::vtable(self).InitServicePointers)(::windows::core::Interface::as_raw(self), plookup.into_param().abi()).ok()
    }
    pub unsafe fn ReleaseServicePointers(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ReleaseServicePointers)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFTopologyServiceLookupClient, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTopologyServiceLookupClient {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTopologyServiceLookupClient {}
impl ::core::fmt::Debug for IMFTopologyServiceLookupClient {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTopologyServiceLookupClient").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTopologyServiceLookupClient {
    type Vtable = IMFTopologyServiceLookupClient_Vtbl;
}
impl ::core::clone::Clone for IMFTopologyServiceLookupClient {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTopologyServiceLookupClient {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfa99388a_4383_415a_a930_dd472a8cf6f7);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTopologyServiceLookupClient_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub InitServicePointers: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, plookup: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub ReleaseServicePointers: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTrackedSample(::windows::core::IUnknown);
impl IMFTrackedSample {
    pub unsafe fn SetAllocator<P0, P1>(&self, psampleallocator: P0, punkstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).SetAllocator)(::windows::core::Interface::as_raw(self), psampleallocator.into_param().abi(), punkstate.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFTrackedSample, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTrackedSample {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTrackedSample {}
impl ::core::fmt::Debug for IMFTrackedSample {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTrackedSample").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTrackedSample {
    type Vtable = IMFTrackedSample_Vtbl;
}
impl ::core::clone::Clone for IMFTrackedSample {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTrackedSample {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x245bf8e9_0755_40f7_88a5_ae0f18d55e17);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTrackedSample_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetAllocator: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, psampleallocator: *mut ::core::ffi::c_void, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTranscodeProfile(::windows::core::IUnknown);
impl IMFTranscodeProfile {
    pub unsafe fn SetAudioAttributes<P0>(&self, pattrs: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).SetAudioAttributes)(::windows::core::Interface::as_raw(self), pattrs.into_param().abi()).ok()
    }
    pub unsafe fn GetAudioAttributes(&self) -> ::windows::core::Result<IMFAttributes> {
        let mut result__ = ::windows::core::zeroed::<IMFAttributes>();
        (::windows::core::Interface::vtable(self).GetAudioAttributes)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetVideoAttributes<P0>(&self, pattrs: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).SetVideoAttributes)(::windows::core::Interface::as_raw(self), pattrs.into_param().abi()).ok()
    }
    pub unsafe fn GetVideoAttributes(&self) -> ::windows::core::Result<IMFAttributes> {
        let mut result__ = ::windows::core::zeroed::<IMFAttributes>();
        (::windows::core::Interface::vtable(self).GetVideoAttributes)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetContainerAttributes<P0>(&self, pattrs: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).SetContainerAttributes)(::windows::core::Interface::as_raw(self), pattrs.into_param().abi()).ok()
    }
    pub unsafe fn GetContainerAttributes(&self) -> ::windows::core::Result<IMFAttributes> {
        let mut result__ = ::windows::core::zeroed::<IMFAttributes>();
        (::windows::core::Interface::vtable(self).GetContainerAttributes)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFTranscodeProfile, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTranscodeProfile {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTranscodeProfile {}
impl ::core::fmt::Debug for IMFTranscodeProfile {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTranscodeProfile").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTranscodeProfile {
    type Vtable = IMFTranscodeProfile_Vtbl;
}
impl ::core::clone::Clone for IMFTranscodeProfile {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTranscodeProfile {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4adfdba3_7ab0_4953_a62b_461e7ff3da1e);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTranscodeProfile_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetAudioAttributes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pattrs: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetAudioAttributes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppattrs: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetVideoAttributes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pattrs: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetVideoAttributes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppattrs: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetContainerAttributes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pattrs: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetContainerAttributes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppattrs: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTranscodeSinkInfoProvider(::windows::core::IUnknown);
impl IMFTranscodeSinkInfoProvider {
    pub unsafe fn SetOutputFile<P0>(&self, pwszfilename: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).SetOutputFile)(::windows::core::Interface::as_raw(self), pwszfilename.into_param().abi()).ok()
    }
    pub unsafe fn SetOutputByteStream<P0>(&self, pbytestreamactivate: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFActivate>,
    {
        (::windows::core::Interface::vtable(self).SetOutputByteStream)(::windows::core::Interface::as_raw(self), pbytestreamactivate.into_param().abi()).ok()
    }
    pub unsafe fn SetProfile<P0>(&self, pprofile: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFTranscodeProfile>,
    {
        (::windows::core::Interface::vtable(self).SetProfile)(::windows::core::Interface::as_raw(self), pprofile.into_param().abi()).ok()
    }
    pub unsafe fn GetSinkInfo(&self) -> ::windows::core::Result<MF_TRANSCODE_SINK_INFO> {
        let mut result__ = ::windows::core::zeroed::<MF_TRANSCODE_SINK_INFO>();
        (::windows::core::Interface::vtable(self).GetSinkInfo)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFTranscodeSinkInfoProvider, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTranscodeSinkInfoProvider {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTranscodeSinkInfoProvider {}
impl ::core::fmt::Debug for IMFTranscodeSinkInfoProvider {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTranscodeSinkInfoProvider").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTranscodeSinkInfoProvider {
    type Vtable = IMFTranscodeSinkInfoProvider_Vtbl;
}
impl ::core::clone::Clone for IMFTranscodeSinkInfoProvider {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTranscodeSinkInfoProvider {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8cffcd2e_5a03_4a3a_aff7_edcd107c620e);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTranscodeSinkInfoProvider_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetOutputFile: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pwszfilename: ::windows::core::PCWSTR) -> ::windows::core::HRESULT,
    pub SetOutputByteStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbytestreamactivate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetProfile: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pprofile: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetSinkInfo: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, psinkinfo: *mut MF_TRANSCODE_SINK_INFO) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTransform(::windows::core::IUnknown);
impl IMFTransform {
    pub unsafe fn GetStreamLimits(&self, pdwinputminimum: *mut u32, pdwinputmaximum: *mut u32, pdwoutputminimum: *mut u32, pdwoutputmaximum: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetStreamLimits)(::windows::core::Interface::as_raw(self), pdwinputminimum, pdwinputmaximum, pdwoutputminimum, pdwoutputmaximum).ok()
    }
    pub unsafe fn GetStreamCount(&self, pcinputstreams: *mut u32, pcoutputstreams: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetStreamCount)(::windows::core::Interface::as_raw(self), pcinputstreams, pcoutputstreams).ok()
    }
    pub unsafe fn GetStreamIDs(&self, pdwinputids: &mut [u32], pdwoutputids: &mut [u32]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetStreamIDs)(::windows::core::Interface::as_raw(self), pdwinputids.len() as _, ::core::mem::transmute(pdwinputids.as_ptr()), pdwoutputids.len() as _, ::core::mem::transmute(pdwoutputids.as_ptr())).ok()
    }
    pub unsafe fn GetInputStreamInfo(&self, dwinputstreamid: u32, pstreaminfo: *mut MFT_INPUT_STREAM_INFO) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetInputStreamInfo)(::windows::core::Interface::as_raw(self), dwinputstreamid, pstreaminfo).ok()
    }
    pub unsafe fn GetOutputStreamInfo(&self, dwoutputstreamid: u32) -> ::windows::core::Result<MFT_OUTPUT_STREAM_INFO> {
        let mut result__ = ::windows::core::zeroed::<MFT_OUTPUT_STREAM_INFO>();
        (::windows::core::Interface::vtable(self).GetOutputStreamInfo)(::windows::core::Interface::as_raw(self), dwoutputstreamid, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetAttributes(&self) -> ::windows::core::Result<IMFAttributes> {
        let mut result__ = ::windows::core::zeroed::<IMFAttributes>();
        (::windows::core::Interface::vtable(self).GetAttributes)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetInputStreamAttributes(&self, dwinputstreamid: u32) -> ::windows::core::Result<IMFAttributes> {
        let mut result__ = ::windows::core::zeroed::<IMFAttributes>();
        (::windows::core::Interface::vtable(self).GetInputStreamAttributes)(::windows::core::Interface::as_raw(self), dwinputstreamid, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetOutputStreamAttributes(&self, dwoutputstreamid: u32) -> ::windows::core::Result<IMFAttributes> {
        let mut result__ = ::windows::core::zeroed::<IMFAttributes>();
        (::windows::core::Interface::vtable(self).GetOutputStreamAttributes)(::windows::core::Interface::as_raw(self), dwoutputstreamid, &mut result__).from_abi(result__)
    }
    pub unsafe fn DeleteInputStream(&self, dwstreamid: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).DeleteInputStream)(::windows::core::Interface::as_raw(self), dwstreamid).ok()
    }
    pub unsafe fn AddInputStreams(&self, cstreams: u32, adwstreamids: *const u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).AddInputStreams)(::windows::core::Interface::as_raw(self), cstreams, adwstreamids).ok()
    }
    pub unsafe fn GetInputAvailableType(&self, dwinputstreamid: u32, dwtypeindex: u32) -> ::windows::core::Result<IMFMediaType> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
        (::windows::core::Interface::vtable(self).GetInputAvailableType)(::windows::core::Interface::as_raw(self), dwinputstreamid, dwtypeindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetOutputAvailableType(&self, dwoutputstreamid: u32, dwtypeindex: u32) -> ::windows::core::Result<IMFMediaType> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
        (::windows::core::Interface::vtable(self).GetOutputAvailableType)(::windows::core::Interface::as_raw(self), dwoutputstreamid, dwtypeindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetInputType<P0>(&self, dwinputstreamid: u32, ptype: P0, dwflags: u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        (::windows::core::Interface::vtable(self).SetInputType)(::windows::core::Interface::as_raw(self), dwinputstreamid, ptype.into_param().abi(), dwflags).ok()
    }
    pub unsafe fn SetOutputType<P0>(&self, dwoutputstreamid: u32, ptype: P0, dwflags: u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        (::windows::core::Interface::vtable(self).SetOutputType)(::windows::core::Interface::as_raw(self), dwoutputstreamid, ptype.into_param().abi(), dwflags).ok()
    }
    pub unsafe fn GetInputCurrentType(&self, dwinputstreamid: u32) -> ::windows::core::Result<IMFMediaType> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
        (::windows::core::Interface::vtable(self).GetInputCurrentType)(::windows::core::Interface::as_raw(self), dwinputstreamid, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetOutputCurrentType(&self, dwoutputstreamid: u32) -> ::windows::core::Result<IMFMediaType> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
        (::windows::core::Interface::vtable(self).GetOutputCurrentType)(::windows::core::Interface::as_raw(self), dwoutputstreamid, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetInputStatus(&self, dwinputstreamid: u32) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetInputStatus)(::windows::core::Interface::as_raw(self), dwinputstreamid, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetOutputStatus(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetOutputStatus)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetOutputBounds(&self, hnslowerbound: i64, hnsupperbound: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetOutputBounds)(::windows::core::Interface::as_raw(self), hnslowerbound, hnsupperbound).ok()
    }
    pub unsafe fn ProcessEvent<P0>(&self, dwinputstreamid: u32, pevent: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaEvent>,
    {
        (::windows::core::Interface::vtable(self).ProcessEvent)(::windows::core::Interface::as_raw(self), dwinputstreamid, pevent.into_param().abi()).ok()
    }
    pub unsafe fn ProcessMessage(&self, emessage: MFT_MESSAGE_TYPE, ulparam: usize) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ProcessMessage)(::windows::core::Interface::as_raw(self), emessage, ulparam).ok()
    }
    pub unsafe fn ProcessInput<P0>(&self, dwinputstreamid: u32, psample: P0, dwflags: u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFSample>,
    {
        (::windows::core::Interface::vtable(self).ProcessInput)(::windows::core::Interface::as_raw(self), dwinputstreamid, psample.into_param().abi(), dwflags).ok()
    }
    pub unsafe fn ProcessOutput(&self, dwflags: u32, poutputsamples: &mut [MFT_OUTPUT_DATA_BUFFER], pdwstatus: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ProcessOutput)(::windows::core::Interface::as_raw(self), dwflags, poutputsamples.len() as _, ::core::mem::transmute(poutputsamples.as_ptr()), pdwstatus).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFTransform, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTransform {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTransform {}
impl ::core::fmt::Debug for IMFTransform {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTransform").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTransform {
    type Vtable = IMFTransform_Vtbl;
}
impl ::core::clone::Clone for IMFTransform {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTransform {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbf94c121_5b05_4e6f_8000_ba598961414d);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTransform_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetStreamLimits: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwinputminimum: *mut u32, pdwinputmaximum: *mut u32, pdwoutputminimum: *mut u32, pdwoutputmaximum: *mut u32) -> ::windows::core::HRESULT,
    pub GetStreamCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcinputstreams: *mut u32, pcoutputstreams: *mut u32) -> ::windows::core::HRESULT,
    pub GetStreamIDs: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwinputidarraysize: u32, pdwinputids: *mut u32, dwoutputidarraysize: u32, pdwoutputids: *mut u32) -> ::windows::core::HRESULT,
    pub GetInputStreamInfo: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, pstreaminfo: *mut MFT_INPUT_STREAM_INFO) -> ::windows::core::HRESULT,
    pub GetOutputStreamInfo: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, pstreaminfo: *mut MFT_OUTPUT_STREAM_INFO) -> ::windows::core::HRESULT,
    pub GetAttributes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pattributes: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetInputStreamAttributes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, pattributes: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetOutputStreamAttributes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, pattributes: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub DeleteInputStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamid: u32) -> ::windows::core::HRESULT,
    pub AddInputStreams: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cstreams: u32, adwstreamids: *const u32) -> ::windows::core::HRESULT,
    pub GetInputAvailableType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, dwtypeindex: u32, pptype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetOutputAvailableType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, dwtypeindex: u32, pptype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetInputType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, ptype: *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::HRESULT,
    pub SetOutputType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, ptype: *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::HRESULT,
    pub GetInputCurrentType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, pptype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetOutputCurrentType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, pptype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetInputStatus: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, pdwflags: *mut u32) -> ::windows::core::HRESULT,
    pub GetOutputStatus: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwflags: *mut u32) -> ::windows::core::HRESULT,
    pub SetOutputBounds: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hnslowerbound: i64, hnsupperbound: i64) -> ::windows::core::HRESULT,
    pub ProcessEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, pevent: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub ProcessMessage: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, emessage: MFT_MESSAGE_TYPE, ulparam: usize) -> ::windows::core::HRESULT,
    pub ProcessInput: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, psample: *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::HRESULT,
    pub ProcessOutput: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwflags: u32, coutputbuffercount: u32, poutputsamples: *mut MFT_OUTPUT_DATA_BUFFER, pdwstatus: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTrustedInput(::windows::core::IUnknown);
impl IMFTrustedInput {
    pub unsafe fn GetInputTrustAuthority(&self, dwstreamid: u32, riid: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::IUnknown>();
        (::windows::core::Interface::vtable(self).GetInputTrustAuthority)(::windows::core::Interface::as_raw(self), dwstreamid, riid, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFTrustedInput, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTrustedInput {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTrustedInput {}
impl ::core::fmt::Debug for IMFTrustedInput {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTrustedInput").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTrustedInput {
    type Vtable = IMFTrustedInput_Vtbl;
}
impl ::core::clone::Clone for IMFTrustedInput {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTrustedInput {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x542612c4_a1b8_4632_b521_de11ea64a0b0);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTrustedInput_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetInputTrustAuthority: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamid: u32, riid: *const ::windows::core::GUID, ppunkobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFTrustedOutput(::windows::core::IUnknown);
impl IMFTrustedOutput {
    pub unsafe fn GetOutputTrustAuthorityCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetOutputTrustAuthorityCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetOutputTrustAuthorityByIndex(&self, dwindex: u32) -> ::windows::core::Result<IMFOutputTrustAuthority> {
        let mut result__ = ::windows::core::zeroed::<IMFOutputTrustAuthority>();
        (::windows::core::Interface::vtable(self).GetOutputTrustAuthorityByIndex)(::windows::core::Interface::as_raw(self), dwindex, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsFinal(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).IsFinal)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFTrustedOutput, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFTrustedOutput {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFTrustedOutput {}
impl ::core::fmt::Debug for IMFTrustedOutput {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFTrustedOutput").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFTrustedOutput {
    type Vtable = IMFTrustedOutput_Vtbl;
}
impl ::core::clone::Clone for IMFTrustedOutput {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFTrustedOutput {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd19f8e95_b126_4446_890c_5dcb7ad71453);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFTrustedOutput_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetOutputTrustAuthorityCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcoutputtrustauthorities: *mut u32) -> ::windows::core::HRESULT,
    pub GetOutputTrustAuthorityByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwindex: u32, ppauthority: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub IsFinal: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pfisfinal: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    IsFinal: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFVideoCaptureSampleAllocator(::windows::core::IUnknown);
impl IMFVideoCaptureSampleAllocator {
    pub unsafe fn SetDirectXManager<P0>(&self, pmanager: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.SetDirectXManager)(::windows::core::Interface::as_raw(self), pmanager.into_param().abi()).ok()
    }
    pub unsafe fn UninitializeSampleAllocator(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.UninitializeSampleAllocator)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn InitializeSampleAllocator<P0>(&self, crequestedframes: u32, pmediatype: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        (::windows::core::Interface::vtable(self).base__.InitializeSampleAllocator)(::windows::core::Interface::as_raw(self), crequestedframes, pmediatype.into_param().abi()).ok()
    }
    pub unsafe fn AllocateSample(&self) -> ::windows::core::Result<IMFSample> {
        let mut result__ = ::windows::core::zeroed::<IMFSample>();
        (::windows::core::Interface::vtable(self).base__.AllocateSample)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn InitializeCaptureSampleAllocator<P0, P1>(&self, cbsamplesize: u32, cbcapturemetadatasize: u32, cbalignment: u32, cminimumsamples: u32, pattributes: P0, pmediatype: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
        P1: ::windows::core::IntoParam<IMFMediaType>,
    {
        (::windows::core::Interface::vtable(self).InitializeCaptureSampleAllocator)(::windows::core::Interface::as_raw(self), cbsamplesize, cbcapturemetadatasize, cbalignment, cminimumsamples, pattributes.into_param().abi(), pmediatype.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFVideoCaptureSampleAllocator, ::windows::core::IUnknown, IMFVideoSampleAllocator);
impl ::core::cmp::PartialEq for IMFVideoCaptureSampleAllocator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFVideoCaptureSampleAllocator {}
impl ::core::fmt::Debug for IMFVideoCaptureSampleAllocator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFVideoCaptureSampleAllocator").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFVideoCaptureSampleAllocator {
    type Vtable = IMFVideoCaptureSampleAllocator_Vtbl;
}
impl ::core::clone::Clone for IMFVideoCaptureSampleAllocator {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFVideoCaptureSampleAllocator {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x725b77c7_ca9f_4fe5_9d72_9946bf9b3c70);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFVideoCaptureSampleAllocator_Vtbl {
    pub base__: IMFVideoSampleAllocator_Vtbl,
    pub InitializeCaptureSampleAllocator: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cbsamplesize: u32, cbcapturemetadatasize: u32, cbalignment: u32, cminimumsamples: u32, pattributes: *mut ::core::ffi::c_void, pmediatype: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFVideoDeviceID(::windows::core::IUnknown);
impl IMFVideoDeviceID {
    pub unsafe fn GetDeviceID(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).GetDeviceID)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFVideoDeviceID, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFVideoDeviceID {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFVideoDeviceID {}
impl ::core::fmt::Debug for IMFVideoDeviceID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFVideoDeviceID").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFVideoDeviceID {
    type Vtable = IMFVideoDeviceID_Vtbl;
}
impl ::core::clone::Clone for IMFVideoDeviceID {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFVideoDeviceID {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa38d9567_5a9c_4f3c_b293_8eb415b279ba);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFVideoDeviceID_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetDeviceID: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdeviceid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFVideoDisplayControl(::windows::core::IUnknown);
impl IMFVideoDisplayControl {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetNativeVideoSize(&self, pszvideo: *mut super::super::Foundation::SIZE, pszarvideo: *mut super::super::Foundation::SIZE) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetNativeVideoSize)(::windows::core::Interface::as_raw(self), pszvideo, pszarvideo).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetIdealVideoSize(&self, pszmin: *mut super::super::Foundation::SIZE, pszmax: *mut super::super::Foundation::SIZE) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetIdealVideoSize)(::windows::core::Interface::as_raw(self), pszmin, pszmax).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetVideoPosition(&self, pnrcsource: *const MFVideoNormalizedRect, prcdest: *const super::super::Foundation::RECT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetVideoPosition)(::windows::core::Interface::as_raw(self), pnrcsource, prcdest).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetVideoPosition(&self, pnrcsource: *mut MFVideoNormalizedRect, prcdest: *mut super::super::Foundation::RECT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetVideoPosition)(::windows::core::Interface::as_raw(self), pnrcsource, prcdest).ok()
    }
    pub unsafe fn SetAspectRatioMode(&self, dwaspectratiomode: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetAspectRatioMode)(::windows::core::Interface::as_raw(self), dwaspectratiomode).ok()
    }
    pub unsafe fn GetAspectRatioMode(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetAspectRatioMode)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetVideoWindow<P0>(&self, hwndvideo: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::HWND>,
    {
        (::windows::core::Interface::vtable(self).SetVideoWindow)(::windows::core::Interface::as_raw(self), hwndvideo.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetVideoWindow(&self) -> ::windows::core::Result<super::super::Foundation::HWND> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::HWND>();
        (::windows::core::Interface::vtable(self).GetVideoWindow)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn RepaintVideo(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RepaintVideo)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Gdi\"`*"]
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub unsafe fn GetCurrentImage(&self, pbih: *mut super::super::Graphics::Gdi::BITMAPINFOHEADER, pdib: *mut *mut u8, pcbdib: *mut u32, ptimestamp: *mut i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetCurrentImage)(::windows::core::Interface::as_raw(self), pbih, pdib, pcbdib, ptimestamp).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetBorderColor<P0>(&self, clr: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::COLORREF>,
    {
        (::windows::core::Interface::vtable(self).SetBorderColor)(::windows::core::Interface::as_raw(self), clr.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetBorderColor(&self) -> ::windows::core::Result<super::super::Foundation::COLORREF> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::COLORREF>();
        (::windows::core::Interface::vtable(self).GetBorderColor)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetRenderingPrefs(&self, dwrenderflags: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetRenderingPrefs)(::windows::core::Interface::as_raw(self), dwrenderflags).ok()
    }
    pub unsafe fn GetRenderingPrefs(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetRenderingPrefs)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetFullscreen<P0>(&self, ffullscreen: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetFullscreen)(::windows::core::Interface::as_raw(self), ffullscreen.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetFullscreen(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).GetFullscreen)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFVideoDisplayControl, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFVideoDisplayControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFVideoDisplayControl {}
impl ::core::fmt::Debug for IMFVideoDisplayControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFVideoDisplayControl").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFVideoDisplayControl {
    type Vtable = IMFVideoDisplayControl_Vtbl;
}
impl ::core::clone::Clone for IMFVideoDisplayControl {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFVideoDisplayControl {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa490b1e4_ab84_4d31_a1b2_181e03b1077a);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFVideoDisplayControl_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub GetNativeVideoSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pszvideo: *mut super::super::Foundation::SIZE, pszarvideo: *mut super::super::Foundation::SIZE) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetNativeVideoSize: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub GetIdealVideoSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pszmin: *mut super::super::Foundation::SIZE, pszmax: *mut super::super::Foundation::SIZE) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetIdealVideoSize: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub SetVideoPosition: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pnrcsource: *const MFVideoNormalizedRect, prcdest: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetVideoPosition: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub GetVideoPosition: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pnrcsource: *mut MFVideoNormalizedRect, prcdest: *mut super::super::Foundation::RECT) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetVideoPosition: usize,
    pub SetAspectRatioMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwaspectratiomode: u32) -> ::windows::core::HRESULT,
    pub GetAspectRatioMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwaspectratiomode: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub SetVideoWindow: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, hwndvideo: super::super::Foundation::HWND) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetVideoWindow: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub GetVideoWindow: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, phwndvideo: *mut super::super::Foundation::HWND) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetVideoWindow: usize,
    pub RepaintVideo: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Gdi")]
    pub GetCurrentImage: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbih: *mut super::super::Graphics::Gdi::BITMAPINFOHEADER, pdib: *mut *mut u8, pcbdib: *mut u32, ptimestamp: *mut i64) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Gdi"))]
    GetCurrentImage: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub SetBorderColor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, clr: super::super::Foundation::COLORREF) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetBorderColor: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub GetBorderColor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pclr: *mut super::super::Foundation::COLORREF) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetBorderColor: usize,
    pub SetRenderingPrefs: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwrenderflags: u32) -> ::windows::core::HRESULT,
    pub GetRenderingPrefs: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwrenderflags: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub SetFullscreen: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ffullscreen: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetFullscreen: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub GetFullscreen: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pffullscreen: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetFullscreen: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFVideoMediaType(::windows::core::IUnknown);
impl IMFVideoMediaType {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItem(&self, guidkey: *const ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.GetItem)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetItemType(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<MF_ATTRIBUTE_TYPE> {
        let mut result__ = ::windows::core::zeroed::<MF_ATTRIBUTE_TYPE>();
        (::windows::core::Interface::vtable(self).base__.base__.GetItemType)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn CompareItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.base__.CompareItem)(::windows::core::Interface::as_raw(self), guidkey, value, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Compare<P0>(&self, ptheirs: P0, matchtype: MF_ATTRIBUTES_MATCH_TYPE) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.base__.Compare)(::windows::core::Interface::as_raw(self), ptheirs.into_param().abi(), matchtype, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT32(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.base__.GetUINT32)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT64(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).base__.base__.GetUINT64)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDouble(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).base__.base__.GetDouble)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetGUID(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).base__.base__.GetGUID)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStringLength(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.base__.GetStringLength)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetString(&self, guidkey: *const ::windows::core::GUID, pwszvalue: &mut [u16], pcchlength: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.GetString)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pwszvalue.as_ptr()), pwszvalue.len() as _, ::core::mem::transmute(pcchlength.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedString(&self, guidkey: *const ::windows::core::GUID, ppwszvalue: *mut ::windows::core::PWSTR, pcchlength: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.GetAllocatedString)(::windows::core::Interface::as_raw(self), guidkey, ppwszvalue, pcchlength).ok()
    }
    pub unsafe fn GetBlobSize(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.base__.GetBlobSize)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &mut [u8], pcbblobsize: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.GetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _, ::core::mem::transmute(pcbblobsize.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedBlob(&self, guidkey: *const ::windows::core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.GetAllocatedBlob)(::windows::core::Interface::as_raw(self), guidkey, ppbuf, pcbsize).ok()
    }
    pub unsafe fn GetUnknown<T>(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.base__.GetUnknown)(::windows::core::Interface::as_raw(self), guidkey, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetItem)(::windows::core::Interface::as_raw(self), guidkey, value).ok()
    }
    pub unsafe fn DeleteItem(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.DeleteItem)(::windows::core::Interface::as_raw(self), guidkey).ok()
    }
    pub unsafe fn DeleteAllItems(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.DeleteAllItems)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetUINT32(&self, guidkey: *const ::windows::core::GUID, unvalue: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetUINT32)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetUINT64(&self, guidkey: *const ::windows::core::GUID, unvalue: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetUINT64)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetDouble(&self, guidkey: *const ::windows::core::GUID, fvalue: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetDouble)(::windows::core::Interface::as_raw(self), guidkey, fvalue).ok()
    }
    pub unsafe fn SetGUID(&self, guidkey: *const ::windows::core::GUID, guidvalue: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetGUID)(::windows::core::Interface::as_raw(self), guidkey, guidvalue).ok()
    }
    pub unsafe fn SetString<P0>(&self, guidkey: *const ::windows::core::GUID, wszvalue: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.SetString)(::windows::core::Interface::as_raw(self), guidkey, wszvalue.into_param().abi()).ok()
    }
    pub unsafe fn SetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _).ok()
    }
    pub unsafe fn SetUnknown<P0>(&self, guidkey: *const ::windows::core::GUID, punknown: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.SetUnknown)(::windows::core::Interface::as_raw(self), guidkey, punknown.into_param().abi()).ok()
    }
    pub unsafe fn LockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.LockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn UnlockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.UnlockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.base__.GetCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItemByIndex(&self, unindex: u32, pguidkey: *mut ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.GetItemByIndex)(::windows::core::Interface::as_raw(self), unindex, pguidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn CopyAllItems<P0>(&self, pdest: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.CopyAllItems)(::windows::core::Interface::as_raw(self), pdest.into_param().abi()).ok()
    }
    pub unsafe fn GetMajorType(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).base__.GetMajorType)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn IsCompressedFormat(&self) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.IsCompressedFormat)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn IsEqual<P0>(&self, pimediatype: P0) -> ::windows::core::Result<u32>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.IsEqual)(::windows::core::Interface::as_raw(self), pimediatype.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetRepresentation(&self, guidrepresentation: ::windows::core::GUID, ppvrepresentation: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetRepresentation)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(guidrepresentation), ppvrepresentation).ok()
    }
    pub unsafe fn FreeRepresentation(&self, guidrepresentation: ::windows::core::GUID, pvrepresentation: *const ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.FreeRepresentation)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(guidrepresentation), pvrepresentation).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetVideoFormat(&self) -> *mut MFVIDEOFORMAT {
        (::windows::core::Interface::vtable(self).GetVideoFormat)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetVideoRepresentation(&self, guidrepresentation: ::windows::core::GUID, ppvrepresentation: *mut *mut ::core::ffi::c_void, lstride: i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetVideoRepresentation)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(guidrepresentation), ppvrepresentation, lstride).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFVideoMediaType, ::windows::core::IUnknown, IMFAttributes, IMFMediaType);
impl ::core::cmp::PartialEq for IMFVideoMediaType {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFVideoMediaType {}
impl ::core::fmt::Debug for IMFVideoMediaType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFVideoMediaType").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFVideoMediaType {
    type Vtable = IMFVideoMediaType_Vtbl;
}
impl ::core::clone::Clone for IMFVideoMediaType {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFVideoMediaType {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb99f381f_a8f9_47a2_a5af_ca3a225a3890);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFVideoMediaType_Vtbl {
    pub base__: IMFMediaType_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub GetVideoFormat: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> *mut MFVIDEOFORMAT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetVideoFormat: usize,
    pub GetVideoRepresentation: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidrepresentation: ::windows::core::GUID, ppvrepresentation: *mut *mut ::core::ffi::c_void, lstride: i32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFVideoMixerBitmap(::windows::core::IUnknown);
impl IMFVideoMixerBitmap {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`, `\"Win32_Graphics_Gdi\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
    pub unsafe fn SetAlphaBitmap(&self, pbmpparms: *const MFVideoAlphaBitmap) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetAlphaBitmap)(::windows::core::Interface::as_raw(self), pbmpparms).ok()
    }
    pub unsafe fn ClearAlphaBitmap(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ClearAlphaBitmap)(::windows::core::Interface::as_raw(self)).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn UpdateAlphaBitmapParameters(&self, pbmpparms: *const MFVideoAlphaBitmapParams) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).UpdateAlphaBitmapParameters)(::windows::core::Interface::as_raw(self), pbmpparms).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetAlphaBitmapParameters(&self, pbmpparms: *mut MFVideoAlphaBitmapParams) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetAlphaBitmapParameters)(::windows::core::Interface::as_raw(self), pbmpparms).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFVideoMixerBitmap, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFVideoMixerBitmap {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFVideoMixerBitmap {}
impl ::core::fmt::Debug for IMFVideoMixerBitmap {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFVideoMixerBitmap").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFVideoMixerBitmap {
    type Vtable = IMFVideoMixerBitmap_Vtbl;
}
impl ::core::clone::Clone for IMFVideoMixerBitmap {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFVideoMixerBitmap {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x814c7b20_0fdb_4eec_af8f_f957c8f69edc);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFVideoMixerBitmap_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
    pub SetAlphaBitmap: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbmpparms: *const MFVideoAlphaBitmap) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi")))]
    SetAlphaBitmap: usize,
    pub ClearAlphaBitmap: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub UpdateAlphaBitmapParameters: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbmpparms: *const MFVideoAlphaBitmapParams) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    UpdateAlphaBitmapParameters: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub GetAlphaBitmapParameters: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbmpparms: *mut MFVideoAlphaBitmapParams) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetAlphaBitmapParameters: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFVideoMixerControl(::windows::core::IUnknown);
impl IMFVideoMixerControl {
    pub unsafe fn SetStreamZOrder(&self, dwstreamid: u32, dwz: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetStreamZOrder)(::windows::core::Interface::as_raw(self), dwstreamid, dwz).ok()
    }
    pub unsafe fn GetStreamZOrder(&self, dwstreamid: u32) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetStreamZOrder)(::windows::core::Interface::as_raw(self), dwstreamid, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetStreamOutputRect(&self, dwstreamid: u32, pnrcoutput: *const MFVideoNormalizedRect) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetStreamOutputRect)(::windows::core::Interface::as_raw(self), dwstreamid, pnrcoutput).ok()
    }
    pub unsafe fn GetStreamOutputRect(&self, dwstreamid: u32) -> ::windows::core::Result<MFVideoNormalizedRect> {
        let mut result__ = ::windows::core::zeroed::<MFVideoNormalizedRect>();
        (::windows::core::Interface::vtable(self).GetStreamOutputRect)(::windows::core::Interface::as_raw(self), dwstreamid, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFVideoMixerControl, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFVideoMixerControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFVideoMixerControl {}
impl ::core::fmt::Debug for IMFVideoMixerControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFVideoMixerControl").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFVideoMixerControl {
    type Vtable = IMFVideoMixerControl_Vtbl;
}
impl ::core::clone::Clone for IMFVideoMixerControl {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFVideoMixerControl {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa5c6c53f_c202_4aa5_9695_175ba8c508a5);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFVideoMixerControl_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetStreamZOrder: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamid: u32, dwz: u32) -> ::windows::core::HRESULT,
    pub GetStreamZOrder: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamid: u32, pdwz: *mut u32) -> ::windows::core::HRESULT,
    pub SetStreamOutputRect: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamid: u32, pnrcoutput: *const MFVideoNormalizedRect) -> ::windows::core::HRESULT,
    pub GetStreamOutputRect: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwstreamid: u32, pnrcoutput: *mut MFVideoNormalizedRect) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFVideoMixerControl2(::windows::core::IUnknown);
impl IMFVideoMixerControl2 {
    pub unsafe fn SetStreamZOrder(&self, dwstreamid: u32, dwz: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetStreamZOrder)(::windows::core::Interface::as_raw(self), dwstreamid, dwz).ok()
    }
    pub unsafe fn GetStreamZOrder(&self, dwstreamid: u32) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetStreamZOrder)(::windows::core::Interface::as_raw(self), dwstreamid, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetStreamOutputRect(&self, dwstreamid: u32, pnrcoutput: *const MFVideoNormalizedRect) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetStreamOutputRect)(::windows::core::Interface::as_raw(self), dwstreamid, pnrcoutput).ok()
    }
    pub unsafe fn GetStreamOutputRect(&self, dwstreamid: u32) -> ::windows::core::Result<MFVideoNormalizedRect> {
        let mut result__ = ::windows::core::zeroed::<MFVideoNormalizedRect>();
        (::windows::core::Interface::vtable(self).base__.GetStreamOutputRect)(::windows::core::Interface::as_raw(self), dwstreamid, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetMixingPrefs(&self, dwmixflags: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetMixingPrefs)(::windows::core::Interface::as_raw(self), dwmixflags).ok()
    }
    pub unsafe fn GetMixingPrefs(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetMixingPrefs)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFVideoMixerControl2, ::windows::core::IUnknown, IMFVideoMixerControl);
impl ::core::cmp::PartialEq for IMFVideoMixerControl2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFVideoMixerControl2 {}
impl ::core::fmt::Debug for IMFVideoMixerControl2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFVideoMixerControl2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFVideoMixerControl2 {
    type Vtable = IMFVideoMixerControl2_Vtbl;
}
impl ::core::clone::Clone for IMFVideoMixerControl2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFVideoMixerControl2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8459616d_966e_4930_b658_54fa7e5a16d3);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFVideoMixerControl2_Vtbl {
    pub base__: IMFVideoMixerControl_Vtbl,
    pub SetMixingPrefs: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwmixflags: u32) -> ::windows::core::HRESULT,
    pub GetMixingPrefs: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwmixflags: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFVideoPositionMapper(::windows::core::IUnknown);
impl IMFVideoPositionMapper {
    pub unsafe fn MapOutputCoordinateToInputStream(&self, xout: f32, yout: f32, dwoutputstreamindex: u32, dwinputstreamindex: u32, pxin: *mut f32, pyin: *mut f32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).MapOutputCoordinateToInputStream)(::windows::core::Interface::as_raw(self), xout, yout, dwoutputstreamindex, dwinputstreamindex, pxin, pyin).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFVideoPositionMapper, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFVideoPositionMapper {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFVideoPositionMapper {}
impl ::core::fmt::Debug for IMFVideoPositionMapper {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFVideoPositionMapper").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFVideoPositionMapper {
    type Vtable = IMFVideoPositionMapper_Vtbl;
}
impl ::core::clone::Clone for IMFVideoPositionMapper {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFVideoPositionMapper {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1f6a9f17_e70b_4e24_8ae4_0b2c3ba7a4ae);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFVideoPositionMapper_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub MapOutputCoordinateToInputStream: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, xout: f32, yout: f32, dwoutputstreamindex: u32, dwinputstreamindex: u32, pxin: *mut f32, pyin: *mut f32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFVideoPresenter(::windows::core::IUnknown);
impl IMFVideoPresenter {
    pub unsafe fn OnClockStart(&self, hnssystemtime: i64, llclockstartoffset: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.OnClockStart)(::windows::core::Interface::as_raw(self), hnssystemtime, llclockstartoffset).ok()
    }
    pub unsafe fn OnClockStop(&self, hnssystemtime: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.OnClockStop)(::windows::core::Interface::as_raw(self), hnssystemtime).ok()
    }
    pub unsafe fn OnClockPause(&self, hnssystemtime: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.OnClockPause)(::windows::core::Interface::as_raw(self), hnssystemtime).ok()
    }
    pub unsafe fn OnClockRestart(&self, hnssystemtime: i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.OnClockRestart)(::windows::core::Interface::as_raw(self), hnssystemtime).ok()
    }
    pub unsafe fn OnClockSetRate(&self, hnssystemtime: i64, flrate: f32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.OnClockSetRate)(::windows::core::Interface::as_raw(self), hnssystemtime, flrate).ok()
    }
    pub unsafe fn ProcessMessage(&self, emessage: MFVP_MESSAGE_TYPE, ulparam: usize) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ProcessMessage)(::windows::core::Interface::as_raw(self), emessage, ulparam).ok()
    }
    pub unsafe fn GetCurrentMediaType(&self) -> ::windows::core::Result<IMFVideoMediaType> {
        let mut result__ = ::windows::core::zeroed::<IMFVideoMediaType>();
        (::windows::core::Interface::vtable(self).GetCurrentMediaType)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFVideoPresenter, ::windows::core::IUnknown, IMFClockStateSink);
impl ::core::cmp::PartialEq for IMFVideoPresenter {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFVideoPresenter {}
impl ::core::fmt::Debug for IMFVideoPresenter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFVideoPresenter").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFVideoPresenter {
    type Vtable = IMFVideoPresenter_Vtbl;
}
impl ::core::clone::Clone for IMFVideoPresenter {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFVideoPresenter {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x29aff080_182a_4a5d_af3b_448f3a6346cb);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFVideoPresenter_Vtbl {
    pub base__: IMFClockStateSink_Vtbl,
    pub ProcessMessage: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, emessage: MFVP_MESSAGE_TYPE, ulparam: usize) -> ::windows::core::HRESULT,
    pub GetCurrentMediaType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppmediatype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFVideoProcessor(::windows::core::IUnknown);
impl IMFVideoProcessor {
    pub unsafe fn GetAvailableVideoProcessorModes(&self, lpdwnumprocessingmodes: *mut u32, ppvideoprocessingmodes: *mut *mut ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetAvailableVideoProcessorModes)(::windows::core::Interface::as_raw(self), lpdwnumprocessingmodes, ppvideoprocessingmodes).ok()
    }
    #[doc = "*Required features: `\"Win32_Graphics_Direct3D9\"`*"]
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub unsafe fn GetVideoProcessorCaps(&self, lpvideoprocessormode: *const ::windows::core::GUID, lpvideoprocessorcaps: *mut DXVA2_VideoProcessorCaps) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetVideoProcessorCaps)(::windows::core::Interface::as_raw(self), lpvideoprocessormode, lpvideoprocessorcaps).ok()
    }
    pub unsafe fn GetVideoProcessorMode(&self) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).GetVideoProcessorMode)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SetVideoProcessorMode(&self, lpmode: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetVideoProcessorMode)(::windows::core::Interface::as_raw(self), lpmode).ok()
    }
    pub unsafe fn GetProcAmpRange(&self, dwproperty: u32) -> ::windows::core::Result<DXVA2_ValueRange> {
        let mut result__ = ::windows::core::zeroed::<DXVA2_ValueRange>();
        (::windows::core::Interface::vtable(self).GetProcAmpRange)(::windows::core::Interface::as_raw(self), dwproperty, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetProcAmpValues(&self, dwflags: u32) -> ::windows::core::Result<DXVA2_ProcAmpValues> {
        let mut result__ = ::windows::core::zeroed::<DXVA2_ProcAmpValues>();
        (::windows::core::Interface::vtable(self).GetProcAmpValues)(::windows::core::Interface::as_raw(self), dwflags, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetProcAmpValues(&self, dwflags: u32, pvalues: *const DXVA2_ProcAmpValues) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetProcAmpValues)(::windows::core::Interface::as_raw(self), dwflags, pvalues).ok()
    }
    pub unsafe fn GetFilteringRange(&self, dwproperty: u32) -> ::windows::core::Result<DXVA2_ValueRange> {
        let mut result__ = ::windows::core::zeroed::<DXVA2_ValueRange>();
        (::windows::core::Interface::vtable(self).GetFilteringRange)(::windows::core::Interface::as_raw(self), dwproperty, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetFilteringValue(&self, dwproperty: u32) -> ::windows::core::Result<DXVA2_Fixed32> {
        let mut result__ = ::windows::core::zeroed::<DXVA2_Fixed32>();
        (::windows::core::Interface::vtable(self).GetFilteringValue)(::windows::core::Interface::as_raw(self), dwproperty, &mut result__).from_abi(result__)
    }
    pub unsafe fn SetFilteringValue(&self, dwproperty: u32, pvalue: *const DXVA2_Fixed32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetFilteringValue)(::windows::core::Interface::as_raw(self), dwproperty, pvalue).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn GetBackgroundColor(&self) -> ::windows::core::Result<super::super::Foundation::COLORREF> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::COLORREF>();
        (::windows::core::Interface::vtable(self).GetBackgroundColor)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetBackgroundColor<P0>(&self, clrbkg: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::COLORREF>,
    {
        (::windows::core::Interface::vtable(self).SetBackgroundColor)(::windows::core::Interface::as_raw(self), clrbkg.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFVideoProcessor, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFVideoProcessor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFVideoProcessor {}
impl ::core::fmt::Debug for IMFVideoProcessor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFVideoProcessor").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFVideoProcessor {
    type Vtable = IMFVideoProcessor_Vtbl;
}
impl ::core::clone::Clone for IMFVideoProcessor {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFVideoProcessor {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6ab0000c_fece_4d1f_a2ac_a9573530656e);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFVideoProcessor_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetAvailableVideoProcessorModes: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, lpdwnumprocessingmodes: *mut u32, ppvideoprocessingmodes: *mut *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Graphics_Direct3D9")]
    pub GetVideoProcessorCaps: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, lpvideoprocessormode: *const ::windows::core::GUID, lpvideoprocessorcaps: *mut DXVA2_VideoProcessorCaps) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Graphics_Direct3D9"))]
    GetVideoProcessorCaps: usize,
    pub GetVideoProcessorMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, lpmode: *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub SetVideoProcessorMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, lpmode: *const ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub GetProcAmpRange: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwproperty: u32, pproprange: *mut DXVA2_ValueRange) -> ::windows::core::HRESULT,
    pub GetProcAmpValues: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwflags: u32, values: *mut DXVA2_ProcAmpValues) -> ::windows::core::HRESULT,
    pub SetProcAmpValues: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwflags: u32, pvalues: *const DXVA2_ProcAmpValues) -> ::windows::core::HRESULT,
    pub GetFilteringRange: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwproperty: u32, pproprange: *mut DXVA2_ValueRange) -> ::windows::core::HRESULT,
    pub GetFilteringValue: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwproperty: u32, pvalue: *mut DXVA2_Fixed32) -> ::windows::core::HRESULT,
    pub SetFilteringValue: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwproperty: u32, pvalue: *const DXVA2_Fixed32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub GetBackgroundColor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, lpclrbkg: *mut super::super::Foundation::COLORREF) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    GetBackgroundColor: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub SetBackgroundColor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, clrbkg: super::super::Foundation::COLORREF) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetBackgroundColor: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFVideoProcessorControl(::windows::core::IUnknown);
impl IMFVideoProcessorControl {
    pub unsafe fn SetBorderColor(&self, pbordercolor: ::core::option::Option<*const MFARGB>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetBorderColor)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pbordercolor.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetSourceRectangle(&self, psrcrect: ::core::option::Option<*const super::super::Foundation::RECT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetSourceRectangle)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(psrcrect.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetDestinationRectangle(&self, pdstrect: ::core::option::Option<*const super::super::Foundation::RECT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetDestinationRectangle)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pdstrect.unwrap_or(::std::ptr::null()))).ok()
    }
    pub unsafe fn SetMirror(&self, emirror: MF_VIDEO_PROCESSOR_MIRROR) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetMirror)(::windows::core::Interface::as_raw(self), emirror).ok()
    }
    pub unsafe fn SetRotation(&self, erotation: MF_VIDEO_PROCESSOR_ROTATION) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetRotation)(::windows::core::Interface::as_raw(self), erotation).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetConstrictionSize(&self, pconstrictionsize: ::core::option::Option<*const super::super::Foundation::SIZE>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetConstrictionSize)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pconstrictionsize.unwrap_or(::std::ptr::null()))).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFVideoProcessorControl, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFVideoProcessorControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFVideoProcessorControl {}
impl ::core::fmt::Debug for IMFVideoProcessorControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFVideoProcessorControl").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFVideoProcessorControl {
    type Vtable = IMFVideoProcessorControl_Vtbl;
}
impl ::core::clone::Clone for IMFVideoProcessorControl {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFVideoProcessorControl {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa3f675d5_6119_4f7f_a100_1d8b280f0efb);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFVideoProcessorControl_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetBorderColor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbordercolor: *const MFARGB) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub SetSourceRectangle: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, psrcrect: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetSourceRectangle: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub SetDestinationRectangle: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdstrect: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetDestinationRectangle: usize,
    pub SetMirror: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, emirror: MF_VIDEO_PROCESSOR_MIRROR) -> ::windows::core::HRESULT,
    pub SetRotation: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, erotation: MF_VIDEO_PROCESSOR_ROTATION) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub SetConstrictionSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pconstrictionsize: *const super::super::Foundation::SIZE) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetConstrictionSize: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFVideoProcessorControl2(::windows::core::IUnknown);
impl IMFVideoProcessorControl2 {
    pub unsafe fn SetBorderColor(&self, pbordercolor: ::core::option::Option<*const MFARGB>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetBorderColor)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pbordercolor.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetSourceRectangle(&self, psrcrect: ::core::option::Option<*const super::super::Foundation::RECT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetSourceRectangle)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(psrcrect.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetDestinationRectangle(&self, pdstrect: ::core::option::Option<*const super::super::Foundation::RECT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetDestinationRectangle)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pdstrect.unwrap_or(::std::ptr::null()))).ok()
    }
    pub unsafe fn SetMirror(&self, emirror: MF_VIDEO_PROCESSOR_MIRROR) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetMirror)(::windows::core::Interface::as_raw(self), emirror).ok()
    }
    pub unsafe fn SetRotation(&self, erotation: MF_VIDEO_PROCESSOR_ROTATION) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetRotation)(::windows::core::Interface::as_raw(self), erotation).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetConstrictionSize(&self, pconstrictionsize: ::core::option::Option<*const super::super::Foundation::SIZE>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetConstrictionSize)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pconstrictionsize.unwrap_or(::std::ptr::null()))).ok()
    }
    pub unsafe fn SetRotationOverride(&self, uirotation: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetRotationOverride)(::windows::core::Interface::as_raw(self), uirotation).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn EnableHardwareEffects<P0>(&self, fenabled: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).EnableHardwareEffects)(::windows::core::Interface::as_raw(self), fenabled.into_param().abi()).ok()
    }
    pub unsafe fn GetSupportedHardwareEffects(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetSupportedHardwareEffects)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFVideoProcessorControl2, ::windows::core::IUnknown, IMFVideoProcessorControl);
impl ::core::cmp::PartialEq for IMFVideoProcessorControl2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFVideoProcessorControl2 {}
impl ::core::fmt::Debug for IMFVideoProcessorControl2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFVideoProcessorControl2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFVideoProcessorControl2 {
    type Vtable = IMFVideoProcessorControl2_Vtbl;
}
impl ::core::clone::Clone for IMFVideoProcessorControl2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFVideoProcessorControl2 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbde633d3_e1dc_4a7f_a693_bbae399c4a20);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFVideoProcessorControl2_Vtbl {
    pub base__: IMFVideoProcessorControl_Vtbl,
    pub SetRotationOverride: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, uirotation: u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub EnableHardwareEffects: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fenabled: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    EnableHardwareEffects: usize,
    pub GetSupportedHardwareEffects: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, puisupport: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFVideoProcessorControl3(::windows::core::IUnknown);
impl IMFVideoProcessorControl3 {
    pub unsafe fn SetBorderColor(&self, pbordercolor: ::core::option::Option<*const MFARGB>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetBorderColor)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pbordercolor.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetSourceRectangle(&self, psrcrect: ::core::option::Option<*const super::super::Foundation::RECT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetSourceRectangle)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(psrcrect.unwrap_or(::std::ptr::null()))).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetDestinationRectangle(&self, pdstrect: ::core::option::Option<*const super::super::Foundation::RECT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetDestinationRectangle)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pdstrect.unwrap_or(::std::ptr::null()))).ok()
    }
    pub unsafe fn SetMirror(&self, emirror: MF_VIDEO_PROCESSOR_MIRROR) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetMirror)(::windows::core::Interface::as_raw(self), emirror).ok()
    }
    pub unsafe fn SetRotation(&self, erotation: MF_VIDEO_PROCESSOR_ROTATION) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetRotation)(::windows::core::Interface::as_raw(self), erotation).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetConstrictionSize(&self, pconstrictionsize: ::core::option::Option<*const super::super::Foundation::SIZE>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.SetConstrictionSize)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(pconstrictionsize.unwrap_or(::std::ptr::null()))).ok()
    }
    pub unsafe fn SetRotationOverride(&self, uirotation: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetRotationOverride)(::windows::core::Interface::as_raw(self), uirotation).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn EnableHardwareEffects<P0>(&self, fenabled: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).base__.EnableHardwareEffects)(::windows::core::Interface::as_raw(self), fenabled.into_param().abi()).ok()
    }
    pub unsafe fn GetSupportedHardwareEffects(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetSupportedHardwareEffects)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetNaturalOutputType(&self) -> ::windows::core::Result<IMFMediaType> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaType>();
        (::windows::core::Interface::vtable(self).GetNaturalOutputType)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn EnableSphericalVideoProcessing<P0>(&self, fenable: P0, eformat: MFVideoSphericalFormat, eprojectionmode: MFVideoSphericalProjectionMode) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).EnableSphericalVideoProcessing)(::windows::core::Interface::as_raw(self), fenable.into_param().abi(), eformat, eprojectionmode).ok()
    }
    pub unsafe fn SetSphericalVideoProperties(&self, x: f32, y: f32, z: f32, w: f32, fieldofview: f32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetSphericalVideoProperties)(::windows::core::Interface::as_raw(self), x, y, z, w, fieldofview).ok()
    }
    pub unsafe fn SetOutputDevice<P0>(&self, poutputdevice: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).SetOutputDevice)(::windows::core::Interface::as_raw(self), poutputdevice.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFVideoProcessorControl3, ::windows::core::IUnknown, IMFVideoProcessorControl, IMFVideoProcessorControl2);
impl ::core::cmp::PartialEq for IMFVideoProcessorControl3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFVideoProcessorControl3 {}
impl ::core::fmt::Debug for IMFVideoProcessorControl3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFVideoProcessorControl3").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFVideoProcessorControl3 {
    type Vtable = IMFVideoProcessorControl3_Vtbl;
}
impl ::core::clone::Clone for IMFVideoProcessorControl3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFVideoProcessorControl3 {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2424b3f2_eb23_40f1_91aa_74bddeea0883);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFVideoProcessorControl3_Vtbl {
    pub base__: IMFVideoProcessorControl2_Vtbl,
    pub GetNaturalOutputType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pptype: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub EnableSphericalVideoProcessing: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fenable: super::super::Foundation::BOOL, eformat: MFVideoSphericalFormat, eprojectionmode: MFVideoSphericalProjectionMode) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    EnableSphericalVideoProcessing: usize,
    pub SetSphericalVideoProperties: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, x: f32, y: f32, z: f32, w: f32, fieldofview: f32) -> ::windows::core::HRESULT,
    pub SetOutputDevice: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, poutputdevice: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFVideoRenderer(::windows::core::IUnknown);
impl IMFVideoRenderer {
    pub unsafe fn InitializeRenderer<P0, P1>(&self, pvideomixer: P0, pvideopresenter: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFTransform>,
        P1: ::windows::core::IntoParam<IMFVideoPresenter>,
    {
        (::windows::core::Interface::vtable(self).InitializeRenderer)(::windows::core::Interface::as_raw(self), pvideomixer.into_param().abi(), pvideopresenter.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFVideoRenderer, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFVideoRenderer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFVideoRenderer {}
impl ::core::fmt::Debug for IMFVideoRenderer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFVideoRenderer").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFVideoRenderer {
    type Vtable = IMFVideoRenderer_Vtbl;
}
impl ::core::clone::Clone for IMFVideoRenderer {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFVideoRenderer {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdfdfd197_a9ca_43d8_b341_6af3503792cd);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFVideoRenderer_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub InitializeRenderer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pvideomixer: *mut ::core::ffi::c_void, pvideopresenter: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFVideoRendererEffectControl(::windows::core::IUnknown);
impl IMFVideoRendererEffectControl {
    pub unsafe fn OnAppServiceConnectionEstablished<P0>(&self, pappserviceconnection: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).OnAppServiceConnectionEstablished)(::windows::core::Interface::as_raw(self), pappserviceconnection.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFVideoRendererEffectControl, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFVideoRendererEffectControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFVideoRendererEffectControl {}
impl ::core::fmt::Debug for IMFVideoRendererEffectControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFVideoRendererEffectControl").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFVideoRendererEffectControl {
    type Vtable = IMFVideoRendererEffectControl_Vtbl;
}
impl ::core::clone::Clone for IMFVideoRendererEffectControl {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFVideoRendererEffectControl {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x604d33d7_cf23_41d5_8224_5bbbb1a87475);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFVideoRendererEffectControl_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub OnAppServiceConnectionEstablished: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pappserviceconnection: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFVideoSampleAllocator(::windows::core::IUnknown);
impl IMFVideoSampleAllocator {
    pub unsafe fn SetDirectXManager<P0>(&self, pmanager: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).SetDirectXManager)(::windows::core::Interface::as_raw(self), pmanager.into_param().abi()).ok()
    }
    pub unsafe fn UninitializeSampleAllocator(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).UninitializeSampleAllocator)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn InitializeSampleAllocator<P0>(&self, crequestedframes: u32, pmediatype: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        (::windows::core::Interface::vtable(self).InitializeSampleAllocator)(::windows::core::Interface::as_raw(self), crequestedframes, pmediatype.into_param().abi()).ok()
    }
    pub unsafe fn AllocateSample(&self) -> ::windows::core::Result<IMFSample> {
        let mut result__ = ::windows::core::zeroed::<IMFSample>();
        (::windows::core::Interface::vtable(self).AllocateSample)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFVideoSampleAllocator, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFVideoSampleAllocator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFVideoSampleAllocator {}
impl ::core::fmt::Debug for IMFVideoSampleAllocator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFVideoSampleAllocator").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFVideoSampleAllocator {
    type Vtable = IMFVideoSampleAllocator_Vtbl;
}
impl ::core::clone::Clone for IMFVideoSampleAllocator {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFVideoSampleAllocator {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x86cbc910_e533_4751_8e3b_f19b5b806a03);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFVideoSampleAllocator_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetDirectXManager: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pmanager: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub UninitializeSampleAllocator: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub InitializeSampleAllocator: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, crequestedframes: u32, pmediatype: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub AllocateSample: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppsample: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFVideoSampleAllocatorCallback(::windows::core::IUnknown);
impl IMFVideoSampleAllocatorCallback {
    pub unsafe fn SetCallback<P0>(&self, pnotify: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFVideoSampleAllocatorNotify>,
    {
        (::windows::core::Interface::vtable(self).SetCallback)(::windows::core::Interface::as_raw(self), pnotify.into_param().abi()).ok()
    }
    pub unsafe fn GetFreeSampleCount(&self) -> ::windows::core::Result<i32> {
        let mut result__ = ::windows::core::zeroed::<i32>();
        (::windows::core::Interface::vtable(self).GetFreeSampleCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFVideoSampleAllocatorCallback, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFVideoSampleAllocatorCallback {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFVideoSampleAllocatorCallback {}
impl ::core::fmt::Debug for IMFVideoSampleAllocatorCallback {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFVideoSampleAllocatorCallback").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFVideoSampleAllocatorCallback {
    type Vtable = IMFVideoSampleAllocatorCallback_Vtbl;
}
impl ::core::clone::Clone for IMFVideoSampleAllocatorCallback {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFVideoSampleAllocatorCallback {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x992388b4_3372_4f67_8b6f_c84c071f4751);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFVideoSampleAllocatorCallback_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetCallback: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pnotify: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetFreeSampleCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, plsamples: *mut i32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFVideoSampleAllocatorEx(::windows::core::IUnknown);
impl IMFVideoSampleAllocatorEx {
    pub unsafe fn SetDirectXManager<P0>(&self, pmanager: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.SetDirectXManager)(::windows::core::Interface::as_raw(self), pmanager.into_param().abi()).ok()
    }
    pub unsafe fn UninitializeSampleAllocator(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.UninitializeSampleAllocator)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn InitializeSampleAllocator<P0>(&self, crequestedframes: u32, pmediatype: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFMediaType>,
    {
        (::windows::core::Interface::vtable(self).base__.InitializeSampleAllocator)(::windows::core::Interface::as_raw(self), crequestedframes, pmediatype.into_param().abi()).ok()
    }
    pub unsafe fn AllocateSample(&self) -> ::windows::core::Result<IMFSample> {
        let mut result__ = ::windows::core::zeroed::<IMFSample>();
        (::windows::core::Interface::vtable(self).base__.AllocateSample)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn InitializeSampleAllocatorEx<P0, P1>(&self, cinitialsamples: u32, cmaximumsamples: u32, pattributes: P0, pmediatype: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
        P1: ::windows::core::IntoParam<IMFMediaType>,
    {
        (::windows::core::Interface::vtable(self).InitializeSampleAllocatorEx)(::windows::core::Interface::as_raw(self), cinitialsamples, cmaximumsamples, pattributes.into_param().abi(), pmediatype.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFVideoSampleAllocatorEx, ::windows::core::IUnknown, IMFVideoSampleAllocator);
impl ::core::cmp::PartialEq for IMFVideoSampleAllocatorEx {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFVideoSampleAllocatorEx {}
impl ::core::fmt::Debug for IMFVideoSampleAllocatorEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFVideoSampleAllocatorEx").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFVideoSampleAllocatorEx {
    type Vtable = IMFVideoSampleAllocatorEx_Vtbl;
}
impl ::core::clone::Clone for IMFVideoSampleAllocatorEx {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFVideoSampleAllocatorEx {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x545b3a48_3283_4f62_866f_a62d8f598f9f);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFVideoSampleAllocatorEx_Vtbl {
    pub base__: IMFVideoSampleAllocator_Vtbl,
    pub InitializeSampleAllocatorEx: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, cinitialsamples: u32, cmaximumsamples: u32, pattributes: *mut ::core::ffi::c_void, pmediatype: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFVideoSampleAllocatorNotify(::windows::core::IUnknown);
impl IMFVideoSampleAllocatorNotify {
    pub unsafe fn NotifyRelease(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).NotifyRelease)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFVideoSampleAllocatorNotify, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFVideoSampleAllocatorNotify {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFVideoSampleAllocatorNotify {}
impl ::core::fmt::Debug for IMFVideoSampleAllocatorNotify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFVideoSampleAllocatorNotify").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFVideoSampleAllocatorNotify {
    type Vtable = IMFVideoSampleAllocatorNotify_Vtbl;
}
impl ::core::clone::Clone for IMFVideoSampleAllocatorNotify {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFVideoSampleAllocatorNotify {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa792cdbe_c374_4e89_8335_278e7b9956a4);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFVideoSampleAllocatorNotify_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub NotifyRelease: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFVideoSampleAllocatorNotifyEx(::windows::core::IUnknown);
impl IMFVideoSampleAllocatorNotifyEx {
    pub unsafe fn NotifyRelease(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.NotifyRelease)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn NotifyPrune<P0>(&self, __midl__imfvideosampleallocatornotifyex0000: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFSample>,
    {
        (::windows::core::Interface::vtable(self).NotifyPrune)(::windows::core::Interface::as_raw(self), __midl__imfvideosampleallocatornotifyex0000.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFVideoSampleAllocatorNotifyEx, ::windows::core::IUnknown, IMFVideoSampleAllocatorNotify);
impl ::core::cmp::PartialEq for IMFVideoSampleAllocatorNotifyEx {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFVideoSampleAllocatorNotifyEx {}
impl ::core::fmt::Debug for IMFVideoSampleAllocatorNotifyEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFVideoSampleAllocatorNotifyEx").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFVideoSampleAllocatorNotifyEx {
    type Vtable = IMFVideoSampleAllocatorNotifyEx_Vtbl;
}
impl ::core::clone::Clone for IMFVideoSampleAllocatorNotifyEx {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFVideoSampleAllocatorNotifyEx {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3978aa1a_6d5b_4b7f_a340_90899189ae34);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFVideoSampleAllocatorNotifyEx_Vtbl {
    pub base__: IMFVideoSampleAllocatorNotify_Vtbl,
    pub NotifyPrune: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, __midl__imfvideosampleallocatornotifyex0000: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFVirtualCamera(::windows::core::IUnknown);
impl IMFVirtualCamera {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItem(&self, guidkey: *const ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItem)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetItemType(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<MF_ATTRIBUTE_TYPE> {
        let mut result__ = ::windows::core::zeroed::<MF_ATTRIBUTE_TYPE>();
        (::windows::core::Interface::vtable(self).base__.GetItemType)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn CompareItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<super::super::Foundation::BOOL> {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.CompareItem)(::windows::core::Interface::as_raw(self), guidkey, value, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn Compare<P0>(&self, ptheirs: P0, matchtype: MF_ATTRIBUTES_MATCH_TYPE) -> ::windows::core::Result<super::super::Foundation::BOOL>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        let mut result__ = ::windows::core::zeroed::<super::super::Foundation::BOOL>();
        (::windows::core::Interface::vtable(self).base__.Compare)(::windows::core::Interface::as_raw(self), ptheirs.into_param().abi(), matchtype, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT32(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetUINT32)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetUINT64(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).base__.GetUINT64)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetDouble(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<f64> {
        let mut result__ = ::windows::core::zeroed::<f64>();
        (::windows::core::Interface::vtable(self).base__.GetDouble)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetGUID(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::GUID> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::GUID>();
        (::windows::core::Interface::vtable(self).base__.GetGUID)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStringLength(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetStringLength)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetString(&self, guidkey: *const ::windows::core::GUID, pwszvalue: &mut [u16], pcchlength: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetString)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pwszvalue.as_ptr()), pwszvalue.len() as _, ::core::mem::transmute(pcchlength.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedString(&self, guidkey: *const ::windows::core::GUID, ppwszvalue: *mut ::windows::core::PWSTR, pcchlength: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedString)(::windows::core::Interface::as_raw(self), guidkey, ppwszvalue, pcchlength).ok()
    }
    pub unsafe fn GetBlobSize(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetBlobSize)(::windows::core::Interface::as_raw(self), guidkey, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &mut [u8], pcbblobsize: ::core::option::Option<*mut u32>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _, ::core::mem::transmute(pcbblobsize.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn GetAllocatedBlob(&self, guidkey: *const ::windows::core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetAllocatedBlob)(::windows::core::Interface::as_raw(self), guidkey, ppbuf, pcbsize).ok()
    }
    pub unsafe fn GetUnknown<T>(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.GetUnknown)(::windows::core::Interface::as_raw(self), guidkey, &<T as ::windows::core::ComInterface>::IID, &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn SetItem(&self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetItem)(::windows::core::Interface::as_raw(self), guidkey, value).ok()
    }
    pub unsafe fn DeleteItem(&self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteItem)(::windows::core::Interface::as_raw(self), guidkey).ok()
    }
    pub unsafe fn DeleteAllItems(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.DeleteAllItems)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetUINT32(&self, guidkey: *const ::windows::core::GUID, unvalue: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT32)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetUINT64(&self, guidkey: *const ::windows::core::GUID, unvalue: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetUINT64)(::windows::core::Interface::as_raw(self), guidkey, unvalue).ok()
    }
    pub unsafe fn SetDouble(&self, guidkey: *const ::windows::core::GUID, fvalue: f64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetDouble)(::windows::core::Interface::as_raw(self), guidkey, fvalue).ok()
    }
    pub unsafe fn SetGUID(&self, guidkey: *const ::windows::core::GUID, guidvalue: *const ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetGUID)(::windows::core::Interface::as_raw(self), guidkey, guidvalue).ok()
    }
    pub unsafe fn SetString<P0>(&self, guidkey: *const ::windows::core::GUID, wszvalue: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.SetString)(::windows::core::Interface::as_raw(self), guidkey, wszvalue.into_param().abi()).ok()
    }
    pub unsafe fn SetBlob(&self, guidkey: *const ::windows::core::GUID, pbuf: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetBlob)(::windows::core::Interface::as_raw(self), guidkey, ::core::mem::transmute(pbuf.as_ptr()), pbuf.len() as _).ok()
    }
    pub unsafe fn SetUnknown<P0>(&self, guidkey: *const ::windows::core::GUID, punknown: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.SetUnknown)(::windows::core::Interface::as_raw(self), guidkey, punknown.into_param().abi()).ok()
    }
    pub unsafe fn LockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.LockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn UnlockStore(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.UnlockStore)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetCount(&self) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetCount)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_System_Com_StructuredStorage\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com_StructuredStorage"))]
    pub unsafe fn GetItemByIndex(&self, unindex: u32, pguidkey: *mut ::windows::core::GUID, pvalue: ::core::option::Option<*mut super::super::System::Com::StructuredStorage::PROPVARIANT>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetItemByIndex)(::windows::core::Interface::as_raw(self), unindex, pguidkey, ::core::mem::transmute(pvalue.unwrap_or(::std::ptr::null_mut()))).ok()
    }
    pub unsafe fn CopyAllItems<P0>(&self, pdest: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAttributes>,
    {
        (::windows::core::Interface::vtable(self).base__.CopyAllItems)(::windows::core::Interface::as_raw(self), pdest.into_param().abi()).ok()
    }
    pub unsafe fn AddDeviceSourceInfo<P0>(&self, devicesourceinfo: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).AddDeviceSourceInfo)(::windows::core::Interface::as_raw(self), devicesourceinfo.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Devices_Properties\"`*"]
    #[cfg(feature = "Win32_Devices_Properties")]
    pub unsafe fn AddProperty(&self, pkey: *const super::super::Devices::Properties::DEVPROPKEY, r#type: super::super::Devices::Properties::DEVPROPTYPE, pbdata: &[u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).AddProperty)(::windows::core::Interface::as_raw(self), pkey, r#type, ::core::mem::transmute(pbdata.as_ptr()), pbdata.len() as _).ok()
    }
    pub unsafe fn AddRegistryEntry<P0, P1>(&self, entryname: P0, subkeypath: P1, dwregtype: u32, pbdata: &[u8]) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).AddRegistryEntry)(::windows::core::Interface::as_raw(self), entryname.into_param().abi(), subkeypath.into_param().abi(), dwregtype, ::core::mem::transmute(pbdata.as_ptr()), pbdata.len() as _).ok()
    }
    pub unsafe fn Start<P0>(&self, pcallback: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
    {
        (::windows::core::Interface::vtable(self).Start)(::windows::core::Interface::as_raw(self), pcallback.into_param().abi()).ok()
    }
    pub unsafe fn Stop(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Stop)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn Remove(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Remove)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetMediaSource(&self) -> ::windows::core::Result<IMFMediaSource> {
        let mut result__ = ::windows::core::zeroed::<IMFMediaSource>();
        (::windows::core::Interface::vtable(self).GetMediaSource)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn SendCameraProperty(&self, propertyset: *const ::windows::core::GUID, propertyid: u32, propertyflags: u32, propertypayload: ::core::option::Option<*mut ::core::ffi::c_void>, propertypayloadlength: u32, data: ::core::option::Option<*mut ::core::ffi::c_void>, datalength: u32, datawritten: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SendCameraProperty)(::windows::core::Interface::as_raw(self), propertyset, propertyid, propertyflags, ::core::mem::transmute(propertypayload.unwrap_or(::std::ptr::null_mut())), propertypayloadlength, ::core::mem::transmute(data.unwrap_or(::std::ptr::null_mut())), datalength, datawritten).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn CreateSyncEvent<P0>(&self, kseventset: *const ::windows::core::GUID, kseventid: u32, kseventflags: u32, eventhandle: P0) -> ::windows::core::Result<IMFCameraSyncObject>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::HANDLE>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFCameraSyncObject>();
        (::windows::core::Interface::vtable(self).CreateSyncEvent)(::windows::core::Interface::as_raw(self), kseventset, kseventid, kseventflags, eventhandle.into_param().abi(), &mut result__).from_abi(result__)
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn CreateSyncSemaphore<P0>(&self, kseventset: *const ::windows::core::GUID, kseventid: u32, kseventflags: u32, semaphorehandle: P0, semaphoreadjustment: i32) -> ::windows::core::Result<IMFCameraSyncObject>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::HANDLE>,
    {
        let mut result__ = ::windows::core::zeroed::<IMFCameraSyncObject>();
        (::windows::core::Interface::vtable(self).CreateSyncSemaphore)(::windows::core::Interface::as_raw(self), kseventset, kseventid, kseventflags, semaphorehandle.into_param().abi(), semaphoreadjustment, &mut result__).from_abi(result__)
    }
    pub unsafe fn Shutdown(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Shutdown)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IMFVirtualCamera, ::windows::core::IUnknown, IMFAttributes);
impl ::core::cmp::PartialEq for IMFVirtualCamera {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFVirtualCamera {}
impl ::core::fmt::Debug for IMFVirtualCamera {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFVirtualCamera").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFVirtualCamera {
    type Vtable = IMFVirtualCamera_Vtbl;
}
impl ::core::clone::Clone for IMFVirtualCamera {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFVirtualCamera {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1c08a864_ef6c_4c75_af59_5f2d68da9563);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFVirtualCamera_Vtbl {
    pub base__: IMFAttributes_Vtbl,
    pub AddDeviceSourceInfo: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, devicesourceinfo: ::windows::core::PCWSTR) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Devices_Properties")]
    pub AddProperty: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pkey: *const super::super::Devices::Properties::DEVPROPKEY, r#type: super::super::Devices::Properties::DEVPROPTYPE, pbdata: *const u8, cbdata: u32) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Devices_Properties"))]
    AddProperty: usize,
    pub AddRegistryEntry: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, entryname: ::windows::core::PCWSTR, subkeypath: ::windows::core::PCWSTR, dwregtype: u32, pbdata: *const u8, cbdata: u32) -> ::windows::core::HRESULT,
    pub Start: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcallback: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Stop: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Remove: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetMediaSource: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ppmediasource: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SendCameraProperty: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, propertyset: *const ::windows::core::GUID, propertyid: u32, propertyflags: u32, propertypayload: *mut ::core::ffi::c_void, propertypayloadlength: u32, data: *mut ::core::ffi::c_void, datalength: u32, datawritten: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub CreateSyncEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, kseventset: *const ::windows::core::GUID, kseventid: u32, kseventflags: u32, eventhandle: super::super::Foundation::HANDLE, camerasyncobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    CreateSyncEvent: usize,
    #[cfg(feature = "Win32_Foundation")]
    pub CreateSyncSemaphore: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, kseventset: *const ::windows::core::GUID, kseventid: u32, kseventflags: u32, semaphorehandle: super::super::Foundation::HANDLE, semaphoreadjustment: i32, camerasyncobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    CreateSyncSemaphore: usize,
    pub Shutdown: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFWorkQueueServices(::windows::core::IUnknown);
impl IMFWorkQueueServices {
    pub unsafe fn BeginRegisterTopologyWorkQueuesWithMMCSS<P0, P1>(&self, pcallback: P0, pstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginRegisterTopologyWorkQueuesWithMMCSS)(::windows::core::Interface::as_raw(self), pcallback.into_param().abi(), pstate.into_param().abi()).ok()
    }
    pub unsafe fn EndRegisterTopologyWorkQueuesWithMMCSS<P0>(&self, presult: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        (::windows::core::Interface::vtable(self).EndRegisterTopologyWorkQueuesWithMMCSS)(::windows::core::Interface::as_raw(self), presult.into_param().abi()).ok()
    }
    pub unsafe fn BeginUnregisterTopologyWorkQueuesWithMMCSS<P0, P1>(&self, pcallback: P0, pstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginUnregisterTopologyWorkQueuesWithMMCSS)(::windows::core::Interface::as_raw(self), pcallback.into_param().abi(), pstate.into_param().abi()).ok()
    }
    pub unsafe fn EndUnregisterTopologyWorkQueuesWithMMCSS<P0>(&self, presult: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        (::windows::core::Interface::vtable(self).EndUnregisterTopologyWorkQueuesWithMMCSS)(::windows::core::Interface::as_raw(self), presult.into_param().abi()).ok()
    }
    pub unsafe fn GetTopologyWorkQueueMMCSSClass(&self, dwtopologyworkqueueid: u32, pwszclass: ::windows::core::PWSTR, pcchclass: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetTopologyWorkQueueMMCSSClass)(::windows::core::Interface::as_raw(self), dwtopologyworkqueueid, ::core::mem::transmute(pwszclass), pcchclass).ok()
    }
    pub unsafe fn GetTopologyWorkQueueMMCSSTaskId(&self, dwtopologyworkqueueid: u32) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetTopologyWorkQueueMMCSSTaskId)(::windows::core::Interface::as_raw(self), dwtopologyworkqueueid, &mut result__).from_abi(result__)
    }
    pub unsafe fn BeginRegisterPlatformWorkQueueWithMMCSS<P0, P1, P2>(&self, dwplatformworkqueue: u32, wszclass: P0, dwtaskid: u32, pcallback: P1, pstate: P2) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P1: ::windows::core::IntoParam<IMFAsyncCallback>,
        P2: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginRegisterPlatformWorkQueueWithMMCSS)(::windows::core::Interface::as_raw(self), dwplatformworkqueue, wszclass.into_param().abi(), dwtaskid, pcallback.into_param().abi(), pstate.into_param().abi()).ok()
    }
    pub unsafe fn EndRegisterPlatformWorkQueueWithMMCSS<P0>(&self, presult: P0) -> ::windows::core::Result<u32>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).EndRegisterPlatformWorkQueueWithMMCSS)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn BeginUnregisterPlatformWorkQueueWithMMCSS<P0, P1>(&self, dwplatformworkqueue: u32, pcallback: P0, pstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginUnregisterPlatformWorkQueueWithMMCSS)(::windows::core::Interface::as_raw(self), dwplatformworkqueue, pcallback.into_param().abi(), pstate.into_param().abi()).ok()
    }
    pub unsafe fn EndUnregisterPlatformWorkQueueWithMMCSS<P0>(&self, presult: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        (::windows::core::Interface::vtable(self).EndUnregisterPlatformWorkQueueWithMMCSS)(::windows::core::Interface::as_raw(self), presult.into_param().abi()).ok()
    }
    pub unsafe fn GetPlaftormWorkQueueMMCSSClass(&self, dwplatformworkqueueid: u32, pwszclass: ::windows::core::PWSTR, pcchclass: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetPlaftormWorkQueueMMCSSClass)(::windows::core::Interface::as_raw(self), dwplatformworkqueueid, ::core::mem::transmute(pwszclass), pcchclass).ok()
    }
    pub unsafe fn GetPlatformWorkQueueMMCSSTaskId(&self, dwplatformworkqueueid: u32) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).GetPlatformWorkQueueMMCSSTaskId)(::windows::core::Interface::as_raw(self), dwplatformworkqueueid, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFWorkQueueServices, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IMFWorkQueueServices {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFWorkQueueServices {}
impl ::core::fmt::Debug for IMFWorkQueueServices {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFWorkQueueServices").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFWorkQueueServices {
    type Vtable = IMFWorkQueueServices_Vtbl;
}
impl ::core::clone::Clone for IMFWorkQueueServices {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFWorkQueueServices {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x35fe1bb8_a3a9_40fe_bbec_eb569c9ccca3);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFWorkQueueServices_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub BeginRegisterTopologyWorkQueuesWithMMCSS: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcallback: *mut ::core::ffi::c_void, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub EndRegisterTopologyWorkQueuesWithMMCSS: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub BeginUnregisterTopologyWorkQueuesWithMMCSS: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcallback: *mut ::core::ffi::c_void, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub EndUnregisterTopologyWorkQueuesWithMMCSS: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetTopologyWorkQueueMMCSSClass: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwtopologyworkqueueid: u32, pwszclass: ::windows::core::PWSTR, pcchclass: *mut u32) -> ::windows::core::HRESULT,
    pub GetTopologyWorkQueueMMCSSTaskId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwtopologyworkqueueid: u32, pdwtaskid: *mut u32) -> ::windows::core::HRESULT,
    pub BeginRegisterPlatformWorkQueueWithMMCSS: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwplatformworkqueue: u32, wszclass: ::windows::core::PCWSTR, dwtaskid: u32, pcallback: *mut ::core::ffi::c_void, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub EndRegisterPlatformWorkQueueWithMMCSS: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void, pdwtaskid: *mut u32) -> ::windows::core::HRESULT,
    pub BeginUnregisterPlatformWorkQueueWithMMCSS: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwplatformworkqueue: u32, pcallback: *mut ::core::ffi::c_void, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub EndUnregisterPlatformWorkQueueWithMMCSS: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, presult: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetPlaftormWorkQueueMMCSSClass: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwplatformworkqueueid: u32, pwszclass: ::windows::core::PWSTR, pcchclass: *mut u32) -> ::windows::core::HRESULT,
    pub GetPlatformWorkQueueMMCSSTaskId: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwplatformworkqueueid: u32, pdwtaskid: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IMFWorkQueueServicesEx(::windows::core::IUnknown);
impl IMFWorkQueueServicesEx {
    pub unsafe fn BeginRegisterTopologyWorkQueuesWithMMCSS<P0, P1>(&self, pcallback: P0, pstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.BeginRegisterTopologyWorkQueuesWithMMCSS)(::windows::core::Interface::as_raw(self), pcallback.into_param().abi(), pstate.into_param().abi()).ok()
    }
    pub unsafe fn EndRegisterTopologyWorkQueuesWithMMCSS<P0>(&self, presult: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        (::windows::core::Interface::vtable(self).base__.EndRegisterTopologyWorkQueuesWithMMCSS)(::windows::core::Interface::as_raw(self), presult.into_param().abi()).ok()
    }
    pub unsafe fn BeginUnregisterTopologyWorkQueuesWithMMCSS<P0, P1>(&self, pcallback: P0, pstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.BeginUnregisterTopologyWorkQueuesWithMMCSS)(::windows::core::Interface::as_raw(self), pcallback.into_param().abi(), pstate.into_param().abi()).ok()
    }
    pub unsafe fn EndUnregisterTopologyWorkQueuesWithMMCSS<P0>(&self, presult: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        (::windows::core::Interface::vtable(self).base__.EndUnregisterTopologyWorkQueuesWithMMCSS)(::windows::core::Interface::as_raw(self), presult.into_param().abi()).ok()
    }
    pub unsafe fn GetTopologyWorkQueueMMCSSClass(&self, dwtopologyworkqueueid: u32, pwszclass: ::windows::core::PWSTR, pcchclass: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetTopologyWorkQueueMMCSSClass)(::windows::core::Interface::as_raw(self), dwtopologyworkqueueid, ::core::mem::transmute(pwszclass), pcchclass).ok()
    }
    pub unsafe fn GetTopologyWorkQueueMMCSSTaskId(&self, dwtopologyworkqueueid: u32) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetTopologyWorkQueueMMCSSTaskId)(::windows::core::Interface::as_raw(self), dwtopologyworkqueueid, &mut result__).from_abi(result__)
    }
    pub unsafe fn BeginRegisterPlatformWorkQueueWithMMCSS<P0, P1, P2>(&self, dwplatformworkqueue: u32, wszclass: P0, dwtaskid: u32, pcallback: P1, pstate: P2) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P1: ::windows::core::IntoParam<IMFAsyncCallback>,
        P2: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.BeginRegisterPlatformWorkQueueWithMMCSS)(::windows::core::Interface::as_raw(self), dwplatformworkqueue, wszclass.into_param().abi(), dwtaskid, pcallback.into_param().abi(), pstate.into_param().abi()).ok()
    }
    pub unsafe fn EndRegisterPlatformWorkQueueWithMMCSS<P0>(&self, presult: P0) -> ::windows::core::Result<u32>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.EndRegisterPlatformWorkQueueWithMMCSS)(::windows::core::Interface::as_raw(self), presult.into_param().abi(), &mut result__).from_abi(result__)
    }
    pub unsafe fn BeginUnregisterPlatformWorkQueueWithMMCSS<P0, P1>(&self, dwplatformworkqueue: u32, pcallback: P0, pstate: P1) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncCallback>,
        P1: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).base__.BeginUnregisterPlatformWorkQueueWithMMCSS)(::windows::core::Interface::as_raw(self), dwplatformworkqueue, pcallback.into_param().abi(), pstate.into_param().abi()).ok()
    }
    pub unsafe fn EndUnregisterPlatformWorkQueueWithMMCSS<P0>(&self, presult: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFAsyncResult>,
    {
        (::windows::core::Interface::vtable(self).base__.EndUnregisterPlatformWorkQueueWithMMCSS)(::windows::core::Interface::as_raw(self), presult.into_param().abi()).ok()
    }
    pub unsafe fn GetPlaftormWorkQueueMMCSSClass(&self, dwplatformworkqueueid: u32, pwszclass: ::windows::core::PWSTR, pcchclass: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetPlaftormWorkQueueMMCSSClass)(::windows::core::Interface::as_raw(self), dwplatformworkqueueid, ::core::mem::transmute(pwszclass), pcchclass).ok()
    }
    pub unsafe fn GetPlatformWorkQueueMMCSSTaskId(&self, dwplatformworkqueueid: u32) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).base__.GetPlatformWorkQueueMMCSSTaskId)(::windows::core::Interface::as_raw(self), dwplatformworkqueueid, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetTopologyWorkQueueMMCSSPriority(&self, dwtopologyworkqueueid: u32) -> ::windows::core::Result<i32> {
        let mut result__ = ::windows::core::zeroed::<i32>();
        (::windows::core::Interface::vtable(self).GetTopologyWorkQueueMMCSSPriority)(::windows::core::Interface::as_raw(self), dwtopologyworkqueueid, &mut result__).from_abi(result__)
    }
    pub unsafe fn BeginRegisterPlatformWorkQueueWithMMCSSEx<P0, P1, P2>(&self, dwplatformworkqueue: u32, wszclass: P0, dwtaskid: u32, lpriority: i32, pcallback: P1, pstate: P2) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P1: ::windows::core::IntoParam<IMFAsyncCallback>,
        P2: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).BeginRegisterPlatformWorkQueueWithMMCSSEx)(::windows::core::Interface::as_raw(self), dwplatformworkqueue, wszclass.into_param().abi(), dwtaskid, lpriority, pcallback.into_param().abi(), pstate.into_param().abi()).ok()
    }
    pub unsafe fn GetPlatformWorkQueueMMCSSPriority(&self, dwplatformworkqueueid: u32) -> ::windows::core::Result<i32> {
        let mut result__ = ::windows::core::zeroed::<i32>();
        (::windows::core::Interface::vtable(self).GetPlatformWorkQueueMMCSSPriority)(::windows::core::Interface::as_raw(self), dwplatformworkqueueid, &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IMFWorkQueueServicesEx, ::windows::core::IUnknown, IMFWorkQueueServices);
impl ::core::cmp::PartialEq for IMFWorkQueueServicesEx {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IMFWorkQueueServicesEx {}
impl ::core::fmt::Debug for IMFWorkQueueServicesEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IMFWorkQueueServicesEx").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IMFWorkQueueServicesEx {
    type Vtable = IMFWorkQueueServicesEx_Vtbl;
}
impl ::core::clone::Clone for IMFWorkQueueServicesEx {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IMFWorkQueueServicesEx {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x96bf961b_40fe_42f1_ba9d_320238b49700);
}
#[repr(C)]
#[doc(hidden)]
pub struct IMFWorkQueueServicesEx_Vtbl {
    pub base__: IMFWorkQueueServices_Vtbl,
    pub GetTopologyWorkQueueMMCSSPriority: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwtopologyworkqueueid: u32, plpriority: *mut i32) -> ::windows::core::HRESULT,
    pub BeginRegisterPlatformWorkQueueWithMMCSSEx: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwplatformworkqueue: u32, wszclass: ::windows::core::PCWSTR, dwtaskid: u32, lpriority: i32, pcallback: *mut ::core::ffi::c_void, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetPlatformWorkQueueMMCSSPriority: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwplatformworkqueueid: u32, plpriority: *mut i32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IOPMVideoOutput(::windows::core::IUnknown);
impl IOPMVideoOutput {
    pub unsafe fn StartInitialization(&self, prnrandomnumber: *mut OPM_RANDOM_NUMBER, ppbcertificate: *mut *mut u8, pulcertificatelength: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).StartInitialization)(::windows::core::Interface::as_raw(self), prnrandomnumber, ppbcertificate, pulcertificatelength).ok()
    }
    pub unsafe fn FinishInitialization(&self, pparameters: *const OPM_ENCRYPTED_INITIALIZATION_PARAMETERS) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).FinishInitialization)(::windows::core::Interface::as_raw(self), pparameters).ok()
    }
    pub unsafe fn GetInformation(&self, pparameters: *const OPM_GET_INFO_PARAMETERS, prequestedinformation: *mut OPM_REQUESTED_INFORMATION) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetInformation)(::windows::core::Interface::as_raw(self), pparameters, prequestedinformation).ok()
    }
    pub unsafe fn COPPCompatibleGetInformation(&self, pparameters: *const OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS, prequestedinformation: *mut OPM_REQUESTED_INFORMATION) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).COPPCompatibleGetInformation)(::windows::core::Interface::as_raw(self), pparameters, prequestedinformation).ok()
    }
    pub unsafe fn Configure(&self, pparameters: *const OPM_CONFIGURE_PARAMETERS, pbadditionalparameters: ::core::option::Option<&[u8]>) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Configure)(::windows::core::Interface::as_raw(self), pparameters, pbadditionalparameters.as_deref().map_or(0, |slice| slice.len() as _), ::core::mem::transmute(pbadditionalparameters.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr()))).ok()
    }
}
::windows::imp::interface_hierarchy!(IOPMVideoOutput, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IOPMVideoOutput {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IOPMVideoOutput {}
impl ::core::fmt::Debug for IOPMVideoOutput {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IOPMVideoOutput").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IOPMVideoOutput {
    type Vtable = IOPMVideoOutput_Vtbl;
}
impl ::core::clone::Clone for IOPMVideoOutput {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IOPMVideoOutput {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0a15159d_41c7_4456_93e1_284cd61d4e8d);
}
#[repr(C)]
#[doc(hidden)]
pub struct IOPMVideoOutput_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub StartInitialization: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, prnrandomnumber: *mut OPM_RANDOM_NUMBER, ppbcertificate: *mut *mut u8, pulcertificatelength: *mut u32) -> ::windows::core::HRESULT,
    pub FinishInitialization: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pparameters: *const OPM_ENCRYPTED_INITIALIZATION_PARAMETERS) -> ::windows::core::HRESULT,
    pub GetInformation: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pparameters: *const OPM_GET_INFO_PARAMETERS, prequestedinformation: *mut OPM_REQUESTED_INFORMATION) -> ::windows::core::HRESULT,
    pub COPPCompatibleGetInformation: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pparameters: *const OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS, prequestedinformation: *mut OPM_REQUESTED_INFORMATION) -> ::windows::core::HRESULT,
    pub Configure: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pparameters: *const OPM_CONFIGURE_PARAMETERS, uladditionalparameterssize: u32, pbadditionalparameters: *const u8) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IPlayToControl(::windows::core::IUnknown);
impl IPlayToControl {
    pub unsafe fn Connect<P0>(&self, pfactory: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFSharingEngineClassFactory>,
    {
        (::windows::core::Interface::vtable(self).Connect)(::windows::core::Interface::as_raw(self), pfactory.into_param().abi()).ok()
    }
    pub unsafe fn Disconnect(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Disconnect)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IPlayToControl, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IPlayToControl {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPlayToControl {}
impl ::core::fmt::Debug for IPlayToControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPlayToControl").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IPlayToControl {
    type Vtable = IPlayToControl_Vtbl;
}
impl ::core::clone::Clone for IPlayToControl {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IPlayToControl {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x607574eb_f4b6_45c1_b08c_cb715122901d);
}
#[repr(C)]
#[doc(hidden)]
pub struct IPlayToControl_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub Connect: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pfactory: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Disconnect: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IPlayToControlWithCapabilities(::windows::core::IUnknown);
impl IPlayToControlWithCapabilities {
    pub unsafe fn Connect<P0>(&self, pfactory: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IMFSharingEngineClassFactory>,
    {
        (::windows::core::Interface::vtable(self).base__.Connect)(::windows::core::Interface::as_raw(self), pfactory.into_param().abi()).ok()
    }
    pub unsafe fn Disconnect(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Disconnect)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn GetCapabilities(&self) -> ::windows::core::Result<PLAYTO_SOURCE_CREATEFLAGS> {
        let mut result__ = ::windows::core::zeroed::<PLAYTO_SOURCE_CREATEFLAGS>();
        (::windows::core::Interface::vtable(self).GetCapabilities)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IPlayToControlWithCapabilities, ::windows::core::IUnknown, IPlayToControl);
impl ::core::cmp::PartialEq for IPlayToControlWithCapabilities {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPlayToControlWithCapabilities {}
impl ::core::fmt::Debug for IPlayToControlWithCapabilities {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPlayToControlWithCapabilities").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IPlayToControlWithCapabilities {
    type Vtable = IPlayToControlWithCapabilities_Vtbl;
}
impl ::core::clone::Clone for IPlayToControlWithCapabilities {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IPlayToControlWithCapabilities {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xaa9dd80f_c50a_4220_91c1_332287f82a34);
}
#[repr(C)]
#[doc(hidden)]
pub struct IPlayToControlWithCapabilities_Vtbl {
    pub base__: IPlayToControl_Vtbl,
    pub GetCapabilities: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pcapabilities: *mut PLAYTO_SOURCE_CREATEFLAGS) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IPlayToSourceClassFactory(::windows::core::IUnknown);
impl IPlayToSourceClassFactory {
    pub unsafe fn CreateInstance<P0>(&self, dwflags: u32, pcontrol: P0) -> ::windows::core::Result<::windows::core::IInspectable>
    where
        P0: ::windows::core::IntoParam<IPlayToControl>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::core::IInspectable>();
        (::windows::core::Interface::vtable(self).CreateInstance)(::windows::core::Interface::as_raw(self), dwflags, pcontrol.into_param().abi(), &mut result__).from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(IPlayToSourceClassFactory, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IPlayToSourceClassFactory {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IPlayToSourceClassFactory {}
impl ::core::fmt::Debug for IPlayToSourceClassFactory {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IPlayToSourceClassFactory").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IPlayToSourceClassFactory {
    type Vtable = IPlayToSourceClassFactory_Vtbl;
}
impl ::core::clone::Clone for IPlayToSourceClassFactory {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IPlayToSourceClassFactory {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x842b32a3_9b9b_4d1c_b3f3_49193248a554);
}
#[repr(C)]
#[doc(hidden)]
pub struct IPlayToSourceClassFactory_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub CreateInstance: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwflags: u32, pcontrol: *mut ::core::ffi::c_void, ppsource: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IToc(::windows::core::IUnknown);
impl IToc {
    pub unsafe fn SetDescriptor(&self, pdescriptor: *mut TOC_DESCRIPTOR) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetDescriptor)(::windows::core::Interface::as_raw(self), pdescriptor).ok()
    }
    pub unsafe fn GetDescriptor(&self, pdescriptor: *mut TOC_DESCRIPTOR) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDescriptor)(::windows::core::Interface::as_raw(self), pdescriptor).ok()
    }
    pub unsafe fn SetDescription<P0>(&self, pwszdescription: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).SetDescription)(::windows::core::Interface::as_raw(self), pwszdescription.into_param().abi()).ok()
    }
    pub unsafe fn GetDescription(&self, pwdescriptionsize: *mut u16, pwszdescription: ::windows::core::PWSTR) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDescription)(::windows::core::Interface::as_raw(self), pwdescriptionsize, ::core::mem::transmute(pwszdescription)).ok()
    }
    pub unsafe fn SetContext(&self, dwcontextsize: u32, pbtcontext: *mut u8) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetContext)(::windows::core::Interface::as_raw(self), dwcontextsize, pbtcontext).ok()
    }
    pub unsafe fn GetContext(&self, pdwcontextsize: *mut u32, pbtcontext: *mut u8) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetContext)(::windows::core::Interface::as_raw(self), pdwcontextsize, pbtcontext).ok()
    }
    pub unsafe fn GetEntryListCount(&self, pwcount: *mut u16) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetEntryListCount)(::windows::core::Interface::as_raw(self), pwcount).ok()
    }
    pub unsafe fn GetEntryListByIndex(&self, wentrylistindex: u16) -> ::windows::core::Result<ITocEntryList> {
        let mut result__ = ::windows::core::zeroed::<ITocEntryList>();
        (::windows::core::Interface::vtable(self).GetEntryListByIndex)(::windows::core::Interface::as_raw(self), wentrylistindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn AddEntryList<P0>(&self, pentrylist: P0, pwentrylistindex: *mut u16) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ITocEntryList>,
    {
        (::windows::core::Interface::vtable(self).AddEntryList)(::windows::core::Interface::as_raw(self), pentrylist.into_param().abi(), pwentrylistindex).ok()
    }
    pub unsafe fn AddEntryListByIndex<P0>(&self, wentrylistindex: u16, pentrylist: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ITocEntryList>,
    {
        (::windows::core::Interface::vtable(self).AddEntryListByIndex)(::windows::core::Interface::as_raw(self), wentrylistindex, pentrylist.into_param().abi()).ok()
    }
    pub unsafe fn RemoveEntryListByIndex(&self, wentrylistindex: u16) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveEntryListByIndex)(::windows::core::Interface::as_raw(self), wentrylistindex).ok()
    }
}
::windows::imp::interface_hierarchy!(IToc, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IToc {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IToc {}
impl ::core::fmt::Debug for IToc {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IToc").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IToc {
    type Vtable = IToc_Vtbl;
}
impl ::core::clone::Clone for IToc {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IToc {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd6f05441_a919_423b_91a0_89d5b4a8ab77);
}
#[repr(C)]
#[doc(hidden)]
pub struct IToc_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetDescriptor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdescriptor: *mut TOC_DESCRIPTOR) -> ::windows::core::HRESULT,
    pub GetDescriptor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdescriptor: *mut TOC_DESCRIPTOR) -> ::windows::core::HRESULT,
    pub SetDescription: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pwszdescription: ::windows::core::PCWSTR) -> ::windows::core::HRESULT,
    pub GetDescription: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pwdescriptionsize: *mut u16, pwszdescription: ::windows::core::PWSTR) -> ::windows::core::HRESULT,
    pub SetContext: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwcontextsize: u32, pbtcontext: *mut u8) -> ::windows::core::HRESULT,
    pub GetContext: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwcontextsize: *mut u32, pbtcontext: *mut u8) -> ::windows::core::HRESULT,
    pub GetEntryListCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pwcount: *mut u16) -> ::windows::core::HRESULT,
    pub GetEntryListByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, wentrylistindex: u16, ppentrylist: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub AddEntryList: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pentrylist: *mut ::core::ffi::c_void, pwentrylistindex: *mut u16) -> ::windows::core::HRESULT,
    pub AddEntryListByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, wentrylistindex: u16, pentrylist: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RemoveEntryListByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, wentrylistindex: u16) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct ITocCollection(::windows::core::IUnknown);
impl ITocCollection {
    pub unsafe fn GetEntryCount(&self, pdwentrycount: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetEntryCount)(::windows::core::Interface::as_raw(self), pdwentrycount).ok()
    }
    pub unsafe fn GetEntryByIndex(&self, dwentryindex: u32) -> ::windows::core::Result<IToc> {
        let mut result__ = ::windows::core::zeroed::<IToc>();
        (::windows::core::Interface::vtable(self).GetEntryByIndex)(::windows::core::Interface::as_raw(self), dwentryindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn AddEntry<P0>(&self, ptoc: P0, pdwentryindex: *mut u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IToc>,
    {
        (::windows::core::Interface::vtable(self).AddEntry)(::windows::core::Interface::as_raw(self), ptoc.into_param().abi(), pdwentryindex).ok()
    }
    pub unsafe fn AddEntryByIndex<P0>(&self, dwentryindex: u32, ptoc: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IToc>,
    {
        (::windows::core::Interface::vtable(self).AddEntryByIndex)(::windows::core::Interface::as_raw(self), dwentryindex, ptoc.into_param().abi()).ok()
    }
    pub unsafe fn RemoveEntryByIndex(&self, dwentryindex: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveEntryByIndex)(::windows::core::Interface::as_raw(self), dwentryindex).ok()
    }
}
::windows::imp::interface_hierarchy!(ITocCollection, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ITocCollection {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ITocCollection {}
impl ::core::fmt::Debug for ITocCollection {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITocCollection").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ITocCollection {
    type Vtable = ITocCollection_Vtbl;
}
impl ::core::clone::Clone for ITocCollection {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ITocCollection {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x23fee831_ae96_42df_b170_25a04847a3ca);
}
#[repr(C)]
#[doc(hidden)]
pub struct ITocCollection_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetEntryCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwentrycount: *mut u32) -> ::windows::core::HRESULT,
    pub GetEntryByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwentryindex: u32, pptoc: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub AddEntry: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ptoc: *mut ::core::ffi::c_void, pdwentryindex: *mut u32) -> ::windows::core::HRESULT,
    pub AddEntryByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwentryindex: u32, ptoc: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RemoveEntryByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwentryindex: u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct ITocEntry(::windows::core::IUnknown);
impl ITocEntry {
    pub unsafe fn SetTitle<P0>(&self, pwsztitle: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).SetTitle)(::windows::core::Interface::as_raw(self), pwsztitle.into_param().abi()).ok()
    }
    pub unsafe fn GetTitle(&self, pwtitlesize: *mut u16, pwsztitle: ::windows::core::PWSTR) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetTitle)(::windows::core::Interface::as_raw(self), pwtitlesize, ::core::mem::transmute(pwsztitle)).ok()
    }
    pub unsafe fn SetDescriptor(&self, pdescriptor: *mut TOC_ENTRY_DESCRIPTOR) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetDescriptor)(::windows::core::Interface::as_raw(self), pdescriptor).ok()
    }
    pub unsafe fn GetDescriptor(&self, pdescriptor: *mut TOC_ENTRY_DESCRIPTOR) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDescriptor)(::windows::core::Interface::as_raw(self), pdescriptor).ok()
    }
    pub unsafe fn SetSubEntries(&self, dwnumsubentries: u32, pwsubentryindices: *mut u16) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetSubEntries)(::windows::core::Interface::as_raw(self), dwnumsubentries, pwsubentryindices).ok()
    }
    pub unsafe fn GetSubEntries(&self, pdwnumsubentries: *mut u32, pwsubentryindices: *mut u16) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetSubEntries)(::windows::core::Interface::as_raw(self), pdwnumsubentries, pwsubentryindices).ok()
    }
    pub unsafe fn SetDescriptionData(&self, dwdescriptiondatasize: u32, pbtdescriptiondata: *mut u8, pguidtype: *mut ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetDescriptionData)(::windows::core::Interface::as_raw(self), dwdescriptiondatasize, pbtdescriptiondata, pguidtype).ok()
    }
    pub unsafe fn GetDescriptionData(&self, pdwdescriptiondatasize: *mut u32, pbtdescriptiondata: *mut u8, pguidtype: *mut ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDescriptionData)(::windows::core::Interface::as_raw(self), pdwdescriptiondatasize, pbtdescriptiondata, pguidtype).ok()
    }
}
::windows::imp::interface_hierarchy!(ITocEntry, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ITocEntry {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ITocEntry {}
impl ::core::fmt::Debug for ITocEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITocEntry").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ITocEntry {
    type Vtable = ITocEntry_Vtbl;
}
impl ::core::clone::Clone for ITocEntry {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ITocEntry {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf22f5e06_585c_4def_8523_6555cfbc0cb3);
}
#[repr(C)]
#[doc(hidden)]
pub struct ITocEntry_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetTitle: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pwsztitle: ::windows::core::PCWSTR) -> ::windows::core::HRESULT,
    pub GetTitle: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pwtitlesize: *mut u16, pwsztitle: ::windows::core::PWSTR) -> ::windows::core::HRESULT,
    pub SetDescriptor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdescriptor: *mut TOC_ENTRY_DESCRIPTOR) -> ::windows::core::HRESULT,
    pub GetDescriptor: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdescriptor: *mut TOC_ENTRY_DESCRIPTOR) -> ::windows::core::HRESULT,
    pub SetSubEntries: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwnumsubentries: u32, pwsubentryindices: *mut u16) -> ::windows::core::HRESULT,
    pub GetSubEntries: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwnumsubentries: *mut u32, pwsubentryindices: *mut u16) -> ::windows::core::HRESULT,
    pub SetDescriptionData: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwdescriptiondatasize: u32, pbtdescriptiondata: *mut u8, pguidtype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub GetDescriptionData: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwdescriptiondatasize: *mut u32, pbtdescriptiondata: *mut u8, pguidtype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct ITocEntryList(::windows::core::IUnknown);
impl ITocEntryList {
    pub unsafe fn GetEntryCount(&self, pdwentrycount: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetEntryCount)(::windows::core::Interface::as_raw(self), pdwentrycount).ok()
    }
    pub unsafe fn GetEntryByIndex(&self, dwentryindex: u32) -> ::windows::core::Result<ITocEntry> {
        let mut result__ = ::windows::core::zeroed::<ITocEntry>();
        (::windows::core::Interface::vtable(self).GetEntryByIndex)(::windows::core::Interface::as_raw(self), dwentryindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn AddEntry<P0>(&self, pentry: P0, pdwentryindex: *mut u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ITocEntry>,
    {
        (::windows::core::Interface::vtable(self).AddEntry)(::windows::core::Interface::as_raw(self), pentry.into_param().abi(), pdwentryindex).ok()
    }
    pub unsafe fn AddEntryByIndex<P0>(&self, dwentryindex: u32, pentry: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ITocEntry>,
    {
        (::windows::core::Interface::vtable(self).AddEntryByIndex)(::windows::core::Interface::as_raw(self), dwentryindex, pentry.into_param().abi()).ok()
    }
    pub unsafe fn RemoveEntryByIndex(&self, dwentryindex: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveEntryByIndex)(::windows::core::Interface::as_raw(self), dwentryindex).ok()
    }
}
::windows::imp::interface_hierarchy!(ITocEntryList, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ITocEntryList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ITocEntryList {}
impl ::core::fmt::Debug for ITocEntryList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITocEntryList").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ITocEntryList {
    type Vtable = ITocEntryList_Vtbl;
}
impl ::core::clone::Clone for ITocEntryList {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ITocEntryList {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3a8cccbd_0efd_43a3_b838_f38a552ba237);
}
#[repr(C)]
#[doc(hidden)]
pub struct ITocEntryList_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetEntryCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwentrycount: *mut u32) -> ::windows::core::HRESULT,
    pub GetEntryByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwentryindex: u32, ppentry: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub AddEntry: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pentry: *mut ::core::ffi::c_void, pdwentryindex: *mut u32) -> ::windows::core::HRESULT,
    pub AddEntryByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwentryindex: u32, pentry: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub RemoveEntryByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwentryindex: u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct ITocParser(::windows::core::IUnknown);
impl ITocParser {
    pub unsafe fn Init<P0>(&self, pwszfilename: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).Init)(::windows::core::Interface::as_raw(self), pwszfilename.into_param().abi()).ok()
    }
    pub unsafe fn GetTocCount(&self, enumtocpostype: TOC_POS_TYPE, pdwtoccount: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetTocCount)(::windows::core::Interface::as_raw(self), enumtocpostype, pdwtoccount).ok()
    }
    pub unsafe fn GetTocByIndex(&self, enumtocpostype: TOC_POS_TYPE, dwtocindex: u32) -> ::windows::core::Result<IToc> {
        let mut result__ = ::windows::core::zeroed::<IToc>();
        (::windows::core::Interface::vtable(self).GetTocByIndex)(::windows::core::Interface::as_raw(self), enumtocpostype, dwtocindex, &mut result__).from_abi(result__)
    }
    pub unsafe fn GetTocByType(&self, enumtocpostype: TOC_POS_TYPE, guidtoctype: ::windows::core::GUID) -> ::windows::core::Result<ITocCollection> {
        let mut result__ = ::windows::core::zeroed::<ITocCollection>();
        (::windows::core::Interface::vtable(self).GetTocByType)(::windows::core::Interface::as_raw(self), enumtocpostype, ::core::mem::transmute(guidtoctype), &mut result__).from_abi(result__)
    }
    pub unsafe fn AddToc<P0>(&self, enumtocpostype: TOC_POS_TYPE, ptoc: P0, pdwtocindex: *mut u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<IToc>,
    {
        (::windows::core::Interface::vtable(self).AddToc)(::windows::core::Interface::as_raw(self), enumtocpostype, ptoc.into_param().abi(), pdwtocindex).ok()
    }
    pub unsafe fn RemoveTocByIndex(&self, enumtocpostype: TOC_POS_TYPE, dwtocindex: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveTocByIndex)(::windows::core::Interface::as_raw(self), enumtocpostype, dwtocindex).ok()
    }
    pub unsafe fn RemoveTocByType(&self, enumtocpostype: TOC_POS_TYPE, guidtoctype: ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RemoveTocByType)(::windows::core::Interface::as_raw(self), enumtocpostype, ::core::mem::transmute(guidtoctype)).ok()
    }
    pub unsafe fn Commit(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Commit)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(ITocParser, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ITocParser {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ITocParser {}
impl ::core::fmt::Debug for ITocParser {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ITocParser").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ITocParser {
    type Vtable = ITocParser_Vtbl;
}
impl ::core::clone::Clone for ITocParser {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ITocParser {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xecfb9a55_9298_4f49_887f_0b36206599d2);
}
#[repr(C)]
#[doc(hidden)]
pub struct ITocParser_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub Init: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pwszfilename: ::windows::core::PCWSTR) -> ::windows::core::HRESULT,
    pub GetTocCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, pdwtoccount: *mut u32) -> ::windows::core::HRESULT,
    pub GetTocByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, dwtocindex: u32, pptoc: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetTocByType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, guidtoctype: ::windows::core::GUID, pptocs: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub AddToc: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, ptoc: *mut ::core::ffi::c_void, pdwtocindex: *mut u32) -> ::windows::core::HRESULT,
    pub RemoveTocByIndex: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, dwtocindex: u32) -> ::windows::core::HRESULT,
    pub RemoveTocByType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, guidtoctype: ::windows::core::GUID) -> ::windows::core::HRESULT,
    pub Commit: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IValidateBinding(::windows::core::IUnknown);
impl IValidateBinding {
    pub unsafe fn GetIdentifier(&self, guidlicensorid: ::windows::core::GUID, pbephemeron: &[u8], ppbblobvalidationid: *mut *mut u8, pcbblobsize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetIdentifier)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(guidlicensorid), ::core::mem::transmute(pbephemeron.as_ptr()), pbephemeron.len() as _, ppbblobvalidationid, pcbblobsize).ok()
    }
}
::windows::imp::interface_hierarchy!(IValidateBinding, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IValidateBinding {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IValidateBinding {}
impl ::core::fmt::Debug for IValidateBinding {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IValidateBinding").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IValidateBinding {
    type Vtable = IValidateBinding_Vtbl;
}
impl ::core::clone::Clone for IValidateBinding {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IValidateBinding {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x04a578b2_e778_422a_a805_b3ee54d90bd9);
}
#[repr(C)]
#[doc(hidden)]
pub struct IValidateBinding_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetIdentifier: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidlicensorid: ::windows::core::GUID, pbephemeron: *const u8, cbephemeron: u32, ppbblobvalidationid: *mut *mut u8, pcbblobsize: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IWMCodecLeakyBucket(::windows::core::IUnknown);
impl IWMCodecLeakyBucket {
    pub unsafe fn SetBufferSizeBits(&self, ulbuffersize: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetBufferSizeBits)(::windows::core::Interface::as_raw(self), ulbuffersize).ok()
    }
    pub unsafe fn GetBufferSizeBits(&self, pulbuffersize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetBufferSizeBits)(::windows::core::Interface::as_raw(self), pulbuffersize).ok()
    }
    pub unsafe fn SetBufferFullnessBits(&self, ulbufferfullness: u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetBufferFullnessBits)(::windows::core::Interface::as_raw(self), ulbufferfullness).ok()
    }
    pub unsafe fn GetBufferFullnessBits(&self, pulbufferfullness: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetBufferFullnessBits)(::windows::core::Interface::as_raw(self), pulbufferfullness).ok()
    }
}
::windows::imp::interface_hierarchy!(IWMCodecLeakyBucket, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IWMCodecLeakyBucket {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IWMCodecLeakyBucket {}
impl ::core::fmt::Debug for IWMCodecLeakyBucket {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWMCodecLeakyBucket").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IWMCodecLeakyBucket {
    type Vtable = IWMCodecLeakyBucket_Vtbl;
}
impl ::core::clone::Clone for IWMCodecLeakyBucket {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IWMCodecLeakyBucket {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa81ba647_6227_43b7_b231_c7b15135dd7d);
}
#[repr(C)]
#[doc(hidden)]
pub struct IWMCodecLeakyBucket_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetBufferSizeBits: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ulbuffersize: u32) -> ::windows::core::HRESULT,
    pub GetBufferSizeBits: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pulbuffersize: *mut u32) -> ::windows::core::HRESULT,
    pub SetBufferFullnessBits: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, ulbufferfullness: u32) -> ::windows::core::HRESULT,
    pub GetBufferFullnessBits: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pulbufferfullness: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IWMCodecOutputTimestamp(::windows::core::IUnknown);
impl IWMCodecOutputTimestamp {
    pub unsafe fn GetNextOutputTime(&self, prttime: *mut i64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetNextOutputTime)(::windows::core::Interface::as_raw(self), prttime).ok()
    }
}
::windows::imp::interface_hierarchy!(IWMCodecOutputTimestamp, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IWMCodecOutputTimestamp {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IWMCodecOutputTimestamp {}
impl ::core::fmt::Debug for IWMCodecOutputTimestamp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWMCodecOutputTimestamp").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IWMCodecOutputTimestamp {
    type Vtable = IWMCodecOutputTimestamp_Vtbl;
}
impl ::core::clone::Clone for IWMCodecOutputTimestamp {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IWMCodecOutputTimestamp {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb72adf95_7adc_4a72_bc05_577d8ea6bf68);
}
#[repr(C)]
#[doc(hidden)]
pub struct IWMCodecOutputTimestamp_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetNextOutputTime: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, prttime: *mut i64) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IWMCodecPrivateData(::windows::core::IUnknown);
impl IWMCodecPrivateData {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Media_DxMediaObjects\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_DxMediaObjects"))]
    pub unsafe fn SetPartialOutputType(&self, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetPartialOutputType)(::windows::core::Interface::as_raw(self), pmt).ok()
    }
    pub unsafe fn GetPrivateData(&self, pbdata: *mut u8, pcbdata: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetPrivateData)(::windows::core::Interface::as_raw(self), pbdata, pcbdata).ok()
    }
}
::windows::imp::interface_hierarchy!(IWMCodecPrivateData, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IWMCodecPrivateData {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IWMCodecPrivateData {}
impl ::core::fmt::Debug for IWMCodecPrivateData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWMCodecPrivateData").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IWMCodecPrivateData {
    type Vtable = IWMCodecPrivateData_Vtbl;
}
impl ::core::clone::Clone for IWMCodecPrivateData {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IWMCodecPrivateData {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x73f0be8e_57f7_4f01_aa66_9f57340cfe0e);
}
#[repr(C)]
#[doc(hidden)]
pub struct IWMCodecPrivateData_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_DxMediaObjects"))]
    pub SetPartialOutputType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Media_DxMediaObjects")))]
    SetPartialOutputType: usize,
    pub GetPrivateData: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbdata: *mut u8, pcbdata: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IWMCodecProps(::windows::core::IUnknown);
impl IWMCodecProps {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Media_DxMediaObjects\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_DxMediaObjects"))]
    pub unsafe fn GetFormatProp<P0>(&self, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE, pszname: P0, ptype: *mut WMT_PROP_DATATYPE, pvalue: *mut u8, pdwsize: *mut u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).GetFormatProp)(::windows::core::Interface::as_raw(self), pmt, pszname.into_param().abi(), ptype, pvalue, pdwsize).ok()
    }
    pub unsafe fn GetCodecProp<P0>(&self, dwformat: u32, pszname: P0, ptype: *mut WMT_PROP_DATATYPE, pvalue: *mut u8, pdwsize: *mut u32) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).GetCodecProp)(::windows::core::Interface::as_raw(self), dwformat, pszname.into_param().abi(), ptype, pvalue, pdwsize).ok()
    }
}
::windows::imp::interface_hierarchy!(IWMCodecProps, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IWMCodecProps {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IWMCodecProps {}
impl ::core::fmt::Debug for IWMCodecProps {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWMCodecProps").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IWMCodecProps {
    type Vtable = IWMCodecProps_Vtbl;
}
impl ::core::clone::Clone for IWMCodecProps {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IWMCodecProps {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2573e11a_f01a_4fdd_a98d_63b8e0ba9589);
}
#[repr(C)]
#[doc(hidden)]
pub struct IWMCodecProps_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_DxMediaObjects"))]
    pub GetFormatProp: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE, pszname: ::windows::core::PCWSTR, ptype: *mut WMT_PROP_DATATYPE, pvalue: *mut u8, pdwsize: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Media_DxMediaObjects")))]
    GetFormatProp: usize,
    pub GetCodecProp: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, dwformat: u32, pszname: ::windows::core::PCWSTR, ptype: *mut WMT_PROP_DATATYPE, pvalue: *mut u8, pdwsize: *mut u32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IWMCodecStrings(::windows::core::IUnknown);
impl IWMCodecStrings {
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Media_DxMediaObjects\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_DxMediaObjects"))]
    pub unsafe fn GetName(&self, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE, szname: ::core::option::Option<&mut [u16]>, pcchlength: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetName)(::windows::core::Interface::as_raw(self), pmt, szname.as_deref().map_or(0, |slice| slice.len() as _), ::core::mem::transmute(szname.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr())), pcchlength).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`, `\"Win32_Media_DxMediaObjects\"`*"]
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_DxMediaObjects"))]
    pub unsafe fn GetDescription(&self, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE, szdescription: ::core::option::Option<&mut [u16]>, pcchlength: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDescription)(::windows::core::Interface::as_raw(self), pmt, szdescription.as_deref().map_or(0, |slice| slice.len() as _), ::core::mem::transmute(szdescription.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr())), pcchlength).ok()
    }
}
::windows::imp::interface_hierarchy!(IWMCodecStrings, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IWMCodecStrings {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IWMCodecStrings {}
impl ::core::fmt::Debug for IWMCodecStrings {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWMCodecStrings").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IWMCodecStrings {
    type Vtable = IWMCodecStrings_Vtbl;
}
impl ::core::clone::Clone for IWMCodecStrings {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IWMCodecStrings {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa7b2504b_e58a_47fb_958b_cac7165a057d);
}
#[repr(C)]
#[doc(hidden)]
pub struct IWMCodecStrings_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_DxMediaObjects"))]
    pub GetName: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE, cchlength: u32, szname: ::windows::core::PWSTR, pcchlength: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Media_DxMediaObjects")))]
    GetName: usize,
    #[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_DxMediaObjects"))]
    pub GetDescription: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE, cchlength: u32, szdescription: ::windows::core::PWSTR, pcchlength: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(not(all(feature = "Win32_Foundation", feature = "Win32_Media_DxMediaObjects")))]
    GetDescription: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IWMColorConvProps(::windows::core::IUnknown);
impl IWMColorConvProps {
    pub unsafe fn SetMode(&self, lmode: i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetMode)(::windows::core::Interface::as_raw(self), lmode).ok()
    }
    pub unsafe fn SetFullCroppingParam(&self, lsrccropleft: i32, lsrccroptop: i32, ldstcropleft: i32, ldstcroptop: i32, lcropwidth: i32, lcropheight: i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetFullCroppingParam)(::windows::core::Interface::as_raw(self), lsrccropleft, lsrccroptop, ldstcropleft, ldstcroptop, lcropwidth, lcropheight).ok()
    }
}
::windows::imp::interface_hierarchy!(IWMColorConvProps, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IWMColorConvProps {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IWMColorConvProps {}
impl ::core::fmt::Debug for IWMColorConvProps {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWMColorConvProps").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IWMColorConvProps {
    type Vtable = IWMColorConvProps_Vtbl;
}
impl ::core::clone::Clone for IWMColorConvProps {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IWMColorConvProps {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe6a49e22_c099_421d_aad3_c061fb4ae85b);
}
#[repr(C)]
#[doc(hidden)]
pub struct IWMColorConvProps_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, lmode: i32) -> ::windows::core::HRESULT,
    pub SetFullCroppingParam: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, lsrccropleft: i32, lsrccroptop: i32, ldstcropleft: i32, ldstcroptop: i32, lcropwidth: i32, lcropheight: i32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IWMColorLegalizerProps(::windows::core::IUnknown);
impl IWMColorLegalizerProps {
    pub unsafe fn SetColorLegalizerQuality(&self, lquality: i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetColorLegalizerQuality)(::windows::core::Interface::as_raw(self), lquality).ok()
    }
}
::windows::imp::interface_hierarchy!(IWMColorLegalizerProps, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IWMColorLegalizerProps {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IWMColorLegalizerProps {}
impl ::core::fmt::Debug for IWMColorLegalizerProps {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWMColorLegalizerProps").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IWMColorLegalizerProps {
    type Vtable = IWMColorLegalizerProps_Vtbl;
}
impl ::core::clone::Clone for IWMColorLegalizerProps {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IWMColorLegalizerProps {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x776c93b3_b72d_4508_b6d0_208785f553e7);
}
#[repr(C)]
#[doc(hidden)]
pub struct IWMColorLegalizerProps_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetColorLegalizerQuality: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, lquality: i32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IWMFrameInterpProps(::windows::core::IUnknown);
impl IWMFrameInterpProps {
    pub unsafe fn SetFrameRateIn(&self, lframerate: i32, lscale: i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetFrameRateIn)(::windows::core::Interface::as_raw(self), lframerate, lscale).ok()
    }
    pub unsafe fn SetFrameRateOut(&self, lframerate: i32, lscale: i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetFrameRateOut)(::windows::core::Interface::as_raw(self), lframerate, lscale).ok()
    }
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetFrameInterpEnabled<P0>(&self, bfienabled: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetFrameInterpEnabled)(::windows::core::Interface::as_raw(self), bfienabled.into_param().abi()).ok()
    }
    pub unsafe fn SetComplexityLevel(&self, icomplexity: i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetComplexityLevel)(::windows::core::Interface::as_raw(self), icomplexity).ok()
    }
}
::windows::imp::interface_hierarchy!(IWMFrameInterpProps, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IWMFrameInterpProps {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IWMFrameInterpProps {}
impl ::core::fmt::Debug for IWMFrameInterpProps {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWMFrameInterpProps").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IWMFrameInterpProps {
    type Vtable = IWMFrameInterpProps_Vtbl;
}
impl ::core::clone::Clone for IWMFrameInterpProps {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IWMFrameInterpProps {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4c06bb9b_626c_4614_8329_cc6a21b93fa0);
}
#[repr(C)]
#[doc(hidden)]
pub struct IWMFrameInterpProps_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetFrameRateIn: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, lframerate: i32, lscale: i32) -> ::windows::core::HRESULT,
    pub SetFrameRateOut: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, lframerate: i32, lscale: i32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Foundation")]
    pub SetFrameInterpEnabled: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, bfienabled: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetFrameInterpEnabled: usize,
    pub SetComplexityLevel: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, icomplexity: i32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IWMInterlaceProps(::windows::core::IUnknown);
impl IWMInterlaceProps {
    pub unsafe fn SetProcessType(&self, iprocesstype: i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetProcessType)(::windows::core::Interface::as_raw(self), iprocesstype).ok()
    }
    pub unsafe fn SetInitInverseTeleCinePattern(&self, iinitpattern: i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetInitInverseTeleCinePattern)(::windows::core::Interface::as_raw(self), iinitpattern).ok()
    }
    pub unsafe fn SetLastFrame(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetLastFrame)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IWMInterlaceProps, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IWMInterlaceProps {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IWMInterlaceProps {}
impl ::core::fmt::Debug for IWMInterlaceProps {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWMInterlaceProps").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IWMInterlaceProps {
    type Vtable = IWMInterlaceProps_Vtbl;
}
impl ::core::clone::Clone for IWMInterlaceProps {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IWMInterlaceProps {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7b12e5d1_bd22_48ea_bc06_98e893221c89);
}
#[repr(C)]
#[doc(hidden)]
pub struct IWMInterlaceProps_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetProcessType: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, iprocesstype: i32) -> ::windows::core::HRESULT,
    pub SetInitInverseTeleCinePattern: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, iinitpattern: i32) -> ::windows::core::HRESULT,
    pub SetLastFrame: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IWMResamplerProps(::windows::core::IUnknown);
impl IWMResamplerProps {
    pub unsafe fn SetHalfFilterLength(&self, lhalffilterlen: i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetHalfFilterLength)(::windows::core::Interface::as_raw(self), lhalffilterlen).ok()
    }
    pub unsafe fn SetUserChannelMtx(&self, userchannelmtx: *mut f32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetUserChannelMtx)(::windows::core::Interface::as_raw(self), userchannelmtx).ok()
    }
}
::windows::imp::interface_hierarchy!(IWMResamplerProps, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IWMResamplerProps {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IWMResamplerProps {}
impl ::core::fmt::Debug for IWMResamplerProps {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWMResamplerProps").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IWMResamplerProps {
    type Vtable = IWMResamplerProps_Vtbl;
}
impl ::core::clone::Clone for IWMResamplerProps {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IWMResamplerProps {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe7e9984f_f09f_4da4_903f_6e2e0efe56b5);
}
#[repr(C)]
#[doc(hidden)]
pub struct IWMResamplerProps_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetHalfFilterLength: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, lhalffilterlen: i32) -> ::windows::core::HRESULT,
    pub SetUserChannelMtx: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, userchannelmtx: *mut f32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IWMResizerProps(::windows::core::IUnknown);
impl IWMResizerProps {
    pub unsafe fn SetResizerQuality(&self, lquality: i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetResizerQuality)(::windows::core::Interface::as_raw(self), lquality).ok()
    }
    pub unsafe fn SetInterlaceMode(&self, lmode: i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetInterlaceMode)(::windows::core::Interface::as_raw(self), lmode).ok()
    }
    pub unsafe fn SetClipRegion(&self, lcliporixsrc: i32, lcliporiysrc: i32, lclipwidthsrc: i32, lclipheightsrc: i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetClipRegion)(::windows::core::Interface::as_raw(self), lcliporixsrc, lcliporiysrc, lclipwidthsrc, lclipheightsrc).ok()
    }
    pub unsafe fn SetFullCropRegion(&self, lcliporixsrc: i32, lcliporiysrc: i32, lclipwidthsrc: i32, lclipheightsrc: i32, lcliporixdst: i32, lcliporiydst: i32, lclipwidthdst: i32, lclipheightdst: i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetFullCropRegion)(::windows::core::Interface::as_raw(self), lcliporixsrc, lcliporiysrc, lclipwidthsrc, lclipheightsrc, lcliporixdst, lcliporiydst, lclipwidthdst, lclipheightdst).ok()
    }
    pub unsafe fn GetFullCropRegion(&self, lcliporixsrc: *mut i32, lcliporiysrc: *mut i32, lclipwidthsrc: *mut i32, lclipheightsrc: *mut i32, lcliporixdst: *mut i32, lcliporiydst: *mut i32, lclipwidthdst: *mut i32, lclipheightdst: *mut i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetFullCropRegion)(::windows::core::Interface::as_raw(self), lcliporixsrc, lcliporiysrc, lclipwidthsrc, lclipheightsrc, lcliporixdst, lcliporiydst, lclipwidthdst, lclipheightdst).ok()
    }
}
::windows::imp::interface_hierarchy!(IWMResizerProps, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IWMResizerProps {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IWMResizerProps {}
impl ::core::fmt::Debug for IWMResizerProps {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWMResizerProps").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IWMResizerProps {
    type Vtable = IWMResizerProps_Vtbl;
}
impl ::core::clone::Clone for IWMResizerProps {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IWMResizerProps {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x57665d4c_0414_4faa_905b_10e546f81c33);
}
#[repr(C)]
#[doc(hidden)]
pub struct IWMResizerProps_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetResizerQuality: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, lquality: i32) -> ::windows::core::HRESULT,
    pub SetInterlaceMode: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, lmode: i32) -> ::windows::core::HRESULT,
    pub SetClipRegion: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, lcliporixsrc: i32, lcliporiysrc: i32, lclipwidthsrc: i32, lclipheightsrc: i32) -> ::windows::core::HRESULT,
    pub SetFullCropRegion: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, lcliporixsrc: i32, lcliporiysrc: i32, lclipwidthsrc: i32, lclipheightsrc: i32, lcliporixdst: i32, lcliporiydst: i32, lclipwidthdst: i32, lclipheightdst: i32) -> ::windows::core::HRESULT,
    pub GetFullCropRegion: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, lcliporixsrc: *mut i32, lcliporiysrc: *mut i32, lclipwidthsrc: *mut i32, lclipheightsrc: *mut i32, lcliporixdst: *mut i32, lcliporiydst: *mut i32, lclipwidthdst: *mut i32, lclipheightdst: *mut i32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IWMSampleExtensionSupport(::windows::core::IUnknown);
impl IWMSampleExtensionSupport {
    #[doc = "*Required features: `\"Win32_Foundation\"`*"]
    #[cfg(feature = "Win32_Foundation")]
    pub unsafe fn SetUseSampleExtensions<P0>(&self, fuseextensions: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::super::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetUseSampleExtensions)(::windows::core::Interface::as_raw(self), fuseextensions.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IWMSampleExtensionSupport, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IWMSampleExtensionSupport {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IWMSampleExtensionSupport {}
impl ::core::fmt::Debug for IWMSampleExtensionSupport {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWMSampleExtensionSupport").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IWMSampleExtensionSupport {
    type Vtable = IWMSampleExtensionSupport_Vtbl;
}
impl ::core::clone::Clone for IWMSampleExtensionSupport {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IWMSampleExtensionSupport {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9bca9884_0604_4c2a_87da_793ff4d586c3);
}
#[repr(C)]
#[doc(hidden)]
pub struct IWMSampleExtensionSupport_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    #[cfg(feature = "Win32_Foundation")]
    pub SetUseSampleExtensions: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, fuseextensions: super::super::Foundation::BOOL) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Foundation"))]
    SetUseSampleExtensions: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IWMValidate(::windows::core::IUnknown);
impl IWMValidate {
    pub unsafe fn SetIdentifier(&self, guidvalidationid: ::windows::core::GUID) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetIdentifier)(::windows::core::Interface::as_raw(self), ::core::mem::transmute(guidvalidationid)).ok()
    }
}
::windows::imp::interface_hierarchy!(IWMValidate, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IWMValidate {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IWMValidate {}
impl ::core::fmt::Debug for IWMValidate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWMValidate").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IWMValidate {
    type Vtable = IWMValidate_Vtbl;
}
impl ::core::clone::Clone for IWMValidate {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IWMValidate {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xcee3def2_3808_414d_be66_fafd472210bc);
}
#[repr(C)]
#[doc(hidden)]
pub struct IWMValidate_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetIdentifier: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, guidvalidationid: ::windows::core::GUID) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IWMVideoDecoderHurryup(::windows::core::IUnknown);
impl IWMVideoDecoderHurryup {
    pub unsafe fn SetHurryup(&self, lhurryup: i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetHurryup)(::windows::core::Interface::as_raw(self), lhurryup).ok()
    }
    pub unsafe fn GetHurryup(&self, plhurryup: *mut i32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetHurryup)(::windows::core::Interface::as_raw(self), plhurryup).ok()
    }
}
::windows::imp::interface_hierarchy!(IWMVideoDecoderHurryup, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IWMVideoDecoderHurryup {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IWMVideoDecoderHurryup {}
impl ::core::fmt::Debug for IWMVideoDecoderHurryup {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWMVideoDecoderHurryup").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IWMVideoDecoderHurryup {
    type Vtable = IWMVideoDecoderHurryup_Vtbl;
}
impl ::core::clone::Clone for IWMVideoDecoderHurryup {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IWMVideoDecoderHurryup {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x352bb3bd_2d4d_4323_9e71_dcdcfbd53ca6);
}
#[repr(C)]
#[doc(hidden)]
pub struct IWMVideoDecoderHurryup_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetHurryup: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, lhurryup: i32) -> ::windows::core::HRESULT,
    pub GetHurryup: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, plhurryup: *mut i32) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IWMVideoDecoderReconBuffer(::windows::core::IUnknown);
impl IWMVideoDecoderReconBuffer {
    pub unsafe fn GetReconstructedVideoFrameSize(&self, pdwsize: *mut u32) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetReconstructedVideoFrameSize)(::windows::core::Interface::as_raw(self), pdwsize).ok()
    }
    #[doc = "*Required features: `\"Win32_Media_DxMediaObjects\"`*"]
    #[cfg(feature = "Win32_Media_DxMediaObjects")]
    pub unsafe fn GetReconstructedVideoFrame<P0>(&self, pbuf: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::DxMediaObjects::IMediaBuffer>,
    {
        (::windows::core::Interface::vtable(self).GetReconstructedVideoFrame)(::windows::core::Interface::as_raw(self), pbuf.into_param().abi()).ok()
    }
    #[doc = "*Required features: `\"Win32_Media_DxMediaObjects\"`*"]
    #[cfg(feature = "Win32_Media_DxMediaObjects")]
    pub unsafe fn SetReconstructedVideoFrame<P0>(&self, pbuf: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<super::DxMediaObjects::IMediaBuffer>,
    {
        (::windows::core::Interface::vtable(self).SetReconstructedVideoFrame)(::windows::core::Interface::as_raw(self), pbuf.into_param().abi()).ok()
    }
}
::windows::imp::interface_hierarchy!(IWMVideoDecoderReconBuffer, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IWMVideoDecoderReconBuffer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IWMVideoDecoderReconBuffer {}
impl ::core::fmt::Debug for IWMVideoDecoderReconBuffer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWMVideoDecoderReconBuffer").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IWMVideoDecoderReconBuffer {
    type Vtable = IWMVideoDecoderReconBuffer_Vtbl;
}
impl ::core::clone::Clone for IWMVideoDecoderReconBuffer {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IWMVideoDecoderReconBuffer {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x45bda2ac_88e2_4923_98ba_3949080711a3);
}
#[repr(C)]
#[doc(hidden)]
pub struct IWMVideoDecoderReconBuffer_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetReconstructedVideoFrameSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pdwsize: *mut u32) -> ::windows::core::HRESULT,
    #[cfg(feature = "Win32_Media_DxMediaObjects")]
    pub GetReconstructedVideoFrame: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbuf: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Media_DxMediaObjects"))]
    GetReconstructedVideoFrame: usize,
    #[cfg(feature = "Win32_Media_DxMediaObjects")]
    pub SetReconstructedVideoFrame: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pbuf: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    #[cfg(not(feature = "Win32_Media_DxMediaObjects"))]
    SetReconstructedVideoFrame: usize,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct IWMVideoForceKeyFrame(::windows::core::IUnknown);
impl IWMVideoForceKeyFrame {
    pub unsafe fn SetKeyFrame(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetKeyFrame)(::windows::core::Interface::as_raw(self)).ok()
    }
}
::windows::imp::interface_hierarchy!(IWMVideoForceKeyFrame, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for IWMVideoForceKeyFrame {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for IWMVideoForceKeyFrame {}
impl ::core::fmt::Debug for IWMVideoForceKeyFrame {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("IWMVideoForceKeyFrame").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for IWMVideoForceKeyFrame {
    type Vtable = IWMVideoForceKeyFrame_Vtbl;
}
impl ::core::clone::Clone for IWMVideoForceKeyFrame {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for IWMVideoForceKeyFrame {
    const IID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9f8496be_5b9a_41b9_a9e8_f21cd80596c2);
}
#[repr(C)]
#[doc(hidden)]
pub struct IWMVideoForceKeyFrame_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetKeyFrame: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
pub struct MFASYNCRESULT(::windows::core::IUnknown);
impl MFASYNCRESULT {
    pub unsafe fn GetState(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::IUnknown>();
        (::windows::core::Interface::vtable(self).base__.GetState)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStatus(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetStatus)(::windows::core::Interface::as_raw(self)).ok()
    }
    pub unsafe fn SetStatus(&self, hrstatus: ::windows::core::HRESULT) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.SetStatus)(::windows::core::Interface::as_raw(self), hrstatus).ok()
    }
    pub unsafe fn GetObject(&self) -> ::windows::core::Result<::windows::core::IUnknown> {
        let mut result__ = ::windows::core::zeroed::<::windows::core::IUnknown>();
        (::windows::core::Interface::vtable(self).base__.GetObject)(::windows::core::Interface::as_raw(self), &mut result__).from_abi(result__)
    }
    pub unsafe fn GetStateNoAddRef(&self) -> ::core::option::Option<::windows::core::IUnknown> {
        (::windows::core::Interface::vtable(self).base__.GetStateNoAddRef)(::windows::core::Interface::as_raw(self))
    }
}
::windows::imp::interface_hierarchy!(MFASYNCRESULT, ::windows::core::IUnknown, IMFAsyncResult);
impl ::core::cmp::PartialEq for MFASYNCRESULT {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for MFASYNCRESULT {}
impl ::core::fmt::Debug for MFASYNCRESULT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFASYNCRESULT").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for MFASYNCRESULT {
    type Vtable = MFASYNCRESULT_Vtbl;
}
impl ::core::clone::Clone for MFASYNCRESULT {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for MFASYNCRESULT {
    const IID: ::windows::core::GUID = ::windows::core::GUID::zeroed();
}
#[repr(C)]
#[doc(hidden)]
pub struct MFASYNCRESULT_Vtbl {
    pub base__: IMFAsyncResult_Vtbl,
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AACMFTEncoder: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x93af0c51_2275_45d2_a35b_f2ba21caed00);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AEC_MAX_SYSTEM_MODES: u32 = 6u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const ALawCodecWrapper: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x36cb6e0c_78c1_42b2_9943_846262f31786);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AMPROPSETID_Pin: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9b00f101_1567_11d1_b3f1_00aa003761c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AM_MEDIA_TYPE_REPRESENTATION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe2e42ad2_132c_491e_a268_3c7c2dca181f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AVENC_H263V_LEVELCOUNT: u32 = 8u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AVENC_H264V_LEVELCOUNT: u32 = 16u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AVENC_H264V_MAX_MBBITS: u32 = 3200u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CAC3DecMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x03d7c802_ecfa_47d9_b268_5fb3e310dee4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CAPTION_FORMAT_ATSC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3ed9cb31_fd10_4ade_bccc_fb9105d2f3ef);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CAPTION_FORMAT_DIRECTV: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe9ca1ce7_915e_47be_9bb9_bf1d8a13a5ec);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CAPTION_FORMAT_DVB: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x12230db4_ff2a_447e_bb88_6841c416d068);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CAPTION_FORMAT_ECHOSTAR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xebb1a262_1158_4b99_ae80_92ac776952c4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CClusterDetectorDmo: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x36e820c4_165a_4521_863c_619e1160d4d4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CColorControlDmo: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x798059f0_89ca_4160_b325_aeb48efe4f9a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CColorConvertDMO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x98230571_0087_4204_b020_3282538e57d3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CColorLegalizerDmo: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfdfaa753_e48e_4e33_9c74_98a27fc6726a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CDTVAudDecoderDS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8e269032_fe03_4753_9b17_18253c21722e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CDTVVidDecoderDS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x64777dc8_4e24_4beb_9d19_60a35be1daaf);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CDVDecoderMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe54709c5_1e17_4c8d_94e7_478940433584);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CDVEncoderMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc82ae729_c327_4cce_914d_8171fefebefb);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CDeColorConvMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x49034c05_f43c_400f_84c1_90a683195a3a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CFrameInterpDMO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0a7cfe1b_6ab5_4334_9ed8_3f97cb37daa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CFrameRateConvertDmo: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x01f36ce2_0907_4d8b_979d_f151be91c883);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CInterlaceMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb5a89c80_4901_407b_9abc_90d9a644bb46);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_ACMWrapper: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6a08cf80_0e18_11cf_a24d_0020afd79767);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_ATSCNetworkPropertyPage: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe3444d16_5ac4_4386_88df_13fd230e1dda);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_ATSCNetworkProvider: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0dad2fdd_5fd7_11d3_8f50_00c04f7971e2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_AVICo: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd76e2820_1563_11cf_ac98_00aa004c0fa9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_AVIDec: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xcf49d4e0_1115_11ce_b03a_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_AVIDoc: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd3588ab0_0781_11ce_b03a_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_AVIDraw: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa888df60_1e90_11cf_ac98_00aa004c0fa9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_AVIMIDIRender: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x07b65360_c445_11ce_afde_00aa006c14f4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_ActiveMovieCategories: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xda4e3da0_d07d_11d0_bd50_00a0c911ce86);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_AllocPresenter: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x99d54f63_1a69_41ae_aa4d_c976eb3f0713);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_AllocPresenterDDXclMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4444ac9e_242e_471b_a3c7_45dcd46352bc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_AnalogVideoDecoderPropertyPage: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x71f96466_78f3_11d0_a18c_00a0c9118956);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_AsyncReader: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436ebb5_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_AudioCompressorCategory: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x33d9a761_90c8_11d0_bd43_00a0c911ce86);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_AudioInputDeviceCategory: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x33d9a762_90c8_11d0_bd43_00a0c911ce86);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_AudioInputMixerProperties: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2ca8ca52_3c3f_11d2_b73d_00c04fb6bd3d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_AudioProperties: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x05589faf_c356_11ce_bf01_00aa0055595a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_AudioRecord: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe30629d2_27e5_11ce_875d_00608cb78066);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_AudioRender: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe30629d1_27e5_11ce_875d_00608cb78066);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_AudioRendererAdvancedProperties: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x37e92a92_d9aa_11d2_bf84_8ef2b1555aed);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_AudioRendererCategory: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe0f158e1_cb04_11d0_bd4e_00a0c911ce86);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_AudioResamplerMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf447b69e_1884_4a7e_8055_346f74d6edb3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_AviDest: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe2510970_f137_11ce_8b67_00aa00a3f1a6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_AviMuxProptyPage: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc647b5c0_157c_11d0_bd23_00a0c911ce86);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_AviMuxProptyPage1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0a9ae910_85c0_11d0_bd42_00a0c911ce86);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_AviReader: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b544c21_fd0b_11ce_8c63_00aa0044b51e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_AviSplitter: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b544c20_fd0b_11ce_8c63_00aa0044b51e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CAcmCoClassManager: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x33d9a761_90c8_11d0_bd43_00a0c911ce86);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CAsfTocParser: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9b77c0f2_8735_46c5_b90f_5f0b303ef6ab);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CAviTocParser: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3adce5cc_13c8_4573_b328_ed438eb694f9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CCAFilter: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3d07a539_35ca_447c_9b05_8d85ce924f9e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CClusterDetectorEx: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x47354492_827e_4b8a_b318_c80eba1381f0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CDeviceMoniker: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4315d437_5b8c_11d0_bd3b_00a0c911ce86);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CFileClient: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbfccd195_1244_4840_ab44_480975c4ffe4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CFileIo: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x11993195_1244_4840_ab44_480975c4ffe4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CIcmCoClassManager: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x33d9a760_90c8_11d0_bd43_00a0c911ce86);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CMidiOutClassManager: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4efe2452_168a_11d1_bc76_00c04fb9453b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CMpegAudioCodec: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4a2286e0_7bef_11ce_9bd9_0000e202599c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CMpegVideoCodec: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfeb50740_7bef_11ce_9bd9_0000e202599c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CQzFilterClassManager: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x083863f1_70de_11d0_bd40_00a0c911ce86);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CToc: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4fe24495_28ce_4920_a4c4_e556e1f0df2a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CTocCollection: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5058292d_a244_4840_ab44_480975c4ffe4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CTocEntry: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf22f5e05_585c_4def_8523_6555cfbc0cb3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CTocEntryList: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3a8cccbc_0efd_43a3_b838_f38a552ba237);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CTocParser: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x499eaeea_2737_4849_8bb6_47f107eaf358);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CVidCapClassManager: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x860bb310_5d01_11d0_bd3b_00a0c911ce86);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CWaveOutClassManager: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe0f158e1_cb04_11d0_bd4e_00a0c911ce86);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CWaveinClassManager: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x33d9a762_90c8_11d0_bd43_00a0c911ce86);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CameraConfigurationManager: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6c92b540_5854_4a17_92b6_ac89c96e9683);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CameraControlPropertyPage: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x71f96465_78f3_11d0_a18c_00a0c9118956);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CaptionsFilter: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2f7ee4b6_6ff5_4eb4_b24a_2bfc41117171);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CaptureGraphBuilder: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbf87b6e0_8c27_11d0_b3f0_00aa003761c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CaptureGraphBuilder2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbf87b6e1_8c27_11d0_b3f0_00aa003761c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CaptureProperties: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b544c22_fd0b_11ce_8c63_00aa0044b51f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_Colour: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1643e180_90f5_11ce_97d5_00aa0055595a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CreateMediaExtensionObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xef65a54d_0788_45b8_8b14_bc0f6a6b5137);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_CrossbarFilterPropertyPage: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x71f96461_78f3_11d0_a18c_00a0c9118956);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_DShowTVEFilter: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x05500280_faa5_4df9_8246_bfc23ac5cea8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_DSoundRender: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x79376820_07d0_11cf_a24d_0020afd79767);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_DVBCNetworkProvider: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdc0c0fe7_0485_4266_b93f_68fbf80ed834);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_DVBSNetworkProvider: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfa4b375a_45b4_4d45_8440_263957b11623);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_DVBTNetworkProvider: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x216c62df_6d7f_4e9a_8571_05f14edb766a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_DVDHWDecodersCategory: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2721ae20_7e70_11d0_a5d6_28db04c10000);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_DVDNavigator: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9b8c4620_2c1a_11d0_8493_00a02438ad48);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_DVDState: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf963c5cf_a659_4a93_9638_caf3cd277d13);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_DVDecPropertiesPage: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x101193c0_0bfe_11d0_af91_00aa00b67a42);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_DVEncPropertiesPage: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4150f050_bb6f_11d0_afb9_00aa00b67a42);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_DVMux: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x129d7e40_c10d_11d0_afb9_00aa00b67a42);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_DVMuxPropertyPage: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4db880e0_c10d_11d0_afb9_00aa00b67a42);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_DVSplitter: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4eb31670_9fc6_11cf_af6e_00aa00b67a42);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_DVVideoCodec: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb1b77c00_c3e4_11cf_af79_00aa00b67a42);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_DVVideoEnc: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x13aa3650_bb6f_11d0_afb9_00aa00b67a42);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_DeviceControlCategory: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xcc7bfb46_f175_11d1_a392_00e0291f3959);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_DirectDrawProperties: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x944d4c00_dd52_11ce_bf0e_00aa0055595a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_DirectShowPluginControl: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8670c736_f614_427b_8ada_bbadc587194b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_Dither: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1da08500_9edc_11cf_bc10_00aa00ac74f6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_DtvCcFilter: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfb056ba0_2502_45b9_8e86_2b40de84ad29);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_DvdGraphBuilder: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfcc152b7_f372_11d0_8e00_00c04fd7c08b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_EVRPlaybackPipelineOptimizer: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x62079164_233b_41f8_a80f_f01705f514a8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_EVRTearlessWindowPresenter9: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa0a7a57b_59b2_4919_a694_add0a526c373);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_EnhancedVideoRenderer: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfa10746c_9b63_4b6c_bc49_fc300ea5f256);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_FGControl: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436ebb4_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_FileSource: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x701722e0_8ae3_11ce_a85c_00aa002feab5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_FileWriter: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8596e5f0_0da5_11d0_bd21_00a0c911ce86);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_FilterGraph: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436ebb3_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_FilterGraphNoThread: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436ebb8_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_FilterGraphPrivateThread: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa3ecbc41_581a_4476_b693_a63340462d8b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_FilterMapper: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436ebb2_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_FilterMapper2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xcda42200_bd88_11d0_bd4e_00a0c911ce86);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_FrameServerNetworkCameraSource: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7a213aa7_866f_414a_8c1a_275c7283a395);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_HttpSchemePlugin: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x44cb442b_9da9_49df_b3fd_023777b16e50);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_ICodecAPIProxy: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7ff0997a_1999_4286_a73c_622b8814e7eb);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_IVideoEncoderCodecAPIProxy: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb05dabd9_56e5_4fdc_afa4_8a47e91f1c9c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_IVideoEncoderProxy: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb43c4eec_8c32_4791_9102_508ada5ee8e7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_InfTee: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf8388a40_d5bb_11d0_be5a_0080c706568e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_LegacyAmFilterCategory: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x083863f1_70de_11d0_bd40_00a0c911ce86);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_Line21Decoder: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6e8d4a20_310c_11d0_b79a_00aa003767a7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_Line21Decoder2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe4206432_01a1_4bee_b3e1_3702c8edc574);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MFByteStreamProxyClassFactory: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x770e8e77_4916_441c_a9a7_b342d0eebc71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MFCaptureEngine: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xefce38d3_8914_4674_a7df_ae1b3d654b8a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MFCaptureEngineClassFactory: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xefce38d3_8914_4674_a7df_ae1b3d654b8a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MFImageSharingEngineClassFactory: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb22c3339_87f3_4059_a0c5_037aa9707eaf);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MFMediaEngineClassFactory: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb44392da_499b_446b_a4cb_005fead0e6d5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MFMediaSharingEngineClassFactory: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf8e307fb_6d45_4ad3_9993_66cd5a529659);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MFReadWriteClassFactory: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x48e2ed0f_98c2_4a37_bed5_166312ddd83f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MFSinkWriter: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa3bbfb17_8273_4e52_9e0e_9739dc887990);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MFSourceReader: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1777133c_0881_411b_a577_ad545f0714c4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MFSourceResolver: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x90eab60f_e43a_4188_bcc4_e47fdf04868c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MFVideoMixer9: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe474e05a_ab65_4f6a_827c_218b1baaf31f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MFVideoPresenter9: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x98455561_5136_4d28_ab08_4cee40ea2781);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MJPGEnc: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb80ab0a0_7416_11d2_9eeb_006008039e37);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MMSPLITTER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3ae86b20_7be8_11d1_abe6_00a0c905f375);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MOVReader: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x44584800_f8ee_11ce_b2d4_00dd01101b85);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MP3DecMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbbeea841_0a63_4f52_a7ab_a9b3a84ed38a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MPEG1Doc: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe4bbd160_4269_11ce_838d_00aa0055595a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MPEG1PacketPlayer: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x26c25940_4ca9_11ce_a828_00aa002feab5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MPEG1Splitter: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x336475d0_942a_11ce_a870_00aa002feab5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MPEG2ByteStreamPlugin: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x40871c59_ab40_471f_8dc3_1f259d862479);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MPEG2DLNASink: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfa5fe7c5_6a1d_4b11_b41f_f959d6c76500);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MPEG2Demultiplexer: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xafb6c280_2c41_11d3_8a60_0000f81e0e4a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MPEG2Demultiplexer_NoClock: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x687d3367_3644_467a_adfe_6cd7a85c4a2c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MSAACDecMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x32d186a7_218f_4c75_8876_dd77273a8999);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MSDDPlusDecMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x177c0afe_900b_48d4_9e4c_57add250b3d4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MSH264DecoderMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x62ce7e72_4c71_4d20_b15d_452831a87d9d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MSH264EncoderMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6ca50344_051a_4ded_9779_a43305165e35);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MSH265DecoderMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x420a51a3_d605_430c_b4fc_45274fa6c562);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MSMPEGAudDecMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x70707b39_b2ca_4015_abea_f8447d22d88b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MSMPEGDecoderMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2d709e52_123f_49b5_9cbc_9af5cde28fb9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MSOpusDecoder: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x63e17c10_2d43_4c42_8fe3_8d8b63e46a6a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MSVPxDecoder: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe3aaf548_c9a4_4c6e_234d_5ada374b0000);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MediaEncoderCategory: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7d22e920_5ca9_4787_8c2b_a6779bd11781);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MediaMultiplexerCategory: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x236c9559_adce_4736_bf72_bab34e392196);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MediaPropertyBag: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xcdbd8d00_c193_11d0_bd4e_00a0c911ce86);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MemoryAllocator: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1e651cc0_b199_11d0_8212_00c04fc32c45);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MidiRendererCategory: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4efe2452_168a_11d1_bc76_00c04fb9453b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_MjpegDec: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x301056d0_6dff_11d2_9eeb_006008039e37);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_ModexRenderer: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x07167665_5011_11cf_bf33_00aa0055595a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_Mpeg2VideoStreamAnalyzer: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6cfad761_735d_4aa5_8afc_af91a7d61eba);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_NetSchemePlugin: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe9f4ebab_d97b_463e_a2b1_c54ee3f9414d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_NetworkProvider: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb2f3a67c_29da_4c78_8831_091ed509a475);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_OverlayMixer: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xcd8743a1_3736_11d0_9e69_00c04fd7c15b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_PerformanceProperties: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x59ce6880_acf8_11cf_b56e_0080c7c4b68a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_PersistMonikerPID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436ebb7_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_PlayToSourceClassFactory: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xda17539a_3dc3_42c1_a749_a183b51f085e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_ProtoFilterGraph: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436ebb0_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_QTDec: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfdfe9681_74a3_11d0_afa7_00aa00b67a42);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_QualityProperties: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x418afb70_f8b8_11ce_aac6_0020af0b99a3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_QuickTimeParser: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd51bd5a0_7548_11cf_a520_0080c77ef58a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_SBE2File: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x93a094d7_51e8_485b_904a_8d6b97dc6b39);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_SBE2FileScan: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3e458037_0ca6_41aa_a594_2aa6c02d709b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_SBE2MediaTypeProfile: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1f26a602_2b5c_4b63_b8e8_9ea5c1a7dc2e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_SBE2Sink: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe2448508_95da_4205_9a27_7ec81e723b1a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_SeekingPassThru: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x060af76c_68dd_11d0_8fc1_00c04fd9189d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_SmartTee: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xcc58e280_8aa1_11d1_b3f1_00aa003761c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_StreamBufferComposeRecording: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd682c4ba_a90a_42fe_b9e1_03109849c423);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_StreamBufferConfig: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfa8a68b2_c864_4ba2_ad53_d3876a87494b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_StreamBufferPropertyHandler: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe37a73f8_fb01_43dc_914e_aaee76095ab9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_StreamBufferRecordingAttributes: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xccaa63ac_1057_4778_ae92_1206ab9acee6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_StreamBufferSink: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2db47ae5_cf39_43c2_b4d6_0cd8d90946f4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_StreamBufferSource: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc9f5fe02_f851_4eb5_99ee_ad602af1e619);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_StreamBufferThumbnailHandler: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x713790ee_5ee1_45ba_8070_a1337d2762fa);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_SubtitlesFilter: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9f22cfea_ce07_41ab_8ba0_c7364af90af9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_SystemClock: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436ebb1_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_SystemDeviceEnum: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x62be5d10_60eb_11d0_bd3b_00a0c911ce86);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_TVAudioFilterPropertyPage: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x71f96463_78f3_11d0_a18c_00a0c9118956);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_TVEFilterCCProperties: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x05500282_faa5_4df9_8246_bfc23ac5cea8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_TVEFilterStatsProperties: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x05500283_faa5_4df9_8246_bfc23ac5cea8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_TVEFilterTuneProperties: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x05500281_faa5_4df9_8246_bfc23ac5cea8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_TVTunerFilterPropertyPage: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x266eee41_6c63_11cf_8a03_00aa006ecb65);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_TextRender: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe30629d3_27e5_11ce_875d_00608cb78066);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_TransmitCategory: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xcc7bfb41_f175_11d1_a392_00e0291f3959);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_URLReader: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436ebb6_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_UrlmonSchemePlugin: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9ec4b4f9_3029_45ad_947b_344de2a249e2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_VBISurfaces: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x814b9800_1c88_11d1_bad9_00609744111a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_VPObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xce292861_fc88_11d0_9e69_00c04fd7c15b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_VPVBIObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x814b9801_1c88_11d1_bad9_00609744111a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_VfwCapture: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b544c22_fd0b_11ce_8c63_00aa0044b51e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_VideoCompressorCategory: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x33d9a760_90c8_11d0_bd43_00a0c911ce86);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_VideoInputDeviceCategory: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x860bb310_5d01_11d0_bd3b_00a0c911ce86);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_VideoMixingRenderer: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb87beb7b_8d29_423f_ae4d_6582c10175ac);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_VideoMixingRenderer9: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x51b4abf3_748f_4e3b_a276_c828330e926a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_VideoPortManager: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6f26a6cd_967b_47fd_874a_7aed2c9d25a2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_VideoProcAmpPropertyPage: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x71f96464_78f3_11d0_a18c_00a0c9118956);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_VideoProcessorMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x88753b26_5b24_49bd_b2e7_0c445c78c982);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_VideoRenderer: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x70e102b0_5556_11ce_97c0_00aa0055595a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_VideoRendererDefault: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6bc1cffa_8fc1_4261_ac22_cfb4cc38db50);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_VideoStreamConfigPropertyPage: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x71f96467_78f3_11d0_a18c_00a0c9118956);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_WMADecMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2eeb4adf_4578_4d10_bca7_bb955f56320a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_WMAsfReader: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x187463a0_5bb7_11d3_acbe_0080c75e246e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_WMAsfWriter: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7c23220e_55bb_11d3_8b16_00c04fb6bd3d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_WMDRMSystemID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8948bb22_11bd_4796_93e3_974d1b575678);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_WMVDecoderMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x82d353df_90bd_4382_8bc2_3f6192b76e34);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_WSTDecoder: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x70bc06e0_5666_11d3_a184_00105aef9f33);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CLSID_WstDecoderPropertyPage: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x04e27f80_91e4_11d3_a184_00105aef9f33);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMP3DecMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbbeea841_0a63_4f52_a7ab_a9b3a84ed38a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMPEG2AudDecoderDS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe1f1a0b8_beee_490d_ba7c_066c40b5e2b9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMPEG2AudioEncoderMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x46a4dd5c_73f8_4304_94df_308f760974f4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMPEG2EncoderAudioDS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xacd453bc_c58a_44d1_bbf5_bfb325be2d78);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMPEG2EncoderDS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5f5aff4a_2f7f_4279_88c2_cd88eb39d144);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMPEG2EncoderVideoDS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x42150cd9_ca9a_4ea5_9939_30ee037f6e74);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMPEG2VidDecoderDS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x212690fb_83e5_4526_8fd7_74478b7939cd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMPEG2VideoEncoderMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe6335f02_80b7_4dc4_adfa_dfe7210d20d5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMPEGAACDecMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8dde1772_edad_41c3_b4be_1f30fb4ee0d6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMSAACDecMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x32d186a7_218f_4c75_8876_dd77273a8999);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMSAC3Enc: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc6b400e2_20a7_4e58_a2fe_24619682ce6c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMSALACDecMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc0cd7d12_31fc_4bbc_b363_7322ee3e1879);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMSALACEncMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9ab6a28c_748e_4b6a_bfff_cc443b8e8fb4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMSDDPlusDecMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x177c0afe_900b_48d4_9e4c_57add250b3d4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMSDolbyDigitalEncMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xac3315c9_f481_45d7_826c_0b406c1f64b8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMSFLACDecMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6b0b3e6b_a2c5_4514_8055_afe8a95242d9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMSFLACEncMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x128509e9_c44e_45dc_95e9_c255b8f466a6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMSH263EncoderMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbc47fcfe_98a0_4f27_bb07_698af24f2b38);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMSH264DecoderMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x62ce7e72_4c71_4d20_b15d_452831a87d9d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMSH264EncoderMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6ca50344_051a_4ded_9779_a43305165e35);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMSH264RemuxMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x05a47ebb_8bf0_4cbf_ad2f_3b71d75866f5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMSH265EncoderMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf2f84074_8bca_40bd_9159_e880f673dd3b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMSMPEGAudDecMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x70707b39_b2ca_4015_abea_f8447d22d88b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMSMPEGDecoderMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2d709e52_123f_49b5_9cbc_9af5cde28fb9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMSOpusDecMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x63e17c10_2d43_4c42_8fe3_8d8b63e46a6a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMSSCDecMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7bafb3b1_d8f4_4279_9253_27da423108de);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMSSCEncMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8cb9cc06_d139_4ae6_8bb4_41e612e141d5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMSSCEncMediaObject2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf7ffe0a0_a4f5_44b5_949e_15ed2bc66f9d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMSVPXEncoderMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xaeb6c755_2546_4881_82cc_e15ae5ebff3d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMSVideoDSPMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x51571744_7fe4_4ff2_a498_2dc34ff74f1b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMpeg2DecMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x863d66cd_cdce_4617_b47f_c8929cfc28a6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMpeg43DecMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xcba9e78b_49a3_49ea_93d4_6bcba8c4de07);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMpeg4DecMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf371728a_6052_4d47_827c_d039335dfe0a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMpeg4EncMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x24f258d8_c651_4042_93e4_ca654abb682c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMpeg4sDecMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5686a0d9_fe39_409f_9dff_3fdbc849f9f5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMpeg4sDecMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2a11bae2_fe6e_4249_864b_9e9ed6e8dbc2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CMpeg4sEncMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6ec5a7be_d81e_4f9e_ada3_cd1bf262b6d8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CNokiaAACCCDecMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xeabf7a6f_ccba_4d60_8620_b152cc977263);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CNokiaAACDecMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb2bde4_4e29_4c44_a73e_2d7c2c46d6ec);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_ALLSETTINGS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6a577e92_83e1_4113_adc2_4fcec32f83a1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AUDIO_ENCODER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb9d19a3e_f897_429c_bc46_8138b7272b2d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVAudioChannelConfig: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x17f89cb3_c38d_4368_9ede_63b94d177f9f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVAudioChannelCount: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1d3583c4_1583_474e_b71a_5ee463c198e4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVAudioSampleRate: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x971d2723_1acb_42e7_855c_520a4b70a5f2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDDSurroundMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x99f2f386_98d1_4452_a163_abc78a6eb770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDSPLoudnessEqualization: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8afd1a15_1812_4cbf_9319_433a5b2a3b27);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDSPSpeakerFill: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5612bca1_56da_4582_8da1_ca8090f92768);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecAACDownmixMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x01274475_f6bb_4017_b084_81a763c942d4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecAudioDualMono: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4a52cda8_30f8_4216_be0f_ba0b2025921d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecAudioDualMonoReproMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa5106186_cc94_4bc9_8cd9_aa2f61f6807e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecCommonInputFormat: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe5005239_bd89_4be3_9c0f_5dde317988cc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecCommonMeanBitRate: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x59488217_007a_4f7a_8e41_5c48b1eac5c6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecCommonMeanBitRateInterval: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0ee437c6_38a7_4c5c_944c_68ab42116b85);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecCommonOutputFormat: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3c790028_c0ce_4256_b1a2_1b0fc8b1dcdc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecDDDynamicRangeScaleHigh: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x50196c21_1f33_4af5_b296_11426d6c8789);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecDDDynamicRangeScaleLow: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x044e62e4_11a5_42d5_a3b2_3bb2c7c2d7cf);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecDDMatrixDecodingMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xddc811a5_04ed_4bf3_a0ca_d00449f9355f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecDDOperationalMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd6d6c6d1_064e_4fdd_a40e_3ecbfcb7ebd0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecDDStereoDownMixMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6ce4122c_3ee9_4182_b4ae_c10fc088649d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecDisableVideoPostProcessing: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf8749193_667a_4f2c_a9e8_5d4af924f08f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecHEAACDynamicRangeControl: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x287c8abe_69a4_4d39_8080_d3d9712178a0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecMmcssClass: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe0ad4828_df66_4893_9f33_788aa4ec4082);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecNumWorkerThreads: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9561c3e8_ea9e_4435_9b1e_a93e691894d8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecSoftwareDynamicFormatChange: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x862e2f0a_507b_47ff_af47_01e2624298b7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecVideoAcceleration_H264: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf7db8a2f_4f48_4ee8_ae31_8b6ebe558ae2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecVideoAcceleration_MPEG2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf7db8a2e_4f48_4ee8_ae31_8b6ebe558ae2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecVideoAcceleration_VC1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf7db8a30_4f48_4ee8_ae31_8b6ebe558ae2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecVideoCodecType: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x434528e5_21f0_46b6_b62c_9b1b6b658cd1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecVideoDXVABusEncryption: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x42153c8b_fd0b_4765_a462_ddd9e8bcc388);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecVideoDXVAMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf758f09e_7337_4ae7_8387_73dc2d54e67d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecVideoDropPicWithMissingRef: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf8226383_14c2_4567_9734_5004e96ff887);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecVideoFastDecodeMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6b529f7d_d3b1_49c6_a999_9ec6911bedbf);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecVideoH264ErrorConcealment: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xececace8_3436_462c_9294_cd7bacd758a9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecVideoImageSize: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5ee5747c_6801_4cab_aaf1_6248fa841ba4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecVideoInputScanType: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x38477e1f_0ea7_42cd_8cd1_130ced57c580);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecVideoMPEG2ErrorConcealment: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9d2bfe18_728d_48d2_b358_bc7e436c6674);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecVideoMaxCodedHeight: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7262a16a_d2dc_4e75_9ba8_65c0c6d32b13);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecVideoMaxCodedWidth: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5ae557b8_77af_41f5_9fa6_4db2fe1d4bca);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecVideoPixelAspectRatio: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb0cf8245_f32d_41df_b02c_87bd304d12ab);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecVideoProcDeinterlaceCSC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf7db8a31_4f48_4ee8_ae31_8b6ebe558ae2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecVideoSWPowerLevel: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfb5d2347_4dd8_4509_aed0_db5fa9aa93f4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecVideoSoftwareDeinterlaceMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0c08d1ce_9ced_4540_bae3_ceb380141109);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVDecVideoThumbnailGenerationMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2efd8eee_1150_4328_9cf5_66dce933fcf4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEnableInLoopDeblockFilter: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd2e8e399_0623_4bf3_92a8_4d1818529ded);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncAACEnableVBR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe836bb98_fca3_44b6_9a39_24786be41be1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncAdaptiveMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4419b185_da1f_4f53_bc76_097d0c1efb1e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncAudioDualMono: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3648126b_a3e8_4329_9b3a_5ce566a43bd3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncAudioInputContent: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3e226c2b_60b9_4a39_b00b_a7b40f70d566);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncAudioIntervalToEncode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x866e4b4d_725a_467c_bb01_b496b23b25f9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncAudioIntervalToSkip: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x88c15f94_c38c_4796_a9e8_96e967983f26);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncAudioMapDestChannel0: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbc5d0b60_df6a_4e16_9803_b82007a30c8d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncAudioMapDestChannel1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbc5d0b61_df6a_4e16_9803_b82007a30c8d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncAudioMapDestChannel10: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbc5d0b6a_df6a_4e16_9803_b82007a30c8d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncAudioMapDestChannel11: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbc5d0b6b_df6a_4e16_9803_b82007a30c8d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncAudioMapDestChannel12: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbc5d0b6c_df6a_4e16_9803_b82007a30c8d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncAudioMapDestChannel13: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbc5d0b6d_df6a_4e16_9803_b82007a30c8d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncAudioMapDestChannel14: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbc5d0b6e_df6a_4e16_9803_b82007a30c8d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncAudioMapDestChannel15: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbc5d0b6f_df6a_4e16_9803_b82007a30c8d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncAudioMapDestChannel2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbc5d0b62_df6a_4e16_9803_b82007a30c8d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncAudioMapDestChannel3: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbc5d0b63_df6a_4e16_9803_b82007a30c8d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncAudioMapDestChannel4: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbc5d0b64_df6a_4e16_9803_b82007a30c8d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncAudioMapDestChannel5: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbc5d0b65_df6a_4e16_9803_b82007a30c8d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncAudioMapDestChannel6: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbc5d0b66_df6a_4e16_9803_b82007a30c8d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncAudioMapDestChannel7: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbc5d0b67_df6a_4e16_9803_b82007a30c8d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncAudioMapDestChannel8: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbc5d0b68_df6a_4e16_9803_b82007a30c8d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncAudioMapDestChannel9: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbc5d0b69_df6a_4e16_9803_b82007a30c8d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncAudioMeanBitRate: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x921295bb_4fca_4679_aab8_9e2a1d753384);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncChromaEncodeMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8a47ab5a_4798_4c93_b5a5_554f9a3b9f50);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncChromaUpdateTime: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4b4fd998_4274_40bb_8ee4_07553e7e2d3a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncCodecType: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x08af4ac1_f3f2_4c74_9dcf_37f2ec79f826);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncCommonAllowFrameDrops: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd8477dcb_9598_48e3_8d0c_752bf206093e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncCommonBufferInLevel: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd9c5c8db_fc74_4064_94e9_cd19f947ed45);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncCommonBufferOutLevel: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xccae7f49_d0bc_4e3d_a57e_fb5740140069);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncCommonBufferSize: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0db96574_b6a4_4c8b_8106_3773de0310cd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncCommonFormatConstraint: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x57cbb9b8_116f_4951_b40c_c2a035ed8f17);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncCommonLowLatency: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9d3ecd55_89e8_490a_970a_0c9548d5a56e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncCommonMaxBitRate: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9651eae4_39b9_4ebf_85ef_d7f444ec7465);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncCommonMeanBitRate: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf7222374_2144_4815_b550_a37f8e12ee52);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncCommonMeanBitRateInterval: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbfaa2f0c_cb82_4bc0_8474_f06a8a0d0258);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncCommonMinBitRate: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x101405b2_2083_4034_a806_efbeddd7c9ff);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncCommonMultipassMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x22533d4c_47e1_41b5_9352_a2b7780e7ac4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncCommonPassEnd: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0e3d01bc_c85c_467d_8b60_c41012ee3bf6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncCommonPassStart: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6a67739f_4eb5_4385_9928_f276a939ef95);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncCommonQuality: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfcbf57a3_7ea5_4b0c_9644_69b40c39c391);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncCommonQualityVsSpeed: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x98332df8_03cd_476b_89fa_3f9e442dec9f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncCommonRateControlMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1c0608e9_370c_4710_8a58_cb6181c42423);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncCommonRealTime: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x143a0ff6_a131_43da_b81e_98fbb8ec378e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncCommonStreamEndHandling: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6aad30af_6ba8_4ccc_8fca_18d19beaeb1c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncCommonTranscodeEncodingProfile: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6947787c_f508_4ea9_b1e9_a1fe3a49fbc9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDAtoDConverterType: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x719f9612_81a1_47e0_9a05_d94ad5fca948);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDCentreDownMixLevel: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe285072c_c958_4a81_afd2_e5e0daf1b148);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDChannelBWLowPassFilter: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe197821d_d2e7_43e2_ad2c_00582f518545);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDCopyright: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8694f076_cd75_481d_a5c6_a904dcc828f0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDDCHighPassFilter: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9565239f_861c_4ac8_bfda_e00cb4db8548);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDDialogNormalization: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd7055acf_f125_437d_a704_79c79f0404a8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDDigitalDeemphasis: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe024a2c2_947c_45ac_87d8_f1030c5c0082);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDDynamicRangeCompressionControl: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xcfc2ff6d_79b8_4b8d_a8aa_a0c9bd1c2940);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDHeadphoneMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4052dbec_52f5_42f5_9b00_d134b1341b9d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDLFELowPassFilter: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd3b80f6f_9d15_45e5_91be_019c3fab1f01);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDLoRoCenterMixLvl_x10: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1cfba222_25b3_4bf4_9bfd_e7111267858c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDLoRoSurroundMixLvl_x10: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe725cff6_eb56_40c7_8450_2b9367e91555);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDLtRtCenterMixLvl_x10: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdca128a2_491f_4600_b2da_76e3344b4197);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDLtRtSurroundMixLvl_x10: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x212246c7_3d2c_4dfa_bc21_652a9098690d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDOriginalBitstream: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x966ae800_5bd3_4ff9_95b9_d30566273856);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDPreferredStereoDownMixMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7f4e6b31_9185_403d_b0a2_763743e6f063);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDProductionInfoExists: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb0b7fe5f_b6ab_4f40_964d_8d91f17c19e8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDProductionMixLevel: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x301d103a_cbf9_4776_8899_7c15b461ab26);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDProductionRoomType: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdad7ad60_23d8_4ab7_a284_556986d8a6fe);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDRFPreEmphasisFilter: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x21af44c0_244e_4f3d_a2cc_3d3068b2e73f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDService: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd2e1bec7_5172_4d2a_a50e_2f3b82b1ddf8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDSurround3dBAttenuation: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4d43b99d_31e2_48b9_bf2e_5cbf1a572784);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDSurround90DegreeePhaseShift: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x25ecec9d_3553_42c0_bb56_d25792104f80);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDSurroundDownMixLevel: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7b20d6e5_0bcf_4273_a487_506b047997e9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncDDSurroundExMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x91607cee_dbdd_4eb6_bca2_aadfafa3dd68);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncEnableVideoProcessing: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x006f4bf6_0ea3_4d42_8702_b5d8be0f7a92);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncH264CABACEnable: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xee6cad62_d305_4248_a50e_e1b255f7caf8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncH264PPSID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbfe29ec2_056c_4d68_a38d_ae5944c8582e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncH264SPSID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x50f38f51_2b79_40e3_b39c_7e9fa0770501);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncInputVideoSystem: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbede146d_b616_4dc7_92b2_f5d9fa9298f7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncLowPowerEncoder: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb668d582_8bad_4f6a_9141_375a95358b6d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMP12MuxDVDNavPacks: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc7607ced_8cf1_4a99_83a1_ee5461be3574);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMP12MuxEarliestPTS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x157232b6_f809_474e_9464_a7f93014a817);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMP12MuxInitialSCR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3433ad21_1b91_4a0b_b190_2b77063b63a4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMP12MuxLargestPacketSize: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x35ceb711_f461_4b92_a4ef_17b6841ed254);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMP12MuxMuxRate: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xee047c72_4bdb_4a9d_8e21_41926c823da7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMP12MuxNumStreams: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf7164a41_dced_4659_a8f2_fb693f2a4cd0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMP12MuxPackSize: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf916053a_1ce8_4faf_aa0b_ba31c80034b8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMP12MuxPacketOverhead: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe40bd720_3955_4453_acf9_b79132a38fa0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMP12MuxSysAudioLock: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0fbb5752_1d43_47bf_bd79_f2293d8ce337);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMP12MuxSysCSPS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7952ff45_9c0d_4822_bc82_8ad772e02993);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMP12MuxSysFixed: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xcefb987e_894f_452e_8f89_a4ef8cec063a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMP12MuxSysRateBound: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x05f0428a_ee30_489d_ae28_205c72446710);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMP12MuxSysSTDBufferBound: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x35746903_b545_43e7_bb35_c5e0a7d5093c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMP12MuxSysVideoLock: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb8296408_2430_4d37_a2a1_95b3e435a91d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMP12MuxTargetPacketizer: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd862212a_2015_45dd_9a32_1b3aa88205a0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMP12PktzCopyright: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc8f4b0c1_094c_43c7_8e68_a595405a6ef8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMP12PktzInitialPTS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2a4f2065_9a63_4d20_ae22_0a1bc896a315);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMP12PktzOriginal: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6b178416_31b9_4964_94cb_6bff866cdf83);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMP12PktzPacketSize: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xab71347a_1332_4dde_a0e5_ccf7da8a0f22);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMP12PktzSTDBuffer: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0b751bd0_819e_478c_9435_75208926b377);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMP12PktzStreamID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc834d038_f5e8_4408_9b60_88f36493fedf);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPACodingMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb16ade03_4b93_43d7_a550_90b4fe224537);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPACopyright: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa6ae762a_d0a9_4454_b8ef_f2dbeefdd3bd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPAEmphasisType: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2d59fcda_bf4e_4ed6_b5df_5b03b36b0a1f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPAEnableRedundancyProtection: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5e54b09e_b2e7_4973_a89b_0b3650a3beda);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPALayer: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9d377230_f91b_453d_9ce0_78445414c22d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPAOriginalBitstream: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cfb7855_9cc9_47ff_b829_b36786c92346);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPAPrivateUserBit: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xafa505ce_c1e3_4e3d_851b_61b700e5e6cc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVAddSeqEndCode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa823178f_57df_4c7a_b8fd_e5ec8887708d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVDefaultBPictureCount: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8d390aac_dc5c_4200_b57f_814d04babab2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVFrameFieldMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xacb5de96_7b93_4c2f_8825_b0295fa93bf4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVGOPOpen: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb1d5d4a6_3300_49b1_ae61_a09937ab0e49);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVGOPSInSeq: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x993410d4_2691_4192_9978_98dc2603669f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVGOPSize: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x95f31b26_95a4_41aa_9303_246a7fc6eef1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVGOPSizeMax: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfe7de4c4_1936_4fe2_bdf7_1f18ca1d001f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVGOPSizeMin: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7155cf20_d440_4852_ad0f_9c4abfe37a6a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVGenerateHeaderPicDispExt: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc6412f84_c03f_4f40_a00c_4293df8395bb);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVGenerateHeaderPicExt: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b8464ab_944f_45f0_b74e_3a58dad11f37);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVGenerateHeaderSeqDispExt: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6437aa6f_5a3c_4de9_8a16_53d9c4ad326f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVGenerateHeaderSeqExt: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd5e78611_082d_4e6b_98af_0f51ab139222);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVGenerateHeaderSeqScaleExt: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0722d62f_dd59_4a86_9cd5_644f8e2653d8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVIntraDCPrecision: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa0116151_cbc8_4af3_97dc_d00cceb82d79);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVIntraVLCTable: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa2b83ff5_1a99_405a_af95_c5997d558d3a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVLevel: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6ee40c40_a60c_41ef_8f50_37c2249e2cb3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVProfile: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdabb534a_1d99_4284_975a_d90e2239baa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVQScaleType: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2b79ebb7_f484_4af7_bb58_a2a188c5cbbe);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVQuantMatrixChromaIntra: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9eb9ecd4_018d_4ffd_8f2d_39e49f07b17a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVQuantMatrixChromaNonIntra: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1415b6b1_362a_4338_ba9a_1ef58703c05b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVQuantMatrixIntra: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9bea04f3_6621_442c_8ba1_3ac378979698);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVQuantMatrixNonIntra: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x87f441d8_0997_4beb_a08e_8573d409cf75);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVScanPattern: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7f8a478e_7bbb_4ae2_b2fc_96d17fc4a2d6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVSceneDetection: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x552799f1_db4c_405b_8a3a_c93f2d0674dc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMPVUseConcealmentMotionVectors: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xec770cf3_6908_4b4b_aa30_7fb986214fea);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMaxFrameRate: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb98e1b31_19fa_4d4f_9931_d6a5b8aab93c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncMuxOutputStreamType: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xcedd9e8f_34d3_44db_a1d8_f81520254f3e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncNoInputCopy: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd2b46a2a_e8ee_4ec5_869e_449b6c62c81a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncNumWorkerThreads: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb0c8bf60_16f7_4951_a30b_1db1609293d6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncProgressiveUpdateTime: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x649faf66_afc6_4828_8fdc_0771cd9ab17d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncSliceControlMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe9e782ef_5f18_44c9_a90b_e9c3c2c17b0b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncSliceControlSize: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x92f51df3_07a5_4172_aefe_c69ca3b60e35);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncSliceGenerationMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8a6bc67f_9497_4286_b46b_02db8d60edbc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncStatAudioAverageBPS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xca6724db_7059_4351_8b43_f82198826a14);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncStatAudioAveragePCMValue: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x979272f8_d17f_4e32_bb73_4e731c68ba2d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncStatAudioPeakPCMValue: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdce7fd34_dc00_4c16_821b_35d9eb00fb1a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncStatAverageBPS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xca6724db_7059_4351_8b43_f82198826a14);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncStatCommonCompletedPasses: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3e5de533_9df7_438c_854f_9f7dd3683d34);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncStatHardwareBandwidthUtilitization: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0124ba9b_dc41_4826_b45f_18ac01b3d5a8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncStatHardwareProcessorUtilitization: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x995dc027_cb95_49e6_b91b_5967753cdcb8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncStatMPVSkippedEmptyFrames: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x32195fd3_590d_4812_a7ed_6d639a1f9711);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncStatVideoCodedFrames: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd47f8d61_6f5a_4a26_bb9f_cd9518462bcd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncStatVideoOutputFrameRate: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbe747849_9ab4_4a63_98fe_f143f04f8ee9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncStatVideoTotalFrames: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfdaa9916_119a_4222_9ad6_3f7cab99cc8b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncStatWMVCBAvg: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6aa6229f_d602_4b9d_b68c_c1ad78884bef);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncStatWMVCBMax: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe976bef8_00fe_44b4_b625_8f238bc03499);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncStatWMVDecoderComplexityProfile: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x89e69fc3_0f9b_436c_974a_df821227c90d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncTileColumns: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb4b31205_01e8_452c_b876_8c6506545925);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncTileRows: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfbc650fc_41ab_4f9b_84b5_065be9cd99ee);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoCBRMotionTradeoff: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0d49451e_18d5_4367_a4ef_3240df1693c4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoCTBSize: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd47db8b2_e73b_4cb9_8c3e_bd877d06d77b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoCodedVideoAccessUnitSize: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb4b10c15_14a7_4ce8_b173_dc90a0b4fcdb);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoConsecutiveFramesForLayer: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0af35522_d984_45ae_bbb8_53933e0ab1b5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoContentType: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x66117aca_eb77_459d_930c_a48d9d0683fc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoDefaultUpperFieldDominant: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x810167c4_0bc1_47ca_8fc2_57055a1474a5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoDirtyRectEnabled: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8acb8fdd_5e0c_4c66_8729_b8f629ab04fb);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoDisplayDimension: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xde053668_f4ec_47a9_86d0_836770f0c1d5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoEncodeDimension: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1074df28_7e0f_47a4_a453_cdd73870f5ce);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoEncodeFrameTypeQP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xaa70b610_e03f_450c_ad07_07314e639ce7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoEncodeOffsetOrigin: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6bc098fe_a71a_4454_852e_4d2ddeb2cd24);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoEncodeQP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2cb5696b_23fb_4ce1_a0f9_ef5b90fd55ca);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoFieldSwap: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfefd7569_4e0a_49f2_9f2b_360ea48c19a2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoForceKeyFrame: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x398c1b98_8353_475a_9ef2_8f265d260345);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoForceSourceScanType: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1ef2065f_058a_4765_a4fc_8a864c103012);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoGradualIntraRefresh: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8f347dee_cb0d_49ba_b462_db6927ee2101);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoHeaderDropFrame: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6ed9e124_7925_43fe_971b_e019f62222b4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoHeaderFrames: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xafd5f567_5c1b_4adc_bdaf_735610381436);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoHeaderHours: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2acc7702_e2da_4158_bf9b_88880129d740);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoHeaderMinutes: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdc1a99ce_0307_408b_880b_b8348ee8ca7f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoHeaderSeconds: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4a2e1a05_a780_4f58_8120_9a449d69656b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoInputChromaResolution: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbb0cec33_16f1_47b0_8a88_37815bee1739);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoInputChromaSubsampling: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa8e73a39_4435_4ec3_a6ea_98300f4b36f7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoInputColorLighting: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x46a99549_0015_4a45_9c30_1d5cfa258316);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoInputColorNominalRange: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x16cf25c6_a2a6_48e9_ae80_21aec41d427e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoInputColorPrimaries: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc24d783f_7ce6_4278_90ab_28a4f1e5f86c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoInputColorTransferFunction: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8c056111_a9c3_4b08_a0a0_ce13f8a27c75);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoInputColorTransferMatrix: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x52ed68b9_72d5_4089_958d_f5405d55081c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoInstantTemporalUpSwitching: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa3308307_0d96_4ba4_b1f0_b91a5e49df10);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoIntraLayerPrediction: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd3af46b8_bf47_44bb_a283_69f0b0228ff9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoInverseTelecineEnable: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2ea9098b_e76d_4ccd_a030_d3b889c1b64c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoInverseTelecineThreshold: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x40247d84_e895_497f_b44c_b74560acfe27);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoLTRBufferControl: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa4a0e93d_4cbc_444c_89f4_826d310e92a7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoMarkLTRFrame: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe42f4748_a06d_4ef9_8cea_3d05fde3bd3b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoMaxCTBSize: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x822363ff_cec8_43e5_92fd_e097488485e9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoMaxKeyframeDistance: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2987123a_ba93_4704_b489_ec1e5f25292c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoMaxNumRefFrame: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x964829ed_94f9_43b4_b74d_ef40944b69a0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoMaxNumRefFrameForLayer: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3141c639_6329_40d1_b7e7_2f0e3ac18e02);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoMaxQP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3daf6f66_a6a7_45e0_a8e5_f2743f46a3a2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoMaxTemporalLayers: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9c668cfe_08e1_424a_934e_b764b064802a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoMeanAbsoluteDifference: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe5c0c10f_81a4_422d_8c3f_b474a4581336);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoMinQP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0ee22c6a_a37c_4568_b5f1_9d4c2b3ab886);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoNoOfFieldsToEncode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x61e4bbe2_4ee0_40e7_80ab_51ddeebe6291);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoNoOfFieldsToSkip: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa97e1240_1427_4c16_a7f7_3dcfd8ba4cc5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoNumGOPsPerIDR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x83bc5bdb_5b89_4521_8f66_33151c373176);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoOutputChromaResolution: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6097b4c9_7c1d_4e64_bfcc_9e9765318ae7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoOutputChromaSubsampling: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfa561c6c_7d17_44f0_83c9_32ed12e96343);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoOutputColorLighting: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0e5aaac6_ace6_4c5c_998e_1a8c9c6c0f89);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoOutputColorNominalRange: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x972835ed_87b5_4e95_9500_c73958566e54);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoOutputColorPrimaries: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbe95907c_9d04_4921_8985_a6d6d87d1a6c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoOutputColorTransferFunction: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4a7f884a_ea11_460d_bf57_b88bc75900de);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoOutputColorTransferMatrix: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa9b90444_af40_4310_8fbe_ed6d933f892b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoOutputFrameRate: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xea85e7c3_9567_4d99_87c4_02c1c278ca7c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoOutputFrameRateConversion: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8c068bf4_369a_4ba3_82fd_b2518fb3396e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoOutputScanType: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x460b5576_842e_49ab_a62d_b36f7312c9db);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoPixelAspectRatio: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cdc718f_b3e9_4eb6_a57f_cf1f1b321b87);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoROIEnabled: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd74f7f18_44dd_4b85_aba3_05d9f42a8280);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoRateControlParams: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x87d43767_7645_44ec_b438_d3322fbca29f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoSelectLayer: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xeb1084f5_6aaa_4914_bb2f_6147227f12e7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoSourceFilmContent: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1791c64b_ccfc_4827_a0ed_2557793b2b1c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoSourceIsBW: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x42ffc49b_1812_4fdc_8d24_7054c521e6eb);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoSupportedControls: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd3f40fdd_77b9_473d_8196_061259e69cff);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoTemporalLayerCount: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x19caebff_b74d_4cfd_8c27_c2f9d97d5f52);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoUsage: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1f636849_5dc1_49f1_b1d8_ce3cf62ea385);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncVideoUseLTRFrame: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00752db8_55f7_4f80_895b_27639195f2ad);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncWMVDecoderComplexity: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf32c0dab_f3cb_4217_b79f_8762768b5f67);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncWMVInterlacedEncoding: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe3d00f8a_c6f5_4e14_a588_0ec87a726f9b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncWMVKeyFrameBufferLevelMarker: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x51ff1115_33ac_426c_a1b1_09321bdf96b4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncWMVKeyFrameDistance: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5569055e_e268_4771_b83e_9555ea28aed3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVEncWMVProduceDummyFrames: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd669d001_183c_42e3_a3ca_2f4586d2396c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVLowLatencyMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9c27891a_ed7a_40e1_88e8_b22727a024ee);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVPriorityControl: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x54ba3dc8_bdde_4329_b187_2018bc5c2ba1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVRealtimeControl: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6f440632_c4ad_4bf7_9e52_456942b454b0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_AVScenarioInfo: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb28a6e64_3ff9_446a_8a4b_0d7a53413236);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_CHANGELISTS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x62b12acf_f6b0_47d9_9456_96f22c4e0b9d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_CURRENTCHANGELIST: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1cb14e83_7d72_4657_83fd_47a2c5b9d13d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVDecAudioInputAAC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x97df7828_b94a_47e2_a4bc_51194db22a4d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVDecAudioInputDTS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x600bc0ca_6a1f_4e91_b241_1bbeb1cb19e0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVDecAudioInputDolby: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8e4228a0_f000_4e0b_8f54_ab8d24ad61a2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVDecAudioInputDolbyDigitalPlus: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0803e185_8f5d_47f5_9908_19a5bbc9fe34);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVDecAudioInputHEAAC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x16efb4aa_330e_4f5c_98a8_cf6ac55cbe60);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVDecAudioInputMPEG: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x91106f36_02c5_4f75_9719_3b7abf75e1f6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVDecAudioInputPCM: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf2421da5_bbb4_4cd5_a996_933c6b5d1347);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVDecAudioInputWMA: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc95e8dcf_4058_4204_8c42_cb24d91e4b9b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVDecAudioInputWMAPro: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0128b7c7_da72_4fe3_bef8_5c52e3557704);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVDecAudioOutputFormat_PCM: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x696e1d31_548f_4036_825f_7026c60011bd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Headphones: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x696e1d34_548f_4036_825f_7026c60011bd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Stereo_Auto: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x696e1d35_548f_4036_825f_7026c60011bd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVDecAudioOutputFormat_PCM_Stereo_MatrixEncoded: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x696e1d30_548f_4036_825f_7026c60011bd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVDecAudioOutputFormat_SPDIF_Bitstream: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x696e1d33_548f_4036_825f_7026c60011bd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVDecAudioOutputFormat_SPDIF_PCM: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x696e1d32_548f_4036_825f_7026c60011bd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncCommonFormatATSC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8d7b897c_a019_4670_aa76_2edcac7ac296);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncCommonFormatDVB: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x71830d8f_6c33_430d_844b_c2705baae6db);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncCommonFormatDVD_DashVR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe55199d6_044c_4dae_a488_531ed306235b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncCommonFormatDVD_PlusVR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe74c6f2e_ec37_478d_9af4_a5e135b6271c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncCommonFormatDVD_V: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xcc9598c4_e7fe_451d_b1ca_761bc840b7f3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncCommonFormatHighMAT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1eabe760_fb2b_4928_90d1_78db88eee889);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncCommonFormatHighMPV: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa2d25db8_b8f9_42c2_8bc7_0b93cf604788);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncCommonFormatMP3: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x349733cd_eb08_4dc2_8197_e49835ef828b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncCommonFormatSVCD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x51d85818_8220_448c_8066_d69bed16c9ad);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncCommonFormatUnSpecified: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xaf46a35a_6024_4525_a48a_094b97f5b3c2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncCommonFormatVCD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x95035bf7_9d90_40ff_ad5c_5cf8cf71ca1d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncDTS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x45fbcaa2_5e6e_4ab0_8893_5903bee93acf);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncDTSHD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2052e630_469d_4bfb_80ca_1d656e7e918f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncDV: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x09b769c7_3329_44fb_8954_fa30937d3d5a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncDolbyDigitalConsumer: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc1a7bf6c_0059_4bfa_94ef_ef747a768d52);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncDolbyDigitalPlus: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x698d1b80_f7dd_415c_971c_42492a2056c6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncDolbyDigitalPro: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf5be76cc_0ff8_40eb_9cb1_bba94004d44f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncH264Video: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x95044eab_31b3_47de_8e75_38a42bb03e28);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncMLP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x05f73e29_f0d1_431e_a41c_a47432ec5a66);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncMPEG1Audio: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd4dd1362_cd4a_4cd6_8138_b94db4542b04);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncMPEG1Video: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc8dafefe_da1e_4774_b27d_11830c16b1fe);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncMPEG2Audio: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xee4cbb1f_9c3f_4770_92b5_fcb7c2a8d381);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncMPEG2Video: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x046dc19a_6677_4aaa_a31d_c1ab716f4560);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncPCM: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x844be7f4_26cf_4779_b386_cc05d187990c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncSDDS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1dc1b82f_11c8_4c71_b7b6_ee3eb9bc2b94);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncWMALossless: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x55ca7265_23d8_4761_9031_b74fbe12f4c1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncWMAPro: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1955f90c_33f7_4a68_ab81_53f5657125c4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncWMAVoice: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x13ed18cb_50e8_4276_a288_a6aa228382d9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEncWMV: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4e0fef9b_1d43_41bd_b8bd_4d7bf7457a2a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GUID_AVEndMPEG4Video: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdd37b12a_9503_4f8b_b8d0_324a00c0a1cf);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_GetOPMContext: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2f036c05_4c14_4689_8839_294c6d73e053);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_SETALLDEFAULTS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6c5e6a7c_acf8_4f55_a999_1a628109051b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_SUPPORTSEVENTS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0581af97_7693_4dbd_9dca_3f9ebd6585a1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_SetHDCPManagerContext: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6d2d1fc8_3dc9_47eb_a1a2_471c80cd60d0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_VIDEO_ENCODER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7112e8e1_3d03_47ef_8e60_03f1cf537301);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CODECAPI_VideoEncoderDisplayContentType: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x79b90b27_f4b1_42dc_9dd7_cdaf8135c400);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const COPP_ProtectionType_ACP: i32 = 2i32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const COPP_ProtectionType_CGMSA: i32 = 4i32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const COPP_ProtectionType_HDCP: i32 = 1i32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const COPP_ProtectionType_Mask: i32 = -2147483641i32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const COPP_ProtectionType_None: i32 = 0i32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const COPP_ProtectionType_Reserved: i32 = 2147483640i32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const COPP_ProtectionType_Unknown: i32 = -2147483648i32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CPK_DS_AC3Decoder: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6c9c69d6_0ffc_4481_afdb_cdf1c79c6f3e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CPK_DS_MPEG2Decoder: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9910c5cd_95c9_4e06_865a_efa1c8016bf4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CResamplerMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf447b69e_1884_4a7e_8055_346f74d6edb3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CResizerDMO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1ea1ea14_48f4_4054_ad1a_e8aee10ac805);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CResizerMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd3ec8b8b_7728_4fd8_9fe0_7b67d19f73a3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CShotDetectorDmo: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x56aefacd_110c_4397_9292_b0a0c61b6750);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CSmpteTransformsDmo: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbde6388b_da25_485d_ba7f_fabc28b20318);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CThumbnailGeneratorDmo: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x559c6bad_1ea8_4963_a087_8a6810f9218b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CTocGeneratorDmo: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4dda1941_77a0_4fb1_a518_e2185041d70c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CVodafoneAACCCDecMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7e76bf7f_c993_4e26_8fab_470a70c0d59c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CVodafoneAACDecMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7f36f942_dcf3_4d82_9289_5b1820278f7c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CWMADecMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2eeb4adf_4578_4d10_bca7_bb955f56320a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CWMAEncMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x70f598e9_f4ab_495a_99e2_a7c4d3d89abf);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CWMATransMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xedcad9cb_3127_40df_b527_0152ccb3f6f5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CWMAudioAEC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x745057c7_f353_4f2d_a7ee_58434477730e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CWMAudioCAPXGFXAPO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x13ab3ebd_137e_4903_9d89_60be8277fd17);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CWMAudioCAPXLFXAPO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc9453e73_8c5c_4463_9984_af8bab2f5447);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CWMAudioGFXAPO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x637c490d_eee3_4c0a_973f_371958802da2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CWMAudioLFXAPO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x62dc1a93_ae24_464c_a43e_452f824c4250);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CWMAudioSpdTxDMO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5210f8e4_b0bb_47c3_a8d9_7b2282cc79ed);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CWMSPDecMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x874131cb_4ecc_443b_8948_746b89595d20);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CWMSPEncMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x67841b03_c689_4188_ad3f_4c9ebeec710b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CWMSPEncMediaObject2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1f1f4e1a_2252_4063_84bb_eee75f8856d5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CWMTDecMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf9dbc64e_2dd0_45dd_9b52_66642ef94431);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CWMTEncMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x60b67652_e46b_4e44_8609_f74bffdc083c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CWMV9EncMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd23b90d0_144f_46bd_841d_59e4eb19dc59);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CWMVDecMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x82d353df_90bd_4382_8bc2_3f6192b76e34);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CWMVEncMediaObject2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x96b57cdd_8966_410c_bb1f_c97eea765c04);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CWMVXEncMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7e320092_596a_41b2_bbeb_175d10504eb6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CWVC1DecMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc9bfbccf_e60e_4588_a3df_5a03b1fd9585);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CWVC1EncMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x44653d0d_8cca_41e7_baca_884337b747ac);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CZuneAACCCDecMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa74e98f2_52d6_4b4e_885b_e0a6ca4f187a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const CZuneM4S2DecMediaObject: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc56fc25c_0fc6_404a_9503_b10bf51a8ab9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_PROFILE_AV1_12BIT_PROFILE2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x17127009_a00f_4ce1_994e_bf4081f6f3f0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_PROFILE_AV1_12BIT_PROFILE2_420: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2d80bed6_9cac_4835_9e91_327bbc4f9ee8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_PROFILE_AV1_PROFILE0: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb8be4ccb_cf53_46ba_8d59_d6b8a6da5d2a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_PROFILE_AV1_PROFILE1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6936ff0f_45b1_4163_9cc1_646ef6946108);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_PROFILE_AV1_PROFILE2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0c5f2aa1_e541_4089_bb7b_98110a19d7c8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_PROFILE_H264: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b81be68_a0c7_11d3_b984_00c04f2e73c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_PROFILE_H264_MULTIVIEW: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x705b9d82_76cf_49d6_b7e6_ac8872db013c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_PROFILE_H264_STEREO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf9aaccbb_c2b6_4cfc_8779_5707b1760552);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_PROFILE_H264_STEREO_PROGRESSIVE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd79be8da_0cf1_4c81_b82a_69a4e236f43d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_PROFILE_HEVC_MAIN: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5b11d51b_2f4c_4452_bcc3_09f2a1160cc0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_PROFILE_HEVC_MAIN10: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x107af0e0_ef1a_4d19_aba8_67a163073d13);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_PROFILE_MPEG1_AND_MPEG2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x86695f12_340e_4f04_9fd3_9253dd327460);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_PROFILE_MPEG2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xee27417f_5e28_4e65_beea_1d26b508adc9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_PROFILE_MPEG4PT2_ADVSIMPLE_NOGMC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xed418a9f_010d_4eda_9ae3_9a65358d8d2e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_PROFILE_MPEG4PT2_SIMPLE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xefd64d74_c9e8_41d7_a5e9_e9b0e39fa319);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_PROFILE_VC1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b81bea3_a0c7_11d3_b984_00c04f2e73c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_PROFILE_VC1_D2010: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b81bea4_a0c7_11d3_b984_00c04f2e73c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_PROFILE_VP8: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x90b899ea_3a62_4705_88b3_8df04b2744e7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_PROFILE_VP9: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x463707f8_a1d0_4585_876d_83aa6d60b89e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_PROFILE_VP9_10BIT_PROFILE2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa4c749ef_6ecf_48aa_8448_50a7a1165ff7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Devices_Properties\"`*"]
#[cfg(feature = "Win32_Devices_Properties")]
pub const DEVPKEY_DeviceInterface_IsVirtualCamera: super::super::Devices::Properties::DEVPROPKEY = super::super::Devices::Properties::DEVPROPKEY { fmtid: ::windows::core::GUID::from_u128(0x6edc630d_c2e3_43b7_b2d1_20525a1af120), pid: 3 };
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Devices_Properties\"`*"]
#[cfg(feature = "Win32_Devices_Properties")]
pub const DEVPKEY_DeviceInterface_IsWindowsCameraEffectAvailable: super::super::Devices::Properties::DEVPROPKEY = super::super::Devices::Properties::DEVPROPKEY { fmtid: ::windows::core::GUID::from_u128(0x6edc630d_c2e3_43b7_b2d1_20525a1af120), pid: 4 };
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Devices_Properties\"`*"]
#[cfg(feature = "Win32_Devices_Properties")]
pub const DEVPKEY_DeviceInterface_VirtualCameraAssociatedCameras: super::super::Devices::Properties::DEVPROPKEY = super::super::Devices::Properties::DEVPROPKEY { fmtid: ::windows::core::GUID::from_u128(0x6edc630d_c2e3_43b7_b2d1_20525a1af120), pid: 5 };
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DSATTRIB_CAPTURE_STREAMTIME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0c1a5614_30cd_4f40_bcbf_d03e52306207);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DSATTRIB_CC_CONTAINER_INFO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe7e050fb_dd5d_40dd_9915_35dcb81bdc8a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DSATTRIB_DSHOW_STREAM_DESC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5fb5673b_0a2a_4565_827b_6853fd75e611);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DSATTRIB_OptionalVideoAttributes: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5a5f08ca_55c2_4033_92ab_55db8f781226);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DSATTRIB_PBDATAG_ATTRIBUTE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe0b56679_12b9_43cc_b7df_578caa5a7b63);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DSATTRIB_PicSampleSeq: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2f5bae02_7b8f_4f60_82d6_e4ea2f1f4c99);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DSATTRIB_SAMPLE_LIVE_STREAM_TIME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x892cd111_72f3_411d_8b91_a9e9123ac29a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DSATTRIB_TRANSPORT_PROPERTIES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb622f612_47ad_4671_ad6c_05a98e65de3a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DSATTRIB_UDCRTag: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xeb7836ca_14ff_4919_bce7_3af12319e50c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DECODE_GET_DRIVER_HANDLE: u32 = 1829u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DECODE_SPECIFY_ENCRYPTED_BLOCKS: u32 = 1828u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_E_NEW_VIDEO_DEVICE: ::windows::core::HRESULT = ::windows::core::HRESULT(-2147217407i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_E_NOT_AVAILABLE: ::windows::core::HRESULT = ::windows::core::HRESULT(-2147217405i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_E_NOT_INITIALIZED: ::windows::core::HRESULT = ::windows::core::HRESULT(-2147217408i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_E_VIDEO_DEVICE_LOCKED: ::windows::core::HRESULT = ::windows::core::HRESULT(-2147217406i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeH264_A: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b81be64_a0c7_11d3_b984_00c04f2e73c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeH264_B: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b81be65_a0c7_11d3_b984_00c04f2e73c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeH264_C: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b81be66_a0c7_11d3_b984_00c04f2e73c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeH264_D: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b81be67_a0c7_11d3_b984_00c04f2e73c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeH264_E: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b81be68_a0c7_11d3_b984_00c04f2e73c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeH264_F: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b81be69_a0c7_11d3_b984_00c04f2e73c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeH264_VLD_Multiview_NoFGT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x705b9d82_76cf_49d6_b7e6_ac8872db013c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeH264_VLD_Stereo_NoFGT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf9aaccbb_c2b6_4cfc_8779_5707b1760552);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeH264_VLD_Stereo_Progressive_NoFGT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd79be8da_0cf1_4c81_b82a_69a4e236f43d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeH264_VLD_WithFMOASO_NoFGT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd5f04ff9_3418_45d8_9561_32a76aae2ddd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeHEVC_VLD_Main: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5b11d51b_2f4c_4452_bcc3_09f2a1160cc0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeHEVC_VLD_Main10: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x107af0e0_ef1a_4d19_aba8_67a163073d13);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeMPEG1_VLD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6f3ec719_3735_42cc_8063_65cc3cb36616);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeMPEG2_IDCT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbf22ad00_03ea_4690_8077_473346209b7e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeMPEG2_MoComp: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe6a9f44b_61b0_4563_9ea4_63d2a3c6fe66);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeMPEG2_VLD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xee27417f_5e28_4e65_beea_1d26b508adc9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeMPEG2and1_VLD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x86695f12_340e_4f04_9fd3_9253dd327460);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeMPEG4pt2_VLD_AdvSimple_GMC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xab998b5b_4258_44a9_9feb_94e597a6baae);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeMPEG4pt2_VLD_AdvSimple_NoGMC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xed418a9f_010d_4eda_9ae3_9a65358d8d2e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeMPEG4pt2_VLD_Simple: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xefd64d74_c9e8_41d7_a5e9_e9b0e39fa319);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeVC1_A: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b81bea0_a0c7_11d3_b984_00c04f2e73c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeVC1_B: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b81bea1_a0c7_11d3_b984_00c04f2e73c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeVC1_C: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b81bea2_a0c7_11d3_b984_00c04f2e73c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeVC1_D: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b81bea3_a0c7_11d3_b984_00c04f2e73c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeVC1_D2010: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b81bea4_a0c7_11d3_b984_00c04f2e73c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeVP8_VLD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x90b899ea_3a62_4705_88b3_8df04b2744e7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeVP9_VLD_10bit_Profile2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa4c749ef_6ecf_48aa_8448_50a7a1165ff7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeVP9_VLD_Profile0: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x463707f8_a1d0_4585_876d_83aa6d60b89e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeWMV8_A: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b81be80_a0c7_11d3_b984_00c04f2e73c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeWMV8_B: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b81be81_a0c7_11d3_b984_00c04f2e73c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeWMV9_A: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b81be90_a0c7_11d3_b984_00c04f2e73c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeWMV9_B: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b81be91_a0c7_11d3_b984_00c04f2e73c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ModeWMV9_C: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b81be94_a0c7_11d3_b984_00c04f2e73c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_NoEncrypt: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b81bed0_a0c7_11d3_b984_00c04f2e73c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoProcBobDevice: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x335aa36e_7884_43a4_9c91_7f87faf3e37e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoProcProgressiveDevice: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5a54a0c9_c7ec_4bd9_8ede_f3c75dc4393b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoProcSoftwareDevice: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4553d47f_ee7e_4e3f_9475_dbf1376c4810);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHDControlGuid: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa0386e75_f70c_464c_a9ce_33c44e091623);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHDETWGUID_CREATEVIDEOPROCESSOR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x681e3d1e_5674_4fb3_a503_2f2055e91f60);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHDETWGUID_DESTROYVIDEOPROCESSOR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf943f0a0_3f16_43e0_8093_105a986aa5f1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHDETWGUID_VIDEOPROCESSBLTHD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbef3d435_78c7_4de3_9707_cd1b083b160a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHDETWGUID_VIDEOPROCESSBLTHD_STREAM: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x27ae473e_a5fc_4be5_b4e3_f24994d3c495);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHDETWGUID_VIDEOPROCESSBLTSTATE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x76c94b5a_193f_4692_9484_a4d999da81a8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHDETWGUID_VIDEOPROCESSSTREAMSTATE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x262c0b02_209d_47ed_94d8_82ae02b84aa7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_STREAM_STATE_PRIVATE_IVTC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9c601e3c_0f33_414c_a739_99540ee42da5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAp_DeinterlaceBobDevice: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x335aa36e_7884_43a4_9c91_7f87faf3e37e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAp_DeinterlaceContainerDevice: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0e85cb93_3046_4ff0_aecc_d58cb5f035fd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAp_ModeMPEG2_A: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b81be0a_a0c7_11d3_b984_00c04f2e73c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAp_ModeMPEG2_C: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b81be0c_a0c7_11d3_b984_00c04f2e73c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAp_NoEncrypt: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b81bed0_a0c7_11d3_b984_00c04f2e73c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const ENCAPIPARAM_BITRATE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x49cc4c43_ca83_4ad4_a9af_f3696af666df);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const ENCAPIPARAM_BITRATE_MODE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xee5fb25c_c713_40d1_9d58_c0d7241e250f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const ENCAPIPARAM_PEAK_BITRATE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x703f16a9_3d48_44a1_b077_018dff915d19);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const ENCAPIPARAM_SAP_MODE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0c0171db_fefc_4af7_9991_a5657c191cd1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const EVRConfig_ForceBatching: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe447df09_10ca_4d17_b17e_6a840f8a3a4c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const EVRConfig_ForceBob: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe447df01_10ca_4d17_b17e_6a840f8a3a4c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const EVRConfig_ForceHalfInterlace: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe447df05_10ca_4d17_b17e_6a840f8a3a4c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const EVRConfig_ForceScaling: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe447df07_10ca_4d17_b17e_6a840f8a3a4c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const EVRConfig_ForceThrottle: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe447df03_10ca_4d17_b17e_6a840f8a3a4c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const E_TOCPARSER_INVALIDASFFILE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1728053247i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const E_TOCPARSER_INVALIDRIFFFILE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1728053246i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const FACILITY_MF: u32 = 13u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const FACILITY_MF_WIN32: u32 = 7u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const FORMAT_525WSS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc7ecf04d_4582_4869_9abb_bfb523b62edf);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const FORMAT_AnalogVideo: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0482dde0_7817_11cf_8a03_00aa006ecb65);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const FORMAT_CAPTIONED_H264VIDEO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa4efc024_873e_4da3_898b_474ddbd79fd0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const FORMAT_CAPTIONED_MPEG2VIDEO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7ab2ada2_81b6_4f14_b3c8_d0c486393b67);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const FORMAT_CC_CONTAINER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x50997a4a_e508_4054_a2b2_10ff0ac1a69a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const FORMAT_DvInfo: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x05589f84_c356_11ce_bf01_00aa0055595a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const FORMAT_MFVideoFormat: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xaed4ab2d_7326_43cb_9464_c879cab9c43d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const FORMAT_MPEGStreams: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x05589f83_c356_11ce_bf01_00aa0055595a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const FORMAT_MPEGVideo: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x05589f82_c356_11ce_bf01_00aa0055595a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const FORMAT_None: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0f6417d6_c318_11d0_a43f_00a0c9223196);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const FORMAT_VideoInfo: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x05589f80_c356_11ce_bf01_00aa0055595a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const FORMAT_VideoInfo2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf72a76a0_eb0a_11d0_ace4_0000c0cc16ba);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const FORMAT_WaveFormatEx: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x05589f81_c356_11ce_bf01_00aa0055595a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const GUID_NativeDeviceService: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xef71e53c_52f4_43c5_b86a_ad6cb216a61e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const GUID_PlayToService: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf6a8ff9d_9e14_41c9_bf0f_120a2b3ce120);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const KSPROPERTYSETID_ANYCAMERACONTROL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x94dd0c30_28c7_4efb_9d6b_812300fb0c7f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const KSPROPSETID_OPMVideoOutput: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x06f414bb_f43a_4fe2_a566_774b4c81f0db);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const LOCAL_D3DFMT_DEFINES: u32 = 1u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const LOOK_DOWNSTREAM_ONLY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xac798be1_98e3_11d1_b3f1_00aa003761c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const LOOK_UPSTREAM_ONLY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xac798be0_98e3_11d1_b3f1_00aa003761c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MACROBLOCK_FLAG_DIRTY: u32 = 2u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MACROBLOCK_FLAG_HAS_MOTION_VECTOR: u32 = 16u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MACROBLOCK_FLAG_HAS_QP: u32 = 32u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MACROBLOCK_FLAG_MOTION: u32 = 4u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MACROBLOCK_FLAG_SKIP: u32 = 1u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MACROBLOCK_FLAG_VIDEO: u32 = 8u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MAX_SUBSTREAMS: u32 = 15u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASINK_CANNOT_MATCH_CLOCK: u32 = 2u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASINK_CAN_PREROLL: u32 = 16u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASINK_CLOCK_REQUIRED: u32 = 8u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASINK_FIXED_STREAMS: u32 = 1u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASINK_RATELESS: u32 = 4u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASINK_REQUIRE_REFERENCE_MEDIATYPE: u32 = 32u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_420O: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4f303234_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_708_608Data: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0af414bc_4ed2_445e_9839_8f095568ab3c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_A2B10G10R10: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x576f7893_bdf6_48c4_875f_ae7b81834567);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_A2R10G10B10: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2f8bb76d_b644_4550_acf3_d30caa65d5c5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_AI44: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x34344941_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_AIFF: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb8d_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_ARGB1555: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x297c55af_e209_4cb3_b757_c76d6b9c88a8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_ARGB1555_D3D_DX7_RT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x35314137_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_ARGB1555_D3D_DX9_RT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x35314139_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_ARGB32: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x773c9ac0_3274_11d0_b724_00aa006c1a01);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_ARGB32_D3D_DX7_RT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x38384137_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_ARGB32_D3D_DX9_RT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x38384139_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_ARGB4444: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6e6415e6_5c24_425f_93cd_80102b3d1cca);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_ARGB4444_D3D_DX7_RT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x34344137_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_ARGB4444_D3D_DX9_RT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x34344139_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_AU: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb8c_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_AVC1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x31435641_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_AYUV: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x56555941_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_AnalogVideo_NTSC_M: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0482dde2_7817_11cf_8a03_00aa006ecb65);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_AnalogVideo_PAL_B: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0482dde5_7817_11cf_8a03_00aa006ecb65);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_AnalogVideo_PAL_D: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0482dde6_7817_11cf_8a03_00aa006ecb65);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_AnalogVideo_PAL_G: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0482dde7_7817_11cf_8a03_00aa006ecb65);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_AnalogVideo_PAL_H: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0482dde8_7817_11cf_8a03_00aa006ecb65);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_AnalogVideo_PAL_I: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0482dde9_7817_11cf_8a03_00aa006ecb65);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_AnalogVideo_PAL_M: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0482ddea_7817_11cf_8a03_00aa006ecb65);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_AnalogVideo_PAL_N: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0482ddeb_7817_11cf_8a03_00aa006ecb65);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_AnalogVideo_PAL_N_COMBO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0482ddec_7817_11cf_8a03_00aa006ecb65);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_AnalogVideo_SECAM_B: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0482ddf0_7817_11cf_8a03_00aa006ecb65);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_AnalogVideo_SECAM_D: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0482ddf1_7817_11cf_8a03_00aa006ecb65);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_AnalogVideo_SECAM_G: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0482ddf2_7817_11cf_8a03_00aa006ecb65);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_AnalogVideo_SECAM_H: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0482ddf3_7817_11cf_8a03_00aa006ecb65);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_AnalogVideo_SECAM_K: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0482ddf4_7817_11cf_8a03_00aa006ecb65);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_AnalogVideo_SECAM_K1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0482ddf5_7817_11cf_8a03_00aa006ecb65);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_AnalogVideo_SECAM_L: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0482ddf6_7817_11cf_8a03_00aa006ecb65);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_Asf: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3db80f90_9412_11d1_aded_0000f8754b99);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_Avi: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb88_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_CC_CONTAINER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7ea626db_54da_437b_be9f_f73073adfa3c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_CFCC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x43434643_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_CLJR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x524a4c43_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_CLPL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4c504c43_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_CPLA: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x414c5043_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_DOLBY_AC3_SPDIF: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000092_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_DOLBY_DDPLUS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa7fb87af_2d02_42fb_a4d4_05cd93843bdd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_DOLBY_TRUEHD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xeb27cec4_163e_4ca3_8b74_8e25f91b517e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_DRM_Audio: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000009_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_DTS2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00002001_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_DTS_HD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa2e58eb7_0fa9_48bb_a40c_fa0e156d0645);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_DTS_HD_HRA: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa61ac364_ad0e_4744_89ff_213ce0df8804);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_DVB_SUBTITLES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x34ffcbc3_d5b3_4171_9002_d4c60301697f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_DVCS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x53435644_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_DVM: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00002000_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_DVSD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x44535644_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_DssAudio: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa0af4f82_e163_11d0_bad9_00609744111a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_DssVideo: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa0af4f81_e163_11d0_bad9_00609744111a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_DtvCcData: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf52addaa_36f0_43f5_95ea_6d866484262a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_H264: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x34363248_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_I420: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x30323449_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_IA44: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x34344149_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_IEEE_FLOAT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000003_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_IF09: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x39304649_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_IJPG: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x47504a49_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_IMC1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x31434d49_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_IMC2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x32434d49_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_IMC3: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x33434d49_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_IMC4: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x34434d49_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_ISDB_CAPTIONS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x059dd67d_2e55_4d41_8d1b_01f5e4f50607);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_ISDB_SUPERIMPOSE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x36dc6d28_f1a6_4216_9048_9cfcefeb5eba);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_IYUV: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x56555949_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_Line21_BytePair: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6e8d4a22_310c_11d0_b79a_00aa003767a7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_Line21_GOPPacket: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6e8d4a23_310c_11d0_b79a_00aa003767a7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_Line21_VBIRawData: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6e8d4a24_310c_11d0_b79a_00aa003767a7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_M4S2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3253344d_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_MDVF: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4656444d_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_MJPG: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x47504a4d_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_MP42: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3234504d_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_MP43: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3334504d_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_MP4S: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5334504d_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_MPEG1Audio: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb87_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_MPEG1AudioPayload: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000050_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_MPEG1Packet: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb80_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_MPEG1Payload: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb81_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_MPEG1System: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb84_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_MPEG1Video: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb86_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_MPEG1VideoCD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb85_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_MPEG_ADTS_AAC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00001600_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_MPEG_HEAAC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00001610_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_MPEG_LOAS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00001602_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_MPEG_RAW_AAC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00001601_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_MPG4: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3447504d_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_MSAUDIO1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000160_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_MSS1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3153534d_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_MSS2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3253534d_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_NOKIA_MPEG_ADTS_AAC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00001608_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_NOKIA_MPEG_RAW_AAC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00001609_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_NV11: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3131564e_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_NV12: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3231564e_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_NV24: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3432564e_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_None: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb8e_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_Overlay: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb7f_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_P010: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x30313050_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_P016: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x36313050_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_P208: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x38303250_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_P210: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x30313250_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_P216: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x36313250_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_P408: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x38303450_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_PCM: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000001_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_PCMAudio_Obsolete: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb8a_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_Plum: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6d756c50_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_QTJpeg: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6765706a_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_QTMovie: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb89_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_QTRle: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x20656c72_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_QTRpza: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x617a7072_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_QTSmc: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x20636d73_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_RAW_AAC1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x000000ff_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_RAW_SPORT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000240_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_RGB1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb78_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_RGB16_D3D_DX7_RT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x36315237_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_RGB16_D3D_DX9_RT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x36315239_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_RGB24: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb7d_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_RGB32: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb7e_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_RGB32_D3D_DX7_RT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x32335237_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_RGB32_D3D_DX9_RT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x32335239_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_RGB4: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb79_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_RGB555: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb7c_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_RGB565: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb7b_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_RGB8: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb7a_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_S340: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x30343353_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_S342: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x32343353_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_SPDIF_TAG_241h: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000241_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_TELETEXT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf72a76e3_eb0a_11d0_ace4_0000c0cc16ba);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_TVMJ: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4a4d5654_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_UYVY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x59565955_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_V216: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x36313256_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_V410: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x30313456_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_VBI: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x663da43c_03e8_4e9a_9cd5_bf11ed0def76);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_VODAFONE_MPEG_ADTS_AAC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0000160a_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_VODAFONE_MPEG_RAW_AAC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0000160b_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_VPS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa1b3f620_9792_4d8d_81a4_86af25772090);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_VPVBI: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5a9b6a41_1a22_11d1_bad9_00609744111a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_VPVideo: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5a9b6a40_1a22_11d1_bad9_00609744111a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_WAKE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x454b4157_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_WAVE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb8b_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_WMASPDIF: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000164_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_WMAUDIO2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000161_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_WMAUDIO3: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000162_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_WMAUDIO4: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000168_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_WMAUDIO_LOSSLESS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000163_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_WMV1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x31564d57_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_WMV2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x32564d57_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_WMV3: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x33564d57_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_WMVA: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x41564d57_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_WMVB: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x42564d57_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_WMVP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x50564d57_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_WMVR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x52564d57_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_WSS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2791d576_8e7a_466f_9e90_5d3f3083738b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_WVC1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x31435657_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_WVP2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x32505657_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_X264: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x34363258_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_XDS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x01ca73e3_dce6_4575_afe1_2bf1c902caf3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_Y210: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x30313259_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_Y211: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x31313259_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_Y216: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x36313259_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_Y411: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x31313459_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_Y41P: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x50313459_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_Y41T: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x54313459_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_Y42T: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x54323459_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_YUY2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x32595559_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_YUYV: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x56595559_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_YV12: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x32315659_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_YVU9: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x39555659_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_YVYU: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x55595659_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_dv25: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x35327664_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_dv50: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x30357664_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_dvh1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x31687664_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_dvhd: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x64687664_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_dvsl: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6c737664_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIASUBTYPE_v210: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x30313276_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIATYPE_AUXLine21Data: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x670aea80_3a82_11d0_b79b_00aa003767a7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIATYPE_AUXTeletextPage: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x11264acb_37de_4eba_8c35_7f04a1a68332);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIATYPE_AnalogAudio: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0482dee1_7817_11cf_8a03_00aa006ecb65);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIATYPE_AnalogVideo: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0482dde1_7817_11cf_8a03_00aa006ecb65);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIATYPE_Audio: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x73647561_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIATYPE_CC_CONTAINER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xaeb312e9_3357_43ca_b701_97ec198e2b62);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIATYPE_DTVCCData: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfb77e152_53b2_499c_b46b_509fc33edfd7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIATYPE_File: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x656c6966_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIATYPE_Interleaved: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x73766169_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIATYPE_LMRT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x74726c6d_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIATYPE_MPEG1SystemStream: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb82_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIATYPE_MSTVCaption: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb88b8a89_b049_4c80_adcf_5898985e22c1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIATYPE_Midi: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7364696d_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIATYPE_ScriptCommand: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x73636d64_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIATYPE_Stream: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb83_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIATYPE_Text: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x73747874_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIATYPE_Timecode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0482dee3_7817_11cf_8a03_00aa006ecb65);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIATYPE_URL_STREAM: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x736c7275_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIATYPE_VBI: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf72a76e1_eb0a_11d0_ace4_0000c0cc16ba);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDIATYPE_Video: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x73646976_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDeviceStreamCreated: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0252a1cf_3540_43b4_9164_d72eb405fa40);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAMRNBByteStreamHandler: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xefe6208a_0a2c_49fa_8a01_3768b559b6da);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAMRNBSinkClassFactory: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb0271158_70d2_4c5b_9f94_76f549d90fdf);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASFINDEXER_APPROX_SEEK_TIME_UNKNOWN: u64 = 18446744073709551615u64;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASFINDEXER_NO_FIXED_INTERVAL: u32 = 4294967295u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASFINDEXER_PER_ENTRY_BYTES_DYNAMIC: u32 = 65535u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASFINDEXER_READ_FOR_REVERSEPLAYBACK_OUTOFDATASEGMENT: u64 = 18446744073709551615u64;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASFINDEXER_TYPE_TIMECODE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x49815231_6bad_44fd_810a_3f60984ec7fd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASFMutexType_Bitrate: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x72178c2c_e45b_11d5_bc2a_00b0d0f3f4ab);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASFMutexType_Language: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x72178c2b_e45b_11d5_bc2a_00b0d0f3f4ab);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASFMutexType_Presentation: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x72178c2d_e45b_11d5_bc2a_00b0d0f3f4ab);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASFMutexType_Unknown: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x72178c2e_e45b_11d5_bc2a_00b0d0f3f4ab);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASFSPLITTER_PACKET_BOUNDARY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfe584a05_e8d6_42e3_b176_f1211705fb6f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASFSampleExtension_ContentType: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd590dc20_07bc_436c_9cf7_f3bbfbf1a4dc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASFSampleExtension_Encryption_KeyID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x76376591_795f_4da1_86ed_9d46eca109a9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASFSampleExtension_Encryption_SampleID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6698b84e_0afa_4330_aeb2_1c0a98d7a44d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASFSampleExtension_FileName: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe165ec0e_19ed_45d7_b4a7_25cbd1e28e9b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASFSampleExtension_OutputCleanPoint: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf72a3c6f_6eb4_4ebc_b192_09ad9759e828);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASFSampleExtension_PixelAspectRatio: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1b1ee554_f9ea_4bc8_821a_376b74e4c4b8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASFSampleExtension_SMPTE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x399595ec_8667_4e2d_8fdb_98814ce76c1e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASFSampleExtension_SampleDuration: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc6bd9450_867f_4907_83a3_c77921b733ad);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASF_DEFAULT_BUFFER_WINDOW_MS: u32 = 3000u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASF_INVALID_STREAM_NUMBER: u32 = 128u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASF_MAX_STREAM_NUMBER: u32 = 127u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASF_PAYLOADEXTENSION_MAX_SIZE: u32 = 255u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASF_PAYLOADEXTENSION_VARIABLE_SIZE: u32 = 65535u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASYNC_BLOCKING_CALLBACK: u32 = 4u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASYNC_CALLBACK_QUEUE_ALL: u32 = 4294967295u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASYNC_CALLBACK_QUEUE_IO: u32 = 3u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASYNC_CALLBACK_QUEUE_LONG_FUNCTION: u32 = 7u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASYNC_CALLBACK_QUEUE_MULTITHREADED: u32 = 5u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASYNC_CALLBACK_QUEUE_PRIVATE_MASK: u32 = 4294901760u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASYNC_CALLBACK_QUEUE_RT: u32 = 2u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASYNC_CALLBACK_QUEUE_STANDARD: u32 = 1u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASYNC_CALLBACK_QUEUE_TIMER: u32 = 4u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASYNC_CALLBACK_QUEUE_UNDEFINED: u32 = 0u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASYNC_FAST_IO_PROCESSING_CALLBACK: u32 = 1u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASYNC_LOCALIZE_REMOTE_CALLBACK: u32 = 16u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASYNC_REPLY_CALLBACK: u32 = 8u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASYNC_SIGNAL_CALLBACK: u32 = 2u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_AAC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00001610_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_AAC_HDCP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x419bce76_8b72_400f_adeb_84b57d63484d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_ADTS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00001600_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_ADTS_HDCP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xda4963a3_14d8_4dcf_92b7_193eb84363db);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_ALAC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00006c61_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_AMR_NB: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00007361_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_AMR_WB: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00007362_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_AMR_WP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00007363_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_Base: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000000_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_Base_HDCP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3884b5bc_e277_43fd_983d_038aa8d9b605);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_DRM: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000009_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_DTS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000008_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_DTS_HD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa2e58eb7_0fa9_48bb_a40c_fa0e156d0645);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_DTS_LBR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc2fe6f0a_4e3c_4df1_9b60_50863091e4b9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_DTS_RAW: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe06d8033_db46_11cf_b4d1_00805f6cbbea);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_DTS_UHD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x87020117_ace3_42de_b73e_c656706263f8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_DTS_UHDY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9b9cca00_91b9_4ccc_883a_8f787ac3cc86);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_DTS_XLL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x45b37c1b_8c70_4e59_a7be_a1e42c81c80d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_Dolby_AC3: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe06d802c_db46_11cf_b4d1_00805f6cbbea);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_Dolby_AC3_HDCP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x97663a80_8ffb_4445_a6ba_792d908f497f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_Dolby_AC3_SPDIF: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000092_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_Dolby_AC4: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0000ac40_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_Dolby_AC4_V1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x36b7927c_3d87_4a2a_9196_a21ad9e935e6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_Dolby_AC4_V1_ES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9d8dccc6_d156_4fb8_979c_a85be7d21dfa);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_Dolby_AC4_V2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7998b2a0_17dd_49b6_8dfa_9b278552a2ac);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_Dolby_AC4_V2_ES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7e58c9f9_b070_45f4_8ccd_a99a0417c1ac);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_Dolby_DDPlus: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa7fb87af_2d02_42fb_a4d4_05cd93843bdd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_FLAC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0000f1ac_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_Float: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000003_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_Float_SpatialObjects: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfa39cd94_bc64_4ab1_9b71_dcd09d5a7e7a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_LPCM: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe06d8032_db46_11cf_b4d1_00805f6cbbea);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_MP3: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000055_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_MPEG: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000050_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_MSP1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0000000a_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_Opus: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0000704f_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_PCM: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000001_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_PCM_HDCP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa5e7ff01_8411_4acc_a865_5f4941288d80);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_Vorbis: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8d2fd10b_5841_4a6b_8905_588fec1aded9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_WMASPDIF: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000164_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_WMAudioV8: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000161_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_WMAudioV9: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000162_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFAudioFormat_WMAudio_Lossless: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000163_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFBYTESTREAM_DOES_NOT_USE_NETWORK: u32 = 2048u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFBYTESTREAM_HAS_SLOW_SEEK: u32 = 256u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFBYTESTREAM_IS_DIRECTORY: u32 = 128u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFBYTESTREAM_IS_PARTIALLY_DOWNLOADED: u32 = 512u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFBYTESTREAM_IS_READABLE: u32 = 1u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFBYTESTREAM_IS_REMOTE: u32 = 8u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFBYTESTREAM_IS_SEEKABLE: u32 = 4u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFBYTESTREAM_IS_WRITABLE: u32 = 2u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFBYTESTREAM_SEEK_FLAG_CANCEL_PENDING_IO: u32 = 1u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFBYTESTREAM_SHARE_WRITE: u32 = 1024u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCAPTURE_METADATA_SCANLINE_VERTICAL: u32 = 4u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCAPTURE_METADATA_SCAN_BOTTOM_TOP: u32 = 2u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCAPTURE_METADATA_SCAN_RIGHT_LEFT: u32 = 1u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCLOCK_FREQUENCY_HNS: u32 = 10000000u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCLOCK_JITTER_DPC: u32 = 4000u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCLOCK_JITTER_ISR: u32 = 1000u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCLOCK_JITTER_PASSIVE: u32 = 10000u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCLOCK_TOLERANCE_UNKNOWN: u32 = 50000u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONNECTOR_AGP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xac3aef60_ce43_11d9_92db_000bdb28ff98);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONNECTOR_COMPONENT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x57cd596b_ce47_11d9_92db_000bdb28ff98);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONNECTOR_COMPOSITE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x57cd596a_ce47_11d9_92db_000bdb28ff98);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONNECTOR_DISPLAYPORT_EMBEDDED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x57cd5973_ce47_11d9_92db_000bdb28ff98);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONNECTOR_DISPLAYPORT_EXTERNAL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x57cd5972_ce47_11d9_92db_000bdb28ff98);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONNECTOR_DVI: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x57cd596c_ce47_11d9_92db_000bdb28ff98);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONNECTOR_D_JPN: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x57cd5970_ce47_11d9_92db_000bdb28ff98);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONNECTOR_HDMI: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x57cd596d_ce47_11d9_92db_000bdb28ff98);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONNECTOR_LVDS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x57cd596e_ce47_11d9_92db_000bdb28ff98);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONNECTOR_MIRACAST: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x57cd5977_ce47_11d9_92db_000bdb28ff98);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONNECTOR_PCI: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xac3aef5d_ce43_11d9_92db_000bdb28ff98);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONNECTOR_PCIX: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xac3aef5e_ce43_11d9_92db_000bdb28ff98);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONNECTOR_PCI_Express: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xac3aef5f_ce43_11d9_92db_000bdb28ff98);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONNECTOR_SDI: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x57cd5971_ce47_11d9_92db_000bdb28ff98);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONNECTOR_SPDIF: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0b94a712_ad3e_4cee_83ce_ce32e3db6522);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONNECTOR_SVIDEO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x57cd5969_ce47_11d9_92db_000bdb28ff98);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONNECTOR_TRANSPORT_AGNOSTIC_DIGITAL_MODE_A: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x57cd5978_ce47_11d9_92db_000bdb28ff98);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONNECTOR_TRANSPORT_AGNOSTIC_DIGITAL_MODE_B: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x57cd5979_ce47_11d9_92db_000bdb28ff98);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONNECTOR_UDI_EMBEDDED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x57cd5975_ce47_11d9_92db_000bdb28ff98);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONNECTOR_UDI_EXTERNAL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x57cd5974_ce47_11d9_92db_000bdb28ff98);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONNECTOR_UNKNOWN: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xac3aef5c_ce43_11d9_92db_000bdb28ff98);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONNECTOR_VGA: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x57cd5968_ce47_11d9_92db_000bdb28ff98);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONTENTPROTECTIONDEVICE_FUNCTIONID_START: u32 = 67108864u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCONTENTPROTECTIONDEVICE_REALTIMECLIENT_DATA_FUNCTIONID: u32 = 67108864u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFENABLETYPE_MF_RebootRequired: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6d4d3d4b_0ece_4652_8b3a_f2d24260d887);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFENABLETYPE_MF_UpdateRevocationInformation: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe558b0b5_b3c4_44a0_924c_50d178932385);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFENABLETYPE_MF_UpdateUntrustedComponent: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9879f3d6_cee2_48e6_b573_9767ab172f16);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFENABLETYPE_WMDRMV1_LicenseAcquisition: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4ff6eeaf_0b43_4797_9b85_abf31815e7b0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFENABLETYPE_WMDRMV7_Individualization: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xacd2c84a_b303_4f65_bc2c_2c848d01a989);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFENABLETYPE_WMDRMV7_LicenseAcquisition: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x003306df_4a06_4884_a097_ef6d22ec84a3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFEVRDLL: u32 = 0u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFFLACBytestreamHandler: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0e41cfb8_0506_40f4_a516_77cc23642d91);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFFLACSinkClassFactory: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7d39c56f_6075_47c9_9bae_8cf9e531b5f5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFImageFormat_JPEG: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x19e4a5aa_5662_4fc5_a0c0_1758028e1057);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFImageFormat_RGB32: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000016_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMPEG4Format_Base: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000000_767a_494d_b478_f29d25dc9037);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMediaType_Audio: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x73647561_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMediaType_Binary: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x72178c25_e45b_11d5_bc2a_00b0d0f3f4ab);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMediaType_Default: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x81a412e6_8103_4b06_857f_1862781024ac);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMediaType_FileTransfer: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x72178c26_e45b_11d5_bc2a_00b0d0f3f4ab);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMediaType_HTML: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x72178c24_e45b_11d5_bc2a_00b0d0f3f4ab);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMediaType_Image: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x72178c23_e45b_11d5_bc2a_00b0d0f3f4ab);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMediaType_Metadata: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2c8fa20c_82bb_4782_90a0_98a2a5bd8ef8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMediaType_MultiplexedFrames: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6ea542b0_281f_4231_a464_fe2f5022501c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMediaType_Perception: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x597ff6f9_6ea2_4670_85b4_ea84073fe940);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMediaType_Protected: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7b4b6fe6_9d04_4494_be14_7e0bd076c8e4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMediaType_SAMI: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe69669a0_3dcd_40cb_9e2e_3708387c0616);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMediaType_Script: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x72178c22_e45b_11d5_bc2a_00b0d0f3f4ab);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMediaType_Stream: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe436eb83_524f_11ce_9f53_0020af0ba770);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMediaType_Subtitle: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa6d13581_ed50_4e65_ae08_26065576aacc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMediaType_Video: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x73646976_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_ACCELERATEDSTREAMINGDURATION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f277_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_AUTORECONNECTLIMIT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f27a_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_AUTORECONNECTPROGRESS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f282_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_BROWSERUSERAGENT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f28b_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_BROWSERWEBPAGE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f28c_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_BUFFERINGTIME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f276_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_CACHEENABLED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f279_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_CLIENTGUID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x60a2c4a6_f197_4c14_a5bf_88830d2458af);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_CONNECTIONBANDWIDTH: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f278_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_CREDENTIAL_MANAGER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f280_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_CROSS_ORIGIN_SUPPORT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9842207c_b02c_4271_a2fc_72e49308e5c2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_DRMNET_LICENSE_REPRESENTATION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x47eae1bd_bdfe_42e2_82f3_54a48c17962d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_ENABLE_DOWNLOAD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f29d_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_ENABLE_HTTP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f299_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_ENABLE_MSB: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f296_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_ENABLE_PRIVATEMODE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x824779d8_f18b_4405_8cf1_464fb5aa8f71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_ENABLE_RTSP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f298_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_ENABLE_STREAMING: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f29c_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_ENABLE_TCP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f295_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_ENABLE_UDP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f294_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_FRIENDLYNAME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5b2a7757_bc6b_447e_aa06_0dda1c646e2f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_HOSTEXE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f28f_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_HOSTVERSION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f291_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_HTTP_DOWNLOAD_SESSION_PROVIDER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7d55081e_307d_4d6d_a663_a93be97c4b5c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_LOGPARAMS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x64936ae8_9418_453a_8cda_3e0a668b353b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_LOGURL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f293_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_MAXBUFFERTIMEMS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x408b24e6_4038_4401_b5b2_fe701a9ebf10);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_MAXUDPACCELERATEDSTREAMINGDURATION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4aab2879_bbe1_4994_9ff0_5495bd250129);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_PEERMANAGER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x48b29adb_febf_45ee_a9bf_efb81c492efc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_PLAYERID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f28e_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_PLAYERUSERAGENT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f292_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_PLAYERVERSION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f28d_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_PPBANDWIDTH: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f281_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_PREVIEWMODEENABLED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f27f_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_PROTOCOL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f27d_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_PROXYBYPASSFORLOCAL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f286_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_PROXYEXCEPTIONLIST: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f285_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_PROXYHOSTNAME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f284_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_PROXYINFO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f29b_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_PROXYLOCATORFACTORY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f283_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_PROXYPORT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f288_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_PROXYRERUNAUTODETECTION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f289_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_PROXYSETTINGS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f287_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_RESENDSENABLED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f27b_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_RESOURCE_FILTER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x815d0ff6_265a_4477_9e46_7b80ad80b5fb);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_SSLCERTIFICATE_MANAGER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x55e6cb27_e69b_4267_940c_2d7ec5bb8a0f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_STATISTICS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f274_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_STATISTICS_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f275_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_STREAM_LANGUAGE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9ab44318_f7cd_4f2d_8d6d_fa35b492cecb);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_THINNINGENABLED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f27c_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_TRANSPORT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f27e_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_UDP_PORT_RANGE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cb1f29a_0505_4c5d_ae71_0a556344efa1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNET_SAVEJOB_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb85a587f_3d02_4e52_9565_55d3ec1e7ff7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFPROTECTIONATTRIBUTE_BEST_EFFORT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc8e06331_75f0_4ec1_8e77_17578f773b46);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFPROTECTIONATTRIBUTE_CONSTRICTVIDEO_IMAGESIZE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x008476fc_4b58_4d80_a790_e7297673161d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFPROTECTIONATTRIBUTE_FAIL_OVER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8536abc5_38f1_4151_9cce_f55d941229ac);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFPROTECTIONATTRIBUTE_HDCP_SRM: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6f302107_3477_4468_8a08_eef9db10e20f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFPROTECTION_ACP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc3fd11c6_f8b7_4d20_b008_1db17d61f2da);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFPROTECTION_CGMSA: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe57e69e9_226b_4d31_b4e3_d3db008736dd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFPROTECTION_CONSTRICTAUDIO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xffc99b44_df48_4e16_8e66_096892c1578a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFPROTECTION_CONSTRICTVIDEO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x193370ce_c5e4_4c3a_8a66_6959b4da4442);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFPROTECTION_CONSTRICTVIDEO_NOOPM: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa580e8cd_c247_4957_b983_3c2eebd1ff59);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFPROTECTION_DISABLE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8cc6d81b_fec6_4d8f_964b_cfba0b0dad0d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFPROTECTION_DISABLE_SCREEN_SCRAPE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa21179a4_b7cd_40d8_9614_8ef2371ba78d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFPROTECTION_FFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x462a56b2_2866_4bb6_980d_6d8d9edb1a8c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFPROTECTION_GRAPHICS_TRANSFER_AES_ENCRYPTION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc873de64_d8a5_49e6_88bb_fb963fd3d4ce);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFPROTECTION_HARDWARE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4ee7f0c1_9ed7_424f_b6be_996b33528856);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFPROTECTION_HDCP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xae7cc03d_c828_4021_acb7_d578d27aaf13);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFPROTECTION_HDCP_WITH_TYPE_ENFORCEMENT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa4a585e8_ed60_442d_814d_db4d4220a06d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFPROTECTION_PROTECTED_SURFACE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4f5d9566_e742_4a25_8d1f_d287b5fa0ade);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFPROTECTION_TRUSTEDAUDIODRIVERS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x65bdf3d2_0168_4816_a533_55d47b027101);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFPROTECTION_VIDEO_FRAMES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x36a59cbc_7401_4a8c_bc20_46a7c9e597f0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFPROTECTION_WMDRMOTA: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa267a6a1_362e_47d0_8805_4628598a23e4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_POSITIONTYPE_100NS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000000_0000_0000_0000_000000000000);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFRR_INFO_VERSION: u32 = 0u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSEQUENCER_INVALID_ELEMENT_ID: u32 = 4294967295u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSESSIONCAP_DOES_NOT_USE_NETWORK: u32 = 64u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSESSIONCAP_PAUSE: u32 = 4u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSESSIONCAP_RATE_FORWARD: u32 = 16u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSESSIONCAP_RATE_REVERSE: u32 = 32u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSESSIONCAP_SEEK: u32 = 2u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSESSIONCAP_START: u32 = 1u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSTARTUP_FULL: u32 = 0u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSTARTUP_LITE: u32 = 1u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSTARTUP_NOSOCKET: u32 = 1u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_3DVideo: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf86f97a4_dd54_4e2e_9a5e_55fc2d74a005);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_3DVideo_SampleFormat: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x08671772_e36f_4cff_97b3_d72e20987a48);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_AccumulatedNonRefPicPercent: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x79ea74df_a740_445b_bc98_c9ed1f260eee);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_BottomFieldFirst: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x941ce0a3_6ae3_4dda_9a08_a64298340617);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_CameraExtrinsics: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6b761658_b7ec_4c3b_8225_8623cabec31d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_CaptureMetadata: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2ebe23a8_faf5_444a_a6a2_eb810880ab5d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_ChromaOnly: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1eb9179c_a01f_4845_8c04_0e65a26eb04f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_CleanPoint: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9cdf01d8_a0f0_43ba_b077_eaa06cbd728a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_ClosedCaption_CEA708: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x26f09068_e744_47dc_aa03_dbf20403bde6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_ClosedCaption_CEA708_MAX_SIZE: u32 = 256u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Content_KeyID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc6c7f5b0_acca_415b_87d9_10441469efc6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_DecodeTimestamp: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x73a954d4_09e2_4861_befc_94bd97c08e6e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Depth_MaxReliableDepth: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe45545d1_1f0f_4a32_a8a7_6101a24ea8be);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Depth_MinReliableDepth: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5f8582b2_e36b_47c8_9b87_fee1ca72c5b0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_DerivedFromTopField: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6852465a_ae1c_4553_8e9b_c3420fcb1637);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_DescrambleData: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x43483be6_4903_4314_b032_2951365936fc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_DeviceReferenceSystemTime: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6523775a_ba2d_405f_b2c5_01ff88e2e8f6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_DeviceTimestamp: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8f3e35e7_2dcd_4887_8622_2a58baa652b0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_DirtyRects: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9ba70225_b342_4e97_9126_0b566ab7ea7e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Discontinuity: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9cdf01d9_a0f0_43ba_b077_eaa06cbd728a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Encryption_ClearSliceHeaderData: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5509a4f4_320d_4e6c_8d1a_94c66dd20cb0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Encryption_CryptByteBlock: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9d84289b_0c7f_4713_ab95_108ab42ad801);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Encryption_HardwareProtection: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9a2b2d2b_8270_43e3_8448_994f426e8886);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Encryption_HardwareProtection_KeyInfo: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb2372080_455b_4dd7_9989_1a955784b754);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Encryption_HardwareProtection_KeyInfoID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8cbfcceb_94a5_4de1_8231_a85e47cf81e7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Encryption_HardwareProtection_VideoDecryptorContext: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x693470c8_e837_47a0_88cb_535b905e3582);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Encryption_KeyID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x76376591_795f_4da1_86ed_9d46eca109a9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Encryption_NALUTypes: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb0f067c7_714c_416c_8d59_5f4ddf8913b6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Encryption_Opaque_Data: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x224d77e5_1391_4ffb_9f41_b432f68c611d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Encryption_ProtectionScheme: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd054d096_28bb_45da_87ec_74f351871406);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Encryption_ResumeVideoOutput: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa435aba5_afde_4cf5_bc1c_f6acaf13949d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Encryption_SEIData: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cf0e972_4542_4687_9999_585f565fba7d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Encryption_SPSPPSData: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xaede0fa2_0e0c_453c_b7f3_de8693364d11);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Encryption_SampleID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6698b84e_0afa_4330_aeb2_1c0a98d7a44d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Encryption_SkipByteBlock: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0d550548_8317_4ab1_845f_d06306e293e3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Encryption_SubSampleMappingSplit: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfe0254b9_2aa5_4edc_99f7_17e89dbf9174);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Encryption_SubSample_Mapping: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8444f27a_69a1_48da_bd08_11cef36830d2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_ExtendedCameraIntrinsics: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x560bc4a5_4de0_4113_9cdc_832db9740f3d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_FeatureMap: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa032d165_46fc_400a_b449_49de53e62a6e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_ForwardedDecodeUnitType: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x089e57c7_47d3_4a26_bf9c_4b64fafb5d1e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_ForwardedDecodeUnits: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x424c754c_97c8_48d6_8777_fc41f7b60879);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_FrameCorruption: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb4dd4a8c_0beb_44c4_8b75_b02b913b04f0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_GenKeyCtx: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x188120cb_d7da_4b59_9b3e_9252fd37301c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_GenKeyFunc: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x441ca1ee_6b1f_4501_903a_de87df42f6ed);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_HDCP_FrameCounter: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9d389c60_f507_4aa6_a40a_71027a02f3de);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_HDCP_OptionalHeader: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9a2e7390_121f_455f_8376_c97428e0b540);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_HDCP_StreamID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x177e5d74_c370_4a7a_95a2_36833c01d0af);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Interlaced: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb1d5830a_deb8_40e3_90fa_389943716461);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_LastSlice: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2b5d5457_5547_4f07_b8c8_b4a3a9a1daac);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_LongTermReferenceFrameInfo: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9154733f_e1bd_41bf_81d3_fcd918f71332);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_MDLCacheCookie: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5f002af9_d8f9_41a3_b6c3_a2ad43f647ad);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_MULTIPLEXED_MANAGER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8dcdee79_6b5a_4c45_8db9_20b395f02fcf);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_MaxDecodeFrameSize: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd3cc654f_f9f3_4a13_889f_f04eb2b5b957);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_MeanAbsoluteDifference: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1cdbde11_08b4_4311_a6dd_0f9f371907aa);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_MoveRegions: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe2a6c693_3a8b_4b8d_95d0_f60281a12fb7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_NALULengthInfo: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x19124e7c_ad4b_465f_bb18_20186287b6af);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_PacketCrossOffsets: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2789671d_389f_40bb_90d9_c282f77f9abd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_PhotoThumbnail: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x74bbc85c_c8bb_42dc_b586_da17ffd35dcc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_PhotoThumbnailMediaType: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x61ad5420_ebf8_4143_89af_6bf25f672def);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_PinholeCameraIntrinsics: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4ee3b6c5_6a15_4e72_9761_70c1db8b9fe3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_ROIRectangle: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3414a438_4998_4d2c_be82_be3ca0b24d43);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_RepeatFirstField: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x304d257c_7493_4fbd_b149_9228de8d9a99);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_RepeatFrame: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x88be738f_0711_4f42_b458_344aed42ec2f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_SampleKeyID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9ed713c8_9b87_4b26_8297_a93b0c5a8acc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_SingleField: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9d85f816_658b_455a_bde0_9fa7e15ab8f9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Spatial_CameraCoordinateSystem: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9d13c82f_2199_4e67_91cd_d1a4181f2534);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Spatial_CameraProjectionTransform: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x47f9fcb5_2a02_4f26_a477_792fdf95886a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Spatial_CameraViewTransform: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4e251fa4_830f_4770_859a_4b8d99aa809b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_TargetGlobalLuminance: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3f60ef36_31ef_4daf_8360_940397e41ef3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Timestamp: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1e436999_69be_4c7a_9369_70068c0260cb);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_Token: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8294da66_f328_4805_b551_00deb4c57a61);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_VideoDSPMode: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc12d55cb_d7d9_476d_81f3_69117f163ea0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_VideoEncodePictureType: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x973704e6_cd14_483c_8f20_c9fc0928bad5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_VideoEncodeQP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb2efe478_f979_4c66_b95e_ee2b82c82f36);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFStreamExtension_CameraExtrinsics: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x686196d0_13e2_41d9_9638_ef032c272a52);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFStreamExtension_ExtendedCameraIntrinsics: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xaa74b3df_9a2c_48d6_8393_5bd1c1a81e6e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFStreamExtension_PinholeCameraIntrinsics: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdbac0455_0ec8_4aef_9c32_7a3ee3456f53);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFStreamFormat_MPEG2Program: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x263067d1_d330_45dc_b669_34d986e4e3e1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFStreamFormat_MPEG2Transport: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe06d8023_db46_11cf_b4d1_00805f6cbbea);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSubtitleFormat_ATSC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7fa7faa3_feae_4e16_aedf_36b9acfbb099);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSubtitleFormat_CustomUserData: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1bb3d849_6614_4d80_8882_ed24aa82da92);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSubtitleFormat_PGS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x71f40e4a_1278_4442_b30d_39dd1d7722bc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSubtitleFormat_SRT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5e467f2e_77ca_4ca5_8391_d142ed4b76c8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSubtitleFormat_SSA: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x57176a1b_1a9e_4eea_abef_c61760198ac4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSubtitleFormat_TTML: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x73e73992_9a10_4356_9557_7194e91e3e54);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSubtitleFormat_VobSub: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6b8e40f4_8d2c_4ced_ad91_5960e45b4433);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSubtitleFormat_WebVTT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc886d215_f485_40bb_8db6_fadbc619a45d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSubtitleFormat_XML: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2006f94f_29ca_4195_b8db_00ded8ff0c97);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_AUDIO_DECODER_AUDIO_ENDPOINT_ID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc7ccdd6e_5398_4695_8be7_51b3e95111bd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_AUDIO_DECODER_DEGRADATION_INFO_ATTRIBUTE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6c3386ad_ec20_430d_b2a5_505c7178d9c4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_AUDIO_DECODER_SPATIAL_METADATA_CLIENT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x05987df4_1270_4999_925f_8e939a7c0af7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_CATEGORY_AUDIO_DECODER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9ea73fb4_ef7a_4559_8d5d_719d8f0426c7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_CATEGORY_AUDIO_EFFECT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x11064c48_3648_4ed0_932e_05ce8ac811b7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_CATEGORY_AUDIO_ENCODER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x91c64bd0_f91e_4d8c_9276_db248279d975);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_CATEGORY_DEMULTIPLEXER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa8700a7a_939b_44c5_99d7_76226b23b3f1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_CATEGORY_ENCRYPTOR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb0c687be_01cd_44b5_b8b2_7c1d7e058b1f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_CATEGORY_MULTIPLEXER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x059c561e_05ae_4b61_b69d_55b61ee54a7b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_CATEGORY_OTHER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x90175d57_b7ea_4901_aeb3_933a8747756f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_CATEGORY_VIDEO_DECODER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd6c02d4b_6833_45b4_971a_05a4b04bab91);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_CATEGORY_VIDEO_EFFECT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x12e17c21_532c_4a6e_8a1c_40825a736397);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_CATEGORY_VIDEO_ENCODER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf79eac7d_e545_4387_bdee_d647d7bde42a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_CATEGORY_VIDEO_PROCESSOR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x302ea3fc_aa5f_47f9_9f7a_c2188bb16302);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_CATEGORY_VIDEO_RENDERER_EFFECT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x145cd8b4_92f4_4b23_8ae7_e0df06c2da95);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_CODEC_MERIT_Attribute: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x88a7cb15_7b07_4a34_9128_e64c6703c4d3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_CONNECTED_STREAM_ATTRIBUTE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x71eeb820_a59f_4de2_bcec_38db1dd611a4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_CONNECTED_TO_HW_STREAM: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x34e6e728_06d6_4491_a553_4795650db912);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_DECODER_EXPOSE_OUTPUT_TYPES_IN_NATIVE_ORDER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xef80833f_f8fa_44d9_80d8_41ed6232670c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_DECODER_FINAL_VIDEO_RESOLUTION_HINT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdc2f8496_15c4_407a_b6f0_1b66ab5fbf53);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_DECODER_QUALITY_MANAGEMENT_CUSTOM_CONTROL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa24e30d7_de25_4558_bbfb_71070a2d332e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_DECODER_QUALITY_MANAGEMENT_RECOVERY_WITHOUT_ARTIFACTS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd8980deb_0a48_425f_8623_611db41d3810);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_ENCODER_ERROR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc8d1eda4_98e4_41d5_9297_44f53852f90e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_ENCODER_SUPPORTS_CONFIG_EVENT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x86a355ae_3a77_4ec4_9f31_01149a4e92de);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_END_STREAMING_AWARE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x70fbc845_b07e_4089_b064_399dc6110f29);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_ENUM_ADAPTER_LUID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1d39518c_e220_4da8_a07f_ba172552d6b1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_ENUM_HARDWARE_URL_Attribute: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2fb866ac_b078_4942_ab6c_003d05cda674);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_ENUM_HARDWARE_VENDOR_ID_Attribute: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3aecb0cc_035b_4bcc_8185_2b8d551ef3af);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_ENUM_TRANSCODE_ONLY_ATTRIBUTE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x111ea8cd_b62a_4bdb_89f6_67ffcdc2458b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_ENUM_VIDEO_RENDERER_EXTENSION_PROFILE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x62c56928_9a4e_443b_b9dc_cac830c24100);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_FIELDOFUSE_UNLOCK_Attribute: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8ec2e9fd_9148_410d_831e_702439461a8e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_FRIENDLY_NAME_Attribute: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x314ffbae_5b41_4c95_9c19_4e7d586face3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_GFX_DRIVER_VERSION_ID_Attribute: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf34b9093_05e0_4b16_993d_3e2a2cde6ad3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_HW_TIMESTAMP_WITH_QPC_Attribute: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8d030fb8_cc43_4258_a22e_9210bef89be4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_INPUT_TYPES_Attributes: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4276c9b1_759d_4bf3_9cd0_0d723d138f96);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_OUTPUT_BOUND_UPPER_UNBOUNDED: u64 = 9223372036854775807u64;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_OUTPUT_TYPES_Attributes: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8eae8cf3_a44f_4306_ba5c_bf5dda242818);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_POLICY_SET_AWARE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5a633b19_cc39_4fa8_8ca5_59981b7a0018);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_PREFERRED_ENCODER_PROFILE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x53004909_1ef5_46d7_a18e_5a75f8b5905f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_PREFERRED_OUTPUTTYPE_Attribute: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7e700499_396a_49ee_b1b4_f628021e8c9d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_PROCESS_LOCAL_Attribute: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x543186e4_4649_4e65_b588_4aa352aff379);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_REMUX_MARK_I_PICTURE_AS_CLEAN_POINT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x364e8f85_3f2e_436c_b2a2_4440a012a9e8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_STREAMS_UNLIMITED: u32 = 4294967295u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_SUPPORT_3DVIDEO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x093f81b1_4f2e_4631_8168_7934032a01d3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_SUPPORT_DYNAMIC_FORMAT_CHANGE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x53476a11_3f13_49fb_ac42_ee2733c96741);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_TRANSFORM_CLSID_Attribute: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6821c42b_65a4_4e82_99bc_9a88205ecd0c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_USING_HARDWARE_DRM: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x34faa77d_d79e_4957_b8ce_362b2684996c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFTranscodeContainerType_3GP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x34c50167_4472_4f34_9ea0_c49fbacf037d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFTranscodeContainerType_AC3: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6d8d91c3_8c91_4ed1_8742_8c347d5b44d0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFTranscodeContainerType_ADTS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x132fd27d_0f02_43de_a301_38fbbbb3834e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFTranscodeContainerType_AMR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x025d5ad3_621a_475b_964d_66b1c824f079);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFTranscodeContainerType_ASF: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x430f6f6e_b6bf_4fc1_a0bd_9ee46eee2afb);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFTranscodeContainerType_AVI: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7edfe8af_402f_4d76_a33c_619fd157d0f1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFTranscodeContainerType_FLAC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x31344aa3_05a9_42b5_901b_8e9d4257f75e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFTranscodeContainerType_FMPEG4: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9ba876f1_419f_4b77_a1e0_35959d9d4004);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFTranscodeContainerType_MP3: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe438b912_83f1_4de6_9e3a_9ffbc6dd24d1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFTranscodeContainerType_MPEG2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbfc2dbf9_7bb4_4f8f_afde_e112c44ba882);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFTranscodeContainerType_MPEG4: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdc6cd05d_b9d0_40ef_bd35_fa622c1ab28a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFTranscodeContainerType_WAVE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x64c3453c_0f26_4741_be63_87bdf8bb935b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_420O: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4f303234_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_A16B16G16R16F: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000071_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_A2R10G10B10: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0000001f_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_AI44: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x34344941_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_ARGB32: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000015_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_AV1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x31305641_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_AYUV: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x56555941_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_Base: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000000_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_Base_HDCP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xeac3b9d5_bd14_4237_8f1f_bab428e49312);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_D16: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000050_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_DV25: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x35327664_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_DV50: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x30357664_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_DVH1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x31687664_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_DVHD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x64687664_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_DVSD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x64737664_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_DVSL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6c737664_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_H263: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x33363248_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_H264: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x34363248_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_H264_ES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3f40f4f0_5622_4ff8_b6d8_a17a584bee5e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_H264_HDCP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5d0ce9dd_9817_49da_bdfd_f5f5b98f18a6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_H265: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x35363248_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_HEVC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x43564548_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_HEVC_ES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x53564548_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_HEVC_HDCP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3cfe0fe6_05c4_47dc_9d70_4bdb2959720f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_I420: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x30323449_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_IYUV: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x56555949_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_L16: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000051_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_L8: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000032_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_M4S2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3253344d_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_MJPG: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x47504a4d_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_MP43: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3334504d_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_MP4S: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5334504d_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_MP4V: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5634504d_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_MPEG2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe06d8026_db46_11cf_b4d1_00805f6cbbea);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_MPG1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3147504d_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_MSS1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3153534d_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_MSS2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3253534d_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_NV11: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3131564e_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_NV12: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3231564e_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_NV21: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3132564e_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_ORAW: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5741524f_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_P010: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x30313050_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_P016: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x36313050_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_P210: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x30313250_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_P216: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x36313250_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_RGB24: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000014_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_RGB32: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000016_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_RGB555: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000018_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_RGB565: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000017_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_RGB8: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000029_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_Theora: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6f656874_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_UYVY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x59565955_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_VP10: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x30315056_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_VP80: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x30385056_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_VP90: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x30395056_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_WMV1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x31564d57_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_WMV2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x32564d57_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_WMV3: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x33564d57_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_WVC1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x31435657_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_Y210: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x30313259_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_Y216: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x36313259_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_Y410: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x30313459_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_Y416: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x36313459_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_Y41P: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x50313459_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_Y41T: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x54313459_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_Y42T: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x54323459_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_YUY2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x32595559_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_YV12: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x32315659_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_YVU9: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x39555659_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_YVYU: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x55595659_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_v210: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x30313276_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_v216: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x36313276_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFormat_v410: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x30313476_0000_0010_8000_00aa00389b71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_1024_BYTE_ALIGNMENT: u32 = 1023u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_128_BYTE_ALIGNMENT: u32 = 127u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_16_BYTE_ALIGNMENT: u32 = 15u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_1_BYTE_ALIGNMENT: u32 = 0u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_2048_BYTE_ALIGNMENT: u32 = 2047u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_256_BYTE_ALIGNMENT: u32 = 255u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_2_BYTE_ALIGNMENT: u32 = 1u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_32_BYTE_ALIGNMENT: u32 = 31u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_4096_BYTE_ALIGNMENT: u32 = 4095u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_4_BYTE_ALIGNMENT: u32 = 3u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_512_BYTE_ALIGNMENT: u32 = 511u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_64_BYTE_ALIGNMENT: u32 = 63u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_8192_BYTE_ALIGNMENT: u32 = 8191u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_8_BYTE_ALIGNMENT: u32 = 7u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ACCESS_CONTROLLED_MEDIASOURCE_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x014a5031_2f05_4c6a_9f9c_7d0dc4eda5f4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ACTIVATE_CUSTOM_VIDEO_MIXER_ACTIVATE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xba491361_be50_451e_95ab_6d4accc7dad8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ACTIVATE_CUSTOM_VIDEO_MIXER_CLSID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xba491360_be50_451e_95ab_6d4accc7dad8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ACTIVATE_CUSTOM_VIDEO_MIXER_FLAGS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xba491362_be50_451e_95ab_6d4accc7dad8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_ACTIVATE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xba491365_be50_451e_95ab_6d4accc7dad8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_CLSID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xba491364_be50_451e_95ab_6d4accc7dad8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_FLAGS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xba491366_be50_451e_95ab_6d4accc7dad8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ACTIVATE_MFT_LOCKED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc1f6093c_7f65_4fbd_9e39_5faec3c4fbd7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ACTIVATE_VIDEO_WINDOW: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9a2dbbdd_f57e_4162_82b9_6831377682d3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_API_VERSION: u32 = 112u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ASFPROFILE_MAXPACKETSIZE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x22587627_47de_4168_87f5_b5aa9b12a8f0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ASFPROFILE_MINPACKETSIZE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x22587626_47de_4168_87f5_b5aa9b12a8f0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ASFSTREAMCONFIG_LEAKYBUCKET1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc69b5901_ea1a_4c9b_b692_e2a0d29a8add);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ASFSTREAMCONFIG_LEAKYBUCKET2: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc69b5902_ea1a_4c9b_b692_e2a0d29a8add);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_AUDIO_RENDERER_ATTRIBUTE_ENDPOINT_ID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb10aaec3_ef71_4cc3_b873_05a9a08b9f8e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_AUDIO_RENDERER_ATTRIBUTE_ENDPOINT_ROLE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6ba644ff_27c5_4d02_9887_c28619fdb91b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_AUDIO_RENDERER_ATTRIBUTE_FLAGS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xede4b5e0_f805_4d6c_99b3_db01bf95dfab);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_AUDIO_RENDERER_ATTRIBUTE_FLAGS_CROSSPROCESS: u32 = 1u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_AUDIO_RENDERER_ATTRIBUTE_FLAGS_DONT_ALLOW_FORMAT_CHANGES: u32 = 4u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_AUDIO_RENDERER_ATTRIBUTE_FLAGS_NOPERSIST: u32 = 2u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_AUDIO_RENDERER_ATTRIBUTE_SESSION_ID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xede4b5e3_f805_4d6c_99b3_db01bf95dfab);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_AUDIO_RENDERER_ATTRIBUTE_STREAM_CATEGORY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa9770471_92ec_4df4_94fe_81c36f0c3a7a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_BD_MVC_PLANE_OFFSET_METADATA: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x62a654e4_b76c_4901_9823_2cb615d47318);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_BOOT_DRIVER_VERIFICATION_FAILED: u32 = 1048576u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_BYTESTREAMHANDLER_ACCEPTS_SHARE_WRITE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa6e1f733_3001_4915_8150_1558a2180ec8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_BYTESTREAM_CONTENT_TYPE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfc358289_3cb6_460c_a424_b6681260375a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_BYTESTREAM_DLNA_PROFILE_ID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfc35828d_3cb6_460c_a424_b6681260375a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_BYTESTREAM_DURATION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfc35828a_3cb6_460c_a424_b6681260375a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_BYTESTREAM_EFFECTIVE_URL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9afa0209_89d1_42af_8456_1de6b562d691);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_BYTESTREAM_IFO_FILE_URI: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfc35828c_3cb6_460c_a424_b6681260375a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_BYTESTREAM_LAST_MODIFIED_TIME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfc35828b_3cb6_460c_a424_b6681260375a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_BYTESTREAM_ORIGIN_NAME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfc358288_3cb6_460c_a424_b6681260375a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_BYTESTREAM_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xab025e2b_16d9_4180_a127_ba6c70156161);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_BYTESTREAM_TRANSCODED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb6c5c282_4dc9_4db9_ab48_cf3b6d8bc5e0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_ALL_EFFECTS_REMOVED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfded7521_8ed8_431a_a96b_f3e2565e981c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_AUDIO_PROCESSING: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x10f1be5e_7e11_410b_973d_f4b6109000fe);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_CAMERA_STREAM_BLOCKED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa4209417_8d39_46f3_b759_5912528f4207);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_CAMERA_STREAM_UNBLOCKED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9be9eef0_cdaf_4717_8564_834aae66415c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_D3D_MANAGER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x76e25e7b_d595_4283_962c_c594afd78ddf);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_DECODER_MFT_FIELDOFUSE_UNLOCK_Attribute: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2b8ad2e8_7acb_4321_a606_325c4249f4fc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_DISABLE_DXVA: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf9818862_179d_433f_a32f_74cbcf74466d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_DISABLE_HARDWARE_TRANSFORMS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb7c42a6b_3207_4495_b4e7_81f9c35d5991);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_EFFECT_ADDED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xaa8dc7b5_a048_4e13_8ebe_f23c46c830c1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_EFFECT_REMOVED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc6e8db07_fb09_4a48_89c6_bf92a04222c9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_ENABLE_CAMERA_STREAMSTATE_NOTIFICATION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4c808e9d_aaed_4713_90fb_cb24064ab8da);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_ENCODER_MFT_FIELDOFUSE_UNLOCK_Attribute: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x54c63a00_78d5_422f_aa3e_5e99ac649269);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_ERROR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x46b89fc6_33cc_4399_9dad_784de77d587c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_EVENT_GENERATOR_GUID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xabfa8ad5_fc6d_4911_87e0_961945f8f7ce);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_EVENT_STREAM_INDEX: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x82697f44_b1cf_42eb_9753_f86d649c8865);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_INITIALIZED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x219992bc_cf92_4531_a1ae_96e1e886c8f1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_MEDIASOURCE_CONFIG: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbc6989d2_0fc1_46e1_a74f_efd36bc788de);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8e3f5bd5_dbbf_42f0_8542_d07a3971762a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_OUTPUT_MEDIA_TYPE_SET: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xcaaad994_83ec_45e9_a30a_1f20aadb9831);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_PHOTO_TAKEN: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3c50c445_7304_48eb_865d_bba19ba3af5c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_PREVIEW_STARTED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa416df21_f9d3_4a74_991b_b817298952c4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_PREVIEW_STOPPED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x13d5143c_1edd_4e50_a2ef_350a47678060);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_RECORD_SINK_AUDIO_MAX_PROCESSED_SAMPLES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9896e12a_f707_4500_b6bd_db8eb810b50f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_RECORD_SINK_AUDIO_MAX_UNPROCESSED_SAMPLES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1cddb141_a7f4_4d58_9896_4d15a53c4efe);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_RECORD_SINK_VIDEO_MAX_PROCESSED_SAMPLES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe7b4a49e_382c_4aef_a946_aed5490b7111);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_RECORD_SINK_VIDEO_MAX_UNPROCESSED_SAMPLES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb467f705_7913_4894_9d42_a215fea23da9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_RECORD_STARTED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xac2b027b_ddf9_48a0_89be_38ab35ef45c0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_RECORD_STOPPED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x55e5200a_f98f_4c0d_a9ec_9eb25ed3d773);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_SELECTEDCAMERAPROFILE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x03160b7e_1c6f_4db2_ad56_a7c430f82392);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_SELECTEDCAMERAPROFILE_INDEX: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3ce88613_2214_46c3_b417_82f8a313c9c3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_USE_AUDIO_DEVICE_ONLY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1c8077da_8466_4dc4_8b8e_276b3f85923b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_USE_VIDEO_DEVICE_ONLY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7e025171_cf32_4f2e_8f19_410577b73a66);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_DIGITALWINDOW: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x276f72a2_59c8_4f69_97b4_068b8c0ec044);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_EXIF: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2e9575b8_8c31_4a02_8575_42b197b71592);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_EXPOSURE_COMPENSATION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd198aa75_4b62_4345_abf3_3c31fa12c299);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_EXPOSURE_TIME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x16b9ae99_cd84_4063_879d_a28c7633729e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_FACEROICHARACTERIZATIONS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb927a1a8_18ef_46d3_b3af_69372f94d9b2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_FACEROIS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x864f25a6_349f_46b1_a30e_54cc22928a47);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_FACEROITIMESTAMPS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe94d50cc_3da0_44d4_bb34_83198a741868);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_FIRST_SCANLINE_START_TIME_QPC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6a2c49f1_e052_46b6_b2d9_73c1558709af);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_FLASH: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4a51520b_fb36_446c_9df2_68171b9a0389);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_FLASH_POWER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9c0e0d49_0205_491a_bc9d_2d6e1f4d5684);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_FOCUSSTATE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa87ee154_997f_465d_b91f_29d53b982b88);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_FRAME_BACKGROUND_MASK: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x03f14dd3_75dd_433a_a8e2_1e3f5f2a50a0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_FRAME_ILLUMINATION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6d688ffc_63d3_46fe_bada_5b947db0d080);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_FRAME_RAWSTREAM: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9252077b_2680_49b9_ae02_b19075973b70);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_HISTOGRAM: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x85358432_2ef6_4ba9_a3fb_06d82974b895);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_ISO_GAINS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x05802ac9_0e1d_41c7_a8c8_7e7369f84e1e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_ISO_SPEED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe528a68f_b2e3_44fe_8b65_07bf4b5a13ff);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_LAST_SCANLINE_END_TIME_QPC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdccadecb_c4d4_400d_b418_10e88525e1f6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_LENS_POSITION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb5fc8e86_11d1_4e70_819b_723a89fa4520);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_PHOTO_FRAME_FLASH: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0f9dd6c6_6003_45d8_bd59_f1f53e3d04e8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_REQUESTED_FRAME_SETTING_ID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbb3716d9_8a61_47a4_8197_459c7ff174d5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_SCANLINE_DIRECTION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6496a3ba_1907_49e6_b0c3_123795f380a9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_SCANLINE_TIME_QPC_ACCURACY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4cd79c51_f765_4b09_b1e1_27d1f7ebea09);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_SCENE_MODE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9cc3b54d_5ed3_4bae_b388_7670aef59e13);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_SENSORFRAMERATE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdb51357e_9d3d_4962_b06d_07ce650d9a0a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_UVC_PAYLOADHEADER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf9f88a87_e1dd_441e_95cb_42e21a64f1d9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_WHITEBALANCE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc736fd77_0fb9_4e2e_97a2_fcd490739ee9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_WHITEBALANCE_GAINS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe7570c8f_2dcb_4c7c_aace_22ece7cce647);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_METADATA_ZOOMFACTOR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe50b0b81_e501_42c2_abf2_857ecb13fa5c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_SINK_PREPARED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7bfce257_12b1_4409_8c34_d445daab7578);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_SOURCE_CURRENT_DEVICE_MEDIA_TYPE_SET: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe7e75e4c_039c_4410_815b_8741307b63aa);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_COMPONENT_CERT_REVOKED: u32 = 32768u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_COMPONENT_HS_CERT_REVOKED: u32 = 131072u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_COMPONENT_INVALID_EKU: u32 = 16384u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_COMPONENT_INVALID_ROOT: u32 = 65536u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_COMPONENT_LS_CERT_REVOKED: u32 = 262144u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_COMPONENT_REVOKED: u32 = 8192u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CONTENTDECRYPTIONMODULE_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x15320c45_ff80_484a_9dcb_0df894e69a01);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CONTENT_DECRYPTOR_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x68a72927_fc7b_44ee_85f4_7c51bd55a659);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CONTENT_PROTECTION_DEVICE_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xff58436f_76a0_41fe_b566_10cc53962edd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_D3D12_SYNCHRONIZATION_OBJECT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2a7c8d6a_85a6_494d_a046_06ea1a138f4b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DECODER_FWD_CUSTOM_SEI_DECODE_ORDER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf13bbe3c_36d4_410a_b985_7a951a1e6294);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICEMFT_CONNECTED_FILTER_KSCONTROL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6a2c4fa6_d179_41cd_9523_822371ea40e5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICEMFT_CONNECTED_PIN_KSCONTROL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe63310f7_b244_4ef8_9a7d_24c74e32ebd0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICEMFT_EXTENSION_PLUGIN_CLSID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0844dbae_34fa_48a0_a783_8e696fb1c9a8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICEMFT_SENSORPROFILE_COLLECTION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x36ebdc44_b12c_441b_89f4_08b2f41a9cfc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICESTREAM_ATTRIBUTE_FACEAUTH_CAPABILITY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xcb6fd12a_2248_4e41_ad46_e78bb90ab9fc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICESTREAM_ATTRIBUTE_FRAMESOURCE_TYPES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x17145fd1_1b2b_423c_8001_2b6833ed3588);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICESTREAM_ATTRIBUTE_SECURE_CAPABILITY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x940fd626_ea6e_4684_9840_36bd6ec9fbef);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICESTREAM_EXTENSION_PLUGIN_CLSID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x048e6558_60c4_4173_bd5b_6a3ca2896aee);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICESTREAM_EXTENSION_PLUGIN_CONNECTION_POINT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x37f9375c_e664_4ea4_aae4_cb6d1daca1f4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICESTREAM_FILTER_KSCONTROL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x46783cca_3df5_4923_a9ef_36b7223edde0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICESTREAM_FRAMESERVER_HIDDEN: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf402567b_4d91_4179_96d1_74c8480c2034);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICESTREAM_FRAMESERVER_SHARED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1cb378e9_b279_41d4_af97_34a243e68320);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICESTREAM_IMAGE_STREAM: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa7ffb865_e7b2_43b0_9f6f_9af2a0e50fc0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICESTREAM_INDEPENDENT_IMAGE_STREAM: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x03eeec7e_d605_4576_8b29_6580b490d7d3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICESTREAM_MAX_FRAME_BUFFERS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1684cebe_3175_4985_882c_0efd3e8ac11e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICESTREAM_MULTIPLEXED_MANAGER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6ea542b0_281f_4231_a464_fe2f5022501c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICESTREAM_PIN_KSCONTROL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xef3ef9a7_87f2_48ca_be02_674878918e98);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICESTREAM_REQUIRED_CAPABILITIES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6d8b957e_7cf6_43f4_af56_9c0e1e4fcbe1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICESTREAM_REQUIRED_SDDL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x331ae85d_c0d3_49ba_83ba_82a12d63cdd6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICESTREAM_SENSORSTREAM_ID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe35b9fe4_0659_4cad_bb51_33160be7e413);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICESTREAM_SOURCE_ATTRIBUTES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2f8cb617_361b_434f_85ea_99a03e1ce4e0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICESTREAM_STREAM_CATEGORY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2939e7b8_a62e_4579_b674_d4073dfabbba);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICESTREAM_STREAM_ID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x11bd5120_d124_446b_88e6_17060257fff9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICESTREAM_TAKEPHOTO_TRIGGER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1d180e34_538c_4fbb_a75a_859af7d261a6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICESTREAM_TRANSFORM_STREAM_ID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe63937b7_daaf_4d49_815f_d826f8ad31e7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVICE_THERMAL_STATE_CHANGED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x70ccd0af_fc9f_4deb_a875_9fecd16c5bd4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVSOURCE_ATTRIBUTE_ENABLE_MS_CAMERA_EFFECTS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x28a5531a_57dd_4fd5_aaa7_385abf57d785);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVSOURCE_ATTRIBUTE_FRIENDLY_NAME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x60d0e559_52f8_4fa2_bbce_acdb34a8ec01);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVSOURCE_ATTRIBUTE_MEDIA_TYPE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x56a819ca_0c78_4de4_a0a7_3ddaba0f24d4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_PASSWORD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa0fd7e16_42d9_49df_84c0_e82c5eab8874);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_STREAM_URL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9d7b40d2_3617_4043_93e3_8d6da9bb3492);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc60ac5fe_252a_478f_a0ef_bc8fa5f7cad3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_ENDPOINT_ID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x30da9258_feb9_47a7_a453_763a7a8e1c5f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_GUID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x14dd9a1c_7cff_41be_b1b9_ba1ac6ecb571);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_ROLE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbc9d118e_8c67_4a18_85d4_12d300400552);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_SYMBOLIC_LINK: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x98d24b5e_5930_4614_b5a1_f600f9355a78);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_CATEGORY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x77f0ae69_c3bd_4509_941d_467e4d24899e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_GUID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8ac3587a_4ae7_42d8_99e0_0a6013eef90f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_HW_SOURCE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xde7046ba_54d6_4487_a2a4_ec7c0d1bd163);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_MAX_BUFFERS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7dd9b730_4f2d_41d5_8f95_0cc9a912ba26);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_PROVIDER_DEVICE_ID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x36689d42_a06c_40ae_84cf_f5a034067cc4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_SYMBOLIC_LINK: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x58f0aad8_22bf_4f8a_bb3d_d2c4978c6e2f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_USERNAME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x05d01add_949f_46eb_bc8e_8b0d2b32d79d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_XADDRESS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbca0be52_c327_44c7_9b7d_7fa8d9b5bcda);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DISABLE_FRAME_CORRUPTION_INFO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7086e16c_49c5_4201_882a_8538f38cf13a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DISABLE_LOCALLY_REGISTERED_PLUGINS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x66b16da9_add4_47e0_a16b_5af1fb483634);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DMFT_FRAME_BUFFER_INFO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x396ce1c9_67a9_454c_8797_95a45799d804);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ENABLE_3DVIDEO_OUTPUT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbdad7bca_0e5f_4b10_ab16_26de381b6293);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_EVENT_DO_THINNING: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x321ea6fb_dad9_46e4_b31d_d2eae7090e30);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_EVENT_MFT_CONTEXT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb7cd31f1_899e_4b41_80c9_26a896d32977);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_EVENT_MFT_INPUT_STREAM_ID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf29c2cca_7ae6_42d2_b284_bf837cc874e2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_EVENT_OUTPUT_NODE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x830f1a8b_c060_46dd_a801_1c95dec9b107);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_EVENT_PRESENTATION_TIME_OFFSET: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5ad914d1_9b45_4a8d_a2c0_81d1e50bfb07);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_EVENT_SCRUBSAMPLE_TIME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9ac712b3_dcb8_44d5_8d0c_37455a2782e3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_EVENT_SESSIONCAPS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7e5ebcd0_11b8_4abe_afad_10f6599a7f42);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_EVENT_SESSIONCAPS_DELTA: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7e5ebcd1_11b8_4abe_afad_10f6599a7f42);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_EVENT_SOURCE_ACTUAL_START: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa8cc55a9_6b31_419f_845d_ffb351a2434b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_EVENT_SOURCE_CHARACTERISTICS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x47db8490_8b22_4f52_afda_9ce1b2d3cfa8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_EVENT_SOURCE_CHARACTERISTICS_OLD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x47db8491_8b22_4f52_afda_9ce1b2d3cfa8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_EVENT_SOURCE_FAKE_START: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa8cc55a7_6b31_419f_845d_ffb351a2434b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_EVENT_SOURCE_PROJECTSTART: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa8cc55a8_6b31_419f_845d_ffb351a2434b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_EVENT_SOURCE_TOPOLOGY_CANCELED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdb62f650_9a5e_4704_acf3_563bc6a73364);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_EVENT_START_PRESENTATION_TIME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5ad914d0_9b45_4a8d_a2c0_81d1e50bfb07);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_EVENT_START_PRESENTATION_TIME_AT_OUTPUT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5ad914d2_9b45_4a8d_a2c0_81d1e50bfb07);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_EVENT_STREAM_METADATA_CONTENT_KEYIDS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5063449d_cc29_4fc6_a75a_d247b35af85c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_EVENT_STREAM_METADATA_KEYDATA: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xcd59a4a1_4a3b_4bbd_8665_72a40fbea776);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_EVENT_STREAM_METADATA_SYSTEMID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1ea2ef64_ba16_4a36_8719_fe7560ba32ad);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_EVENT_TOPOLOGY_STATUS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x30c5018d_9a53_454b_ad9e_6d5f8fa7c43b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_ALLOCATOR_ALREADY_COMMITED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072846854i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_ALLOCATOR_NOT_COMMITED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072846855i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_ALLOCATOR_NOT_INITIALIZED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072846856i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_ALL_PROCESS_RESTART_REQUIRED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860820i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_ALREADY_INITIALIZED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072871856i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_ASF_DROPPED_PACKET: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072874847i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_ASF_FILESINK_BITRATE_UNKNOWN: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072870848i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_ASF_INDEXNOTLOADED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072874850i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_ASF_INVALIDDATA: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072874854i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_ASF_MISSINGDATA: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072874855i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_ASF_NOINDEX: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072874852i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_ASF_OPAQUEPACKET: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072874853i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_ASF_OUTOFRANGE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072874851i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_ASF_PARSINGINCOMPLETE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072874856i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_ASF_TOO_MANY_PAYLOADS: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072874849i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_ASF_UNSUPPORTED_STREAM_TYPE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072874848i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_ATTRIBUTENOTFOUND: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875802i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_AUDIO_BUFFER_SIZE_ERROR: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072869752i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_AUDIO_CLIENT_WRAPPER_SPOOF_ERROR: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072869751i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_AUDIO_PLAYBACK_DEVICE_INVALIDATED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072869754i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_AUDIO_PLAYBACK_DEVICE_IN_USE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072869755i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_AUDIO_RECORDING_DEVICE_INVALIDATED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873823i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_AUDIO_RECORDING_DEVICE_IN_USE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873824i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_AUDIO_SERVICE_NOT_RUNNING: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072869753i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_BACKUP_RESTRICTED_LICENSE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860850i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_BAD_OPL_STRUCTURE_FORMAT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860803i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_BAD_STARTUP_VERSION: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875805i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_BANDWIDTH_OVERRUN: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072871855i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_BUFFERTOOSMALL: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875855i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_BYTESTREAM_NOT_SEEKABLE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875794i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_BYTESTREAM_UNKNOWN_LENGTH: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875781i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CANNOT_CREATE_SINK: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875782i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CANNOT_FIND_KEYFRAME_SAMPLE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873827i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CANNOT_INDEX_IN_PLACE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072871849i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CANNOT_PARSE_BYTESTREAM: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875792i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CAPTURE_ENGINE_ALL_EFFECTS_REMOVED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072845851i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CAPTURE_ENGINE_INVALID_OP: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072845852i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CAPTURE_NO_SAMPLES_IN_QUEUE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072845845i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CAPTURE_PROPERTY_SET_DURING_PHOTO: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072845846i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CAPTURE_SINK_MIRROR_ERROR: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072845854i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CAPTURE_SINK_OUTPUT_NOT_SET: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072845855i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CAPTURE_SINK_ROTATE_ERROR: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072845853i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CAPTURE_SOURCE_DEVICE_EXTENDEDPROP_OP_IN_PROGRESS: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072845847i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CAPTURE_SOURCE_NO_AUDIO_STREAM_PRESENT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072845848i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CAPTURE_SOURCE_NO_INDEPENDENT_PHOTO_STREAM_PRESENT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072845850i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CAPTURE_SOURCE_NO_VIDEO_STREAM_PRESENT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072845849i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CLOCK_AUDIO_DEVICE_POSITION_UNEXPECTED: ::windows::core::HRESULT = ::windows::core::HRESULT(891973i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CLOCK_AUDIO_RENDER_POSITION_UNEXPECTED: ::windows::core::HRESULT = ::windows::core::HRESULT(891974i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CLOCK_AUDIO_RENDER_TIME_UNEXPECTED: ::windows::core::HRESULT = ::windows::core::HRESULT(891975i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CLOCK_INVALID_CONTINUITY_KEY: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072849856i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CLOCK_NOT_SIMPLE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072849853i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CLOCK_NO_TIME_SOURCE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072849855i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CLOCK_STATE_ALREADY_SET: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072849854i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CODE_EXPIRED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860834i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_COMPONENT_REVOKED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860847i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_CONTENT_PROTECTION_SYSTEM_NOT_ENABLED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860795i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_DEBUGGING_NOT_ALLOWED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860835i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_DISABLED_IN_SAFEMODE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875793i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_DRM_HARDWARE_INCONSISTENT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860853i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_DRM_MIGRATION_NOT_SUPPORTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860793i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_DRM_UNSUPPORTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875776i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_DROPTIME_NOT_SUPPORTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072848854i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_DURATION_TOO_LONG: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875769i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_DXGI_DEVICE_NOT_INITIALIZED: ::windows::core::HRESULT = ::windows::core::HRESULT(-2147217408i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_DXGI_NEW_VIDEO_DEVICE: ::windows::core::HRESULT = ::windows::core::HRESULT(-2147217407i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_DXGI_VIDEO_DEVICE_LOCKED: ::windows::core::HRESULT = ::windows::core::HRESULT(-2147217406i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_END_OF_STREAM: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873852i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_FLUSH_NEEDED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072871853i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_FORMAT_CHANGE_NOT_SUPPORTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875778i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_GRL_ABSENT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860814i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_GRL_EXTENSIBLE_ENTRY_NOT_FOUND: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860831i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_GRL_INVALID_FORMAT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860822i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_GRL_RENEWAL_NOT_FOUND: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860832i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_GRL_UNRECOGNIZED_FORMAT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860821i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_GRL_VERSION_TOO_LOW: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860833i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_HARDWARE_DRM_UNSUPPORTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875770i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_HDCP_AUTHENTICATION_FAILURE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860792i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_HDCP_LINK_FAILURE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860791i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_HIGH_SECURITY_LEVEL_CONTENT_NOT_ALLOWED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860808i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_HW_ACCELERATED_THUMBNAIL_NOT_SUPPORTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072845844i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_HW_MFT_FAILED_START_STREAMING: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875772i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_HW_STREAM_NOT_CONNECTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072846851i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_INCOMPATIBLE_SAMPLE_PROTECTION: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860810i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_INDEX_NOT_COMMITTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072871851i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_INSUFFICIENT_BUFFER: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860816i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_INVALIDINDEX: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875841i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_INVALIDMEDIATYPE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875852i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_INVALIDNAME: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875844i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_INVALIDREQUEST: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875854i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_INVALIDSTREAMNUMBER: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875853i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_INVALIDTYPE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875843i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_INVALID_AKE_CHANNEL_PARAMETERS: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860796i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_INVALID_ASF_STREAMID: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072871847i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_INVALID_CODEC_MERIT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875773i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_INVALID_FILE_FORMAT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875842i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_INVALID_FORMAT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873844i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_INVALID_KEY: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875806i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_INVALID_POSITION: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875803i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_INVALID_PROFILE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072871852i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_INVALID_STATE_TRANSITION: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873854i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_INVALID_STREAM_DATA: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875829i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_INVALID_STREAM_STATE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072846852i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_INVALID_TIMESTAMP: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875840i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_INVALID_WORKQUEUE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875777i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_ITA_ERROR_PARSING_SAP_PARAMETERS: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860805i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_ITA_OPL_DATA_NOT_INITIALIZED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860800i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_OUTPUT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860799i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_PROTECTION_GUID: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860802i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_ITA_UNRECOGNIZED_DIGITAL_VIDEO_OUTPUT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860798i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_ITA_UNSUPPORTED_ACTION: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860806i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_KERNEL_UNTRUSTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860830i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_LATE_SAMPLE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072871854i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_LICENSE_INCORRECT_RIGHTS: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860856i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_LICENSE_OUTOFDATE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860855i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_LICENSE_REQUIRED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860854i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_LICENSE_RESTORE_NEEDS_INDIVIDUALIZATION: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860849i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_LICENSE_RESTORE_NO_RIGHTS: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860851i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_MEDIAPROC_WRONGSTATE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875790i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_MEDIA_EXTENSION_APPSERVICE_CONNECTION_FAILED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072843856i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_MEDIA_EXTENSION_APPSERVICE_REQUEST_FAILED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072843855i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_MEDIA_EXTENSION_PACKAGE_INTEGRITY_CHECK_FAILED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072843854i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_MEDIA_EXTENSION_PACKAGE_LICENSE_INVALID: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072843853i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_MEDIA_SOURCE_NOT_STARTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873839i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_MEDIA_SOURCE_NO_STREAMS_SELECTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873828i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_MEDIA_SOURCE_WRONGSTATE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873829i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_METADATA_TOO_LONG: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072870845i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_MISSING_ASF_LEAKYBUCKET: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072871848i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_MP3_BAD_CRC: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873831i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_MP3_NOTFOUND: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873850i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_MP3_NOTMP3: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873848i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_MP3_NOTSUPPORTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873847i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_MP3_OUTOFDATA: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873849i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_MULTIPLE_BEGIN: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875815i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_MULTIPLE_SUBSCRIBERS: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875814i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NETWORK_RESOURCE_FAILURE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872856i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_BAD_CONTROL_DATA: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872838i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_BAD_REQUEST: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872833i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_BUSY: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872822i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_BWLEVEL_NOT_SUPPORTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872851i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_CACHESTREAM_NOT_FOUND: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872847i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_CACHE_NO_DATA: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872835i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_CANNOTCONNECT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872825i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_CLIENT_CLOSE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872839i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_COMPANION_DRIVER_DISCONNECT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872811i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_CONNECTION_FAILURE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872829i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_EOL: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872834i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_ERROR_FROM_PROXY: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872820i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_INCOMPATIBLE_PUSHSERVER: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872828i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_INCOMPATIBLE_SERVER: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872837i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_INTERNAL_SERVER_ERROR: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872832i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_INVALID_PRESENTATION_DESCRIPTOR: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872848i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_INVALID_PUSH_PUBLISHING_POINT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872823i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_INVALID_PUSH_TEMPLATE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872824i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_MANUALSS_NOT_SUPPORTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872849i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_NOCONNECTION: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872830i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_PROTOCOL_DISABLED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872812i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_PROXY_ACCESSDENIED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872826i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_PROXY_TIMEOUT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872819i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_READ: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872854i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_REDIRECT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872843i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_REDIRECT_TO_PROXY: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872842i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_REQUIRE_ASYNC: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872852i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_REQUIRE_INPUT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872844i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_REQUIRE_NETWORK: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872853i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_RESOURCE_GONE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872821i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_SERVER_ACCESSDENIED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872827i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_SERVER_UNAVAILABLE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872818i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_SESSION_INVALID: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872816i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_SESSION_NOT_FOUND: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872831i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_STREAMGROUPS_NOT_SUPPORTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872850i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_TIMEOUT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872840i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_TOO_MANY_REDIRECTS: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872841i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_TOO_MUCH_DATA: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872817i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_UDP_BLOCKED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872814i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_UNSAFE_URL: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872836i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_UNSUPPORTED_CONFIGURATION: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872813i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NET_WRITE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872855i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NEW_VIDEO_DEVICE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072869851i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NON_PE_PROCESS: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860827i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NOTACCEPTING: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875851i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NOT_AVAILABLE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875818i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NOT_FOUND: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875819i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NOT_INITIALIZED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875850i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NOT_PROTECTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873830i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NO_AUDIO_PLAYBACK_DEVICE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072869756i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NO_AUDIO_RECORDING_DEVICE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873825i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NO_BITPUMP: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875786i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NO_CAPTURE_DEVICES_AVAILABLE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072845856i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NO_CLOCK: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875817i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NO_CONTENT_PROTECTION_MANAGER: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860852i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NO_DURATION: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873846i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NO_EVENTS_AVAILABLE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873856i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NO_INDEX: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072871850i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NO_MORE_DROP_MODES: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072848856i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NO_MORE_QUALITY_LEVELS: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072848855i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NO_MORE_TYPES: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875847i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NO_PMP_HOST: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860801i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NO_SAMPLE_DURATION: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875831i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NO_SAMPLE_TIMESTAMP: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875832i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NO_SOURCE_IN_CACHE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072864850i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_NO_VIDEO_SAMPLE_AVAILABLE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072869850i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_OFFLINE_MODE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072872815i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_OPERATION_CANCELLED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875795i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_OPERATION_IN_PROGRESS: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875771i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_OPERATION_UNSUPPORTED_AT_D3D_FEATURE_LEVEL: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875768i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_OPL_NOT_SUPPORTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860838i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_OUT_OF_RANGE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875774i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_PEAUTH_NOT_STARTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860811i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_PEAUTH_PUBLICKEY_REVOKED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860815i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_PEAUTH_SESSION_NOT_STARTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860817i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_PEAUTH_UNTRUSTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860829i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_PE_SESSIONS_MAXED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860809i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_PE_UNTRUSTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860812i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_PLATFORM_NOT_INITIALIZED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875856i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_POLICY_MGR_ACTION_OUTOFBOUNDS: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860804i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_POLICY_UNSUPPORTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860839i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_PROCESS_RESTART_REQUIRED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860819i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_PROPERTY_EMPTY: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875799i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_PROPERTY_NOT_ALLOWED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873841i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_PROPERTY_NOT_EMPTY: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875798i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_PROPERTY_NOT_FOUND: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873843i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_PROPERTY_READ_ONLY: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873842i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_PROPERTY_TYPE_NOT_ALLOWED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875801i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_PROPERTY_TYPE_NOT_SUPPORTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875800i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_PROPERTY_VECTOR_NOT_ALLOWED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875797i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_PROPERTY_VECTOR_REQUIRED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875796i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_QM_INVALIDSTATE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072848852i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_QUALITYKNOB_WAIT_LONGER: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072848853i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_RATE_CHANGE_PREEMPTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875820i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_REBOOT_REQUIRED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860825i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_RESOLUTION_REQUIRES_PMP_CREATION_CALLBACK: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860797i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_REVERSE_UNSUPPORTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875822i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_RT_OUTOFMEMORY: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875785i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_RT_THROUGHPUT_NOT_AVAILABLE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875789i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_RT_TOO_MANY_CLASSES: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875788i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_RT_UNAVAILABLE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875825i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_RT_WORKQUEUE_CLASS_NOT_SPECIFIED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875784i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_RT_WOULDBLOCK: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875787i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_SAMPLEALLOCATOR_CANCELED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072870851i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_SAMPLEALLOCATOR_EMPTY: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072870850i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_SAMPLE_HAS_TOO_MANY_BUFFERS: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875809i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_SAMPLE_NOT_WRITABLE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875808i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_SEQUENCER_UNKNOWN_SEGMENT_ID: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072864852i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_SESSION_PAUSEWHILESTOPPED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875780i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_SHUTDOWN: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873851i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_SIGNATURE_VERIFICATION_FAILED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860836i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_SINK_ALREADYSTOPPED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072870849i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_SINK_HEADERS_NOT_FOUND: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072870843i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_SINK_NO_SAMPLES_PROCESSED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072870844i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_SINK_NO_STREAMS: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072870847i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_SOURCERESOLVER_MUTUALLY_EXCLUSIVE_FLAGS: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875791i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_STATE_TRANSITION_PENDING: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875812i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_STREAMSINKS_FIXED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072870853i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_STREAMSINKS_OUT_OF_SYNC: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072870854i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_STREAMSINK_EXISTS: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072870852i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_STREAMSINK_REMOVED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072870856i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_STREAM_ERROR: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072846853i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TEST_SIGNED_COMPONENTS_NOT_ALLOWED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860807i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_THINNING_UNSUPPORTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875823i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TIMELINECONTROLLER_CANNOT_ATTACH: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072844854i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TIMELINECONTROLLER_NOT_ALLOWED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072844855i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TIMELINECONTROLLER_UNSUPPORTED_SOURCE_TYPE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072844856i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TIMER_ORPHANED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875813i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TOPOLOGY_VERIFICATION_FAILED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860837i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TOPO_CANNOT_CONNECT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072868845i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TOPO_CANNOT_FIND_DECRYPTOR: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072868847i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TOPO_CODEC_NOT_FOUND: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072868846i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TOPO_INVALID_OPTIONAL_NODE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072868850i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TOPO_INVALID_TIME_ATTRIBUTES: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072868843i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TOPO_LOOPS_IN_TOPOLOGY: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072868842i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TOPO_MISSING_PRESENTATION_DESCRIPTOR: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072868841i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TOPO_MISSING_SOURCE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072868838i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TOPO_MISSING_STREAM_DESCRIPTOR: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072868840i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TOPO_SINK_ACTIVATES_UNSUPPORTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072868837i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TOPO_STREAM_DESCRIPTOR_NOT_SELECTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072868839i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TOPO_UNSUPPORTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072868844i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSCODE_INVALID_PROFILE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072847853i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSCODE_NO_CONTAINERTYPE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072847856i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSCODE_NO_MATCHING_ENCODER: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072847854i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSCODE_PROFILE_NO_MATCHING_STREAMS: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072847855i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_ASYNC_LOCKED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861833i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_ASYNC_MFT_NOT_SUPPORTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861830i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_CANNOT_CHANGE_MEDIATYPE_WHILE_PROCESSING: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861836i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_CANNOT_INITIALIZE_ACM_DRIVER: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861832i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_CONFLICTS_WITH_OTHER_CURRENTLY_ENABLED_FEATURES: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861840i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_EXATTRIBUTE_NOT_SUPPORTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861828i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_INPUT_REMAINING: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861854i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_NEED_MORE_INPUT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861838i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_INPUT_MEDIATYPE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861842i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_MEDIATYPE_COMBINATION: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861841i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_OUTPUT_MEDIATYPE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861843i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_SPKR_CONFIG: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861837i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_PROFILE_INVALID_OR_CORRUPT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861852i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_PROFILE_MISSING: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861853i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_PROFILE_TRUNCATED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861851i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_PROPERTY_ARRAY_VALUE_WRONG_NUM_DIM: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861847i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_PROPERTY_NOT_WRITEABLE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861848i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_PROPERTY_PID_NOT_RECOGNIZED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861850i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_PROPERTY_VALUE_INCOMPATIBLE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861844i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_PROPERTY_VALUE_OUT_OF_RANGE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861845i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_PROPERTY_VALUE_SIZE_WRONG: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861846i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_PROPERTY_VARIANT_TYPE_WRONG: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861849i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_STREAM_CHANGE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861855i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_STREAM_INVALID_RESOLUTION: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861831i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRANSFORM_TYPE_NOT_SET: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861856i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_TRUST_DISABLED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860846i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_UNAUTHORIZED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875775i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_UNEXPECTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875845i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_UNRECOVERABLE_ERROR_OCCURRED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875810i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_UNSUPPORTED_BYTESTREAM_TYPE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875836i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_UNSUPPORTED_CAPTION: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875804i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_UNSUPPORTED_CAPTURE_DEVICE_PRESENT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072845843i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_UNSUPPORTED_CHARACTERISTICS: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873826i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_UNSUPPORTED_CONTENT_PROTECTION_SYSTEM: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860794i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_UNSUPPORTED_D3D_TYPE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072861834i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_UNSUPPORTED_FORMAT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873832i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_UNSUPPORTED_MEDIATYPE_AT_D3D_FEATURE_LEVEL: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875767i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_UNSUPPORTED_RATE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875824i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_UNSUPPORTED_RATE_TRANSITION: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875821i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_UNSUPPORTED_REPRESENTATION: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875849i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_UNSUPPORTED_SCHEME: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875837i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_UNSUPPORTED_SERVICE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875846i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_UNSUPPORTED_STATE_TRANSITION: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875811i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_UNSUPPORTED_TIME_FORMAT: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072875835i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_USERMODE_UNTRUSTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860818i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_VIDEO_DEVICE_LOCKED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072869852i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_VIDEO_RECORDING_DEVICE_INVALIDATED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873822i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_VIDEO_RECORDING_DEVICE_PREEMPTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072873821i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_VIDEO_REN_COPYPROT_FAILED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072869854i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_VIDEO_REN_NO_DEINTERLACE_HW: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072869855i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_VIDEO_REN_NO_PROCAMP_HW: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072869856i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_VIDEO_REN_SURFACE_NOT_SHARED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072869853i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_WMDRMOTA_ACTION_ALREADY_SET: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860844i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_WMDRMOTA_ACTION_MISMATCH: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860841i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_WMDRMOTA_DRM_ENCRYPTION_SCHEME_NOT_SUPPORTED: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860842i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_WMDRMOTA_DRM_HEADER_NOT_AVAILABLE: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860843i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_WMDRMOTA_INVALID_POLICY: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860840i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_E_WMDRMOTA_NO_ACTION: ::windows::core::HRESULT = ::windows::core::HRESULT(-1072860845i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_FRAMESERVER_VCAMEVENT_EXTENDED_CUSTOM_EVENT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6e59489c_47d3_4467_83ef_12d34e871665);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_FRAMESERVER_VCAMEVENT_EXTENDED_PIPELINE_SHUTDOWN: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x45a81b31_43f8_4e5d_8ce2_22dce026996d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_FRAMESERVER_VCAMEVENT_EXTENDED_SOURCE_INITIALIZE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe52c4dff_e46d_4d0b_bc75_ddd4c8723f96);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_FRAMESERVER_VCAMEVENT_EXTENDED_SOURCE_START: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb1eeb989_b456_4f4a_ae40_079c28e24af8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_FRAMESERVER_VCAMEVENT_EXTENDED_SOURCE_STOP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb7fe7a61_fe91_415e_8608_d37dedb1a58b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_FRAMESERVER_VCAMEVENT_EXTENDED_SOURCE_UNINITIALIZE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa0ebaba7_a422_4e33_8401_b37d2800aa67);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_GRL_ABSENT: u32 = 4096u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_GRL_LOAD_FAILED: u32 = 16u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_HISTOGRAM_CHANNEL_B: u32 = 8u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_HISTOGRAM_CHANNEL_Cb: u32 = 16u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_HISTOGRAM_CHANNEL_Cr: u32 = 32u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_HISTOGRAM_CHANNEL_G: u32 = 4u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_HISTOGRAM_CHANNEL_R: u32 = 2u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_HISTOGRAM_CHANNEL_Y: u32 = 1u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_INDEPENDENT_STILL_IMAGE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xea12af41_0710_42c9_a127_daa3e78483a5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_INDEX_SIZE_ERR: u32 = 2154823681u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_INVALID_ACCESS_ERR: u32 = 2154823695u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_INVALID_GRL_SIGNATURE: u32 = 32u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_INVALID_PRESENTATION_TIME: u64 = 9223372036854775808u64;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_INVALID_STATE_ERR: u32 = 2154823691u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_I_MANUAL_PROXY: ::windows::core::HRESULT = ::windows::core::HRESULT(1074610802i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_KERNEL_MODE_COMPONENT_LOAD: u32 = 2u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_LOCAL_MFT_REGISTRATION_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xddf5cf9c_4506_45aa_abf0_6d5d94dd1b4a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_LOCAL_PLUGIN_CONTROL_POLICY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd91b0085_c86d_4f81_8822_8c68e1d7fa04);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_LOW_LATENCY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9c27891a_ed7a_40e1_88e8_b22727a024ee);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_LUMA_KEY_ENABLE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7369820f_76de_43ca_9284_47b8f37e0649);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_LUMA_KEY_LOWER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x93d7b8d5_0b81_4715_aea0_8725871621e9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_LUMA_KEY_UPPER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd09f39bb_4602_4c31_a706_a12171a5110a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIASINK_AUTOFINALIZE_SUPPORTED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x48c131be_135a_41cb_8290_03652509c999);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIASINK_ENABLE_AUTOFINALIZE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x34014265_cb7e_4cde_ac7c_effd3b3c2530);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIASOURCE_EXPOSE_ALL_STREAMS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe7f250b8_8fd9_4a09_b6c1_6a315c7c720e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIASOURCE_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf09992f7_9fba_4c4a_a37f_8c47b4e1dfe7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIATYPE_EQUAL_FORMAT_DATA: u32 = 4u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIATYPE_EQUAL_FORMAT_TYPES: u32 = 2u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIATYPE_EQUAL_FORMAT_USER_DATA: u32 = 8u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIATYPE_EQUAL_MAJOR_TYPES: u32 = 1u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIATYPE_MULTIPLEXED_MANAGER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x13c78fb5_f275_4ea0_bb5f_0249832b0d6e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_AUDIO_CATEGORY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc8d4c51d_350e_41f2_ba46_faebbb0857f6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_AUDIO_ENDPOINT_ROLE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd2cb93d1_116a_44f2_9385_f7d0fda2fb46);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4e0212e2_e18f_41e1_95e5_c0e7e9235bc3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE_IE10: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x11a47afd_6589_4124_b312_6158ec517fc3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE_IE11: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1cf1315f_ce3f_4035_9391_16142f775189);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE_IE9: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x052c2d39_40c0_4188_ab86_f828273b7522);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE_IE_EDGE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa6f3e465_3aca_442c_a3f0_ad6ddad839ae);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_CALLBACK: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc60381b8_83a4_41f8_a3d0_de05076849a9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_COMPATIBILITY_MODE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3ef26ad4_dc54_45de_b9af_76c8c66bfa8e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_COMPATIBILITY_MODE_WIN10: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5b25e089_6ca7_4139_a2cb_fcaab39552a3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_COMPATIBILITY_MODE_WWA_EDGE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x15b29098_9f01_4e4d_b65a_c06c6c89da2a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_CONTENT_PROTECTION_FLAGS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe0350223_5aaf_4d76_a7c3_06de70894db4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_CONTENT_PROTECTION_MANAGER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfdd6dfaa_bd85_4af3_9e0f_a01d539d876a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_CONTINUE_ON_CODEC_ERROR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdbcdb7f9_48e4_4295_b70d_d518234eeb38);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_COREWINDOW: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfccae4dc_0b7f_41c2_9f96_4659948acddc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_DXGI_MANAGER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x065702da_1094_486d_8617_ee7cc4ee4648);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EME_CALLBACK: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x494553a7_a481_4cb7_bec5_380903513731);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EXTENSION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3109fd46_060d_4b62_8dcf_faff811318d2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_MEDIA_PLAYER_MODE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3ddd8d45_5aa1_4112_82e5_36f6a2197e6e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_NEEDKEY_CALLBACK: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7ea80843_b6e4_432c_8ea4_7848ffe4220e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_OPM_HWND: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa0be8ee7_0572_4f2c_a801_2a151bd3e726);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_PLAYBACK_HWND: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd988879b_67c9_4d92_baa7_6eadd446039d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_PLAYBACK_VISUAL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6debd26f_6ab9_4d7e_b0ee_c61a73ffad15);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_SOURCE_RESOLVER_CONFIG_STORE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0ac0c497_b3c4_48c9_9cde_bb8ca2442ca3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_STREAM_CONTAINS_ALPHA_CHANNEL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5cbfaf44_d2b2_4cfb_80a7_d429c74c789d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_SYNCHRONOUS_CLOSE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc3c2e12f_7e0e_4e43_b91c_dc992ccdfa5e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_TELEMETRY_APPLICATION_ID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1e7b273b_a7e4_402a_8f51_c48e88a2cabc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_TIMEDTEXT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x805ea411_92e0_4e59_9b6e_5c7d7915e64f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_TRACK_ID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x65bea312_4043_4815_8eab_44dce2ef8f2a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_VIDEO_OUTPUT_FORMAT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5066893c_8cf9_42bc_8b8a_472212e52726);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_PROTECTION_MANAGER_PROPERTIES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x38bd81a9_acea_4c73_89b2_5532c0aeca79);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_SHARING_ENGINE_DEVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb461c58a_7a08_4b98_99a8_70fd5f3badfd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_SHARING_ENGINE_DEVICE_NAME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x771e05d1_862f_4299_95ac_ae81fd14f3e7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_SHARING_ENGINE_INITIAL_SEEK_TIME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6f3497f5_d528_4a4f_8dd7_db36657ec4c9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_METADATAFACIALEXPRESSION_SMILE: u32 = 1u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_METADATATIMESTAMPS_DEVICE: u32 = 1u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_METADATATIMESTAMPS_PRESENTATION: u32 = 2u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_METADATA_PROVIDER_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdb214084_58a4_4d2e_b84f_6f755b2f7a0d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MINCRYPT_FAILURE: u32 = 268435456u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MP2DLNA_AUDIO_BIT_RATE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2d1c070e_2b5f_4ab3_a7e6_8d943ba8d00a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MP2DLNA_ENCODE_QUALITY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb52379d7_1d46_4fb6_a317_a4a5f60959f8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MP2DLNA_STATISTICS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x75e488a3_d5ad_4898_85e0_bcce24a722d7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MP2DLNA_USE_MMCSS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x54f3e2ee_a2a2_497d_9834_973afde521eb);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MP2DLNA_VIDEO_BIT_RATE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe88548de_73b4_42d7_9c75_adfa0a2a6e4c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MPEG4SINK_MAX_CODED_SEQUENCES_PER_FRAGMENT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfc1b3bd6_692d_4ce5_9299_738aa5463e9a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MPEG4SINK_MINIMUM_PROPERTIES_SIZE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdca1ed52_450e_4a22_8c62_4ed452f7a187);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MPEG4SINK_MIN_FRAGMENT_DURATION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa30b570c_8efd_45e8_94fe_27c84b5bdff6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MPEG4SINK_MOOV_BEFORE_MDAT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf672e3ac_e1e6_4f10_b5ec_5f3b30828816);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MPEG4SINK_SPSPPS_PASSTHROUGH: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5601a134_2005_4ad2_b37d_22a6c554deb2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MSE_ACTIVELIST_CALLBACK: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x949bda0f_4549_46d5_ad7f_b846e1ab1652);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MSE_BUFFERLIST_CALLBACK: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x42e669b0_d60e_4afb_a85b_d8e5fe6bdab5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MSE_CALLBACK: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9063a7c0_42c5_4ffd_a8a8_6fcf9ea3d00c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MSE_OPUS_SUPPORT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4d224cc1_8cc4_48a3_a7a7_e4c16ce6388a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MSE_VP9_SUPPORT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x92d78429_d88b_4ff0_8322_803efa6e9626);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_AAC_AUDIO_PROFILE_LEVEL_INDICATION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7632f0e6_9538_4d61_acda_ea29c8c14456);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_AAC_PAYLOAD_TYPE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbfbabe79_7434_4d1c_94f0_72a3b9e17188);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_ALL_SAMPLES_INDEPENDENT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc9173739_5e56_461c_b713_46fb995cb95f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_ALPHA_MODE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5d959b0d_4cbf_4d04_919f_3f5f7f284211);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_AM_FORMAT_TYPE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x73d1072d_1870_4174_a063_29ff4ff6c11e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_ARBITRARY_FORMAT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5a75b249_0d7d_49a1_a1c3_e0d87f0cade5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_ARBITRARY_HEADER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9e6bd6f5_0109_4f95_84ac_9309153a19fc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_AUDIO_AVG_BYTES_PER_SECOND: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1aab75c8_cfef_451c_ab95_ac034b8e1731);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_AUDIO_BITS_PER_SAMPLE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf2deb57f_40fa_4764_aa33_ed4f2d1ff669);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_AUDIO_BLOCK_ALIGNMENT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x322de230_9eeb_43bd_ab7a_ff412251541d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_AUDIO_CHANNEL_MASK: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x55fb5765_644a_4caf_8479_938983bb1588);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_AUDIO_FLAC_MAX_BLOCK_SIZE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8b81adae_4b5a_4d40_8022_f38d09ca3c5c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_AUDIO_FLOAT_SAMPLES_PER_SECOND: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfb3b724a_cfb5_4319_aefe_6e42b2406132);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_AUDIO_FOLDDOWN_MATRIX: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9d62927c_36be_4cf2_b5c4_a3926e3e8711);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_AUDIO_NUM_CHANNELS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x37e48bf5_645e_4c5b_89de_ada9e29b696a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_AUDIO_PREFER_WAVEFORMATEX: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa901aaba_e037_458a_bdf6_545be2074042);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_AUDIO_SAMPLES_PER_BLOCK: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xaab15aac_e13a_4995_9222_501ea15c6877);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_AUDIO_SAMPLES_PER_SECOND: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5faeeae7_0290_4c31_9e8a_c534f68d9dba);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_AUDIO_VALID_BITS_PER_SAMPLE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd9bf8d6a_9530_4b7c_9ddf_ff6fd58bbd06);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_AUDIO_WMADRC_AVGREF: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9d62927f_36be_4cf2_b5c4_a3926e3e8711);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_AUDIO_WMADRC_AVGTARGET: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9d629280_36be_4cf2_b5c4_a3926e3e8711);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_AUDIO_WMADRC_PEAKREF: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9d62927d_36be_4cf2_b5c4_a3926e3e8711);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_AUDIO_WMADRC_PEAKTARGET: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9d62927e_36be_4cf2_b5c4_a3926e3e8711);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_AVG_BITRATE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x20332624_fb0d_4d9e_bd0d_cbf6786c102e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_AVG_BIT_ERROR_RATE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x799cabd6_3508_4db4_a3c7_569cd533deb1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_COMPRESSED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3afd0cee_18f2_4ba5_a110_8bea502e1f92);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_CONTAINER_RATE_SCALING: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x83877f5e_0444_4e28_8479_6db0989b8c09);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_CUSTOM_VIDEO_PRIMARIES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x47537213_8cfb_4722_aa34_fbc9e24d77b8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_D3D12_CPU_READBACK: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x28ee9fe3_d481_46a6_b98a_7f69d5280e82);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_D3D12_RESOURCE_FLAG_ALLOW_CROSS_ADAPTER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa6a1e439_2f96_4ab5_98dc_adf74973505d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb1138dc3_01d5_4c14_9bdc_cdc9336f55b9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xeeac2585_3430_498c_84a2_77b1bba570f6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_D3D12_RESOURCE_FLAG_ALLOW_SIMULTANEOUS_ACCESS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0a4940b2_cfd6_4738_9d02_98113734015a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x82c85647_5057_4960_9559_f45b8e271427);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_D3D12_RESOURCE_FLAG_DENY_SHADER_RESOURCE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xba06bfac_ffe3_474a_ab55_161ee4417a2e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_D3D12_TEXTURE_LAYOUT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x97c85caa_0beb_4ee1_9715_f22fad8c10f5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_D3D_RESOURCE_VERSION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x174f1e85_fe26_453d_b52e_5bdd4e55b944);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_DECODER_MAX_DPB_COUNT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x67be144c_88b7_4ca9_9628_c808d5262217);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_DECODER_USE_MAX_RESOLUTION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4c547c24_af9a_4f38_96ad_978773cf53e7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_DEFAULT_STRIDE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x644b4e48_1e02_4516_b0eb_c01ca9d49ac6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_DEPTH_MEASUREMENT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfd5ac489_0917_4bb6_9d54_3122bf70144b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_DEPTH_VALUE_UNIT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x21a800f5_3189_4797_beba_f13cd9a31a5e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_DRM_FLAGS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8772f323_355a_4cc7_bb78_6d61a048ae82);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_DV_AAUX_CTRL_PACK_0: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf731004e_1dd1_4515_aabe_f0c06aa536ac);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_DV_AAUX_CTRL_PACK_1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xcd1f470d_1f04_4fe0_bfb9_d07ae0386ad8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_DV_AAUX_SRC_PACK_0: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x84bd5d88_0fb8_4ac8_be4b_a8848bef98f3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_DV_AAUX_SRC_PACK_1: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x720e6544_0225_4003_a651_0196563a958e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_DV_VAUX_CTRL_PACK: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2f84e1c4_0da1_4788_938e_0dfbfbb34b48);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_DV_VAUX_SRC_PACK: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x41402d9d_7b57_43c6_b129_2cb997f15009);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_FIXED_SIZE_SAMPLES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb8ebefaf_b718_4e04_b0a9_116775e3321b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_FORWARD_CUSTOM_NALU: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xed336efd_244f_428d_9153_28f399458890);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_FORWARD_CUSTOM_SEI: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe27362f1_b136_41d1_9594_3a7e4febf2d1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_FRAME_RATE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc459a2e8_3d2c_4e44_b132_fee5156c7bb0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_FRAME_RATE_RANGE_MAX: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe3371d41_b4cf_4a05_bd4e_20b88bb2c4d6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_FRAME_RATE_RANGE_MIN: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd2e7558c_dc1f_403f_9a72_d28bb1eb3b5e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_FRAME_SIZE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1652c33d_d6b2_4012_b834_72030849a37d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_GEOMETRIC_APERTURE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x66758743_7e5f_400d_980a_aa8596c85696);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_H264_CAPABILITIES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbb3bd508_490a_11e0_99e4_1316dfd72085);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_H264_LAYOUT_PER_STREAM: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x85e299b2_90e3_4fe8_b2f5_c067e0bfe57a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_H264_MAX_CODEC_CONFIG_DELAY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf5929986_4c45_4fbb_bb49_6cc534d05b9b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_H264_MAX_MB_PER_SEC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x45256d30_7215_4576_9336_b0f1bcd59bb2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_H264_RATE_CONTROL_MODES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x705177d8_45cb_11e0_ac7d_b91ce0d72085);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_H264_RESOLUTION_SCALING: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe3854272_f715_4757_ba90_1b696c773457);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_H264_SIMULCAST_SUPPORT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9ea2d63d_53f0_4a34_b94e_9de49a078cb3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_H264_SUPPORTED_RATE_CONTROL_MODES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6a8ac47e_519c_4f18_9bb3_7eeaaea5594d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_H264_SUPPORTED_SLICE_MODES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc8be1937_4d64_4549_8343_a8086c0bfda5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_H264_SUPPORTED_SYNC_FRAME_TYPES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x89a52c01_f282_48d2_b522_22e6ae633199);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_H264_SUPPORTED_USAGES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x60b1a998_dc01_40ce_9736_aba845a2dbdc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_H264_SVC_CAPABILITIES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf8993abe_d937_4a8f_bbca_6966fe9e1152);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_H264_USAGE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x359ce3a5_af00_49ca_a2f4_2ac94ca82b61);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_IMAGE_LOSS_TOLERANT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xed062cf4_e34e_4922_be99_934032133d7c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_INTERLACE_MODE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe2724bb8_e676_4806_b4b2_a8d6efb44ccd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_IN_BAND_PARAMETER_SET: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x75da5090_910b_4a03_896c_7b898feea5af);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_MAJOR_TYPE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x48eba18e_f8c9_4687_bf11_0a74c9f96a8f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_MAX_FRAME_AVERAGE_LUMINANCE_LEVEL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x58d4bf57_6f52_4733_a195_a9e29ecf9e27);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_MAX_KEYFRAME_SPACING: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc16eb52b_73a1_476f_8d62_839d6a020652);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_MAX_LUMINANCE_LEVEL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x50253128_c110_4de4_98ae_46a324fae6da);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_MAX_MASTERING_LUMINANCE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd6c6b997_272f_4ca1_8d00_8042111a0ff6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_MINIMUM_DISPLAY_APERTURE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd7388766_18fe_48c6_a177_ee894867c8c4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_MIN_MASTERING_LUMINANCE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x839a4460_4e7e_4b4f_ae79_cc08905c7b27);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_MPEG2_CONTENT_PACKET: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x825d55e4_4f12_4197_9eb3_59b6e4710f06);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_MPEG2_FLAGS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x31e3991d_f701_4b2f_b426_8ae3bda9e04b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_MPEG2_HDCP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x168f1b4a_3e91_450f_aea7_e4baeadae5ba);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_MPEG2_LEVEL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x96f66574_11c5_4015_8666_bff516436da7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_MPEG2_ONE_FRAME_PER_PACKET: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x91a49eb5_1d20_4b42_ace8_804269bf95ed);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_MPEG2_PROFILE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xad76a80b_2d5c_4e0b_b375_64e520137036);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_MPEG2_STANDARD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa20af9e8_928a_4b26_aaa9_f05c74cac47c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_MPEG2_TIMECODE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5229ba10_e29d_4f80_a59c_df4f180207d2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_MPEG4_CURRENT_SAMPLE_ENTRY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9aa7e155_b64a_4c1d_a500_455d600b6560);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_MPEG4_SAMPLE_DESCRIPTION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x261e9d83_9529_4b8f_a111_8b9c950a81a9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_MPEG4_TRACK_TYPE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x54f486dd_9327_4f6d_80ab_6f709ebb4cce);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_MPEG_SEQUENCE_HEADER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3c036de7_3ad0_4c9e_9216_ee6d6ac21cb3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_MPEG_START_TIME_CODE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x91f67885_4333_4280_97cd_bd5a6c03a06e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_ORIGINAL_4CC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd7be3fe0_2bc7_492d_b843_61a1919b70c3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_ORIGINAL_WAVE_FORMAT_TAG: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8cbbc843_9fd9_49c2_882f_a72586c408ad);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_OUTPUT_BUFFER_NUM: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa505d3ac_f930_436e_8ede_93a509ce23b2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_PAD_CONTROL_FLAGS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4d0e73e5_80ea_4354_a9d0_1176ceb028ea);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_PALETTE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6d283f42_9846_4410_afd9_654d503b1a54);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_PAN_SCAN_APERTURE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x79614dde_9187_48fb_b8c7_4d52689de649);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_PAN_SCAN_ENABLED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4b7f6bc3_8b13_40b2_a993_abf630b8204e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_PIXEL_ASPECT_RATIO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc6376a1e_8d0a_4027_be45_6d9a0ad39bb6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_REALTIME_CONTENT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbb12d222_2bdb_425e_91ec_2308e189a58f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_SAMPLE_SIZE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdad3ab78_1990_408b_bce2_eba673dacc10);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_SECURE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc5acc4fd_0304_4ecf_809f_47bc97ff63bd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_SOURCE_CONTENT_HINT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x68aca3cc_22d0_44e6_85f8_28167197fa38);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_SPATIAL_AUDIO_DATA_PRESENT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6842f6e7_d43e_4ebb_9c9c_c96f41784863);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_SPATIAL_AUDIO_MAX_DYNAMIC_OBJECTS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdcfba24a_2609_4240_a721_3faea76a4df9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_SPATIAL_AUDIO_MAX_METADATA_ITEMS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x11aa80b4_e0da_47c6_8060_96c1259ae50d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_SPATIAL_AUDIO_MIN_METADATA_ITEM_OFFSET_SPACING: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x83e96ec9_1184_417e_8254_9f269158fc06);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_SPATIAL_AUDIO_OBJECT_METADATA_FORMAT_ID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2ab71bc0_6223_4ba7_ad64_7b94b47ae792);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_SPATIAL_AUDIO_OBJECT_METADATA_LENGTH: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x094ba8be_d723_489f_92fa_766777b34726);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_SUBTYPE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf7e34c9a_42e8_4714_b74b_cb29d72c35e5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_TIMESTAMP_CAN_BE_DTS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x24974215_1b7b_41e4_8625_ac469f2dedaa);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_TRANSFER_FUNCTION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5fb0fce9_be5c_4935_a811_ec838f8eed93);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_USER_DATA: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb6bc765f_4c3b_40a4_bd51_2535b66fe09d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_VIDEO_3D: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xcb5e88cf_7b5b_476b_85aa_1ca5ae187555);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_VIDEO_3D_FIRST_IS_LEFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xec298493_0ada_4ea1_a4fe_cbbd36ce9331);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_VIDEO_3D_FORMAT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5315d8a0_87c5_4697_b793_6606c67c049b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_VIDEO_3D_LEFT_IS_BASE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6d4b7bff_5629_4404_948c_c634f4ce26d4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_VIDEO_3D_NUM_VIEWS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xbb077e8a_dcbf_42eb_af60_418df98aa495);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_VIDEO_CHROMA_SITING: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x65df2370_c773_4c33_aa64_843e068efb0c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_VIDEO_H264_NO_FMOASO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xed461cd6_ec9f_416a_a8a3_26d7d31018d7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_VIDEO_LEVEL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x96f66574_11c5_4015_8666_bff516436da7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_VIDEO_LIGHTING: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x53a0529c_890b_4216_8bf9_599367ad6d20);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_VIDEO_NOMINAL_RANGE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc21b8ee5_b956_4071_8daf_325edf5cab11);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_VIDEO_NO_FRAME_ORDERING: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3f5b106f_6bc2_4ee3_b7ed_8902c18f5351);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_VIDEO_PRIMARIES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdbfbe4d7_0740_4ee0_8192_850ab0e21935);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_VIDEO_PROFILE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xad76a80b_2d5c_4e0b_b375_64e520137036);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_VIDEO_RENDERER_EXTENSION_PROFILE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8437d4b9_d448_4fcd_9b6b_839bf96c7798);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_VIDEO_ROTATION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc380465d_2271_428c_9b83_ecea3b4a85c1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_WRAPPED_TYPE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4d3f7b23_d02f_4e6c_9bee_e4bf2c6c695d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MT_YUV_MATRIX: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3e23d450_2c75_4d25_a00e_b91670d12327);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_NALU_LENGTH_INFORMATION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x19124e7c_ad4b_465f_bb18_20186287b6af);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_NALU_LENGTH_SET: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa7911d53_12a4_4965_ae70_6eadd6ff0551);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_NOT_FOUND_ERR: u32 = 2154823688u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_NOT_SUPPORTED_ERR: u32 = 2154823689u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PARSE_ERR: u32 = 2154823761u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ADAPTIVE_STREAMING: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xea0d5d97_29f9_488b_ae6b_7d6b4136112b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_APP_CONTEXT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6c990d32_bb8e_477a_8598_0d5d96fcd88a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_CODECLIST: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe4bb3509_c18d_4df1_bb99_7a36b3cc4119);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_CONTENTENCRYPTIONEX_ENCRYPTION_DATA: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x62508be5_ecdf_4924_a359_72bab3397b9d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_CONTENTENCRYPTION_KEYID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8520fe3e_277e_46ea_99e4_e30a86db12be);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_CONTENTENCRYPTION_LICENSE_URL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8520fe40_277e_46ea_99e4_e30a86db12be);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_CONTENTENCRYPTION_SECRET_DATA: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8520fe3f_277e_46ea_99e4_e30a86db12be);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_CONTENTENCRYPTION_TYPE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8520fe3d_277e_46ea_99e4_e30a86db12be);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_DATA_LENGTH: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe7d5b3e8_1f29_45d3_8822_3e78fae272ed);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_DATA_START_OFFSET: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe7d5b3e7_1f29_45d3_8822_3e78fae272ed);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_FILEPROPERTIES_CREATION_TIME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3de649b6_d76d_4e66_9ec9_78120fb4c7e3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_FILEPROPERTIES_FILE_ID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3de649b4_d76d_4e66_9ec9_78120fb4c7e3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_FILEPROPERTIES_FLAGS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3de649bb_d76d_4e66_9ec9_78120fb4c7e3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_FILEPROPERTIES_MAX_BITRATE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3de649be_d76d_4e66_9ec9_78120fb4c7e3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_FILEPROPERTIES_MAX_PACKET_SIZE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3de649bd_d76d_4e66_9ec9_78120fb4c7e3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_FILEPROPERTIES_MIN_PACKET_SIZE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3de649bc_d76d_4e66_9ec9_78120fb4c7e3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_FILEPROPERTIES_PACKETS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3de649b7_d76d_4e66_9ec9_78120fb4c7e3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_FILEPROPERTIES_PLAY_DURATION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3de649b8_d76d_4e66_9ec9_78120fb4c7e3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_FILEPROPERTIES_PREROLL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3de649ba_d76d_4e66_9ec9_78120fb4c7e3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_FILEPROPERTIES_SEND_DURATION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3de649b9_d76d_4e66_9ec9_78120fb4c7e3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_INFO_HAS_AUDIO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x80e62295_2296_4a44_b31c_d103c6fed23c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_INFO_HAS_NON_AUDIO_VIDEO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x80e62297_2296_4a44_b31c_d103c6fed23c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_INFO_HAS_VIDEO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x80e62296_2296_4a44_b31c_d103c6fed23c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_LANGLIST: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf23de43c_9977_460d_a6ec_32937f160f7d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_LANGLIST_LEGACYORDER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf23de43d_9977_460d_a6ec_32937f160f7d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_MARKER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5134330e_83a6_475e_a9d5_4fb875fb2e31);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_METADATA_IS_VBR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5fc6947a_ef60_445d_b449_442ecc78b4c1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_METADATA_LEAKY_BUCKET_PAIRS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5fc6947d_ef60_445d_b449_442ecc78b4c1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_METADATA_V8_BUFFERAVERAGE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5fc6947c_ef60_445d_b449_442ecc78b4c1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_METADATA_V8_VBRPEAK: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5fc6947b_ef60_445d_b449_442ecc78b4c1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_ASF_SCRIPT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe29cd0d7_d602_4923_a7fe_73fd97ecc650);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_AUDIO_ENCODING_BITRATE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6c990d35_bb8e_477a_8598_0d5d96fcd88a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_AUDIO_ISVARIABLEBITRATE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x33026ee0_e387_4582_ae0a_34a2ad3baa18);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_DURATION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6c990d33_bb8e_477a_8598_0d5d96fcd88a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_LAST_MODIFIED_TIME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6c990d38_bb8e_477a_8598_0d5d96fcd88a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_MIME_TYPE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6c990d37_bb8e_477a_8598_0d5d96fcd88a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_PLAYBACK_BOUNDARY_TIME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6c990d3b_bb8e_477a_8598_0d5d96fcd88a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_PLAYBACK_ELEMENT_ID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6c990d39_bb8e_477a_8598_0d5d96fcd88a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_PMPHOST_CONTEXT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6c990d31_bb8e_477a_8598_0d5d96fcd88a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_PREFERRED_LANGUAGE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6c990d3a_bb8e_477a_8598_0d5d96fcd88a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_SAMI_STYLELIST: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe0b73c7f_486d_484e_9872_4de5192a7bf8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_TOTAL_FILE_SIZE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6c990d34_bb8e_477a_8598_0d5d96fcd88a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PD_VIDEO_ENCODING_BITRATE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6c990d36_bb8e_477a_8598_0d5d96fcd88a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PMP_SERVER_CONTEXT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2f00c910_d2cf_4278_8b6a_d077fac3a25f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_POLICY_ID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb160c24d_c059_48f1_a901_9ee298a9a8c3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PREFERRED_SOURCE_URI: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5fc85488_436a_4db8_90af_4db402ae5c57);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PROGRESSIVE_CODING_CONTENT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8f020eea_1508_471f_9da6_507d7cfa40db);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PROPERTY_HANDLER_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa3face02_32b8_41dd_90e7_5fef7c8991b5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_QUALITY_NOTIFY_PROCESSING_LATENCY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf6b44af8_604d_46fe_a95d_45479b10c9bc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_QUALITY_NOTIFY_SAMPLE_LAG: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x30d15206_ed2a_4760_be17_eb4a9f12295c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_QUALITY_SERVICES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb7e2be11_2f96_4640_b52c_282365bdf16c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_QUOTA_EXCEEDED_ERR: u32 = 2154823702u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_RATE_CONTROL_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x866fa297_b802_4bf8_9dc9_5e3b6a9f53c9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_READWRITE_D3D_OPTIONAL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x216479d9_3071_42ca_bb6c_4c22102e1d18);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_READWRITE_DISABLE_CONVERTERS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x98d5b065_1374_4847_8d5d_31520fee7156);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_READWRITE_ENABLE_AUTOFINALIZE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdd7ca129_8cd1_4dc5_9dde_ce168675de61);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_READWRITE_ENABLE_HARDWARE_TRANSFORMS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa634a91c_822b_41b9_a494_4de4643612b0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_READWRITE_MMCSS_CLASS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x39384300_d0eb_40b1_87a0_3318871b5a53);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_READWRITE_MMCSS_CLASS_AUDIO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x430847da_0890_4b0e_938c_054332c547e1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_READWRITE_MMCSS_PRIORITY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x43ad19ce_f33f_4ba9_a580_e4cd12f2d144);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_READWRITE_MMCSS_PRIORITY_AUDIO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x273db885_2de2_4db2_a6a7_fdb66fb40b61);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_REMOTE_PROXY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2f00c90e_d2cf_4278_8b6a_d077fac3a25f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SAMI_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x49a89ae7_b4d9_4ef2_aa5c_f65a3e05ae4e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SAMPLEGRABBERSINK_IGNORE_CLOCK: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0efda2c0_2b69_4e2e_ab8d_46dcbff7d25d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SAMPLEGRABBERSINK_SAMPLE_TIME_OFFSET: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x62e3d776_8100_4e03_a6e8_bd3857ac9c47);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SA_AUDIO_ENDPOINT_AWARE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc0381701_805c_42b2_ac8d_e2b4bf21f4f8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SA_BUFFERS_PER_SAMPLE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x873c5171_1e3d_4e25_988d_b433ce041983);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SA_D3D11_ALLOCATE_DISPLAYABLE_RESOURCES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xeeface6d_2ea9_4adf_bbdf_7bbc482a1b6d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SA_D3D11_ALLOW_DYNAMIC_YUV_TEXTURE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xce06d49f_0613_4b9d_86a6_d8c4f9c10075);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SA_D3D11_AWARE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x206b4fc8_fcf9_4c51_afe3_9764369e33a0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SA_D3D11_BINDFLAGS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xeacf97ad_065c_4408_bee3_fdcbfd128be2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SA_D3D11_HW_PROTECTED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3a8ba9d9_92ca_4307_a391_6999dbf3b6ce);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SA_D3D11_SHARED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7b8f32c3_6d96_4b89_9203_dd38b61414f3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SA_D3D11_SHARED_WITHOUT_MUTEX: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x39dbd44d_2e44_4931_a4c8_352d3dc42115);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SA_D3D11_USAGE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe85fe442_2ca3_486e_a9c7_109dda609880);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SA_D3D12_CLEAR_VALUE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x86ba9a39_0526_495d_9ab5_54ec9fad6fc3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SA_D3D12_HEAP_FLAGS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x496b3266_d28f_4f8c_93a7_4a596b1a31a1);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SA_D3D12_HEAP_TYPE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x56f26a76_bbc1_4ce0_bb11_e22368d874ed);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SA_D3D_AWARE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xeaa35c29_775e_488e_9b61_b3283e49583b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SA_MINIMUM_OUTPUT_SAMPLE_COUNT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x851745d5_c3d6_476d_9527_498ef2d10d18);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SA_MINIMUM_OUTPUT_SAMPLE_COUNT_PROGRESSIVE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0f5523a5_1cb2_47c5_a550_2eeb84b4d14a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SA_REQUIRED_SAMPLE_COUNT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x18802c61_324b_4952_abd0_176ff5c696ff);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SA_REQUIRED_SAMPLE_COUNT_PROGRESSIVE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb172d58e_fa77_4e48_8d2a_1df2d850eac2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SDK_VERSION: u32 = 2u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SD_AMBISONICS_SAMPLE3D_DESCRIPTION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf715cf3e_a964_4c3f_94ae_9d6ba7264641);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SD_ASF_EXTSTRMPROP_AVG_BUFFERSIZE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x48f8a524_305d_422d_8524_2502dda33680);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SD_ASF_EXTSTRMPROP_AVG_DATA_BITRATE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x48f8a523_305d_422d_8524_2502dda33680);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SD_ASF_EXTSTRMPROP_LANGUAGE_ID_INDEX: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x48f8a522_305d_422d_8524_2502dda33680);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SD_ASF_EXTSTRMPROP_MAX_BUFFERSIZE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x48f8a526_305d_422d_8524_2502dda33680);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SD_ASF_EXTSTRMPROP_MAX_DATA_BITRATE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x48f8a525_305d_422d_8524_2502dda33680);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SD_ASF_METADATA_DEVICE_CONFORMANCE_TEMPLATE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x245e929d_c44e_4f7e_bb3c_77d4dfd27f8a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SD_ASF_STREAMBITRATES_BITRATE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa8e182ed_afc8_43d0_b0d1_f65bad9da558);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SD_AUDIO_ENCODER_DELAY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8e85422c_73de_403f_9a35_550ad6e8b951);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SD_AUDIO_ENCODER_PADDING: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x529c7f2c_ac4b_4e3f_bfc3_0902194982cb);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SD_LANGUAGE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00af2180_bdc2_423c_abca_f503593bc121);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SD_MEDIASOURCE_STATUS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1913678b_fc0f_44da_8f43_1ba3b526f4ae);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SD_MUTUALLY_EXCLUSIVE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x023ef79c_388d_487f_ac17_696cd6e3c6f5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SD_PROTECTED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00af2181_bdc2_423c_abca_f503593bc121);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SD_SAMI_LANGUAGE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x36fcb98a_6cd0_44cb_acb9_a8f5600dd0bb);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SD_STREAM_NAME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4f1b099d_d314_41e5_a781_7fefaa4c501f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SD_VIDEO_SPHERICAL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa51da449_3fdc_478c_bcb5_30be76595f55);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SD_VIDEO_SPHERICAL_FORMAT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4a8fc407_6ea1_46c8_b567_6971d4a139c3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SD_VIDEO_SPHERICAL_INITIAL_VIEWDIRECTION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x11d25a49_bb62_467f_9db1_c17165716c49);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SESSION_APPROX_EVENT_OCCURRENCE_TIME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x190e852f_6238_42d1_b5af_69ea338ef850);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SESSION_CONTENT_PROTECTION_MANAGER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1e83d482_1f1c_4571_8405_88f4b2181f74);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SESSION_GLOBAL_TIME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1e83d482_1f1c_4571_8405_88f4b2181f72);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SESSION_QUALITY_MANAGER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1e83d482_1f1c_4571_8405_88f4b2181f73);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SESSION_REMOTE_SOURCE_MODE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf4033ef4_9bb3_4378_941f_85a0856bc244);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SESSION_SERVER_CONTEXT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xafe5b291_50fa_46e8_b9be_0c0c3ce4b3a5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SESSION_TOPOLOADER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1e83d482_1f1c_4571_8405_88f4b2181f71);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SHARING_ENGINE_CALLBACK: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x57dc1e95_d252_43fa_9bbc_180070eefe6d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SHARING_ENGINE_SHAREDRENDERER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xefa446a0_73e7_404e_8ae2_fef60af5a32b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SHUTDOWN_RENDERER_ON_ENGINE_SHUTDOWN: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc112d94d_6b9c_48f8_b6f9_7950ff9ab71e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SINK_VIDEO_DISPLAY_ASPECT_RATIO_DENOMINATOR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6ea1eb97_1fe0_4f10_a6e4_1f4f661564e0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SINK_VIDEO_DISPLAY_ASPECT_RATIO_NUMERATOR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd0f33b22_b78a_4879_b455_f03ef3fa82cd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SINK_VIDEO_NATIVE_HEIGHT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf0ca6705_490c_43e8_941c_c0b3206b9a65);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SINK_VIDEO_NATIVE_WIDTH: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe6d6a707_1505_4747_9b10_72d2d158cb3a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SINK_VIDEO_PTS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2162bde7_421e_4b90_9b33_e58fbf1d58b6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SINK_WRITER_ASYNC_CALLBACK: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x48cb183e_7b0b_46f4_822e_5e1d2dda4354);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SINK_WRITER_D3D_MANAGER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xec822da2_e1e9_4b29_a0d8_563c719f5269);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SINK_WRITER_DISABLE_THROTTLING: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x08b845d8_2b74_4afe_9d53_be16d2d5ae4f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SINK_WRITER_ENCODER_CONFIG: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xad91cd04_a7cc_4ac7_99b6_a57b9a4a7c70);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_PRESENTATION_PROVIDER_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe002aadc_f4af_4ee5_9847_053edf840426);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READER_ASYNC_CALLBACK: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1e3dbeac_bb43_4c35_b507_cd644464c965);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READER_D3D11_BIND_FLAGS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x33f3197b_f73a_4e14_8d85_0e4c4368788d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READER_D3D_MANAGER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xec822da2_e1e9_4b29_a0d8_563c719f5269);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READER_DISABLE_CAMERA_PLUGINS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9d3365dd_058f_4cfb_9f97_b314cc99c8ad);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READER_DISABLE_DXVA: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xaa456cfd_3943_4a1e_a77d_1838c0ea2e35);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READER_DISCONNECT_MEDIASOURCE_ON_SHUTDOWN: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x56b67165_219e_456d_a22e_2d3004c7fe56);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READER_ENABLE_ADVANCED_VIDEO_PROCESSING: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0f81da2c_b537_4672_a8b2_a681b17307a3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READER_ENABLE_TRANSCODE_ONLY_TRANSFORMS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xdfd4f008_b5fd_4e78_ae44_62a1e67bbe27);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READER_ENABLE_VIDEO_PROCESSING: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfb394f3d_ccf1_42ee_bbb3_f9b845d5681d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READER_MEDIASOURCE_CHARACTERISTICS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6d23f5c8_c5d7_4a9b_9971_5d11f8bca880);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READER_MEDIASOURCE_CONFIG: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9085abeb_0354_48f9_abb5_200df838c68e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_STREAM_SUPPORTS_HW_CONNECTION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa38253aa_6314_42fd_a3ce_bb27b6859946);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_STF_VERSION_DATE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x31a165d5_df67_4095_8e44_8868fc20dbfd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_STF_VERSION_INFO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6770bd39_ef82_44ee_a49b_934beb24aef7);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_STREAM_SINK_SUPPORTS_HW_CONNECTION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9b465cbf_0597_4f9e_9f3c_b97eeef90359);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_STREAM_SINK_SUPPORTS_ROTATION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb3e96280_bd05_41a5_97ad_8a7fee24b912);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ST_MEDIASOURCE_COLLECTION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x616de972_83ad_4950_8170_630d19cbe307);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SYNTAX_ERR: u32 = 2154823692u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_S_ACTIVATE_REPLACED: ::windows::core::HRESULT = ::windows::core::HRESULT(866045i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_S_ASF_PARSEINPROGRESS: ::windows::core::HRESULT = ::windows::core::HRESULT(1074608792i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_S_CLOCK_STOPPED: ::windows::core::HRESULT = ::windows::core::HRESULT(891972i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_S_MULTIPLE_BEGIN: ::windows::core::HRESULT = ::windows::core::HRESULT(866008i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_S_PE_TRUSTED: ::windows::core::HRESULT = ::windows::core::HRESULT(881011i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_S_PROTECTION_NOT_REQUIRED: ::windows::core::HRESULT = ::windows::core::HRESULT(880976i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_S_SEQUENCER_CONTEXT_CANCELED: ::windows::core::HRESULT = ::windows::core::HRESULT(876973i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_S_SEQUENCER_SEGMENT_AT_END_OF_STREAM: ::windows::core::HRESULT = ::windows::core::HRESULT(876975i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_S_SINK_NOT_FINALIZED: ::windows::core::HRESULT = ::windows::core::HRESULT(870978i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_S_TRANSFORM_DO_NOT_PROPAGATE_EVENT: ::windows::core::HRESULT = ::windows::core::HRESULT(879989i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_S_VIDEO_DISABLED_WITH_UNKNOWN_SOFTWARE_OUTPUT: ::windows::core::HRESULT = ::windows::core::HRESULT(881001i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_S_WAIT_FOR_POLICY_SET: ::windows::core::HRESULT = ::windows::core::HRESULT(881000i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SampleProtectionSalt: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5403deee_b9ee_438f_aa83_3804997e569d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TEST_SIGNED_COMPONENT_LOADING: u32 = 16777216u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMECODE_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa0d502a7_0eb3_4885_b1b9_9feb0d083454);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIME_FORMAT_ENTRY_RELATIVE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4399f178_46d3_4504_afda_20d32e9ba360);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIME_FORMAT_SEGMENT_OFFSET: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc8b8be77_869c_431d_812e_169693f65a39);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOLOGY_DXVA_MODE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1e8d34f6_f5ab_4e23_bb88_874aa3a1a74d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOLOGY_DYNAMIC_CHANGE_NOT_ALLOWED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd529950b_d484_4527_a9cd_b1909532b5b0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOLOGY_ENABLE_XVP_FOR_PLAYBACK: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1967731f_cd78_42fc_b026_0992a56e5693);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOLOGY_ENUMERATE_SOURCE_TYPES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6248c36d_5d0b_4f40_a0bb_b0b305f77698);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOLOGY_HARDWARE_MODE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd2d362fd_4e4f_4191_a579_c618b66706af);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOLOGY_NO_MARKIN_MARKOUT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7ed3f804_86bb_4b3f_b7e4_7cb43afd4b80);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOLOGY_PLAYBACK_FRAMERATE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc164737a_c2b1_4553_83bb_5a526072448f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOLOGY_PLAYBACK_MAX_DIMS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5715cf19_5768_44aa_ad6e_8721f1b0f9bb);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOLOGY_PROJECTSTART: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7ed3f802_86bb_4b3f_b7e4_7cb43afd4b80);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOLOGY_PROJECTSTOP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7ed3f803_86bb_4b3f_b7e4_7cb43afd4b80);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOLOGY_RESOLUTION_STATUS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x494bbcde_b031_4e38_97c4_d5422dd618dc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOLOGY_START_TIME_ON_PRESENTATION_SWITCH: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc8cc113f_7951_4548_aad6_9ed6202e62b3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOLOGY_STATIC_PLAYBACK_OPTIMIZATIONS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb86cac42_41a6_4b79_897a_1ab0e52b4a1b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_ATTRIBUTE_EDITOR_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x65656e1a_077f_4472_83ef_316f11d5087a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_CONNECT_METHOD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x494bbcf1_b031_4e38_97c4_d5422dd618dc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_D3DAWARE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x494bbced_b031_4e38_97c4_d5422dd618dc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_DECODER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x494bbd02_b031_4e38_97c4_d5422dd618dc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_DECRYPTOR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x494bbcfa_b031_4e38_97c4_d5422dd618dc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_DISABLE_PREROLL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x14932f9e_9087_4bb4_8412_5167145cbe04);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_DISCARDABLE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x494bbcfb_b031_4e38_97c4_d5422dd618dc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_DRAIN: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x494bbce9_b031_4e38_97c4_d5422dd618dc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_ERRORCODE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x494bbcee_b031_4e38_97c4_d5422dd618dc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_ERROR_MAJORTYPE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x494bbcfd_b031_4e38_97c4_d5422dd618dc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_ERROR_SUBTYPE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x494bbcfe_b031_4e38_97c4_d5422dd618dc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_FLUSH: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x494bbce8_b031_4e38_97c4_d5422dd618dc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_LOCKED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x494bbcf7_b031_4e38_97c4_d5422dd618dc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_MARKIN_HERE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x494bbd00_b031_4e38_97c4_d5422dd618dc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_MARKOUT_HERE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x494bbd01_b031_4e38_97c4_d5422dd618dc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_MEDIASTART: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x835c58ea_e075_4bc7_bcba_4de000df9ae6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_MEDIASTOP: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x835c58eb_e075_4bc7_bcba_4de000df9ae6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_NOSHUTDOWN_ON_REMOVE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x14932f9c_9087_4bb4_8412_5167145cbe04);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_PRESENTATION_DESCRIPTOR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x835c58ed_e075_4bc7_bcba_4de000df9ae6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_PRIMARYOUTPUT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6304ef99_16b2_4ebe_9d67_e4c539b3a259);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_RATELESS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x14932f9d_9087_4bb4_8412_5167145cbe04);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_SEQUENCE_ELEMENTID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x835c58ef_e075_4bc7_bcba_4de000df9ae6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_SOURCE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x835c58ec_e075_4bc7_bcba_4de000df9ae6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_STREAMID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x14932f9b_9087_4bb4_8412_5167145cbe04);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_STREAM_DESCRIPTOR: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x835c58ee_e075_4bc7_bcba_4de000df9ae6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_TRANSFORM_OBJECTID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x88dcc0c9_293e_4e8b_9aeb_0ad64cc016b0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_WORKQUEUE_ID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x494bbcf8_b031_4e38_97c4_d5422dd618dc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_WORKQUEUE_ITEM_PRIORITY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa1ff99be_5e97_4a53_b494_568c642c0ff3);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_WORKQUEUE_MMCSS_CLASS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x494bbcf9_b031_4e38_97c4_d5422dd618dc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_WORKQUEUE_MMCSS_PRIORITY: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5001f840_2816_48f4_9364_ad1ef661a123);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_WORKQUEUE_MMCSS_TASKID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x494bbcff_b031_4e38_97c4_d5422dd618dc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TRANSCODE_ADJUST_PROFILE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9c37c21b_060f_487c_a690_80d7f50d1c72);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TRANSCODE_CONTAINERTYPE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x150ff23f_4abc_478b_ac4f_e1916fba1cca);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TRANSCODE_DONOT_INSERT_ENCODER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf45aa7ce_ab24_4012_a11b_dc8220201410);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TRANSCODE_ENCODINGPROFILE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6947787c_f508_4ea9_b1e9_a1fe3a49fbc9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TRANSCODE_QUALITYVSSPEED: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x98332df8_03cd_476b_89fa_3f9e442dec9f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TRANSCODE_SKIP_METADATA_TRANSFER: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4e4469ef_b571_4959_8f83_3dcfba33a393);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TRANSCODE_TOPOLOGYMODE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3e3df610_394a_40b2_9dea_3bab650bebf2);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TRANSFORM_ASYNC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf81a699a_649a_497d_8c73_29f8fed6ad7a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TRANSFORM_ASYNC_UNLOCK: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe5666d6b_3422_4eb6_a421_da7db1f8e207);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TRANSFORM_CATEGORY_Attribute: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xceabba49_506d_4757_a6ff_66c184987e4e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TRANSFORM_FLAGS_Attribute: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9359bb7e_6275_46c4_a025_1c01e45f1a86);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TYPE_ERR: u32 = 2154840069u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_UNKNOWN_DURATION: u32 = 0u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_USER_DATA_PAYLOAD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd1d4985d_dc92_457a_b3a0_651a33a31047);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_USER_EXTENDED_ATTRIBUTES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc02abac6_feb2_4541_922f_920b43702722);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_USER_MODE_COMPONENT_LOAD: u32 = 1u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_VERSION: u32 = 131184u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_VIDEODSP_MODE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x16d720f0_768c_11de_8a39_0800200c9a66);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_VIDEO_MAX_MB_PER_SEC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe3f2e203_d445_4b8c_9211_ae390d3ba017);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_VIDEO_PROCESSOR_ALGORITHM: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4a0a1e1f_272c_4fb6_9eb1_db330cbc97ca);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_VIDEO_RENDERER_EFFECT_APP_SERVICE_NAME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc6052a80_6d9c_40a3_9db8_f027a25c9ab9);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_VIRTUALCAMERA_ASSOCIATED_CAMERA_SOURCES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1bb79e7c_5d83_438c_94d8_e5f0df6d3279);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_VIRTUALCAMERA_CONFIGURATION_APP_PACKAGE_FAMILY_NAME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x658abe51_8044_462e_97ea_e676fd72055f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_VIRTUALCAMERA_PROVIDE_ASSOCIATED_CAMERA_SOURCES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf0273718_4a4d_4ac5_a15d_305eb5e90667);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_WORKQUEUE_SERVICES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8e37d489_41e0_413a_9068_287c886d8dda);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_WRAPPED_BUFFER_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xab544072_c269_4ebc_a552_1c3b32bed5ca);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_WRAPPED_OBJECT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2b182c4c_d6ac_49f4_8915_f71887db70cd);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_WRAPPED_SAMPLE_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x31f52bf2_d03e_4048_80d0_9c1046d87c61);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_WVC1_PROG_SINGLE_SLICE_CONTENT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x67ec2559_0f2f_4420_a4dd_2f8ee7a5738b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_XVP_CALLER_ALLOCATES_OUTPUT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x04a2cabc_0cab_40b1_a1b9_75bc3658f000);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_XVP_DISABLE_FRC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2c0afa19_7a97_4d5a_9ee8_16d4fc518d8c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_XVP_SAMPLE_LOCK_TIMEOUT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xaa4ddb29_5134_4363_ac72_83ec4bc10426);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MP3ACMCodecWrapper: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x11103421_354c_4cca_a7a3_1aff9a5b6701);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MR_AUDIO_POLICY_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x911fd737_6775_4ab0_a614_297862fdac88);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MR_BUFFER_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa562248c_9ac6_4ffc_9fba_3af8f8ad1a4d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MR_CAPTURE_POLICY_VOLUME_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x24030acd_107a_4265_975c_414e33e65f2a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MR_POLICY_VOLUME_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1abaa2ac_9d3b_47c6_ab48_c59506de784d);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MR_STREAM_VOLUME_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xf8b5fa2f_32ef_46f5_b172_1321212fb2c4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MR_VIDEO_ACCELERATION_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xefef5175_5c7d_4ce2_bbbd_34ff8bca6554);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MR_VIDEO_MIXER_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x073cd2fc_6cf4_40b7_8859_e89552c841f8);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MR_VIDEO_RENDER_SERVICE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1092a86c_ab1a_459a_a336_831fbc4d11ff);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MSAMRNBDecoder: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x265011ae_5481_4f77_a295_abb6ffe8d63e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MSAMRNBEncoder: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x2fae8afe_04a3_423a_a814_85db454712b0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MULawCodecWrapper: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x92b66080_5e2d_449e_90c4_c41f268e5514);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_GET_ACP_AND_CGMSA_SIGNALING: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x6629a591_3b79_4cf3_924a_11e8e7811671);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_GET_ACTUAL_OUTPUT_FORMAT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xd7bf1ba3_ad13_4f8e_af98_0dcb3ca204cc);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_GET_ACTUAL_PROTECTION_LEVEL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1957210a_7766_452a_b99a_d27aed54f03a);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_GET_ADAPTER_BUS_TYPE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xc6f4d673_6174_4184_8e35_f6db5200bcba);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_GET_CODEC_INFO: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x4f374491_8f5f_4445_9dba_95588f6b58b4);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_GET_CONNECTED_HDCP_DEVICE_INFORMATION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x0db59d74_a992_492e_a0bd_c23fda564e00);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_GET_CONNECTOR_TYPE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x81d0bfd5_6afe_48c2_99c0_95a08f97c5da);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_GET_CURRENT_HDCP_SRM_VERSION: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x99c5ceff_5f1d_4879_81c1_c52443c9482b);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_GET_DVI_CHARACTERISTICS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xa470b3bb_5dd7_4172_839c_3d3776e0ebf5);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_GET_OUTPUT_HARDWARE_PROTECTION_SUPPORT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x3b129589_2af8_4ef0_96a2_704a845a218e);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_GET_OUTPUT_ID: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x72cb6df3_244f_40ce_b09e_20506af6302f);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_GET_SUPPORTED_PROTECTION_TYPES: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x38f2a801_9a6c_48bb_9107_b6696e6f1797);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_GET_VIRTUAL_PROTECTION_LEVEL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xb2075857_3eda_4d5d_88db_748f8c1a0549);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_SET_ACP_AND_CGMSA_SIGNALING: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x09a631a5_d684_4c60_8e4d_d3bb0f0be3ee);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_SET_HDCP_SRM: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x8b5ef5d1_c30d_44ff_84a5_ea71dce78f13);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_SET_PROTECTION_LEVEL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x9bb9327c_4eb5_4727_9f00_b42b0919c0da);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_SET_PROTECTION_LEVEL_ACCORDING_TO_CSS_DVD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x39ce333e_4cc0_44ae_bfcc_da50b5f82e72);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PIN_CATEGORY_ANALOGVIDEOIN: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfb6c4283_0353_11d1_905f_0000c0cc16ba);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PIN_CATEGORY_CAPTURE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfb6c4281_0353_11d1_905f_0000c0cc16ba);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PIN_CATEGORY_CC: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfb6c4289_0353_11d1_905f_0000c0cc16ba);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PIN_CATEGORY_EDS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfb6c4287_0353_11d1_905f_0000c0cc16ba);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PIN_CATEGORY_NABTS: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfb6c4286_0353_11d1_905f_0000c0cc16ba);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PIN_CATEGORY_PREVIEW: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfb6c4282_0353_11d1_905f_0000c0cc16ba);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PIN_CATEGORY_STILL: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfb6c428a_0353_11d1_905f_0000c0cc16ba);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PIN_CATEGORY_TELETEXT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfb6c4288_0353_11d1_905f_0000c0cc16ba);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PIN_CATEGORY_TIMECODE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfb6c428b_0353_11d1_905f_0000c0cc16ba);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PIN_CATEGORY_VBI: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfb6c4284_0353_11d1_905f_0000c0cc16ba);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PIN_CATEGORY_VIDEOPORT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfb6c4285_0353_11d1_905f_0000c0cc16ba);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PIN_CATEGORY_VIDEOPORT_VBI: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xfb6c428c_0353_11d1_905f_0000c0cc16ba);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PRESENTATION_CURRENT_POSITION: u64 = 9223372036854775807u64;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const SHA_HASH_LEN: u32 = 20u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const SYSFXUI_DONOTSHOW_BASSBOOST: u32 = 8u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const SYSFXUI_DONOTSHOW_BASSMANAGEMENT: u32 = 4u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const SYSFXUI_DONOTSHOW_CHANNELPHANTOMING: u32 = 128u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const SYSFXUI_DONOTSHOW_HEADPHONEVIRTUALIZATION: u32 = 16u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const SYSFXUI_DONOTSHOW_LOUDNESSEQUALIZATION: u32 = 1u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const SYSFXUI_DONOTSHOW_ROOMCORRECTION: u32 = 2u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const SYSFXUI_DONOTSHOW_SPEAKERFILLING: u32 = 64u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const SYSFXUI_DONOTSHOW_VIRTUALSURROUND: u32 = 32u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const TIME_FORMAT_BYTE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7b785571_8c82_11cf_bc0c_00aa00ac74f6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const TIME_FORMAT_FIELD: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7b785573_8c82_11cf_bc0c_00aa00ac74f6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const TIME_FORMAT_FRAME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7b785570_8c82_11cf_bc0c_00aa00ac74f6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const TIME_FORMAT_MEDIA_TIME: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7b785574_8c82_11cf_bc0c_00aa00ac74f6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const TIME_FORMAT_NONE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x00000000_0000_0000_0000_000000000000);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const TIME_FORMAT_SAMPLE: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7b785572_8c82_11cf_bc0c_00aa00ac74f6);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const TOC_ENTRY_MAX_TITLE_SIZE: u32 = 65535u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const TOC_MAX_DESCRIPTION_SIZE: u32 = 65535u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const UUID_UdriTagTables: ::windows::core::GUID = ::windows::core::GUID::from_u128(0xe1b98d74_9778_4878_b664_eb2020364d88);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const UUID_WMDRMTagTables: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x5dcd1101_9263_45bb_a4d5_c415ab8c589c);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const VIDEO_ZOOM_RECT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x7aaa1638_1b7f_4c93_bd89_5b9c9fb6fcf0);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const VorbisDecoderMFT: ::windows::core::GUID = ::windows::core::GUID::from_u128(0x1a198ef2_60e5_4ea8_90d8_da1f2832c288);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const WMAAECMA_E_NO_ACTIVE_RENDER_STREAM: u32 = 2278293514u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const WM_CODEC_ONEPASS_CBR: u32 = 1u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const WM_CODEC_ONEPASS_VBR: u32 = 2u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const WM_CODEC_TWOPASS_CBR: u32 = 4u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const WM_CODEC_TWOPASS_VBR_PEAKCONSTRAINED: u32 = 16u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const WM_CODEC_TWOPASS_VBR_UNCONSTRAINED: u32 = 8u32;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const g_wszSpeechFormatCaps: ::windows::core::PCWSTR = ::windows::core::w!("SpeechFormatCap");
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const g_wszWMCPAudioVBRQuality: ::windows::core::PCWSTR = ::windows::core::w!("_VBRQUALITY");
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const g_wszWMCPAudioVBRSupported: ::windows::core::PCWSTR = ::windows::core::w!("_VBRENABLED");
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const g_wszWMCPCodecName: ::windows::core::PCWSTR = ::windows::core::w!("_CODECNAME");
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const g_wszWMCPDefaultCrisp: ::windows::core::PCWSTR = ::windows::core::w!("_DEFAULTCRISP");
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const g_wszWMCPMaxPasses: ::windows::core::PCWSTR = ::windows::core::w!("_PASSESRECOMMENDED");
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const g_wszWMCPSupportedVBRModes: ::windows::core::PCWSTR = ::windows::core::w!("_SUPPORTEDVBRMODES");
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct AEC_INPUT_STREAM(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AEC_CAPTURE_STREAM: AEC_INPUT_STREAM = AEC_INPUT_STREAM(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AEC_REFERENCE_STREAM: AEC_INPUT_STREAM = AEC_INPUT_STREAM(1i32);
impl ::core::marker::Copy for AEC_INPUT_STREAM {}
impl ::core::clone::Clone for AEC_INPUT_STREAM {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for AEC_INPUT_STREAM {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for AEC_INPUT_STREAM {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for AEC_INPUT_STREAM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AEC_INPUT_STREAM").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct AEC_SYSTEM_MODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const SINGLE_CHANNEL_AEC: AEC_SYSTEM_MODE = AEC_SYSTEM_MODE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const ADAPTIVE_ARRAY_ONLY: AEC_SYSTEM_MODE = AEC_SYSTEM_MODE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPTIBEAM_ARRAY_ONLY: AEC_SYSTEM_MODE = AEC_SYSTEM_MODE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const ADAPTIVE_ARRAY_AND_AEC: AEC_SYSTEM_MODE = AEC_SYSTEM_MODE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPTIBEAM_ARRAY_AND_AEC: AEC_SYSTEM_MODE = AEC_SYSTEM_MODE(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const SINGLE_CHANNEL_NSAGC: AEC_SYSTEM_MODE = AEC_SYSTEM_MODE(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MODE_NOT_SET: AEC_SYSTEM_MODE = AEC_SYSTEM_MODE(6i32);
impl ::core::marker::Copy for AEC_SYSTEM_MODE {}
impl ::core::clone::Clone for AEC_SYSTEM_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for AEC_SYSTEM_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for AEC_SYSTEM_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for AEC_SYSTEM_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AEC_SYSTEM_MODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct AEC_VAD_MODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AEC_VAD_DISABLED: AEC_VAD_MODE = AEC_VAD_MODE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AEC_VAD_NORMAL: AEC_VAD_MODE = AEC_VAD_MODE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AEC_VAD_FOR_AGC: AEC_VAD_MODE = AEC_VAD_MODE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AEC_VAD_FOR_SILENCE_SUPPRESSION: AEC_VAD_MODE = AEC_VAD_MODE(3i32);
impl ::core::marker::Copy for AEC_VAD_MODE {}
impl ::core::clone::Clone for AEC_VAD_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for AEC_VAD_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for AEC_VAD_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for AEC_VAD_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AEC_VAD_MODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct ASF_SELECTION_STATUS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const ASF_STATUS_NOTSELECTED: ASF_SELECTION_STATUS = ASF_SELECTION_STATUS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const ASF_STATUS_CLEANPOINTSONLY: ASF_SELECTION_STATUS = ASF_SELECTION_STATUS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const ASF_STATUS_ALLDATAUNITS: ASF_SELECTION_STATUS = ASF_SELECTION_STATUS(2i32);
impl ::core::marker::Copy for ASF_SELECTION_STATUS {}
impl ::core::clone::Clone for ASF_SELECTION_STATUS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for ASF_SELECTION_STATUS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for ASF_SELECTION_STATUS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for ASF_SELECTION_STATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ASF_SELECTION_STATUS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct ASF_STATUSFLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const ASF_STATUSFLAGS_INCOMPLETE: ASF_STATUSFLAGS = ASF_STATUSFLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const ASF_STATUSFLAGS_NONFATAL_ERROR: ASF_STATUSFLAGS = ASF_STATUSFLAGS(2i32);
impl ::core::marker::Copy for ASF_STATUSFLAGS {}
impl ::core::clone::Clone for ASF_STATUSFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for ASF_STATUSFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for ASF_STATUSFLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for ASF_STATUSFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ASF_STATUSFLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_BITSTREAM_ENCRYPTION_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_BITSTREAM_ENCRYPTION_TYPE_NONE: D3D12_BITSTREAM_ENCRYPTION_TYPE = D3D12_BITSTREAM_ENCRYPTION_TYPE(0i32);
impl ::core::marker::Copy for D3D12_BITSTREAM_ENCRYPTION_TYPE {}
impl ::core::clone::Clone for D3D12_BITSTREAM_ENCRYPTION_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_BITSTREAM_ENCRYPTION_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_BITSTREAM_ENCRYPTION_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_BITSTREAM_ENCRYPTION_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_BITSTREAM_ENCRYPTION_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_FEATURE_VIDEO(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_DECODE_SUPPORT: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_DECODE_PROFILES: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_DECODE_FORMATS: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_DECODE_CONVERSION_SUPPORT: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_PROCESS_SUPPORT: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_PROCESS_MAX_INPUT_STREAMS: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_PROCESS_REFERENCE_INFO: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_DECODER_HEAP_SIZE: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_PROCESSOR_SIZE: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(9i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_DECODE_PROFILE_COUNT: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(10i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_DECODE_FORMAT_COUNT: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(11i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_ARCHITECTURE: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(17i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_DECODE_HISTOGRAM: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(18i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_FEATURE_AREA_SUPPORT: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(19i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_MOTION_ESTIMATOR: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(20i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_MOTION_ESTIMATOR_SIZE: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(21i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_COUNT: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(22i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMANDS: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(23i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(24i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_PARAMETERS: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(25i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_SUPPORT: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(26i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_SIZE: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(27i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_DECODE_PROTECTED_RESOURCES: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(28i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_PROCESS_PROTECTED_RESOURCES: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(29i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(30i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_DECODER_HEAP_SIZE1: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(31i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_PROCESSOR_SIZE1: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_ENCODER_CODEC: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(33i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_ENCODER_PROFILE_LEVEL: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(34i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_ENCODER_OUTPUT_RESOLUTION_RATIOS_COUNT: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(35i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_ENCODER_OUTPUT_RESOLUTION: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(36i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_ENCODER_INPUT_FORMAT: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(37i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_ENCODER_RATE_CONTROL_MODE: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(38i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_ENCODER_INTRA_REFRESH_MODE: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(39i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(40i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_ENCODER_HEAP_SIZE: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(41i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(42i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_ENCODER_SUPPORT: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(43i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(44i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_FEATURE_VIDEO_ENCODER_RESOURCE_REQUIREMENTS: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(45i32);
impl ::core::marker::Copy for D3D12_FEATURE_VIDEO {}
impl ::core::clone::Clone for D3D12_FEATURE_VIDEO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_FEATURE_VIDEO {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_VIDEO {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_FEATURE_VIDEO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_FEATURE_VIDEO").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_DECODE_ARGUMENT_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_ARGUMENT_TYPE_PICTURE_PARAMETERS: D3D12_VIDEO_DECODE_ARGUMENT_TYPE = D3D12_VIDEO_DECODE_ARGUMENT_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_ARGUMENT_TYPE_INVERSE_QUANTIZATION_MATRIX: D3D12_VIDEO_DECODE_ARGUMENT_TYPE = D3D12_VIDEO_DECODE_ARGUMENT_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_ARGUMENT_TYPE_SLICE_CONTROL: D3D12_VIDEO_DECODE_ARGUMENT_TYPE = D3D12_VIDEO_DECODE_ARGUMENT_TYPE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_ARGUMENT_TYPE_MAX_VALID: D3D12_VIDEO_DECODE_ARGUMENT_TYPE = D3D12_VIDEO_DECODE_ARGUMENT_TYPE(3i32);
impl ::core::marker::Copy for D3D12_VIDEO_DECODE_ARGUMENT_TYPE {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_ARGUMENT_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_DECODE_ARGUMENT_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_ARGUMENT_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_ARGUMENT_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_DECODE_ARGUMENT_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_NONE: D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS = D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_HEIGHT_ALIGNMENT_MULTIPLE_32_REQUIRED: D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS = D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_POST_PROCESSING_SUPPORTED: D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS = D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_REFERENCE_ONLY_ALLOCATIONS_REQUIRED: D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS = D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_ALLOW_RESOLUTION_CHANGE_ON_NON_KEY_FRAME: D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS = D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS(8i32);
impl ::core::marker::Copy for D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAG_NONE: D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS = D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAG_SUPPORTED: D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS = D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_Y: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_U: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_V: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_R: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_G: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_B: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_A: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT(3i32);
impl ::core::marker::Copy for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_NONE: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_Y: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_U: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_V: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_R: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_G: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_B: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_A: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS(8i32);
impl ::core::marker::Copy for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_DECODE_STATUS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_STATUS_OK: D3D12_VIDEO_DECODE_STATUS = D3D12_VIDEO_DECODE_STATUS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_STATUS_CONTINUE: D3D12_VIDEO_DECODE_STATUS = D3D12_VIDEO_DECODE_STATUS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_STATUS_CONTINUE_SKIP_DISPLAY: D3D12_VIDEO_DECODE_STATUS = D3D12_VIDEO_DECODE_STATUS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_STATUS_RESTART: D3D12_VIDEO_DECODE_STATUS = D3D12_VIDEO_DECODE_STATUS(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_STATUS_RATE_EXCEEDED: D3D12_VIDEO_DECODE_STATUS = D3D12_VIDEO_DECODE_STATUS(4i32);
impl ::core::marker::Copy for D3D12_VIDEO_DECODE_STATUS {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_STATUS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_DECODE_STATUS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_STATUS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_STATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_DECODE_STATUS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_DECODE_SUPPORT_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_SUPPORT_FLAG_NONE: D3D12_VIDEO_DECODE_SUPPORT_FLAGS = D3D12_VIDEO_DECODE_SUPPORT_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_SUPPORT_FLAG_SUPPORTED: D3D12_VIDEO_DECODE_SUPPORT_FLAGS = D3D12_VIDEO_DECODE_SUPPORT_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_DECODE_SUPPORT_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_SUPPORT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_DECODE_SUPPORT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_SUPPORT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_SUPPORT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_DECODE_SUPPORT_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_DECODE_SUPPORT_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_DECODE_SUPPORT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_DECODE_SUPPORT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_DECODE_SUPPORT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_DECODE_SUPPORT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_DECODE_SUPPORT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_DECODE_TIER(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_TIER_NOT_SUPPORTED: D3D12_VIDEO_DECODE_TIER = D3D12_VIDEO_DECODE_TIER(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_TIER_1: D3D12_VIDEO_DECODE_TIER = D3D12_VIDEO_DECODE_TIER(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_TIER_2: D3D12_VIDEO_DECODE_TIER = D3D12_VIDEO_DECODE_TIER(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_DECODE_TIER_3: D3D12_VIDEO_DECODE_TIER = D3D12_VIDEO_DECODE_TIER(3i32);
impl ::core::marker::Copy for D3D12_VIDEO_DECODE_TIER {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_TIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_DECODE_TIER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_TIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_TIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_DECODE_TIER").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_CODEC(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_H264: D3D12_VIDEO_ENCODER_CODEC = D3D12_VIDEO_ENCODER_CODEC(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_HEVC: D3D12_VIDEO_ENCODER_CODEC = D3D12_VIDEO_ENCODER_CODEC(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_CODEC").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES_DISABLED: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES_TEMPORAL: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES_SPATIAL: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES(2i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAG_NONE: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAG_USE_CONSTRAINED_INTRAPREDICTION: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAG_USE_ADAPTIVE_8x8_TRANSFORM: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAG_ENABLE_CABAC_ENCODING: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAG_ALLOW_REQUEST_INTRA_CONSTRAINED_SLICES: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS(8i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_0_ALL_LUMA_CHROMA_SLICE_BLOCK_EDGES_ALWAYS_FILTERED: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_1_DISABLE_ALL_SLICE_BLOCK_EDGES: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_2_DISABLE_SLICE_BOUNDARIES_BLOCKS: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_3_USE_TWO_STAGE_DEBLOCKING: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_4_DISABLE_CHROMA_BLOCK_EDGES: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_5_DISABLE_CHROMA_BLOCK_EDGES_AND_LUMA_BOUNDARIES: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_6_DISABLE_CHROMA_BLOCK_EDGES_AND_USE_LUMA_TWO_STAGE_DEBLOCKING: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES(6i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_NONE: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_0_ALL_LUMA_CHROMA_SLICE_BLOCK_EDGES_ALWAYS_FILTERED: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_1_DISABLE_ALL_SLICE_BLOCK_EDGES: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_2_DISABLE_SLICE_BOUNDARIES_BLOCKS: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_3_USE_TWO_STAGE_DEBLOCKING: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_4_DISABLE_CHROMA_BLOCK_EDGES: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_5_DISABLE_CHROMA_BLOCK_EDGES_AND_LUMA_BOUNDARIES: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_6_DISABLE_CHROMA_BLOCK_EDGES_AND_USE_LUMA_TWO_STAGE_DEBLOCKING: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS(64i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE_8x8: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE_16x16: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE_32x32: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE_64x64: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE(3i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_NONE: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_DISABLE_LOOP_FILTER_ACROSS_SLICES: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_ALLOW_REQUEST_INTRA_CONSTRAINED_SLICES: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_ENABLE_SAO_FILTER: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_ENABLE_LONG_TERM_REFERENCES: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_USE_ASYMETRIC_MOTION_PARTITION: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_ENABLE_TRANSFORM_SKIPPING: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_USE_CONSTRAINED_INTRAPREDICTION: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS(64i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE_4x4: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE_8x8: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE_16x16: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE_32x32: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE(3i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_NONE: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_CABAC_ENCODING_SUPPORT: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_INTRA_SLICE_CONSTRAINED_ENCODING_SUPPORT: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_BFRAME_LTR_COMBINED_SUPPORT: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_ADAPTIVE_8x8_TRANSFORM_ENCODING_SUPPORT: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_DIRECT_SPATIAL_ENCODING_SUPPORT: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_DIRECT_TEMPORAL_ENCODING_SUPPORT: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_CONSTRAINED_INTRAPREDICTION_SUPPORT: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS(64i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_NONE: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_BFRAME_LTR_COMBINED_SUPPORT: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_INTRA_SLICE_CONSTRAINED_ENCODING_SUPPORT: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_CONSTRAINED_INTRAPREDICTION_SUPPORT: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_SAO_FILTER_SUPPORT: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_ASYMETRIC_MOTION_PARTITION_SUPPORT: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_ASYMETRIC_MOTION_PARTITION_REQUIRED: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_TRANSFORM_SKIP_SUPPORT: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS(64i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_DISABLING_LOOP_FILTER_ACROSS_SLICES_SUPPORT: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS(128i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_P_FRAMES_IMPLEMENTED_AS_LOW_DELAY_B_FRAMES: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS(256i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAG_NO_ERROR: D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS = D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAG_CODEC_PICTURE_CONTROL_NOT_SUPPORTED: D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS = D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAG_SUBREGION_LAYOUT_CONFIGURATION_NOT_SUPPORTED: D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS = D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAG_INVALID_REFERENCE_PICTURES: D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS = D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAG_RECONFIGURATION_REQUEST_NOT_SUPPORTED: D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS = D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAG_INVALID_METADATA_BUFFER_SOURCE: D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS = D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS(16i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_FLAG_NONE: D3D12_VIDEO_ENCODER_FLAGS = D3D12_VIDEO_ENCODER_FLAGS(0i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_ENCODER_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_FULL_FRAME: D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE = D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_BYTES_PER_SUBREGION: D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE = D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_SQUARE_UNITS_PER_SUBREGION_ROW_UNALIGNED: D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE = D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_UNIFORM_PARTITIONING_ROWS_PER_SUBREGION: D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE = D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_UNIFORM_PARTITIONING_SUBREGIONS_PER_FRAME: D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE = D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE(4i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_FRAME_TYPE_H264(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_H264_I_FRAME: D3D12_VIDEO_ENCODER_FRAME_TYPE_H264 = D3D12_VIDEO_ENCODER_FRAME_TYPE_H264(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_H264_P_FRAME: D3D12_VIDEO_ENCODER_FRAME_TYPE_H264 = D3D12_VIDEO_ENCODER_FRAME_TYPE_H264(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_H264_B_FRAME: D3D12_VIDEO_ENCODER_FRAME_TYPE_H264 = D3D12_VIDEO_ENCODER_FRAME_TYPE_H264(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_H264_IDR_FRAME: D3D12_VIDEO_ENCODER_FRAME_TYPE_H264 = D3D12_VIDEO_ENCODER_FRAME_TYPE_H264(3i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_FRAME_TYPE_H264 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_FRAME_TYPE_H264 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_FRAME_TYPE_H264 {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_FRAME_TYPE_H264 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_FRAME_TYPE_H264 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_FRAME_TYPE_H264").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC_I_FRAME: D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC = D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC_P_FRAME: D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC = D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC_B_FRAME: D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC = D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC_IDR_FRAME: D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC = D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC(3i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_HEAP_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_HEAP_FLAG_NONE: D3D12_VIDEO_ENCODER_HEAP_FLAGS = D3D12_VIDEO_ENCODER_HEAP_FLAGS(0i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_HEAP_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_HEAP_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_HEAP_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_HEAP_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_HEAP_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_HEAP_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_ENCODER_HEAP_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_HEAP_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_HEAP_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_HEAP_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_HEAP_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_HEAP_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE_NONE: D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE = D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE_ROW_BASED: D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE = D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_LEVELS_H264(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_1: D3D12_VIDEO_ENCODER_LEVELS_H264 = D3D12_VIDEO_ENCODER_LEVELS_H264(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_1b: D3D12_VIDEO_ENCODER_LEVELS_H264 = D3D12_VIDEO_ENCODER_LEVELS_H264(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_11: D3D12_VIDEO_ENCODER_LEVELS_H264 = D3D12_VIDEO_ENCODER_LEVELS_H264(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_12: D3D12_VIDEO_ENCODER_LEVELS_H264 = D3D12_VIDEO_ENCODER_LEVELS_H264(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_13: D3D12_VIDEO_ENCODER_LEVELS_H264 = D3D12_VIDEO_ENCODER_LEVELS_H264(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_2: D3D12_VIDEO_ENCODER_LEVELS_H264 = D3D12_VIDEO_ENCODER_LEVELS_H264(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_21: D3D12_VIDEO_ENCODER_LEVELS_H264 = D3D12_VIDEO_ENCODER_LEVELS_H264(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_22: D3D12_VIDEO_ENCODER_LEVELS_H264 = D3D12_VIDEO_ENCODER_LEVELS_H264(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_3: D3D12_VIDEO_ENCODER_LEVELS_H264 = D3D12_VIDEO_ENCODER_LEVELS_H264(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_31: D3D12_VIDEO_ENCODER_LEVELS_H264 = D3D12_VIDEO_ENCODER_LEVELS_H264(9i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_32: D3D12_VIDEO_ENCODER_LEVELS_H264 = D3D12_VIDEO_ENCODER_LEVELS_H264(10i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_4: D3D12_VIDEO_ENCODER_LEVELS_H264 = D3D12_VIDEO_ENCODER_LEVELS_H264(11i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_41: D3D12_VIDEO_ENCODER_LEVELS_H264 = D3D12_VIDEO_ENCODER_LEVELS_H264(12i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_42: D3D12_VIDEO_ENCODER_LEVELS_H264 = D3D12_VIDEO_ENCODER_LEVELS_H264(13i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_5: D3D12_VIDEO_ENCODER_LEVELS_H264 = D3D12_VIDEO_ENCODER_LEVELS_H264(14i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_51: D3D12_VIDEO_ENCODER_LEVELS_H264 = D3D12_VIDEO_ENCODER_LEVELS_H264(15i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_52: D3D12_VIDEO_ENCODER_LEVELS_H264 = D3D12_VIDEO_ENCODER_LEVELS_H264(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_6: D3D12_VIDEO_ENCODER_LEVELS_H264 = D3D12_VIDEO_ENCODER_LEVELS_H264(17i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_61: D3D12_VIDEO_ENCODER_LEVELS_H264 = D3D12_VIDEO_ENCODER_LEVELS_H264(18i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_62: D3D12_VIDEO_ENCODER_LEVELS_H264 = D3D12_VIDEO_ENCODER_LEVELS_H264(19i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_LEVELS_H264 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_LEVELS_H264 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_LEVELS_H264 {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_LEVELS_H264 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_LEVELS_H264 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_LEVELS_H264").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_LEVELS_HEVC(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_1: D3D12_VIDEO_ENCODER_LEVELS_HEVC = D3D12_VIDEO_ENCODER_LEVELS_HEVC(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_2: D3D12_VIDEO_ENCODER_LEVELS_HEVC = D3D12_VIDEO_ENCODER_LEVELS_HEVC(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_21: D3D12_VIDEO_ENCODER_LEVELS_HEVC = D3D12_VIDEO_ENCODER_LEVELS_HEVC(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_3: D3D12_VIDEO_ENCODER_LEVELS_HEVC = D3D12_VIDEO_ENCODER_LEVELS_HEVC(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_31: D3D12_VIDEO_ENCODER_LEVELS_HEVC = D3D12_VIDEO_ENCODER_LEVELS_HEVC(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_4: D3D12_VIDEO_ENCODER_LEVELS_HEVC = D3D12_VIDEO_ENCODER_LEVELS_HEVC(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_41: D3D12_VIDEO_ENCODER_LEVELS_HEVC = D3D12_VIDEO_ENCODER_LEVELS_HEVC(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_5: D3D12_VIDEO_ENCODER_LEVELS_HEVC = D3D12_VIDEO_ENCODER_LEVELS_HEVC(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_51: D3D12_VIDEO_ENCODER_LEVELS_HEVC = D3D12_VIDEO_ENCODER_LEVELS_HEVC(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_52: D3D12_VIDEO_ENCODER_LEVELS_HEVC = D3D12_VIDEO_ENCODER_LEVELS_HEVC(9i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_6: D3D12_VIDEO_ENCODER_LEVELS_HEVC = D3D12_VIDEO_ENCODER_LEVELS_HEVC(10i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_61: D3D12_VIDEO_ENCODER_LEVELS_HEVC = D3D12_VIDEO_ENCODER_LEVELS_HEVC(11i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_62: D3D12_VIDEO_ENCODER_LEVELS_HEVC = D3D12_VIDEO_ENCODER_LEVELS_HEVC(12i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_LEVELS_HEVC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_LEVELS_HEVC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_LEVELS_HEVC {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_LEVELS_HEVC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_LEVELS_HEVC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_LEVELS_HEVC").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE_MAXIMUM: D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE = D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE_FULL_PIXEL: D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE = D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE_HALF_PIXEL: D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE = D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE_QUARTER_PIXEL: D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE = D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE(3i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAG_NONE: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS = D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAG_REQUEST_INTRA_CONSTRAINED_SLICES: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS = D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAG_NONE: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS = D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAG_REQUEST_INTRA_CONSTRAINED_SLICES: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS = D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAG_NONE: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAG_USED_AS_REFERENCE_PICTURE: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_PROFILE_H264(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_PROFILE_H264_MAIN: D3D12_VIDEO_ENCODER_PROFILE_H264 = D3D12_VIDEO_ENCODER_PROFILE_H264(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_PROFILE_H264_HIGH: D3D12_VIDEO_ENCODER_PROFILE_H264 = D3D12_VIDEO_ENCODER_PROFILE_H264(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_PROFILE_H264_HIGH_10: D3D12_VIDEO_ENCODER_PROFILE_H264 = D3D12_VIDEO_ENCODER_PROFILE_H264(2i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PROFILE_H264 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PROFILE_H264 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PROFILE_H264 {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PROFILE_H264 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_PROFILE_H264 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_PROFILE_H264").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_PROFILE_HEVC(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_PROFILE_HEVC_MAIN: D3D12_VIDEO_ENCODER_PROFILE_HEVC = D3D12_VIDEO_ENCODER_PROFILE_HEVC(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_PROFILE_HEVC_MAIN10: D3D12_VIDEO_ENCODER_PROFILE_HEVC = D3D12_VIDEO_ENCODER_PROFILE_HEVC(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PROFILE_HEVC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PROFILE_HEVC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PROFILE_HEVC {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PROFILE_HEVC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_PROFILE_HEVC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_PROFILE_HEVC").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAG_NONE: D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAG_ENABLE_DELTA_QP: D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAG_ENABLE_FRAME_ANALYSIS: D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAG_ENABLE_QP_RANGE: D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAG_ENABLE_INITIAL_QP: D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAG_ENABLE_MAX_FRAME_SIZE: D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAG_ENABLE_VBV_SIZES: D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS(32i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE_ABSOLUTE_QP_MAP: D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE = D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE_CQP: D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE = D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE_CBR: D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE = D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE_VBR: D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE = D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE_QVBR: D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE = D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE(4i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAG_NONE: D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAG_RESOLUTION_CHANGE: D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAG_RATE_CONTROL_CHANGE: D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAG_SUBREGION_LAYOUT_CHANGE: D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAG_REQUEST_INTRA_REFRESH: D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAG_GOP_SEQUENCE_CHANGE: D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS(16i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_NONE: D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_GENERAL_SUPPORT_OK: D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RATE_CONTROL_RECONFIGURATION_AVAILABLE: D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RESOLUTION_RECONFIGURATION_AVAILABLE: D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RATE_CONTROL_VBV_SIZE_CONFIG_AVAILABLE: D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RATE_CONTROL_FRAME_ANALYSIS_AVAILABLE: D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RECONSTRUCTED_FRAMES_REQUIRE_TEXTURE_ARRAYS: D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RATE_CONTROL_DELTA_QP_AVAILABLE: D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(64i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_SUBREGION_LAYOUT_RECONFIGURATION_AVAILABLE: D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(128i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RATE_CONTROL_ADJUSTABLE_QP_RANGE_AVAILABLE: D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(256i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RATE_CONTROL_INITIAL_QP_AVAILABLE: D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(512i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RATE_CONTROL_MAX_FRAME_SIZE_AVAILABLE: D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(1024i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_SEQUENCE_GOP_RECONFIGURATION_AVAILABLE: D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(2048i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_MOTION_ESTIMATION_PRECISION_MODE_LIMIT_AVAILABLE: D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(4096i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_SUPPORT_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_SUPPORT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_SUPPORT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_SUPPORT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_SUPPORT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_SUPPORT_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_ENCODER_SUPPORT_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_SUPPORT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_SUPPORT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_SUPPORT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_SUPPORT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_SUPPORT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_TIER_HEVC(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_TIER_HEVC_MAIN: D3D12_VIDEO_ENCODER_TIER_HEVC = D3D12_VIDEO_ENCODER_TIER_HEVC(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_TIER_HEVC_HIGH: D3D12_VIDEO_ENCODER_TIER_HEVC = D3D12_VIDEO_ENCODER_TIER_HEVC(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_TIER_HEVC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_TIER_HEVC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_TIER_HEVC {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_TIER_HEVC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_TIER_HEVC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_TIER_HEVC").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_VALIDATION_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_NONE: D3D12_VIDEO_ENCODER_VALIDATION_FLAGS = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_CODEC_NOT_SUPPORTED: D3D12_VIDEO_ENCODER_VALIDATION_FLAGS = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_INPUT_FORMAT_NOT_SUPPORTED: D3D12_VIDEO_ENCODER_VALIDATION_FLAGS = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_CODEC_CONFIGURATION_NOT_SUPPORTED: D3D12_VIDEO_ENCODER_VALIDATION_FLAGS = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_RATE_CONTROL_MODE_NOT_SUPPORTED: D3D12_VIDEO_ENCODER_VALIDATION_FLAGS = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_RATE_CONTROL_CONFIGURATION_NOT_SUPPORTED: D3D12_VIDEO_ENCODER_VALIDATION_FLAGS = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS(64i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_INTRA_REFRESH_MODE_NOT_SUPPORTED: D3D12_VIDEO_ENCODER_VALIDATION_FLAGS = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS(128i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_SUBREGION_LAYOUT_MODE_NOT_SUPPORTED: D3D12_VIDEO_ENCODER_VALIDATION_FLAGS = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS(256i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_RESOLUTION_NOT_SUPPORTED_IN_LIST: D3D12_VIDEO_ENCODER_VALIDATION_FLAGS = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS(512i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_GOP_STRUCTURE_NOT_SUPPORTED: D3D12_VIDEO_ENCODER_VALIDATION_FLAGS = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS(2048i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_VALIDATION_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_VALIDATION_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_VALIDATION_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_VALIDATION_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_VALIDATION_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_VALIDATION_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_ENCODER_VALIDATION_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_VALIDATION_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_VALIDATION_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_VALIDATION_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_VALIDATION_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_VALIDATION_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAG_NONE: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAG_READ: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAG_WRITE: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS(2i32);
impl ::core::marker::Copy for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_CREATION: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_INITIALIZATION: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_EXECUTION: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_CAPS_INPUT: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_CAPS_OUTPUT: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_DEVICE_EXECUTE_INPUT: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_DEVICE_EXECUTE_OUTPUT: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE(6i32);
impl ::core::marker::Copy for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE {}
impl ::core::clone::Clone for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_UINT8: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_UINT16: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_UINT32: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_UINT64: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_SINT8: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_SINT16: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_SINT32: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_SINT64: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_FLOAT: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_DOUBLE: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(9i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_RESOURCE: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(10i32);
impl ::core::marker::Copy for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE {}
impl ::core::clone::Clone for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_FIELD_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_FIELD_TYPE_NONE: D3D12_VIDEO_FIELD_TYPE = D3D12_VIDEO_FIELD_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_FIELD_TYPE_INTERLACED_TOP_FIELD_FIRST: D3D12_VIDEO_FIELD_TYPE = D3D12_VIDEO_FIELD_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_FIELD_TYPE_INTERLACED_BOTTOM_FIELD_FIRST: D3D12_VIDEO_FIELD_TYPE = D3D12_VIDEO_FIELD_TYPE(2i32);
impl ::core::marker::Copy for D3D12_VIDEO_FIELD_TYPE {}
impl ::core::clone::Clone for D3D12_VIDEO_FIELD_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_FIELD_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_FIELD_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_FIELD_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_FIELD_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE_NONE: D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE = D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE_FIELD_BASED: D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE = D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE {}
impl ::core::clone::Clone for D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_FRAME_STEREO_FORMAT(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_FRAME_STEREO_FORMAT_NONE: D3D12_VIDEO_FRAME_STEREO_FORMAT = D3D12_VIDEO_FRAME_STEREO_FORMAT(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_FRAME_STEREO_FORMAT_MONO: D3D12_VIDEO_FRAME_STEREO_FORMAT = D3D12_VIDEO_FRAME_STEREO_FORMAT(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_FRAME_STEREO_FORMAT_HORIZONTAL: D3D12_VIDEO_FRAME_STEREO_FORMAT = D3D12_VIDEO_FRAME_STEREO_FORMAT(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_FRAME_STEREO_FORMAT_VERTICAL: D3D12_VIDEO_FRAME_STEREO_FORMAT = D3D12_VIDEO_FRAME_STEREO_FORMAT(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_FRAME_STEREO_FORMAT_SEPARATE: D3D12_VIDEO_FRAME_STEREO_FORMAT = D3D12_VIDEO_FRAME_STEREO_FORMAT(4i32);
impl ::core::marker::Copy for D3D12_VIDEO_FRAME_STEREO_FORMAT {}
impl ::core::clone::Clone for D3D12_VIDEO_FRAME_STEREO_FORMAT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_FRAME_STEREO_FORMAT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_FRAME_STEREO_FORMAT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_FRAME_STEREO_FORMAT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_FRAME_STEREO_FORMAT").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_8X8: D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE = D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_16X16: D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE = D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE {}
impl ::core::clone::Clone for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAG_NONE: D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS = D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAG_8X8: D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS = D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAG_16X16: D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS = D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS(2i32);
impl ::core::marker::Copy for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_QUARTER_PEL: D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION = D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION(0i32);
impl ::core::marker::Copy for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION {}
impl ::core::clone::Clone for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAG_NONE: D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS = D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAG_QUARTER_PEL: D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS = D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_OPAQUE: D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE = D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_BACKGROUND: D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE = D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_DESTINATION: D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE = D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_SOURCE_STREAM: D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE = D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE(3i32);
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS(pub u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_NONE: D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS(0u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_DENOISE: D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS(1u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_DERINGING: D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS(2u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_EDGE_ENHANCEMENT: D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS(4u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_COLOR_CORRECTION: D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS(8u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_FLESH_TONE_MAPPING: D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS(16u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_IMAGE_STABILIZATION: D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS(32u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_SUPER_RESOLUTION: D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS(64u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_ANAMORPHIC_SCALING: D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS(128u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_CUSTOM: D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS(2147483648u32);
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS(pub u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_NONE: D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS = D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS(0u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_BOB: D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS = D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS(1u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_CUSTOM: D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS = D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS(2147483648u32);
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_PROCESS_FEATURE_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_NONE: D3D12_VIDEO_PROCESS_FEATURE_FLAGS = D3D12_VIDEO_PROCESS_FEATURE_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_ALPHA_FILL: D3D12_VIDEO_PROCESS_FEATURE_FLAGS = D3D12_VIDEO_PROCESS_FEATURE_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_LUMA_KEY: D3D12_VIDEO_PROCESS_FEATURE_FLAGS = D3D12_VIDEO_PROCESS_FEATURE_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_STEREO: D3D12_VIDEO_PROCESS_FEATURE_FLAGS = D3D12_VIDEO_PROCESS_FEATURE_FLAGS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_ROTATION: D3D12_VIDEO_PROCESS_FEATURE_FLAGS = D3D12_VIDEO_PROCESS_FEATURE_FLAGS(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_FLIP: D3D12_VIDEO_PROCESS_FEATURE_FLAGS = D3D12_VIDEO_PROCESS_FEATURE_FLAGS(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_ALPHA_BLENDING: D3D12_VIDEO_PROCESS_FEATURE_FLAGS = D3D12_VIDEO_PROCESS_FEATURE_FLAGS(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_PIXEL_ASPECT_RATIO: D3D12_VIDEO_PROCESS_FEATURE_FLAGS = D3D12_VIDEO_PROCESS_FEATURE_FLAGS(64i32);
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_FEATURE_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_FEATURE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_FEATURE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_FEATURE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_FEATURE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_PROCESS_FEATURE_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_PROCESS_FEATURE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_PROCESS_FEATURE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_PROCESS_FEATURE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_PROCESS_FEATURE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_PROCESS_FEATURE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_PROCESS_FEATURE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_PROCESS_FILTER(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FILTER_BRIGHTNESS: D3D12_VIDEO_PROCESS_FILTER = D3D12_VIDEO_PROCESS_FILTER(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FILTER_CONTRAST: D3D12_VIDEO_PROCESS_FILTER = D3D12_VIDEO_PROCESS_FILTER(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FILTER_HUE: D3D12_VIDEO_PROCESS_FILTER = D3D12_VIDEO_PROCESS_FILTER(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FILTER_SATURATION: D3D12_VIDEO_PROCESS_FILTER = D3D12_VIDEO_PROCESS_FILTER(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FILTER_NOISE_REDUCTION: D3D12_VIDEO_PROCESS_FILTER = D3D12_VIDEO_PROCESS_FILTER(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FILTER_EDGE_ENHANCEMENT: D3D12_VIDEO_PROCESS_FILTER = D3D12_VIDEO_PROCESS_FILTER(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FILTER_ANAMORPHIC_SCALING: D3D12_VIDEO_PROCESS_FILTER = D3D12_VIDEO_PROCESS_FILTER(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FILTER_STEREO_ADJUSTMENT: D3D12_VIDEO_PROCESS_FILTER = D3D12_VIDEO_PROCESS_FILTER(7i32);
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_FILTER {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_FILTER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_FILTER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_FILTER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_FILTER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_PROCESS_FILTER").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_PROCESS_FILTER_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_NONE: D3D12_VIDEO_PROCESS_FILTER_FLAGS = D3D12_VIDEO_PROCESS_FILTER_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_BRIGHTNESS: D3D12_VIDEO_PROCESS_FILTER_FLAGS = D3D12_VIDEO_PROCESS_FILTER_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_CONTRAST: D3D12_VIDEO_PROCESS_FILTER_FLAGS = D3D12_VIDEO_PROCESS_FILTER_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_HUE: D3D12_VIDEO_PROCESS_FILTER_FLAGS = D3D12_VIDEO_PROCESS_FILTER_FLAGS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_SATURATION: D3D12_VIDEO_PROCESS_FILTER_FLAGS = D3D12_VIDEO_PROCESS_FILTER_FLAGS(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_NOISE_REDUCTION: D3D12_VIDEO_PROCESS_FILTER_FLAGS = D3D12_VIDEO_PROCESS_FILTER_FLAGS(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_EDGE_ENHANCEMENT: D3D12_VIDEO_PROCESS_FILTER_FLAGS = D3D12_VIDEO_PROCESS_FILTER_FLAGS(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_ANAMORPHIC_SCALING: D3D12_VIDEO_PROCESS_FILTER_FLAGS = D3D12_VIDEO_PROCESS_FILTER_FLAGS(64i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_STEREO_ADJUSTMENT: D3D12_VIDEO_PROCESS_FILTER_FLAGS = D3D12_VIDEO_PROCESS_FILTER_FLAGS(128i32);
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_FILTER_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_FILTER_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_FILTER_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_FILTER_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_FILTER_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_PROCESS_FILTER_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_PROCESS_FILTER_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_PROCESS_FILTER_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_PROCESS_FILTER_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_PROCESS_FILTER_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_PROCESS_FILTER_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_PROCESS_FILTER_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAG_NONE: D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS = D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAG_FRAME_DISCONTINUITY: D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS = D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAG_FRAME_REPEAT: D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS = D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS(2i32);
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_PROCESS_ORIENTATION(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_ORIENTATION_DEFAULT: D3D12_VIDEO_PROCESS_ORIENTATION = D3D12_VIDEO_PROCESS_ORIENTATION(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_ORIENTATION_FLIP_HORIZONTAL: D3D12_VIDEO_PROCESS_ORIENTATION = D3D12_VIDEO_PROCESS_ORIENTATION(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_90: D3D12_VIDEO_PROCESS_ORIENTATION = D3D12_VIDEO_PROCESS_ORIENTATION(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_90_FLIP_HORIZONTAL: D3D12_VIDEO_PROCESS_ORIENTATION = D3D12_VIDEO_PROCESS_ORIENTATION(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_180: D3D12_VIDEO_PROCESS_ORIENTATION = D3D12_VIDEO_PROCESS_ORIENTATION(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_ORIENTATION_FLIP_VERTICAL: D3D12_VIDEO_PROCESS_ORIENTATION = D3D12_VIDEO_PROCESS_ORIENTATION(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_270: D3D12_VIDEO_PROCESS_ORIENTATION = D3D12_VIDEO_PROCESS_ORIENTATION(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_270_FLIP_HORIZONTAL: D3D12_VIDEO_PROCESS_ORIENTATION = D3D12_VIDEO_PROCESS_ORIENTATION(7i32);
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_ORIENTATION {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_ORIENTATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_ORIENTATION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_ORIENTATION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_ORIENTATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_PROCESS_ORIENTATION").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_PROCESS_SUPPORT_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_SUPPORT_FLAG_NONE: D3D12_VIDEO_PROCESS_SUPPORT_FLAGS = D3D12_VIDEO_PROCESS_SUPPORT_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROCESS_SUPPORT_FLAG_SUPPORTED: D3D12_VIDEO_PROCESS_SUPPORT_FLAGS = D3D12_VIDEO_PROCESS_SUPPORT_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_SUPPORT_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_SUPPORT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_SUPPORT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_SUPPORT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_SUPPORT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_PROCESS_SUPPORT_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_PROCESS_SUPPORT_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_PROCESS_SUPPORT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_PROCESS_SUPPORT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_PROCESS_SUPPORT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_PROCESS_SUPPORT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_PROCESS_SUPPORT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAG_NONE: D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS = D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAG_SUPPORTED: D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS = D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_SCALE_SUPPORT_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_SCALE_SUPPORT_FLAG_NONE: D3D12_VIDEO_SCALE_SUPPORT_FLAGS = D3D12_VIDEO_SCALE_SUPPORT_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_SCALE_SUPPORT_FLAG_POW2_ONLY: D3D12_VIDEO_SCALE_SUPPORT_FLAGS = D3D12_VIDEO_SCALE_SUPPORT_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const D3D12_VIDEO_SCALE_SUPPORT_FLAG_EVEN_DIMENSIONS_ONLY: D3D12_VIDEO_SCALE_SUPPORT_FLAGS = D3D12_VIDEO_SCALE_SUPPORT_FLAGS(2i32);
impl ::core::marker::Copy for D3D12_VIDEO_SCALE_SUPPORT_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_SCALE_SUPPORT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_SCALE_SUPPORT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_SCALE_SUPPORT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_SCALE_SUPPORT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_SCALE_SUPPORT_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_VIDEO_SCALE_SUPPORT_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_SCALE_SUPPORT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_SCALE_SUPPORT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_SCALE_SUPPORT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_SCALE_SUPPORT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_SCALE_SUPPORT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA2_BufferfType(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_PictureParametersBufferType: DXVA2_BufferfType = DXVA2_BufferfType(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_MacroBlockControlBufferType: DXVA2_BufferfType = DXVA2_BufferfType(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ResidualDifferenceBufferType: DXVA2_BufferfType = DXVA2_BufferfType(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DeblockingControlBufferType: DXVA2_BufferfType = DXVA2_BufferfType(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_InverseQuantizationMatrixBufferType: DXVA2_BufferfType = DXVA2_BufferfType(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_SliceControlBufferType: DXVA2_BufferfType = DXVA2_BufferfType(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_BitStreamDateBufferType: DXVA2_BufferfType = DXVA2_BufferfType(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_MotionVectorBuffer: DXVA2_BufferfType = DXVA2_BufferfType(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_FilmGrainBuffer: DXVA2_BufferfType = DXVA2_BufferfType(8i32);
impl ::core::marker::Copy for DXVA2_BufferfType {}
impl ::core::clone::Clone for DXVA2_BufferfType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA2_BufferfType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA2_BufferfType {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA2_BufferfType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA2_BufferfType").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA2_DeinterlaceTech(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DeinterlaceTech_Unknown: DXVA2_DeinterlaceTech = DXVA2_DeinterlaceTech(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DeinterlaceTech_BOBLineReplicate: DXVA2_DeinterlaceTech = DXVA2_DeinterlaceTech(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DeinterlaceTech_BOBVerticalStretch: DXVA2_DeinterlaceTech = DXVA2_DeinterlaceTech(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DeinterlaceTech_BOBVerticalStretch4Tap: DXVA2_DeinterlaceTech = DXVA2_DeinterlaceTech(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DeinterlaceTech_MedianFiltering: DXVA2_DeinterlaceTech = DXVA2_DeinterlaceTech(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DeinterlaceTech_EdgeFiltering: DXVA2_DeinterlaceTech = DXVA2_DeinterlaceTech(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DeinterlaceTech_FieldAdaptive: DXVA2_DeinterlaceTech = DXVA2_DeinterlaceTech(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DeinterlaceTech_PixelAdaptive: DXVA2_DeinterlaceTech = DXVA2_DeinterlaceTech(64i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DeinterlaceTech_MotionVectorSteered: DXVA2_DeinterlaceTech = DXVA2_DeinterlaceTech(128i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DeinterlaceTech_InverseTelecine: DXVA2_DeinterlaceTech = DXVA2_DeinterlaceTech(256i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DeinterlaceTech_Mask: DXVA2_DeinterlaceTech = DXVA2_DeinterlaceTech(511i32);
impl ::core::marker::Copy for DXVA2_DeinterlaceTech {}
impl ::core::clone::Clone for DXVA2_DeinterlaceTech {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA2_DeinterlaceTech {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA2_DeinterlaceTech {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA2_DeinterlaceTech {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA2_DeinterlaceTech").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA2_DestData(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DestData_RFF: DXVA2_DestData = DXVA2_DestData(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DestData_TFF: DXVA2_DestData = DXVA2_DestData(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DestData_RFF_TFF_Present: DXVA2_DestData = DXVA2_DestData(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DestData_Mask: DXVA2_DestData = DXVA2_DestData(65535i32);
impl ::core::marker::Copy for DXVA2_DestData {}
impl ::core::clone::Clone for DXVA2_DestData {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA2_DestData {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA2_DestData {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA2_DestData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA2_DestData").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA2_DetailFilterTech(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DetailFilterTech_Unsupported: DXVA2_DetailFilterTech = DXVA2_DetailFilterTech(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DetailFilterTech_Unknown: DXVA2_DetailFilterTech = DXVA2_DetailFilterTech(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DetailFilterTech_Edge: DXVA2_DetailFilterTech = DXVA2_DetailFilterTech(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DetailFilterTech_Sharpening: DXVA2_DetailFilterTech = DXVA2_DetailFilterTech(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DetailFilterTech_Mask: DXVA2_DetailFilterTech = DXVA2_DetailFilterTech(7i32);
impl ::core::marker::Copy for DXVA2_DetailFilterTech {}
impl ::core::clone::Clone for DXVA2_DetailFilterTech {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA2_DetailFilterTech {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA2_DetailFilterTech {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA2_DetailFilterTech {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA2_DetailFilterTech").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA2_FilterType(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_NoiseFilterLumaLevel: DXVA2_FilterType = DXVA2_FilterType(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_NoiseFilterLumaThreshold: DXVA2_FilterType = DXVA2_FilterType(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_NoiseFilterLumaRadius: DXVA2_FilterType = DXVA2_FilterType(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_NoiseFilterChromaLevel: DXVA2_FilterType = DXVA2_FilterType(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_NoiseFilterChromaThreshold: DXVA2_FilterType = DXVA2_FilterType(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_NoiseFilterChromaRadius: DXVA2_FilterType = DXVA2_FilterType(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DetailFilterLumaLevel: DXVA2_FilterType = DXVA2_FilterType(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DetailFilterLumaThreshold: DXVA2_FilterType = DXVA2_FilterType(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DetailFilterLumaRadius: DXVA2_FilterType = DXVA2_FilterType(9i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DetailFilterChromaLevel: DXVA2_FilterType = DXVA2_FilterType(10i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DetailFilterChromaThreshold: DXVA2_FilterType = DXVA2_FilterType(11i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_DetailFilterChromaRadius: DXVA2_FilterType = DXVA2_FilterType(12i32);
impl ::core::marker::Copy for DXVA2_FilterType {}
impl ::core::clone::Clone for DXVA2_FilterType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA2_FilterType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA2_FilterType {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA2_FilterType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA2_FilterType").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA2_NoiseFilterTech(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_NoiseFilterTech_Unsupported: DXVA2_NoiseFilterTech = DXVA2_NoiseFilterTech(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_NoiseFilterTech_Unknown: DXVA2_NoiseFilterTech = DXVA2_NoiseFilterTech(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_NoiseFilterTech_Median: DXVA2_NoiseFilterTech = DXVA2_NoiseFilterTech(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_NoiseFilterTech_Temporal: DXVA2_NoiseFilterTech = DXVA2_NoiseFilterTech(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_NoiseFilterTech_BlockNoise: DXVA2_NoiseFilterTech = DXVA2_NoiseFilterTech(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_NoiseFilterTech_MosquitoNoise: DXVA2_NoiseFilterTech = DXVA2_NoiseFilterTech(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_NoiseFilterTech_Mask: DXVA2_NoiseFilterTech = DXVA2_NoiseFilterTech(31i32);
impl ::core::marker::Copy for DXVA2_NoiseFilterTech {}
impl ::core::clone::Clone for DXVA2_NoiseFilterTech {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA2_NoiseFilterTech {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA2_NoiseFilterTech {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA2_NoiseFilterTech {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA2_NoiseFilterTech").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA2_NominalRange(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_NominalRangeMask: DXVA2_NominalRange = DXVA2_NominalRange(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_NominalRange_Unknown: DXVA2_NominalRange = DXVA2_NominalRange(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_NominalRange_Normal: DXVA2_NominalRange = DXVA2_NominalRange(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_NominalRange_Wide: DXVA2_NominalRange = DXVA2_NominalRange(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_NominalRange_0_255: DXVA2_NominalRange = DXVA2_NominalRange(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_NominalRange_16_235: DXVA2_NominalRange = DXVA2_NominalRange(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_NominalRange_48_208: DXVA2_NominalRange = DXVA2_NominalRange(3i32);
impl ::core::marker::Copy for DXVA2_NominalRange {}
impl ::core::clone::Clone for DXVA2_NominalRange {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA2_NominalRange {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA2_NominalRange {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA2_NominalRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA2_NominalRange").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA2_ProcAmp(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ProcAmp_None: DXVA2_ProcAmp = DXVA2_ProcAmp(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ProcAmp_Brightness: DXVA2_ProcAmp = DXVA2_ProcAmp(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ProcAmp_Contrast: DXVA2_ProcAmp = DXVA2_ProcAmp(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ProcAmp_Hue: DXVA2_ProcAmp = DXVA2_ProcAmp(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ProcAmp_Saturation: DXVA2_ProcAmp = DXVA2_ProcAmp(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_ProcAmp_Mask: DXVA2_ProcAmp = DXVA2_ProcAmp(15i32);
impl ::core::marker::Copy for DXVA2_ProcAmp {}
impl ::core::clone::Clone for DXVA2_ProcAmp {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA2_ProcAmp {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA2_ProcAmp {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA2_ProcAmp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA2_ProcAmp").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA2_SampleData(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_SampleData_RFF: DXVA2_SampleData = DXVA2_SampleData(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_SampleData_TFF: DXVA2_SampleData = DXVA2_SampleData(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_SampleData_RFF_TFF_Present: DXVA2_SampleData = DXVA2_SampleData(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_SampleData_Mask: DXVA2_SampleData = DXVA2_SampleData(65535i32);
impl ::core::marker::Copy for DXVA2_SampleData {}
impl ::core::clone::Clone for DXVA2_SampleData {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA2_SampleData {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA2_SampleData {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA2_SampleData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA2_SampleData").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA2_SampleFormat(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_SampleFormatMask: DXVA2_SampleFormat = DXVA2_SampleFormat(255i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_SampleUnknown: DXVA2_SampleFormat = DXVA2_SampleFormat(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_SampleProgressiveFrame: DXVA2_SampleFormat = DXVA2_SampleFormat(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_SampleFieldInterleavedEvenFirst: DXVA2_SampleFormat = DXVA2_SampleFormat(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_SampleFieldInterleavedOddFirst: DXVA2_SampleFormat = DXVA2_SampleFormat(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_SampleFieldSingleEven: DXVA2_SampleFormat = DXVA2_SampleFormat(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_SampleFieldSingleOdd: DXVA2_SampleFormat = DXVA2_SampleFormat(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_SampleSubStream: DXVA2_SampleFormat = DXVA2_SampleFormat(7i32);
impl ::core::marker::Copy for DXVA2_SampleFormat {}
impl ::core::clone::Clone for DXVA2_SampleFormat {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA2_SampleFormat {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA2_SampleFormat {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA2_SampleFormat {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA2_SampleFormat").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA2_SurfaceType(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_SurfaceType_DecoderRenderTarget: DXVA2_SurfaceType = DXVA2_SurfaceType(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_SurfaceType_ProcessorRenderTarget: DXVA2_SurfaceType = DXVA2_SurfaceType(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_SurfaceType_D3DRenderTargetTexture: DXVA2_SurfaceType = DXVA2_SurfaceType(2i32);
impl ::core::marker::Copy for DXVA2_SurfaceType {}
impl ::core::clone::Clone for DXVA2_SurfaceType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA2_SurfaceType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA2_SurfaceType {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA2_SurfaceType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA2_SurfaceType").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA2_VPDev(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VPDev_HardwareDevice: DXVA2_VPDev = DXVA2_VPDev(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VPDev_EmulatedDXVA1: DXVA2_VPDev = DXVA2_VPDev(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VPDev_SoftwareDevice: DXVA2_VPDev = DXVA2_VPDev(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VPDev_Mask: DXVA2_VPDev = DXVA2_VPDev(7i32);
impl ::core::marker::Copy for DXVA2_VPDev {}
impl ::core::clone::Clone for DXVA2_VPDev {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA2_VPDev {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA2_VPDev {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA2_VPDev {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA2_VPDev").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA2_VideoChromaSubSampling(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoChromaSubsamplingMask: DXVA2_VideoChromaSubSampling = DXVA2_VideoChromaSubSampling(15i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoChromaSubsampling_Unknown: DXVA2_VideoChromaSubSampling = DXVA2_VideoChromaSubSampling(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoChromaSubsampling_ProgressiveChroma: DXVA2_VideoChromaSubSampling = DXVA2_VideoChromaSubSampling(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoChromaSubsampling_Horizontally_Cosited: DXVA2_VideoChromaSubSampling = DXVA2_VideoChromaSubSampling(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoChromaSubsampling_Vertically_Cosited: DXVA2_VideoChromaSubSampling = DXVA2_VideoChromaSubSampling(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoChromaSubsampling_Vertically_AlignedChromaPlanes: DXVA2_VideoChromaSubSampling = DXVA2_VideoChromaSubSampling(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoChromaSubsampling_MPEG2: DXVA2_VideoChromaSubSampling = DXVA2_VideoChromaSubSampling(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoChromaSubsampling_MPEG1: DXVA2_VideoChromaSubSampling = DXVA2_VideoChromaSubSampling(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoChromaSubsampling_DV_PAL: DXVA2_VideoChromaSubSampling = DXVA2_VideoChromaSubSampling(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoChromaSubsampling_Cosited: DXVA2_VideoChromaSubSampling = DXVA2_VideoChromaSubSampling(7i32);
impl ::core::marker::Copy for DXVA2_VideoChromaSubSampling {}
impl ::core::clone::Clone for DXVA2_VideoChromaSubSampling {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA2_VideoChromaSubSampling {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA2_VideoChromaSubSampling {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA2_VideoChromaSubSampling {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA2_VideoChromaSubSampling").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA2_VideoLighting(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoLightingMask: DXVA2_VideoLighting = DXVA2_VideoLighting(15i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoLighting_Unknown: DXVA2_VideoLighting = DXVA2_VideoLighting(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoLighting_bright: DXVA2_VideoLighting = DXVA2_VideoLighting(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoLighting_office: DXVA2_VideoLighting = DXVA2_VideoLighting(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoLighting_dim: DXVA2_VideoLighting = DXVA2_VideoLighting(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoLighting_dark: DXVA2_VideoLighting = DXVA2_VideoLighting(4i32);
impl ::core::marker::Copy for DXVA2_VideoLighting {}
impl ::core::clone::Clone for DXVA2_VideoLighting {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA2_VideoLighting {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA2_VideoLighting {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA2_VideoLighting {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA2_VideoLighting").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA2_VideoPrimaries(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoPrimariesMask: DXVA2_VideoPrimaries = DXVA2_VideoPrimaries(31i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoPrimaries_Unknown: DXVA2_VideoPrimaries = DXVA2_VideoPrimaries(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoPrimaries_reserved: DXVA2_VideoPrimaries = DXVA2_VideoPrimaries(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoPrimaries_BT709: DXVA2_VideoPrimaries = DXVA2_VideoPrimaries(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoPrimaries_BT470_2_SysM: DXVA2_VideoPrimaries = DXVA2_VideoPrimaries(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoPrimaries_BT470_2_SysBG: DXVA2_VideoPrimaries = DXVA2_VideoPrimaries(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoPrimaries_SMPTE170M: DXVA2_VideoPrimaries = DXVA2_VideoPrimaries(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoPrimaries_SMPTE240M: DXVA2_VideoPrimaries = DXVA2_VideoPrimaries(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoPrimaries_EBU3213: DXVA2_VideoPrimaries = DXVA2_VideoPrimaries(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoPrimaries_SMPTE_C: DXVA2_VideoPrimaries = DXVA2_VideoPrimaries(8i32);
impl ::core::marker::Copy for DXVA2_VideoPrimaries {}
impl ::core::clone::Clone for DXVA2_VideoPrimaries {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA2_VideoPrimaries {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA2_VideoPrimaries {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA2_VideoPrimaries {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA2_VideoPrimaries").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA2_VideoProcess(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoProcess_None: DXVA2_VideoProcess = DXVA2_VideoProcess(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoProcess_YUV2RGB: DXVA2_VideoProcess = DXVA2_VideoProcess(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoProcess_StretchX: DXVA2_VideoProcess = DXVA2_VideoProcess(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoProcess_StretchY: DXVA2_VideoProcess = DXVA2_VideoProcess(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoProcess_AlphaBlend: DXVA2_VideoProcess = DXVA2_VideoProcess(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoProcess_SubRects: DXVA2_VideoProcess = DXVA2_VideoProcess(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoProcess_SubStreams: DXVA2_VideoProcess = DXVA2_VideoProcess(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoProcess_SubStreamsExtended: DXVA2_VideoProcess = DXVA2_VideoProcess(64i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoProcess_YUV2RGBExtended: DXVA2_VideoProcess = DXVA2_VideoProcess(128i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoProcess_AlphaBlendExtended: DXVA2_VideoProcess = DXVA2_VideoProcess(256i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoProcess_Constriction: DXVA2_VideoProcess = DXVA2_VideoProcess(512i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoProcess_NoiseFilter: DXVA2_VideoProcess = DXVA2_VideoProcess(1024i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoProcess_DetailFilter: DXVA2_VideoProcess = DXVA2_VideoProcess(2048i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoProcess_PlanarAlpha: DXVA2_VideoProcess = DXVA2_VideoProcess(4096i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoProcess_LinearScaling: DXVA2_VideoProcess = DXVA2_VideoProcess(8192i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoProcess_GammaCompensated: DXVA2_VideoProcess = DXVA2_VideoProcess(16384i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoProcess_MaintainsOriginalFieldData: DXVA2_VideoProcess = DXVA2_VideoProcess(32768i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoProcess_Mask: DXVA2_VideoProcess = DXVA2_VideoProcess(65535i32);
impl ::core::marker::Copy for DXVA2_VideoProcess {}
impl ::core::clone::Clone for DXVA2_VideoProcess {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA2_VideoProcess {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA2_VideoProcess {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA2_VideoProcess {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA2_VideoProcess").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA2_VideoRenderTargetType(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoDecoderRenderTarget: DXVA2_VideoRenderTargetType = DXVA2_VideoRenderTargetType(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoProcessorRenderTarget: DXVA2_VideoRenderTargetType = DXVA2_VideoRenderTargetType(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoSoftwareRenderTarget: DXVA2_VideoRenderTargetType = DXVA2_VideoRenderTargetType(2i32);
impl ::core::marker::Copy for DXVA2_VideoRenderTargetType {}
impl ::core::clone::Clone for DXVA2_VideoRenderTargetType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA2_VideoRenderTargetType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA2_VideoRenderTargetType {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA2_VideoRenderTargetType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA2_VideoRenderTargetType").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA2_VideoTransferFunction(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoTransFuncMask: DXVA2_VideoTransferFunction = DXVA2_VideoTransferFunction(31i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoTransFunc_Unknown: DXVA2_VideoTransferFunction = DXVA2_VideoTransferFunction(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoTransFunc_10: DXVA2_VideoTransferFunction = DXVA2_VideoTransferFunction(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoTransFunc_18: DXVA2_VideoTransferFunction = DXVA2_VideoTransferFunction(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoTransFunc_20: DXVA2_VideoTransferFunction = DXVA2_VideoTransferFunction(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoTransFunc_22: DXVA2_VideoTransferFunction = DXVA2_VideoTransferFunction(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoTransFunc_709: DXVA2_VideoTransferFunction = DXVA2_VideoTransferFunction(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoTransFunc_240M: DXVA2_VideoTransferFunction = DXVA2_VideoTransferFunction(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoTransFunc_sRGB: DXVA2_VideoTransferFunction = DXVA2_VideoTransferFunction(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoTransFunc_28: DXVA2_VideoTransferFunction = DXVA2_VideoTransferFunction(8i32);
impl ::core::marker::Copy for DXVA2_VideoTransferFunction {}
impl ::core::clone::Clone for DXVA2_VideoTransferFunction {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA2_VideoTransferFunction {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA2_VideoTransferFunction {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA2_VideoTransferFunction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA2_VideoTransferFunction").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA2_VideoTransferMatrix(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoTransferMatrixMask: DXVA2_VideoTransferMatrix = DXVA2_VideoTransferMatrix(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoTransferMatrix_Unknown: DXVA2_VideoTransferMatrix = DXVA2_VideoTransferMatrix(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoTransferMatrix_BT709: DXVA2_VideoTransferMatrix = DXVA2_VideoTransferMatrix(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoTransferMatrix_BT601: DXVA2_VideoTransferMatrix = DXVA2_VideoTransferMatrix(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA2_VideoTransferMatrix_SMPTE240M: DXVA2_VideoTransferMatrix = DXVA2_VideoTransferMatrix(3i32);
impl ::core::marker::Copy for DXVA2_VideoTransferMatrix {}
impl ::core::clone::Clone for DXVA2_VideoTransferMatrix {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA2_VideoTransferMatrix {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA2_VideoTransferMatrix {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA2_VideoTransferMatrix {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA2_VideoTransferMatrix").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVAHD_ALPHA_FILL_MODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_ALPHA_FILL_MODE_OPAQUE: DXVAHD_ALPHA_FILL_MODE = DXVAHD_ALPHA_FILL_MODE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_ALPHA_FILL_MODE_BACKGROUND: DXVAHD_ALPHA_FILL_MODE = DXVAHD_ALPHA_FILL_MODE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_ALPHA_FILL_MODE_DESTINATION: DXVAHD_ALPHA_FILL_MODE = DXVAHD_ALPHA_FILL_MODE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_ALPHA_FILL_MODE_SOURCE_STREAM: DXVAHD_ALPHA_FILL_MODE = DXVAHD_ALPHA_FILL_MODE(3i32);
impl ::core::marker::Copy for DXVAHD_ALPHA_FILL_MODE {}
impl ::core::clone::Clone for DXVAHD_ALPHA_FILL_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVAHD_ALPHA_FILL_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVAHD_ALPHA_FILL_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVAHD_ALPHA_FILL_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVAHD_ALPHA_FILL_MODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVAHD_BLT_STATE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_BLT_STATE_TARGET_RECT: DXVAHD_BLT_STATE = DXVAHD_BLT_STATE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_BLT_STATE_BACKGROUND_COLOR: DXVAHD_BLT_STATE = DXVAHD_BLT_STATE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE: DXVAHD_BLT_STATE = DXVAHD_BLT_STATE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_BLT_STATE_ALPHA_FILL: DXVAHD_BLT_STATE = DXVAHD_BLT_STATE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_BLT_STATE_CONSTRICTION: DXVAHD_BLT_STATE = DXVAHD_BLT_STATE(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_BLT_STATE_PRIVATE: DXVAHD_BLT_STATE = DXVAHD_BLT_STATE(1000i32);
impl ::core::marker::Copy for DXVAHD_BLT_STATE {}
impl ::core::clone::Clone for DXVAHD_BLT_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVAHD_BLT_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVAHD_BLT_STATE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVAHD_BLT_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVAHD_BLT_STATE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVAHD_DEVICE_CAPS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_DEVICE_CAPS_LINEAR_SPACE: DXVAHD_DEVICE_CAPS = DXVAHD_DEVICE_CAPS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_DEVICE_CAPS_xvYCC: DXVAHD_DEVICE_CAPS = DXVAHD_DEVICE_CAPS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_DEVICE_CAPS_RGB_RANGE_CONVERSION: DXVAHD_DEVICE_CAPS = DXVAHD_DEVICE_CAPS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_DEVICE_CAPS_YCbCr_MATRIX_CONVERSION: DXVAHD_DEVICE_CAPS = DXVAHD_DEVICE_CAPS(8i32);
impl ::core::marker::Copy for DXVAHD_DEVICE_CAPS {}
impl ::core::clone::Clone for DXVAHD_DEVICE_CAPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVAHD_DEVICE_CAPS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVAHD_DEVICE_CAPS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVAHD_DEVICE_CAPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVAHD_DEVICE_CAPS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVAHD_DEVICE_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_DEVICE_TYPE_HARDWARE: DXVAHD_DEVICE_TYPE = DXVAHD_DEVICE_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_DEVICE_TYPE_SOFTWARE: DXVAHD_DEVICE_TYPE = DXVAHD_DEVICE_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_DEVICE_TYPE_REFERENCE: DXVAHD_DEVICE_TYPE = DXVAHD_DEVICE_TYPE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_DEVICE_TYPE_OTHER: DXVAHD_DEVICE_TYPE = DXVAHD_DEVICE_TYPE(3i32);
impl ::core::marker::Copy for DXVAHD_DEVICE_TYPE {}
impl ::core::clone::Clone for DXVAHD_DEVICE_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVAHD_DEVICE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVAHD_DEVICE_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVAHD_DEVICE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVAHD_DEVICE_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVAHD_DEVICE_USAGE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_DEVICE_USAGE_PLAYBACK_NORMAL: DXVAHD_DEVICE_USAGE = DXVAHD_DEVICE_USAGE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_DEVICE_USAGE_OPTIMAL_SPEED: DXVAHD_DEVICE_USAGE = DXVAHD_DEVICE_USAGE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_DEVICE_USAGE_OPTIMAL_QUALITY: DXVAHD_DEVICE_USAGE = DXVAHD_DEVICE_USAGE(2i32);
impl ::core::marker::Copy for DXVAHD_DEVICE_USAGE {}
impl ::core::clone::Clone for DXVAHD_DEVICE_USAGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVAHD_DEVICE_USAGE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVAHD_DEVICE_USAGE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVAHD_DEVICE_USAGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVAHD_DEVICE_USAGE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVAHD_FEATURE_CAPS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_FEATURE_CAPS_ALPHA_FILL: DXVAHD_FEATURE_CAPS = DXVAHD_FEATURE_CAPS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_FEATURE_CAPS_CONSTRICTION: DXVAHD_FEATURE_CAPS = DXVAHD_FEATURE_CAPS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_FEATURE_CAPS_LUMA_KEY: DXVAHD_FEATURE_CAPS = DXVAHD_FEATURE_CAPS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_FEATURE_CAPS_ALPHA_PALETTE: DXVAHD_FEATURE_CAPS = DXVAHD_FEATURE_CAPS(8i32);
impl ::core::marker::Copy for DXVAHD_FEATURE_CAPS {}
impl ::core::clone::Clone for DXVAHD_FEATURE_CAPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVAHD_FEATURE_CAPS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVAHD_FEATURE_CAPS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVAHD_FEATURE_CAPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVAHD_FEATURE_CAPS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVAHD_FILTER(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_FILTER_BRIGHTNESS: DXVAHD_FILTER = DXVAHD_FILTER(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_FILTER_CONTRAST: DXVAHD_FILTER = DXVAHD_FILTER(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_FILTER_HUE: DXVAHD_FILTER = DXVAHD_FILTER(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_FILTER_SATURATION: DXVAHD_FILTER = DXVAHD_FILTER(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_FILTER_NOISE_REDUCTION: DXVAHD_FILTER = DXVAHD_FILTER(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_FILTER_EDGE_ENHANCEMENT: DXVAHD_FILTER = DXVAHD_FILTER(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_FILTER_ANAMORPHIC_SCALING: DXVAHD_FILTER = DXVAHD_FILTER(6i32);
impl ::core::marker::Copy for DXVAHD_FILTER {}
impl ::core::clone::Clone for DXVAHD_FILTER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVAHD_FILTER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVAHD_FILTER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVAHD_FILTER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVAHD_FILTER").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVAHD_FILTER_CAPS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_FILTER_CAPS_BRIGHTNESS: DXVAHD_FILTER_CAPS = DXVAHD_FILTER_CAPS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_FILTER_CAPS_CONTRAST: DXVAHD_FILTER_CAPS = DXVAHD_FILTER_CAPS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_FILTER_CAPS_HUE: DXVAHD_FILTER_CAPS = DXVAHD_FILTER_CAPS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_FILTER_CAPS_SATURATION: DXVAHD_FILTER_CAPS = DXVAHD_FILTER_CAPS(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_FILTER_CAPS_NOISE_REDUCTION: DXVAHD_FILTER_CAPS = DXVAHD_FILTER_CAPS(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_FILTER_CAPS_EDGE_ENHANCEMENT: DXVAHD_FILTER_CAPS = DXVAHD_FILTER_CAPS(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_FILTER_CAPS_ANAMORPHIC_SCALING: DXVAHD_FILTER_CAPS = DXVAHD_FILTER_CAPS(64i32);
impl ::core::marker::Copy for DXVAHD_FILTER_CAPS {}
impl ::core::clone::Clone for DXVAHD_FILTER_CAPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVAHD_FILTER_CAPS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVAHD_FILTER_CAPS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVAHD_FILTER_CAPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVAHD_FILTER_CAPS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVAHD_FRAME_FORMAT(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_FRAME_FORMAT_PROGRESSIVE: DXVAHD_FRAME_FORMAT = DXVAHD_FRAME_FORMAT(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_FRAME_FORMAT_INTERLACED_TOP_FIELD_FIRST: DXVAHD_FRAME_FORMAT = DXVAHD_FRAME_FORMAT(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_FRAME_FORMAT_INTERLACED_BOTTOM_FIELD_FIRST: DXVAHD_FRAME_FORMAT = DXVAHD_FRAME_FORMAT(2i32);
impl ::core::marker::Copy for DXVAHD_FRAME_FORMAT {}
impl ::core::clone::Clone for DXVAHD_FRAME_FORMAT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVAHD_FRAME_FORMAT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVAHD_FRAME_FORMAT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVAHD_FRAME_FORMAT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVAHD_FRAME_FORMAT").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVAHD_INPUT_FORMAT_CAPS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_INPUT_FORMAT_CAPS_RGB_INTERLACED: DXVAHD_INPUT_FORMAT_CAPS = DXVAHD_INPUT_FORMAT_CAPS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_INPUT_FORMAT_CAPS_RGB_PROCAMP: DXVAHD_INPUT_FORMAT_CAPS = DXVAHD_INPUT_FORMAT_CAPS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_INPUT_FORMAT_CAPS_RGB_LUMA_KEY: DXVAHD_INPUT_FORMAT_CAPS = DXVAHD_INPUT_FORMAT_CAPS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_INPUT_FORMAT_CAPS_PALETTE_INTERLACED: DXVAHD_INPUT_FORMAT_CAPS = DXVAHD_INPUT_FORMAT_CAPS(8i32);
impl ::core::marker::Copy for DXVAHD_INPUT_FORMAT_CAPS {}
impl ::core::clone::Clone for DXVAHD_INPUT_FORMAT_CAPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVAHD_INPUT_FORMAT_CAPS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVAHD_INPUT_FORMAT_CAPS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVAHD_INPUT_FORMAT_CAPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVAHD_INPUT_FORMAT_CAPS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVAHD_ITELECINE_CAPS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_ITELECINE_CAPS_32: DXVAHD_ITELECINE_CAPS = DXVAHD_ITELECINE_CAPS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_ITELECINE_CAPS_22: DXVAHD_ITELECINE_CAPS = DXVAHD_ITELECINE_CAPS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_ITELECINE_CAPS_2224: DXVAHD_ITELECINE_CAPS = DXVAHD_ITELECINE_CAPS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_ITELECINE_CAPS_2332: DXVAHD_ITELECINE_CAPS = DXVAHD_ITELECINE_CAPS(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_ITELECINE_CAPS_32322: DXVAHD_ITELECINE_CAPS = DXVAHD_ITELECINE_CAPS(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_ITELECINE_CAPS_55: DXVAHD_ITELECINE_CAPS = DXVAHD_ITELECINE_CAPS(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_ITELECINE_CAPS_64: DXVAHD_ITELECINE_CAPS = DXVAHD_ITELECINE_CAPS(64i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_ITELECINE_CAPS_87: DXVAHD_ITELECINE_CAPS = DXVAHD_ITELECINE_CAPS(128i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_ITELECINE_CAPS_222222222223: DXVAHD_ITELECINE_CAPS = DXVAHD_ITELECINE_CAPS(256i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_ITELECINE_CAPS_OTHER: DXVAHD_ITELECINE_CAPS = DXVAHD_ITELECINE_CAPS(-2147483648i32);
impl ::core::marker::Copy for DXVAHD_ITELECINE_CAPS {}
impl ::core::clone::Clone for DXVAHD_ITELECINE_CAPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVAHD_ITELECINE_CAPS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVAHD_ITELECINE_CAPS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVAHD_ITELECINE_CAPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVAHD_ITELECINE_CAPS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVAHD_OUTPUT_RATE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_OUTPUT_RATE_NORMAL: DXVAHD_OUTPUT_RATE = DXVAHD_OUTPUT_RATE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_OUTPUT_RATE_HALF: DXVAHD_OUTPUT_RATE = DXVAHD_OUTPUT_RATE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_OUTPUT_RATE_CUSTOM: DXVAHD_OUTPUT_RATE = DXVAHD_OUTPUT_RATE(2i32);
impl ::core::marker::Copy for DXVAHD_OUTPUT_RATE {}
impl ::core::clone::Clone for DXVAHD_OUTPUT_RATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVAHD_OUTPUT_RATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVAHD_OUTPUT_RATE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVAHD_OUTPUT_RATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVAHD_OUTPUT_RATE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVAHD_PROCESSOR_CAPS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_PROCESSOR_CAPS_DEINTERLACE_BLEND: DXVAHD_PROCESSOR_CAPS = DXVAHD_PROCESSOR_CAPS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_PROCESSOR_CAPS_DEINTERLACE_BOB: DXVAHD_PROCESSOR_CAPS = DXVAHD_PROCESSOR_CAPS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_PROCESSOR_CAPS_DEINTERLACE_ADAPTIVE: DXVAHD_PROCESSOR_CAPS = DXVAHD_PROCESSOR_CAPS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_PROCESSOR_CAPS_DEINTERLACE_MOTION_COMPENSATION: DXVAHD_PROCESSOR_CAPS = DXVAHD_PROCESSOR_CAPS(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_PROCESSOR_CAPS_INVERSE_TELECINE: DXVAHD_PROCESSOR_CAPS = DXVAHD_PROCESSOR_CAPS(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_PROCESSOR_CAPS_FRAME_RATE_CONVERSION: DXVAHD_PROCESSOR_CAPS = DXVAHD_PROCESSOR_CAPS(32i32);
impl ::core::marker::Copy for DXVAHD_PROCESSOR_CAPS {}
impl ::core::clone::Clone for DXVAHD_PROCESSOR_CAPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVAHD_PROCESSOR_CAPS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVAHD_PROCESSOR_CAPS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVAHD_PROCESSOR_CAPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVAHD_PROCESSOR_CAPS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVAHD_STREAM_STATE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_STREAM_STATE_D3DFORMAT: DXVAHD_STREAM_STATE = DXVAHD_STREAM_STATE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_STREAM_STATE_FRAME_FORMAT: DXVAHD_STREAM_STATE = DXVAHD_STREAM_STATE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE: DXVAHD_STREAM_STATE = DXVAHD_STREAM_STATE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_STREAM_STATE_OUTPUT_RATE: DXVAHD_STREAM_STATE = DXVAHD_STREAM_STATE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_STREAM_STATE_SOURCE_RECT: DXVAHD_STREAM_STATE = DXVAHD_STREAM_STATE(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_STREAM_STATE_DESTINATION_RECT: DXVAHD_STREAM_STATE = DXVAHD_STREAM_STATE(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_STREAM_STATE_ALPHA: DXVAHD_STREAM_STATE = DXVAHD_STREAM_STATE(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_STREAM_STATE_PALETTE: DXVAHD_STREAM_STATE = DXVAHD_STREAM_STATE(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_STREAM_STATE_LUMA_KEY: DXVAHD_STREAM_STATE = DXVAHD_STREAM_STATE(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_STREAM_STATE_ASPECT_RATIO: DXVAHD_STREAM_STATE = DXVAHD_STREAM_STATE(9i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_STREAM_STATE_FILTER_BRIGHTNESS: DXVAHD_STREAM_STATE = DXVAHD_STREAM_STATE(100i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_STREAM_STATE_FILTER_CONTRAST: DXVAHD_STREAM_STATE = DXVAHD_STREAM_STATE(101i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_STREAM_STATE_FILTER_HUE: DXVAHD_STREAM_STATE = DXVAHD_STREAM_STATE(102i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_STREAM_STATE_FILTER_SATURATION: DXVAHD_STREAM_STATE = DXVAHD_STREAM_STATE(103i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_STREAM_STATE_FILTER_NOISE_REDUCTION: DXVAHD_STREAM_STATE = DXVAHD_STREAM_STATE(104i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_STREAM_STATE_FILTER_EDGE_ENHANCEMENT: DXVAHD_STREAM_STATE = DXVAHD_STREAM_STATE(105i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_STREAM_STATE_FILTER_ANAMORPHIC_SCALING: DXVAHD_STREAM_STATE = DXVAHD_STREAM_STATE(106i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_STREAM_STATE_PRIVATE: DXVAHD_STREAM_STATE = DXVAHD_STREAM_STATE(1000i32);
impl ::core::marker::Copy for DXVAHD_STREAM_STATE {}
impl ::core::clone::Clone for DXVAHD_STREAM_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVAHD_STREAM_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVAHD_STREAM_STATE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVAHD_STREAM_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVAHD_STREAM_STATE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVAHD_SURFACE_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_SURFACE_TYPE_VIDEO_INPUT: DXVAHD_SURFACE_TYPE = DXVAHD_SURFACE_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_SURFACE_TYPE_VIDEO_INPUT_PRIVATE: DXVAHD_SURFACE_TYPE = DXVAHD_SURFACE_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVAHD_SURFACE_TYPE_VIDEO_OUTPUT: DXVAHD_SURFACE_TYPE = DXVAHD_SURFACE_TYPE(2i32);
impl ::core::marker::Copy for DXVAHD_SURFACE_TYPE {}
impl ::core::clone::Clone for DXVAHD_SURFACE_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVAHD_SURFACE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVAHD_SURFACE_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVAHD_SURFACE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVAHD_SURFACE_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA_DeinterlaceTech(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_DeinterlaceTech_Unknown: DXVA_DeinterlaceTech = DXVA_DeinterlaceTech(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_DeinterlaceTech_BOBLineReplicate: DXVA_DeinterlaceTech = DXVA_DeinterlaceTech(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_DeinterlaceTech_BOBVerticalStretch: DXVA_DeinterlaceTech = DXVA_DeinterlaceTech(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_DeinterlaceTech_BOBVerticalStretch4Tap: DXVA_DeinterlaceTech = DXVA_DeinterlaceTech(256i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_DeinterlaceTech_MedianFiltering: DXVA_DeinterlaceTech = DXVA_DeinterlaceTech(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_DeinterlaceTech_EdgeFiltering: DXVA_DeinterlaceTech = DXVA_DeinterlaceTech(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_DeinterlaceTech_FieldAdaptive: DXVA_DeinterlaceTech = DXVA_DeinterlaceTech(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_DeinterlaceTech_PixelAdaptive: DXVA_DeinterlaceTech = DXVA_DeinterlaceTech(64i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_DeinterlaceTech_MotionVectorSteered: DXVA_DeinterlaceTech = DXVA_DeinterlaceTech(128i32);
impl ::core::marker::Copy for DXVA_DeinterlaceTech {}
impl ::core::clone::Clone for DXVA_DeinterlaceTech {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA_DeinterlaceTech {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA_DeinterlaceTech {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA_DeinterlaceTech {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA_DeinterlaceTech").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA_DestinationFlags(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_DestinationFlagMask: DXVA_DestinationFlags = DXVA_DestinationFlags(15i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_DestinationFlag_Background_Changed: DXVA_DestinationFlags = DXVA_DestinationFlags(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_DestinationFlag_TargetRect_Changed: DXVA_DestinationFlags = DXVA_DestinationFlags(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_DestinationFlag_ColorData_Changed: DXVA_DestinationFlags = DXVA_DestinationFlags(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_DestinationFlag_Alpha_Changed: DXVA_DestinationFlags = DXVA_DestinationFlags(8i32);
impl ::core::marker::Copy for DXVA_DestinationFlags {}
impl ::core::clone::Clone for DXVA_DestinationFlags {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA_DestinationFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA_DestinationFlags {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA_DestinationFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA_DestinationFlags").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA_NominalRange(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_NominalRangeShift: DXVA_NominalRange = DXVA_NominalRange(12i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_NominalRangeMask: DXVA_NominalRange = DXVA_NominalRange(28672i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_NominalRange_Unknown: DXVA_NominalRange = DXVA_NominalRange(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_NominalRange_Normal: DXVA_NominalRange = DXVA_NominalRange(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_NominalRange_Wide: DXVA_NominalRange = DXVA_NominalRange(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_NominalRange_0_255: DXVA_NominalRange = DXVA_NominalRange(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_NominalRange_16_235: DXVA_NominalRange = DXVA_NominalRange(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_NominalRange_48_208: DXVA_NominalRange = DXVA_NominalRange(3i32);
impl ::core::marker::Copy for DXVA_NominalRange {}
impl ::core::clone::Clone for DXVA_NominalRange {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA_NominalRange {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA_NominalRange {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA_NominalRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA_NominalRange").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA_ProcAmpControlProp(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_ProcAmp_None: DXVA_ProcAmpControlProp = DXVA_ProcAmpControlProp(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_ProcAmp_Brightness: DXVA_ProcAmpControlProp = DXVA_ProcAmpControlProp(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_ProcAmp_Contrast: DXVA_ProcAmpControlProp = DXVA_ProcAmpControlProp(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_ProcAmp_Hue: DXVA_ProcAmpControlProp = DXVA_ProcAmpControlProp(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_ProcAmp_Saturation: DXVA_ProcAmpControlProp = DXVA_ProcAmpControlProp(8i32);
impl ::core::marker::Copy for DXVA_ProcAmpControlProp {}
impl ::core::clone::Clone for DXVA_ProcAmpControlProp {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA_ProcAmpControlProp {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA_ProcAmpControlProp {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA_ProcAmpControlProp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA_ProcAmpControlProp").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA_SampleFlags(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_SampleFlagsMask: DXVA_SampleFlags = DXVA_SampleFlags(15i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_SampleFlag_Palette_Changed: DXVA_SampleFlags = DXVA_SampleFlags(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_SampleFlag_SrcRect_Changed: DXVA_SampleFlags = DXVA_SampleFlags(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_SampleFlag_DstRect_Changed: DXVA_SampleFlags = DXVA_SampleFlags(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_SampleFlag_ColorData_Changed: DXVA_SampleFlags = DXVA_SampleFlags(8i32);
impl ::core::marker::Copy for DXVA_SampleFlags {}
impl ::core::clone::Clone for DXVA_SampleFlags {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA_SampleFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA_SampleFlags {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA_SampleFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA_SampleFlags").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA_SampleFormat(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_SampleFormatMask: DXVA_SampleFormat = DXVA_SampleFormat(255i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_SampleUnknown: DXVA_SampleFormat = DXVA_SampleFormat(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_SamplePreviousFrame: DXVA_SampleFormat = DXVA_SampleFormat(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_SampleProgressiveFrame: DXVA_SampleFormat = DXVA_SampleFormat(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_SampleFieldInterleavedEvenFirst: DXVA_SampleFormat = DXVA_SampleFormat(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_SampleFieldInterleavedOddFirst: DXVA_SampleFormat = DXVA_SampleFormat(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_SampleFieldSingleEven: DXVA_SampleFormat = DXVA_SampleFormat(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_SampleFieldSingleOdd: DXVA_SampleFormat = DXVA_SampleFormat(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_SampleSubStream: DXVA_SampleFormat = DXVA_SampleFormat(7i32);
impl ::core::marker::Copy for DXVA_SampleFormat {}
impl ::core::clone::Clone for DXVA_SampleFormat {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA_SampleFormat {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA_SampleFormat {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA_SampleFormat {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA_SampleFormat").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA_VideoChromaSubsampling(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoChromaSubsamplingShift: DXVA_VideoChromaSubsampling = DXVA_VideoChromaSubsampling(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoChromaSubsamplingMask: DXVA_VideoChromaSubsampling = DXVA_VideoChromaSubsampling(3840i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoChromaSubsampling_Unknown: DXVA_VideoChromaSubsampling = DXVA_VideoChromaSubsampling(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoChromaSubsampling_ProgressiveChroma: DXVA_VideoChromaSubsampling = DXVA_VideoChromaSubsampling(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoChromaSubsampling_Horizontally_Cosited: DXVA_VideoChromaSubsampling = DXVA_VideoChromaSubsampling(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoChromaSubsampling_Vertically_Cosited: DXVA_VideoChromaSubsampling = DXVA_VideoChromaSubsampling(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoChromaSubsampling_Vertically_AlignedChromaPlanes: DXVA_VideoChromaSubsampling = DXVA_VideoChromaSubsampling(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoChromaSubsampling_MPEG2: DXVA_VideoChromaSubsampling = DXVA_VideoChromaSubsampling(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoChromaSubsampling_MPEG1: DXVA_VideoChromaSubsampling = DXVA_VideoChromaSubsampling(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoChromaSubsampling_DV_PAL: DXVA_VideoChromaSubsampling = DXVA_VideoChromaSubsampling(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoChromaSubsampling_Cosited: DXVA_VideoChromaSubsampling = DXVA_VideoChromaSubsampling(7i32);
impl ::core::marker::Copy for DXVA_VideoChromaSubsampling {}
impl ::core::clone::Clone for DXVA_VideoChromaSubsampling {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA_VideoChromaSubsampling {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA_VideoChromaSubsampling {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA_VideoChromaSubsampling {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA_VideoChromaSubsampling").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA_VideoLighting(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoLightingShift: DXVA_VideoLighting = DXVA_VideoLighting(18i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoLightingMask: DXVA_VideoLighting = DXVA_VideoLighting(3932160i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoLighting_Unknown: DXVA_VideoLighting = DXVA_VideoLighting(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoLighting_bright: DXVA_VideoLighting = DXVA_VideoLighting(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoLighting_office: DXVA_VideoLighting = DXVA_VideoLighting(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoLighting_dim: DXVA_VideoLighting = DXVA_VideoLighting(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoLighting_dark: DXVA_VideoLighting = DXVA_VideoLighting(4i32);
impl ::core::marker::Copy for DXVA_VideoLighting {}
impl ::core::clone::Clone for DXVA_VideoLighting {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA_VideoLighting {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA_VideoLighting {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA_VideoLighting {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA_VideoLighting").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA_VideoPrimaries(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoPrimariesShift: DXVA_VideoPrimaries = DXVA_VideoPrimaries(22i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoPrimariesMask: DXVA_VideoPrimaries = DXVA_VideoPrimaries(130023424i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoPrimaries_Unknown: DXVA_VideoPrimaries = DXVA_VideoPrimaries(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoPrimaries_reserved: DXVA_VideoPrimaries = DXVA_VideoPrimaries(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoPrimaries_BT709: DXVA_VideoPrimaries = DXVA_VideoPrimaries(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoPrimaries_BT470_2_SysM: DXVA_VideoPrimaries = DXVA_VideoPrimaries(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoPrimaries_BT470_2_SysBG: DXVA_VideoPrimaries = DXVA_VideoPrimaries(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoPrimaries_SMPTE170M: DXVA_VideoPrimaries = DXVA_VideoPrimaries(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoPrimaries_SMPTE240M: DXVA_VideoPrimaries = DXVA_VideoPrimaries(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoPrimaries_EBU3213: DXVA_VideoPrimaries = DXVA_VideoPrimaries(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoPrimaries_SMPTE_C: DXVA_VideoPrimaries = DXVA_VideoPrimaries(8i32);
impl ::core::marker::Copy for DXVA_VideoPrimaries {}
impl ::core::clone::Clone for DXVA_VideoPrimaries {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA_VideoPrimaries {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA_VideoPrimaries {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA_VideoPrimaries {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA_VideoPrimaries").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA_VideoProcessCaps(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoProcess_None: DXVA_VideoProcessCaps = DXVA_VideoProcessCaps(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoProcess_YUV2RGB: DXVA_VideoProcessCaps = DXVA_VideoProcessCaps(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoProcess_StretchX: DXVA_VideoProcessCaps = DXVA_VideoProcessCaps(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoProcess_StretchY: DXVA_VideoProcessCaps = DXVA_VideoProcessCaps(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoProcess_AlphaBlend: DXVA_VideoProcessCaps = DXVA_VideoProcessCaps(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoProcess_SubRects: DXVA_VideoProcessCaps = DXVA_VideoProcessCaps(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoProcess_SubStreams: DXVA_VideoProcessCaps = DXVA_VideoProcessCaps(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoProcess_SubStreamsExtended: DXVA_VideoProcessCaps = DXVA_VideoProcessCaps(64i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoProcess_YUV2RGBExtended: DXVA_VideoProcessCaps = DXVA_VideoProcessCaps(128i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoProcess_AlphaBlendExtended: DXVA_VideoProcessCaps = DXVA_VideoProcessCaps(256i32);
impl ::core::marker::Copy for DXVA_VideoProcessCaps {}
impl ::core::clone::Clone for DXVA_VideoProcessCaps {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA_VideoProcessCaps {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA_VideoProcessCaps {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA_VideoProcessCaps {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA_VideoProcessCaps").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA_VideoTransferFunction(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoTransFuncShift: DXVA_VideoTransferFunction = DXVA_VideoTransferFunction(27i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoTransFuncMask: DXVA_VideoTransferFunction = DXVA_VideoTransferFunction(-134217728i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoTransFunc_Unknown: DXVA_VideoTransferFunction = DXVA_VideoTransferFunction(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoTransFunc_10: DXVA_VideoTransferFunction = DXVA_VideoTransferFunction(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoTransFunc_18: DXVA_VideoTransferFunction = DXVA_VideoTransferFunction(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoTransFunc_20: DXVA_VideoTransferFunction = DXVA_VideoTransferFunction(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoTransFunc_22: DXVA_VideoTransferFunction = DXVA_VideoTransferFunction(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoTransFunc_22_709: DXVA_VideoTransferFunction = DXVA_VideoTransferFunction(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoTransFunc_22_240M: DXVA_VideoTransferFunction = DXVA_VideoTransferFunction(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoTransFunc_22_8bit_sRGB: DXVA_VideoTransferFunction = DXVA_VideoTransferFunction(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoTransFunc_28: DXVA_VideoTransferFunction = DXVA_VideoTransferFunction(8i32);
impl ::core::marker::Copy for DXVA_VideoTransferFunction {}
impl ::core::clone::Clone for DXVA_VideoTransferFunction {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA_VideoTransferFunction {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA_VideoTransferFunction {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA_VideoTransferFunction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA_VideoTransferFunction").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXVA_VideoTransferMatrix(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoTransferMatrixShift: DXVA_VideoTransferMatrix = DXVA_VideoTransferMatrix(15i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoTransferMatrixMask: DXVA_VideoTransferMatrix = DXVA_VideoTransferMatrix(229376i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoTransferMatrix_Unknown: DXVA_VideoTransferMatrix = DXVA_VideoTransferMatrix(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoTransferMatrix_BT709: DXVA_VideoTransferMatrix = DXVA_VideoTransferMatrix(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoTransferMatrix_BT601: DXVA_VideoTransferMatrix = DXVA_VideoTransferMatrix(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DXVA_VideoTransferMatrix_SMPTE240M: DXVA_VideoTransferMatrix = DXVA_VideoTransferMatrix(3i32);
impl ::core::marker::Copy for DXVA_VideoTransferMatrix {}
impl ::core::clone::Clone for DXVA_VideoTransferMatrix {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXVA_VideoTransferMatrix {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXVA_VideoTransferMatrix {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXVA_VideoTransferMatrix {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXVA_VideoTransferMatrix").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DeviceStreamState(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DeviceStreamState_Stop: DeviceStreamState = DeviceStreamState(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DeviceStreamState_Pause: DeviceStreamState = DeviceStreamState(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DeviceStreamState_Run: DeviceStreamState = DeviceStreamState(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DeviceStreamState_Disabled: DeviceStreamState = DeviceStreamState(3i32);
impl ::core::marker::Copy for DeviceStreamState {}
impl ::core::clone::Clone for DeviceStreamState {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DeviceStreamState {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DeviceStreamState {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DeviceStreamState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DeviceStreamState").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct EAllocationType(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAllocationTypeDynamic: EAllocationType = EAllocationType(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAllocationTypeRT: EAllocationType = EAllocationType(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAllocationTypePageable: EAllocationType = EAllocationType(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAllocationTypeIgnore: EAllocationType = EAllocationType(3i32);
impl ::core::marker::Copy for EAllocationType {}
impl ::core::clone::Clone for EAllocationType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for EAllocationType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for EAllocationType {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for EAllocationType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("EAllocationType").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct EVRFilterConfigPrefs(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const EVRFilterConfigPrefs_EnableQoS: EVRFilterConfigPrefs = EVRFilterConfigPrefs(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const EVRFilterConfigPrefs_Mask: EVRFilterConfigPrefs = EVRFilterConfigPrefs(1i32);
impl ::core::marker::Copy for EVRFilterConfigPrefs {}
impl ::core::clone::Clone for EVRFilterConfigPrefs {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for EVRFilterConfigPrefs {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for EVRFilterConfigPrefs {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for EVRFilterConfigPrefs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("EVRFilterConfigPrefs").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct FILE_ACCESSMODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const ACCESSMODE_READ: FILE_ACCESSMODE = FILE_ACCESSMODE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const ACCESSMODE_WRITE: FILE_ACCESSMODE = FILE_ACCESSMODE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const ACCESSMODE_READWRITE: FILE_ACCESSMODE = FILE_ACCESSMODE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const ACCESSMODE_WRITE_EXCLUSIVE: FILE_ACCESSMODE = FILE_ACCESSMODE(4i32);
impl ::core::marker::Copy for FILE_ACCESSMODE {}
impl ::core::clone::Clone for FILE_ACCESSMODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FILE_ACCESSMODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for FILE_ACCESSMODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for FILE_ACCESSMODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FILE_ACCESSMODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct FILE_OPENMODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPENMODE_FAIL_IF_NOT_EXIST: FILE_OPENMODE = FILE_OPENMODE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPENMODE_FAIL_IF_EXIST: FILE_OPENMODE = FILE_OPENMODE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPENMODE_RESET_IF_EXIST: FILE_OPENMODE = FILE_OPENMODE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPENMODE_APPEND_IF_EXIST: FILE_OPENMODE = FILE_OPENMODE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPENMODE_DELETE_IF_EXIST: FILE_OPENMODE = FILE_OPENMODE(4i32);
impl ::core::marker::Copy for FILE_OPENMODE {}
impl ::core::clone::Clone for FILE_OPENMODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FILE_OPENMODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for FILE_OPENMODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for FILE_OPENMODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FILE_OPENMODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct KSMETHOD_OPMVIDEOOUTPUT(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const KSMETHOD_OPMVIDEOOUTPUT_STARTINITIALIZATION: KSMETHOD_OPMVIDEOOUTPUT = KSMETHOD_OPMVIDEOOUTPUT(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const KSMETHOD_OPMVIDEOOUTPUT_FINISHINITIALIZATION: KSMETHOD_OPMVIDEOOUTPUT = KSMETHOD_OPMVIDEOOUTPUT(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const KSMETHOD_OPMVIDEOOUTPUT_GETINFORMATION: KSMETHOD_OPMVIDEOOUTPUT = KSMETHOD_OPMVIDEOOUTPUT(2i32);
impl ::core::marker::Copy for KSMETHOD_OPMVIDEOOUTPUT {}
impl ::core::clone::Clone for KSMETHOD_OPMVIDEOOUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for KSMETHOD_OPMVIDEOOUTPUT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for KSMETHOD_OPMVIDEOOUTPUT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for KSMETHOD_OPMVIDEOOUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("KSMETHOD_OPMVIDEOOUTPUT").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS(pub u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_EVENT_FLAG_NONE: MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS = MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS(0u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_EVENT_FLAG_NO_WAIT: MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS = MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS(1u32);
impl ::core::marker::Copy for MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS {}
impl ::core::clone::Clone for MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF2DBuffer_LockFlags(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF2DBuffer_LockFlags_LockTypeMask: MF2DBuffer_LockFlags = MF2DBuffer_LockFlags(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF2DBuffer_LockFlags_Read: MF2DBuffer_LockFlags = MF2DBuffer_LockFlags(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF2DBuffer_LockFlags_Write: MF2DBuffer_LockFlags = MF2DBuffer_LockFlags(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF2DBuffer_LockFlags_ReadWrite: MF2DBuffer_LockFlags = MF2DBuffer_LockFlags(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF2DBuffer_LockFlags_ForceDWORD: MF2DBuffer_LockFlags = MF2DBuffer_LockFlags(2147483647i32);
impl ::core::marker::Copy for MF2DBuffer_LockFlags {}
impl ::core::clone::Clone for MF2DBuffer_LockFlags {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF2DBuffer_LockFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF2DBuffer_LockFlags {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF2DBuffer_LockFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF2DBuffer_LockFlags").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF3DVideoOutputType(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF3DVideoOutputType_BaseView: MF3DVideoOutputType = MF3DVideoOutputType(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF3DVideoOutputType_Stereo: MF3DVideoOutputType = MF3DVideoOutputType(1i32);
impl ::core::marker::Copy for MF3DVideoOutputType {}
impl ::core::clone::Clone for MF3DVideoOutputType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF3DVideoOutputType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF3DVideoOutputType {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF3DVideoOutputType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF3DVideoOutputType").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFASF_INDEXER_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASF_INDEXER_WRITE_NEW_INDEX: MFASF_INDEXER_FLAGS = MFASF_INDEXER_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASF_INDEXER_READ_FOR_REVERSEPLAYBACK: MFASF_INDEXER_FLAGS = MFASF_INDEXER_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASF_INDEXER_WRITE_FOR_LIVEREAD: MFASF_INDEXER_FLAGS = MFASF_INDEXER_FLAGS(4i32);
impl ::core::marker::Copy for MFASF_INDEXER_FLAGS {}
impl ::core::clone::Clone for MFASF_INDEXER_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFASF_INDEXER_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFASF_INDEXER_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFASF_INDEXER_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFASF_INDEXER_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFASF_MULTIPLEXERFLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASF_MULTIPLEXER_AUTOADJUST_BITRATE: MFASF_MULTIPLEXERFLAGS = MFASF_MULTIPLEXERFLAGS(1i32);
impl ::core::marker::Copy for MFASF_MULTIPLEXERFLAGS {}
impl ::core::clone::Clone for MFASF_MULTIPLEXERFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFASF_MULTIPLEXERFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFASF_MULTIPLEXERFLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFASF_MULTIPLEXERFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFASF_MULTIPLEXERFLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFASF_SPLITTERFLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASF_SPLITTER_REVERSE: MFASF_SPLITTERFLAGS = MFASF_SPLITTERFLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASF_SPLITTER_WMDRM: MFASF_SPLITTERFLAGS = MFASF_SPLITTERFLAGS(2i32);
impl ::core::marker::Copy for MFASF_SPLITTERFLAGS {}
impl ::core::clone::Clone for MFASF_SPLITTERFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFASF_SPLITTERFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFASF_SPLITTERFLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFASF_SPLITTERFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFASF_SPLITTERFLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFASF_STREAMSELECTOR_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASF_STREAMSELECTOR_DISABLE_THINNING: MFASF_STREAMSELECTOR_FLAGS = MFASF_STREAMSELECTOR_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFASF_STREAMSELECTOR_USE_AVERAGE_BITRATE: MFASF_STREAMSELECTOR_FLAGS = MFASF_STREAMSELECTOR_FLAGS(2i32);
impl ::core::marker::Copy for MFASF_STREAMSELECTOR_FLAGS {}
impl ::core::clone::Clone for MFASF_STREAMSELECTOR_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFASF_STREAMSELECTOR_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFASF_STREAMSELECTOR_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFASF_STREAMSELECTOR_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFASF_STREAMSELECTOR_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFASYNC_WORKQUEUE_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_STANDARD_WORKQUEUE: MFASYNC_WORKQUEUE_TYPE = MFASYNC_WORKQUEUE_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_WINDOW_WORKQUEUE: MFASYNC_WORKQUEUE_TYPE = MFASYNC_WORKQUEUE_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MULTITHREADED_WORKQUEUE: MFASYNC_WORKQUEUE_TYPE = MFASYNC_WORKQUEUE_TYPE(2i32);
impl ::core::marker::Copy for MFASYNC_WORKQUEUE_TYPE {}
impl ::core::clone::Clone for MFASYNC_WORKQUEUE_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFASYNC_WORKQUEUE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFASYNC_WORKQUEUE_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFASYNC_WORKQUEUE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFASYNC_WORKQUEUE_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFAudioConstriction(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFaudioConstrictionOff: MFAudioConstriction = MFAudioConstriction(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFaudioConstriction48_16: MFAudioConstriction = MFAudioConstriction(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFaudioConstriction44_16: MFAudioConstriction = MFAudioConstriction(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFaudioConstriction14_14: MFAudioConstriction = MFAudioConstriction(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFaudioConstrictionMute: MFAudioConstriction = MFAudioConstriction(4i32);
impl ::core::marker::Copy for MFAudioConstriction {}
impl ::core::clone::Clone for MFAudioConstriction {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFAudioConstriction {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFAudioConstriction {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFAudioConstriction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFAudioConstriction").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFBYTESTREAM_SEEK_ORIGIN(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const msoBegin: MFBYTESTREAM_SEEK_ORIGIN = MFBYTESTREAM_SEEK_ORIGIN(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const msoCurrent: MFBYTESTREAM_SEEK_ORIGIN = MFBYTESTREAM_SEEK_ORIGIN(1i32);
impl ::core::marker::Copy for MFBYTESTREAM_SEEK_ORIGIN {}
impl ::core::clone::Clone for MFBYTESTREAM_SEEK_ORIGIN {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFBYTESTREAM_SEEK_ORIGIN {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFBYTESTREAM_SEEK_ORIGIN {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFBYTESTREAM_SEEK_ORIGIN {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFBYTESTREAM_SEEK_ORIGIN").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFCLOCK_CHARACTERISTICS_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCLOCK_CHARACTERISTICS_FLAG_FREQUENCY_10MHZ: MFCLOCK_CHARACTERISTICS_FLAGS = MFCLOCK_CHARACTERISTICS_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCLOCK_CHARACTERISTICS_FLAG_ALWAYS_RUNNING: MFCLOCK_CHARACTERISTICS_FLAGS = MFCLOCK_CHARACTERISTICS_FLAGS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCLOCK_CHARACTERISTICS_FLAG_IS_SYSTEM_CLOCK: MFCLOCK_CHARACTERISTICS_FLAGS = MFCLOCK_CHARACTERISTICS_FLAGS(8i32);
impl ::core::marker::Copy for MFCLOCK_CHARACTERISTICS_FLAGS {}
impl ::core::clone::Clone for MFCLOCK_CHARACTERISTICS_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFCLOCK_CHARACTERISTICS_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFCLOCK_CHARACTERISTICS_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFCLOCK_CHARACTERISTICS_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFCLOCK_CHARACTERISTICS_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFCLOCK_RELATIONAL_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCLOCK_RELATIONAL_FLAG_JITTER_NEVER_AHEAD: MFCLOCK_RELATIONAL_FLAGS = MFCLOCK_RELATIONAL_FLAGS(1i32);
impl ::core::marker::Copy for MFCLOCK_RELATIONAL_FLAGS {}
impl ::core::clone::Clone for MFCLOCK_RELATIONAL_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFCLOCK_RELATIONAL_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFCLOCK_RELATIONAL_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFCLOCK_RELATIONAL_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFCLOCK_RELATIONAL_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFCLOCK_STATE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCLOCK_STATE_INVALID: MFCLOCK_STATE = MFCLOCK_STATE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCLOCK_STATE_RUNNING: MFCLOCK_STATE = MFCLOCK_STATE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCLOCK_STATE_STOPPED: MFCLOCK_STATE = MFCLOCK_STATE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCLOCK_STATE_PAUSED: MFCLOCK_STATE = MFCLOCK_STATE(3i32);
impl ::core::marker::Copy for MFCLOCK_STATE {}
impl ::core::clone::Clone for MFCLOCK_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFCLOCK_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFCLOCK_STATE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFCLOCK_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFCLOCK_STATE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFCameraIntrinsic_DistortionModelType(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCameraIntrinsic_DistortionModelType_6KT: MFCameraIntrinsic_DistortionModelType = MFCameraIntrinsic_DistortionModelType(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCameraIntrinsic_DistortionModelType_ArcTan: MFCameraIntrinsic_DistortionModelType = MFCameraIntrinsic_DistortionModelType(1i32);
impl ::core::marker::Copy for MFCameraIntrinsic_DistortionModelType {}
impl ::core::clone::Clone for MFCameraIntrinsic_DistortionModelType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFCameraIntrinsic_DistortionModelType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFCameraIntrinsic_DistortionModelType {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFCameraIntrinsic_DistortionModelType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFCameraIntrinsic_DistortionModelType").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFCameraOcclusionState(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCameraOcclusionState_Open: MFCameraOcclusionState = MFCameraOcclusionState(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCameraOcclusionState_OccludedByLid: MFCameraOcclusionState = MFCameraOcclusionState(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFCameraOcclusionState_OccludedByCameraHardware: MFCameraOcclusionState = MFCameraOcclusionState(2i32);
impl ::core::marker::Copy for MFCameraOcclusionState {}
impl ::core::clone::Clone for MFCameraOcclusionState {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFCameraOcclusionState {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFCameraOcclusionState {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFCameraOcclusionState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFCameraOcclusionState").field(&self.0).finish()
    }
}
impl MFCameraOcclusionState {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for MFCameraOcclusionState {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for MFCameraOcclusionState {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for MFCameraOcclusionState {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for MFCameraOcclusionState {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for MFCameraOcclusionState {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFDepthMeasurement(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DistanceToFocalPlane: MFDepthMeasurement = MFDepthMeasurement(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const DistanceToOpticalCenter: MFDepthMeasurement = MFDepthMeasurement(1i32);
impl ::core::marker::Copy for MFDepthMeasurement {}
impl ::core::clone::Clone for MFDepthMeasurement {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFDepthMeasurement {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFDepthMeasurement {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFDepthMeasurement {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFDepthMeasurement").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFFrameSourceTypes(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFFrameSourceTypes_Color: MFFrameSourceTypes = MFFrameSourceTypes(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFFrameSourceTypes_Infrared: MFFrameSourceTypes = MFFrameSourceTypes(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFFrameSourceTypes_Depth: MFFrameSourceTypes = MFFrameSourceTypes(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFFrameSourceTypes_Image: MFFrameSourceTypes = MFFrameSourceTypes(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFFrameSourceTypes_Custom: MFFrameSourceTypes = MFFrameSourceTypes(128i32);
impl ::core::marker::Copy for MFFrameSourceTypes {}
impl ::core::clone::Clone for MFFrameSourceTypes {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFFrameSourceTypes {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFFrameSourceTypes {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFFrameSourceTypes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFFrameSourceTypes").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFMEDIASOURCE_CHARACTERISTICS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMEDIASOURCE_IS_LIVE: MFMEDIASOURCE_CHARACTERISTICS = MFMEDIASOURCE_CHARACTERISTICS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMEDIASOURCE_CAN_SEEK: MFMEDIASOURCE_CHARACTERISTICS = MFMEDIASOURCE_CHARACTERISTICS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMEDIASOURCE_CAN_PAUSE: MFMEDIASOURCE_CHARACTERISTICS = MFMEDIASOURCE_CHARACTERISTICS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMEDIASOURCE_HAS_SLOW_SEEK: MFMEDIASOURCE_CHARACTERISTICS = MFMEDIASOURCE_CHARACTERISTICS(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMEDIASOURCE_HAS_MULTIPLE_PRESENTATIONS: MFMEDIASOURCE_CHARACTERISTICS = MFMEDIASOURCE_CHARACTERISTICS(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMEDIASOURCE_CAN_SKIPFORWARD: MFMEDIASOURCE_CHARACTERISTICS = MFMEDIASOURCE_CHARACTERISTICS(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMEDIASOURCE_CAN_SKIPBACKWARD: MFMEDIASOURCE_CHARACTERISTICS = MFMEDIASOURCE_CHARACTERISTICS(64i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFMEDIASOURCE_DOES_NOT_USE_NETWORK: MFMEDIASOURCE_CHARACTERISTICS = MFMEDIASOURCE_CHARACTERISTICS(128i32);
impl ::core::marker::Copy for MFMEDIASOURCE_CHARACTERISTICS {}
impl ::core::clone::Clone for MFMEDIASOURCE_CHARACTERISTICS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFMEDIASOURCE_CHARACTERISTICS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFMEDIASOURCE_CHARACTERISTICS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFMEDIASOURCE_CHARACTERISTICS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFMEDIASOURCE_CHARACTERISTICS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFNETSOURCE_CACHE_STATE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_CACHE_UNAVAILABLE: MFNETSOURCE_CACHE_STATE = MFNETSOURCE_CACHE_STATE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_CACHE_ACTIVE_WRITING: MFNETSOURCE_CACHE_STATE = MFNETSOURCE_CACHE_STATE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_CACHE_ACTIVE_COMPLETE: MFNETSOURCE_CACHE_STATE = MFNETSOURCE_CACHE_STATE(2i32);
impl ::core::marker::Copy for MFNETSOURCE_CACHE_STATE {}
impl ::core::clone::Clone for MFNETSOURCE_CACHE_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFNETSOURCE_CACHE_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFNETSOURCE_CACHE_STATE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFNETSOURCE_CACHE_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFNETSOURCE_CACHE_STATE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFNETSOURCE_PROTOCOL_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_UNDEFINED: MFNETSOURCE_PROTOCOL_TYPE = MFNETSOURCE_PROTOCOL_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_HTTP: MFNETSOURCE_PROTOCOL_TYPE = MFNETSOURCE_PROTOCOL_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_RTSP: MFNETSOURCE_PROTOCOL_TYPE = MFNETSOURCE_PROTOCOL_TYPE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_FILE: MFNETSOURCE_PROTOCOL_TYPE = MFNETSOURCE_PROTOCOL_TYPE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_MULTICAST: MFNETSOURCE_PROTOCOL_TYPE = MFNETSOURCE_PROTOCOL_TYPE(4i32);
impl ::core::marker::Copy for MFNETSOURCE_PROTOCOL_TYPE {}
impl ::core::clone::Clone for MFNETSOURCE_PROTOCOL_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFNETSOURCE_PROTOCOL_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFNETSOURCE_PROTOCOL_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFNETSOURCE_PROTOCOL_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFNETSOURCE_PROTOCOL_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFNETSOURCE_STATISTICS_IDS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_RECVPACKETS_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_LOSTPACKETS_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_RESENDSREQUESTED_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_RESENDSRECEIVED_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_RECOVEREDBYECCPACKETS_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_RECOVEREDBYRTXPACKETS_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_OUTPACKETS_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_RECVRATE_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_AVGBANDWIDTHBPS_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_BYTESRECEIVED_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(9i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_PROTOCOL_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(10i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_TRANSPORT_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(11i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_CACHE_STATE_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(12i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_LINKBANDWIDTH_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(13i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_CONTENTBITRATE_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(14i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_SPEEDFACTOR_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(15i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_BUFFERSIZE_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_BUFFERPROGRESS_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(17i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_LASTBWSWITCHTS_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(18i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_SEEKRANGESTART_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(19i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_SEEKRANGEEND_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(20i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_BUFFERINGCOUNT_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(21i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_INCORRECTLYSIGNEDPACKETS_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(22i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_SIGNEDSESSION_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(23i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_MAXBITRATE_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(24i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_RECEPTION_QUALITY_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(25i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_RECOVEREDPACKETS_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(26i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_VBR_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(27i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_DOWNLOADPROGRESS_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(28i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_UNPREDEFINEDPROTOCOLNAME_ID: MFNETSOURCE_STATISTICS_IDS = MFNETSOURCE_STATISTICS_IDS(29i32);
impl ::core::marker::Copy for MFNETSOURCE_STATISTICS_IDS {}
impl ::core::clone::Clone for MFNETSOURCE_STATISTICS_IDS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFNETSOURCE_STATISTICS_IDS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFNETSOURCE_STATISTICS_IDS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFNETSOURCE_STATISTICS_IDS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFNETSOURCE_STATISTICS_IDS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFNETSOURCE_TRANSPORT_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_UDP: MFNETSOURCE_TRANSPORT_TYPE = MFNETSOURCE_TRANSPORT_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNETSOURCE_TCP: MFNETSOURCE_TRANSPORT_TYPE = MFNETSOURCE_TRANSPORT_TYPE(1i32);
impl ::core::marker::Copy for MFNETSOURCE_TRANSPORT_TYPE {}
impl ::core::clone::Clone for MFNETSOURCE_TRANSPORT_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFNETSOURCE_TRANSPORT_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFNETSOURCE_TRANSPORT_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFNETSOURCE_TRANSPORT_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFNETSOURCE_TRANSPORT_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFNET_PROXYSETTINGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNET_PROXYSETTING_NONE: MFNET_PROXYSETTINGS = MFNET_PROXYSETTINGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNET_PROXYSETTING_MANUAL: MFNET_PROXYSETTINGS = MFNET_PROXYSETTINGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNET_PROXYSETTING_AUTO: MFNET_PROXYSETTINGS = MFNET_PROXYSETTINGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNET_PROXYSETTING_BROWSER: MFNET_PROXYSETTINGS = MFNET_PROXYSETTINGS(3i32);
impl ::core::marker::Copy for MFNET_PROXYSETTINGS {}
impl ::core::clone::Clone for MFNET_PROXYSETTINGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFNET_PROXYSETTINGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFNET_PROXYSETTINGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFNET_PROXYSETTINGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFNET_PROXYSETTINGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFNetAuthenticationFlags(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNET_AUTHENTICATION_PROXY: MFNetAuthenticationFlags = MFNetAuthenticationFlags(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNET_AUTHENTICATION_CLEAR_TEXT: MFNetAuthenticationFlags = MFNetAuthenticationFlags(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNET_AUTHENTICATION_LOGGED_ON_USER: MFNetAuthenticationFlags = MFNetAuthenticationFlags(4i32);
impl ::core::marker::Copy for MFNetAuthenticationFlags {}
impl ::core::clone::Clone for MFNetAuthenticationFlags {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFNetAuthenticationFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFNetAuthenticationFlags {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFNetAuthenticationFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFNetAuthenticationFlags").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFNetCredentialOptions(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNET_CREDENTIAL_SAVE: MFNetCredentialOptions = MFNetCredentialOptions(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNET_CREDENTIAL_DONT_CACHE: MFNetCredentialOptions = MFNetCredentialOptions(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNET_CREDENTIAL_ALLOW_CLEAR_TEXT: MFNetCredentialOptions = MFNetCredentialOptions(4i32);
impl ::core::marker::Copy for MFNetCredentialOptions {}
impl ::core::clone::Clone for MFNetCredentialOptions {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFNetCredentialOptions {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFNetCredentialOptions {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFNetCredentialOptions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFNetCredentialOptions").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFNetCredentialRequirements(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const REQUIRE_PROMPT: MFNetCredentialRequirements = MFNetCredentialRequirements(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const REQUIRE_SAVE_SELECTED: MFNetCredentialRequirements = MFNetCredentialRequirements(2i32);
impl ::core::marker::Copy for MFNetCredentialRequirements {}
impl ::core::clone::Clone for MFNetCredentialRequirements {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFNetCredentialRequirements {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFNetCredentialRequirements {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFNetCredentialRequirements {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFNetCredentialRequirements").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFNominalRange(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNominalRange_Unknown: MFNominalRange = MFNominalRange(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNominalRange_Normal: MFNominalRange = MFNominalRange(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNominalRange_Wide: MFNominalRange = MFNominalRange(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNominalRange_0_255: MFNominalRange = MFNominalRange(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNominalRange_16_235: MFNominalRange = MFNominalRange(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNominalRange_48_208: MFNominalRange = MFNominalRange(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNominalRange_64_127: MFNominalRange = MFNominalRange(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNominalRange_Last: MFNominalRange = MFNominalRange(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFNominalRange_ForceDWORD: MFNominalRange = MFNominalRange(2147483647i32);
impl ::core::marker::Copy for MFNominalRange {}
impl ::core::clone::Clone for MFNominalRange {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFNominalRange {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFNominalRange {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFNominalRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFNominalRange").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFPMPSESSION_CREATION_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFPMPSESSION_UNPROTECTED_PROCESS: MFPMPSESSION_CREATION_FLAGS = MFPMPSESSION_CREATION_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFPMPSESSION_IN_PROCESS: MFPMPSESSION_CREATION_FLAGS = MFPMPSESSION_CREATION_FLAGS(2i32);
impl ::core::marker::Copy for MFPMPSESSION_CREATION_FLAGS {}
impl ::core::clone::Clone for MFPMPSESSION_CREATION_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFPMPSESSION_CREATION_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFPMPSESSION_CREATION_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFPMPSESSION_CREATION_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFPMPSESSION_CREATION_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFPOLICYMANAGER_ACTION(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PEACTION_NO: MFPOLICYMANAGER_ACTION = MFPOLICYMANAGER_ACTION(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PEACTION_PLAY: MFPOLICYMANAGER_ACTION = MFPOLICYMANAGER_ACTION(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PEACTION_COPY: MFPOLICYMANAGER_ACTION = MFPOLICYMANAGER_ACTION(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PEACTION_EXPORT: MFPOLICYMANAGER_ACTION = MFPOLICYMANAGER_ACTION(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PEACTION_EXTRACT: MFPOLICYMANAGER_ACTION = MFPOLICYMANAGER_ACTION(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PEACTION_RESERVED1: MFPOLICYMANAGER_ACTION = MFPOLICYMANAGER_ACTION(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PEACTION_RESERVED2: MFPOLICYMANAGER_ACTION = MFPOLICYMANAGER_ACTION(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PEACTION_RESERVED3: MFPOLICYMANAGER_ACTION = MFPOLICYMANAGER_ACTION(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PEACTION_LAST: MFPOLICYMANAGER_ACTION = MFPOLICYMANAGER_ACTION(7i32);
impl ::core::marker::Copy for MFPOLICYMANAGER_ACTION {}
impl ::core::clone::Clone for MFPOLICYMANAGER_ACTION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFPOLICYMANAGER_ACTION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFPOLICYMANAGER_ACTION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFPOLICYMANAGER_ACTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFPOLICYMANAGER_ACTION").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFP_CREATION_OPTIONS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_OPTION_NONE: MFP_CREATION_OPTIONS = MFP_CREATION_OPTIONS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_OPTION_FREE_THREADED_CALLBACK: MFP_CREATION_OPTIONS = MFP_CREATION_OPTIONS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_OPTION_NO_MMCSS: MFP_CREATION_OPTIONS = MFP_CREATION_OPTIONS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_OPTION_NO_REMOTE_DESKTOP_OPTIMIZATION: MFP_CREATION_OPTIONS = MFP_CREATION_OPTIONS(4i32);
impl ::core::marker::Copy for MFP_CREATION_OPTIONS {}
impl ::core::clone::Clone for MFP_CREATION_OPTIONS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFP_CREATION_OPTIONS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFP_CREATION_OPTIONS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFP_CREATION_OPTIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFP_CREATION_OPTIONS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFP_EVENT_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_EVENT_TYPE_PLAY: MFP_EVENT_TYPE = MFP_EVENT_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_EVENT_TYPE_PAUSE: MFP_EVENT_TYPE = MFP_EVENT_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_EVENT_TYPE_STOP: MFP_EVENT_TYPE = MFP_EVENT_TYPE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_EVENT_TYPE_POSITION_SET: MFP_EVENT_TYPE = MFP_EVENT_TYPE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_EVENT_TYPE_RATE_SET: MFP_EVENT_TYPE = MFP_EVENT_TYPE(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_EVENT_TYPE_MEDIAITEM_CREATED: MFP_EVENT_TYPE = MFP_EVENT_TYPE(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_EVENT_TYPE_MEDIAITEM_SET: MFP_EVENT_TYPE = MFP_EVENT_TYPE(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_EVENT_TYPE_FRAME_STEP: MFP_EVENT_TYPE = MFP_EVENT_TYPE(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_EVENT_TYPE_MEDIAITEM_CLEARED: MFP_EVENT_TYPE = MFP_EVENT_TYPE(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_EVENT_TYPE_MF: MFP_EVENT_TYPE = MFP_EVENT_TYPE(9i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_EVENT_TYPE_ERROR: MFP_EVENT_TYPE = MFP_EVENT_TYPE(10i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_EVENT_TYPE_PLAYBACK_ENDED: MFP_EVENT_TYPE = MFP_EVENT_TYPE(11i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_EVENT_TYPE_ACQUIRE_USER_CREDENTIAL: MFP_EVENT_TYPE = MFP_EVENT_TYPE(12i32);
impl ::core::marker::Copy for MFP_EVENT_TYPE {}
impl ::core::clone::Clone for MFP_EVENT_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFP_EVENT_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFP_EVENT_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFP_EVENT_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFP_EVENT_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFP_MEDIAPLAYER_STATE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_MEDIAPLAYER_STATE_EMPTY: MFP_MEDIAPLAYER_STATE = MFP_MEDIAPLAYER_STATE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_MEDIAPLAYER_STATE_STOPPED: MFP_MEDIAPLAYER_STATE = MFP_MEDIAPLAYER_STATE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_MEDIAPLAYER_STATE_PLAYING: MFP_MEDIAPLAYER_STATE = MFP_MEDIAPLAYER_STATE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_MEDIAPLAYER_STATE_PAUSED: MFP_MEDIAPLAYER_STATE = MFP_MEDIAPLAYER_STATE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_MEDIAPLAYER_STATE_SHUTDOWN: MFP_MEDIAPLAYER_STATE = MFP_MEDIAPLAYER_STATE(4i32);
impl ::core::marker::Copy for MFP_MEDIAPLAYER_STATE {}
impl ::core::clone::Clone for MFP_MEDIAPLAYER_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFP_MEDIAPLAYER_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFP_MEDIAPLAYER_STATE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFP_MEDIAPLAYER_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFP_MEDIAPLAYER_STATE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFRATE_DIRECTION(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFRATE_FORWARD: MFRATE_DIRECTION = MFRATE_DIRECTION(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFRATE_REVERSE: MFRATE_DIRECTION = MFRATE_DIRECTION(1i32);
impl ::core::marker::Copy for MFRATE_DIRECTION {}
impl ::core::clone::Clone for MFRATE_DIRECTION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFRATE_DIRECTION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFRATE_DIRECTION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFRATE_DIRECTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFRATE_DIRECTION").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFSESSION_GETFULLTOPOLOGY_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSESSION_GETFULLTOPOLOGY_CURRENT: MFSESSION_GETFULLTOPOLOGY_FLAGS = MFSESSION_GETFULLTOPOLOGY_FLAGS(1i32);
impl ::core::marker::Copy for MFSESSION_GETFULLTOPOLOGY_FLAGS {}
impl ::core::clone::Clone for MFSESSION_GETFULLTOPOLOGY_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFSESSION_GETFULLTOPOLOGY_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFSESSION_GETFULLTOPOLOGY_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFSESSION_GETFULLTOPOLOGY_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFSESSION_GETFULLTOPOLOGY_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFSESSION_SETTOPOLOGY_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSESSION_SETTOPOLOGY_IMMEDIATE: MFSESSION_SETTOPOLOGY_FLAGS = MFSESSION_SETTOPOLOGY_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSESSION_SETTOPOLOGY_NORESOLUTION: MFSESSION_SETTOPOLOGY_FLAGS = MFSESSION_SETTOPOLOGY_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSESSION_SETTOPOLOGY_CLEAR_CURRENT: MFSESSION_SETTOPOLOGY_FLAGS = MFSESSION_SETTOPOLOGY_FLAGS(4i32);
impl ::core::marker::Copy for MFSESSION_SETTOPOLOGY_FLAGS {}
impl ::core::clone::Clone for MFSESSION_SETTOPOLOGY_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFSESSION_SETTOPOLOGY_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFSESSION_SETTOPOLOGY_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFSESSION_SETTOPOLOGY_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFSESSION_SETTOPOLOGY_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFSHUTDOWN_STATUS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSHUTDOWN_INITIATED: MFSHUTDOWN_STATUS = MFSHUTDOWN_STATUS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSHUTDOWN_COMPLETED: MFSHUTDOWN_STATUS = MFSHUTDOWN_STATUS(1i32);
impl ::core::marker::Copy for MFSHUTDOWN_STATUS {}
impl ::core::clone::Clone for MFSHUTDOWN_STATUS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFSHUTDOWN_STATUS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFSHUTDOWN_STATUS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFSHUTDOWN_STATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFSHUTDOWN_STATUS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFSINK_WMDRMACTION(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSINK_WMDRMACTION_UNDEFINED: MFSINK_WMDRMACTION = MFSINK_WMDRMACTION(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSINK_WMDRMACTION_ENCODE: MFSINK_WMDRMACTION = MFSINK_WMDRMACTION(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSINK_WMDRMACTION_TRANSCODE: MFSINK_WMDRMACTION = MFSINK_WMDRMACTION(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSINK_WMDRMACTION_TRANSCRYPT: MFSINK_WMDRMACTION = MFSINK_WMDRMACTION(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSINK_WMDRMACTION_LAST: MFSINK_WMDRMACTION = MFSINK_WMDRMACTION(3i32);
impl ::core::marker::Copy for MFSINK_WMDRMACTION {}
impl ::core::clone::Clone for MFSINK_WMDRMACTION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFSINK_WMDRMACTION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFSINK_WMDRMACTION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFSINK_WMDRMACTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFSINK_WMDRMACTION").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFSTREAMSINK_MARKER_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSTREAMSINK_MARKER_DEFAULT: MFSTREAMSINK_MARKER_TYPE = MFSTREAMSINK_MARKER_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSTREAMSINK_MARKER_ENDOFSEGMENT: MFSTREAMSINK_MARKER_TYPE = MFSTREAMSINK_MARKER_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSTREAMSINK_MARKER_TICK: MFSTREAMSINK_MARKER_TYPE = MFSTREAMSINK_MARKER_TYPE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSTREAMSINK_MARKER_EVENT: MFSTREAMSINK_MARKER_TYPE = MFSTREAMSINK_MARKER_TYPE(3i32);
impl ::core::marker::Copy for MFSTREAMSINK_MARKER_TYPE {}
impl ::core::clone::Clone for MFSTREAMSINK_MARKER_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFSTREAMSINK_MARKER_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFSTREAMSINK_MARKER_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFSTREAMSINK_MARKER_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFSTREAMSINK_MARKER_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFSampleAllocatorUsage(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleAllocatorUsage_UsesProvidedAllocator: MFSampleAllocatorUsage = MFSampleAllocatorUsage(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleAllocatorUsage_UsesCustomAllocator: MFSampleAllocatorUsage = MFSampleAllocatorUsage(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleAllocatorUsage_DoesNotAllocate: MFSampleAllocatorUsage = MFSampleAllocatorUsage(2i32);
impl ::core::marker::Copy for MFSampleAllocatorUsage {}
impl ::core::clone::Clone for MFSampleAllocatorUsage {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFSampleAllocatorUsage {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFSampleAllocatorUsage {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFSampleAllocatorUsage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFSampleAllocatorUsage").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFSampleEncryptionProtectionScheme(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_NONE: MFSampleEncryptionProtectionScheme = MFSampleEncryptionProtectionScheme(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_AES_CTR: MFSampleEncryptionProtectionScheme = MFSampleEncryptionProtectionScheme(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_AES_CBC: MFSampleEncryptionProtectionScheme = MFSampleEncryptionProtectionScheme(2i32);
impl ::core::marker::Copy for MFSampleEncryptionProtectionScheme {}
impl ::core::clone::Clone for MFSampleEncryptionProtectionScheme {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFSampleEncryptionProtectionScheme {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFSampleEncryptionProtectionScheme {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFSampleEncryptionProtectionScheme {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFSampleEncryptionProtectionScheme").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFSensorDeviceMode(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSensorDeviceMode_Controller: MFSensorDeviceMode = MFSensorDeviceMode(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSensorDeviceMode_Shared: MFSensorDeviceMode = MFSensorDeviceMode(1i32);
impl ::core::marker::Copy for MFSensorDeviceMode {}
impl ::core::clone::Clone for MFSensorDeviceMode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFSensorDeviceMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFSensorDeviceMode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFSensorDeviceMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFSensorDeviceMode").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFSensorDeviceType(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSensorDeviceType_Unknown: MFSensorDeviceType = MFSensorDeviceType(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSensorDeviceType_Device: MFSensorDeviceType = MFSensorDeviceType(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSensorDeviceType_MediaSource: MFSensorDeviceType = MFSensorDeviceType(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSensorDeviceType_FrameProvider: MFSensorDeviceType = MFSensorDeviceType(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSensorDeviceType_SensorTransform: MFSensorDeviceType = MFSensorDeviceType(4i32);
impl ::core::marker::Copy for MFSensorDeviceType {}
impl ::core::clone::Clone for MFSensorDeviceType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFSensorDeviceType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFSensorDeviceType {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFSensorDeviceType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFSensorDeviceType").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFSensorStreamType(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSensorStreamType_Unknown: MFSensorStreamType = MFSensorStreamType(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSensorStreamType_Input: MFSensorStreamType = MFSensorStreamType(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSensorStreamType_Output: MFSensorStreamType = MFSensorStreamType(2i32);
impl ::core::marker::Copy for MFSensorStreamType {}
impl ::core::clone::Clone for MFSensorStreamType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFSensorStreamType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFSensorStreamType {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFSensorStreamType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFSensorStreamType").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFSequencerTopologyFlags(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const SequencerTopologyFlags_Last: MFSequencerTopologyFlags = MFSequencerTopologyFlags(1i32);
impl ::core::marker::Copy for MFSequencerTopologyFlags {}
impl ::core::clone::Clone for MFSequencerTopologyFlags {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFSequencerTopologyFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFSequencerTopologyFlags {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFSequencerTopologyFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFSequencerTopologyFlags").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFStandardVideoFormat(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFStdVideoFormat_reserved: MFStandardVideoFormat = MFStandardVideoFormat(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFStdVideoFormat_NTSC: MFStandardVideoFormat = MFStandardVideoFormat(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFStdVideoFormat_PAL: MFStandardVideoFormat = MFStandardVideoFormat(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFStdVideoFormat_DVD_NTSC: MFStandardVideoFormat = MFStandardVideoFormat(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFStdVideoFormat_DVD_PAL: MFStandardVideoFormat = MFStandardVideoFormat(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFStdVideoFormat_DV_PAL: MFStandardVideoFormat = MFStandardVideoFormat(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFStdVideoFormat_DV_NTSC: MFStandardVideoFormat = MFStandardVideoFormat(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFStdVideoFormat_ATSC_SD480i: MFStandardVideoFormat = MFStandardVideoFormat(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFStdVideoFormat_ATSC_HD1080i: MFStandardVideoFormat = MFStandardVideoFormat(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFStdVideoFormat_ATSC_HD720p: MFStandardVideoFormat = MFStandardVideoFormat(9i32);
impl ::core::marker::Copy for MFStandardVideoFormat {}
impl ::core::clone::Clone for MFStandardVideoFormat {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFStandardVideoFormat {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFStandardVideoFormat {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFStandardVideoFormat {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFStandardVideoFormat").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFTIMER_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFTIMER_RELATIVE: MFTIMER_FLAGS = MFTIMER_FLAGS(1i32);
impl ::core::marker::Copy for MFTIMER_FLAGS {}
impl ::core::clone::Clone for MFTIMER_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFTIMER_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFTIMER_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFTIMER_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFTIMER_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFTOPOLOGY_DXVA_MODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFTOPOLOGY_DXVA_DEFAULT: MFTOPOLOGY_DXVA_MODE = MFTOPOLOGY_DXVA_MODE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFTOPOLOGY_DXVA_NONE: MFTOPOLOGY_DXVA_MODE = MFTOPOLOGY_DXVA_MODE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFTOPOLOGY_DXVA_FULL: MFTOPOLOGY_DXVA_MODE = MFTOPOLOGY_DXVA_MODE(2i32);
impl ::core::marker::Copy for MFTOPOLOGY_DXVA_MODE {}
impl ::core::clone::Clone for MFTOPOLOGY_DXVA_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFTOPOLOGY_DXVA_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFTOPOLOGY_DXVA_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFTOPOLOGY_DXVA_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFTOPOLOGY_DXVA_MODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFTOPOLOGY_HARDWARE_MODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFTOPOLOGY_HWMODE_SOFTWARE_ONLY: MFTOPOLOGY_HARDWARE_MODE = MFTOPOLOGY_HARDWARE_MODE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFTOPOLOGY_HWMODE_USE_HARDWARE: MFTOPOLOGY_HARDWARE_MODE = MFTOPOLOGY_HARDWARE_MODE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFTOPOLOGY_HWMODE_USE_ONLY_HARDWARE: MFTOPOLOGY_HARDWARE_MODE = MFTOPOLOGY_HARDWARE_MODE(2i32);
impl ::core::marker::Copy for MFTOPOLOGY_HARDWARE_MODE {}
impl ::core::clone::Clone for MFTOPOLOGY_HARDWARE_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFTOPOLOGY_HARDWARE_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFTOPOLOGY_HARDWARE_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFTOPOLOGY_HARDWARE_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFTOPOLOGY_HARDWARE_MODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFT_AUDIO_DECODER_DEGRADATION_REASON(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_AUDIO_DECODER_DEGRADATION_REASON_NONE: MFT_AUDIO_DECODER_DEGRADATION_REASON = MFT_AUDIO_DECODER_DEGRADATION_REASON(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_AUDIO_DECODER_DEGRADATION_REASON_LICENSING_REQUIREMENT: MFT_AUDIO_DECODER_DEGRADATION_REASON = MFT_AUDIO_DECODER_DEGRADATION_REASON(1i32);
impl ::core::marker::Copy for MFT_AUDIO_DECODER_DEGRADATION_REASON {}
impl ::core::clone::Clone for MFT_AUDIO_DECODER_DEGRADATION_REASON {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFT_AUDIO_DECODER_DEGRADATION_REASON {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFT_AUDIO_DECODER_DEGRADATION_REASON {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFT_AUDIO_DECODER_DEGRADATION_REASON {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFT_AUDIO_DECODER_DEGRADATION_REASON").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFT_AUDIO_DECODER_DEGRADATION_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_AUDIO_DECODER_DEGRADATION_TYPE_NONE: MFT_AUDIO_DECODER_DEGRADATION_TYPE = MFT_AUDIO_DECODER_DEGRADATION_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX2CHANNEL: MFT_AUDIO_DECODER_DEGRADATION_TYPE = MFT_AUDIO_DECODER_DEGRADATION_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX6CHANNEL: MFT_AUDIO_DECODER_DEGRADATION_TYPE = MFT_AUDIO_DECODER_DEGRADATION_TYPE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX8CHANNEL: MFT_AUDIO_DECODER_DEGRADATION_TYPE = MFT_AUDIO_DECODER_DEGRADATION_TYPE(3i32);
impl ::core::marker::Copy for MFT_AUDIO_DECODER_DEGRADATION_TYPE {}
impl ::core::clone::Clone for MFT_AUDIO_DECODER_DEGRADATION_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFT_AUDIO_DECODER_DEGRADATION_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFT_AUDIO_DECODER_DEGRADATION_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFT_AUDIO_DECODER_DEGRADATION_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFT_AUDIO_DECODER_DEGRADATION_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFT_DRAIN_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_DRAIN_PRODUCE_TAILS: MFT_DRAIN_TYPE = MFT_DRAIN_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_DRAIN_NO_TAILS: MFT_DRAIN_TYPE = MFT_DRAIN_TYPE(1i32);
impl ::core::marker::Copy for MFT_DRAIN_TYPE {}
impl ::core::clone::Clone for MFT_DRAIN_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFT_DRAIN_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFT_DRAIN_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFT_DRAIN_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFT_DRAIN_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFT_ENUM_FLAG(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_ENUM_FLAG_SYNCMFT: MFT_ENUM_FLAG = MFT_ENUM_FLAG(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_ENUM_FLAG_ASYNCMFT: MFT_ENUM_FLAG = MFT_ENUM_FLAG(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_ENUM_FLAG_HARDWARE: MFT_ENUM_FLAG = MFT_ENUM_FLAG(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_ENUM_FLAG_FIELDOFUSE: MFT_ENUM_FLAG = MFT_ENUM_FLAG(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_ENUM_FLAG_LOCALMFT: MFT_ENUM_FLAG = MFT_ENUM_FLAG(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_ENUM_FLAG_TRANSCODE_ONLY: MFT_ENUM_FLAG = MFT_ENUM_FLAG(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_ENUM_FLAG_SORTANDFILTER: MFT_ENUM_FLAG = MFT_ENUM_FLAG(64i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_ENUM_FLAG_SORTANDFILTER_APPROVED_ONLY: MFT_ENUM_FLAG = MFT_ENUM_FLAG(192i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_ENUM_FLAG_SORTANDFILTER_WEB_ONLY: MFT_ENUM_FLAG = MFT_ENUM_FLAG(320i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_ENUM_FLAG_SORTANDFILTER_WEB_ONLY_EDGEMODE: MFT_ENUM_FLAG = MFT_ENUM_FLAG(576i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_ENUM_FLAG_UNTRUSTED_STOREMFT: MFT_ENUM_FLAG = MFT_ENUM_FLAG(1024i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_ENUM_FLAG_ALL: MFT_ENUM_FLAG = MFT_ENUM_FLAG(63i32);
impl ::core::marker::Copy for MFT_ENUM_FLAG {}
impl ::core::clone::Clone for MFT_ENUM_FLAG {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFT_ENUM_FLAG {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFT_ENUM_FLAG {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFT_ENUM_FLAG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFT_ENUM_FLAG").field(&self.0).finish()
    }
}
impl MFT_ENUM_FLAG {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for MFT_ENUM_FLAG {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for MFT_ENUM_FLAG {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for MFT_ENUM_FLAG {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for MFT_ENUM_FLAG {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for MFT_ENUM_FLAG {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFT_MESSAGE_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_MESSAGE_COMMAND_FLUSH: MFT_MESSAGE_TYPE = MFT_MESSAGE_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_MESSAGE_COMMAND_DRAIN: MFT_MESSAGE_TYPE = MFT_MESSAGE_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_MESSAGE_SET_D3D_MANAGER: MFT_MESSAGE_TYPE = MFT_MESSAGE_TYPE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_MESSAGE_DROP_SAMPLES: MFT_MESSAGE_TYPE = MFT_MESSAGE_TYPE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_MESSAGE_COMMAND_TICK: MFT_MESSAGE_TYPE = MFT_MESSAGE_TYPE(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_MESSAGE_NOTIFY_BEGIN_STREAMING: MFT_MESSAGE_TYPE = MFT_MESSAGE_TYPE(268435456i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_MESSAGE_NOTIFY_END_STREAMING: MFT_MESSAGE_TYPE = MFT_MESSAGE_TYPE(268435457i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_MESSAGE_NOTIFY_END_OF_STREAM: MFT_MESSAGE_TYPE = MFT_MESSAGE_TYPE(268435458i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_MESSAGE_NOTIFY_START_OF_STREAM: MFT_MESSAGE_TYPE = MFT_MESSAGE_TYPE(268435459i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_MESSAGE_NOTIFY_RELEASE_RESOURCES: MFT_MESSAGE_TYPE = MFT_MESSAGE_TYPE(268435460i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_MESSAGE_NOTIFY_REACQUIRE_RESOURCES: MFT_MESSAGE_TYPE = MFT_MESSAGE_TYPE(268435461i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_MESSAGE_NOTIFY_EVENT: MFT_MESSAGE_TYPE = MFT_MESSAGE_TYPE(268435462i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_MESSAGE_COMMAND_SET_OUTPUT_STREAM_STATE: MFT_MESSAGE_TYPE = MFT_MESSAGE_TYPE(268435463i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_MESSAGE_COMMAND_FLUSH_OUTPUT_STREAM: MFT_MESSAGE_TYPE = MFT_MESSAGE_TYPE(268435464i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_MESSAGE_COMMAND_MARKER: MFT_MESSAGE_TYPE = MFT_MESSAGE_TYPE(536870912i32);
impl ::core::marker::Copy for MFT_MESSAGE_TYPE {}
impl ::core::clone::Clone for MFT_MESSAGE_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFT_MESSAGE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFT_MESSAGE_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFT_MESSAGE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFT_MESSAGE_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVP_MESSAGE_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVP_MESSAGE_FLUSH: MFVP_MESSAGE_TYPE = MFVP_MESSAGE_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVP_MESSAGE_INVALIDATEMEDIATYPE: MFVP_MESSAGE_TYPE = MFVP_MESSAGE_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVP_MESSAGE_PROCESSINPUTNOTIFY: MFVP_MESSAGE_TYPE = MFVP_MESSAGE_TYPE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVP_MESSAGE_BEGINSTREAMING: MFVP_MESSAGE_TYPE = MFVP_MESSAGE_TYPE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVP_MESSAGE_ENDSTREAMING: MFVP_MESSAGE_TYPE = MFVP_MESSAGE_TYPE(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVP_MESSAGE_ENDOFSTREAM: MFVP_MESSAGE_TYPE = MFVP_MESSAGE_TYPE(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVP_MESSAGE_STEP: MFVP_MESSAGE_TYPE = MFVP_MESSAGE_TYPE(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVP_MESSAGE_CANCELSTEP: MFVP_MESSAGE_TYPE = MFVP_MESSAGE_TYPE(7i32);
impl ::core::marker::Copy for MFVP_MESSAGE_TYPE {}
impl ::core::clone::Clone for MFVP_MESSAGE_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVP_MESSAGE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVP_MESSAGE_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVP_MESSAGE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVP_MESSAGE_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVideo3DFormat(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideo3DSampleFormat_BaseView: MFVideo3DFormat = MFVideo3DFormat(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideo3DSampleFormat_MultiView: MFVideo3DFormat = MFVideo3DFormat(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideo3DSampleFormat_Packed_LeftRight: MFVideo3DFormat = MFVideo3DFormat(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideo3DSampleFormat_Packed_TopBottom: MFVideo3DFormat = MFVideo3DFormat(3i32);
impl ::core::marker::Copy for MFVideo3DFormat {}
impl ::core::clone::Clone for MFVideo3DFormat {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVideo3DFormat {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVideo3DFormat {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVideo3DFormat {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVideo3DFormat").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVideo3DSampleFormat(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_3DVideo_MultiView: MFVideo3DSampleFormat = MFVideo3DSampleFormat(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFSampleExtension_3DVideo_Packed: MFVideo3DSampleFormat = MFVideo3DSampleFormat(0i32);
impl ::core::marker::Copy for MFVideo3DSampleFormat {}
impl ::core::clone::Clone for MFVideo3DSampleFormat {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVideo3DSampleFormat {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVideo3DSampleFormat {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVideo3DSampleFormat {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVideo3DSampleFormat").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVideoAlphaBitmapFlags(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoAlphaBitmap_EntireDDS: MFVideoAlphaBitmapFlags = MFVideoAlphaBitmapFlags(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoAlphaBitmap_SrcColorKey: MFVideoAlphaBitmapFlags = MFVideoAlphaBitmapFlags(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoAlphaBitmap_SrcRect: MFVideoAlphaBitmapFlags = MFVideoAlphaBitmapFlags(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoAlphaBitmap_DestRect: MFVideoAlphaBitmapFlags = MFVideoAlphaBitmapFlags(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoAlphaBitmap_FilterMode: MFVideoAlphaBitmapFlags = MFVideoAlphaBitmapFlags(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoAlphaBitmap_Alpha: MFVideoAlphaBitmapFlags = MFVideoAlphaBitmapFlags(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoAlphaBitmap_BitMask: MFVideoAlphaBitmapFlags = MFVideoAlphaBitmapFlags(63i32);
impl ::core::marker::Copy for MFVideoAlphaBitmapFlags {}
impl ::core::clone::Clone for MFVideoAlphaBitmapFlags {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVideoAlphaBitmapFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVideoAlphaBitmapFlags {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVideoAlphaBitmapFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVideoAlphaBitmapFlags").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVideoAspectRatioMode(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoARMode_None: MFVideoAspectRatioMode = MFVideoAspectRatioMode(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoARMode_PreservePicture: MFVideoAspectRatioMode = MFVideoAspectRatioMode(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoARMode_PreservePixel: MFVideoAspectRatioMode = MFVideoAspectRatioMode(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoARMode_NonLinearStretch: MFVideoAspectRatioMode = MFVideoAspectRatioMode(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoARMode_Mask: MFVideoAspectRatioMode = MFVideoAspectRatioMode(7i32);
impl ::core::marker::Copy for MFVideoAspectRatioMode {}
impl ::core::clone::Clone for MFVideoAspectRatioMode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVideoAspectRatioMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVideoAspectRatioMode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVideoAspectRatioMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVideoAspectRatioMode").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVideoChromaSubsampling(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoChromaSubsampling_Unknown: MFVideoChromaSubsampling = MFVideoChromaSubsampling(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoChromaSubsampling_ProgressiveChroma: MFVideoChromaSubsampling = MFVideoChromaSubsampling(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoChromaSubsampling_Horizontally_Cosited: MFVideoChromaSubsampling = MFVideoChromaSubsampling(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoChromaSubsampling_Vertically_Cosited: MFVideoChromaSubsampling = MFVideoChromaSubsampling(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoChromaSubsampling_Vertically_AlignedChromaPlanes: MFVideoChromaSubsampling = MFVideoChromaSubsampling(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoChromaSubsampling_MPEG2: MFVideoChromaSubsampling = MFVideoChromaSubsampling(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoChromaSubsampling_MPEG1: MFVideoChromaSubsampling = MFVideoChromaSubsampling(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoChromaSubsampling_DV_PAL: MFVideoChromaSubsampling = MFVideoChromaSubsampling(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoChromaSubsampling_Cosited: MFVideoChromaSubsampling = MFVideoChromaSubsampling(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoChromaSubsampling_Last: MFVideoChromaSubsampling = MFVideoChromaSubsampling(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoChromaSubsampling_ForceDWORD: MFVideoChromaSubsampling = MFVideoChromaSubsampling(2147483647i32);
impl ::core::marker::Copy for MFVideoChromaSubsampling {}
impl ::core::clone::Clone for MFVideoChromaSubsampling {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVideoChromaSubsampling {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVideoChromaSubsampling {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVideoChromaSubsampling {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVideoChromaSubsampling").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVideoDRMFlags(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoDRMFlag_None: MFVideoDRMFlags = MFVideoDRMFlags(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoDRMFlag_AnalogProtected: MFVideoDRMFlags = MFVideoDRMFlags(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoDRMFlag_DigitallyProtected: MFVideoDRMFlags = MFVideoDRMFlags(2i32);
impl ::core::marker::Copy for MFVideoDRMFlags {}
impl ::core::clone::Clone for MFVideoDRMFlags {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVideoDRMFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVideoDRMFlags {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVideoDRMFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVideoDRMFlags").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVideoDSPMode(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoDSPMode_Passthrough: MFVideoDSPMode = MFVideoDSPMode(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoDSPMode_Stabilization: MFVideoDSPMode = MFVideoDSPMode(4i32);
impl ::core::marker::Copy for MFVideoDSPMode {}
impl ::core::clone::Clone for MFVideoDSPMode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVideoDSPMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVideoDSPMode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVideoDSPMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVideoDSPMode").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVideoFlags(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFlag_PAD_TO_Mask: MFVideoFlags = MFVideoFlags(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFlag_PAD_TO_None: MFVideoFlags = MFVideoFlags(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFlag_PAD_TO_4x3: MFVideoFlags = MFVideoFlags(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFlag_PAD_TO_16x9: MFVideoFlags = MFVideoFlags(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFlag_SrcContentHintMask: MFVideoFlags = MFVideoFlags(28i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFlag_SrcContentHintNone: MFVideoFlags = MFVideoFlags(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFlag_SrcContentHint16x9: MFVideoFlags = MFVideoFlags(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFlag_SrcContentHint235_1: MFVideoFlags = MFVideoFlags(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFlag_AnalogProtected: MFVideoFlags = MFVideoFlags(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFlag_DigitallyProtected: MFVideoFlags = MFVideoFlags(64i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFlag_ProgressiveContent: MFVideoFlags = MFVideoFlags(128i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFlag_FieldRepeatCountMask: MFVideoFlags = MFVideoFlags(1792i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFlag_FieldRepeatCountShift: MFVideoFlags = MFVideoFlags(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFlag_ProgressiveSeqReset: MFVideoFlags = MFVideoFlags(2048i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFlag_PanScanEnabled: MFVideoFlags = MFVideoFlags(131072i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFlag_LowerFieldFirst: MFVideoFlags = MFVideoFlags(262144i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFlag_BottomUpLinearRep: MFVideoFlags = MFVideoFlags(524288i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFlags_DXVASurface: MFVideoFlags = MFVideoFlags(1048576i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFlags_RenderTargetSurface: MFVideoFlags = MFVideoFlags(4194304i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoFlags_ForceQWORD: MFVideoFlags = MFVideoFlags(2147483647i32);
impl ::core::marker::Copy for MFVideoFlags {}
impl ::core::clone::Clone for MFVideoFlags {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVideoFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVideoFlags {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVideoFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVideoFlags").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVideoInterlaceMode(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoInterlace_Unknown: MFVideoInterlaceMode = MFVideoInterlaceMode(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoInterlace_Progressive: MFVideoInterlaceMode = MFVideoInterlaceMode(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoInterlace_FieldInterleavedUpperFirst: MFVideoInterlaceMode = MFVideoInterlaceMode(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoInterlace_FieldInterleavedLowerFirst: MFVideoInterlaceMode = MFVideoInterlaceMode(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoInterlace_FieldSingleUpper: MFVideoInterlaceMode = MFVideoInterlaceMode(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoInterlace_FieldSingleLower: MFVideoInterlaceMode = MFVideoInterlaceMode(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoInterlace_MixedInterlaceOrProgressive: MFVideoInterlaceMode = MFVideoInterlaceMode(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoInterlace_Last: MFVideoInterlaceMode = MFVideoInterlaceMode(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoInterlace_ForceDWORD: MFVideoInterlaceMode = MFVideoInterlaceMode(2147483647i32);
impl ::core::marker::Copy for MFVideoInterlaceMode {}
impl ::core::clone::Clone for MFVideoInterlaceMode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVideoInterlaceMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVideoInterlaceMode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVideoInterlaceMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVideoInterlaceMode").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVideoLighting(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoLighting_Unknown: MFVideoLighting = MFVideoLighting(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoLighting_bright: MFVideoLighting = MFVideoLighting(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoLighting_office: MFVideoLighting = MFVideoLighting(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoLighting_dim: MFVideoLighting = MFVideoLighting(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoLighting_dark: MFVideoLighting = MFVideoLighting(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoLighting_Last: MFVideoLighting = MFVideoLighting(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoLighting_ForceDWORD: MFVideoLighting = MFVideoLighting(2147483647i32);
impl ::core::marker::Copy for MFVideoLighting {}
impl ::core::clone::Clone for MFVideoLighting {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVideoLighting {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVideoLighting {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVideoLighting {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVideoLighting").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVideoMixPrefs(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoMixPrefs_ForceHalfInterlace: MFVideoMixPrefs = MFVideoMixPrefs(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoMixPrefs_AllowDropToHalfInterlace: MFVideoMixPrefs = MFVideoMixPrefs(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoMixPrefs_AllowDropToBob: MFVideoMixPrefs = MFVideoMixPrefs(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoMixPrefs_ForceBob: MFVideoMixPrefs = MFVideoMixPrefs(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoMixPrefs_EnableRotation: MFVideoMixPrefs = MFVideoMixPrefs(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoMixPrefs_Mask: MFVideoMixPrefs = MFVideoMixPrefs(31i32);
impl ::core::marker::Copy for MFVideoMixPrefs {}
impl ::core::clone::Clone for MFVideoMixPrefs {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVideoMixPrefs {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVideoMixPrefs {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVideoMixPrefs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVideoMixPrefs").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVideoPadFlags(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoPadFlag_PAD_TO_None: MFVideoPadFlags = MFVideoPadFlags(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoPadFlag_PAD_TO_4x3: MFVideoPadFlags = MFVideoPadFlags(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoPadFlag_PAD_TO_16x9: MFVideoPadFlags = MFVideoPadFlags(2i32);
impl ::core::marker::Copy for MFVideoPadFlags {}
impl ::core::clone::Clone for MFVideoPadFlags {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVideoPadFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVideoPadFlags {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVideoPadFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVideoPadFlags").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVideoPrimaries(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoPrimaries_Unknown: MFVideoPrimaries = MFVideoPrimaries(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoPrimaries_reserved: MFVideoPrimaries = MFVideoPrimaries(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoPrimaries_BT709: MFVideoPrimaries = MFVideoPrimaries(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoPrimaries_BT470_2_SysM: MFVideoPrimaries = MFVideoPrimaries(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoPrimaries_BT470_2_SysBG: MFVideoPrimaries = MFVideoPrimaries(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoPrimaries_SMPTE170M: MFVideoPrimaries = MFVideoPrimaries(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoPrimaries_SMPTE240M: MFVideoPrimaries = MFVideoPrimaries(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoPrimaries_EBU3213: MFVideoPrimaries = MFVideoPrimaries(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoPrimaries_SMPTE_C: MFVideoPrimaries = MFVideoPrimaries(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoPrimaries_BT2020: MFVideoPrimaries = MFVideoPrimaries(9i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoPrimaries_XYZ: MFVideoPrimaries = MFVideoPrimaries(10i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoPrimaries_DCI_P3: MFVideoPrimaries = MFVideoPrimaries(11i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoPrimaries_ACES: MFVideoPrimaries = MFVideoPrimaries(12i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoPrimaries_Last: MFVideoPrimaries = MFVideoPrimaries(13i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoPrimaries_ForceDWORD: MFVideoPrimaries = MFVideoPrimaries(2147483647i32);
impl ::core::marker::Copy for MFVideoPrimaries {}
impl ::core::clone::Clone for MFVideoPrimaries {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVideoPrimaries {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVideoPrimaries {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVideoPrimaries {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVideoPrimaries").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVideoRenderPrefs(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoRenderPrefs_DoNotRenderBorder: MFVideoRenderPrefs = MFVideoRenderPrefs(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoRenderPrefs_DoNotClipToDevice: MFVideoRenderPrefs = MFVideoRenderPrefs(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoRenderPrefs_AllowOutputThrottling: MFVideoRenderPrefs = MFVideoRenderPrefs(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoRenderPrefs_ForceOutputThrottling: MFVideoRenderPrefs = MFVideoRenderPrefs(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoRenderPrefs_ForceBatching: MFVideoRenderPrefs = MFVideoRenderPrefs(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoRenderPrefs_AllowBatching: MFVideoRenderPrefs = MFVideoRenderPrefs(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoRenderPrefs_ForceScaling: MFVideoRenderPrefs = MFVideoRenderPrefs(64i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoRenderPrefs_AllowScaling: MFVideoRenderPrefs = MFVideoRenderPrefs(128i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoRenderPrefs_DoNotRepaintOnStop: MFVideoRenderPrefs = MFVideoRenderPrefs(256i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoRenderPrefs_Mask: MFVideoRenderPrefs = MFVideoRenderPrefs(511i32);
impl ::core::marker::Copy for MFVideoRenderPrefs {}
impl ::core::clone::Clone for MFVideoRenderPrefs {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVideoRenderPrefs {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVideoRenderPrefs {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVideoRenderPrefs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVideoRenderPrefs").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVideoRotationFormat(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoRotationFormat_0: MFVideoRotationFormat = MFVideoRotationFormat(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoRotationFormat_90: MFVideoRotationFormat = MFVideoRotationFormat(90i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoRotationFormat_180: MFVideoRotationFormat = MFVideoRotationFormat(180i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoRotationFormat_270: MFVideoRotationFormat = MFVideoRotationFormat(270i32);
impl ::core::marker::Copy for MFVideoRotationFormat {}
impl ::core::clone::Clone for MFVideoRotationFormat {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVideoRotationFormat {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVideoRotationFormat {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVideoRotationFormat {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVideoRotationFormat").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVideoSphericalFormat(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoSphericalFormat_Unsupported: MFVideoSphericalFormat = MFVideoSphericalFormat(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoSphericalFormat_Equirectangular: MFVideoSphericalFormat = MFVideoSphericalFormat(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoSphericalFormat_CubeMap: MFVideoSphericalFormat = MFVideoSphericalFormat(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoSphericalFormat_3DMesh: MFVideoSphericalFormat = MFVideoSphericalFormat(3i32);
impl ::core::marker::Copy for MFVideoSphericalFormat {}
impl ::core::clone::Clone for MFVideoSphericalFormat {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVideoSphericalFormat {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVideoSphericalFormat {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVideoSphericalFormat {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVideoSphericalFormat").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVideoSphericalProjectionMode(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoSphericalProjectionMode_Spherical: MFVideoSphericalProjectionMode = MFVideoSphericalProjectionMode(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoSphericalProjectionMode_Flat: MFVideoSphericalProjectionMode = MFVideoSphericalProjectionMode(1i32);
impl ::core::marker::Copy for MFVideoSphericalProjectionMode {}
impl ::core::clone::Clone for MFVideoSphericalProjectionMode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVideoSphericalProjectionMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVideoSphericalProjectionMode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVideoSphericalProjectionMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVideoSphericalProjectionMode").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVideoSrcContentHintFlags(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoSrcContentHintFlag_None: MFVideoSrcContentHintFlags = MFVideoSrcContentHintFlags(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoSrcContentHintFlag_16x9: MFVideoSrcContentHintFlags = MFVideoSrcContentHintFlags(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoSrcContentHintFlag_235_1: MFVideoSrcContentHintFlags = MFVideoSrcContentHintFlags(2i32);
impl ::core::marker::Copy for MFVideoSrcContentHintFlags {}
impl ::core::clone::Clone for MFVideoSrcContentHintFlags {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVideoSrcContentHintFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVideoSrcContentHintFlags {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVideoSrcContentHintFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVideoSrcContentHintFlags").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVideoTransferFunction(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransFunc_Unknown: MFVideoTransferFunction = MFVideoTransferFunction(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransFunc_10: MFVideoTransferFunction = MFVideoTransferFunction(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransFunc_18: MFVideoTransferFunction = MFVideoTransferFunction(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransFunc_20: MFVideoTransferFunction = MFVideoTransferFunction(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransFunc_22: MFVideoTransferFunction = MFVideoTransferFunction(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransFunc_709: MFVideoTransferFunction = MFVideoTransferFunction(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransFunc_240M: MFVideoTransferFunction = MFVideoTransferFunction(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransFunc_sRGB: MFVideoTransferFunction = MFVideoTransferFunction(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransFunc_28: MFVideoTransferFunction = MFVideoTransferFunction(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransFunc_Log_100: MFVideoTransferFunction = MFVideoTransferFunction(9i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransFunc_Log_316: MFVideoTransferFunction = MFVideoTransferFunction(10i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransFunc_709_sym: MFVideoTransferFunction = MFVideoTransferFunction(11i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransFunc_2020_const: MFVideoTransferFunction = MFVideoTransferFunction(12i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransFunc_2020: MFVideoTransferFunction = MFVideoTransferFunction(13i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransFunc_26: MFVideoTransferFunction = MFVideoTransferFunction(14i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransFunc_2084: MFVideoTransferFunction = MFVideoTransferFunction(15i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransFunc_HLG: MFVideoTransferFunction = MFVideoTransferFunction(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransFunc_10_rel: MFVideoTransferFunction = MFVideoTransferFunction(17i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransFunc_Last: MFVideoTransferFunction = MFVideoTransferFunction(18i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransFunc_ForceDWORD: MFVideoTransferFunction = MFVideoTransferFunction(2147483647i32);
impl ::core::marker::Copy for MFVideoTransferFunction {}
impl ::core::clone::Clone for MFVideoTransferFunction {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVideoTransferFunction {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVideoTransferFunction {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVideoTransferFunction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVideoTransferFunction").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVideoTransferMatrix(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransferMatrix_Unknown: MFVideoTransferMatrix = MFVideoTransferMatrix(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransferMatrix_BT709: MFVideoTransferMatrix = MFVideoTransferMatrix(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransferMatrix_BT601: MFVideoTransferMatrix = MFVideoTransferMatrix(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransferMatrix_SMPTE240M: MFVideoTransferMatrix = MFVideoTransferMatrix(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransferMatrix_BT2020_10: MFVideoTransferMatrix = MFVideoTransferMatrix(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransferMatrix_BT2020_12: MFVideoTransferMatrix = MFVideoTransferMatrix(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransferMatrix_Last: MFVideoTransferMatrix = MFVideoTransferMatrix(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVideoTransferMatrix_ForceDWORD: MFVideoTransferMatrix = MFVideoTransferMatrix(2147483647i32);
impl ::core::marker::Copy for MFVideoTransferMatrix {}
impl ::core::clone::Clone for MFVideoTransferMatrix {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVideoTransferMatrix {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVideoTransferMatrix {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVideoTransferMatrix {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVideoTransferMatrix").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVirtualCameraAccess(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVirtualCameraAccess_CurrentUser: MFVirtualCameraAccess = MFVirtualCameraAccess(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVirtualCameraAccess_AllUsers: MFVirtualCameraAccess = MFVirtualCameraAccess(1i32);
impl ::core::marker::Copy for MFVirtualCameraAccess {}
impl ::core::clone::Clone for MFVirtualCameraAccess {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVirtualCameraAccess {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVirtualCameraAccess {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVirtualCameraAccess {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVirtualCameraAccess").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVirtualCameraLifetime(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVirtualCameraLifetime_Session: MFVirtualCameraLifetime = MFVirtualCameraLifetime(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVirtualCameraLifetime_System: MFVirtualCameraLifetime = MFVirtualCameraLifetime(1i32);
impl ::core::marker::Copy for MFVirtualCameraLifetime {}
impl ::core::clone::Clone for MFVirtualCameraLifetime {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVirtualCameraLifetime {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVirtualCameraLifetime {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVirtualCameraLifetime {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVirtualCameraLifetime").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFVirtualCameraType(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFVirtualCameraType_SoftwareCameraSource: MFVirtualCameraType = MFVirtualCameraType(0i32);
impl ::core::marker::Copy for MFVirtualCameraType {}
impl ::core::clone::Clone for MFVirtualCameraType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFVirtualCameraType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFVirtualCameraType {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFVirtualCameraType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFVirtualCameraType").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MFWaveFormatExConvertFlags(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFWaveFormatExConvertFlag_Normal: MFWaveFormatExConvertFlags = MFWaveFormatExConvertFlags(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFWaveFormatExConvertFlag_ForceExtensible: MFWaveFormatExConvertFlags = MFWaveFormatExConvertFlags(1i32);
impl ::core::marker::Copy for MFWaveFormatExConvertFlags {}
impl ::core::clone::Clone for MFWaveFormatExConvertFlags {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MFWaveFormatExConvertFlags {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MFWaveFormatExConvertFlags {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MFWaveFormatExConvertFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MFWaveFormatExConvertFlags").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_ACTIVATE_CUSTOM_MIXER(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ACTIVATE_CUSTOM_MIXER_ALLOWFAIL: MF_ACTIVATE_CUSTOM_MIXER = MF_ACTIVATE_CUSTOM_MIXER(1i32);
impl ::core::marker::Copy for MF_ACTIVATE_CUSTOM_MIXER {}
impl ::core::clone::Clone for MF_ACTIVATE_CUSTOM_MIXER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_ACTIVATE_CUSTOM_MIXER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_ACTIVATE_CUSTOM_MIXER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_ACTIVATE_CUSTOM_MIXER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_ACTIVATE_CUSTOM_MIXER").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_ACTIVATE_CUSTOM_PRESENTER(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ACTIVATE_CUSTOM_PRESENTER_ALLOWFAIL: MF_ACTIVATE_CUSTOM_PRESENTER = MF_ACTIVATE_CUSTOM_PRESENTER(1i32);
impl ::core::marker::Copy for MF_ACTIVATE_CUSTOM_PRESENTER {}
impl ::core::clone::Clone for MF_ACTIVATE_CUSTOM_PRESENTER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_ACTIVATE_CUSTOM_PRESENTER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_ACTIVATE_CUSTOM_PRESENTER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_ACTIVATE_CUSTOM_PRESENTER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_ACTIVATE_CUSTOM_PRESENTER").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_ATTRIBUTES_MATCH_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ATTRIBUTES_MATCH_OUR_ITEMS: MF_ATTRIBUTES_MATCH_TYPE = MF_ATTRIBUTES_MATCH_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ATTRIBUTES_MATCH_THEIR_ITEMS: MF_ATTRIBUTES_MATCH_TYPE = MF_ATTRIBUTES_MATCH_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ATTRIBUTES_MATCH_ALL_ITEMS: MF_ATTRIBUTES_MATCH_TYPE = MF_ATTRIBUTES_MATCH_TYPE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ATTRIBUTES_MATCH_INTERSECTION: MF_ATTRIBUTES_MATCH_TYPE = MF_ATTRIBUTES_MATCH_TYPE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ATTRIBUTES_MATCH_SMALLER: MF_ATTRIBUTES_MATCH_TYPE = MF_ATTRIBUTES_MATCH_TYPE(4i32);
impl ::core::marker::Copy for MF_ATTRIBUTES_MATCH_TYPE {}
impl ::core::clone::Clone for MF_ATTRIBUTES_MATCH_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_ATTRIBUTES_MATCH_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_ATTRIBUTES_MATCH_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_ATTRIBUTES_MATCH_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_ATTRIBUTES_MATCH_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_ATTRIBUTE_SERIALIZE_OPTIONS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ATTRIBUTE_SERIALIZE_UNKNOWN_BYREF: MF_ATTRIBUTE_SERIALIZE_OPTIONS = MF_ATTRIBUTE_SERIALIZE_OPTIONS(1i32);
impl ::core::marker::Copy for MF_ATTRIBUTE_SERIALIZE_OPTIONS {}
impl ::core::clone::Clone for MF_ATTRIBUTE_SERIALIZE_OPTIONS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_ATTRIBUTE_SERIALIZE_OPTIONS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_ATTRIBUTE_SERIALIZE_OPTIONS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_ATTRIBUTE_SERIALIZE_OPTIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_ATTRIBUTE_SERIALIZE_OPTIONS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_ATTRIBUTE_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ATTRIBUTE_UINT32: MF_ATTRIBUTE_TYPE = MF_ATTRIBUTE_TYPE(19i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ATTRIBUTE_UINT64: MF_ATTRIBUTE_TYPE = MF_ATTRIBUTE_TYPE(21i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ATTRIBUTE_DOUBLE: MF_ATTRIBUTE_TYPE = MF_ATTRIBUTE_TYPE(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ATTRIBUTE_GUID: MF_ATTRIBUTE_TYPE = MF_ATTRIBUTE_TYPE(72i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ATTRIBUTE_STRING: MF_ATTRIBUTE_TYPE = MF_ATTRIBUTE_TYPE(31i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ATTRIBUTE_BLOB: MF_ATTRIBUTE_TYPE = MF_ATTRIBUTE_TYPE(4113i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ATTRIBUTE_IUNKNOWN: MF_ATTRIBUTE_TYPE = MF_ATTRIBUTE_TYPE(13i32);
impl ::core::marker::Copy for MF_ATTRIBUTE_TYPE {}
impl ::core::clone::Clone for MF_ATTRIBUTE_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_ATTRIBUTE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_ATTRIBUTE_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_ATTRIBUTE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_ATTRIBUTE_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_AUVRHP_ROOMMODEL(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const VRHP_SMALLROOM: MF_AUVRHP_ROOMMODEL = MF_AUVRHP_ROOMMODEL(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const VRHP_MEDIUMROOM: MF_AUVRHP_ROOMMODEL = MF_AUVRHP_ROOMMODEL(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const VRHP_BIGROOM: MF_AUVRHP_ROOMMODEL = MF_AUVRHP_ROOMMODEL(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const VRHP_CUSTUMIZEDROOM: MF_AUVRHP_ROOMMODEL = MF_AUVRHP_ROOMMODEL(3i32);
impl ::core::marker::Copy for MF_AUVRHP_ROOMMODEL {}
impl ::core::clone::Clone for MF_AUVRHP_ROOMMODEL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_AUVRHP_ROOMMODEL {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_AUVRHP_ROOMMODEL {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_AUVRHP_ROOMMODEL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_AUVRHP_ROOMMODEL").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_CAMERA_CONTROL_CONFIGURATION_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAMERA_CONTROL_CONFIGURATION_TYPE_PRESTART: MF_CAMERA_CONTROL_CONFIGURATION_TYPE = MF_CAMERA_CONTROL_CONFIGURATION_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAMERA_CONTROL_CONFIGURATION_TYPE_POSTSTART: MF_CAMERA_CONTROL_CONFIGURATION_TYPE = MF_CAMERA_CONTROL_CONFIGURATION_TYPE(1i32);
impl ::core::marker::Copy for MF_CAMERA_CONTROL_CONFIGURATION_TYPE {}
impl ::core::clone::Clone for MF_CAMERA_CONTROL_CONFIGURATION_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_CAMERA_CONTROL_CONFIGURATION_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_CAMERA_CONTROL_CONFIGURATION_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_CAMERA_CONTROL_CONFIGURATION_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_CAMERA_CONTROL_CONFIGURATION_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_CAPTURE_ENGINE_AUDIO_PROCESSING_MODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_AUDIO_PROCESSING_DEFAULT: MF_CAPTURE_ENGINE_AUDIO_PROCESSING_MODE = MF_CAPTURE_ENGINE_AUDIO_PROCESSING_MODE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_AUDIO_PROCESSING_RAW: MF_CAPTURE_ENGINE_AUDIO_PROCESSING_MODE = MF_CAPTURE_ENGINE_AUDIO_PROCESSING_MODE(1i32);
impl ::core::marker::Copy for MF_CAPTURE_ENGINE_AUDIO_PROCESSING_MODE {}
impl ::core::clone::Clone for MF_CAPTURE_ENGINE_AUDIO_PROCESSING_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_CAPTURE_ENGINE_AUDIO_PROCESSING_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_CAPTURE_ENGINE_AUDIO_PROCESSING_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_CAPTURE_ENGINE_AUDIO_PROCESSING_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_CAPTURE_ENGINE_AUDIO_PROCESSING_MODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_CAPTURE_ENGINE_DEVICE_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_DEVICE_TYPE_AUDIO: MF_CAPTURE_ENGINE_DEVICE_TYPE = MF_CAPTURE_ENGINE_DEVICE_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_DEVICE_TYPE_VIDEO: MF_CAPTURE_ENGINE_DEVICE_TYPE = MF_CAPTURE_ENGINE_DEVICE_TYPE(1i32);
impl ::core::marker::Copy for MF_CAPTURE_ENGINE_DEVICE_TYPE {}
impl ::core::clone::Clone for MF_CAPTURE_ENGINE_DEVICE_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_CAPTURE_ENGINE_DEVICE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_CAPTURE_ENGINE_DEVICE_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_CAPTURE_ENGINE_DEVICE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_CAPTURE_ENGINE_DEVICE_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_OTHER: MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE = MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_COMMUNICATIONS: MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE = MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_MEDIA: MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE = MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_GAMECHAT: MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE = MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_SPEECH: MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE = MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_FARFIELDSPEECH: MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE = MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_UNIFORMSPEECH: MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE = MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_VOICETYPING: MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE = MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE(7i32);
impl ::core::marker::Copy for MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE {}
impl ::core::clone::Clone for MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_CAPTURE_ENGINE_SINK_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_SINK_TYPE_RECORD: MF_CAPTURE_ENGINE_SINK_TYPE = MF_CAPTURE_ENGINE_SINK_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_SINK_TYPE_PREVIEW: MF_CAPTURE_ENGINE_SINK_TYPE = MF_CAPTURE_ENGINE_SINK_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_SINK_TYPE_PHOTO: MF_CAPTURE_ENGINE_SINK_TYPE = MF_CAPTURE_ENGINE_SINK_TYPE(2i32);
impl ::core::marker::Copy for MF_CAPTURE_ENGINE_SINK_TYPE {}
impl ::core::clone::Clone for MF_CAPTURE_ENGINE_SINK_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_CAPTURE_ENGINE_SINK_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_CAPTURE_ENGINE_SINK_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_CAPTURE_ENGINE_SINK_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_CAPTURE_ENGINE_SINK_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_CAPTURE_ENGINE_SOURCE(pub u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_PREVIEW: MF_CAPTURE_ENGINE_SOURCE = MF_CAPTURE_ENGINE_SOURCE(4294967290u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_RECORD: MF_CAPTURE_ENGINE_SOURCE = MF_CAPTURE_ENGINE_SOURCE(4294967289u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_PHOTO: MF_CAPTURE_ENGINE_SOURCE = MF_CAPTURE_ENGINE_SOURCE(4294967288u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_AUDIO: MF_CAPTURE_ENGINE_SOURCE = MF_CAPTURE_ENGINE_SOURCE(4294967287u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_METADATA: MF_CAPTURE_ENGINE_SOURCE = MF_CAPTURE_ENGINE_SOURCE(4294967286u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_MEDIASOURCE: MF_CAPTURE_ENGINE_SOURCE = MF_CAPTURE_ENGINE_SOURCE(4294967295u32);
impl ::core::marker::Copy for MF_CAPTURE_ENGINE_SOURCE {}
impl ::core::clone::Clone for MF_CAPTURE_ENGINE_SOURCE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_CAPTURE_ENGINE_SOURCE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_CAPTURE_ENGINE_SOURCE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_CAPTURE_ENGINE_SOURCE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_CAPTURE_ENGINE_SOURCE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_CAPTURE_ENGINE_STREAM_CATEGORY(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_STREAM_CATEGORY_VIDEO_PREVIEW: MF_CAPTURE_ENGINE_STREAM_CATEGORY = MF_CAPTURE_ENGINE_STREAM_CATEGORY(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_STREAM_CATEGORY_VIDEO_CAPTURE: MF_CAPTURE_ENGINE_STREAM_CATEGORY = MF_CAPTURE_ENGINE_STREAM_CATEGORY(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_STREAM_CATEGORY_PHOTO_INDEPENDENT: MF_CAPTURE_ENGINE_STREAM_CATEGORY = MF_CAPTURE_ENGINE_STREAM_CATEGORY(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_STREAM_CATEGORY_PHOTO_DEPENDENT: MF_CAPTURE_ENGINE_STREAM_CATEGORY = MF_CAPTURE_ENGINE_STREAM_CATEGORY(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_STREAM_CATEGORY_AUDIO: MF_CAPTURE_ENGINE_STREAM_CATEGORY = MF_CAPTURE_ENGINE_STREAM_CATEGORY(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_STREAM_CATEGORY_UNSUPPORTED: MF_CAPTURE_ENGINE_STREAM_CATEGORY = MF_CAPTURE_ENGINE_STREAM_CATEGORY(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CAPTURE_ENGINE_STREAM_CATEGORY_METADATA: MF_CAPTURE_ENGINE_STREAM_CATEGORY = MF_CAPTURE_ENGINE_STREAM_CATEGORY(6i32);
impl ::core::marker::Copy for MF_CAPTURE_ENGINE_STREAM_CATEGORY {}
impl ::core::clone::Clone for MF_CAPTURE_ENGINE_STREAM_CATEGORY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_CAPTURE_ENGINE_STREAM_CATEGORY {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_CAPTURE_ENGINE_STREAM_CATEGORY {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_CAPTURE_ENGINE_STREAM_CATEGORY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_CAPTURE_ENGINE_STREAM_CATEGORY").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_CONNECT_METHOD(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CONNECT_DIRECT: MF_CONNECT_METHOD = MF_CONNECT_METHOD(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CONNECT_ALLOW_CONVERTER: MF_CONNECT_METHOD = MF_CONNECT_METHOD(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CONNECT_ALLOW_DECODER: MF_CONNECT_METHOD = MF_CONNECT_METHOD(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CONNECT_RESOLVE_INDEPENDENT_OUTPUTTYPES: MF_CONNECT_METHOD = MF_CONNECT_METHOD(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CONNECT_AS_OPTIONAL: MF_CONNECT_METHOD = MF_CONNECT_METHOD(65536i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CONNECT_AS_OPTIONAL_BRANCH: MF_CONNECT_METHOD = MF_CONNECT_METHOD(131072i32);
impl ::core::marker::Copy for MF_CONNECT_METHOD {}
impl ::core::clone::Clone for MF_CONNECT_METHOD {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_CONNECT_METHOD {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_CONNECT_METHOD {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_CONNECT_METHOD {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_CONNECT_METHOD").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_CROSS_ORIGIN_POLICY(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CROSS_ORIGIN_POLICY_NONE: MF_CROSS_ORIGIN_POLICY = MF_CROSS_ORIGIN_POLICY(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CROSS_ORIGIN_POLICY_ANONYMOUS: MF_CROSS_ORIGIN_POLICY = MF_CROSS_ORIGIN_POLICY(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_CROSS_ORIGIN_POLICY_USE_CREDENTIALS: MF_CROSS_ORIGIN_POLICY = MF_CROSS_ORIGIN_POLICY(2i32);
impl ::core::marker::Copy for MF_CROSS_ORIGIN_POLICY {}
impl ::core::clone::Clone for MF_CROSS_ORIGIN_POLICY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_CROSS_ORIGIN_POLICY {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_CROSS_ORIGIN_POLICY {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_CROSS_ORIGIN_POLICY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_CROSS_ORIGIN_POLICY").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_CUSTOM_DECODE_UNIT_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DECODE_UNIT_NAL: MF_CUSTOM_DECODE_UNIT_TYPE = MF_CUSTOM_DECODE_UNIT_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DECODE_UNIT_SEI: MF_CUSTOM_DECODE_UNIT_TYPE = MF_CUSTOM_DECODE_UNIT_TYPE(1i32);
impl ::core::marker::Copy for MF_CUSTOM_DECODE_UNIT_TYPE {}
impl ::core::clone::Clone for MF_CUSTOM_DECODE_UNIT_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_CUSTOM_DECODE_UNIT_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_CUSTOM_DECODE_UNIT_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_CUSTOM_DECODE_UNIT_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_CUSTOM_DECODE_UNIT_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_EVENT_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEUnknown: MF_EVENT_TYPE = MF_EVENT_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEError: MF_EVENT_TYPE = MF_EVENT_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEExtendedType: MF_EVENT_TYPE = MF_EVENT_TYPE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MENonFatalError: MF_EVENT_TYPE = MF_EVENT_TYPE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEGenericV1Anchor: MF_EVENT_TYPE = MF_EVENT_TYPE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESessionUnknown: MF_EVENT_TYPE = MF_EVENT_TYPE(100i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESessionTopologySet: MF_EVENT_TYPE = MF_EVENT_TYPE(101i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESessionTopologiesCleared: MF_EVENT_TYPE = MF_EVENT_TYPE(102i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESessionStarted: MF_EVENT_TYPE = MF_EVENT_TYPE(103i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESessionPaused: MF_EVENT_TYPE = MF_EVENT_TYPE(104i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESessionStopped: MF_EVENT_TYPE = MF_EVENT_TYPE(105i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESessionClosed: MF_EVENT_TYPE = MF_EVENT_TYPE(106i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESessionEnded: MF_EVENT_TYPE = MF_EVENT_TYPE(107i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESessionRateChanged: MF_EVENT_TYPE = MF_EVENT_TYPE(108i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESessionScrubSampleComplete: MF_EVENT_TYPE = MF_EVENT_TYPE(109i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESessionCapabilitiesChanged: MF_EVENT_TYPE = MF_EVENT_TYPE(110i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESessionTopologyStatus: MF_EVENT_TYPE = MF_EVENT_TYPE(111i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESessionNotifyPresentationTime: MF_EVENT_TYPE = MF_EVENT_TYPE(112i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MENewPresentation: MF_EVENT_TYPE = MF_EVENT_TYPE(113i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MELicenseAcquisitionStart: MF_EVENT_TYPE = MF_EVENT_TYPE(114i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MELicenseAcquisitionCompleted: MF_EVENT_TYPE = MF_EVENT_TYPE(115i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEIndividualizationStart: MF_EVENT_TYPE = MF_EVENT_TYPE(116i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEIndividualizationCompleted: MF_EVENT_TYPE = MF_EVENT_TYPE(117i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEEnablerProgress: MF_EVENT_TYPE = MF_EVENT_TYPE(118i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEEnablerCompleted: MF_EVENT_TYPE = MF_EVENT_TYPE(119i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEPolicyError: MF_EVENT_TYPE = MF_EVENT_TYPE(120i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEPolicyReport: MF_EVENT_TYPE = MF_EVENT_TYPE(121i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEBufferingStarted: MF_EVENT_TYPE = MF_EVENT_TYPE(122i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEBufferingStopped: MF_EVENT_TYPE = MF_EVENT_TYPE(123i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEConnectStart: MF_EVENT_TYPE = MF_EVENT_TYPE(124i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEConnectEnd: MF_EVENT_TYPE = MF_EVENT_TYPE(125i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEReconnectStart: MF_EVENT_TYPE = MF_EVENT_TYPE(126i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEReconnectEnd: MF_EVENT_TYPE = MF_EVENT_TYPE(127i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MERendererEvent: MF_EVENT_TYPE = MF_EVENT_TYPE(128i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESessionStreamSinkFormatChanged: MF_EVENT_TYPE = MF_EVENT_TYPE(129i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESessionV1Anchor: MF_EVENT_TYPE = MF_EVENT_TYPE(129i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESourceUnknown: MF_EVENT_TYPE = MF_EVENT_TYPE(200i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESourceStarted: MF_EVENT_TYPE = MF_EVENT_TYPE(201i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEStreamStarted: MF_EVENT_TYPE = MF_EVENT_TYPE(202i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESourceSeeked: MF_EVENT_TYPE = MF_EVENT_TYPE(203i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEStreamSeeked: MF_EVENT_TYPE = MF_EVENT_TYPE(204i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MENewStream: MF_EVENT_TYPE = MF_EVENT_TYPE(205i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEUpdatedStream: MF_EVENT_TYPE = MF_EVENT_TYPE(206i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESourceStopped: MF_EVENT_TYPE = MF_EVENT_TYPE(207i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEStreamStopped: MF_EVENT_TYPE = MF_EVENT_TYPE(208i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESourcePaused: MF_EVENT_TYPE = MF_EVENT_TYPE(209i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEStreamPaused: MF_EVENT_TYPE = MF_EVENT_TYPE(210i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEEndOfPresentation: MF_EVENT_TYPE = MF_EVENT_TYPE(211i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEEndOfStream: MF_EVENT_TYPE = MF_EVENT_TYPE(212i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEMediaSample: MF_EVENT_TYPE = MF_EVENT_TYPE(213i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEStreamTick: MF_EVENT_TYPE = MF_EVENT_TYPE(214i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEStreamThinMode: MF_EVENT_TYPE = MF_EVENT_TYPE(215i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEStreamFormatChanged: MF_EVENT_TYPE = MF_EVENT_TYPE(216i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESourceRateChanged: MF_EVENT_TYPE = MF_EVENT_TYPE(217i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEEndOfPresentationSegment: MF_EVENT_TYPE = MF_EVENT_TYPE(218i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESourceCharacteristicsChanged: MF_EVENT_TYPE = MF_EVENT_TYPE(219i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESourceRateChangeRequested: MF_EVENT_TYPE = MF_EVENT_TYPE(220i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESourceMetadataChanged: MF_EVENT_TYPE = MF_EVENT_TYPE(221i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESequencerSourceTopologyUpdated: MF_EVENT_TYPE = MF_EVENT_TYPE(222i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESourceV1Anchor: MF_EVENT_TYPE = MF_EVENT_TYPE(222i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESinkUnknown: MF_EVENT_TYPE = MF_EVENT_TYPE(300i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEStreamSinkStarted: MF_EVENT_TYPE = MF_EVENT_TYPE(301i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEStreamSinkStopped: MF_EVENT_TYPE = MF_EVENT_TYPE(302i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEStreamSinkPaused: MF_EVENT_TYPE = MF_EVENT_TYPE(303i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEStreamSinkRateChanged: MF_EVENT_TYPE = MF_EVENT_TYPE(304i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEStreamSinkRequestSample: MF_EVENT_TYPE = MF_EVENT_TYPE(305i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEStreamSinkMarker: MF_EVENT_TYPE = MF_EVENT_TYPE(306i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEStreamSinkPrerolled: MF_EVENT_TYPE = MF_EVENT_TYPE(307i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEStreamSinkScrubSampleComplete: MF_EVENT_TYPE = MF_EVENT_TYPE(308i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEStreamSinkFormatChanged: MF_EVENT_TYPE = MF_EVENT_TYPE(309i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEStreamSinkDeviceChanged: MF_EVENT_TYPE = MF_EVENT_TYPE(310i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEQualityNotify: MF_EVENT_TYPE = MF_EVENT_TYPE(311i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESinkInvalidated: MF_EVENT_TYPE = MF_EVENT_TYPE(312i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEAudioSessionNameChanged: MF_EVENT_TYPE = MF_EVENT_TYPE(313i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEAudioSessionVolumeChanged: MF_EVENT_TYPE = MF_EVENT_TYPE(314i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEAudioSessionDeviceRemoved: MF_EVENT_TYPE = MF_EVENT_TYPE(315i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEAudioSessionServerShutdown: MF_EVENT_TYPE = MF_EVENT_TYPE(316i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEAudioSessionGroupingParamChanged: MF_EVENT_TYPE = MF_EVENT_TYPE(317i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEAudioSessionIconChanged: MF_EVENT_TYPE = MF_EVENT_TYPE(318i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEAudioSessionFormatChanged: MF_EVENT_TYPE = MF_EVENT_TYPE(319i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEAudioSessionDisconnected: MF_EVENT_TYPE = MF_EVENT_TYPE(320i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEAudioSessionExclusiveModeOverride: MF_EVENT_TYPE = MF_EVENT_TYPE(321i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESinkV1Anchor: MF_EVENT_TYPE = MF_EVENT_TYPE(321i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MECaptureAudioSessionVolumeChanged: MF_EVENT_TYPE = MF_EVENT_TYPE(322i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MECaptureAudioSessionDeviceRemoved: MF_EVENT_TYPE = MF_EVENT_TYPE(323i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MECaptureAudioSessionFormatChanged: MF_EVENT_TYPE = MF_EVENT_TYPE(324i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MECaptureAudioSessionDisconnected: MF_EVENT_TYPE = MF_EVENT_TYPE(325i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MECaptureAudioSessionExclusiveModeOverride: MF_EVENT_TYPE = MF_EVENT_TYPE(326i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MECaptureAudioSessionServerShutdown: MF_EVENT_TYPE = MF_EVENT_TYPE(327i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MESinkV2Anchor: MF_EVENT_TYPE = MF_EVENT_TYPE(327i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const METrustUnknown: MF_EVENT_TYPE = MF_EVENT_TYPE(400i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEPolicyChanged: MF_EVENT_TYPE = MF_EVENT_TYPE(401i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEContentProtectionMessage: MF_EVENT_TYPE = MF_EVENT_TYPE(402i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEPolicySet: MF_EVENT_TYPE = MF_EVENT_TYPE(403i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const METrustV1Anchor: MF_EVENT_TYPE = MF_EVENT_TYPE(403i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEWMDRMLicenseBackupCompleted: MF_EVENT_TYPE = MF_EVENT_TYPE(500i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEWMDRMLicenseBackupProgress: MF_EVENT_TYPE = MF_EVENT_TYPE(501i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEWMDRMLicenseRestoreCompleted: MF_EVENT_TYPE = MF_EVENT_TYPE(502i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEWMDRMLicenseRestoreProgress: MF_EVENT_TYPE = MF_EVENT_TYPE(503i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEWMDRMLicenseAcquisitionCompleted: MF_EVENT_TYPE = MF_EVENT_TYPE(506i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEWMDRMIndividualizationCompleted: MF_EVENT_TYPE = MF_EVENT_TYPE(508i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEWMDRMIndividualizationProgress: MF_EVENT_TYPE = MF_EVENT_TYPE(513i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEWMDRMProximityCompleted: MF_EVENT_TYPE = MF_EVENT_TYPE(514i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEWMDRMLicenseStoreCleaned: MF_EVENT_TYPE = MF_EVENT_TYPE(515i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEWMDRMRevocationDownloadCompleted: MF_EVENT_TYPE = MF_EVENT_TYPE(516i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEWMDRMV1Anchor: MF_EVENT_TYPE = MF_EVENT_TYPE(516i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const METransformUnknown: MF_EVENT_TYPE = MF_EVENT_TYPE(600i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const METransformNeedInput: MF_EVENT_TYPE = MF_EVENT_TYPE(601i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const METransformHaveOutput: MF_EVENT_TYPE = MF_EVENT_TYPE(602i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const METransformDrainComplete: MF_EVENT_TYPE = MF_EVENT_TYPE(603i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const METransformMarker: MF_EVENT_TYPE = MF_EVENT_TYPE(604i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const METransformInputStreamStateChanged: MF_EVENT_TYPE = MF_EVENT_TYPE(605i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEByteStreamCharacteristicsChanged: MF_EVENT_TYPE = MF_EVENT_TYPE(700i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEVideoCaptureDeviceRemoved: MF_EVENT_TYPE = MF_EVENT_TYPE(800i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEVideoCaptureDevicePreempted: MF_EVENT_TYPE = MF_EVENT_TYPE(801i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEStreamSinkFormatInvalidated: MF_EVENT_TYPE = MF_EVENT_TYPE(802i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEEncodingParameters: MF_EVENT_TYPE = MF_EVENT_TYPE(803i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEContentProtectionMetadata: MF_EVENT_TYPE = MF_EVENT_TYPE(900i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEDeviceThermalStateChanged: MF_EVENT_TYPE = MF_EVENT_TYPE(950i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MEReservedMax: MF_EVENT_TYPE = MF_EVENT_TYPE(10000i32);
impl ::core::marker::Copy for MF_EVENT_TYPE {}
impl ::core::clone::Clone for MF_EVENT_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_EVENT_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_EVENT_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_EVENT_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_EVENT_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_FILE_ACCESSMODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ACCESSMODE_READ: MF_FILE_ACCESSMODE = MF_FILE_ACCESSMODE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ACCESSMODE_WRITE: MF_FILE_ACCESSMODE = MF_FILE_ACCESSMODE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_ACCESSMODE_READWRITE: MF_FILE_ACCESSMODE = MF_FILE_ACCESSMODE(3i32);
impl ::core::marker::Copy for MF_FILE_ACCESSMODE {}
impl ::core::clone::Clone for MF_FILE_ACCESSMODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_FILE_ACCESSMODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_FILE_ACCESSMODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_FILE_ACCESSMODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_FILE_ACCESSMODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_FILE_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_FILEFLAGS_NONE: MF_FILE_FLAGS = MF_FILE_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_FILEFLAGS_NOBUFFERING: MF_FILE_FLAGS = MF_FILE_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_FILEFLAGS_ALLOW_WRITE_SHARING: MF_FILE_FLAGS = MF_FILE_FLAGS(2i32);
impl ::core::marker::Copy for MF_FILE_FLAGS {}
impl ::core::clone::Clone for MF_FILE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_FILE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_FILE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_FILE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_FILE_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_FILE_OPENMODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_OPENMODE_FAIL_IF_NOT_EXIST: MF_FILE_OPENMODE = MF_FILE_OPENMODE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_OPENMODE_FAIL_IF_EXIST: MF_FILE_OPENMODE = MF_FILE_OPENMODE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_OPENMODE_RESET_IF_EXIST: MF_FILE_OPENMODE = MF_FILE_OPENMODE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_OPENMODE_APPEND_IF_EXIST: MF_FILE_OPENMODE = MF_FILE_OPENMODE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_OPENMODE_DELETE_IF_EXIST: MF_FILE_OPENMODE = MF_FILE_OPENMODE(4i32);
impl ::core::marker::Copy for MF_FILE_OPENMODE {}
impl ::core::clone::Clone for MF_FILE_OPENMODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_FILE_OPENMODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_FILE_OPENMODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_FILE_OPENMODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_FILE_OPENMODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_HDCP_STATUS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_HDCP_STATUS_ON: MF_HDCP_STATUS = MF_HDCP_STATUS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_HDCP_STATUS_OFF: MF_HDCP_STATUS = MF_HDCP_STATUS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_HDCP_STATUS_ON_WITH_TYPE_ENFORCEMENT: MF_HDCP_STATUS = MF_HDCP_STATUS(2i32);
impl ::core::marker::Copy for MF_HDCP_STATUS {}
impl ::core::clone::Clone for MF_HDCP_STATUS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_HDCP_STATUS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_HDCP_STATUS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_HDCP_STATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_HDCP_STATUS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MEDIAKEYSESSION_MESSAGETYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_REQUEST: MF_MEDIAKEYSESSION_MESSAGETYPE = MF_MEDIAKEYSESSION_MESSAGETYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_RENEWAL: MF_MEDIAKEYSESSION_MESSAGETYPE = MF_MEDIAKEYSESSION_MESSAGETYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_RELEASE: MF_MEDIAKEYSESSION_MESSAGETYPE = MF_MEDIAKEYSESSION_MESSAGETYPE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAKEYSESSION_MESSAGETYPE_INDIVIDUALIZATION_REQUEST: MF_MEDIAKEYSESSION_MESSAGETYPE = MF_MEDIAKEYSESSION_MESSAGETYPE(3i32);
impl ::core::marker::Copy for MF_MEDIAKEYSESSION_MESSAGETYPE {}
impl ::core::clone::Clone for MF_MEDIAKEYSESSION_MESSAGETYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MEDIAKEYSESSION_MESSAGETYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MEDIAKEYSESSION_MESSAGETYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MEDIAKEYSESSION_MESSAGETYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MEDIAKEYSESSION_MESSAGETYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MEDIAKEYSESSION_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAKEYSESSION_TYPE_TEMPORARY: MF_MEDIAKEYSESSION_TYPE = MF_MEDIAKEYSESSION_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAKEYSESSION_TYPE_PERSISTENT_LICENSE: MF_MEDIAKEYSESSION_TYPE = MF_MEDIAKEYSESSION_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAKEYSESSION_TYPE_PERSISTENT_RELEASE_MESSAGE: MF_MEDIAKEYSESSION_TYPE = MF_MEDIAKEYSESSION_TYPE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAKEYSESSION_TYPE_PERSISTENT_USAGE_RECORD: MF_MEDIAKEYSESSION_TYPE = MF_MEDIAKEYSESSION_TYPE(3i32);
impl ::core::marker::Copy for MF_MEDIAKEYSESSION_TYPE {}
impl ::core::clone::Clone for MF_MEDIAKEYSESSION_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MEDIAKEYSESSION_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MEDIAKEYSESSION_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MEDIAKEYSESSION_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MEDIAKEYSESSION_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MEDIAKEYS_REQUIREMENT(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAKEYS_REQUIREMENT_REQUIRED: MF_MEDIAKEYS_REQUIREMENT = MF_MEDIAKEYS_REQUIREMENT(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAKEYS_REQUIREMENT_OPTIONAL: MF_MEDIAKEYS_REQUIREMENT = MF_MEDIAKEYS_REQUIREMENT(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAKEYS_REQUIREMENT_NOT_ALLOWED: MF_MEDIAKEYS_REQUIREMENT = MF_MEDIAKEYS_REQUIREMENT(3i32);
impl ::core::marker::Copy for MF_MEDIAKEYS_REQUIREMENT {}
impl ::core::clone::Clone for MF_MEDIAKEYS_REQUIREMENT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MEDIAKEYS_REQUIREMENT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MEDIAKEYS_REQUIREMENT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MEDIAKEYS_REQUIREMENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MEDIAKEYS_REQUIREMENT").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MEDIAKEY_STATUS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAKEY_STATUS_USABLE: MF_MEDIAKEY_STATUS = MF_MEDIAKEY_STATUS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAKEY_STATUS_EXPIRED: MF_MEDIAKEY_STATUS = MF_MEDIAKEY_STATUS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAKEY_STATUS_OUTPUT_DOWNSCALED: MF_MEDIAKEY_STATUS = MF_MEDIAKEY_STATUS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAKEY_STATUS_OUTPUT_NOT_ALLOWED: MF_MEDIAKEY_STATUS = MF_MEDIAKEY_STATUS(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAKEY_STATUS_STATUS_PENDING: MF_MEDIAKEY_STATUS = MF_MEDIAKEY_STATUS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAKEY_STATUS_INTERNAL_ERROR: MF_MEDIAKEY_STATUS = MF_MEDIAKEY_STATUS(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAKEY_STATUS_RELEASED: MF_MEDIAKEY_STATUS = MF_MEDIAKEY_STATUS(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAKEY_STATUS_OUTPUT_RESTRICTED: MF_MEDIAKEY_STATUS = MF_MEDIAKEY_STATUS(7i32);
impl ::core::marker::Copy for MF_MEDIAKEY_STATUS {}
impl ::core::clone::Clone for MF_MEDIAKEY_STATUS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MEDIAKEY_STATUS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MEDIAKEY_STATUS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MEDIAKEY_STATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MEDIAKEY_STATUS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MEDIA_ENGINE_CANPLAY(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_CANPLAY_NOT_SUPPORTED: MF_MEDIA_ENGINE_CANPLAY = MF_MEDIA_ENGINE_CANPLAY(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_CANPLAY_MAYBE: MF_MEDIA_ENGINE_CANPLAY = MF_MEDIA_ENGINE_CANPLAY(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_CANPLAY_PROBABLY: MF_MEDIA_ENGINE_CANPLAY = MF_MEDIA_ENGINE_CANPLAY(2i32);
impl ::core::marker::Copy for MF_MEDIA_ENGINE_CANPLAY {}
impl ::core::clone::Clone for MF_MEDIA_ENGINE_CANPLAY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MEDIA_ENGINE_CANPLAY {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MEDIA_ENGINE_CANPLAY {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MEDIA_ENGINE_CANPLAY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MEDIA_ENGINE_CANPLAY").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MEDIA_ENGINE_CREATEFLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_AUDIOONLY: MF_MEDIA_ENGINE_CREATEFLAGS = MF_MEDIA_ENGINE_CREATEFLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_WAITFORSTABLE_STATE: MF_MEDIA_ENGINE_CREATEFLAGS = MF_MEDIA_ENGINE_CREATEFLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_FORCEMUTE: MF_MEDIA_ENGINE_CREATEFLAGS = MF_MEDIA_ENGINE_CREATEFLAGS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_REAL_TIME_MODE: MF_MEDIA_ENGINE_CREATEFLAGS = MF_MEDIA_ENGINE_CREATEFLAGS(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_DISABLE_LOCAL_PLUGINS: MF_MEDIA_ENGINE_CREATEFLAGS = MF_MEDIA_ENGINE_CREATEFLAGS(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_CREATEFLAGS_MASK: MF_MEDIA_ENGINE_CREATEFLAGS = MF_MEDIA_ENGINE_CREATEFLAGS(31i32);
impl ::core::marker::Copy for MF_MEDIA_ENGINE_CREATEFLAGS {}
impl ::core::clone::Clone for MF_MEDIA_ENGINE_CREATEFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MEDIA_ENGINE_CREATEFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MEDIA_ENGINE_CREATEFLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MEDIA_ENGINE_CREATEFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MEDIA_ENGINE_CREATEFLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MEDIA_ENGINE_ERR(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_ERR_NOERROR: MF_MEDIA_ENGINE_ERR = MF_MEDIA_ENGINE_ERR(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_ERR_ABORTED: MF_MEDIA_ENGINE_ERR = MF_MEDIA_ENGINE_ERR(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_ERR_NETWORK: MF_MEDIA_ENGINE_ERR = MF_MEDIA_ENGINE_ERR(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_ERR_DECODE: MF_MEDIA_ENGINE_ERR = MF_MEDIA_ENGINE_ERR(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_ERR_SRC_NOT_SUPPORTED: MF_MEDIA_ENGINE_ERR = MF_MEDIA_ENGINE_ERR(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_ERR_ENCRYPTED: MF_MEDIA_ENGINE_ERR = MF_MEDIA_ENGINE_ERR(5i32);
impl ::core::marker::Copy for MF_MEDIA_ENGINE_ERR {}
impl ::core::clone::Clone for MF_MEDIA_ENGINE_ERR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MEDIA_ENGINE_ERR {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MEDIA_ENGINE_ERR {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MEDIA_ENGINE_ERR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MEDIA_ENGINE_ERR").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MEDIA_ENGINE_EVENT(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_LOADSTART: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_PROGRESS: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_SUSPEND: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_ABORT: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_ERROR: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_EMPTIED: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_STALLED: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_PLAY: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_PAUSE: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(9i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_LOADEDMETADATA: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(10i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_LOADEDDATA: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(11i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_WAITING: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(12i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_PLAYING: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(13i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_CANPLAY: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(14i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_CANPLAYTHROUGH: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(15i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_SEEKING: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_SEEKED: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(17i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_TIMEUPDATE: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(18i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_ENDED: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(19i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_RATECHANGE: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(20i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_DURATIONCHANGE: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(21i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_VOLUMECHANGE: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(22i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_FORMATCHANGE: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(1000i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_PURGEQUEUEDEVENTS: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(1001i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_TIMELINE_MARKER: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(1002i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_BALANCECHANGE: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(1003i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_DOWNLOADCOMPLETE: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(1004i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_BUFFERINGSTARTED: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(1005i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_BUFFERINGENDED: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(1006i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_FRAMESTEPCOMPLETED: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(1007i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_NOTIFYSTABLESTATE: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(1008i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_FIRSTFRAMEREADY: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(1009i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_TRACKSCHANGE: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(1010i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_OPMINFO: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(1011i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_RESOURCELOST: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(1012i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_DELAYLOADEVENT_CHANGED: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(1013i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_STREAMRENDERINGERROR: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(1014i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_SUPPORTEDRATES_CHANGED: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(1015i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EVENT_AUDIOENDPOINTCHANGE: MF_MEDIA_ENGINE_EVENT = MF_MEDIA_ENGINE_EVENT(1016i32);
impl ::core::marker::Copy for MF_MEDIA_ENGINE_EVENT {}
impl ::core::clone::Clone for MF_MEDIA_ENGINE_EVENT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MEDIA_ENGINE_EVENT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MEDIA_ENGINE_EVENT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MEDIA_ENGINE_EVENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MEDIA_ENGINE_EVENT").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MEDIA_ENGINE_EXTENSION_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EXTENSION_TYPE_MEDIASOURCE: MF_MEDIA_ENGINE_EXTENSION_TYPE = MF_MEDIA_ENGINE_EXTENSION_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_EXTENSION_TYPE_BYTESTREAM: MF_MEDIA_ENGINE_EXTENSION_TYPE = MF_MEDIA_ENGINE_EXTENSION_TYPE(1i32);
impl ::core::marker::Copy for MF_MEDIA_ENGINE_EXTENSION_TYPE {}
impl ::core::clone::Clone for MF_MEDIA_ENGINE_EXTENSION_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MEDIA_ENGINE_EXTENSION_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MEDIA_ENGINE_EXTENSION_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MEDIA_ENGINE_EXTENSION_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MEDIA_ENGINE_EXTENSION_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_PROTECTED: MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS = MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_REQUIRES_SURFACE_PROTECTION: MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS = MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_REQUIRES_ANTI_SCREEN_SCRAPE_PROTECTION: MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS = MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS(4i32);
impl ::core::marker::Copy for MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS {}
impl ::core::clone::Clone for MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MEDIA_ENGINE_KEYERR(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAENGINE_KEYERR_UNKNOWN: MF_MEDIA_ENGINE_KEYERR = MF_MEDIA_ENGINE_KEYERR(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAENGINE_KEYERR_CLIENT: MF_MEDIA_ENGINE_KEYERR = MF_MEDIA_ENGINE_KEYERR(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAENGINE_KEYERR_SERVICE: MF_MEDIA_ENGINE_KEYERR = MF_MEDIA_ENGINE_KEYERR(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAENGINE_KEYERR_OUTPUT: MF_MEDIA_ENGINE_KEYERR = MF_MEDIA_ENGINE_KEYERR(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAENGINE_KEYERR_HARDWARECHANGE: MF_MEDIA_ENGINE_KEYERR = MF_MEDIA_ENGINE_KEYERR(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIAENGINE_KEYERR_DOMAIN: MF_MEDIA_ENGINE_KEYERR = MF_MEDIA_ENGINE_KEYERR(6i32);
impl ::core::marker::Copy for MF_MEDIA_ENGINE_KEYERR {}
impl ::core::clone::Clone for MF_MEDIA_ENGINE_KEYERR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MEDIA_ENGINE_KEYERR {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MEDIA_ENGINE_KEYERR {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MEDIA_ENGINE_KEYERR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MEDIA_ENGINE_KEYERR").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MEDIA_ENGINE_NETWORK(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_NETWORK_EMPTY: MF_MEDIA_ENGINE_NETWORK = MF_MEDIA_ENGINE_NETWORK(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_NETWORK_IDLE: MF_MEDIA_ENGINE_NETWORK = MF_MEDIA_ENGINE_NETWORK(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_NETWORK_LOADING: MF_MEDIA_ENGINE_NETWORK = MF_MEDIA_ENGINE_NETWORK(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_NETWORK_NO_SOURCE: MF_MEDIA_ENGINE_NETWORK = MF_MEDIA_ENGINE_NETWORK(3i32);
impl ::core::marker::Copy for MF_MEDIA_ENGINE_NETWORK {}
impl ::core::clone::Clone for MF_MEDIA_ENGINE_NETWORK {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MEDIA_ENGINE_NETWORK {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MEDIA_ENGINE_NETWORK {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MEDIA_ENGINE_NETWORK {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MEDIA_ENGINE_NETWORK").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MEDIA_ENGINE_OPM_STATUS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_OPM_NOT_REQUESTED: MF_MEDIA_ENGINE_OPM_STATUS = MF_MEDIA_ENGINE_OPM_STATUS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_OPM_ESTABLISHED: MF_MEDIA_ENGINE_OPM_STATUS = MF_MEDIA_ENGINE_OPM_STATUS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_OPM_FAILED_VM: MF_MEDIA_ENGINE_OPM_STATUS = MF_MEDIA_ENGINE_OPM_STATUS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_OPM_FAILED_BDA: MF_MEDIA_ENGINE_OPM_STATUS = MF_MEDIA_ENGINE_OPM_STATUS(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_OPM_FAILED_UNSIGNED_DRIVER: MF_MEDIA_ENGINE_OPM_STATUS = MF_MEDIA_ENGINE_OPM_STATUS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_OPM_FAILED: MF_MEDIA_ENGINE_OPM_STATUS = MF_MEDIA_ENGINE_OPM_STATUS(5i32);
impl ::core::marker::Copy for MF_MEDIA_ENGINE_OPM_STATUS {}
impl ::core::clone::Clone for MF_MEDIA_ENGINE_OPM_STATUS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MEDIA_ENGINE_OPM_STATUS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MEDIA_ENGINE_OPM_STATUS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MEDIA_ENGINE_OPM_STATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MEDIA_ENGINE_OPM_STATUS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MEDIA_ENGINE_PRELOAD(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_PRELOAD_MISSING: MF_MEDIA_ENGINE_PRELOAD = MF_MEDIA_ENGINE_PRELOAD(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_PRELOAD_EMPTY: MF_MEDIA_ENGINE_PRELOAD = MF_MEDIA_ENGINE_PRELOAD(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_PRELOAD_NONE: MF_MEDIA_ENGINE_PRELOAD = MF_MEDIA_ENGINE_PRELOAD(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_PRELOAD_METADATA: MF_MEDIA_ENGINE_PRELOAD = MF_MEDIA_ENGINE_PRELOAD(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_PRELOAD_AUTOMATIC: MF_MEDIA_ENGINE_PRELOAD = MF_MEDIA_ENGINE_PRELOAD(4i32);
impl ::core::marker::Copy for MF_MEDIA_ENGINE_PRELOAD {}
impl ::core::clone::Clone for MF_MEDIA_ENGINE_PRELOAD {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MEDIA_ENGINE_PRELOAD {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MEDIA_ENGINE_PRELOAD {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MEDIA_ENGINE_PRELOAD {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MEDIA_ENGINE_PRELOAD").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MEDIA_ENGINE_PROTECTION_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_ENABLE_PROTECTED_CONTENT: MF_MEDIA_ENGINE_PROTECTION_FLAGS = MF_MEDIA_ENGINE_PROTECTION_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_USE_PMP_FOR_ALL_CONTENT: MF_MEDIA_ENGINE_PROTECTION_FLAGS = MF_MEDIA_ENGINE_PROTECTION_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_USE_UNPROTECTED_PMP: MF_MEDIA_ENGINE_PROTECTION_FLAGS = MF_MEDIA_ENGINE_PROTECTION_FLAGS(4i32);
impl ::core::marker::Copy for MF_MEDIA_ENGINE_PROTECTION_FLAGS {}
impl ::core::clone::Clone for MF_MEDIA_ENGINE_PROTECTION_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MEDIA_ENGINE_PROTECTION_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MEDIA_ENGINE_PROTECTION_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MEDIA_ENGINE_PROTECTION_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MEDIA_ENGINE_PROTECTION_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MEDIA_ENGINE_READY(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_READY_HAVE_NOTHING: MF_MEDIA_ENGINE_READY = MF_MEDIA_ENGINE_READY(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_READY_HAVE_METADATA: MF_MEDIA_ENGINE_READY = MF_MEDIA_ENGINE_READY(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_READY_HAVE_CURRENT_DATA: MF_MEDIA_ENGINE_READY = MF_MEDIA_ENGINE_READY(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_READY_HAVE_FUTURE_DATA: MF_MEDIA_ENGINE_READY = MF_MEDIA_ENGINE_READY(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_READY_HAVE_ENOUGH_DATA: MF_MEDIA_ENGINE_READY = MF_MEDIA_ENGINE_READY(4i32);
impl ::core::marker::Copy for MF_MEDIA_ENGINE_READY {}
impl ::core::clone::Clone for MF_MEDIA_ENGINE_READY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MEDIA_ENGINE_READY {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MEDIA_ENGINE_READY {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MEDIA_ENGINE_READY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MEDIA_ENGINE_READY").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MEDIA_ENGINE_S3D_PACKING_MODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_S3D_PACKING_MODE_NONE: MF_MEDIA_ENGINE_S3D_PACKING_MODE = MF_MEDIA_ENGINE_S3D_PACKING_MODE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_S3D_PACKING_MODE_SIDE_BY_SIDE: MF_MEDIA_ENGINE_S3D_PACKING_MODE = MF_MEDIA_ENGINE_S3D_PACKING_MODE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_S3D_PACKING_MODE_TOP_BOTTOM: MF_MEDIA_ENGINE_S3D_PACKING_MODE = MF_MEDIA_ENGINE_S3D_PACKING_MODE(2i32);
impl ::core::marker::Copy for MF_MEDIA_ENGINE_S3D_PACKING_MODE {}
impl ::core::clone::Clone for MF_MEDIA_ENGINE_S3D_PACKING_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MEDIA_ENGINE_S3D_PACKING_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MEDIA_ENGINE_S3D_PACKING_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MEDIA_ENGINE_S3D_PACKING_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MEDIA_ENGINE_S3D_PACKING_MODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MEDIA_ENGINE_SEEK_MODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_SEEK_MODE_NORMAL: MF_MEDIA_ENGINE_SEEK_MODE = MF_MEDIA_ENGINE_SEEK_MODE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_SEEK_MODE_APPROXIMATE: MF_MEDIA_ENGINE_SEEK_MODE = MF_MEDIA_ENGINE_SEEK_MODE(1i32);
impl ::core::marker::Copy for MF_MEDIA_ENGINE_SEEK_MODE {}
impl ::core::clone::Clone for MF_MEDIA_ENGINE_SEEK_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MEDIA_ENGINE_SEEK_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MEDIA_ENGINE_SEEK_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MEDIA_ENGINE_SEEK_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MEDIA_ENGINE_SEEK_MODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MEDIA_ENGINE_STATISTIC(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_STATISTIC_FRAMES_RENDERED: MF_MEDIA_ENGINE_STATISTIC = MF_MEDIA_ENGINE_STATISTIC(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_STATISTIC_FRAMES_DROPPED: MF_MEDIA_ENGINE_STATISTIC = MF_MEDIA_ENGINE_STATISTIC(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_STATISTIC_BYTES_DOWNLOADED: MF_MEDIA_ENGINE_STATISTIC = MF_MEDIA_ENGINE_STATISTIC(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_STATISTIC_BUFFER_PROGRESS: MF_MEDIA_ENGINE_STATISTIC = MF_MEDIA_ENGINE_STATISTIC(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_STATISTIC_FRAMES_PER_SECOND: MF_MEDIA_ENGINE_STATISTIC = MF_MEDIA_ENGINE_STATISTIC(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_STATISTIC_PLAYBACK_JITTER: MF_MEDIA_ENGINE_STATISTIC = MF_MEDIA_ENGINE_STATISTIC(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_STATISTIC_FRAMES_CORRUPTED: MF_MEDIA_ENGINE_STATISTIC = MF_MEDIA_ENGINE_STATISTIC(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_STATISTIC_TOTAL_FRAME_DELAY: MF_MEDIA_ENGINE_STATISTIC = MF_MEDIA_ENGINE_STATISTIC(7i32);
impl ::core::marker::Copy for MF_MEDIA_ENGINE_STATISTIC {}
impl ::core::clone::Clone for MF_MEDIA_ENGINE_STATISTIC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MEDIA_ENGINE_STATISTIC {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MEDIA_ENGINE_STATISTIC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MEDIA_ENGINE_STATISTIC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MEDIA_ENGINE_STATISTIC").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MEDIA_ENGINE_STREAMTYPE_FAILED(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_STREAMTYPE_FAILED_UNKNOWN: MF_MEDIA_ENGINE_STREAMTYPE_FAILED = MF_MEDIA_ENGINE_STREAMTYPE_FAILED(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_STREAMTYPE_FAILED_AUDIO: MF_MEDIA_ENGINE_STREAMTYPE_FAILED = MF_MEDIA_ENGINE_STREAMTYPE_FAILED(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_ENGINE_STREAMTYPE_FAILED_VIDEO: MF_MEDIA_ENGINE_STREAMTYPE_FAILED = MF_MEDIA_ENGINE_STREAMTYPE_FAILED(2i32);
impl ::core::marker::Copy for MF_MEDIA_ENGINE_STREAMTYPE_FAILED {}
impl ::core::clone::Clone for MF_MEDIA_ENGINE_STREAMTYPE_FAILED {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MEDIA_ENGINE_STREAMTYPE_FAILED {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MEDIA_ENGINE_STREAMTYPE_FAILED {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MEDIA_ENGINE_STREAMTYPE_FAILED {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MEDIA_ENGINE_STREAMTYPE_FAILED").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MEDIA_SHARING_ENGINE_EVENT(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MEDIA_SHARING_ENGINE_EVENT_DISCONNECT: MF_MEDIA_SHARING_ENGINE_EVENT = MF_MEDIA_SHARING_ENGINE_EVENT(2000i32);
impl ::core::marker::Copy for MF_MEDIA_SHARING_ENGINE_EVENT {}
impl ::core::clone::Clone for MF_MEDIA_SHARING_ENGINE_EVENT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MEDIA_SHARING_ENGINE_EVENT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MEDIA_SHARING_ENGINE_EVENT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MEDIA_SHARING_ENGINE_EVENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MEDIA_SHARING_ENGINE_EVENT").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MSE_APPEND_MODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MSE_APPEND_MODE_SEGMENTS: MF_MSE_APPEND_MODE = MF_MSE_APPEND_MODE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MSE_APPEND_MODE_SEQUENCE: MF_MSE_APPEND_MODE = MF_MSE_APPEND_MODE(1i32);
impl ::core::marker::Copy for MF_MSE_APPEND_MODE {}
impl ::core::clone::Clone for MF_MSE_APPEND_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MSE_APPEND_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MSE_APPEND_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MSE_APPEND_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MSE_APPEND_MODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MSE_ERROR(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MSE_ERROR_NOERROR: MF_MSE_ERROR = MF_MSE_ERROR(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MSE_ERROR_NETWORK: MF_MSE_ERROR = MF_MSE_ERROR(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MSE_ERROR_DECODE: MF_MSE_ERROR = MF_MSE_ERROR(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MSE_ERROR_UNKNOWN_ERROR: MF_MSE_ERROR = MF_MSE_ERROR(3i32);
impl ::core::marker::Copy for MF_MSE_ERROR {}
impl ::core::clone::Clone for MF_MSE_ERROR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MSE_ERROR {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MSE_ERROR {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MSE_ERROR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MSE_ERROR").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MSE_OPUS_SUPPORT_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MSE_OPUS_SUPPORT_ON: MF_MSE_OPUS_SUPPORT_TYPE = MF_MSE_OPUS_SUPPORT_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MSE_OPUS_SUPPORT_OFF: MF_MSE_OPUS_SUPPORT_TYPE = MF_MSE_OPUS_SUPPORT_TYPE(1i32);
impl ::core::marker::Copy for MF_MSE_OPUS_SUPPORT_TYPE {}
impl ::core::clone::Clone for MF_MSE_OPUS_SUPPORT_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MSE_OPUS_SUPPORT_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MSE_OPUS_SUPPORT_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MSE_OPUS_SUPPORT_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MSE_OPUS_SUPPORT_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MSE_READY(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MSE_READY_CLOSED: MF_MSE_READY = MF_MSE_READY(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MSE_READY_OPEN: MF_MSE_READY = MF_MSE_READY(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MSE_READY_ENDED: MF_MSE_READY = MF_MSE_READY(3i32);
impl ::core::marker::Copy for MF_MSE_READY {}
impl ::core::clone::Clone for MF_MSE_READY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MSE_READY {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MSE_READY {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MSE_READY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MSE_READY").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MSE_VP9_SUPPORT_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MSE_VP9_SUPPORT_DEFAULT: MF_MSE_VP9_SUPPORT_TYPE = MF_MSE_VP9_SUPPORT_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MSE_VP9_SUPPORT_ON: MF_MSE_VP9_SUPPORT_TYPE = MF_MSE_VP9_SUPPORT_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_MSE_VP9_SUPPORT_OFF: MF_MSE_VP9_SUPPORT_TYPE = MF_MSE_VP9_SUPPORT_TYPE(2i32);
impl ::core::marker::Copy for MF_MSE_VP9_SUPPORT_TYPE {}
impl ::core::clone::Clone for MF_MSE_VP9_SUPPORT_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MSE_VP9_SUPPORT_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MSE_VP9_SUPPORT_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MSE_VP9_SUPPORT_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MSE_VP9_SUPPORT_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_MT_D3D_RESOURCE_VERSION_ENUM(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_D3D11_RESOURCE: MF_MT_D3D_RESOURCE_VERSION_ENUM = MF_MT_D3D_RESOURCE_VERSION_ENUM(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_D3D12_RESOURCE: MF_MT_D3D_RESOURCE_VERSION_ENUM = MF_MT_D3D_RESOURCE_VERSION_ENUM(1i32);
impl ::core::marker::Copy for MF_MT_D3D_RESOURCE_VERSION_ENUM {}
impl ::core::clone::Clone for MF_MT_D3D_RESOURCE_VERSION_ENUM {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_MT_D3D_RESOURCE_VERSION_ENUM {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_MT_D3D_RESOURCE_VERSION_ENUM {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_MT_D3D_RESOURCE_VERSION_ENUM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_MT_D3D_RESOURCE_VERSION_ENUM").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_OBJECT_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_OBJECT_MEDIASOURCE: MF_OBJECT_TYPE = MF_OBJECT_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_OBJECT_BYTESTREAM: MF_OBJECT_TYPE = MF_OBJECT_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_OBJECT_INVALID: MF_OBJECT_TYPE = MF_OBJECT_TYPE(2i32);
impl ::core::marker::Copy for MF_OBJECT_TYPE {}
impl ::core::clone::Clone for MF_OBJECT_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_OBJECT_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_OBJECT_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_OBJECT_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_OBJECT_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_OPM_ACP_PROTECTION_LEVEL(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_OPM_ACP_OFF: MF_OPM_ACP_PROTECTION_LEVEL = MF_OPM_ACP_PROTECTION_LEVEL(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_OPM_ACP_LEVEL_ONE: MF_OPM_ACP_PROTECTION_LEVEL = MF_OPM_ACP_PROTECTION_LEVEL(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_OPM_ACP_LEVEL_TWO: MF_OPM_ACP_PROTECTION_LEVEL = MF_OPM_ACP_PROTECTION_LEVEL(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_OPM_ACP_LEVEL_THREE: MF_OPM_ACP_PROTECTION_LEVEL = MF_OPM_ACP_PROTECTION_LEVEL(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_OPM_ACP_FORCE_ULONG: MF_OPM_ACP_PROTECTION_LEVEL = MF_OPM_ACP_PROTECTION_LEVEL(2147483647i32);
impl ::core::marker::Copy for MF_OPM_ACP_PROTECTION_LEVEL {}
impl ::core::clone::Clone for MF_OPM_ACP_PROTECTION_LEVEL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_OPM_ACP_PROTECTION_LEVEL {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_OPM_ACP_PROTECTION_LEVEL {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_OPM_ACP_PROTECTION_LEVEL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_OPM_ACP_PROTECTION_LEVEL").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_OPM_CGMSA_PROTECTION_LEVEL(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_OPM_CGMSA_OFF: MF_OPM_CGMSA_PROTECTION_LEVEL = MF_OPM_CGMSA_PROTECTION_LEVEL(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_OPM_CGMSA_COPY_FREELY: MF_OPM_CGMSA_PROTECTION_LEVEL = MF_OPM_CGMSA_PROTECTION_LEVEL(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_OPM_CGMSA_COPY_NO_MORE: MF_OPM_CGMSA_PROTECTION_LEVEL = MF_OPM_CGMSA_PROTECTION_LEVEL(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_OPM_CGMSA_COPY_ONE_GENERATION: MF_OPM_CGMSA_PROTECTION_LEVEL = MF_OPM_CGMSA_PROTECTION_LEVEL(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_OPM_CGMSA_COPY_NEVER: MF_OPM_CGMSA_PROTECTION_LEVEL = MF_OPM_CGMSA_PROTECTION_LEVEL(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_OPM_CGMSA_REDISTRIBUTION_CONTROL_REQUIRED: MF_OPM_CGMSA_PROTECTION_LEVEL = MF_OPM_CGMSA_PROTECTION_LEVEL(8i32);
impl ::core::marker::Copy for MF_OPM_CGMSA_PROTECTION_LEVEL {}
impl ::core::clone::Clone for MF_OPM_CGMSA_PROTECTION_LEVEL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_OPM_CGMSA_PROTECTION_LEVEL {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_OPM_CGMSA_PROTECTION_LEVEL {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_OPM_CGMSA_PROTECTION_LEVEL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_OPM_CGMSA_PROTECTION_LEVEL").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_PLUGIN_CONTROL_POLICY(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PLUGIN_CONTROL_POLICY_USE_ALL_PLUGINS: MF_PLUGIN_CONTROL_POLICY = MF_PLUGIN_CONTROL_POLICY(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PLUGIN_CONTROL_POLICY_USE_APPROVED_PLUGINS: MF_PLUGIN_CONTROL_POLICY = MF_PLUGIN_CONTROL_POLICY(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PLUGIN_CONTROL_POLICY_USE_WEB_PLUGINS: MF_PLUGIN_CONTROL_POLICY = MF_PLUGIN_CONTROL_POLICY(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_PLUGIN_CONTROL_POLICY_USE_WEB_PLUGINS_EDGEMODE: MF_PLUGIN_CONTROL_POLICY = MF_PLUGIN_CONTROL_POLICY(3i32);
impl ::core::marker::Copy for MF_PLUGIN_CONTROL_POLICY {}
impl ::core::clone::Clone for MF_PLUGIN_CONTROL_POLICY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_PLUGIN_CONTROL_POLICY {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_PLUGIN_CONTROL_POLICY {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_PLUGIN_CONTROL_POLICY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_PLUGIN_CONTROL_POLICY").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_Plugin_Type(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_Plugin_Type_MFT: MF_Plugin_Type = MF_Plugin_Type(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_Plugin_Type_MediaSource: MF_Plugin_Type = MF_Plugin_Type(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_Plugin_Type_MFT_MatchOutputType: MF_Plugin_Type = MF_Plugin_Type(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_Plugin_Type_Other: MF_Plugin_Type = MF_Plugin_Type(-1i32);
impl ::core::marker::Copy for MF_Plugin_Type {}
impl ::core::clone::Clone for MF_Plugin_Type {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_Plugin_Type {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_Plugin_Type {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_Plugin_Type {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_Plugin_Type").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_QUALITY_ADVISE_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_QUALITY_CANNOT_KEEP_UP: MF_QUALITY_ADVISE_FLAGS = MF_QUALITY_ADVISE_FLAGS(1i32);
impl ::core::marker::Copy for MF_QUALITY_ADVISE_FLAGS {}
impl ::core::clone::Clone for MF_QUALITY_ADVISE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_QUALITY_ADVISE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_QUALITY_ADVISE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_QUALITY_ADVISE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_QUALITY_ADVISE_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_QUALITY_DROP_MODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DROP_MODE_NONE: MF_QUALITY_DROP_MODE = MF_QUALITY_DROP_MODE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DROP_MODE_1: MF_QUALITY_DROP_MODE = MF_QUALITY_DROP_MODE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DROP_MODE_2: MF_QUALITY_DROP_MODE = MF_QUALITY_DROP_MODE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DROP_MODE_3: MF_QUALITY_DROP_MODE = MF_QUALITY_DROP_MODE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DROP_MODE_4: MF_QUALITY_DROP_MODE = MF_QUALITY_DROP_MODE(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_DROP_MODE_5: MF_QUALITY_DROP_MODE = MF_QUALITY_DROP_MODE(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_NUM_DROP_MODES: MF_QUALITY_DROP_MODE = MF_QUALITY_DROP_MODE(6i32);
impl ::core::marker::Copy for MF_QUALITY_DROP_MODE {}
impl ::core::clone::Clone for MF_QUALITY_DROP_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_QUALITY_DROP_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_QUALITY_DROP_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_QUALITY_DROP_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_QUALITY_DROP_MODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_QUALITY_LEVEL(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_QUALITY_NORMAL: MF_QUALITY_LEVEL = MF_QUALITY_LEVEL(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_QUALITY_NORMAL_MINUS_1: MF_QUALITY_LEVEL = MF_QUALITY_LEVEL(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_QUALITY_NORMAL_MINUS_2: MF_QUALITY_LEVEL = MF_QUALITY_LEVEL(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_QUALITY_NORMAL_MINUS_3: MF_QUALITY_LEVEL = MF_QUALITY_LEVEL(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_QUALITY_NORMAL_MINUS_4: MF_QUALITY_LEVEL = MF_QUALITY_LEVEL(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_QUALITY_NORMAL_MINUS_5: MF_QUALITY_LEVEL = MF_QUALITY_LEVEL(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_NUM_QUALITY_LEVELS: MF_QUALITY_LEVEL = MF_QUALITY_LEVEL(6i32);
impl ::core::marker::Copy for MF_QUALITY_LEVEL {}
impl ::core::clone::Clone for MF_QUALITY_LEVEL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_QUALITY_LEVEL {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_QUALITY_LEVEL {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_QUALITY_LEVEL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_QUALITY_LEVEL").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_RESOLUTION_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_RESOLUTION_MEDIASOURCE: MF_RESOLUTION_FLAGS = MF_RESOLUTION_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_RESOLUTION_BYTESTREAM: MF_RESOLUTION_FLAGS = MF_RESOLUTION_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_RESOLUTION_CONTENT_DOES_NOT_HAVE_TO_MATCH_EXTENSION_OR_MIME_TYPE: MF_RESOLUTION_FLAGS = MF_RESOLUTION_FLAGS(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_RESOLUTION_KEEP_BYTE_STREAM_ALIVE_ON_FAIL: MF_RESOLUTION_FLAGS = MF_RESOLUTION_FLAGS(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_RESOLUTION_DISABLE_LOCAL_PLUGINS: MF_RESOLUTION_FLAGS = MF_RESOLUTION_FLAGS(64i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_RESOLUTION_PLUGIN_CONTROL_POLICY_APPROVED_ONLY: MF_RESOLUTION_FLAGS = MF_RESOLUTION_FLAGS(128i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY: MF_RESOLUTION_FLAGS = MF_RESOLUTION_FLAGS(256i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY_EDGEMODE: MF_RESOLUTION_FLAGS = MF_RESOLUTION_FLAGS(512i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_RESOLUTION_ENABLE_STORE_PLUGINS: MF_RESOLUTION_FLAGS = MF_RESOLUTION_FLAGS(1024i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_RESOLUTION_READ: MF_RESOLUTION_FLAGS = MF_RESOLUTION_FLAGS(65536i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_RESOLUTION_WRITE: MF_RESOLUTION_FLAGS = MF_RESOLUTION_FLAGS(131072i32);
impl ::core::marker::Copy for MF_RESOLUTION_FLAGS {}
impl ::core::clone::Clone for MF_RESOLUTION_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_RESOLUTION_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_RESOLUTION_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_RESOLUTION_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_RESOLUTION_FLAGS").field(&self.0).finish()
    }
}
impl MF_RESOLUTION_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for MF_RESOLUTION_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for MF_RESOLUTION_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for MF_RESOLUTION_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for MF_RESOLUTION_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for MF_RESOLUTION_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_SERVICE_LOOKUP_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SERVICE_LOOKUP_UPSTREAM: MF_SERVICE_LOOKUP_TYPE = MF_SERVICE_LOOKUP_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SERVICE_LOOKUP_UPSTREAM_DIRECT: MF_SERVICE_LOOKUP_TYPE = MF_SERVICE_LOOKUP_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SERVICE_LOOKUP_DOWNSTREAM: MF_SERVICE_LOOKUP_TYPE = MF_SERVICE_LOOKUP_TYPE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SERVICE_LOOKUP_DOWNSTREAM_DIRECT: MF_SERVICE_LOOKUP_TYPE = MF_SERVICE_LOOKUP_TYPE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SERVICE_LOOKUP_ALL: MF_SERVICE_LOOKUP_TYPE = MF_SERVICE_LOOKUP_TYPE(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SERVICE_LOOKUP_GLOBAL: MF_SERVICE_LOOKUP_TYPE = MF_SERVICE_LOOKUP_TYPE(5i32);
impl ::core::marker::Copy for MF_SERVICE_LOOKUP_TYPE {}
impl ::core::clone::Clone for MF_SERVICE_LOOKUP_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_SERVICE_LOOKUP_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_SERVICE_LOOKUP_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_SERVICE_LOOKUP_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_SERVICE_LOOKUP_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_SHARING_ENGINE_EVENT(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SHARING_ENGINE_EVENT_DISCONNECT: MF_SHARING_ENGINE_EVENT = MF_SHARING_ENGINE_EVENT(2000i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SHARING_ENGINE_EVENT_LOCALRENDERINGSTARTED: MF_SHARING_ENGINE_EVENT = MF_SHARING_ENGINE_EVENT(2001i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SHARING_ENGINE_EVENT_LOCALRENDERINGENDED: MF_SHARING_ENGINE_EVENT = MF_SHARING_ENGINE_EVENT(2002i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SHARING_ENGINE_EVENT_STOPPED: MF_SHARING_ENGINE_EVENT = MF_SHARING_ENGINE_EVENT(2003i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SHARING_ENGINE_EVENT_ERROR: MF_SHARING_ENGINE_EVENT = MF_SHARING_ENGINE_EVENT(2501i32);
impl ::core::marker::Copy for MF_SHARING_ENGINE_EVENT {}
impl ::core::clone::Clone for MF_SHARING_ENGINE_EVENT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_SHARING_ENGINE_EVENT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_SHARING_ENGINE_EVENT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_SHARING_ENGINE_EVENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_SHARING_ENGINE_EVENT").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_SINK_WRITER_CONSTANTS(pub u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SINK_WRITER_INVALID_STREAM_INDEX: MF_SINK_WRITER_CONSTANTS = MF_SINK_WRITER_CONSTANTS(4294967295u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SINK_WRITER_ALL_STREAMS: MF_SINK_WRITER_CONSTANTS = MF_SINK_WRITER_CONSTANTS(4294967294u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SINK_WRITER_MEDIASINK: MF_SINK_WRITER_CONSTANTS = MF_SINK_WRITER_CONSTANTS(4294967295u32);
impl ::core::marker::Copy for MF_SINK_WRITER_CONSTANTS {}
impl ::core::clone::Clone for MF_SINK_WRITER_CONSTANTS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_SINK_WRITER_CONSTANTS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_SINK_WRITER_CONSTANTS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_SINK_WRITER_CONSTANTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_SINK_WRITER_CONSTANTS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_SOURCE_READER_CONSTANTS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READER_INVALID_STREAM_INDEX: MF_SOURCE_READER_CONSTANTS = MF_SOURCE_READER_CONSTANTS(-1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READER_ALL_STREAMS: MF_SOURCE_READER_CONSTANTS = MF_SOURCE_READER_CONSTANTS(-2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READER_ANY_STREAM: MF_SOURCE_READER_CONSTANTS = MF_SOURCE_READER_CONSTANTS(-2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READER_FIRST_AUDIO_STREAM: MF_SOURCE_READER_CONSTANTS = MF_SOURCE_READER_CONSTANTS(-3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READER_FIRST_VIDEO_STREAM: MF_SOURCE_READER_CONSTANTS = MF_SOURCE_READER_CONSTANTS(-4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READER_MEDIASOURCE: MF_SOURCE_READER_CONSTANTS = MF_SOURCE_READER_CONSTANTS(-1i32);
impl ::core::marker::Copy for MF_SOURCE_READER_CONSTANTS {}
impl ::core::clone::Clone for MF_SOURCE_READER_CONSTANTS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_SOURCE_READER_CONSTANTS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_SOURCE_READER_CONSTANTS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_SOURCE_READER_CONSTANTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_SOURCE_READER_CONSTANTS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_SOURCE_READER_CONTROL_FLAG(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READER_CONTROLF_DRAIN: MF_SOURCE_READER_CONTROL_FLAG = MF_SOURCE_READER_CONTROL_FLAG(1i32);
impl ::core::marker::Copy for MF_SOURCE_READER_CONTROL_FLAG {}
impl ::core::clone::Clone for MF_SOURCE_READER_CONTROL_FLAG {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_SOURCE_READER_CONTROL_FLAG {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_SOURCE_READER_CONTROL_FLAG {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_SOURCE_READER_CONTROL_FLAG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_SOURCE_READER_CONTROL_FLAG").field(&self.0).finish()
    }
}
impl MF_SOURCE_READER_CONTROL_FLAG {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for MF_SOURCE_READER_CONTROL_FLAG {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for MF_SOURCE_READER_CONTROL_FLAG {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for MF_SOURCE_READER_CONTROL_FLAG {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for MF_SOURCE_READER_CONTROL_FLAG {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for MF_SOURCE_READER_CONTROL_FLAG {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_SOURCE_READER_CURRENT_TYPE_CONSTANTS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READER_CURRENT_TYPE_INDEX: MF_SOURCE_READER_CURRENT_TYPE_CONSTANTS = MF_SOURCE_READER_CURRENT_TYPE_CONSTANTS(-1i32);
impl ::core::marker::Copy for MF_SOURCE_READER_CURRENT_TYPE_CONSTANTS {}
impl ::core::clone::Clone for MF_SOURCE_READER_CURRENT_TYPE_CONSTANTS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_SOURCE_READER_CURRENT_TYPE_CONSTANTS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_SOURCE_READER_CURRENT_TYPE_CONSTANTS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_SOURCE_READER_CURRENT_TYPE_CONSTANTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_SOURCE_READER_CURRENT_TYPE_CONSTANTS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_SOURCE_READER_FLAG(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READERF_ERROR: MF_SOURCE_READER_FLAG = MF_SOURCE_READER_FLAG(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READERF_ENDOFSTREAM: MF_SOURCE_READER_FLAG = MF_SOURCE_READER_FLAG(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READERF_NEWSTREAM: MF_SOURCE_READER_FLAG = MF_SOURCE_READER_FLAG(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READERF_NATIVEMEDIATYPECHANGED: MF_SOURCE_READER_FLAG = MF_SOURCE_READER_FLAG(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED: MF_SOURCE_READER_FLAG = MF_SOURCE_READER_FLAG(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READERF_STREAMTICK: MF_SOURCE_READER_FLAG = MF_SOURCE_READER_FLAG(256i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_SOURCE_READERF_ALLEFFECTSREMOVED: MF_SOURCE_READER_FLAG = MF_SOURCE_READER_FLAG(512i32);
impl ::core::marker::Copy for MF_SOURCE_READER_FLAG {}
impl ::core::clone::Clone for MF_SOURCE_READER_FLAG {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_SOURCE_READER_FLAG {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_SOURCE_READER_FLAG {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_SOURCE_READER_FLAG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_SOURCE_READER_FLAG").field(&self.0).finish()
    }
}
impl MF_SOURCE_READER_FLAG {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for MF_SOURCE_READER_FLAG {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for MF_SOURCE_READER_FLAG {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for MF_SOURCE_READER_FLAG {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for MF_SOURCE_READER_FLAG {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for MF_SOURCE_READER_FLAG {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_STREAM_STATE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_STREAM_STATE_STOPPED: MF_STREAM_STATE = MF_STREAM_STATE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_STREAM_STATE_PAUSED: MF_STREAM_STATE = MF_STREAM_STATE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_STREAM_STATE_RUNNING: MF_STREAM_STATE = MF_STREAM_STATE(2i32);
impl ::core::marker::Copy for MF_STREAM_STATE {}
impl ::core::clone::Clone for MF_STREAM_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_STREAM_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_STREAM_STATE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_STREAM_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_STREAM_STATE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_TIMED_TEXT_ALIGNMENT(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_ALIGNMENT_START: MF_TIMED_TEXT_ALIGNMENT = MF_TIMED_TEXT_ALIGNMENT(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_ALIGNMENT_END: MF_TIMED_TEXT_ALIGNMENT = MF_TIMED_TEXT_ALIGNMENT(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_ALIGNMENT_CENTER: MF_TIMED_TEXT_ALIGNMENT = MF_TIMED_TEXT_ALIGNMENT(2i32);
impl ::core::marker::Copy for MF_TIMED_TEXT_ALIGNMENT {}
impl ::core::clone::Clone for MF_TIMED_TEXT_ALIGNMENT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_TIMED_TEXT_ALIGNMENT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_TIMED_TEXT_ALIGNMENT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_TIMED_TEXT_ALIGNMENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_TIMED_TEXT_ALIGNMENT").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_TIMED_TEXT_BOUTEN_POSITION(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_BOUTEN_POSITION_BEFORE: MF_TIMED_TEXT_BOUTEN_POSITION = MF_TIMED_TEXT_BOUTEN_POSITION(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_BOUTEN_POSITION_AFTER: MF_TIMED_TEXT_BOUTEN_POSITION = MF_TIMED_TEXT_BOUTEN_POSITION(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_BOUTEN_POSITION_OUTSIDE: MF_TIMED_TEXT_BOUTEN_POSITION = MF_TIMED_TEXT_BOUTEN_POSITION(2i32);
impl ::core::marker::Copy for MF_TIMED_TEXT_BOUTEN_POSITION {}
impl ::core::clone::Clone for MF_TIMED_TEXT_BOUTEN_POSITION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_TIMED_TEXT_BOUTEN_POSITION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_TIMED_TEXT_BOUTEN_POSITION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_TIMED_TEXT_BOUTEN_POSITION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_TIMED_TEXT_BOUTEN_POSITION").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_TIMED_TEXT_BOUTEN_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_BOUTEN_TYPE_NONE: MF_TIMED_TEXT_BOUTEN_TYPE = MF_TIMED_TEXT_BOUTEN_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_BOUTEN_TYPE_AUTO: MF_TIMED_TEXT_BOUTEN_TYPE = MF_TIMED_TEXT_BOUTEN_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_BOUTEN_TYPE_FILLEDCIRCLE: MF_TIMED_TEXT_BOUTEN_TYPE = MF_TIMED_TEXT_BOUTEN_TYPE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_BOUTEN_TYPE_OPENCIRCLE: MF_TIMED_TEXT_BOUTEN_TYPE = MF_TIMED_TEXT_BOUTEN_TYPE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_BOUTEN_TYPE_FILLEDDOT: MF_TIMED_TEXT_BOUTEN_TYPE = MF_TIMED_TEXT_BOUTEN_TYPE(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_BOUTEN_TYPE_OPENDOT: MF_TIMED_TEXT_BOUTEN_TYPE = MF_TIMED_TEXT_BOUTEN_TYPE(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_BOUTEN_TYPE_FILLEDSESAME: MF_TIMED_TEXT_BOUTEN_TYPE = MF_TIMED_TEXT_BOUTEN_TYPE(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_BOUTEN_TYPE_OPENSESAME: MF_TIMED_TEXT_BOUTEN_TYPE = MF_TIMED_TEXT_BOUTEN_TYPE(7i32);
impl ::core::marker::Copy for MF_TIMED_TEXT_BOUTEN_TYPE {}
impl ::core::clone::Clone for MF_TIMED_TEXT_BOUTEN_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_TIMED_TEXT_BOUTEN_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_TIMED_TEXT_BOUTEN_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_TIMED_TEXT_BOUTEN_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_TIMED_TEXT_BOUTEN_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_TIMED_TEXT_CUE_EVENT(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_CUE_EVENT_ACTIVE: MF_TIMED_TEXT_CUE_EVENT = MF_TIMED_TEXT_CUE_EVENT(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_CUE_EVENT_INACTIVE: MF_TIMED_TEXT_CUE_EVENT = MF_TIMED_TEXT_CUE_EVENT(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_CUE_EVENT_CLEAR: MF_TIMED_TEXT_CUE_EVENT = MF_TIMED_TEXT_CUE_EVENT(2i32);
impl ::core::marker::Copy for MF_TIMED_TEXT_CUE_EVENT {}
impl ::core::clone::Clone for MF_TIMED_TEXT_CUE_EVENT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_TIMED_TEXT_CUE_EVENT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_TIMED_TEXT_CUE_EVENT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_TIMED_TEXT_CUE_EVENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_TIMED_TEXT_CUE_EVENT").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_TIMED_TEXT_DECORATION(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_DECORATION_NONE: MF_TIMED_TEXT_DECORATION = MF_TIMED_TEXT_DECORATION(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_DECORATION_UNDERLINE: MF_TIMED_TEXT_DECORATION = MF_TIMED_TEXT_DECORATION(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_DECORATION_LINE_THROUGH: MF_TIMED_TEXT_DECORATION = MF_TIMED_TEXT_DECORATION(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_DECORATION_OVERLINE: MF_TIMED_TEXT_DECORATION = MF_TIMED_TEXT_DECORATION(4i32);
impl ::core::marker::Copy for MF_TIMED_TEXT_DECORATION {}
impl ::core::clone::Clone for MF_TIMED_TEXT_DECORATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_TIMED_TEXT_DECORATION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_TIMED_TEXT_DECORATION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_TIMED_TEXT_DECORATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_TIMED_TEXT_DECORATION").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_TIMED_TEXT_DISPLAY_ALIGNMENT(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_DISPLAY_ALIGNMENT_BEFORE: MF_TIMED_TEXT_DISPLAY_ALIGNMENT = MF_TIMED_TEXT_DISPLAY_ALIGNMENT(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_DISPLAY_ALIGNMENT_AFTER: MF_TIMED_TEXT_DISPLAY_ALIGNMENT = MF_TIMED_TEXT_DISPLAY_ALIGNMENT(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_DISPLAY_ALIGNMENT_CENTER: MF_TIMED_TEXT_DISPLAY_ALIGNMENT = MF_TIMED_TEXT_DISPLAY_ALIGNMENT(2i32);
impl ::core::marker::Copy for MF_TIMED_TEXT_DISPLAY_ALIGNMENT {}
impl ::core::clone::Clone for MF_TIMED_TEXT_DISPLAY_ALIGNMENT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_TIMED_TEXT_DISPLAY_ALIGNMENT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_TIMED_TEXT_DISPLAY_ALIGNMENT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_TIMED_TEXT_DISPLAY_ALIGNMENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_TIMED_TEXT_DISPLAY_ALIGNMENT").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_TIMED_TEXT_ERROR_CODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_ERROR_CODE_NOERROR: MF_TIMED_TEXT_ERROR_CODE = MF_TIMED_TEXT_ERROR_CODE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_ERROR_CODE_FATAL: MF_TIMED_TEXT_ERROR_CODE = MF_TIMED_TEXT_ERROR_CODE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_ERROR_CODE_DATA_FORMAT: MF_TIMED_TEXT_ERROR_CODE = MF_TIMED_TEXT_ERROR_CODE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_ERROR_CODE_NETWORK: MF_TIMED_TEXT_ERROR_CODE = MF_TIMED_TEXT_ERROR_CODE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_ERROR_CODE_INTERNAL: MF_TIMED_TEXT_ERROR_CODE = MF_TIMED_TEXT_ERROR_CODE(4i32);
impl ::core::marker::Copy for MF_TIMED_TEXT_ERROR_CODE {}
impl ::core::clone::Clone for MF_TIMED_TEXT_ERROR_CODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_TIMED_TEXT_ERROR_CODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_TIMED_TEXT_ERROR_CODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_TIMED_TEXT_ERROR_CODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_TIMED_TEXT_ERROR_CODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_TIMED_TEXT_FONT_STYLE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_FONT_STYLE_NORMAL: MF_TIMED_TEXT_FONT_STYLE = MF_TIMED_TEXT_FONT_STYLE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_FONT_STYLE_OBLIQUE: MF_TIMED_TEXT_FONT_STYLE = MF_TIMED_TEXT_FONT_STYLE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_FONT_STYLE_ITALIC: MF_TIMED_TEXT_FONT_STYLE = MF_TIMED_TEXT_FONT_STYLE(2i32);
impl ::core::marker::Copy for MF_TIMED_TEXT_FONT_STYLE {}
impl ::core::clone::Clone for MF_TIMED_TEXT_FONT_STYLE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_TIMED_TEXT_FONT_STYLE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_TIMED_TEXT_FONT_STYLE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_TIMED_TEXT_FONT_STYLE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_TIMED_TEXT_FONT_STYLE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_TIMED_TEXT_RUBY_ALIGN(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_RUBY_ALIGN_CENTER: MF_TIMED_TEXT_RUBY_ALIGN = MF_TIMED_TEXT_RUBY_ALIGN(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_RUBY_ALIGN_START: MF_TIMED_TEXT_RUBY_ALIGN = MF_TIMED_TEXT_RUBY_ALIGN(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_RUBY_ALIGN_END: MF_TIMED_TEXT_RUBY_ALIGN = MF_TIMED_TEXT_RUBY_ALIGN(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_RUBY_ALIGN_SPACEAROUND: MF_TIMED_TEXT_RUBY_ALIGN = MF_TIMED_TEXT_RUBY_ALIGN(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_RUBY_ALIGN_SPACEBETWEEN: MF_TIMED_TEXT_RUBY_ALIGN = MF_TIMED_TEXT_RUBY_ALIGN(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_RUBY_ALIGN_WITHBASE: MF_TIMED_TEXT_RUBY_ALIGN = MF_TIMED_TEXT_RUBY_ALIGN(5i32);
impl ::core::marker::Copy for MF_TIMED_TEXT_RUBY_ALIGN {}
impl ::core::clone::Clone for MF_TIMED_TEXT_RUBY_ALIGN {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_TIMED_TEXT_RUBY_ALIGN {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_TIMED_TEXT_RUBY_ALIGN {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_TIMED_TEXT_RUBY_ALIGN {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_TIMED_TEXT_RUBY_ALIGN").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_TIMED_TEXT_RUBY_POSITION(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_RUBY_POSITION_BEFORE: MF_TIMED_TEXT_RUBY_POSITION = MF_TIMED_TEXT_RUBY_POSITION(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_RUBY_POSITION_AFTER: MF_TIMED_TEXT_RUBY_POSITION = MF_TIMED_TEXT_RUBY_POSITION(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_RUBY_POSITION_OUTSIDE: MF_TIMED_TEXT_RUBY_POSITION = MF_TIMED_TEXT_RUBY_POSITION(2i32);
impl ::core::marker::Copy for MF_TIMED_TEXT_RUBY_POSITION {}
impl ::core::clone::Clone for MF_TIMED_TEXT_RUBY_POSITION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_TIMED_TEXT_RUBY_POSITION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_TIMED_TEXT_RUBY_POSITION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_TIMED_TEXT_RUBY_POSITION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_TIMED_TEXT_RUBY_POSITION").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_TIMED_TEXT_RUBY_RESERVE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_RUBY_RESERVE_NONE: MF_TIMED_TEXT_RUBY_RESERVE = MF_TIMED_TEXT_RUBY_RESERVE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_RUBY_RESERVE_BEFORE: MF_TIMED_TEXT_RUBY_RESERVE = MF_TIMED_TEXT_RUBY_RESERVE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_RUBY_RESERVE_AFTER: MF_TIMED_TEXT_RUBY_RESERVE = MF_TIMED_TEXT_RUBY_RESERVE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_RUBY_RESERVE_BOTH: MF_TIMED_TEXT_RUBY_RESERVE = MF_TIMED_TEXT_RUBY_RESERVE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_RUBY_RESERVE_OUTSIDE: MF_TIMED_TEXT_RUBY_RESERVE = MF_TIMED_TEXT_RUBY_RESERVE(4i32);
impl ::core::marker::Copy for MF_TIMED_TEXT_RUBY_RESERVE {}
impl ::core::clone::Clone for MF_TIMED_TEXT_RUBY_RESERVE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_TIMED_TEXT_RUBY_RESERVE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_TIMED_TEXT_RUBY_RESERVE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_TIMED_TEXT_RUBY_RESERVE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_TIMED_TEXT_RUBY_RESERVE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_TIMED_TEXT_SCROLL_MODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_SCROLL_MODE_POP_ON: MF_TIMED_TEXT_SCROLL_MODE = MF_TIMED_TEXT_SCROLL_MODE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_SCROLL_MODE_ROLL_UP: MF_TIMED_TEXT_SCROLL_MODE = MF_TIMED_TEXT_SCROLL_MODE(1i32);
impl ::core::marker::Copy for MF_TIMED_TEXT_SCROLL_MODE {}
impl ::core::clone::Clone for MF_TIMED_TEXT_SCROLL_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_TIMED_TEXT_SCROLL_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_TIMED_TEXT_SCROLL_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_TIMED_TEXT_SCROLL_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_TIMED_TEXT_SCROLL_MODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_TIMED_TEXT_TRACK_KIND(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_TRACK_KIND_UNKNOWN: MF_TIMED_TEXT_TRACK_KIND = MF_TIMED_TEXT_TRACK_KIND(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_TRACK_KIND_SUBTITLES: MF_TIMED_TEXT_TRACK_KIND = MF_TIMED_TEXT_TRACK_KIND(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_TRACK_KIND_CAPTIONS: MF_TIMED_TEXT_TRACK_KIND = MF_TIMED_TEXT_TRACK_KIND(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_TRACK_KIND_METADATA: MF_TIMED_TEXT_TRACK_KIND = MF_TIMED_TEXT_TRACK_KIND(3i32);
impl ::core::marker::Copy for MF_TIMED_TEXT_TRACK_KIND {}
impl ::core::clone::Clone for MF_TIMED_TEXT_TRACK_KIND {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_TIMED_TEXT_TRACK_KIND {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_TIMED_TEXT_TRACK_KIND {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_TIMED_TEXT_TRACK_KIND {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_TIMED_TEXT_TRACK_KIND").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_TIMED_TEXT_TRACK_READY_STATE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_TRACK_READY_STATE_NONE: MF_TIMED_TEXT_TRACK_READY_STATE = MF_TIMED_TEXT_TRACK_READY_STATE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_TRACK_READY_STATE_LOADING: MF_TIMED_TEXT_TRACK_READY_STATE = MF_TIMED_TEXT_TRACK_READY_STATE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_TRACK_READY_STATE_LOADED: MF_TIMED_TEXT_TRACK_READY_STATE = MF_TIMED_TEXT_TRACK_READY_STATE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_TRACK_READY_STATE_ERROR: MF_TIMED_TEXT_TRACK_READY_STATE = MF_TIMED_TEXT_TRACK_READY_STATE(3i32);
impl ::core::marker::Copy for MF_TIMED_TEXT_TRACK_READY_STATE {}
impl ::core::clone::Clone for MF_TIMED_TEXT_TRACK_READY_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_TIMED_TEXT_TRACK_READY_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_TIMED_TEXT_TRACK_READY_STATE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_TIMED_TEXT_TRACK_READY_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_TIMED_TEXT_TRACK_READY_STATE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_TIMED_TEXT_UNIT_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_UNIT_TYPE_PIXELS: MF_TIMED_TEXT_UNIT_TYPE = MF_TIMED_TEXT_UNIT_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_UNIT_TYPE_PERCENTAGE: MF_TIMED_TEXT_UNIT_TYPE = MF_TIMED_TEXT_UNIT_TYPE(1i32);
impl ::core::marker::Copy for MF_TIMED_TEXT_UNIT_TYPE {}
impl ::core::clone::Clone for MF_TIMED_TEXT_UNIT_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_TIMED_TEXT_UNIT_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_TIMED_TEXT_UNIT_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_TIMED_TEXT_UNIT_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_TIMED_TEXT_UNIT_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_TIMED_TEXT_WRITING_MODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_WRITING_MODE_LRTB: MF_TIMED_TEXT_WRITING_MODE = MF_TIMED_TEXT_WRITING_MODE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_WRITING_MODE_RLTB: MF_TIMED_TEXT_WRITING_MODE = MF_TIMED_TEXT_WRITING_MODE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_WRITING_MODE_TBRL: MF_TIMED_TEXT_WRITING_MODE = MF_TIMED_TEXT_WRITING_MODE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_WRITING_MODE_TBLR: MF_TIMED_TEXT_WRITING_MODE = MF_TIMED_TEXT_WRITING_MODE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_WRITING_MODE_LR: MF_TIMED_TEXT_WRITING_MODE = MF_TIMED_TEXT_WRITING_MODE(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_WRITING_MODE_RL: MF_TIMED_TEXT_WRITING_MODE = MF_TIMED_TEXT_WRITING_MODE(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TIMED_TEXT_WRITING_MODE_TB: MF_TIMED_TEXT_WRITING_MODE = MF_TIMED_TEXT_WRITING_MODE(6i32);
impl ::core::marker::Copy for MF_TIMED_TEXT_WRITING_MODE {}
impl ::core::clone::Clone for MF_TIMED_TEXT_WRITING_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_TIMED_TEXT_WRITING_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_TIMED_TEXT_WRITING_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_TIMED_TEXT_WRITING_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_TIMED_TEXT_WRITING_MODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOLOGY_RESOLUTION_SUCCEEDED: MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS = MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_OPTIONAL_NODE_REJECTED_MEDIA_TYPE: MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS = MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_OPTIONAL_NODE_REJECTED_PROTECTED_PROCESS: MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS = MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS(2i32);
impl ::core::marker::Copy for MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS {}
impl ::core::clone::Clone for MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_TOPOLOGY_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOLOGY_OUTPUT_NODE: MF_TOPOLOGY_TYPE = MF_TOPOLOGY_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOLOGY_SOURCESTREAM_NODE: MF_TOPOLOGY_TYPE = MF_TOPOLOGY_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOLOGY_TRANSFORM_NODE: MF_TOPOLOGY_TYPE = MF_TOPOLOGY_TYPE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOLOGY_TEE_NODE: MF_TOPOLOGY_TYPE = MF_TOPOLOGY_TYPE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOLOGY_MAX: MF_TOPOLOGY_TYPE = MF_TOPOLOGY_TYPE(-1i32);
impl ::core::marker::Copy for MF_TOPOLOGY_TYPE {}
impl ::core::clone::Clone for MF_TOPOLOGY_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_TOPOLOGY_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_TOPOLOGY_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_TOPOLOGY_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_TOPOLOGY_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_TOPONODE_DRAIN_MODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_DRAIN_DEFAULT: MF_TOPONODE_DRAIN_MODE = MF_TOPONODE_DRAIN_MODE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_DRAIN_ALWAYS: MF_TOPONODE_DRAIN_MODE = MF_TOPONODE_DRAIN_MODE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_DRAIN_NEVER: MF_TOPONODE_DRAIN_MODE = MF_TOPONODE_DRAIN_MODE(2i32);
impl ::core::marker::Copy for MF_TOPONODE_DRAIN_MODE {}
impl ::core::clone::Clone for MF_TOPONODE_DRAIN_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_TOPONODE_DRAIN_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_TOPONODE_DRAIN_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_TOPONODE_DRAIN_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_TOPONODE_DRAIN_MODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_TOPONODE_FLUSH_MODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_FLUSH_ALWAYS: MF_TOPONODE_FLUSH_MODE = MF_TOPONODE_FLUSH_MODE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_FLUSH_SEEK: MF_TOPONODE_FLUSH_MODE = MF_TOPONODE_FLUSH_MODE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPONODE_FLUSH_NEVER: MF_TOPONODE_FLUSH_MODE = MF_TOPONODE_FLUSH_MODE(2i32);
impl ::core::marker::Copy for MF_TOPONODE_FLUSH_MODE {}
impl ::core::clone::Clone for MF_TOPONODE_FLUSH_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_TOPONODE_FLUSH_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_TOPONODE_FLUSH_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_TOPONODE_FLUSH_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_TOPONODE_FLUSH_MODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_TOPOSTATUS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOSTATUS_INVALID: MF_TOPOSTATUS = MF_TOPOSTATUS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOSTATUS_READY: MF_TOPOSTATUS = MF_TOPOSTATUS(100i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOSTATUS_STARTED_SOURCE: MF_TOPOSTATUS = MF_TOPOSTATUS(200i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOSTATUS_DYNAMIC_CHANGED: MF_TOPOSTATUS = MF_TOPOSTATUS(210i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOSTATUS_SINK_SWITCHED: MF_TOPOSTATUS = MF_TOPOSTATUS(300i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TOPOSTATUS_ENDED: MF_TOPOSTATUS = MF_TOPOSTATUS(400i32);
impl ::core::marker::Copy for MF_TOPOSTATUS {}
impl ::core::clone::Clone for MF_TOPOSTATUS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_TOPOSTATUS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_TOPOSTATUS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_TOPOSTATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_TOPOSTATUS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_TRANSCODE_ADJUST_PROFILE_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TRANSCODE_ADJUST_PROFILE_DEFAULT: MF_TRANSCODE_ADJUST_PROFILE_FLAGS = MF_TRANSCODE_ADJUST_PROFILE_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TRANSCODE_ADJUST_PROFILE_USE_SOURCE_ATTRIBUTES: MF_TRANSCODE_ADJUST_PROFILE_FLAGS = MF_TRANSCODE_ADJUST_PROFILE_FLAGS(1i32);
impl ::core::marker::Copy for MF_TRANSCODE_ADJUST_PROFILE_FLAGS {}
impl ::core::clone::Clone for MF_TRANSCODE_ADJUST_PROFILE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_TRANSCODE_ADJUST_PROFILE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_TRANSCODE_ADJUST_PROFILE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_TRANSCODE_ADJUST_PROFILE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_TRANSCODE_ADJUST_PROFILE_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_TRANSCODE_TOPOLOGYMODE_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TRANSCODE_TOPOLOGYMODE_SOFTWARE_ONLY: MF_TRANSCODE_TOPOLOGYMODE_FLAGS = MF_TRANSCODE_TOPOLOGYMODE_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_TRANSCODE_TOPOLOGYMODE_HARDWARE_ALLOWED: MF_TRANSCODE_TOPOLOGYMODE_FLAGS = MF_TRANSCODE_TOPOLOGYMODE_FLAGS(1i32);
impl ::core::marker::Copy for MF_TRANSCODE_TOPOLOGYMODE_FLAGS {}
impl ::core::clone::Clone for MF_TRANSCODE_TOPOLOGYMODE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_TRANSCODE_TOPOLOGYMODE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_TRANSCODE_TOPOLOGYMODE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_TRANSCODE_TOPOLOGYMODE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_TRANSCODE_TOPOLOGYMODE_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_URL_TRUST_STATUS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_LICENSE_URL_UNTRUSTED: MF_URL_TRUST_STATUS = MF_URL_TRUST_STATUS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_LICENSE_URL_TRUSTED: MF_URL_TRUST_STATUS = MF_URL_TRUST_STATUS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_LICENSE_URL_TAMPERED: MF_URL_TRUST_STATUS = MF_URL_TRUST_STATUS(2i32);
impl ::core::marker::Copy for MF_URL_TRUST_STATUS {}
impl ::core::clone::Clone for MF_URL_TRUST_STATUS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_URL_TRUST_STATUS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_URL_TRUST_STATUS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_URL_TRUST_STATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_URL_TRUST_STATUS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_VIDEO_PROCESSOR_ALGORITHM_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_VIDEO_PROCESSOR_ALGORITHM_DEFAULT: MF_VIDEO_PROCESSOR_ALGORITHM_TYPE = MF_VIDEO_PROCESSOR_ALGORITHM_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MF_VIDEO_PROCESSOR_ALGORITHM_MRF_CRF_444: MF_VIDEO_PROCESSOR_ALGORITHM_TYPE = MF_VIDEO_PROCESSOR_ALGORITHM_TYPE(1i32);
impl ::core::marker::Copy for MF_VIDEO_PROCESSOR_ALGORITHM_TYPE {}
impl ::core::clone::Clone for MF_VIDEO_PROCESSOR_ALGORITHM_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_VIDEO_PROCESSOR_ALGORITHM_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_VIDEO_PROCESSOR_ALGORITHM_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_VIDEO_PROCESSOR_ALGORITHM_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_VIDEO_PROCESSOR_ALGORITHM_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_VIDEO_PROCESSOR_MIRROR(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MIRROR_NONE: MF_VIDEO_PROCESSOR_MIRROR = MF_VIDEO_PROCESSOR_MIRROR(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MIRROR_HORIZONTAL: MF_VIDEO_PROCESSOR_MIRROR = MF_VIDEO_PROCESSOR_MIRROR(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MIRROR_VERTICAL: MF_VIDEO_PROCESSOR_MIRROR = MF_VIDEO_PROCESSOR_MIRROR(2i32);
impl ::core::marker::Copy for MF_VIDEO_PROCESSOR_MIRROR {}
impl ::core::clone::Clone for MF_VIDEO_PROCESSOR_MIRROR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_VIDEO_PROCESSOR_MIRROR {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_VIDEO_PROCESSOR_MIRROR {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_VIDEO_PROCESSOR_MIRROR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_VIDEO_PROCESSOR_MIRROR").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MF_VIDEO_PROCESSOR_ROTATION(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const ROTATION_NONE: MF_VIDEO_PROCESSOR_ROTATION = MF_VIDEO_PROCESSOR_ROTATION(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const ROTATION_NORMAL: MF_VIDEO_PROCESSOR_ROTATION = MF_VIDEO_PROCESSOR_ROTATION(1i32);
impl ::core::marker::Copy for MF_VIDEO_PROCESSOR_ROTATION {}
impl ::core::clone::Clone for MF_VIDEO_PROCESSOR_ROTATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MF_VIDEO_PROCESSOR_ROTATION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MF_VIDEO_PROCESSOR_ROTATION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MF_VIDEO_PROCESSOR_ROTATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MF_VIDEO_PROCESSOR_ROTATION").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MIC_ARRAY_MODE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MICARRAY_SINGLE_CHAN: MIC_ARRAY_MODE = MIC_ARRAY_MODE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MICARRAY_SIMPLE_SUM: MIC_ARRAY_MODE = MIC_ARRAY_MODE(256i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MICARRAY_SINGLE_BEAM: MIC_ARRAY_MODE = MIC_ARRAY_MODE(512i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MICARRAY_FIXED_BEAM: MIC_ARRAY_MODE = MIC_ARRAY_MODE(1024i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MICARRAY_EXTERN_BEAM: MIC_ARRAY_MODE = MIC_ARRAY_MODE(2048i32);
impl ::core::marker::Copy for MIC_ARRAY_MODE {}
impl ::core::clone::Clone for MIC_ARRAY_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MIC_ARRAY_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MIC_ARRAY_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MIC_ARRAY_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MIC_ARRAY_MODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MPEG2VIDEOINFO_FLAGS(pub u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AMMPEG2_DoPanScan: MPEG2VIDEOINFO_FLAGS = MPEG2VIDEOINFO_FLAGS(1u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AMMPEG2_DVDLine21Field1: MPEG2VIDEOINFO_FLAGS = MPEG2VIDEOINFO_FLAGS(2u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AMMPEG2_DVDLine21Field2: MPEG2VIDEOINFO_FLAGS = MPEG2VIDEOINFO_FLAGS(4u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AMMPEG2_SourceIsLetterboxed: MPEG2VIDEOINFO_FLAGS = MPEG2VIDEOINFO_FLAGS(8u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AMMPEG2_FilmCameraMode: MPEG2VIDEOINFO_FLAGS = MPEG2VIDEOINFO_FLAGS(16u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AMMPEG2_LetterboxAnalogOut: MPEG2VIDEOINFO_FLAGS = MPEG2VIDEOINFO_FLAGS(32u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AMMPEG2_DSS_UserData: MPEG2VIDEOINFO_FLAGS = MPEG2VIDEOINFO_FLAGS(64u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AMMPEG2_DVB_UserData: MPEG2VIDEOINFO_FLAGS = MPEG2VIDEOINFO_FLAGS(128u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AMMPEG2_27MhzTimebase: MPEG2VIDEOINFO_FLAGS = MPEG2VIDEOINFO_FLAGS(256u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AMMPEG2_WidescreenAnalogOut: MPEG2VIDEOINFO_FLAGS = MPEG2VIDEOINFO_FLAGS(512u32);
impl ::core::marker::Copy for MPEG2VIDEOINFO_FLAGS {}
impl ::core::clone::Clone for MPEG2VIDEOINFO_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MPEG2VIDEOINFO_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for MPEG2VIDEOINFO_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for MPEG2VIDEOINFO_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MPEG2VIDEOINFO_FLAGS").field(&self.0).finish()
    }
}
impl MPEG2VIDEOINFO_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for MPEG2VIDEOINFO_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for MPEG2VIDEOINFO_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for MPEG2VIDEOINFO_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for MPEG2VIDEOINFO_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for MPEG2VIDEOINFO_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct OPM_ACP_PROTECTION_LEVEL(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_ACP_OFF: OPM_ACP_PROTECTION_LEVEL = OPM_ACP_PROTECTION_LEVEL(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_ACP_LEVEL_ONE: OPM_ACP_PROTECTION_LEVEL = OPM_ACP_PROTECTION_LEVEL(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_ACP_LEVEL_TWO: OPM_ACP_PROTECTION_LEVEL = OPM_ACP_PROTECTION_LEVEL(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_ACP_LEVEL_THREE: OPM_ACP_PROTECTION_LEVEL = OPM_ACP_PROTECTION_LEVEL(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_ACP_FORCE_ULONG: OPM_ACP_PROTECTION_LEVEL = OPM_ACP_PROTECTION_LEVEL(2147483647i32);
impl ::core::marker::Copy for OPM_ACP_PROTECTION_LEVEL {}
impl ::core::clone::Clone for OPM_ACP_PROTECTION_LEVEL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for OPM_ACP_PROTECTION_LEVEL {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for OPM_ACP_PROTECTION_LEVEL {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for OPM_ACP_PROTECTION_LEVEL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OPM_ACP_PROTECTION_LEVEL").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct OPM_BUS_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_BUS_TYPE_OTHER: OPM_BUS_TYPE = OPM_BUS_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_BUS_TYPE_PCI: OPM_BUS_TYPE = OPM_BUS_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_BUS_TYPE_PCIX: OPM_BUS_TYPE = OPM_BUS_TYPE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_BUS_TYPE_PCIEXPRESS: OPM_BUS_TYPE = OPM_BUS_TYPE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_BUS_TYPE_AGP: OPM_BUS_TYPE = OPM_BUS_TYPE(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_BUS_IMPLEMENTATION_MODIFIER_INSIDE_OF_CHIPSET: OPM_BUS_TYPE = OPM_BUS_TYPE(65536i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_BUS_IMPLEMENTATION_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_CHIP: OPM_BUS_TYPE = OPM_BUS_TYPE(131072i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_BUS_IMPLEMENTATION_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_SOCKET: OPM_BUS_TYPE = OPM_BUS_TYPE(196608i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_BUS_IMPLEMENTATION_MODIFIER_DAUGHTER_BOARD_CONNECTOR: OPM_BUS_TYPE = OPM_BUS_TYPE(262144i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_BUS_IMPLEMENTATION_MODIFIER_DAUGHTER_BOARD_CONNECTOR_INSIDE_OF_NUAE: OPM_BUS_TYPE = OPM_BUS_TYPE(327680i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_BUS_IMPLEMENTATION_MODIFIER_NON_STANDARD: OPM_BUS_TYPE = OPM_BUS_TYPE(-2147483648i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_COPP_COMPATIBLE_BUS_TYPE_INTEGRATED: OPM_BUS_TYPE = OPM_BUS_TYPE(-2147483648i32);
impl ::core::marker::Copy for OPM_BUS_TYPE {}
impl ::core::clone::Clone for OPM_BUS_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for OPM_BUS_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for OPM_BUS_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for OPM_BUS_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OPM_BUS_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct OPM_CGMSA(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CGMSA_OFF: OPM_CGMSA = OPM_CGMSA(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CGMSA_COPY_FREELY: OPM_CGMSA = OPM_CGMSA(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CGMSA_COPY_NO_MORE: OPM_CGMSA = OPM_CGMSA(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CGMSA_COPY_ONE_GENERATION: OPM_CGMSA = OPM_CGMSA(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CGMSA_COPY_NEVER: OPM_CGMSA = OPM_CGMSA(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CGMSA_REDISTRIBUTION_CONTROL_REQUIRED: OPM_CGMSA = OPM_CGMSA(8i32);
impl ::core::marker::Copy for OPM_CGMSA {}
impl ::core::clone::Clone for OPM_CGMSA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for OPM_CGMSA {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for OPM_CGMSA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for OPM_CGMSA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OPM_CGMSA").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct OPM_CONNECTOR_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CONNECTOR_TYPE_OTHER: OPM_CONNECTOR_TYPE = OPM_CONNECTOR_TYPE(-1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CONNECTOR_TYPE_VGA: OPM_CONNECTOR_TYPE = OPM_CONNECTOR_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CONNECTOR_TYPE_SVIDEO: OPM_CONNECTOR_TYPE = OPM_CONNECTOR_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CONNECTOR_TYPE_COMPOSITE_VIDEO: OPM_CONNECTOR_TYPE = OPM_CONNECTOR_TYPE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CONNECTOR_TYPE_COMPONENT_VIDEO: OPM_CONNECTOR_TYPE = OPM_CONNECTOR_TYPE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CONNECTOR_TYPE_DVI: OPM_CONNECTOR_TYPE = OPM_CONNECTOR_TYPE(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CONNECTOR_TYPE_HDMI: OPM_CONNECTOR_TYPE = OPM_CONNECTOR_TYPE(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CONNECTOR_TYPE_LVDS: OPM_CONNECTOR_TYPE = OPM_CONNECTOR_TYPE(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CONNECTOR_TYPE_D_JPN: OPM_CONNECTOR_TYPE = OPM_CONNECTOR_TYPE(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CONNECTOR_TYPE_SDI: OPM_CONNECTOR_TYPE = OPM_CONNECTOR_TYPE(9i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CONNECTOR_TYPE_DISPLAYPORT_EXTERNAL: OPM_CONNECTOR_TYPE = OPM_CONNECTOR_TYPE(10i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CONNECTOR_TYPE_DISPLAYPORT_EMBEDDED: OPM_CONNECTOR_TYPE = OPM_CONNECTOR_TYPE(11i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CONNECTOR_TYPE_UDI_EXTERNAL: OPM_CONNECTOR_TYPE = OPM_CONNECTOR_TYPE(12i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CONNECTOR_TYPE_UDI_EMBEDDED: OPM_CONNECTOR_TYPE = OPM_CONNECTOR_TYPE(13i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CONNECTOR_TYPE_RESERVED: OPM_CONNECTOR_TYPE = OPM_CONNECTOR_TYPE(14i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CONNECTOR_TYPE_MIRACAST: OPM_CONNECTOR_TYPE = OPM_CONNECTOR_TYPE(15i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CONNECTOR_TYPE_TRANSPORT_AGNOSTIC_DIGITAL_MODE_A: OPM_CONNECTOR_TYPE = OPM_CONNECTOR_TYPE(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CONNECTOR_TYPE_TRANSPORT_AGNOSTIC_DIGITAL_MODE_B: OPM_CONNECTOR_TYPE = OPM_CONNECTOR_TYPE(17i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_COPP_COMPATIBLE_CONNECTOR_TYPE_INTERNAL: OPM_CONNECTOR_TYPE = OPM_CONNECTOR_TYPE(-2147483648i32);
impl ::core::marker::Copy for OPM_CONNECTOR_TYPE {}
impl ::core::clone::Clone for OPM_CONNECTOR_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for OPM_CONNECTOR_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for OPM_CONNECTOR_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for OPM_CONNECTOR_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OPM_CONNECTOR_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct OPM_DPCP_PROTECTION_LEVEL(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_DPCP_OFF: OPM_DPCP_PROTECTION_LEVEL = OPM_DPCP_PROTECTION_LEVEL(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_DPCP_ON: OPM_DPCP_PROTECTION_LEVEL = OPM_DPCP_PROTECTION_LEVEL(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_DPCP_FORCE_ULONG: OPM_DPCP_PROTECTION_LEVEL = OPM_DPCP_PROTECTION_LEVEL(2147483647i32);
impl ::core::marker::Copy for OPM_DPCP_PROTECTION_LEVEL {}
impl ::core::clone::Clone for OPM_DPCP_PROTECTION_LEVEL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for OPM_DPCP_PROTECTION_LEVEL {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for OPM_DPCP_PROTECTION_LEVEL {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for OPM_DPCP_PROTECTION_LEVEL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OPM_DPCP_PROTECTION_LEVEL").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct OPM_DVI_CHARACTERISTIC(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_DVI_CHARACTERISTIC_1_0: OPM_DVI_CHARACTERISTIC = OPM_DVI_CHARACTERISTIC(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_DVI_CHARACTERISTIC_1_1_OR_ABOVE: OPM_DVI_CHARACTERISTIC = OPM_DVI_CHARACTERISTIC(2i32);
impl ::core::marker::Copy for OPM_DVI_CHARACTERISTIC {}
impl ::core::clone::Clone for OPM_DVI_CHARACTERISTIC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for OPM_DVI_CHARACTERISTIC {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for OPM_DVI_CHARACTERISTIC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for OPM_DVI_CHARACTERISTIC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OPM_DVI_CHARACTERISTIC").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct OPM_HDCP_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_HDCP_FLAG_NONE: OPM_HDCP_FLAGS = OPM_HDCP_FLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_HDCP_FLAG_REPEATER: OPM_HDCP_FLAGS = OPM_HDCP_FLAGS(1i32);
impl ::core::marker::Copy for OPM_HDCP_FLAGS {}
impl ::core::clone::Clone for OPM_HDCP_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for OPM_HDCP_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for OPM_HDCP_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for OPM_HDCP_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OPM_HDCP_FLAGS").field(&self.0).finish()
    }
}
impl OPM_HDCP_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for OPM_HDCP_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for OPM_HDCP_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for OPM_HDCP_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for OPM_HDCP_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for OPM_HDCP_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct OPM_HDCP_PROTECTION_LEVEL(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_HDCP_OFF: OPM_HDCP_PROTECTION_LEVEL = OPM_HDCP_PROTECTION_LEVEL(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_HDCP_ON: OPM_HDCP_PROTECTION_LEVEL = OPM_HDCP_PROTECTION_LEVEL(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_HDCP_FORCE_ULONG: OPM_HDCP_PROTECTION_LEVEL = OPM_HDCP_PROTECTION_LEVEL(2147483647i32);
impl ::core::marker::Copy for OPM_HDCP_PROTECTION_LEVEL {}
impl ::core::clone::Clone for OPM_HDCP_PROTECTION_LEVEL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for OPM_HDCP_PROTECTION_LEVEL {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for OPM_HDCP_PROTECTION_LEVEL {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for OPM_HDCP_PROTECTION_LEVEL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OPM_HDCP_PROTECTION_LEVEL").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct OPM_HDCP_STATUS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_HDCP_STATUS_ON: OPM_HDCP_STATUS = OPM_HDCP_STATUS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_HDCP_STATUS_OFF: OPM_HDCP_STATUS = OPM_HDCP_STATUS(1i32);
impl ::core::marker::Copy for OPM_HDCP_STATUS {}
impl ::core::clone::Clone for OPM_HDCP_STATUS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for OPM_HDCP_STATUS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for OPM_HDCP_STATUS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for OPM_HDCP_STATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OPM_HDCP_STATUS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct OPM_HDCP_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_HDCP_TYPE_0: OPM_HDCP_TYPE = OPM_HDCP_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_HDCP_TYPE_1: OPM_HDCP_TYPE = OPM_HDCP_TYPE(1i32);
impl ::core::marker::Copy for OPM_HDCP_TYPE {}
impl ::core::clone::Clone for OPM_HDCP_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for OPM_HDCP_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for OPM_HDCP_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for OPM_HDCP_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OPM_HDCP_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct OPM_IMAGE_ASPECT_RATIO_EN300294(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_ASPECT_RATIO_EN300294_FULL_FORMAT_4_BY_3: OPM_IMAGE_ASPECT_RATIO_EN300294 = OPM_IMAGE_ASPECT_RATIO_EN300294(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_ASPECT_RATIO_EN300294_BOX_14_BY_9_CENTER: OPM_IMAGE_ASPECT_RATIO_EN300294 = OPM_IMAGE_ASPECT_RATIO_EN300294(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_ASPECT_RATIO_EN300294_BOX_14_BY_9_TOP: OPM_IMAGE_ASPECT_RATIO_EN300294 = OPM_IMAGE_ASPECT_RATIO_EN300294(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_ASPECT_RATIO_EN300294_BOX_16_BY_9_CENTER: OPM_IMAGE_ASPECT_RATIO_EN300294 = OPM_IMAGE_ASPECT_RATIO_EN300294(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_ASPECT_RATIO_EN300294_BOX_16_BY_9_TOP: OPM_IMAGE_ASPECT_RATIO_EN300294 = OPM_IMAGE_ASPECT_RATIO_EN300294(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_ASPECT_RATIO_EN300294_BOX_GT_16_BY_9_CENTER: OPM_IMAGE_ASPECT_RATIO_EN300294 = OPM_IMAGE_ASPECT_RATIO_EN300294(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_ASPECT_RATIO_EN300294_FULL_FORMAT_4_BY_3_PROTECTED_CENTER: OPM_IMAGE_ASPECT_RATIO_EN300294 = OPM_IMAGE_ASPECT_RATIO_EN300294(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_ASPECT_RATIO_EN300294_FULL_FORMAT_16_BY_9_ANAMORPHIC: OPM_IMAGE_ASPECT_RATIO_EN300294 = OPM_IMAGE_ASPECT_RATIO_EN300294(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_ASPECT_RATIO_FORCE_ULONG: OPM_IMAGE_ASPECT_RATIO_EN300294 = OPM_IMAGE_ASPECT_RATIO_EN300294(2147483647i32);
impl ::core::marker::Copy for OPM_IMAGE_ASPECT_RATIO_EN300294 {}
impl ::core::clone::Clone for OPM_IMAGE_ASPECT_RATIO_EN300294 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for OPM_IMAGE_ASPECT_RATIO_EN300294 {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for OPM_IMAGE_ASPECT_RATIO_EN300294 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for OPM_IMAGE_ASPECT_RATIO_EN300294 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OPM_IMAGE_ASPECT_RATIO_EN300294").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct OPM_OUTPUT_HARDWARE_PROTECTION(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_OUTPUT_HARDWARE_PROTECTION_NOT_SUPPORTED: OPM_OUTPUT_HARDWARE_PROTECTION = OPM_OUTPUT_HARDWARE_PROTECTION(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_OUTPUT_HARDWARE_PROTECTION_SUPPORTED: OPM_OUTPUT_HARDWARE_PROTECTION = OPM_OUTPUT_HARDWARE_PROTECTION(1i32);
impl ::core::marker::Copy for OPM_OUTPUT_HARDWARE_PROTECTION {}
impl ::core::clone::Clone for OPM_OUTPUT_HARDWARE_PROTECTION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for OPM_OUTPUT_HARDWARE_PROTECTION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for OPM_OUTPUT_HARDWARE_PROTECTION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for OPM_OUTPUT_HARDWARE_PROTECTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OPM_OUTPUT_HARDWARE_PROTECTION").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct OPM_PROTECTION_STANDARD_TYPE(pub u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_STANDARD_OTHER: OPM_PROTECTION_STANDARD_TYPE = OPM_PROTECTION_STANDARD_TYPE(2147483648u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_STANDARD_NONE: OPM_PROTECTION_STANDARD_TYPE = OPM_PROTECTION_STANDARD_TYPE(0u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_STANDARD_IEC61880_525I: OPM_PROTECTION_STANDARD_TYPE = OPM_PROTECTION_STANDARD_TYPE(1u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_STANDARD_IEC61880_2_525I: OPM_PROTECTION_STANDARD_TYPE = OPM_PROTECTION_STANDARD_TYPE(2u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_STANDARD_IEC62375_625P: OPM_PROTECTION_STANDARD_TYPE = OPM_PROTECTION_STANDARD_TYPE(4u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_STANDARD_EIA608B_525: OPM_PROTECTION_STANDARD_TYPE = OPM_PROTECTION_STANDARD_TYPE(8u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_STANDARD_EN300294_625I: OPM_PROTECTION_STANDARD_TYPE = OPM_PROTECTION_STANDARD_TYPE(16u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_STANDARD_CEA805A_TYPEA_525P: OPM_PROTECTION_STANDARD_TYPE = OPM_PROTECTION_STANDARD_TYPE(32u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_STANDARD_CEA805A_TYPEA_750P: OPM_PROTECTION_STANDARD_TYPE = OPM_PROTECTION_STANDARD_TYPE(64u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_STANDARD_CEA805A_TYPEA_1125I: OPM_PROTECTION_STANDARD_TYPE = OPM_PROTECTION_STANDARD_TYPE(128u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_STANDARD_CEA805A_TYPEB_525P: OPM_PROTECTION_STANDARD_TYPE = OPM_PROTECTION_STANDARD_TYPE(256u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_STANDARD_CEA805A_TYPEB_750P: OPM_PROTECTION_STANDARD_TYPE = OPM_PROTECTION_STANDARD_TYPE(512u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_STANDARD_CEA805A_TYPEB_1125I: OPM_PROTECTION_STANDARD_TYPE = OPM_PROTECTION_STANDARD_TYPE(1024u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_STANDARD_ARIBTRB15_525I: OPM_PROTECTION_STANDARD_TYPE = OPM_PROTECTION_STANDARD_TYPE(2048u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_STANDARD_ARIBTRB15_525P: OPM_PROTECTION_STANDARD_TYPE = OPM_PROTECTION_STANDARD_TYPE(4096u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_STANDARD_ARIBTRB15_750P: OPM_PROTECTION_STANDARD_TYPE = OPM_PROTECTION_STANDARD_TYPE(8192u32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_STANDARD_ARIBTRB15_1125I: OPM_PROTECTION_STANDARD_TYPE = OPM_PROTECTION_STANDARD_TYPE(16384u32);
impl ::core::marker::Copy for OPM_PROTECTION_STANDARD_TYPE {}
impl ::core::clone::Clone for OPM_PROTECTION_STANDARD_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for OPM_PROTECTION_STANDARD_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for OPM_PROTECTION_STANDARD_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for OPM_PROTECTION_STANDARD_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OPM_PROTECTION_STANDARD_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct OPM_PROTECTION_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_TYPE_OTHER: OPM_PROTECTION_TYPE = OPM_PROTECTION_TYPE(-2147483648i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_TYPE_NONE: OPM_PROTECTION_TYPE = OPM_PROTECTION_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_TYPE_COPP_COMPATIBLE_HDCP: OPM_PROTECTION_TYPE = OPM_PROTECTION_TYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_TYPE_ACP: OPM_PROTECTION_TYPE = OPM_PROTECTION_TYPE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_TYPE_CGMSA: OPM_PROTECTION_TYPE = OPM_PROTECTION_TYPE(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_TYPE_HDCP: OPM_PROTECTION_TYPE = OPM_PROTECTION_TYPE(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_TYPE_DPCP: OPM_PROTECTION_TYPE = OPM_PROTECTION_TYPE(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_TYPE_TYPE_ENFORCEMENT_HDCP: OPM_PROTECTION_TYPE = OPM_PROTECTION_TYPE(32i32);
impl ::core::marker::Copy for OPM_PROTECTION_TYPE {}
impl ::core::clone::Clone for OPM_PROTECTION_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for OPM_PROTECTION_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for OPM_PROTECTION_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for OPM_PROTECTION_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OPM_PROTECTION_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct OPM_STATUS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_STATUS_NORMAL: OPM_STATUS = OPM_STATUS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_STATUS_LINK_LOST: OPM_STATUS = OPM_STATUS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_STATUS_RENEGOTIATION_REQUIRED: OPM_STATUS = OPM_STATUS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_STATUS_TAMPERING_DETECTED: OPM_STATUS = OPM_STATUS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_STATUS_REVOKED_HDCP_DEVICE_ATTACHED: OPM_STATUS = OPM_STATUS(8i32);
impl ::core::marker::Copy for OPM_STATUS {}
impl ::core::clone::Clone for OPM_STATUS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for OPM_STATUS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for OPM_STATUS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for OPM_STATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OPM_STATUS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct OPM_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_OMAC_SIZE: OPM_TYPE = OPM_TYPE(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_128_BIT_RANDOM_NUMBER_SIZE: OPM_TYPE = OPM_TYPE(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_ENCRYPTED_INITIALIZATION_PARAMETERS_SIZE: OPM_TYPE = OPM_TYPE(256i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_CONFIGURE_SETTING_DATA_SIZE: OPM_TYPE = OPM_TYPE(4056i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_GET_INFORMATION_PARAMETERS_SIZE: OPM_TYPE = OPM_TYPE(4056i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_REQUESTED_INFORMATION_SIZE: OPM_TYPE = OPM_TYPE(4076i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_HDCP_KEY_SELECTION_VECTOR_SIZE: OPM_TYPE = OPM_TYPE(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_PROTECTION_TYPE_SIZE: OPM_TYPE = OPM_TYPE(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_BUS_TYPE_MASK: OPM_TYPE = OPM_TYPE(65535i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_BUS_IMPLEMENTATION_MODIFIER_MASK: OPM_TYPE = OPM_TYPE(32767i32);
impl ::core::marker::Copy for OPM_TYPE {}
impl ::core::clone::Clone for OPM_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for OPM_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for OPM_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for OPM_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OPM_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_TYPE_ENFORCEMENT_HDCP_OFF: OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL = OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_TYPE_ENFORCEMENT_HDCP_ON_WITH_NO_TYPE_RESTRICTION: OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL = OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_TYPE_ENFORCEMENT_HDCP_ON_WITH_TYPE1_RESTRICTION: OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL = OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_TYPE_ENFORCEMENT_HDCP_FORCE_ULONG: OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL = OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL(2147483647i32);
impl ::core::marker::Copy for OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL {}
impl ::core::clone::Clone for OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct OPM_VIDEO_OUTPUT_SEMANTICS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_VOS_COPP_SEMANTICS: OPM_VIDEO_OUTPUT_SEMANTICS = OPM_VIDEO_OUTPUT_SEMANTICS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_VOS_OPM_SEMANTICS: OPM_VIDEO_OUTPUT_SEMANTICS = OPM_VIDEO_OUTPUT_SEMANTICS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const OPM_VOS_OPM_INDIRECT_DISPLAY: OPM_VIDEO_OUTPUT_SEMANTICS = OPM_VIDEO_OUTPUT_SEMANTICS(2i32);
impl ::core::marker::Copy for OPM_VIDEO_OUTPUT_SEMANTICS {}
impl ::core::clone::Clone for OPM_VIDEO_OUTPUT_SEMANTICS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for OPM_VIDEO_OUTPUT_SEMANTICS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for OPM_VIDEO_OUTPUT_SEMANTICS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for OPM_VIDEO_OUTPUT_SEMANTICS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OPM_VIDEO_OUTPUT_SEMANTICS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct PLAYTO_SOURCE_CREATEFLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PLAYTO_SOURCE_NONE: PLAYTO_SOURCE_CREATEFLAGS = PLAYTO_SOURCE_CREATEFLAGS(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PLAYTO_SOURCE_IMAGE: PLAYTO_SOURCE_CREATEFLAGS = PLAYTO_SOURCE_CREATEFLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PLAYTO_SOURCE_AUDIO: PLAYTO_SOURCE_CREATEFLAGS = PLAYTO_SOURCE_CREATEFLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PLAYTO_SOURCE_VIDEO: PLAYTO_SOURCE_CREATEFLAGS = PLAYTO_SOURCE_CREATEFLAGS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const PLAYTO_SOURCE_PROTECTED: PLAYTO_SOURCE_CREATEFLAGS = PLAYTO_SOURCE_CREATEFLAGS(8i32);
impl ::core::marker::Copy for PLAYTO_SOURCE_CREATEFLAGS {}
impl ::core::clone::Clone for PLAYTO_SOURCE_CREATEFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for PLAYTO_SOURCE_CREATEFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for PLAYTO_SOURCE_CREATEFLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for PLAYTO_SOURCE_CREATEFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("PLAYTO_SOURCE_CREATEFLAGS").field(&self.0).finish()
    }
}
impl PLAYTO_SOURCE_CREATEFLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for PLAYTO_SOURCE_CREATEFLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for PLAYTO_SOURCE_CREATEFLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for PLAYTO_SOURCE_CREATEFLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for PLAYTO_SOURCE_CREATEFLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for PLAYTO_SOURCE_CREATEFLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct SAMPLE_PROTECTION_VERSION(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const SAMPLE_PROTECTION_VERSION_NO: SAMPLE_PROTECTION_VERSION = SAMPLE_PROTECTION_VERSION(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const SAMPLE_PROTECTION_VERSION_BASIC_LOKI: SAMPLE_PROTECTION_VERSION = SAMPLE_PROTECTION_VERSION(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const SAMPLE_PROTECTION_VERSION_SCATTER: SAMPLE_PROTECTION_VERSION = SAMPLE_PROTECTION_VERSION(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const SAMPLE_PROTECTION_VERSION_RC4: SAMPLE_PROTECTION_VERSION = SAMPLE_PROTECTION_VERSION(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const SAMPLE_PROTECTION_VERSION_AES128CTR: SAMPLE_PROTECTION_VERSION = SAMPLE_PROTECTION_VERSION(4i32);
impl ::core::marker::Copy for SAMPLE_PROTECTION_VERSION {}
impl ::core::clone::Clone for SAMPLE_PROTECTION_VERSION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SAMPLE_PROTECTION_VERSION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for SAMPLE_PROTECTION_VERSION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for SAMPLE_PROTECTION_VERSION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SAMPLE_PROTECTION_VERSION").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct SEEK_ORIGIN(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const _msoBegin: SEEK_ORIGIN = SEEK_ORIGIN(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const _msoCurrent: SEEK_ORIGIN = SEEK_ORIGIN(1i32);
impl ::core::marker::Copy for SEEK_ORIGIN {}
impl ::core::clone::Clone for SEEK_ORIGIN {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SEEK_ORIGIN {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for SEEK_ORIGIN {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for SEEK_ORIGIN {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SEEK_ORIGIN").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct TOC_POS_TYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const TOC_POS_INHEADER: TOC_POS_TYPE = TOC_POS_TYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const TOC_POS_TOPLEVELOBJECT: TOC_POS_TYPE = TOC_POS_TYPE(1i32);
impl ::core::marker::Copy for TOC_POS_TYPE {}
impl ::core::clone::Clone for TOC_POS_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for TOC_POS_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for TOC_POS_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for TOC_POS_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("TOC_POS_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct WMT_PROP_DATATYPE(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const WMT_PROP_TYPE_DWORD: WMT_PROP_DATATYPE = WMT_PROP_DATATYPE(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const WMT_PROP_TYPE_STRING: WMT_PROP_DATATYPE = WMT_PROP_DATATYPE(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const WMT_PROP_TYPE_BINARY: WMT_PROP_DATATYPE = WMT_PROP_DATATYPE(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const WMT_PROP_TYPE_BOOL: WMT_PROP_DATATYPE = WMT_PROP_DATATYPE(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const WMT_PROP_TYPE_QWORD: WMT_PROP_DATATYPE = WMT_PROP_DATATYPE(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const WMT_PROP_TYPE_WORD: WMT_PROP_DATATYPE = WMT_PROP_DATATYPE(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const WMT_PROP_TYPE_GUID: WMT_PROP_DATATYPE = WMT_PROP_DATATYPE(6i32);
impl ::core::marker::Copy for WMT_PROP_DATATYPE {}
impl ::core::clone::Clone for WMT_PROP_DATATYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for WMT_PROP_DATATYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for WMT_PROP_DATATYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for WMT_PROP_DATATYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("WMT_PROP_DATATYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct WMV_DYNAMIC_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const WMV_DYNAMIC_BITRATE: WMV_DYNAMIC_FLAGS = WMV_DYNAMIC_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const WMV_DYNAMIC_RESOLUTION: WMV_DYNAMIC_FLAGS = WMV_DYNAMIC_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const WMV_DYNAMIC_COMPLEXITY: WMV_DYNAMIC_FLAGS = WMV_DYNAMIC_FLAGS(4i32);
impl ::core::marker::Copy for WMV_DYNAMIC_FLAGS {}
impl ::core::clone::Clone for WMV_DYNAMIC_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for WMV_DYNAMIC_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for WMV_DYNAMIC_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for WMV_DYNAMIC_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("WMV_DYNAMIC_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct _MFP_CREDENTIAL_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_CREDENTIAL_PROMPT: _MFP_CREDENTIAL_FLAGS = _MFP_CREDENTIAL_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_CREDENTIAL_SAVE: _MFP_CREDENTIAL_FLAGS = _MFP_CREDENTIAL_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_CREDENTIAL_DO_NOT_CACHE: _MFP_CREDENTIAL_FLAGS = _MFP_CREDENTIAL_FLAGS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_CREDENTIAL_CLEAR_TEXT: _MFP_CREDENTIAL_FLAGS = _MFP_CREDENTIAL_FLAGS(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_CREDENTIAL_PROXY: _MFP_CREDENTIAL_FLAGS = _MFP_CREDENTIAL_FLAGS(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_CREDENTIAL_LOGGED_ON_USER: _MFP_CREDENTIAL_FLAGS = _MFP_CREDENTIAL_FLAGS(32i32);
impl ::core::marker::Copy for _MFP_CREDENTIAL_FLAGS {}
impl ::core::clone::Clone for _MFP_CREDENTIAL_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _MFP_CREDENTIAL_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for _MFP_CREDENTIAL_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for _MFP_CREDENTIAL_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_MFP_CREDENTIAL_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct _MFP_MEDIAITEM_CHARACTERISTICS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_MEDIAITEM_IS_LIVE: _MFP_MEDIAITEM_CHARACTERISTICS = _MFP_MEDIAITEM_CHARACTERISTICS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_MEDIAITEM_CAN_SEEK: _MFP_MEDIAITEM_CHARACTERISTICS = _MFP_MEDIAITEM_CHARACTERISTICS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_MEDIAITEM_CAN_PAUSE: _MFP_MEDIAITEM_CHARACTERISTICS = _MFP_MEDIAITEM_CHARACTERISTICS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFP_MEDIAITEM_HAS_SLOW_SEEK: _MFP_MEDIAITEM_CHARACTERISTICS = _MFP_MEDIAITEM_CHARACTERISTICS(8i32);
impl ::core::marker::Copy for _MFP_MEDIAITEM_CHARACTERISTICS {}
impl ::core::clone::Clone for _MFP_MEDIAITEM_CHARACTERISTICS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _MFP_MEDIAITEM_CHARACTERISTICS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for _MFP_MEDIAITEM_CHARACTERISTICS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for _MFP_MEDIAITEM_CHARACTERISTICS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_MFP_MEDIAITEM_CHARACTERISTICS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct _MFT_INPUT_DATA_BUFFER_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_INPUT_DATA_BUFFER_PLACEHOLDER: _MFT_INPUT_DATA_BUFFER_FLAGS = _MFT_INPUT_DATA_BUFFER_FLAGS(-1i32);
impl ::core::marker::Copy for _MFT_INPUT_DATA_BUFFER_FLAGS {}
impl ::core::clone::Clone for _MFT_INPUT_DATA_BUFFER_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _MFT_INPUT_DATA_BUFFER_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for _MFT_INPUT_DATA_BUFFER_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for _MFT_INPUT_DATA_BUFFER_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_MFT_INPUT_DATA_BUFFER_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct _MFT_INPUT_STATUS_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_INPUT_STATUS_ACCEPT_DATA: _MFT_INPUT_STATUS_FLAGS = _MFT_INPUT_STATUS_FLAGS(1i32);
impl ::core::marker::Copy for _MFT_INPUT_STATUS_FLAGS {}
impl ::core::clone::Clone for _MFT_INPUT_STATUS_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _MFT_INPUT_STATUS_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for _MFT_INPUT_STATUS_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for _MFT_INPUT_STATUS_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_MFT_INPUT_STATUS_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct _MFT_INPUT_STREAM_INFO_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_INPUT_STREAM_WHOLE_SAMPLES: _MFT_INPUT_STREAM_INFO_FLAGS = _MFT_INPUT_STREAM_INFO_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_INPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER: _MFT_INPUT_STREAM_INFO_FLAGS = _MFT_INPUT_STREAM_INFO_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_INPUT_STREAM_FIXED_SAMPLE_SIZE: _MFT_INPUT_STREAM_INFO_FLAGS = _MFT_INPUT_STREAM_INFO_FLAGS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_INPUT_STREAM_HOLDS_BUFFERS: _MFT_INPUT_STREAM_INFO_FLAGS = _MFT_INPUT_STREAM_INFO_FLAGS(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_INPUT_STREAM_DOES_NOT_ADDREF: _MFT_INPUT_STREAM_INFO_FLAGS = _MFT_INPUT_STREAM_INFO_FLAGS(256i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_INPUT_STREAM_REMOVABLE: _MFT_INPUT_STREAM_INFO_FLAGS = _MFT_INPUT_STREAM_INFO_FLAGS(512i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_INPUT_STREAM_OPTIONAL: _MFT_INPUT_STREAM_INFO_FLAGS = _MFT_INPUT_STREAM_INFO_FLAGS(1024i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_INPUT_STREAM_PROCESSES_IN_PLACE: _MFT_INPUT_STREAM_INFO_FLAGS = _MFT_INPUT_STREAM_INFO_FLAGS(2048i32);
impl ::core::marker::Copy for _MFT_INPUT_STREAM_INFO_FLAGS {}
impl ::core::clone::Clone for _MFT_INPUT_STREAM_INFO_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _MFT_INPUT_STREAM_INFO_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for _MFT_INPUT_STREAM_INFO_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for _MFT_INPUT_STREAM_INFO_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_MFT_INPUT_STREAM_INFO_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct _MFT_OUTPUT_DATA_BUFFER_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_OUTPUT_DATA_BUFFER_INCOMPLETE: _MFT_OUTPUT_DATA_BUFFER_FLAGS = _MFT_OUTPUT_DATA_BUFFER_FLAGS(16777216i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE: _MFT_OUTPUT_DATA_BUFFER_FLAGS = _MFT_OUTPUT_DATA_BUFFER_FLAGS(256i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_OUTPUT_DATA_BUFFER_STREAM_END: _MFT_OUTPUT_DATA_BUFFER_FLAGS = _MFT_OUTPUT_DATA_BUFFER_FLAGS(512i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE: _MFT_OUTPUT_DATA_BUFFER_FLAGS = _MFT_OUTPUT_DATA_BUFFER_FLAGS(768i32);
impl ::core::marker::Copy for _MFT_OUTPUT_DATA_BUFFER_FLAGS {}
impl ::core::clone::Clone for _MFT_OUTPUT_DATA_BUFFER_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _MFT_OUTPUT_DATA_BUFFER_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for _MFT_OUTPUT_DATA_BUFFER_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for _MFT_OUTPUT_DATA_BUFFER_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_MFT_OUTPUT_DATA_BUFFER_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct _MFT_OUTPUT_STATUS_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_OUTPUT_STATUS_SAMPLE_READY: _MFT_OUTPUT_STATUS_FLAGS = _MFT_OUTPUT_STATUS_FLAGS(1i32);
impl ::core::marker::Copy for _MFT_OUTPUT_STATUS_FLAGS {}
impl ::core::clone::Clone for _MFT_OUTPUT_STATUS_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _MFT_OUTPUT_STATUS_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for _MFT_OUTPUT_STATUS_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for _MFT_OUTPUT_STATUS_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_MFT_OUTPUT_STATUS_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct _MFT_OUTPUT_STREAM_INFO_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_OUTPUT_STREAM_WHOLE_SAMPLES: _MFT_OUTPUT_STREAM_INFO_FLAGS = _MFT_OUTPUT_STREAM_INFO_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_OUTPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER: _MFT_OUTPUT_STREAM_INFO_FLAGS = _MFT_OUTPUT_STREAM_INFO_FLAGS(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE: _MFT_OUTPUT_STREAM_INFO_FLAGS = _MFT_OUTPUT_STREAM_INFO_FLAGS(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_OUTPUT_STREAM_DISCARDABLE: _MFT_OUTPUT_STREAM_INFO_FLAGS = _MFT_OUTPUT_STREAM_INFO_FLAGS(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_OUTPUT_STREAM_OPTIONAL: _MFT_OUTPUT_STREAM_INFO_FLAGS = _MFT_OUTPUT_STREAM_INFO_FLAGS(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_OUTPUT_STREAM_PROVIDES_SAMPLES: _MFT_OUTPUT_STREAM_INFO_FLAGS = _MFT_OUTPUT_STREAM_INFO_FLAGS(256i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES: _MFT_OUTPUT_STREAM_INFO_FLAGS = _MFT_OUTPUT_STREAM_INFO_FLAGS(512i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_OUTPUT_STREAM_LAZY_READ: _MFT_OUTPUT_STREAM_INFO_FLAGS = _MFT_OUTPUT_STREAM_INFO_FLAGS(1024i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_OUTPUT_STREAM_REMOVABLE: _MFT_OUTPUT_STREAM_INFO_FLAGS = _MFT_OUTPUT_STREAM_INFO_FLAGS(2048i32);
impl ::core::marker::Copy for _MFT_OUTPUT_STREAM_INFO_FLAGS {}
impl ::core::clone::Clone for _MFT_OUTPUT_STREAM_INFO_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _MFT_OUTPUT_STREAM_INFO_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for _MFT_OUTPUT_STREAM_INFO_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for _MFT_OUTPUT_STREAM_INFO_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_MFT_OUTPUT_STREAM_INFO_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct _MFT_PROCESS_OUTPUT_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER: _MFT_PROCESS_OUTPUT_FLAGS = _MFT_PROCESS_OUTPUT_FLAGS(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_PROCESS_OUTPUT_REGENERATE_LAST_OUTPUT: _MFT_PROCESS_OUTPUT_FLAGS = _MFT_PROCESS_OUTPUT_FLAGS(2i32);
impl ::core::marker::Copy for _MFT_PROCESS_OUTPUT_FLAGS {}
impl ::core::clone::Clone for _MFT_PROCESS_OUTPUT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _MFT_PROCESS_OUTPUT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for _MFT_PROCESS_OUTPUT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for _MFT_PROCESS_OUTPUT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_MFT_PROCESS_OUTPUT_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct _MFT_PROCESS_OUTPUT_STATUS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_PROCESS_OUTPUT_STATUS_NEW_STREAMS: _MFT_PROCESS_OUTPUT_STATUS = _MFT_PROCESS_OUTPUT_STATUS(256i32);
impl ::core::marker::Copy for _MFT_PROCESS_OUTPUT_STATUS {}
impl ::core::clone::Clone for _MFT_PROCESS_OUTPUT_STATUS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _MFT_PROCESS_OUTPUT_STATUS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for _MFT_PROCESS_OUTPUT_STATUS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for _MFT_PROCESS_OUTPUT_STATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_MFT_PROCESS_OUTPUT_STATUS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct _MFT_SET_TYPE_FLAGS(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const MFT_SET_TYPE_TEST_ONLY: _MFT_SET_TYPE_FLAGS = _MFT_SET_TYPE_FLAGS(1i32);
impl ::core::marker::Copy for _MFT_SET_TYPE_FLAGS {}
impl ::core::clone::Clone for _MFT_SET_TYPE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _MFT_SET_TYPE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for _MFT_SET_TYPE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for _MFT_SET_TYPE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_MFT_SET_TYPE_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVAudioChannelConfig(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVAudioChannelConfig_FRONT_LEFT: eAVAudioChannelConfig = eAVAudioChannelConfig(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVAudioChannelConfig_FRONT_RIGHT: eAVAudioChannelConfig = eAVAudioChannelConfig(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVAudioChannelConfig_FRONT_CENTER: eAVAudioChannelConfig = eAVAudioChannelConfig(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVAudioChannelConfig_LOW_FREQUENCY: eAVAudioChannelConfig = eAVAudioChannelConfig(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVAudioChannelConfig_BACK_LEFT: eAVAudioChannelConfig = eAVAudioChannelConfig(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVAudioChannelConfig_BACK_RIGHT: eAVAudioChannelConfig = eAVAudioChannelConfig(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVAudioChannelConfig_FRONT_LEFT_OF_CENTER: eAVAudioChannelConfig = eAVAudioChannelConfig(64i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVAudioChannelConfig_FRONT_RIGHT_OF_CENTER: eAVAudioChannelConfig = eAVAudioChannelConfig(128i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVAudioChannelConfig_BACK_CENTER: eAVAudioChannelConfig = eAVAudioChannelConfig(256i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVAudioChannelConfig_SIDE_LEFT: eAVAudioChannelConfig = eAVAudioChannelConfig(512i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVAudioChannelConfig_SIDE_RIGHT: eAVAudioChannelConfig = eAVAudioChannelConfig(1024i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVAudioChannelConfig_TOP_CENTER: eAVAudioChannelConfig = eAVAudioChannelConfig(2048i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVAudioChannelConfig_TOP_FRONT_LEFT: eAVAudioChannelConfig = eAVAudioChannelConfig(4096i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVAudioChannelConfig_TOP_FRONT_CENTER: eAVAudioChannelConfig = eAVAudioChannelConfig(8192i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVAudioChannelConfig_TOP_FRONT_RIGHT: eAVAudioChannelConfig = eAVAudioChannelConfig(16384i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVAudioChannelConfig_TOP_BACK_LEFT: eAVAudioChannelConfig = eAVAudioChannelConfig(32768i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVAudioChannelConfig_TOP_BACK_CENTER: eAVAudioChannelConfig = eAVAudioChannelConfig(65536i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVAudioChannelConfig_TOP_BACK_RIGHT: eAVAudioChannelConfig = eAVAudioChannelConfig(131072i32);
impl ::core::marker::Copy for eAVAudioChannelConfig {}
impl ::core::clone::Clone for eAVAudioChannelConfig {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVAudioChannelConfig {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVAudioChannelConfig {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVAudioChannelConfig {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVAudioChannelConfig").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVDDSurroundMode(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDDSurroundMode_NotIndicated: eAVDDSurroundMode = eAVDDSurroundMode(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDDSurroundMode_No: eAVDDSurroundMode = eAVDDSurroundMode(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDDSurroundMode_Yes: eAVDDSurroundMode = eAVDDSurroundMode(2i32);
impl ::core::marker::Copy for eAVDDSurroundMode {}
impl ::core::clone::Clone for eAVDDSurroundMode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVDDSurroundMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVDDSurroundMode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVDDSurroundMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVDDSurroundMode").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVDSPLoudnessEqualization(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDSPLoudnessEqualization_OFF: eAVDSPLoudnessEqualization = eAVDSPLoudnessEqualization(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDSPLoudnessEqualization_ON: eAVDSPLoudnessEqualization = eAVDSPLoudnessEqualization(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDSPLoudnessEqualization_AUTO: eAVDSPLoudnessEqualization = eAVDSPLoudnessEqualization(2i32);
impl ::core::marker::Copy for eAVDSPLoudnessEqualization {}
impl ::core::clone::Clone for eAVDSPLoudnessEqualization {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVDSPLoudnessEqualization {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVDSPLoudnessEqualization {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVDSPLoudnessEqualization {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVDSPLoudnessEqualization").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVDSPSpeakerFill(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDSPSpeakerFill_OFF: eAVDSPSpeakerFill = eAVDSPSpeakerFill(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDSPSpeakerFill_ON: eAVDSPSpeakerFill = eAVDSPSpeakerFill(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDSPSpeakerFill_AUTO: eAVDSPSpeakerFill = eAVDSPSpeakerFill(2i32);
impl ::core::marker::Copy for eAVDSPSpeakerFill {}
impl ::core::clone::Clone for eAVDSPSpeakerFill {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVDSPSpeakerFill {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVDSPSpeakerFill {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVDSPSpeakerFill {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVDSPSpeakerFill").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVDecAACDownmixMode(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecAACUseISODownmix: eAVDecAACDownmixMode = eAVDecAACDownmixMode(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecAACUseARIBDownmix: eAVDecAACDownmixMode = eAVDecAACDownmixMode(1i32);
impl ::core::marker::Copy for eAVDecAACDownmixMode {}
impl ::core::clone::Clone for eAVDecAACDownmixMode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVDecAACDownmixMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVDecAACDownmixMode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVDecAACDownmixMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVDecAACDownmixMode").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVDecAudioDualMono(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecAudioDualMono_IsNotDualMono: eAVDecAudioDualMono = eAVDecAudioDualMono(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecAudioDualMono_IsDualMono: eAVDecAudioDualMono = eAVDecAudioDualMono(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecAudioDualMono_UnSpecified: eAVDecAudioDualMono = eAVDecAudioDualMono(2i32);
impl ::core::marker::Copy for eAVDecAudioDualMono {}
impl ::core::clone::Clone for eAVDecAudioDualMono {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVDecAudioDualMono {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVDecAudioDualMono {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVDecAudioDualMono {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVDecAudioDualMono").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVDecAudioDualMonoReproMode(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecAudioDualMonoReproMode_STEREO: eAVDecAudioDualMonoReproMode = eAVDecAudioDualMonoReproMode(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecAudioDualMonoReproMode_LEFT_MONO: eAVDecAudioDualMonoReproMode = eAVDecAudioDualMonoReproMode(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecAudioDualMonoReproMode_RIGHT_MONO: eAVDecAudioDualMonoReproMode = eAVDecAudioDualMonoReproMode(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecAudioDualMonoReproMode_MIX_MONO: eAVDecAudioDualMonoReproMode = eAVDecAudioDualMonoReproMode(3i32);
impl ::core::marker::Copy for eAVDecAudioDualMonoReproMode {}
impl ::core::clone::Clone for eAVDecAudioDualMonoReproMode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVDecAudioDualMonoReproMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVDecAudioDualMonoReproMode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVDecAudioDualMonoReproMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVDecAudioDualMonoReproMode").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVDecDDMatrixDecodingMode(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecDDMatrixDecodingMode_OFF: eAVDecDDMatrixDecodingMode = eAVDecDDMatrixDecodingMode(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecDDMatrixDecodingMode_ON: eAVDecDDMatrixDecodingMode = eAVDecDDMatrixDecodingMode(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecDDMatrixDecodingMode_AUTO: eAVDecDDMatrixDecodingMode = eAVDecDDMatrixDecodingMode(2i32);
impl ::core::marker::Copy for eAVDecDDMatrixDecodingMode {}
impl ::core::clone::Clone for eAVDecDDMatrixDecodingMode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVDecDDMatrixDecodingMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVDecDDMatrixDecodingMode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVDecDDMatrixDecodingMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVDecDDMatrixDecodingMode").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVDecDDOperationalMode(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecDDOperationalMode_NONE: eAVDecDDOperationalMode = eAVDecDDOperationalMode(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecDDOperationalMode_LINE: eAVDecDDOperationalMode = eAVDecDDOperationalMode(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecDDOperationalMode_RF: eAVDecDDOperationalMode = eAVDecDDOperationalMode(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecDDOperationalMode_CUSTOM0: eAVDecDDOperationalMode = eAVDecDDOperationalMode(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecDDOperationalMode_CUSTOM1: eAVDecDDOperationalMode = eAVDecDDOperationalMode(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecDDOperationalMode_PORTABLE8: eAVDecDDOperationalMode = eAVDecDDOperationalMode(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecDDOperationalMode_PORTABLE11: eAVDecDDOperationalMode = eAVDecDDOperationalMode(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecDDOperationalMode_PORTABLE14: eAVDecDDOperationalMode = eAVDecDDOperationalMode(7i32);
impl ::core::marker::Copy for eAVDecDDOperationalMode {}
impl ::core::clone::Clone for eAVDecDDOperationalMode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVDecDDOperationalMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVDecDDOperationalMode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVDecDDOperationalMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVDecDDOperationalMode").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVDecDDStereoDownMixMode(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecDDStereoDownMixMode_Auto: eAVDecDDStereoDownMixMode = eAVDecDDStereoDownMixMode(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecDDStereoDownMixMode_LtRt: eAVDecDDStereoDownMixMode = eAVDecDDStereoDownMixMode(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecDDStereoDownMixMode_LoRo: eAVDecDDStereoDownMixMode = eAVDecDDStereoDownMixMode(2i32);
impl ::core::marker::Copy for eAVDecDDStereoDownMixMode {}
impl ::core::clone::Clone for eAVDecDDStereoDownMixMode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVDecDDStereoDownMixMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVDecDDStereoDownMixMode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVDecDDStereoDownMixMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVDecDDStereoDownMixMode").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVDecHEAACDynamicRangeControl(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecHEAACDynamicRangeControl_OFF: eAVDecHEAACDynamicRangeControl = eAVDecHEAACDynamicRangeControl(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecHEAACDynamicRangeControl_ON: eAVDecHEAACDynamicRangeControl = eAVDecHEAACDynamicRangeControl(1i32);
impl ::core::marker::Copy for eAVDecHEAACDynamicRangeControl {}
impl ::core::clone::Clone for eAVDecHEAACDynamicRangeControl {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVDecHEAACDynamicRangeControl {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVDecHEAACDynamicRangeControl {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVDecHEAACDynamicRangeControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVDecHEAACDynamicRangeControl").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVDecVideoCodecType(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecVideoCodecType_NOTPLAYING: eAVDecVideoCodecType = eAVDecVideoCodecType(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecVideoCodecType_MPEG2: eAVDecVideoCodecType = eAVDecVideoCodecType(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecVideoCodecType_H264: eAVDecVideoCodecType = eAVDecVideoCodecType(2i32);
impl ::core::marker::Copy for eAVDecVideoCodecType {}
impl ::core::clone::Clone for eAVDecVideoCodecType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVDecVideoCodecType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVDecVideoCodecType {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVDecVideoCodecType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVDecVideoCodecType").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVDecVideoDXVABusEncryption(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecVideoDXVABusEncryption_NONE: eAVDecVideoDXVABusEncryption = eAVDecVideoDXVABusEncryption(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecVideoDXVABusEncryption_PRIVATE: eAVDecVideoDXVABusEncryption = eAVDecVideoDXVABusEncryption(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecVideoDXVABusEncryption_AES: eAVDecVideoDXVABusEncryption = eAVDecVideoDXVABusEncryption(2i32);
impl ::core::marker::Copy for eAVDecVideoDXVABusEncryption {}
impl ::core::clone::Clone for eAVDecVideoDXVABusEncryption {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVDecVideoDXVABusEncryption {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVDecVideoDXVABusEncryption {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVDecVideoDXVABusEncryption {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVDecVideoDXVABusEncryption").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVDecVideoDXVAMode(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecVideoDXVAMode_NOTPLAYING: eAVDecVideoDXVAMode = eAVDecVideoDXVAMode(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecVideoDXVAMode_SW: eAVDecVideoDXVAMode = eAVDecVideoDXVAMode(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecVideoDXVAMode_MC: eAVDecVideoDXVAMode = eAVDecVideoDXVAMode(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecVideoDXVAMode_IDCT: eAVDecVideoDXVAMode = eAVDecVideoDXVAMode(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecVideoDXVAMode_VLD: eAVDecVideoDXVAMode = eAVDecVideoDXVAMode(4i32);
impl ::core::marker::Copy for eAVDecVideoDXVAMode {}
impl ::core::clone::Clone for eAVDecVideoDXVAMode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVDecVideoDXVAMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVDecVideoDXVAMode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVDecVideoDXVAMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVDecVideoDXVAMode").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVDecVideoH264ErrorConcealment(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eErrorConcealmentTypeDrop: eAVDecVideoH264ErrorConcealment = eAVDecVideoH264ErrorConcealment(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eErrorConcealmentTypeBasic: eAVDecVideoH264ErrorConcealment = eAVDecVideoH264ErrorConcealment(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eErrorConcealmentTypeAdvanced: eAVDecVideoH264ErrorConcealment = eAVDecVideoH264ErrorConcealment(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eErrorConcealmentTypeDXVASetBlack: eAVDecVideoH264ErrorConcealment = eAVDecVideoH264ErrorConcealment(3i32);
impl ::core::marker::Copy for eAVDecVideoH264ErrorConcealment {}
impl ::core::clone::Clone for eAVDecVideoH264ErrorConcealment {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVDecVideoH264ErrorConcealment {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVDecVideoH264ErrorConcealment {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVDecVideoH264ErrorConcealment {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVDecVideoH264ErrorConcealment").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVDecVideoInputScanType(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecVideoInputScan_Unknown: eAVDecVideoInputScanType = eAVDecVideoInputScanType(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecVideoInputScan_Progressive: eAVDecVideoInputScanType = eAVDecVideoInputScanType(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecVideoInputScan_Interlaced_UpperFieldFirst: eAVDecVideoInputScanType = eAVDecVideoInputScanType(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecVideoInputScan_Interlaced_LowerFieldFirst: eAVDecVideoInputScanType = eAVDecVideoInputScanType(3i32);
impl ::core::marker::Copy for eAVDecVideoInputScanType {}
impl ::core::clone::Clone for eAVDecVideoInputScanType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVDecVideoInputScanType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVDecVideoInputScanType {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVDecVideoInputScanType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVDecVideoInputScanType").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVDecVideoMPEG2ErrorConcealment(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eErrorConcealmentOff: eAVDecVideoMPEG2ErrorConcealment = eAVDecVideoMPEG2ErrorConcealment(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eErrorConcealmentOn: eAVDecVideoMPEG2ErrorConcealment = eAVDecVideoMPEG2ErrorConcealment(1i32);
impl ::core::marker::Copy for eAVDecVideoMPEG2ErrorConcealment {}
impl ::core::clone::Clone for eAVDecVideoMPEG2ErrorConcealment {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVDecVideoMPEG2ErrorConcealment {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVDecVideoMPEG2ErrorConcealment {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVDecVideoMPEG2ErrorConcealment {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVDecVideoMPEG2ErrorConcealment").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVDecVideoSWPowerLevel(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecVideoSWPowerLevel_BatteryLife: eAVDecVideoSWPowerLevel = eAVDecVideoSWPowerLevel(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecVideoSWPowerLevel_Balanced: eAVDecVideoSWPowerLevel = eAVDecVideoSWPowerLevel(50i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecVideoSWPowerLevel_VideoQuality: eAVDecVideoSWPowerLevel = eAVDecVideoSWPowerLevel(100i32);
impl ::core::marker::Copy for eAVDecVideoSWPowerLevel {}
impl ::core::clone::Clone for eAVDecVideoSWPowerLevel {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVDecVideoSWPowerLevel {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVDecVideoSWPowerLevel {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVDecVideoSWPowerLevel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVDecVideoSWPowerLevel").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVDecVideoSoftwareDeinterlaceMode(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecVideoSoftwareDeinterlaceMode_NoDeinterlacing: eAVDecVideoSoftwareDeinterlaceMode = eAVDecVideoSoftwareDeinterlaceMode(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecVideoSoftwareDeinterlaceMode_ProgressiveDeinterlacing: eAVDecVideoSoftwareDeinterlaceMode = eAVDecVideoSoftwareDeinterlaceMode(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecVideoSoftwareDeinterlaceMode_BOBDeinterlacing: eAVDecVideoSoftwareDeinterlaceMode = eAVDecVideoSoftwareDeinterlaceMode(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVDecVideoSoftwareDeinterlaceMode_SmartBOBDeinterlacing: eAVDecVideoSoftwareDeinterlaceMode = eAVDecVideoSoftwareDeinterlaceMode(3i32);
impl ::core::marker::Copy for eAVDecVideoSoftwareDeinterlaceMode {}
impl ::core::clone::Clone for eAVDecVideoSoftwareDeinterlaceMode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVDecVideoSoftwareDeinterlaceMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVDecVideoSoftwareDeinterlaceMode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVDecVideoSoftwareDeinterlaceMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVDecVideoSoftwareDeinterlaceMode").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncAV1PictureType(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1PictureType_Key: eAVEncAV1PictureType = eAVEncAV1PictureType(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1PictureType_Intra_Only: eAVEncAV1PictureType = eAVEncAV1PictureType(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1PictureType_Inter: eAVEncAV1PictureType = eAVEncAV1PictureType(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1PictureType_Switch: eAVEncAV1PictureType = eAVEncAV1PictureType(3i32);
impl ::core::marker::Copy for eAVEncAV1PictureType {}
impl ::core::clone::Clone for eAVEncAV1PictureType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncAV1PictureType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncAV1PictureType {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncAV1PictureType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncAV1PictureType").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncAV1VLevel(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VLevel2: eAVEncAV1VLevel = eAVEncAV1VLevel(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VLevel2_1: eAVEncAV1VLevel = eAVEncAV1VLevel(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VLevel3: eAVEncAV1VLevel = eAVEncAV1VLevel(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VLevel3_1: eAVEncAV1VLevel = eAVEncAV1VLevel(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VLevel4: eAVEncAV1VLevel = eAVEncAV1VLevel(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VLevel4_1: eAVEncAV1VLevel = eAVEncAV1VLevel(9i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VLevel5: eAVEncAV1VLevel = eAVEncAV1VLevel(12i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VLevel5_1: eAVEncAV1VLevel = eAVEncAV1VLevel(13i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VLevel5_2: eAVEncAV1VLevel = eAVEncAV1VLevel(14i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VLevel5_3: eAVEncAV1VLevel = eAVEncAV1VLevel(15i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VLevel6: eAVEncAV1VLevel = eAVEncAV1VLevel(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VLevel6_1: eAVEncAV1VLevel = eAVEncAV1VLevel(17i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VLevel6_2: eAVEncAV1VLevel = eAVEncAV1VLevel(18i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VLevel6_3: eAVEncAV1VLevel = eAVEncAV1VLevel(19i32);
impl ::core::marker::Copy for eAVEncAV1VLevel {}
impl ::core::clone::Clone for eAVEncAV1VLevel {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncAV1VLevel {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncAV1VLevel {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncAV1VLevel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncAV1VLevel").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncAV1VProfile(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VProfile_unknown: eAVEncAV1VProfile = eAVEncAV1VProfile(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VProfile_Main_420_8: eAVEncAV1VProfile = eAVEncAV1VProfile(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VProfile_Main_420_10: eAVEncAV1VProfile = eAVEncAV1VProfile(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VProfile_Main_400_8: eAVEncAV1VProfile = eAVEncAV1VProfile(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VProfile_Main_400_10: eAVEncAV1VProfile = eAVEncAV1VProfile(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VProfile_High_444_8: eAVEncAV1VProfile = eAVEncAV1VProfile(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VProfile_High_444_10: eAVEncAV1VProfile = eAVEncAV1VProfile(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VProfile_Professional_420_12: eAVEncAV1VProfile = eAVEncAV1VProfile(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VProfile_Professional_400_12: eAVEncAV1VProfile = eAVEncAV1VProfile(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VProfile_Professional_444_12: eAVEncAV1VProfile = eAVEncAV1VProfile(9i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VProfile_Professional_422_8: eAVEncAV1VProfile = eAVEncAV1VProfile(10i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VProfile_Professional_422_10: eAVEncAV1VProfile = eAVEncAV1VProfile(11i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAV1VProfile_Professional_422_12: eAVEncAV1VProfile = eAVEncAV1VProfile(12i32);
impl ::core::marker::Copy for eAVEncAV1VProfile {}
impl ::core::clone::Clone for eAVEncAV1VProfile {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncAV1VProfile {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncAV1VProfile {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncAV1VProfile {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncAV1VProfile").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncAdaptiveMode(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAdaptiveMode_None: eAVEncAdaptiveMode = eAVEncAdaptiveMode(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAdaptiveMode_Resolution: eAVEncAdaptiveMode = eAVEncAdaptiveMode(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAdaptiveMode_FrameRate: eAVEncAdaptiveMode = eAVEncAdaptiveMode(2i32);
impl ::core::marker::Copy for eAVEncAdaptiveMode {}
impl ::core::clone::Clone for eAVEncAdaptiveMode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncAdaptiveMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncAdaptiveMode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncAdaptiveMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncAdaptiveMode").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncAudioDualMono(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAudioDualMono_SameAsInput: eAVEncAudioDualMono = eAVEncAudioDualMono(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAudioDualMono_Off: eAVEncAudioDualMono = eAVEncAudioDualMono(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncAudioDualMono_On: eAVEncAudioDualMono = eAVEncAudioDualMono(2i32);
impl ::core::marker::Copy for eAVEncAudioDualMono {}
impl ::core::clone::Clone for eAVEncAudioDualMono {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncAudioDualMono {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncAudioDualMono {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncAudioDualMono {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncAudioDualMono").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncAudioInputContent(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AVEncAudioInputContent_Unknown: eAVEncAudioInputContent = eAVEncAudioInputContent(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AVEncAudioInputContent_Voice: eAVEncAudioInputContent = eAVEncAudioInputContent(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const AVEncAudioInputContent_Music: eAVEncAudioInputContent = eAVEncAudioInputContent(2i32);
impl ::core::marker::Copy for eAVEncAudioInputContent {}
impl ::core::clone::Clone for eAVEncAudioInputContent {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncAudioInputContent {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncAudioInputContent {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncAudioInputContent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncAudioInputContent").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncChromaEncodeMode(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncChromaEncodeMode_420: eAVEncChromaEncodeMode = eAVEncChromaEncodeMode(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncChromaEncodeMode_444: eAVEncChromaEncodeMode = eAVEncChromaEncodeMode(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncChromaEncodeMode_444_v2: eAVEncChromaEncodeMode = eAVEncChromaEncodeMode(2i32);
impl ::core::marker::Copy for eAVEncChromaEncodeMode {}
impl ::core::clone::Clone for eAVEncChromaEncodeMode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncChromaEncodeMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncChromaEncodeMode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncChromaEncodeMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncChromaEncodeMode").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncCommonRateControlMode(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncCommonRateControlMode_CBR: eAVEncCommonRateControlMode = eAVEncCommonRateControlMode(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncCommonRateControlMode_PeakConstrainedVBR: eAVEncCommonRateControlMode = eAVEncCommonRateControlMode(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncCommonRateControlMode_UnconstrainedVBR: eAVEncCommonRateControlMode = eAVEncCommonRateControlMode(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncCommonRateControlMode_Quality: eAVEncCommonRateControlMode = eAVEncCommonRateControlMode(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncCommonRateControlMode_LowDelayVBR: eAVEncCommonRateControlMode = eAVEncCommonRateControlMode(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncCommonRateControlMode_GlobalVBR: eAVEncCommonRateControlMode = eAVEncCommonRateControlMode(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncCommonRateControlMode_GlobalLowDelayVBR: eAVEncCommonRateControlMode = eAVEncCommonRateControlMode(6i32);
impl ::core::marker::Copy for eAVEncCommonRateControlMode {}
impl ::core::clone::Clone for eAVEncCommonRateControlMode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncCommonRateControlMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncCommonRateControlMode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncCommonRateControlMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncCommonRateControlMode").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncCommonStreamEndHandling(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncCommonStreamEndHandling_DiscardPartial: eAVEncCommonStreamEndHandling = eAVEncCommonStreamEndHandling(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncCommonStreamEndHandling_EnsureComplete: eAVEncCommonStreamEndHandling = eAVEncCommonStreamEndHandling(1i32);
impl ::core::marker::Copy for eAVEncCommonStreamEndHandling {}
impl ::core::clone::Clone for eAVEncCommonStreamEndHandling {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncCommonStreamEndHandling {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncCommonStreamEndHandling {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncCommonStreamEndHandling {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncCommonStreamEndHandling").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncDDAtoDConverterType(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDAtoDConverterType_Standard: eAVEncDDAtoDConverterType = eAVEncDDAtoDConverterType(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDAtoDConverterType_HDCD: eAVEncDDAtoDConverterType = eAVEncDDAtoDConverterType(1i32);
impl ::core::marker::Copy for eAVEncDDAtoDConverterType {}
impl ::core::clone::Clone for eAVEncDDAtoDConverterType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncDDAtoDConverterType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncDDAtoDConverterType {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncDDAtoDConverterType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncDDAtoDConverterType").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncDDDynamicRangeCompressionControl(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDDynamicRangeCompressionControl_None: eAVEncDDDynamicRangeCompressionControl = eAVEncDDDynamicRangeCompressionControl(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDDynamicRangeCompressionControl_FilmStandard: eAVEncDDDynamicRangeCompressionControl = eAVEncDDDynamicRangeCompressionControl(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDDynamicRangeCompressionControl_FilmLight: eAVEncDDDynamicRangeCompressionControl = eAVEncDDDynamicRangeCompressionControl(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDDynamicRangeCompressionControl_MusicStandard: eAVEncDDDynamicRangeCompressionControl = eAVEncDDDynamicRangeCompressionControl(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDDynamicRangeCompressionControl_MusicLight: eAVEncDDDynamicRangeCompressionControl = eAVEncDDDynamicRangeCompressionControl(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDDynamicRangeCompressionControl_Speech: eAVEncDDDynamicRangeCompressionControl = eAVEncDDDynamicRangeCompressionControl(5i32);
impl ::core::marker::Copy for eAVEncDDDynamicRangeCompressionControl {}
impl ::core::clone::Clone for eAVEncDDDynamicRangeCompressionControl {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncDDDynamicRangeCompressionControl {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncDDDynamicRangeCompressionControl {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncDDDynamicRangeCompressionControl {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncDDDynamicRangeCompressionControl").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncDDHeadphoneMode(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDHeadphoneMode_NotIndicated: eAVEncDDHeadphoneMode = eAVEncDDHeadphoneMode(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDHeadphoneMode_NotEncoded: eAVEncDDHeadphoneMode = eAVEncDDHeadphoneMode(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDHeadphoneMode_Encoded: eAVEncDDHeadphoneMode = eAVEncDDHeadphoneMode(2i32);
impl ::core::marker::Copy for eAVEncDDHeadphoneMode {}
impl ::core::clone::Clone for eAVEncDDHeadphoneMode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncDDHeadphoneMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncDDHeadphoneMode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncDDHeadphoneMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncDDHeadphoneMode").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncDDPreferredStereoDownMixMode(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDPreferredStereoDownMixMode_LtRt: eAVEncDDPreferredStereoDownMixMode = eAVEncDDPreferredStereoDownMixMode(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDPreferredStereoDownMixMode_LoRo: eAVEncDDPreferredStereoDownMixMode = eAVEncDDPreferredStereoDownMixMode(1i32);
impl ::core::marker::Copy for eAVEncDDPreferredStereoDownMixMode {}
impl ::core::clone::Clone for eAVEncDDPreferredStereoDownMixMode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncDDPreferredStereoDownMixMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncDDPreferredStereoDownMixMode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncDDPreferredStereoDownMixMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncDDPreferredStereoDownMixMode").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncDDProductionRoomType(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDProductionRoomType_NotIndicated: eAVEncDDProductionRoomType = eAVEncDDProductionRoomType(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDProductionRoomType_Large: eAVEncDDProductionRoomType = eAVEncDDProductionRoomType(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDProductionRoomType_Small: eAVEncDDProductionRoomType = eAVEncDDProductionRoomType(2i32);
impl ::core::marker::Copy for eAVEncDDProductionRoomType {}
impl ::core::clone::Clone for eAVEncDDProductionRoomType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncDDProductionRoomType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncDDProductionRoomType {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncDDProductionRoomType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncDDProductionRoomType").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncDDService(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDService_CM: eAVEncDDService = eAVEncDDService(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDService_ME: eAVEncDDService = eAVEncDDService(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDService_VI: eAVEncDDService = eAVEncDDService(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDService_HI: eAVEncDDService = eAVEncDDService(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDService_D: eAVEncDDService = eAVEncDDService(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDService_C: eAVEncDDService = eAVEncDDService(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDService_E: eAVEncDDService = eAVEncDDService(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDService_VO: eAVEncDDService = eAVEncDDService(7i32);
impl ::core::marker::Copy for eAVEncDDService {}
impl ::core::clone::Clone for eAVEncDDService {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncDDService {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncDDService {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncDDService {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncDDService").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncDDSurroundExMode(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDSurroundExMode_NotIndicated: eAVEncDDSurroundExMode = eAVEncDDSurroundExMode(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDSurroundExMode_No: eAVEncDDSurroundExMode = eAVEncDDSurroundExMode(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncDDSurroundExMode_Yes: eAVEncDDSurroundExMode = eAVEncDDSurroundExMode(2i32);
impl ::core::marker::Copy for eAVEncDDSurroundExMode {}
impl ::core::clone::Clone for eAVEncDDSurroundExMode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncDDSurroundExMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncDDSurroundExMode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncDDSurroundExMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncDDSurroundExMode").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncH263PictureType(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH263PictureType_I: eAVEncH263PictureType = eAVEncH263PictureType(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH263PictureType_P: eAVEncH263PictureType = eAVEncH263PictureType(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH263PictureType_B: eAVEncH263PictureType = eAVEncH263PictureType(2i32);
impl ::core::marker::Copy for eAVEncH263PictureType {}
impl ::core::clone::Clone for eAVEncH263PictureType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncH263PictureType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncH263PictureType {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncH263PictureType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncH263PictureType").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncH263VLevel(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH263VLevel1: eAVEncH263VLevel = eAVEncH263VLevel(10i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH263VLevel2: eAVEncH263VLevel = eAVEncH263VLevel(20i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH263VLevel3: eAVEncH263VLevel = eAVEncH263VLevel(30i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH263VLevel4: eAVEncH263VLevel = eAVEncH263VLevel(40i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH263VLevel4_5: eAVEncH263VLevel = eAVEncH263VLevel(45i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH263VLevel5: eAVEncH263VLevel = eAVEncH263VLevel(50i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH263VLevel6: eAVEncH263VLevel = eAVEncH263VLevel(60i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH263VLevel7: eAVEncH263VLevel = eAVEncH263VLevel(70i32);
impl ::core::marker::Copy for eAVEncH263VLevel {}
impl ::core::clone::Clone for eAVEncH263VLevel {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncH263VLevel {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncH263VLevel {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncH263VLevel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncH263VLevel").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncH263VProfile(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH263VProfile_Base: eAVEncH263VProfile = eAVEncH263VProfile(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH263VProfile_CompatibilityV2: eAVEncH263VProfile = eAVEncH263VProfile(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH263VProfile_CompatibilityV1: eAVEncH263VProfile = eAVEncH263VProfile(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH263VProfile_WirelessV2: eAVEncH263VProfile = eAVEncH263VProfile(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH263VProfile_WirelessV3: eAVEncH263VProfile = eAVEncH263VProfile(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH263VProfile_HighCompression: eAVEncH263VProfile = eAVEncH263VProfile(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH263VProfile_Internet: eAVEncH263VProfile = eAVEncH263VProfile(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH263VProfile_Interlace: eAVEncH263VProfile = eAVEncH263VProfile(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH263VProfile_HighLatency: eAVEncH263VProfile = eAVEncH263VProfile(8i32);
impl ::core::marker::Copy for eAVEncH263VProfile {}
impl ::core::clone::Clone for eAVEncH263VProfile {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncH263VProfile {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncH263VProfile {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncH263VProfile {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncH263VProfile").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncH264PictureType(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264PictureType_IDR: eAVEncH264PictureType = eAVEncH264PictureType(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264PictureType_P: eAVEncH264PictureType = eAVEncH264PictureType(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264PictureType_B: eAVEncH264PictureType = eAVEncH264PictureType(2i32);
impl ::core::marker::Copy for eAVEncH264PictureType {}
impl ::core::clone::Clone for eAVEncH264PictureType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncH264PictureType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncH264PictureType {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncH264PictureType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncH264PictureType").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncH264VLevel(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VLevel1: eAVEncH264VLevel = eAVEncH264VLevel(10i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VLevel1_b: eAVEncH264VLevel = eAVEncH264VLevel(11i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VLevel1_1: eAVEncH264VLevel = eAVEncH264VLevel(11i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VLevel1_2: eAVEncH264VLevel = eAVEncH264VLevel(12i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VLevel1_3: eAVEncH264VLevel = eAVEncH264VLevel(13i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VLevel2: eAVEncH264VLevel = eAVEncH264VLevel(20i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VLevel2_1: eAVEncH264VLevel = eAVEncH264VLevel(21i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VLevel2_2: eAVEncH264VLevel = eAVEncH264VLevel(22i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VLevel3: eAVEncH264VLevel = eAVEncH264VLevel(30i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VLevel3_1: eAVEncH264VLevel = eAVEncH264VLevel(31i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VLevel3_2: eAVEncH264VLevel = eAVEncH264VLevel(32i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VLevel4: eAVEncH264VLevel = eAVEncH264VLevel(40i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VLevel4_1: eAVEncH264VLevel = eAVEncH264VLevel(41i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VLevel4_2: eAVEncH264VLevel = eAVEncH264VLevel(42i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VLevel5: eAVEncH264VLevel = eAVEncH264VLevel(50i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VLevel5_1: eAVEncH264VLevel = eAVEncH264VLevel(51i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VLevel5_2: eAVEncH264VLevel = eAVEncH264VLevel(52i32);
impl ::core::marker::Copy for eAVEncH264VLevel {}
impl ::core::clone::Clone for eAVEncH264VLevel {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncH264VLevel {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncH264VLevel {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncH264VLevel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncH264VLevel").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncH264VProfile(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VProfile_unknown: eAVEncH264VProfile = eAVEncH264VProfile(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VProfile_Simple: eAVEncH264VProfile = eAVEncH264VProfile(66i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VProfile_Base: eAVEncH264VProfile = eAVEncH264VProfile(66i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VProfile_Main: eAVEncH264VProfile = eAVEncH264VProfile(77i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VProfile_High: eAVEncH264VProfile = eAVEncH264VProfile(100i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VProfile_422: eAVEncH264VProfile = eAVEncH264VProfile(122i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VProfile_High10: eAVEncH264VProfile = eAVEncH264VProfile(110i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VProfile_444: eAVEncH264VProfile = eAVEncH264VProfile(244i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VProfile_Extended: eAVEncH264VProfile = eAVEncH264VProfile(88i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VProfile_ScalableBase: eAVEncH264VProfile = eAVEncH264VProfile(83i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VProfile_ScalableHigh: eAVEncH264VProfile = eAVEncH264VProfile(86i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VProfile_MultiviewHigh: eAVEncH264VProfile = eAVEncH264VProfile(118i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VProfile_StereoHigh: eAVEncH264VProfile = eAVEncH264VProfile(128i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VProfile_ConstrainedBase: eAVEncH264VProfile = eAVEncH264VProfile(256i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VProfile_UCConstrainedHigh: eAVEncH264VProfile = eAVEncH264VProfile(257i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VProfile_UCScalableConstrainedBase: eAVEncH264VProfile = eAVEncH264VProfile(258i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH264VProfile_UCScalableConstrainedHigh: eAVEncH264VProfile = eAVEncH264VProfile(259i32);
impl ::core::marker::Copy for eAVEncH264VProfile {}
impl ::core::clone::Clone for eAVEncH264VProfile {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncH264VProfile {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncH264VProfile {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncH264VProfile {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncH264VProfile").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncH265VLevel(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VLevel1: eAVEncH265VLevel = eAVEncH265VLevel(30i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VLevel2: eAVEncH265VLevel = eAVEncH265VLevel(60i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VLevel2_1: eAVEncH265VLevel = eAVEncH265VLevel(63i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VLevel3: eAVEncH265VLevel = eAVEncH265VLevel(90i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VLevel3_1: eAVEncH265VLevel = eAVEncH265VLevel(93i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VLevel4: eAVEncH265VLevel = eAVEncH265VLevel(120i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VLevel4_1: eAVEncH265VLevel = eAVEncH265VLevel(123i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VLevel5: eAVEncH265VLevel = eAVEncH265VLevel(150i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VLevel5_1: eAVEncH265VLevel = eAVEncH265VLevel(153i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VLevel5_2: eAVEncH265VLevel = eAVEncH265VLevel(156i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VLevel6: eAVEncH265VLevel = eAVEncH265VLevel(180i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VLevel6_1: eAVEncH265VLevel = eAVEncH265VLevel(183i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VLevel6_2: eAVEncH265VLevel = eAVEncH265VLevel(186i32);
impl ::core::marker::Copy for eAVEncH265VLevel {}
impl ::core::clone::Clone for eAVEncH265VLevel {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncH265VLevel {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncH265VLevel {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncH265VLevel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncH265VLevel").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncH265VProfile(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VProfile_unknown: eAVEncH265VProfile = eAVEncH265VProfile(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VProfile_Main_420_8: eAVEncH265VProfile = eAVEncH265VProfile(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VProfile_Main_420_10: eAVEncH265VProfile = eAVEncH265VProfile(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VProfile_Main_420_12: eAVEncH265VProfile = eAVEncH265VProfile(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VProfile_Main_422_10: eAVEncH265VProfile = eAVEncH265VProfile(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VProfile_Main_422_12: eAVEncH265VProfile = eAVEncH265VProfile(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VProfile_Main_444_8: eAVEncH265VProfile = eAVEncH265VProfile(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VProfile_Main_444_10: eAVEncH265VProfile = eAVEncH265VProfile(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VProfile_Main_444_12: eAVEncH265VProfile = eAVEncH265VProfile(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VProfile_Monochrome_12: eAVEncH265VProfile = eAVEncH265VProfile(9i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VProfile_Monochrome_16: eAVEncH265VProfile = eAVEncH265VProfile(10i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VProfile_MainIntra_420_8: eAVEncH265VProfile = eAVEncH265VProfile(11i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VProfile_MainIntra_420_10: eAVEncH265VProfile = eAVEncH265VProfile(12i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VProfile_MainIntra_420_12: eAVEncH265VProfile = eAVEncH265VProfile(13i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VProfile_MainIntra_422_10: eAVEncH265VProfile = eAVEncH265VProfile(14i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VProfile_MainIntra_422_12: eAVEncH265VProfile = eAVEncH265VProfile(15i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VProfile_MainIntra_444_8: eAVEncH265VProfile = eAVEncH265VProfile(16i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VProfile_MainIntra_444_10: eAVEncH265VProfile = eAVEncH265VProfile(17i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VProfile_MainIntra_444_12: eAVEncH265VProfile = eAVEncH265VProfile(18i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VProfile_MainIntra_444_16: eAVEncH265VProfile = eAVEncH265VProfile(19i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VProfile_MainStill_420_8: eAVEncH265VProfile = eAVEncH265VProfile(20i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VProfile_MainStill_444_8: eAVEncH265VProfile = eAVEncH265VProfile(21i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncH265VProfile_MainStill_444_16: eAVEncH265VProfile = eAVEncH265VProfile(22i32);
impl ::core::marker::Copy for eAVEncH265VProfile {}
impl ::core::clone::Clone for eAVEncH265VProfile {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncH265VProfile {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncH265VProfile {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncH265VProfile {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncH265VProfile").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncInputVideoSystem(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncInputVideoSystem_Unspecified: eAVEncInputVideoSystem = eAVEncInputVideoSystem(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncInputVideoSystem_PAL: eAVEncInputVideoSystem = eAVEncInputVideoSystem(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncInputVideoSystem_NTSC: eAVEncInputVideoSystem = eAVEncInputVideoSystem(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncInputVideoSystem_SECAM: eAVEncInputVideoSystem = eAVEncInputVideoSystem(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncInputVideoSystem_MAC: eAVEncInputVideoSystem = eAVEncInputVideoSystem(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncInputVideoSystem_HDV: eAVEncInputVideoSystem = eAVEncInputVideoSystem(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncInputVideoSystem_Component: eAVEncInputVideoSystem = eAVEncInputVideoSystem(6i32);
impl ::core::marker::Copy for eAVEncInputVideoSystem {}
impl ::core::clone::Clone for eAVEncInputVideoSystem {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncInputVideoSystem {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncInputVideoSystem {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncInputVideoSystem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncInputVideoSystem").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncMPACodingMode(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPACodingMode_Mono: eAVEncMPACodingMode = eAVEncMPACodingMode(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPACodingMode_Stereo: eAVEncMPACodingMode = eAVEncMPACodingMode(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPACodingMode_DualChannel: eAVEncMPACodingMode = eAVEncMPACodingMode(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPACodingMode_JointStereo: eAVEncMPACodingMode = eAVEncMPACodingMode(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPACodingMode_Surround: eAVEncMPACodingMode = eAVEncMPACodingMode(4i32);
impl ::core::marker::Copy for eAVEncMPACodingMode {}
impl ::core::clone::Clone for eAVEncMPACodingMode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncMPACodingMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncMPACodingMode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncMPACodingMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncMPACodingMode").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncMPAEmphasisType(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPAEmphasisType_None: eAVEncMPAEmphasisType = eAVEncMPAEmphasisType(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPAEmphasisType_50_15: eAVEncMPAEmphasisType = eAVEncMPAEmphasisType(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPAEmphasisType_Reserved: eAVEncMPAEmphasisType = eAVEncMPAEmphasisType(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPAEmphasisType_CCITT_J17: eAVEncMPAEmphasisType = eAVEncMPAEmphasisType(3i32);
impl ::core::marker::Copy for eAVEncMPAEmphasisType {}
impl ::core::clone::Clone for eAVEncMPAEmphasisType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncMPAEmphasisType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncMPAEmphasisType {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncMPAEmphasisType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncMPAEmphasisType").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncMPALayer(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPALayer_1: eAVEncMPALayer = eAVEncMPALayer(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPALayer_2: eAVEncMPALayer = eAVEncMPALayer(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPALayer_3: eAVEncMPALayer = eAVEncMPALayer(3i32);
impl ::core::marker::Copy for eAVEncMPALayer {}
impl ::core::clone::Clone for eAVEncMPALayer {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncMPALayer {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncMPALayer {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncMPALayer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncMPALayer").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncMPVFrameFieldMode(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVFrameFieldMode_FieldMode: eAVEncMPVFrameFieldMode = eAVEncMPVFrameFieldMode(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVFrameFieldMode_FrameMode: eAVEncMPVFrameFieldMode = eAVEncMPVFrameFieldMode(1i32);
impl ::core::marker::Copy for eAVEncMPVFrameFieldMode {}
impl ::core::clone::Clone for eAVEncMPVFrameFieldMode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncMPVFrameFieldMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncMPVFrameFieldMode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncMPVFrameFieldMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncMPVFrameFieldMode").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncMPVIntraVLCTable(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVIntraVLCTable_Auto: eAVEncMPVIntraVLCTable = eAVEncMPVIntraVLCTable(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVIntraVLCTable_MPEG1: eAVEncMPVIntraVLCTable = eAVEncMPVIntraVLCTable(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVIntraVLCTable_Alternate: eAVEncMPVIntraVLCTable = eAVEncMPVIntraVLCTable(2i32);
impl ::core::marker::Copy for eAVEncMPVIntraVLCTable {}
impl ::core::clone::Clone for eAVEncMPVIntraVLCTable {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncMPVIntraVLCTable {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncMPVIntraVLCTable {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncMPVIntraVLCTable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncMPVIntraVLCTable").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncMPVLevel(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVLevel_Low: eAVEncMPVLevel = eAVEncMPVLevel(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVLevel_Main: eAVEncMPVLevel = eAVEncMPVLevel(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVLevel_High1440: eAVEncMPVLevel = eAVEncMPVLevel(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVLevel_High: eAVEncMPVLevel = eAVEncMPVLevel(4i32);
impl ::core::marker::Copy for eAVEncMPVLevel {}
impl ::core::clone::Clone for eAVEncMPVLevel {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncMPVLevel {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncMPVLevel {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncMPVLevel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncMPVLevel").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncMPVProfile(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVProfile_unknown: eAVEncMPVProfile = eAVEncMPVProfile(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVProfile_Simple: eAVEncMPVProfile = eAVEncMPVProfile(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVProfile_Main: eAVEncMPVProfile = eAVEncMPVProfile(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVProfile_High: eAVEncMPVProfile = eAVEncMPVProfile(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVProfile_422: eAVEncMPVProfile = eAVEncMPVProfile(4i32);
impl ::core::marker::Copy for eAVEncMPVProfile {}
impl ::core::clone::Clone for eAVEncMPVProfile {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncMPVProfile {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncMPVProfile {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncMPVProfile {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncMPVProfile").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncMPVQScaleType(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVQScaleType_Auto: eAVEncMPVQScaleType = eAVEncMPVQScaleType(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVQScaleType_Linear: eAVEncMPVQScaleType = eAVEncMPVQScaleType(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVQScaleType_NonLinear: eAVEncMPVQScaleType = eAVEncMPVQScaleType(2i32);
impl ::core::marker::Copy for eAVEncMPVQScaleType {}
impl ::core::clone::Clone for eAVEncMPVQScaleType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncMPVQScaleType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncMPVQScaleType {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncMPVQScaleType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncMPVQScaleType").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncMPVScanPattern(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVScanPattern_Auto: eAVEncMPVScanPattern = eAVEncMPVScanPattern(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVScanPattern_ZigZagScan: eAVEncMPVScanPattern = eAVEncMPVScanPattern(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVScanPattern_AlternateScan: eAVEncMPVScanPattern = eAVEncMPVScanPattern(2i32);
impl ::core::marker::Copy for eAVEncMPVScanPattern {}
impl ::core::clone::Clone for eAVEncMPVScanPattern {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncMPVScanPattern {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncMPVScanPattern {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncMPVScanPattern {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncMPVScanPattern").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncMPVSceneDetection(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVSceneDetection_None: eAVEncMPVSceneDetection = eAVEncMPVSceneDetection(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVSceneDetection_InsertIPicture: eAVEncMPVSceneDetection = eAVEncMPVSceneDetection(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVSceneDetection_StartNewGOP: eAVEncMPVSceneDetection = eAVEncMPVSceneDetection(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMPVSceneDetection_StartNewLocatableGOP: eAVEncMPVSceneDetection = eAVEncMPVSceneDetection(3i32);
impl ::core::marker::Copy for eAVEncMPVSceneDetection {}
impl ::core::clone::Clone for eAVEncMPVSceneDetection {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncMPVSceneDetection {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncMPVSceneDetection {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncMPVSceneDetection {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncMPVSceneDetection").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncMuxOutput(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMuxOutputAuto: eAVEncMuxOutput = eAVEncMuxOutput(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMuxOutputPS: eAVEncMuxOutput = eAVEncMuxOutput(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncMuxOutputTS: eAVEncMuxOutput = eAVEncMuxOutput(2i32);
impl ::core::marker::Copy for eAVEncMuxOutput {}
impl ::core::clone::Clone for eAVEncMuxOutput {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncMuxOutput {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncMuxOutput {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncMuxOutput {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncMuxOutput").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncVP9VProfile(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVP9VProfile_unknown: eAVEncVP9VProfile = eAVEncVP9VProfile(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVP9VProfile_420_8: eAVEncVP9VProfile = eAVEncVP9VProfile(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVP9VProfile_420_10: eAVEncVP9VProfile = eAVEncVP9VProfile(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVP9VProfile_420_12: eAVEncVP9VProfile = eAVEncVP9VProfile(3i32);
impl ::core::marker::Copy for eAVEncVP9VProfile {}
impl ::core::clone::Clone for eAVEncVP9VProfile {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncVP9VProfile {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncVP9VProfile {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncVP9VProfile {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncVP9VProfile").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncVideoChromaResolution(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoChromaResolution_SameAsSource: eAVEncVideoChromaResolution = eAVEncVideoChromaResolution(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoChromaResolution_444: eAVEncVideoChromaResolution = eAVEncVideoChromaResolution(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoChromaResolution_422: eAVEncVideoChromaResolution = eAVEncVideoChromaResolution(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoChromaResolution_420: eAVEncVideoChromaResolution = eAVEncVideoChromaResolution(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoChromaResolution_411: eAVEncVideoChromaResolution = eAVEncVideoChromaResolution(4i32);
impl ::core::marker::Copy for eAVEncVideoChromaResolution {}
impl ::core::clone::Clone for eAVEncVideoChromaResolution {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncVideoChromaResolution {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncVideoChromaResolution {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncVideoChromaResolution {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncVideoChromaResolution").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncVideoChromaSubsampling(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoChromaSubsamplingFormat_SameAsSource: eAVEncVideoChromaSubsampling = eAVEncVideoChromaSubsampling(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoChromaSubsamplingFormat_ProgressiveChroma: eAVEncVideoChromaSubsampling = eAVEncVideoChromaSubsampling(8i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoChromaSubsamplingFormat_Horizontally_Cosited: eAVEncVideoChromaSubsampling = eAVEncVideoChromaSubsampling(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoChromaSubsamplingFormat_Vertically_Cosited: eAVEncVideoChromaSubsampling = eAVEncVideoChromaSubsampling(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoChromaSubsamplingFormat_Vertically_AlignedChromaPlanes: eAVEncVideoChromaSubsampling = eAVEncVideoChromaSubsampling(1i32);
impl ::core::marker::Copy for eAVEncVideoChromaSubsampling {}
impl ::core::clone::Clone for eAVEncVideoChromaSubsampling {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncVideoChromaSubsampling {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncVideoChromaSubsampling {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncVideoChromaSubsampling {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncVideoChromaSubsampling").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncVideoColorLighting(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorLighting_SameAsSource: eAVEncVideoColorLighting = eAVEncVideoColorLighting(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorLighting_Unknown: eAVEncVideoColorLighting = eAVEncVideoColorLighting(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorLighting_Bright: eAVEncVideoColorLighting = eAVEncVideoColorLighting(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorLighting_Office: eAVEncVideoColorLighting = eAVEncVideoColorLighting(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorLighting_Dim: eAVEncVideoColorLighting = eAVEncVideoColorLighting(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorLighting_Dark: eAVEncVideoColorLighting = eAVEncVideoColorLighting(5i32);
impl ::core::marker::Copy for eAVEncVideoColorLighting {}
impl ::core::clone::Clone for eAVEncVideoColorLighting {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncVideoColorLighting {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncVideoColorLighting {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncVideoColorLighting {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncVideoColorLighting").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncVideoColorNominalRange(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorNominalRange_SameAsSource: eAVEncVideoColorNominalRange = eAVEncVideoColorNominalRange(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorNominalRange_0_255: eAVEncVideoColorNominalRange = eAVEncVideoColorNominalRange(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorNominalRange_16_235: eAVEncVideoColorNominalRange = eAVEncVideoColorNominalRange(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorNominalRange_48_208: eAVEncVideoColorNominalRange = eAVEncVideoColorNominalRange(3i32);
impl ::core::marker::Copy for eAVEncVideoColorNominalRange {}
impl ::core::clone::Clone for eAVEncVideoColorNominalRange {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncVideoColorNominalRange {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncVideoColorNominalRange {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncVideoColorNominalRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncVideoColorNominalRange").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncVideoColorPrimaries(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorPrimaries_SameAsSource: eAVEncVideoColorPrimaries = eAVEncVideoColorPrimaries(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorPrimaries_Reserved: eAVEncVideoColorPrimaries = eAVEncVideoColorPrimaries(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorPrimaries_BT709: eAVEncVideoColorPrimaries = eAVEncVideoColorPrimaries(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorPrimaries_BT470_2_SysM: eAVEncVideoColorPrimaries = eAVEncVideoColorPrimaries(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorPrimaries_BT470_2_SysBG: eAVEncVideoColorPrimaries = eAVEncVideoColorPrimaries(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorPrimaries_SMPTE170M: eAVEncVideoColorPrimaries = eAVEncVideoColorPrimaries(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorPrimaries_SMPTE240M: eAVEncVideoColorPrimaries = eAVEncVideoColorPrimaries(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorPrimaries_EBU3231: eAVEncVideoColorPrimaries = eAVEncVideoColorPrimaries(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorPrimaries_SMPTE_C: eAVEncVideoColorPrimaries = eAVEncVideoColorPrimaries(8i32);
impl ::core::marker::Copy for eAVEncVideoColorPrimaries {}
impl ::core::clone::Clone for eAVEncVideoColorPrimaries {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncVideoColorPrimaries {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncVideoColorPrimaries {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncVideoColorPrimaries {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncVideoColorPrimaries").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncVideoColorTransferFunction(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorTransferFunction_SameAsSource: eAVEncVideoColorTransferFunction = eAVEncVideoColorTransferFunction(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorTransferFunction_10: eAVEncVideoColorTransferFunction = eAVEncVideoColorTransferFunction(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorTransferFunction_18: eAVEncVideoColorTransferFunction = eAVEncVideoColorTransferFunction(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorTransferFunction_20: eAVEncVideoColorTransferFunction = eAVEncVideoColorTransferFunction(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorTransferFunction_22: eAVEncVideoColorTransferFunction = eAVEncVideoColorTransferFunction(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorTransferFunction_22_709: eAVEncVideoColorTransferFunction = eAVEncVideoColorTransferFunction(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorTransferFunction_22_240M: eAVEncVideoColorTransferFunction = eAVEncVideoColorTransferFunction(6i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorTransferFunction_22_8bit_sRGB: eAVEncVideoColorTransferFunction = eAVEncVideoColorTransferFunction(7i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorTransferFunction_28: eAVEncVideoColorTransferFunction = eAVEncVideoColorTransferFunction(8i32);
impl ::core::marker::Copy for eAVEncVideoColorTransferFunction {}
impl ::core::clone::Clone for eAVEncVideoColorTransferFunction {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncVideoColorTransferFunction {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncVideoColorTransferFunction {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncVideoColorTransferFunction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncVideoColorTransferFunction").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncVideoColorTransferMatrix(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorTransferMatrix_SameAsSource: eAVEncVideoColorTransferMatrix = eAVEncVideoColorTransferMatrix(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorTransferMatrix_BT709: eAVEncVideoColorTransferMatrix = eAVEncVideoColorTransferMatrix(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorTransferMatrix_BT601: eAVEncVideoColorTransferMatrix = eAVEncVideoColorTransferMatrix(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoColorTransferMatrix_SMPTE240M: eAVEncVideoColorTransferMatrix = eAVEncVideoColorTransferMatrix(3i32);
impl ::core::marker::Copy for eAVEncVideoColorTransferMatrix {}
impl ::core::clone::Clone for eAVEncVideoColorTransferMatrix {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncVideoColorTransferMatrix {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncVideoColorTransferMatrix {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncVideoColorTransferMatrix {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncVideoColorTransferMatrix").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncVideoContentType(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoContentType_Unknown: eAVEncVideoContentType = eAVEncVideoContentType(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoContentType_FixedCameraAngle: eAVEncVideoContentType = eAVEncVideoContentType(1i32);
impl ::core::marker::Copy for eAVEncVideoContentType {}
impl ::core::clone::Clone for eAVEncVideoContentType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncVideoContentType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncVideoContentType {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncVideoContentType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncVideoContentType").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncVideoFilmContent(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoFilmContent_VideoOnly: eAVEncVideoFilmContent = eAVEncVideoFilmContent(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoFilmContent_FilmOnly: eAVEncVideoFilmContent = eAVEncVideoFilmContent(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoFilmContent_Mixed: eAVEncVideoFilmContent = eAVEncVideoFilmContent(2i32);
impl ::core::marker::Copy for eAVEncVideoFilmContent {}
impl ::core::clone::Clone for eAVEncVideoFilmContent {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncVideoFilmContent {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncVideoFilmContent {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncVideoFilmContent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncVideoFilmContent").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncVideoOutputFrameRateConversion(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoOutputFrameRateConversion_Disable: eAVEncVideoOutputFrameRateConversion = eAVEncVideoOutputFrameRateConversion(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoOutputFrameRateConversion_Enable: eAVEncVideoOutputFrameRateConversion = eAVEncVideoOutputFrameRateConversion(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoOutputFrameRateConversion_Alias: eAVEncVideoOutputFrameRateConversion = eAVEncVideoOutputFrameRateConversion(2i32);
impl ::core::marker::Copy for eAVEncVideoOutputFrameRateConversion {}
impl ::core::clone::Clone for eAVEncVideoOutputFrameRateConversion {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncVideoOutputFrameRateConversion {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncVideoOutputFrameRateConversion {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncVideoOutputFrameRateConversion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncVideoOutputFrameRateConversion").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncVideoOutputScanType(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoOutputScan_Progressive: eAVEncVideoOutputScanType = eAVEncVideoOutputScanType(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoOutputScan_Interlaced: eAVEncVideoOutputScanType = eAVEncVideoOutputScanType(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoOutputScan_SameAsInput: eAVEncVideoOutputScanType = eAVEncVideoOutputScanType(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoOutputScan_Automatic: eAVEncVideoOutputScanType = eAVEncVideoOutputScanType(3i32);
impl ::core::marker::Copy for eAVEncVideoOutputScanType {}
impl ::core::clone::Clone for eAVEncVideoOutputScanType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncVideoOutputScanType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncVideoOutputScanType {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncVideoOutputScanType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncVideoOutputScanType").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVEncVideoSourceScanType(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoSourceScan_Automatic: eAVEncVideoSourceScanType = eAVEncVideoSourceScanType(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoSourceScan_Interlaced: eAVEncVideoSourceScanType = eAVEncVideoSourceScanType(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVEncVideoSourceScan_Progressive: eAVEncVideoSourceScanType = eAVEncVideoSourceScanType(2i32);
impl ::core::marker::Copy for eAVEncVideoSourceScanType {}
impl ::core::clone::Clone for eAVEncVideoSourceScanType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVEncVideoSourceScanType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVEncVideoSourceScanType {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVEncVideoSourceScanType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVEncVideoSourceScanType").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVFastDecodeMode(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eVideoDecodeCompliant: eAVFastDecodeMode = eAVFastDecodeMode(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eVideoDecodeOptimalLF: eAVFastDecodeMode = eAVFastDecodeMode(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eVideoDecodeDisableLF: eAVFastDecodeMode = eAVFastDecodeMode(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eVideoDecodeFastest: eAVFastDecodeMode = eAVFastDecodeMode(32i32);
impl ::core::marker::Copy for eAVFastDecodeMode {}
impl ::core::clone::Clone for eAVFastDecodeMode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVFastDecodeMode {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVFastDecodeMode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVFastDecodeMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVFastDecodeMode").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eAVScenarioInfo(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVScenarioInfo_Unknown: eAVScenarioInfo = eAVScenarioInfo(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVScenarioInfo_DisplayRemoting: eAVScenarioInfo = eAVScenarioInfo(1i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVScenarioInfo_VideoConference: eAVScenarioInfo = eAVScenarioInfo(2i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVScenarioInfo_Archive: eAVScenarioInfo = eAVScenarioInfo(3i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVScenarioInfo_LiveStreaming: eAVScenarioInfo = eAVScenarioInfo(4i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVScenarioInfo_CameraRecord: eAVScenarioInfo = eAVScenarioInfo(5i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eAVScenarioInfo_DisplayRemotingWithFeatureMap: eAVScenarioInfo = eAVScenarioInfo(6i32);
impl ::core::marker::Copy for eAVScenarioInfo {}
impl ::core::clone::Clone for eAVScenarioInfo {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eAVScenarioInfo {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eAVScenarioInfo {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eAVScenarioInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eAVScenarioInfo").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct eVideoEncoderDisplayContentType(pub i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eVideoEncoderDisplayContent_Unknown: eVideoEncoderDisplayContentType = eVideoEncoderDisplayContentType(0i32);
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub const eVideoEncoderDisplayContent_FullScreenVideo: eVideoEncoderDisplayContentType = eVideoEncoderDisplayContentType(1i32);
impl ::core::marker::Copy for eVideoEncoderDisplayContentType {}
impl ::core::clone::Clone for eVideoEncoderDisplayContentType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for eVideoEncoderDisplayContentType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for eVideoEncoderDisplayContentType {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for eVideoEncoderDisplayContentType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("eVideoEncoderDisplayContentType").field(&self.0).finish()
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct AM_MEDIA_TYPE {
    pub majortype: ::windows::core::GUID,
    pub subtype: ::windows::core::GUID,
    pub bFixedSizeSamples: super::super::Foundation::BOOL,
    pub bTemporalCompression: super::super::Foundation::BOOL,
    pub lSampleSize: u32,
    pub formattype: ::windows::core::GUID,
    pub pUnk: ::std::mem::ManuallyDrop<::core::option::Option<::windows::core::IUnknown>>,
    pub cbFormat: u32,
    pub pbFormat: *mut u8,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for AM_MEDIA_TYPE {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for AM_MEDIA_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AM_MEDIA_TYPE").field("majortype", &self.majortype).field("subtype", &self.subtype).field("bFixedSizeSamples", &self.bFixedSizeSamples).field("bTemporalCompression", &self.bTemporalCompression).field("lSampleSize", &self.lSampleSize).field("formattype", &self.formattype).field("pUnk", &self.pUnk).field("cbFormat", &self.cbFormat).field("pbFormat", &self.pbFormat).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for AM_MEDIA_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for AM_MEDIA_TYPE {
    fn eq(&self, other: &Self) -> bool {
        self.majortype == other.majortype && self.subtype == other.subtype && self.bFixedSizeSamples == other.bFixedSizeSamples && self.bTemporalCompression == other.bTemporalCompression && self.lSampleSize == other.lSampleSize && self.formattype == other.formattype && self.pUnk == other.pUnk && self.cbFormat == other.cbFormat && self.pbFormat == other.pbFormat
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for AM_MEDIA_TYPE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for AM_MEDIA_TYPE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct ASF_FLAT_PICTURE {
    pub bPictureType: u8,
    pub dwDataLen: u32,
}
impl ::core::marker::Copy for ASF_FLAT_PICTURE {}
impl ::core::clone::Clone for ASF_FLAT_PICTURE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for ASF_FLAT_PICTURE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for ASF_FLAT_PICTURE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct ASF_FLAT_SYNCHRONISED_LYRICS {
    pub bTimeStampFormat: u8,
    pub bContentType: u8,
    pub dwLyricsLen: u32,
}
impl ::core::marker::Copy for ASF_FLAT_SYNCHRONISED_LYRICS {}
impl ::core::clone::Clone for ASF_FLAT_SYNCHRONISED_LYRICS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for ASF_FLAT_SYNCHRONISED_LYRICS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for ASF_FLAT_SYNCHRONISED_LYRICS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct ASF_INDEX_DESCRIPTOR {
    pub Identifier: ASF_INDEX_IDENTIFIER,
    pub cPerEntryBytes: u16,
    pub szDescription: [u16; 32],
    pub dwInterval: u32,
}
impl ::core::marker::Copy for ASF_INDEX_DESCRIPTOR {}
impl ::core::clone::Clone for ASF_INDEX_DESCRIPTOR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for ASF_INDEX_DESCRIPTOR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ASF_INDEX_DESCRIPTOR").field("Identifier", &self.Identifier).field("cPerEntryBytes", &self.cPerEntryBytes).field("szDescription", &self.szDescription).field("dwInterval", &self.dwInterval).finish()
    }
}
impl ::windows::core::TypeKind for ASF_INDEX_DESCRIPTOR {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for ASF_INDEX_DESCRIPTOR {
    fn eq(&self, other: &Self) -> bool {
        self.Identifier == other.Identifier && self.cPerEntryBytes == other.cPerEntryBytes && self.szDescription == other.szDescription && self.dwInterval == other.dwInterval
    }
}
impl ::core::cmp::Eq for ASF_INDEX_DESCRIPTOR {}
impl ::core::default::Default for ASF_INDEX_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct ASF_INDEX_IDENTIFIER {
    pub guidIndexType: ::windows::core::GUID,
    pub wStreamNumber: u16,
}
impl ::core::marker::Copy for ASF_INDEX_IDENTIFIER {}
impl ::core::clone::Clone for ASF_INDEX_IDENTIFIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for ASF_INDEX_IDENTIFIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ASF_INDEX_IDENTIFIER").field("guidIndexType", &self.guidIndexType).field("wStreamNumber", &self.wStreamNumber).finish()
    }
}
impl ::windows::core::TypeKind for ASF_INDEX_IDENTIFIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for ASF_INDEX_IDENTIFIER {
    fn eq(&self, other: &Self) -> bool {
        self.guidIndexType == other.guidIndexType && self.wStreamNumber == other.wStreamNumber
    }
}
impl ::core::cmp::Eq for ASF_INDEX_IDENTIFIER {}
impl ::core::default::Default for ASF_INDEX_IDENTIFIER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct ASF_MUX_STATISTICS {
    pub cFramesWritten: u32,
    pub cFramesDropped: u32,
}
impl ::core::marker::Copy for ASF_MUX_STATISTICS {}
impl ::core::clone::Clone for ASF_MUX_STATISTICS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for ASF_MUX_STATISTICS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ASF_MUX_STATISTICS").field("cFramesWritten", &self.cFramesWritten).field("cFramesDropped", &self.cFramesDropped).finish()
    }
}
impl ::windows::core::TypeKind for ASF_MUX_STATISTICS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for ASF_MUX_STATISTICS {
    fn eq(&self, other: &Self) -> bool {
        self.cFramesWritten == other.cFramesWritten && self.cFramesDropped == other.cFramesDropped
    }
}
impl ::core::cmp::Eq for ASF_MUX_STATISTICS {}
impl ::core::default::Default for ASF_MUX_STATISTICS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct AecQualityMetrics_Struct {
    pub i64Timestamp: i64,
    pub ConvergenceFlag: u8,
    pub MicClippedFlag: u8,
    pub MicSilenceFlag: u8,
    pub PstvFeadbackFlag: u8,
    pub SpkClippedFlag: u8,
    pub SpkMuteFlag: u8,
    pub GlitchFlag: u8,
    pub DoubleTalkFlag: u8,
    pub uGlitchCount: u32,
    pub uMicClipCount: u32,
    pub fDuration: f32,
    pub fTSVariance: f32,
    pub fTSDriftRate: f32,
    pub fVoiceLevel: f32,
    pub fNoiseLevel: f32,
    pub fERLE: f32,
    pub fAvgERLE: f32,
    pub dwReserved: u32,
}
impl ::core::marker::Copy for AecQualityMetrics_Struct {}
impl ::core::clone::Clone for AecQualityMetrics_Struct {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for AecQualityMetrics_Struct {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("AecQualityMetrics_Struct")
            .field("i64Timestamp", &self.i64Timestamp)
            .field("ConvergenceFlag", &self.ConvergenceFlag)
            .field("MicClippedFlag", &self.MicClippedFlag)
            .field("MicSilenceFlag", &self.MicSilenceFlag)
            .field("PstvFeadbackFlag", &self.PstvFeadbackFlag)
            .field("SpkClippedFlag", &self.SpkClippedFlag)
            .field("SpkMuteFlag", &self.SpkMuteFlag)
            .field("GlitchFlag", &self.GlitchFlag)
            .field("DoubleTalkFlag", &self.DoubleTalkFlag)
            .field("uGlitchCount", &self.uGlitchCount)
            .field("uMicClipCount", &self.uMicClipCount)
            .field("fDuration", &self.fDuration)
            .field("fTSVariance", &self.fTSVariance)
            .field("fTSDriftRate", &self.fTSDriftRate)
            .field("fVoiceLevel", &self.fVoiceLevel)
            .field("fNoiseLevel", &self.fNoiseLevel)
            .field("fERLE", &self.fERLE)
            .field("fAvgERLE", &self.fAvgERLE)
            .field("dwReserved", &self.dwReserved)
            .finish()
    }
}
impl ::windows::core::TypeKind for AecQualityMetrics_Struct {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for AecQualityMetrics_Struct {
    fn eq(&self, other: &Self) -> bool {
        self.i64Timestamp == other.i64Timestamp
            && self.ConvergenceFlag == other.ConvergenceFlag
            && self.MicClippedFlag == other.MicClippedFlag
            && self.MicSilenceFlag == other.MicSilenceFlag
            && self.PstvFeadbackFlag == other.PstvFeadbackFlag
            && self.SpkClippedFlag == other.SpkClippedFlag
            && self.SpkMuteFlag == other.SpkMuteFlag
            && self.GlitchFlag == other.GlitchFlag
            && self.DoubleTalkFlag == other.DoubleTalkFlag
            && self.uGlitchCount == other.uGlitchCount
            && self.uMicClipCount == other.uMicClipCount
            && self.fDuration == other.fDuration
            && self.fTSVariance == other.fTSVariance
            && self.fTSDriftRate == other.fTSDriftRate
            && self.fVoiceLevel == other.fVoiceLevel
            && self.fNoiseLevel == other.fNoiseLevel
            && self.fERLE == other.fERLE
            && self.fAvgERLE == other.fAvgERLE
            && self.dwReserved == other.dwReserved
    }
}
impl ::core::cmp::Eq for AecQualityMetrics_Struct {}
impl ::core::default::Default for AecQualityMetrics_Struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct CodecAPIEventData {
    pub guid: ::windows::core::GUID,
    pub dataLength: u32,
    pub reserved: [u32; 3],
}
impl ::core::marker::Copy for CodecAPIEventData {}
impl ::core::clone::Clone for CodecAPIEventData {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CodecAPIEventData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CodecAPIEventData").field("guid", &self.guid).field("dataLength", &self.dataLength).field("reserved", &self.reserved).finish()
    }
}
impl ::windows::core::TypeKind for CodecAPIEventData {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for CodecAPIEventData {
    fn eq(&self, other: &Self) -> bool {
        self.guid == other.guid && self.dataLength == other.dataLength && self.reserved == other.reserved
    }
}
impl ::core::cmp::Eq for CodecAPIEventData {}
impl ::core::default::Default for CodecAPIEventData {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct D3D12_FEATURE_DATA_VIDEO_ARCHITECTURE {
    pub IOCoherent: super::super::Foundation::BOOL,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ARCHITECTURE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ARCHITECTURE {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_ARCHITECTURE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_ARCHITECTURE").field("IOCoherent", &self.IOCoherent).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ARCHITECTURE {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_ARCHITECTURE {
    fn eq(&self, other: &Self) -> bool {
        self.IOCoherent == other.IOCoherent
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_ARCHITECTURE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ARCHITECTURE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
pub struct D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE {
    pub VideoDecoderHeapDesc: D3D12_VIDEO_DECODER_HEAP_DESC,
    pub MemoryPoolL0Size: u64,
    pub MemoryPoolL1Size: u64,
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE").field("VideoDecoderHeapDesc", &self.VideoDecoderHeapDesc).field("MemoryPoolL0Size", &self.MemoryPoolL0Size).field("MemoryPoolL1Size", &self.MemoryPoolL1Size).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE {
    fn eq(&self, other: &Self) -> bool {
        self.VideoDecoderHeapDesc == other.VideoDecoderHeapDesc && self.MemoryPoolL0Size == other.MemoryPoolL0Size && self.MemoryPoolL1Size == other.MemoryPoolL1Size
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
pub struct D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE1 {
    pub VideoDecoderHeapDesc: D3D12_VIDEO_DECODER_HEAP_DESC,
    pub Protected: super::super::Foundation::BOOL,
    pub MemoryPoolL0Size: u64,
    pub MemoryPoolL1Size: u64,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE1 {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE1").field("VideoDecoderHeapDesc", &self.VideoDecoderHeapDesc).field("Protected", &self.Protected).field("MemoryPoolL0Size", &self.MemoryPoolL0Size).field("MemoryPoolL1Size", &self.MemoryPoolL1Size).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE1 {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE1 {
    fn eq(&self, other: &Self) -> bool {
        self.VideoDecoderHeapDesc == other.VideoDecoderHeapDesc && self.Protected == other.Protected && self.MemoryPoolL0Size == other.MemoryPoolL0Size && self.MemoryPoolL1Size == other.MemoryPoolL1Size
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE1 {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
pub struct D3D12_FEATURE_DATA_VIDEO_DECODE_CONVERSION_SUPPORT {
    pub NodeIndex: u32,
    pub Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    pub DecodeSample: D3D12_VIDEO_SAMPLE,
    pub OutputFormat: D3D12_VIDEO_FORMAT,
    pub FrameRate: super::super::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub BitRate: u32,
    pub SupportFlags: D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS,
    pub ScaleSupport: D3D12_VIDEO_SCALE_SUPPORT,
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_DECODE_CONVERSION_SUPPORT {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_DECODE_CONVERSION_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_DECODE_CONVERSION_SUPPORT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_DECODE_CONVERSION_SUPPORT").field("NodeIndex", &self.NodeIndex).field("Configuration", &self.Configuration).field("DecodeSample", &self.DecodeSample).field("OutputFormat", &self.OutputFormat).field("FrameRate", &self.FrameRate).field("BitRate", &self.BitRate).field("SupportFlags", &self.SupportFlags).field("ScaleSupport", &self.ScaleSupport).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_DECODE_CONVERSION_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_DECODE_CONVERSION_SUPPORT {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.Configuration == other.Configuration && self.DecodeSample == other.DecodeSample && self.OutputFormat == other.OutputFormat && self.FrameRate == other.FrameRate && self.BitRate == other.BitRate && self.SupportFlags == other.SupportFlags && self.ScaleSupport == other.ScaleSupport
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_DECODE_CONVERSION_SUPPORT {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_DECODE_CONVERSION_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
pub struct D3D12_FEATURE_DATA_VIDEO_DECODE_FORMATS {
    pub NodeIndex: u32,
    pub Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    pub FormatCount: u32,
    pub pOutputFormats: *mut super::super::Graphics::Dxgi::Common::DXGI_FORMAT,
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMATS {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMATS {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMATS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_DECODE_FORMATS").field("NodeIndex", &self.NodeIndex).field("Configuration", &self.Configuration).field("FormatCount", &self.FormatCount).field("pOutputFormats", &self.pOutputFormats).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMATS {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMATS {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.Configuration == other.Configuration && self.FormatCount == other.FormatCount && self.pOutputFormats == other.pOutputFormats
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMATS {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMATS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_FEATURE_DATA_VIDEO_DECODE_FORMAT_COUNT {
    pub NodeIndex: u32,
    pub Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    pub FormatCount: u32,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMAT_COUNT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMAT_COUNT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMAT_COUNT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_DECODE_FORMAT_COUNT").field("NodeIndex", &self.NodeIndex).field("Configuration", &self.Configuration).field("FormatCount", &self.FormatCount).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMAT_COUNT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMAT_COUNT {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.Configuration == other.Configuration && self.FormatCount == other.FormatCount
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMAT_COUNT {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMAT_COUNT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
pub struct D3D12_FEATURE_DATA_VIDEO_DECODE_HISTOGRAM {
    pub NodeIndex: u32,
    pub DecodeProfile: ::windows::core::GUID,
    pub Width: u32,
    pub Height: u32,
    pub DecodeFormat: super::super::Graphics::Dxgi::Common::DXGI_FORMAT,
    pub Components: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS,
    pub BinCount: u32,
    pub CounterBitDepth: u32,
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_DECODE_HISTOGRAM {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_DECODE_HISTOGRAM {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_DECODE_HISTOGRAM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_DECODE_HISTOGRAM").field("NodeIndex", &self.NodeIndex).field("DecodeProfile", &self.DecodeProfile).field("Width", &self.Width).field("Height", &self.Height).field("DecodeFormat", &self.DecodeFormat).field("Components", &self.Components).field("BinCount", &self.BinCount).field("CounterBitDepth", &self.CounterBitDepth).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_DECODE_HISTOGRAM {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_DECODE_HISTOGRAM {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.DecodeProfile == other.DecodeProfile && self.Width == other.Width && self.Height == other.Height && self.DecodeFormat == other.DecodeFormat && self.Components == other.Components && self.BinCount == other.BinCount && self.CounterBitDepth == other.CounterBitDepth
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_DECODE_HISTOGRAM {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_DECODE_HISTOGRAM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILES {
    pub NodeIndex: u32,
    pub ProfileCount: u32,
    pub pProfiles: *mut ::windows::core::GUID,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILES {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILES").field("NodeIndex", &self.NodeIndex).field("ProfileCount", &self.ProfileCount).field("pProfiles", &self.pProfiles).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILES {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.ProfileCount == other.ProfileCount && self.pProfiles == other.pProfiles
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILES {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILE_COUNT {
    pub NodeIndex: u32,
    pub ProfileCount: u32,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILE_COUNT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILE_COUNT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILE_COUNT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILE_COUNT").field("NodeIndex", &self.NodeIndex).field("ProfileCount", &self.ProfileCount).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILE_COUNT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILE_COUNT {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.ProfileCount == other.ProfileCount
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILE_COUNT {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILE_COUNT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_FEATURE_DATA_VIDEO_DECODE_PROTECTED_RESOURCES {
    pub NodeIndex: u32,
    pub Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    pub SupportFlags: D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_DECODE_PROTECTED_RESOURCES {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_DECODE_PROTECTED_RESOURCES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_DECODE_PROTECTED_RESOURCES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_DECODE_PROTECTED_RESOURCES").field("NodeIndex", &self.NodeIndex).field("Configuration", &self.Configuration).field("SupportFlags", &self.SupportFlags).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_DECODE_PROTECTED_RESOURCES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_DECODE_PROTECTED_RESOURCES {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.Configuration == other.Configuration && self.SupportFlags == other.SupportFlags
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_DECODE_PROTECTED_RESOURCES {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_DECODE_PROTECTED_RESOURCES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
pub struct D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT {
    pub NodeIndex: u32,
    pub Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    pub Width: u32,
    pub Height: u32,
    pub DecodeFormat: super::super::Graphics::Dxgi::Common::DXGI_FORMAT,
    pub FrameRate: super::super::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub BitRate: u32,
    pub SupportFlags: D3D12_VIDEO_DECODE_SUPPORT_FLAGS,
    pub ConfigurationFlags: D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS,
    pub DecodeTier: D3D12_VIDEO_DECODE_TIER,
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT").field("NodeIndex", &self.NodeIndex).field("Configuration", &self.Configuration).field("Width", &self.Width).field("Height", &self.Height).field("DecodeFormat", &self.DecodeFormat).field("FrameRate", &self.FrameRate).field("BitRate", &self.BitRate).field("SupportFlags", &self.SupportFlags).field("ConfigurationFlags", &self.ConfigurationFlags).field("DecodeTier", &self.DecodeTier).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.Configuration == other.Configuration && self.Width == other.Width && self.Height == other.Height && self.DecodeFormat == other.DecodeFormat && self.FrameRate == other.FrameRate && self.BitRate == other.BitRate && self.SupportFlags == other.SupportFlags && self.ConfigurationFlags == other.ConfigurationFlags && self.DecodeTier == other.DecodeTier
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub IsSupported: super::super::Foundation::BOOL,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC").field("NodeIndex", &self.NodeIndex).field("Codec", &self.Codec).field("IsSupported", &self.IsSupported).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.Codec == other.Codec && self.IsSupported == other.IsSupported
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub Profile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub IsSupported: super::super::Foundation::BOOL,
    pub CodecSupportLimits: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub Profile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub IsSupported: super::super::Foundation::BOOL,
    pub PictureSupport: D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub Profile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub Level: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
    pub SubregionMode: D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE,
    pub IsSupported: super::super::Foundation::BOOL,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_HEAP_SIZE {
    pub HeapDesc: D3D12_VIDEO_ENCODER_HEAP_DESC,
    pub IsSupported: super::super::Foundation::BOOL,
    pub MemoryPoolL0Size: u64,
    pub MemoryPoolL1Size: u64,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_HEAP_SIZE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_HEAP_SIZE {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_HEAP_SIZE {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_HEAP_SIZE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_INPUT_FORMAT {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub Profile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub Format: super::super::Graphics::Dxgi::Common::DXGI_FORMAT,
    pub IsSupported: super::super::Foundation::BOOL,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_INPUT_FORMAT {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_INPUT_FORMAT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_INPUT_FORMAT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_INPUT_FORMAT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_INTRA_REFRESH_MODE {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub Profile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub Level: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
    pub IntraRefreshMode: D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE,
    pub IsSupported: super::super::Foundation::BOOL,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_INTRA_REFRESH_MODE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_INTRA_REFRESH_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_INTRA_REFRESH_MODE {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_INTRA_REFRESH_MODE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub ResolutionRatiosCount: u32,
    pub IsSupported: super::super::Foundation::BOOL,
    pub MinResolutionSupported: D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
    pub MaxResolutionSupported: D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
    pub ResolutionWidthMultipleRequirement: u32,
    pub ResolutionHeightMultipleRequirement: u32,
    pub pResolutionRatios: *mut D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_RATIO_DESC,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION")
            .field("NodeIndex", &self.NodeIndex)
            .field("Codec", &self.Codec)
            .field("ResolutionRatiosCount", &self.ResolutionRatiosCount)
            .field("IsSupported", &self.IsSupported)
            .field("MinResolutionSupported", &self.MinResolutionSupported)
            .field("MaxResolutionSupported", &self.MaxResolutionSupported)
            .field("ResolutionWidthMultipleRequirement", &self.ResolutionWidthMultipleRequirement)
            .field("ResolutionHeightMultipleRequirement", &self.ResolutionHeightMultipleRequirement)
            .field("pResolutionRatios", &self.pResolutionRatios)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.Codec == other.Codec && self.ResolutionRatiosCount == other.ResolutionRatiosCount && self.IsSupported == other.IsSupported && self.MinResolutionSupported == other.MinResolutionSupported && self.MaxResolutionSupported == other.MaxResolutionSupported && self.ResolutionWidthMultipleRequirement == other.ResolutionWidthMultipleRequirement && self.ResolutionHeightMultipleRequirement == other.ResolutionHeightMultipleRequirement && self.pResolutionRatios == other.pResolutionRatios
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION_RATIOS_COUNT {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub ResolutionRatiosCount: u32,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION_RATIOS_COUNT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION_RATIOS_COUNT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION_RATIOS_COUNT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION_RATIOS_COUNT").field("NodeIndex", &self.NodeIndex).field("Codec", &self.Codec).field("ResolutionRatiosCount", &self.ResolutionRatiosCount).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION_RATIOS_COUNT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION_RATIOS_COUNT {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.Codec == other.Codec && self.ResolutionRatiosCount == other.ResolutionRatiosCount
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION_RATIOS_COUNT {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION_RATIOS_COUNT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_PROFILE_LEVEL {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub Profile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub IsSupported: super::super::Foundation::BOOL,
    pub MinSupportedLevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
    pub MaxSupportedLevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_PROFILE_LEVEL {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_PROFILE_LEVEL {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_PROFILE_LEVEL {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_PROFILE_LEVEL {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_RATE_CONTROL_MODE {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub RateControlMode: D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE,
    pub IsSupported: super::super::Foundation::BOOL,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_RATE_CONTROL_MODE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_RATE_CONTROL_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_ENCODER_RATE_CONTROL_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_ENCODER_RATE_CONTROL_MODE").field("NodeIndex", &self.NodeIndex).field("Codec", &self.Codec).field("RateControlMode", &self.RateControlMode).field("IsSupported", &self.IsSupported).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_RATE_CONTROL_MODE {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_ENCODER_RATE_CONTROL_MODE {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.Codec == other.Codec && self.RateControlMode == other.RateControlMode && self.IsSupported == other.IsSupported
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_ENCODER_RATE_CONTROL_MODE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_RATE_CONTROL_MODE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOLUTION_SUPPORT_LIMITS {
    pub MaxSubregionsNumber: u32,
    pub MaxIntraRefreshFrameDuration: u32,
    pub SubregionBlockPixelsSize: u32,
    pub QPMapRegionPixelsSize: u32,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOLUTION_SUPPORT_LIMITS {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOLUTION_SUPPORT_LIMITS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOLUTION_SUPPORT_LIMITS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOLUTION_SUPPORT_LIMITS").field("MaxSubregionsNumber", &self.MaxSubregionsNumber).field("MaxIntraRefreshFrameDuration", &self.MaxIntraRefreshFrameDuration).field("SubregionBlockPixelsSize", &self.SubregionBlockPixelsSize).field("QPMapRegionPixelsSize", &self.QPMapRegionPixelsSize).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOLUTION_SUPPORT_LIMITS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOLUTION_SUPPORT_LIMITS {
    fn eq(&self, other: &Self) -> bool {
        self.MaxSubregionsNumber == other.MaxSubregionsNumber && self.MaxIntraRefreshFrameDuration == other.MaxIntraRefreshFrameDuration && self.SubregionBlockPixelsSize == other.SubregionBlockPixelsSize && self.QPMapRegionPixelsSize == other.QPMapRegionPixelsSize
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOLUTION_SUPPORT_LIMITS {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOLUTION_SUPPORT_LIMITS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOURCE_REQUIREMENTS {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub Profile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub InputFormat: super::super::Graphics::Dxgi::Common::DXGI_FORMAT,
    pub PictureTargetResolution: D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
    pub IsSupported: super::super::Foundation::BOOL,
    pub CompressedBitstreamBufferAccessAlignment: u32,
    pub EncoderMetadataBufferAccessAlignment: u32,
    pub MaxEncoderOutputMetadataBufferSize: u32,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOURCE_REQUIREMENTS {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOURCE_REQUIREMENTS {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOURCE_REQUIREMENTS {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOURCE_REQUIREMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_SUPPORT {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub InputFormat: super::super::Graphics::Dxgi::Common::DXGI_FORMAT,
    pub CodecConfiguration: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION,
    pub CodecGopSequence: D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE,
    pub RateControl: D3D12_VIDEO_ENCODER_RATE_CONTROL,
    pub IntraRefresh: D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE,
    pub SubregionFrameEncoding: D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE,
    pub ResolutionsListCount: u32,
    pub pResolutionList: *const D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
    pub MaxReferenceFramesInDPB: u32,
    pub ValidationFlags: D3D12_VIDEO_ENCODER_VALIDATION_FLAGS,
    pub SupportFlags: D3D12_VIDEO_ENCODER_SUPPORT_FLAGS,
    pub SuggestedProfile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub SuggestedLevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
    pub pResolutionDependentSupport: *mut D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOLUTION_SUPPORT_LIMITS,
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_SUPPORT {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub struct D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMANDS {
    pub NodeIndex: u32,
    pub CommandCount: u32,
    pub pCommandInfos: *mut D3D12_VIDEO_EXTENSION_COMMAND_INFO,
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMANDS {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMANDS {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMANDS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMANDS").field("NodeIndex", &self.NodeIndex).field("CommandCount", &self.CommandCount).field("pCommandInfos", &self.pCommandInfos).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMANDS {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMANDS {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.CommandCount == other.CommandCount && self.pCommandInfos == other.pCommandInfos
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMANDS {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMANDS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_COUNT {
    pub NodeIndex: u32,
    pub CommandCount: u32,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_COUNT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_COUNT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_COUNT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_COUNT").field("NodeIndex", &self.NodeIndex).field("CommandCount", &self.CommandCount).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_COUNT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_COUNT {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.CommandCount == other.CommandCount
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_COUNT {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_COUNT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETERS {
    pub CommandId: ::windows::core::GUID,
    pub Stage: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE,
    pub ParameterCount: u32,
    pub pParameterInfos: *mut D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETERS {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETERS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETERS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETERS").field("CommandId", &self.CommandId).field("Stage", &self.Stage).field("ParameterCount", &self.ParameterCount).field("pParameterInfos", &self.pParameterInfos).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETERS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETERS {
    fn eq(&self, other: &Self) -> bool {
        self.CommandId == other.CommandId && self.Stage == other.Stage && self.ParameterCount == other.ParameterCount && self.pParameterInfos == other.pParameterInfos
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETERS {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETERS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT {
    pub CommandId: ::windows::core::GUID,
    pub Stage: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE,
    pub ParameterCount: u32,
    pub ParameterPacking: u32,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT").field("CommandId", &self.CommandId).field("Stage", &self.Stage).field("ParameterCount", &self.ParameterCount).field("ParameterPacking", &self.ParameterPacking).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT {
    fn eq(&self, other: &Self) -> bool {
        self.CommandId == other.CommandId && self.Stage == other.Stage && self.ParameterCount == other.ParameterCount && self.ParameterPacking == other.ParameterPacking
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SIZE {
    pub NodeIndex: u32,
    pub CommandId: ::windows::core::GUID,
    pub pCreationParameters: *const ::core::ffi::c_void,
    pub CreationParametersSizeInBytes: usize,
    pub MemoryPoolL0Size: u64,
    pub MemoryPoolL1Size: u64,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SIZE {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SIZE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SIZE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SIZE").field("NodeIndex", &self.NodeIndex).field("CommandId", &self.CommandId).field("pCreationParameters", &self.pCreationParameters).field("CreationParametersSizeInBytes", &self.CreationParametersSizeInBytes).field("MemoryPoolL0Size", &self.MemoryPoolL0Size).field("MemoryPoolL1Size", &self.MemoryPoolL1Size).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SIZE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SIZE {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.CommandId == other.CommandId && self.pCreationParameters == other.pCreationParameters && self.CreationParametersSizeInBytes == other.CreationParametersSizeInBytes && self.MemoryPoolL0Size == other.MemoryPoolL0Size && self.MemoryPoolL1Size == other.MemoryPoolL1Size
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SIZE {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SIZE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SUPPORT {
    pub NodeIndex: u32,
    pub CommandId: ::windows::core::GUID,
    pub pInputData: *const ::core::ffi::c_void,
    pub InputDataSizeInBytes: usize,
    pub pOutputData: *mut ::core::ffi::c_void,
    pub OutputDataSizeInBytes: usize,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SUPPORT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SUPPORT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SUPPORT").field("NodeIndex", &self.NodeIndex).field("CommandId", &self.CommandId).field("pInputData", &self.pInputData).field("InputDataSizeInBytes", &self.InputDataSizeInBytes).field("pOutputData", &self.pOutputData).field("OutputDataSizeInBytes", &self.OutputDataSizeInBytes).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SUPPORT {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.CommandId == other.CommandId && self.pInputData == other.pInputData && self.InputDataSizeInBytes == other.InputDataSizeInBytes && self.pOutputData == other.pOutputData && self.OutputDataSizeInBytes == other.OutputDataSizeInBytes
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SUPPORT {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct D3D12_FEATURE_DATA_VIDEO_FEATURE_AREA_SUPPORT {
    pub NodeIndex: u32,
    pub VideoDecodeSupport: super::super::Foundation::BOOL,
    pub VideoProcessSupport: super::super::Foundation::BOOL,
    pub VideoEncodeSupport: super::super::Foundation::BOOL,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_FEATURE_AREA_SUPPORT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_FEATURE_AREA_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_FEATURE_AREA_SUPPORT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_FEATURE_AREA_SUPPORT").field("NodeIndex", &self.NodeIndex).field("VideoDecodeSupport", &self.VideoDecodeSupport).field("VideoProcessSupport", &self.VideoProcessSupport).field("VideoEncodeSupport", &self.VideoEncodeSupport).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_FEATURE_AREA_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_FEATURE_AREA_SUPPORT {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.VideoDecodeSupport == other.VideoDecodeSupport && self.VideoProcessSupport == other.VideoProcessSupport && self.VideoEncodeSupport == other.VideoEncodeSupport
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_FEATURE_AREA_SUPPORT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_FEATURE_AREA_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
pub struct D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR {
    pub NodeIndex: u32,
    pub InputFormat: super::super::Graphics::Dxgi::Common::DXGI_FORMAT,
    pub BlockSizeFlags: D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS,
    pub PrecisionFlags: D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS,
    pub SizeRange: D3D12_VIDEO_SIZE_RANGE,
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR").field("NodeIndex", &self.NodeIndex).field("InputFormat", &self.InputFormat).field("BlockSizeFlags", &self.BlockSizeFlags).field("PrecisionFlags", &self.PrecisionFlags).field("SizeRange", &self.SizeRange).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.InputFormat == other.InputFormat && self.BlockSizeFlags == other.BlockSizeFlags && self.PrecisionFlags == other.PrecisionFlags && self.SizeRange == other.SizeRange
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES {
    pub NodeIndex: u32,
    pub SupportFlags: D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES").field("NodeIndex", &self.NodeIndex).field("SupportFlags", &self.SupportFlags).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.SupportFlags == other.SupportFlags
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
pub struct D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_SIZE {
    pub NodeIndex: u32,
    pub InputFormat: super::super::Graphics::Dxgi::Common::DXGI_FORMAT,
    pub BlockSize: D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE,
    pub Precision: D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION,
    pub SizeRange: D3D12_VIDEO_SIZE_RANGE,
    pub Protected: super::super::Foundation::BOOL,
    pub MotionVectorHeapMemoryPoolL0Size: u64,
    pub MotionVectorHeapMemoryPoolL1Size: u64,
    pub MotionEstimatorMemoryPoolL0Size: u64,
    pub MotionEstimatorMemoryPoolL1Size: u64,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_SIZE {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_SIZE {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_SIZE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_SIZE")
            .field("NodeIndex", &self.NodeIndex)
            .field("InputFormat", &self.InputFormat)
            .field("BlockSize", &self.BlockSize)
            .field("Precision", &self.Precision)
            .field("SizeRange", &self.SizeRange)
            .field("Protected", &self.Protected)
            .field("MotionVectorHeapMemoryPoolL0Size", &self.MotionVectorHeapMemoryPoolL0Size)
            .field("MotionVectorHeapMemoryPoolL1Size", &self.MotionVectorHeapMemoryPoolL1Size)
            .field("MotionEstimatorMemoryPoolL0Size", &self.MotionEstimatorMemoryPoolL0Size)
            .field("MotionEstimatorMemoryPoolL1Size", &self.MotionEstimatorMemoryPoolL1Size)
            .finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_SIZE {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_SIZE {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.InputFormat == other.InputFormat && self.BlockSize == other.BlockSize && self.Precision == other.Precision && self.SizeRange == other.SizeRange && self.Protected == other.Protected && self.MotionVectorHeapMemoryPoolL0Size == other.MotionVectorHeapMemoryPoolL0Size && self.MotionVectorHeapMemoryPoolL1Size == other.MotionVectorHeapMemoryPoolL1Size && self.MotionEstimatorMemoryPoolL0Size == other.MotionEstimatorMemoryPoolL0Size && self.MotionEstimatorMemoryPoolL1Size == other.MotionEstimatorMemoryPoolL1Size
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_SIZE {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_SIZE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
pub struct D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE {
    pub NodeMask: u32,
    pub pOutputStreamDesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
    pub NumInputStreamDescs: u32,
    pub pInputStreamDescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
    pub MemoryPoolL0Size: u64,
    pub MemoryPoolL1Size: u64,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE").field("NodeMask", &self.NodeMask).field("pOutputStreamDesc", &self.pOutputStreamDesc).field("NumInputStreamDescs", &self.NumInputStreamDescs).field("pInputStreamDescs", &self.pInputStreamDescs).field("MemoryPoolL0Size", &self.MemoryPoolL0Size).field("MemoryPoolL1Size", &self.MemoryPoolL1Size).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE {
    fn eq(&self, other: &Self) -> bool {
        self.NodeMask == other.NodeMask && self.pOutputStreamDesc == other.pOutputStreamDesc && self.NumInputStreamDescs == other.NumInputStreamDescs && self.pInputStreamDescs == other.pInputStreamDescs && self.MemoryPoolL0Size == other.MemoryPoolL0Size && self.MemoryPoolL1Size == other.MemoryPoolL1Size
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
pub struct D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE1 {
    pub NodeMask: u32,
    pub pOutputStreamDesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
    pub NumInputStreamDescs: u32,
    pub pInputStreamDescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
    pub Protected: super::super::Foundation::BOOL,
    pub MemoryPoolL0Size: u64,
    pub MemoryPoolL1Size: u64,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE1 {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE1").field("NodeMask", &self.NodeMask).field("pOutputStreamDesc", &self.pOutputStreamDesc).field("NumInputStreamDescs", &self.NumInputStreamDescs).field("pInputStreamDescs", &self.pInputStreamDescs).field("Protected", &self.Protected).field("MemoryPoolL0Size", &self.MemoryPoolL0Size).field("MemoryPoolL1Size", &self.MemoryPoolL1Size).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE1 {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE1 {
    fn eq(&self, other: &Self) -> bool {
        self.NodeMask == other.NodeMask && self.pOutputStreamDesc == other.pOutputStreamDesc && self.NumInputStreamDescs == other.NumInputStreamDescs && self.pInputStreamDescs == other.pInputStreamDescs && self.Protected == other.Protected && self.MemoryPoolL0Size == other.MemoryPoolL0Size && self.MemoryPoolL1Size == other.MemoryPoolL1Size
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE1 {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_FEATURE_DATA_VIDEO_PROCESS_MAX_INPUT_STREAMS {
    pub NodeIndex: u32,
    pub MaxInputStreams: u32,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_PROCESS_MAX_INPUT_STREAMS {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_PROCESS_MAX_INPUT_STREAMS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_PROCESS_MAX_INPUT_STREAMS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_PROCESS_MAX_INPUT_STREAMS").field("NodeIndex", &self.NodeIndex).field("MaxInputStreams", &self.MaxInputStreams).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_PROCESS_MAX_INPUT_STREAMS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_PROCESS_MAX_INPUT_STREAMS {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.MaxInputStreams == other.MaxInputStreams
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_PROCESS_MAX_INPUT_STREAMS {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_PROCESS_MAX_INPUT_STREAMS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_FEATURE_DATA_VIDEO_PROCESS_PROTECTED_RESOURCES {
    pub NodeIndex: u32,
    pub SupportFlags: D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_PROCESS_PROTECTED_RESOURCES {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_PROCESS_PROTECTED_RESOURCES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_PROCESS_PROTECTED_RESOURCES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_PROCESS_PROTECTED_RESOURCES").field("NodeIndex", &self.NodeIndex).field("SupportFlags", &self.SupportFlags).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_PROCESS_PROTECTED_RESOURCES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_PROCESS_PROTECTED_RESOURCES {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.SupportFlags == other.SupportFlags
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_PROCESS_PROTECTED_RESOURCES {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_PROCESS_PROTECTED_RESOURCES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
pub struct D3D12_FEATURE_DATA_VIDEO_PROCESS_REFERENCE_INFO {
    pub NodeIndex: u32,
    pub DeinterlaceMode: D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS,
    pub Filters: D3D12_VIDEO_PROCESS_FILTER_FLAGS,
    pub FeatureSupport: D3D12_VIDEO_PROCESS_FEATURE_FLAGS,
    pub InputFrameRate: super::super::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub OutputFrameRate: super::super::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub EnableAutoProcessing: super::super::Foundation::BOOL,
    pub PastFrames: u32,
    pub FutureFrames: u32,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_PROCESS_REFERENCE_INFO {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_PROCESS_REFERENCE_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_PROCESS_REFERENCE_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_PROCESS_REFERENCE_INFO").field("NodeIndex", &self.NodeIndex).field("DeinterlaceMode", &self.DeinterlaceMode).field("Filters", &self.Filters).field("FeatureSupport", &self.FeatureSupport).field("InputFrameRate", &self.InputFrameRate).field("OutputFrameRate", &self.OutputFrameRate).field("EnableAutoProcessing", &self.EnableAutoProcessing).field("PastFrames", &self.PastFrames).field("FutureFrames", &self.FutureFrames).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_PROCESS_REFERENCE_INFO {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_PROCESS_REFERENCE_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.DeinterlaceMode == other.DeinterlaceMode && self.Filters == other.Filters && self.FeatureSupport == other.FeatureSupport && self.InputFrameRate == other.InputFrameRate && self.OutputFrameRate == other.OutputFrameRate && self.EnableAutoProcessing == other.EnableAutoProcessing && self.PastFrames == other.PastFrames && self.FutureFrames == other.FutureFrames
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_PROCESS_REFERENCE_INFO {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_PROCESS_REFERENCE_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
pub struct D3D12_FEATURE_DATA_VIDEO_PROCESS_SUPPORT {
    pub NodeIndex: u32,
    pub InputSample: D3D12_VIDEO_SAMPLE,
    pub InputFieldType: D3D12_VIDEO_FIELD_TYPE,
    pub InputStereoFormat: D3D12_VIDEO_FRAME_STEREO_FORMAT,
    pub InputFrameRate: super::super::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub OutputFormat: D3D12_VIDEO_FORMAT,
    pub OutputStereoFormat: D3D12_VIDEO_FRAME_STEREO_FORMAT,
    pub OutputFrameRate: super::super::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub SupportFlags: D3D12_VIDEO_PROCESS_SUPPORT_FLAGS,
    pub ScaleSupport: D3D12_VIDEO_SCALE_SUPPORT,
    pub FeatureSupport: D3D12_VIDEO_PROCESS_FEATURE_FLAGS,
    pub DeinterlaceSupport: D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS,
    pub AutoProcessingSupport: D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS,
    pub FilterSupport: D3D12_VIDEO_PROCESS_FILTER_FLAGS,
    pub FilterRangeSupport: [D3D12_VIDEO_PROCESS_FILTER_RANGE; 32],
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_PROCESS_SUPPORT {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_PROCESS_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_PROCESS_SUPPORT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_PROCESS_SUPPORT")
            .field("NodeIndex", &self.NodeIndex)
            .field("InputSample", &self.InputSample)
            .field("InputFieldType", &self.InputFieldType)
            .field("InputStereoFormat", &self.InputStereoFormat)
            .field("InputFrameRate", &self.InputFrameRate)
            .field("OutputFormat", &self.OutputFormat)
            .field("OutputStereoFormat", &self.OutputStereoFormat)
            .field("OutputFrameRate", &self.OutputFrameRate)
            .field("SupportFlags", &self.SupportFlags)
            .field("ScaleSupport", &self.ScaleSupport)
            .field("FeatureSupport", &self.FeatureSupport)
            .field("DeinterlaceSupport", &self.DeinterlaceSupport)
            .field("AutoProcessingSupport", &self.AutoProcessingSupport)
            .field("FilterSupport", &self.FilterSupport)
            .field("FilterRangeSupport", &self.FilterRangeSupport)
            .finish()
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_PROCESS_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_PROCESS_SUPPORT {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.InputSample == other.InputSample && self.InputFieldType == other.InputFieldType && self.InputStereoFormat == other.InputStereoFormat && self.InputFrameRate == other.InputFrameRate && self.OutputFormat == other.OutputFormat && self.OutputStereoFormat == other.OutputStereoFormat && self.OutputFrameRate == other.OutputFrameRate && self.SupportFlags == other.SupportFlags && self.ScaleSupport == other.ScaleSupport && self.FeatureSupport == other.FeatureSupport && self.DeinterlaceSupport == other.DeinterlaceSupport && self.AutoProcessingSupport == other.AutoProcessingSupport && self.FilterSupport == other.FilterSupport && self.FilterRangeSupport == other.FilterRangeSupport
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_PROCESS_SUPPORT {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_PROCESS_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
pub struct D3D12_QUERY_DATA_VIDEO_DECODE_STATISTICS {
    pub Status: u64,
    pub NumMacroblocksAffected: u64,
    pub FrameRate: super::super::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub BitRate: u32,
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::marker::Copy for D3D12_QUERY_DATA_VIDEO_DECODE_STATISTICS {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::clone::Clone for D3D12_QUERY_DATA_VIDEO_DECODE_STATISTICS {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::fmt::Debug for D3D12_QUERY_DATA_VIDEO_DECODE_STATISTICS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_QUERY_DATA_VIDEO_DECODE_STATISTICS").field("Status", &self.Status).field("NumMacroblocksAffected", &self.NumMacroblocksAffected).field("FrameRate", &self.FrameRate).field("BitRate", &self.BitRate).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::windows::core::TypeKind for D3D12_QUERY_DATA_VIDEO_DECODE_STATISTICS {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::PartialEq for D3D12_QUERY_DATA_VIDEO_DECODE_STATISTICS {
    fn eq(&self, other: &Self) -> bool {
        self.Status == other.Status && self.NumMacroblocksAffected == other.NumMacroblocksAffected && self.FrameRate == other.FrameRate && self.BitRate == other.BitRate
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::Eq for D3D12_QUERY_DATA_VIDEO_DECODE_STATISTICS {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::default::Default for D3D12_QUERY_DATA_VIDEO_DECODE_STATISTICS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub struct D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT {
    pub pMotionVectorHeap: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12VideoMotionVectorHeap>>,
    pub PixelWidth: u32,
    pub PixelHeight: u32,
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT").field("pMotionVectorHeap", &self.pMotionVectorHeap).field("PixelWidth", &self.PixelWidth).field("PixelHeight", &self.PixelHeight).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::TypeKind for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.pMotionVectorHeap == other.pMotionVectorHeap && self.PixelWidth == other.PixelWidth && self.PixelHeight == other.PixelHeight
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::default::Default for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub struct D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT {
    pub pMotionVectorTexture2D: ::std::mem::ManuallyDrop<::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>>,
    pub MotionVectorCoordinate: D3D12_RESOURCE_COORDINATE,
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT").field("pMotionVectorTexture2D", &self.pMotionVectorTexture2D).field("MotionVectorCoordinate", &self.MotionVectorCoordinate).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::TypeKind for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.pMotionVectorTexture2D == other.pMotionVectorTexture2D && self.MotionVectorCoordinate == other.MotionVectorCoordinate
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::default::Default for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_RESOURCE_COORDINATE {
    pub X: u64,
    pub Y: u32,
    pub Z: u32,
    pub SubresourceIndex: u32,
}
impl ::core::marker::Copy for D3D12_RESOURCE_COORDINATE {}
impl ::core::clone::Clone for D3D12_RESOURCE_COORDINATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RESOURCE_COORDINATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RESOURCE_COORDINATE").field("X", &self.X).field("Y", &self.Y).field("Z", &self.Z).field("SubresourceIndex", &self.SubresourceIndex).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RESOURCE_COORDINATE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RESOURCE_COORDINATE {
    fn eq(&self, other: &Self) -> bool {
        self.X == other.X && self.Y == other.Y && self.Z == other.Z && self.SubresourceIndex == other.SubresourceIndex
    }
}
impl ::core::cmp::Eq for D3D12_RESOURCE_COORDINATE {}
impl ::core::default::Default for D3D12_RESOURCE_COORDINATE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_DECODER_DESC {
    pub NodeMask: u32,
    pub Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
}
impl ::core::marker::Copy for D3D12_VIDEO_DECODER_DESC {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODER_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODER_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODER_DESC").field("NodeMask", &self.NodeMask).field("Configuration", &self.Configuration).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODER_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODER_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.NodeMask == other.NodeMask && self.Configuration == other.Configuration
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_DECODER_DESC {}
impl ::core::default::Default for D3D12_VIDEO_DECODER_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
pub struct D3D12_VIDEO_DECODER_HEAP_DESC {
    pub NodeMask: u32,
    pub Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    pub DecodeWidth: u32,
    pub DecodeHeight: u32,
    pub Format: super::super::Graphics::Dxgi::Common::DXGI_FORMAT,
    pub FrameRate: super::super::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub BitRate: u32,
    pub MaxDecodePictureBufferCount: u32,
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::marker::Copy for D3D12_VIDEO_DECODER_HEAP_DESC {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::clone::Clone for D3D12_VIDEO_DECODER_HEAP_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::fmt::Debug for D3D12_VIDEO_DECODER_HEAP_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODER_HEAP_DESC").field("NodeMask", &self.NodeMask).field("Configuration", &self.Configuration).field("DecodeWidth", &self.DecodeWidth).field("DecodeHeight", &self.DecodeHeight).field("Format", &self.Format).field("FrameRate", &self.FrameRate).field("BitRate", &self.BitRate).field("MaxDecodePictureBufferCount", &self.MaxDecodePictureBufferCount).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODER_HEAP_DESC {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODER_HEAP_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.NodeMask == other.NodeMask && self.Configuration == other.Configuration && self.DecodeWidth == other.DecodeWidth && self.DecodeHeight == other.DecodeHeight && self.Format == other.Format && self.FrameRate == other.FrameRate && self.BitRate == other.BitRate && self.MaxDecodePictureBufferCount == other.MaxDecodePictureBufferCount
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::Eq for D3D12_VIDEO_DECODER_HEAP_DESC {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::default::Default for D3D12_VIDEO_DECODER_HEAP_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub struct D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM {
    pub pBuffer: ::std::mem::ManuallyDrop<::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>>,
    pub Offset: u64,
    pub Size: u64,
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM").field("pBuffer", &self.pBuffer).field("Offset", &self.Offset).field("Size", &self.Size).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM {
    fn eq(&self, other: &Self) -> bool {
        self.pBuffer == other.pBuffer && self.Offset == other.Offset && self.Size == other.Size
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::default::Default for D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_DECODE_CONFIGURATION {
    pub DecodeProfile: ::windows::core::GUID,
    pub BitstreamEncryption: D3D12_BITSTREAM_ENCRYPTION_TYPE,
    pub InterlaceType: D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE,
}
impl ::core::marker::Copy for D3D12_VIDEO_DECODE_CONFIGURATION {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_CONFIGURATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_CONFIGURATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODE_CONFIGURATION").field("DecodeProfile", &self.DecodeProfile).field("BitstreamEncryption", &self.BitstreamEncryption).field("InterlaceType", &self.InterlaceType).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_CONFIGURATION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODE_CONFIGURATION {
    fn eq(&self, other: &Self) -> bool {
        self.DecodeProfile == other.DecodeProfile && self.BitstreamEncryption == other.BitstreamEncryption && self.InterlaceType == other.InterlaceType
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_DECODE_CONFIGURATION {}
impl ::core::default::Default for D3D12_VIDEO_DECODE_CONFIGURATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub struct D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS {
    pub Enable: super::super::Foundation::BOOL,
    pub pReferenceTexture2D: ::std::mem::ManuallyDrop<::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>>,
    pub ReferenceSubresource: u32,
    pub OutputColorSpace: super::super::Graphics::Dxgi::Common::DXGI_COLOR_SPACE_TYPE,
    pub DecodeColorSpace: super::super::Graphics::Dxgi::Common::DXGI_COLOR_SPACE_TYPE,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS").field("Enable", &self.Enable).field("pReferenceTexture2D", &self.pReferenceTexture2D).field("ReferenceSubresource", &self.ReferenceSubresource).field("OutputColorSpace", &self.OutputColorSpace).field("DecodeColorSpace", &self.DecodeColorSpace).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS {
    fn eq(&self, other: &Self) -> bool {
        self.Enable == other.Enable && self.pReferenceTexture2D == other.pReferenceTexture2D && self.ReferenceSubresource == other.ReferenceSubresource && self.OutputColorSpace == other.OutputColorSpace && self.DecodeColorSpace == other.DecodeColorSpace
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::cmp::Eq for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::default::Default for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub struct D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1 {
    pub Enable: super::super::Foundation::BOOL,
    pub pReferenceTexture2D: ::std::mem::ManuallyDrop<::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>>,
    pub ReferenceSubresource: u32,
    pub OutputColorSpace: super::super::Graphics::Dxgi::Common::DXGI_COLOR_SPACE_TYPE,
    pub DecodeColorSpace: super::super::Graphics::Dxgi::Common::DXGI_COLOR_SPACE_TYPE,
    pub OutputWidth: u32,
    pub OutputHeight: u32,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1 {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1").field("Enable", &self.Enable).field("pReferenceTexture2D", &self.pReferenceTexture2D).field("ReferenceSubresource", &self.ReferenceSubresource).field("OutputColorSpace", &self.OutputColorSpace).field("DecodeColorSpace", &self.DecodeColorSpace).field("OutputWidth", &self.OutputWidth).field("OutputHeight", &self.OutputHeight).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1 {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1 {
    fn eq(&self, other: &Self) -> bool {
        self.Enable == other.Enable && self.pReferenceTexture2D == other.pReferenceTexture2D && self.ReferenceSubresource == other.ReferenceSubresource && self.OutputColorSpace == other.OutputColorSpace && self.DecodeColorSpace == other.DecodeColorSpace && self.OutputWidth == other.OutputWidth && self.OutputHeight == other.OutputHeight
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::cmp::Eq for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1 {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::default::Default for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_DECODE_FRAME_ARGUMENT {
    pub Type: D3D12_VIDEO_DECODE_ARGUMENT_TYPE,
    pub Size: u32,
    pub pData: *mut ::core::ffi::c_void,
}
impl ::core::marker::Copy for D3D12_VIDEO_DECODE_FRAME_ARGUMENT {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_FRAME_ARGUMENT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_FRAME_ARGUMENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODE_FRAME_ARGUMENT").field("Type", &self.Type).field("Size", &self.Size).field("pData", &self.pData).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_FRAME_ARGUMENT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODE_FRAME_ARGUMENT {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type && self.Size == other.Size && self.pData == other.pData
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_DECODE_FRAME_ARGUMENT {}
impl ::core::default::Default for D3D12_VIDEO_DECODE_FRAME_ARGUMENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub struct D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS {
    pub NumFrameArguments: u32,
    pub FrameArguments: [D3D12_VIDEO_DECODE_FRAME_ARGUMENT; 10],
    pub ReferenceFrames: D3D12_VIDEO_DECODE_REFERENCE_FRAMES,
    pub CompressedBitstream: D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM,
    pub pHeap: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12VideoDecoderHeap>>,
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS").field("NumFrameArguments", &self.NumFrameArguments).field("FrameArguments", &self.FrameArguments).field("ReferenceFrames", &self.ReferenceFrames).field("CompressedBitstream", &self.CompressedBitstream).field("pHeap", &self.pHeap).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS {
    fn eq(&self, other: &Self) -> bool {
        self.NumFrameArguments == other.NumFrameArguments && self.FrameArguments == other.FrameArguments && self.ReferenceFrames == other.ReferenceFrames && self.CompressedBitstream == other.CompressedBitstream && self.pHeap == other.pHeap
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::default::Default for D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub struct D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM {
    pub Offset: u64,
    pub pBuffer: ::std::mem::ManuallyDrop<::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>>,
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM").field("Offset", &self.Offset).field("pBuffer", &self.pBuffer).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM {
    fn eq(&self, other: &Self) -> bool {
        self.Offset == other.Offset && self.pBuffer == other.pBuffer
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::default::Default for D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub struct D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS {
    pub pOutputTexture2D: ::std::mem::ManuallyDrop<::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>>,
    pub OutputSubresource: u32,
    pub ConversionArguments: D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS").field("pOutputTexture2D", &self.pOutputTexture2D).field("OutputSubresource", &self.OutputSubresource).field("ConversionArguments", &self.ConversionArguments).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS {
    fn eq(&self, other: &Self) -> bool {
        self.pOutputTexture2D == other.pOutputTexture2D && self.OutputSubresource == other.OutputSubresource && self.ConversionArguments == other.ConversionArguments
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::cmp::Eq for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::default::Default for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub struct D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1 {
    pub pOutputTexture2D: ::std::mem::ManuallyDrop<::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>>,
    pub OutputSubresource: u32,
    pub ConversionArguments: D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1,
    pub Histograms: [D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM; 4],
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1 {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1").field("pOutputTexture2D", &self.pOutputTexture2D).field("OutputSubresource", &self.OutputSubresource).field("ConversionArguments", &self.ConversionArguments).field("Histograms", &self.Histograms).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1 {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1 {
    fn eq(&self, other: &Self) -> bool {
        self.pOutputTexture2D == other.pOutputTexture2D && self.OutputSubresource == other.OutputSubresource && self.ConversionArguments == other.ConversionArguments && self.Histograms == other.Histograms
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::cmp::Eq for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1 {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::default::Default for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub struct D3D12_VIDEO_DECODE_REFERENCE_FRAMES {
    pub NumTexture2Ds: u32,
    pub ppTexture2Ds: *mut ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>,
    pub pSubresources: *mut u32,
    pub ppHeaps: *mut ::core::option::Option<ID3D12VideoDecoderHeap>,
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::marker::Copy for D3D12_VIDEO_DECODE_REFERENCE_FRAMES {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_REFERENCE_FRAMES {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_REFERENCE_FRAMES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODE_REFERENCE_FRAMES").field("NumTexture2Ds", &self.NumTexture2Ds).field("ppTexture2Ds", &self.ppTexture2Ds).field("pSubresources", &self.pSubresources).field("ppHeaps", &self.ppHeaps).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_REFERENCE_FRAMES {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODE_REFERENCE_FRAMES {
    fn eq(&self, other: &Self) -> bool {
        self.NumTexture2Ds == other.NumTexture2Ds && self.ppTexture2Ds == other.ppTexture2Ds && self.pSubresources == other.pSubresources && self.ppHeaps == other.ppHeaps
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for D3D12_VIDEO_DECODE_REFERENCE_FRAMES {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::default::Default for D3D12_VIDEO_DECODE_REFERENCE_FRAMES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION {
    pub DataSize: u32,
    pub Anonymous: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_0,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub union D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_0 {
    pub pH264Config: *mut D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264,
    pub pHEVCConfig: *mut D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_0 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264 {
    pub ConfigurationFlags: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS,
    pub DirectModeConfig: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES,
    pub DisableDeblockingFilterConfig: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264").field("ConfigurationFlags", &self.ConfigurationFlags).field("DirectModeConfig", &self.DirectModeConfig).field("DisableDeblockingFilterConfig", &self.DisableDeblockingFilterConfig).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264 {
    fn eq(&self, other: &Self) -> bool {
        self.ConfigurationFlags == other.ConfigurationFlags && self.DirectModeConfig == other.DirectModeConfig && self.DisableDeblockingFilterConfig == other.DisableDeblockingFilterConfig
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264 {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC {
    pub ConfigurationFlags: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS,
    pub MinLumaCodingUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE,
    pub MaxLumaCodingUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE,
    pub MinLumaTransformUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE,
    pub MaxLumaTransformUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE,
    pub max_transform_hierarchy_depth_inter: u8,
    pub max_transform_hierarchy_depth_intra: u8,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC")
            .field("ConfigurationFlags", &self.ConfigurationFlags)
            .field("MinLumaCodingUnitSize", &self.MinLumaCodingUnitSize)
            .field("MaxLumaCodingUnitSize", &self.MaxLumaCodingUnitSize)
            .field("MinLumaTransformUnitSize", &self.MinLumaTransformUnitSize)
            .field("MaxLumaTransformUnitSize", &self.MaxLumaTransformUnitSize)
            .field("max_transform_hierarchy_depth_inter", &self.max_transform_hierarchy_depth_inter)
            .field("max_transform_hierarchy_depth_intra", &self.max_transform_hierarchy_depth_intra)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC {
    fn eq(&self, other: &Self) -> bool {
        self.ConfigurationFlags == other.ConfigurationFlags && self.MinLumaCodingUnitSize == other.MinLumaCodingUnitSize && self.MaxLumaCodingUnitSize == other.MaxLumaCodingUnitSize && self.MinLumaTransformUnitSize == other.MinLumaTransformUnitSize && self.MaxLumaTransformUnitSize == other.MaxLumaTransformUnitSize && self.max_transform_hierarchy_depth_inter == other.max_transform_hierarchy_depth_inter && self.max_transform_hierarchy_depth_intra == other.max_transform_hierarchy_depth_intra
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT {
    pub DataSize: u32,
    pub Anonymous: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_0,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub union D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_0 {
    pub pH264Support: *mut D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264,
    pub pHEVCSupport: *mut D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_0 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264 {
    pub SupportFlags: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS,
    pub DisableDeblockingFilterSupportedModes: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264").field("SupportFlags", &self.SupportFlags).field("DisableDeblockingFilterSupportedModes", &self.DisableDeblockingFilterSupportedModes).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264 {
    fn eq(&self, other: &Self) -> bool {
        self.SupportFlags == other.SupportFlags && self.DisableDeblockingFilterSupportedModes == other.DisableDeblockingFilterSupportedModes
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264 {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC {
    pub SupportFlags: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS,
    pub MinLumaCodingUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE,
    pub MaxLumaCodingUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE,
    pub MinLumaTransformUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE,
    pub MaxLumaTransformUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE,
    pub max_transform_hierarchy_depth_inter: u8,
    pub max_transform_hierarchy_depth_intra: u8,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC")
            .field("SupportFlags", &self.SupportFlags)
            .field("MinLumaCodingUnitSize", &self.MinLumaCodingUnitSize)
            .field("MaxLumaCodingUnitSize", &self.MaxLumaCodingUnitSize)
            .field("MinLumaTransformUnitSize", &self.MinLumaTransformUnitSize)
            .field("MaxLumaTransformUnitSize", &self.MaxLumaTransformUnitSize)
            .field("max_transform_hierarchy_depth_inter", &self.max_transform_hierarchy_depth_inter)
            .field("max_transform_hierarchy_depth_intra", &self.max_transform_hierarchy_depth_intra)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC {
    fn eq(&self, other: &Self) -> bool {
        self.SupportFlags == other.SupportFlags && self.MinLumaCodingUnitSize == other.MinLumaCodingUnitSize && self.MaxLumaCodingUnitSize == other.MaxLumaCodingUnitSize && self.MinLumaTransformUnitSize == other.MinLumaTransformUnitSize && self.MaxLumaTransformUnitSize == other.MaxLumaTransformUnitSize && self.max_transform_hierarchy_depth_inter == other.max_transform_hierarchy_depth_inter && self.max_transform_hierarchy_depth_intra == other.max_transform_hierarchy_depth_intra
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT {
    pub DataSize: u32,
    pub Anonymous: D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_0,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub union D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_0 {
    pub pH264Support: *mut D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_H264,
    pub pHEVCSupport: *mut D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_HEVC,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_0 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_H264 {
    pub MaxL0ReferencesForP: u32,
    pub MaxL0ReferencesForB: u32,
    pub MaxL1ReferencesForB: u32,
    pub MaxLongTermReferences: u32,
    pub MaxDPBCapacity: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_H264 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_H264 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_H264 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_H264").field("MaxL0ReferencesForP", &self.MaxL0ReferencesForP).field("MaxL0ReferencesForB", &self.MaxL0ReferencesForB).field("MaxL1ReferencesForB", &self.MaxL1ReferencesForB).field("MaxLongTermReferences", &self.MaxLongTermReferences).field("MaxDPBCapacity", &self.MaxDPBCapacity).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_H264 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_H264 {
    fn eq(&self, other: &Self) -> bool {
        self.MaxL0ReferencesForP == other.MaxL0ReferencesForP && self.MaxL0ReferencesForB == other.MaxL0ReferencesForB && self.MaxL1ReferencesForB == other.MaxL1ReferencesForB && self.MaxLongTermReferences == other.MaxLongTermReferences && self.MaxDPBCapacity == other.MaxDPBCapacity
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_H264 {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_H264 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_HEVC {
    pub MaxL0ReferencesForP: u32,
    pub MaxL0ReferencesForB: u32,
    pub MaxL1ReferencesForB: u32,
    pub MaxLongTermReferences: u32,
    pub MaxDPBCapacity: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_HEVC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_HEVC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_HEVC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_HEVC").field("MaxL0ReferencesForP", &self.MaxL0ReferencesForP).field("MaxL0ReferencesForB", &self.MaxL0ReferencesForB).field("MaxL1ReferencesForB", &self.MaxL1ReferencesForB).field("MaxLongTermReferences", &self.MaxLongTermReferences).field("MaxDPBCapacity", &self.MaxDPBCapacity).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_HEVC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_HEVC {
    fn eq(&self, other: &Self) -> bool {
        self.MaxL0ReferencesForP == other.MaxL0ReferencesForP && self.MaxL0ReferencesForB == other.MaxL0ReferencesForB && self.MaxL1ReferencesForB == other.MaxL1ReferencesForB && self.MaxLongTermReferences == other.MaxLongTermReferences && self.MaxDPBCapacity == other.MaxDPBCapacity
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_HEVC {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_HEVC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub struct D3D12_VIDEO_ENCODER_COMPRESSED_BITSTREAM {
    pub pBuffer: ::std::mem::ManuallyDrop<::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>>,
    pub FrameStartOffset: u64,
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_COMPRESSED_BITSTREAM {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_COMPRESSED_BITSTREAM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_COMPRESSED_BITSTREAM").field("pBuffer", &self.pBuffer).field("FrameStartOffset", &self.FrameStartOffset).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_COMPRESSED_BITSTREAM {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_COMPRESSED_BITSTREAM {
    fn eq(&self, other: &Self) -> bool {
        self.pBuffer == other.pBuffer && self.FrameStartOffset == other.FrameStartOffset
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_COMPRESSED_BITSTREAM {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::default::Default for D3D12_VIDEO_ENCODER_COMPRESSED_BITSTREAM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
pub struct D3D12_VIDEO_ENCODER_DESC {
    pub NodeMask: u32,
    pub Flags: D3D12_VIDEO_ENCODER_FLAGS,
    pub EncodeCodec: D3D12_VIDEO_ENCODER_CODEC,
    pub EncodeProfile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub InputFormat: super::super::Graphics::Dxgi::Common::DXGI_FORMAT,
    pub CodecConfiguration: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION,
    pub MaxMotionEstimationPrecision: D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE,
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_DESC {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_DESC {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::default::Default for D3D12_VIDEO_ENCODER_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub struct D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS {
    pub SequenceControlDesc: D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_DESC,
    pub PictureControlDesc: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_DESC,
    pub pInputFrame: ::std::mem::ManuallyDrop<::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>>,
    pub InputFrameSubresource: u32,
    pub CurrentFrameBitstreamMetadataSize: u32,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::default::Default for D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub struct D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS {
    pub Bitstream: D3D12_VIDEO_ENCODER_COMPRESSED_BITSTREAM,
    pub ReconstructedPicture: D3D12_VIDEO_ENCODER_RECONSTRUCTED_PICTURE,
    pub EncoderOutputMetadata: D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER,
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS").field("Bitstream", &self.Bitstream).field("ReconstructedPicture", &self.ReconstructedPicture).field("EncoderOutputMetadata", &self.EncoderOutputMetadata).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS {
    fn eq(&self, other: &Self) -> bool {
        self.Bitstream == other.Bitstream && self.ReconstructedPicture == other.ReconstructedPicture && self.EncoderOutputMetadata == other.EncoderOutputMetadata
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::default::Default for D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub struct D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER {
    pub pBuffer: ::std::mem::ManuallyDrop<::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>>,
    pub Offset: u64,
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER").field("pBuffer", &self.pBuffer).field("Offset", &self.Offset).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.pBuffer == other.pBuffer && self.Offset == other.Offset
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::default::Default for D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_FRAME_SUBREGION_METADATA {
    pub bSize: u64,
    pub bStartOffset: u64,
    pub bHeaderSize: u64,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_METADATA {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_METADATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_METADATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_FRAME_SUBREGION_METADATA").field("bSize", &self.bSize).field("bStartOffset", &self.bStartOffset).field("bHeaderSize", &self.bHeaderSize).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_METADATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_METADATA {
    fn eq(&self, other: &Self) -> bool {
        self.bSize == other.bSize && self.bStartOffset == other.bStartOffset && self.bHeaderSize == other.bHeaderSize
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_METADATA {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_METADATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_HEAP_DESC {
    pub NodeMask: u32,
    pub Flags: D3D12_VIDEO_ENCODER_HEAP_FLAGS,
    pub EncodeCodec: D3D12_VIDEO_ENCODER_CODEC,
    pub EncodeProfile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub EncodeLevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
    pub ResolutionsListCount: u32,
    pub pResolutionList: *const D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_HEAP_DESC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_HEAP_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_HEAP_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_HEAP_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_INTRA_REFRESH {
    pub Mode: D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE,
    pub IntraRefreshDuration: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_INTRA_REFRESH {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_INTRA_REFRESH {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_INTRA_REFRESH {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_INTRA_REFRESH").field("Mode", &self.Mode).field("IntraRefreshDuration", &self.IntraRefreshDuration).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_INTRA_REFRESH {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_INTRA_REFRESH {
    fn eq(&self, other: &Self) -> bool {
        self.Mode == other.Mode && self.IntraRefreshDuration == other.IntraRefreshDuration
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_INTRA_REFRESH {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_INTRA_REFRESH {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_LEVEL_SETTING {
    pub DataSize: u32,
    pub Anonymous: D3D12_VIDEO_ENCODER_LEVEL_SETTING_0,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_LEVEL_SETTING {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_LEVEL_SETTING {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_LEVEL_SETTING {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_LEVEL_SETTING {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub union D3D12_VIDEO_ENCODER_LEVEL_SETTING_0 {
    pub pH264LevelSetting: *mut D3D12_VIDEO_ENCODER_LEVELS_H264,
    pub pHEVCLevelSetting: *mut D3D12_VIDEO_ENCODER_LEVEL_TIER_CONSTRAINTS_HEVC,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_LEVEL_SETTING_0 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_LEVEL_SETTING_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_LEVEL_SETTING_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_LEVEL_SETTING_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_LEVEL_TIER_CONSTRAINTS_HEVC {
    pub Level: D3D12_VIDEO_ENCODER_LEVELS_HEVC,
    pub Tier: D3D12_VIDEO_ENCODER_TIER_HEVC,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_LEVEL_TIER_CONSTRAINTS_HEVC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_LEVEL_TIER_CONSTRAINTS_HEVC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_LEVEL_TIER_CONSTRAINTS_HEVC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_LEVEL_TIER_CONSTRAINTS_HEVC").field("Level", &self.Level).field("Tier", &self.Tier).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_LEVEL_TIER_CONSTRAINTS_HEVC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_LEVEL_TIER_CONSTRAINTS_HEVC {
    fn eq(&self, other: &Self) -> bool {
        self.Level == other.Level && self.Tier == other.Tier
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_LEVEL_TIER_CONSTRAINTS_HEVC {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_LEVEL_TIER_CONSTRAINTS_HEVC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_OUTPUT_METADATA {
    pub EncodeErrorFlags: u64,
    pub EncodeStats: D3D12_VIDEO_ENCODER_OUTPUT_METADATA_STATISTICS,
    pub EncodedBitstreamWrittenBytesCount: u64,
    pub WrittenSubregionsCount: u64,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_OUTPUT_METADATA {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_OUTPUT_METADATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_OUTPUT_METADATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_OUTPUT_METADATA").field("EncodeErrorFlags", &self.EncodeErrorFlags).field("EncodeStats", &self.EncodeStats).field("EncodedBitstreamWrittenBytesCount", &self.EncodedBitstreamWrittenBytesCount).field("WrittenSubregionsCount", &self.WrittenSubregionsCount).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_OUTPUT_METADATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_OUTPUT_METADATA {
    fn eq(&self, other: &Self) -> bool {
        self.EncodeErrorFlags == other.EncodeErrorFlags && self.EncodeStats == other.EncodeStats && self.EncodedBitstreamWrittenBytesCount == other.EncodedBitstreamWrittenBytesCount && self.WrittenSubregionsCount == other.WrittenSubregionsCount
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_OUTPUT_METADATA {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_OUTPUT_METADATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_OUTPUT_METADATA_STATISTICS {
    pub AverageQP: u64,
    pub IntraCodingUnitsCount: u64,
    pub InterCodingUnitsCount: u64,
    pub SkipCodingUnitsCount: u64,
    pub AverageMotionEstimationXDirection: u64,
    pub AverageMotionEstimationYDirection: u64,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_OUTPUT_METADATA_STATISTICS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_OUTPUT_METADATA_STATISTICS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_OUTPUT_METADATA_STATISTICS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_OUTPUT_METADATA_STATISTICS").field("AverageQP", &self.AverageQP).field("IntraCodingUnitsCount", &self.IntraCodingUnitsCount).field("InterCodingUnitsCount", &self.InterCodingUnitsCount).field("SkipCodingUnitsCount", &self.SkipCodingUnitsCount).field("AverageMotionEstimationXDirection", &self.AverageMotionEstimationXDirection).field("AverageMotionEstimationYDirection", &self.AverageMotionEstimationYDirection).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_OUTPUT_METADATA_STATISTICS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_OUTPUT_METADATA_STATISTICS {
    fn eq(&self, other: &Self) -> bool {
        self.AverageQP == other.AverageQP && self.IntraCodingUnitsCount == other.IntraCodingUnitsCount && self.InterCodingUnitsCount == other.InterCodingUnitsCount && self.SkipCodingUnitsCount == other.SkipCodingUnitsCount && self.AverageMotionEstimationXDirection == other.AverageMotionEstimationXDirection && self.AverageMotionEstimationYDirection == other.AverageMotionEstimationYDirection
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_OUTPUT_METADATA_STATISTICS {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_OUTPUT_METADATA_STATISTICS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA {
    pub DataSize: u32,
    pub Anonymous: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_0,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub union D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_0 {
    pub pH264PicData: *mut D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264,
    pub pHEVCPicData: *mut D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_0 {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_0 {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264 {
    pub Flags: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS,
    pub FrameType: D3D12_VIDEO_ENCODER_FRAME_TYPE_H264,
    pub pic_parameter_set_id: u32,
    pub idr_pic_id: u32,
    pub PictureOrderCountNumber: u32,
    pub FrameDecodingOrderNumber: u32,
    pub TemporalLayerIndex: u32,
    pub List0ReferenceFramesCount: u32,
    pub pList0ReferenceFrames: *mut u32,
    pub List1ReferenceFramesCount: u32,
    pub pList1ReferenceFrames: *mut u32,
    pub ReferenceFramesReconPictureDescriptorsCount: u32,
    pub pReferenceFramesReconPictureDescriptors: *mut D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_H264,
    pub adaptive_ref_pic_marking_mode_flag: u8,
    pub RefPicMarkingOperationsCommandsCount: u32,
    pub pRefPicMarkingOperationsCommands: *mut D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_MARKING_OPERATION,
    pub List0RefPicModificationsCount: u32,
    pub pList0RefPicModifications: *mut D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION,
    pub List1RefPicModificationsCount: u32,
    pub pList1RefPicModifications: *mut D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION,
    pub QPMapValuesCount: u32,
    pub pRateControlQPMap: *mut i8,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264 {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264")
            .field("Flags", &self.Flags)
            .field("FrameType", &self.FrameType)
            .field("pic_parameter_set_id", &self.pic_parameter_set_id)
            .field("idr_pic_id", &self.idr_pic_id)
            .field("PictureOrderCountNumber", &self.PictureOrderCountNumber)
            .field("FrameDecodingOrderNumber", &self.FrameDecodingOrderNumber)
            .field("TemporalLayerIndex", &self.TemporalLayerIndex)
            .field("List0ReferenceFramesCount", &self.List0ReferenceFramesCount)
            .field("pList0ReferenceFrames", &self.pList0ReferenceFrames)
            .field("List1ReferenceFramesCount", &self.List1ReferenceFramesCount)
            .field("pList1ReferenceFrames", &self.pList1ReferenceFrames)
            .field("ReferenceFramesReconPictureDescriptorsCount", &self.ReferenceFramesReconPictureDescriptorsCount)
            .field("pReferenceFramesReconPictureDescriptors", &self.pReferenceFramesReconPictureDescriptors)
            .field("adaptive_ref_pic_marking_mode_flag", &self.adaptive_ref_pic_marking_mode_flag)
            .field("RefPicMarkingOperationsCommandsCount", &self.RefPicMarkingOperationsCommandsCount)
            .field("pRefPicMarkingOperationsCommands", &self.pRefPicMarkingOperationsCommands)
            .field("List0RefPicModificationsCount", &self.List0RefPicModificationsCount)
            .field("pList0RefPicModifications", &self.pList0RefPicModifications)
            .field("List1RefPicModificationsCount", &self.List1RefPicModificationsCount)
            .field("pList1RefPicModifications", &self.pList1RefPicModifications)
            .field("QPMapValuesCount", &self.QPMapValuesCount)
            .field("pRateControlQPMap", &self.pRateControlQPMap)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264 {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264 {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
            && self.FrameType == other.FrameType
            && self.pic_parameter_set_id == other.pic_parameter_set_id
            && self.idr_pic_id == other.idr_pic_id
            && self.PictureOrderCountNumber == other.PictureOrderCountNumber
            && self.FrameDecodingOrderNumber == other.FrameDecodingOrderNumber
            && self.TemporalLayerIndex == other.TemporalLayerIndex
            && self.List0ReferenceFramesCount == other.List0ReferenceFramesCount
            && self.pList0ReferenceFrames == other.pList0ReferenceFrames
            && self.List1ReferenceFramesCount == other.List1ReferenceFramesCount
            && self.pList1ReferenceFrames == other.pList1ReferenceFrames
            && self.ReferenceFramesReconPictureDescriptorsCount == other.ReferenceFramesReconPictureDescriptorsCount
            && self.pReferenceFramesReconPictureDescriptors == other.pReferenceFramesReconPictureDescriptors
            && self.adaptive_ref_pic_marking_mode_flag == other.adaptive_ref_pic_marking_mode_flag
            && self.RefPicMarkingOperationsCommandsCount == other.RefPicMarkingOperationsCommandsCount
            && self.pRefPicMarkingOperationsCommands == other.pRefPicMarkingOperationsCommands
            && self.List0RefPicModificationsCount == other.List0RefPicModificationsCount
            && self.pList0RefPicModifications == other.pList0RefPicModifications
            && self.List1RefPicModificationsCount == other.List1RefPicModificationsCount
            && self.pList1RefPicModifications == other.pList1RefPicModifications
            && self.QPMapValuesCount == other.QPMapValuesCount
            && self.pRateControlQPMap == other.pRateControlQPMap
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264 {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION {
    pub modification_of_pic_nums_idc: u8,
    pub abs_diff_pic_num_minus1: u32,
    pub long_term_pic_num: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION").field("modification_of_pic_nums_idc", &self.modification_of_pic_nums_idc).field("abs_diff_pic_num_minus1", &self.abs_diff_pic_num_minus1).field("long_term_pic_num", &self.long_term_pic_num).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION {
    fn eq(&self, other: &Self) -> bool {
        self.modification_of_pic_nums_idc == other.modification_of_pic_nums_idc && self.abs_diff_pic_num_minus1 == other.abs_diff_pic_num_minus1 && self.long_term_pic_num == other.long_term_pic_num
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_MARKING_OPERATION {
    pub memory_management_control_operation: u8,
    pub difference_of_pic_nums_minus1: u32,
    pub long_term_pic_num: u32,
    pub long_term_frame_idx: u32,
    pub max_long_term_frame_idx_plus1: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_MARKING_OPERATION {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_MARKING_OPERATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_MARKING_OPERATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_MARKING_OPERATION").field("memory_management_control_operation", &self.memory_management_control_operation).field("difference_of_pic_nums_minus1", &self.difference_of_pic_nums_minus1).field("long_term_pic_num", &self.long_term_pic_num).field("long_term_frame_idx", &self.long_term_frame_idx).field("max_long_term_frame_idx_plus1", &self.max_long_term_frame_idx_plus1).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_MARKING_OPERATION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_MARKING_OPERATION {
    fn eq(&self, other: &Self) -> bool {
        self.memory_management_control_operation == other.memory_management_control_operation && self.difference_of_pic_nums_minus1 == other.difference_of_pic_nums_minus1 && self.long_term_pic_num == other.long_term_pic_num && self.long_term_frame_idx == other.long_term_frame_idx && self.max_long_term_frame_idx_plus1 == other.max_long_term_frame_idx_plus1
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_MARKING_OPERATION {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_MARKING_OPERATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC {
    pub Flags: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS,
    pub FrameType: D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC,
    pub slice_pic_parameter_set_id: u32,
    pub PictureOrderCountNumber: u32,
    pub TemporalLayerIndex: u32,
    pub List0ReferenceFramesCount: u32,
    pub pList0ReferenceFrames: *mut u32,
    pub List1ReferenceFramesCount: u32,
    pub pList1ReferenceFrames: *mut u32,
    pub ReferenceFramesReconPictureDescriptorsCount: u32,
    pub pReferenceFramesReconPictureDescriptors: *mut D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_HEVC,
    pub List0RefPicModificationsCount: u32,
    pub pList0RefPicModifications: *mut u32,
    pub List1RefPicModificationsCount: u32,
    pub pList1RefPicModifications: *mut u32,
    pub QPMapValuesCount: u32,
    pub pRateControlQPMap: *mut i8,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC")
            .field("Flags", &self.Flags)
            .field("FrameType", &self.FrameType)
            .field("slice_pic_parameter_set_id", &self.slice_pic_parameter_set_id)
            .field("PictureOrderCountNumber", &self.PictureOrderCountNumber)
            .field("TemporalLayerIndex", &self.TemporalLayerIndex)
            .field("List0ReferenceFramesCount", &self.List0ReferenceFramesCount)
            .field("pList0ReferenceFrames", &self.pList0ReferenceFrames)
            .field("List1ReferenceFramesCount", &self.List1ReferenceFramesCount)
            .field("pList1ReferenceFrames", &self.pList1ReferenceFrames)
            .field("ReferenceFramesReconPictureDescriptorsCount", &self.ReferenceFramesReconPictureDescriptorsCount)
            .field("pReferenceFramesReconPictureDescriptors", &self.pReferenceFramesReconPictureDescriptors)
            .field("List0RefPicModificationsCount", &self.List0RefPicModificationsCount)
            .field("pList0RefPicModifications", &self.pList0RefPicModifications)
            .field("List1RefPicModificationsCount", &self.List1RefPicModificationsCount)
            .field("pList1RefPicModifications", &self.pList1RefPicModifications)
            .field("QPMapValuesCount", &self.QPMapValuesCount)
            .field("pRateControlQPMap", &self.pRateControlQPMap)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
            && self.FrameType == other.FrameType
            && self.slice_pic_parameter_set_id == other.slice_pic_parameter_set_id
            && self.PictureOrderCountNumber == other.PictureOrderCountNumber
            && self.TemporalLayerIndex == other.TemporalLayerIndex
            && self.List0ReferenceFramesCount == other.List0ReferenceFramesCount
            && self.pList0ReferenceFrames == other.pList0ReferenceFrames
            && self.List1ReferenceFramesCount == other.List1ReferenceFramesCount
            && self.pList1ReferenceFrames == other.pList1ReferenceFrames
            && self.ReferenceFramesReconPictureDescriptorsCount == other.ReferenceFramesReconPictureDescriptorsCount
            && self.pReferenceFramesReconPictureDescriptors == other.pReferenceFramesReconPictureDescriptors
            && self.List0RefPicModificationsCount == other.List0RefPicModificationsCount
            && self.pList0RefPicModifications == other.pList0RefPicModifications
            && self.List1RefPicModificationsCount == other.List1RefPicModificationsCount
            && self.pList1RefPicModifications == other.pList1RefPicModifications
            && self.QPMapValuesCount == other.QPMapValuesCount
            && self.pRateControlQPMap == other.pRateControlQPMap
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
pub struct D3D12_VIDEO_ENCODER_PICTURE_CONTROL_DESC {
    pub IntraRefreshFrameIndex: u32,
    pub Flags: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS,
    pub PictureControlCodecData: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA,
    pub ReferenceFrames: D3D12_VIDEO_ENCODE_REFERENCE_FRAMES,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_DESC {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_DESC {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA {
    pub DataSize: u32,
    pub Anonymous: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_0,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub union D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_0 {
    pub pSlicesPartition_H264: *const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES,
    pub pSlicesPartition_HEVC: *const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_0 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES {
    pub Anonymous: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES_0,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub union D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES_0 {
    pub MaxBytesPerSlice: u32,
    pub NumberOfCodingUnitsPerSlice: u32,
    pub NumberOfRowsPerSlice: u32,
    pub NumberOfSlicesPerFrame: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES_0 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC {
    pub Width: u32,
    pub Height: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC").field("Width", &self.Width).field("Height", &self.Height).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Width == other.Width && self.Height == other.Height
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_RATIO_DESC {
    pub WidthRatio: u32,
    pub HeightRatio: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_RATIO_DESC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_RATIO_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_RATIO_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_RATIO_DESC").field("WidthRatio", &self.WidthRatio).field("HeightRatio", &self.HeightRatio).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_RATIO_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_RATIO_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.WidthRatio == other.WidthRatio && self.HeightRatio == other.HeightRatio
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_RATIO_DESC {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_RATIO_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_PROFILE_DESC {
    pub DataSize: u32,
    pub Anonymous: D3D12_VIDEO_ENCODER_PROFILE_DESC_0,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PROFILE_DESC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PROFILE_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PROFILE_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PROFILE_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub union D3D12_VIDEO_ENCODER_PROFILE_DESC_0 {
    pub pH264Profile: *mut D3D12_VIDEO_ENCODER_PROFILE_H264,
    pub pHEVCProfile: *mut D3D12_VIDEO_ENCODER_PROFILE_HEVC,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PROFILE_DESC_0 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PROFILE_DESC_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PROFILE_DESC_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PROFILE_DESC_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
pub struct D3D12_VIDEO_ENCODER_RATE_CONTROL {
    pub Mode: D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE,
    pub Flags: D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS,
    pub ConfigParams: D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS,
    pub TargetFrameRate: super::super::Graphics::Dxgi::Common::DXGI_RATIONAL,
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_RATE_CONTROL {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RATE_CONTROL {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RATE_CONTROL {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RATE_CONTROL {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_RATE_CONTROL_CBR {
    pub InitialQP: u32,
    pub MinQP: u32,
    pub MaxQP: u32,
    pub MaxFrameBitSize: u64,
    pub TargetBitRate: u64,
    pub VBVCapacity: u64,
    pub InitialVBVFullness: u64,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_RATE_CONTROL_CBR {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RATE_CONTROL_CBR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_RATE_CONTROL_CBR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_RATE_CONTROL_CBR").field("InitialQP", &self.InitialQP).field("MinQP", &self.MinQP).field("MaxQP", &self.MaxQP).field("MaxFrameBitSize", &self.MaxFrameBitSize).field("TargetBitRate", &self.TargetBitRate).field("VBVCapacity", &self.VBVCapacity).field("InitialVBVFullness", &self.InitialVBVFullness).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RATE_CONTROL_CBR {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_RATE_CONTROL_CBR {
    fn eq(&self, other: &Self) -> bool {
        self.InitialQP == other.InitialQP && self.MinQP == other.MinQP && self.MaxQP == other.MaxQP && self.MaxFrameBitSize == other.MaxFrameBitSize && self.TargetBitRate == other.TargetBitRate && self.VBVCapacity == other.VBVCapacity && self.InitialVBVFullness == other.InitialVBVFullness
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_RATE_CONTROL_CBR {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RATE_CONTROL_CBR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS {
    pub DataSize: u32,
    pub Anonymous: D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS_0,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub union D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS_0 {
    pub pConfiguration_CQP: *const D3D12_VIDEO_ENCODER_RATE_CONTROL_CQP,
    pub pConfiguration_CBR: *const D3D12_VIDEO_ENCODER_RATE_CONTROL_CBR,
    pub pConfiguration_VBR: *const D3D12_VIDEO_ENCODER_RATE_CONTROL_VBR,
    pub pConfiguration_QVBR: *const D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS_0 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_RATE_CONTROL_CQP {
    pub ConstantQP_FullIntracodedFrame: u32,
    pub ConstantQP_InterPredictedFrame_PrevRefOnly: u32,
    pub ConstantQP_InterPredictedFrame_BiDirectionalRef: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_RATE_CONTROL_CQP {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RATE_CONTROL_CQP {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_RATE_CONTROL_CQP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_RATE_CONTROL_CQP").field("ConstantQP_FullIntracodedFrame", &self.ConstantQP_FullIntracodedFrame).field("ConstantQP_InterPredictedFrame_PrevRefOnly", &self.ConstantQP_InterPredictedFrame_PrevRefOnly).field("ConstantQP_InterPredictedFrame_BiDirectionalRef", &self.ConstantQP_InterPredictedFrame_BiDirectionalRef).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RATE_CONTROL_CQP {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_RATE_CONTROL_CQP {
    fn eq(&self, other: &Self) -> bool {
        self.ConstantQP_FullIntracodedFrame == other.ConstantQP_FullIntracodedFrame && self.ConstantQP_InterPredictedFrame_PrevRefOnly == other.ConstantQP_InterPredictedFrame_PrevRefOnly && self.ConstantQP_InterPredictedFrame_BiDirectionalRef == other.ConstantQP_InterPredictedFrame_BiDirectionalRef
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_RATE_CONTROL_CQP {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RATE_CONTROL_CQP {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR {
    pub InitialQP: u32,
    pub MinQP: u32,
    pub MaxQP: u32,
    pub MaxFrameBitSize: u64,
    pub TargetAvgBitRate: u64,
    pub PeakBitRate: u64,
    pub ConstantQualityTarget: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR").field("InitialQP", &self.InitialQP).field("MinQP", &self.MinQP).field("MaxQP", &self.MaxQP).field("MaxFrameBitSize", &self.MaxFrameBitSize).field("TargetAvgBitRate", &self.TargetAvgBitRate).field("PeakBitRate", &self.PeakBitRate).field("ConstantQualityTarget", &self.ConstantQualityTarget).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR {
    fn eq(&self, other: &Self) -> bool {
        self.InitialQP == other.InitialQP && self.MinQP == other.MinQP && self.MaxQP == other.MaxQP && self.MaxFrameBitSize == other.MaxFrameBitSize && self.TargetAvgBitRate == other.TargetAvgBitRate && self.PeakBitRate == other.PeakBitRate && self.ConstantQualityTarget == other.ConstantQualityTarget
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_RATE_CONTROL_VBR {
    pub InitialQP: u32,
    pub MinQP: u32,
    pub MaxQP: u32,
    pub MaxFrameBitSize: u64,
    pub TargetAvgBitRate: u64,
    pub PeakBitRate: u64,
    pub VBVCapacity: u64,
    pub InitialVBVFullness: u64,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_RATE_CONTROL_VBR {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RATE_CONTROL_VBR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_RATE_CONTROL_VBR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_RATE_CONTROL_VBR").field("InitialQP", &self.InitialQP).field("MinQP", &self.MinQP).field("MaxQP", &self.MaxQP).field("MaxFrameBitSize", &self.MaxFrameBitSize).field("TargetAvgBitRate", &self.TargetAvgBitRate).field("PeakBitRate", &self.PeakBitRate).field("VBVCapacity", &self.VBVCapacity).field("InitialVBVFullness", &self.InitialVBVFullness).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RATE_CONTROL_VBR {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_RATE_CONTROL_VBR {
    fn eq(&self, other: &Self) -> bool {
        self.InitialQP == other.InitialQP && self.MinQP == other.MinQP && self.MaxQP == other.MaxQP && self.MaxFrameBitSize == other.MaxFrameBitSize && self.TargetAvgBitRate == other.TargetAvgBitRate && self.PeakBitRate == other.PeakBitRate && self.VBVCapacity == other.VBVCapacity && self.InitialVBVFullness == other.InitialVBVFullness
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_RATE_CONTROL_VBR {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RATE_CONTROL_VBR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub struct D3D12_VIDEO_ENCODER_RECONSTRUCTED_PICTURE {
    pub pReconstructedPicture: ::std::mem::ManuallyDrop<::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>>,
    pub ReconstructedPictureSubresource: u32,
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RECONSTRUCTED_PICTURE {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_RECONSTRUCTED_PICTURE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_RECONSTRUCTED_PICTURE").field("pReconstructedPicture", &self.pReconstructedPicture).field("ReconstructedPictureSubresource", &self.ReconstructedPictureSubresource).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RECONSTRUCTED_PICTURE {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_RECONSTRUCTED_PICTURE {
    fn eq(&self, other: &Self) -> bool {
        self.pReconstructedPicture == other.pReconstructedPicture && self.ReconstructedPictureSubresource == other.ReconstructedPictureSubresource
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_RECONSTRUCTED_PICTURE {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RECONSTRUCTED_PICTURE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_H264 {
    pub ReconstructedPictureResourceIndex: u32,
    pub IsLongTermReference: super::super::Foundation::BOOL,
    pub LongTermPictureIdx: u32,
    pub PictureOrderCountNumber: u32,
    pub FrameDecodingOrderNumber: u32,
    pub TemporalLayerIndex: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_H264 {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_H264 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_H264 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_H264").field("ReconstructedPictureResourceIndex", &self.ReconstructedPictureResourceIndex).field("IsLongTermReference", &self.IsLongTermReference).field("LongTermPictureIdx", &self.LongTermPictureIdx).field("PictureOrderCountNumber", &self.PictureOrderCountNumber).field("FrameDecodingOrderNumber", &self.FrameDecodingOrderNumber).field("TemporalLayerIndex", &self.TemporalLayerIndex).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_H264 {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_H264 {
    fn eq(&self, other: &Self) -> bool {
        self.ReconstructedPictureResourceIndex == other.ReconstructedPictureResourceIndex && self.IsLongTermReference == other.IsLongTermReference && self.LongTermPictureIdx == other.LongTermPictureIdx && self.PictureOrderCountNumber == other.PictureOrderCountNumber && self.FrameDecodingOrderNumber == other.FrameDecodingOrderNumber && self.TemporalLayerIndex == other.TemporalLayerIndex
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_H264 {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_H264 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_HEVC {
    pub ReconstructedPictureResourceIndex: u32,
    pub IsRefUsedByCurrentPic: super::super::Foundation::BOOL,
    pub IsLongTermReference: super::super::Foundation::BOOL,
    pub PictureOrderCountNumber: u32,
    pub TemporalLayerIndex: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_HEVC {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_HEVC {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_HEVC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_HEVC").field("ReconstructedPictureResourceIndex", &self.ReconstructedPictureResourceIndex).field("IsRefUsedByCurrentPic", &self.IsRefUsedByCurrentPic).field("IsLongTermReference", &self.IsLongTermReference).field("PictureOrderCountNumber", &self.PictureOrderCountNumber).field("TemporalLayerIndex", &self.TemporalLayerIndex).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_HEVC {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_HEVC {
    fn eq(&self, other: &Self) -> bool {
        self.ReconstructedPictureResourceIndex == other.ReconstructedPictureResourceIndex && self.IsRefUsedByCurrentPic == other.IsRefUsedByCurrentPic && self.IsLongTermReference == other.IsLongTermReference && self.PictureOrderCountNumber == other.PictureOrderCountNumber && self.TemporalLayerIndex == other.TemporalLayerIndex
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_HEVC {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_HEVC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub struct D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS {
    pub EncoderCodec: D3D12_VIDEO_ENCODER_CODEC,
    pub EncoderProfile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub EncoderInputFormat: super::super::Graphics::Dxgi::Common::DXGI_FORMAT,
    pub EncodedPictureEffectiveResolution: D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
    pub HWLayoutMetadata: D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER,
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub struct D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS {
    pub ResolvedLayoutMetadata: D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER,
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS").field("ResolvedLayoutMetadata", &self.ResolvedLayoutMetadata).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS {
    fn eq(&self, other: &Self) -> bool {
        self.ResolvedLayoutMetadata == other.ResolvedLayoutMetadata
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
pub struct D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_DESC {
    pub Flags: D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS,
    pub IntraRefreshConfig: D3D12_VIDEO_ENCODER_INTRA_REFRESH,
    pub RateControl: D3D12_VIDEO_ENCODER_RATE_CONTROL,
    pub PictureTargetResolution: D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
    pub SelectedLayoutMode: D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE,
    pub FrameSubregionsLayoutData: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA,
    pub CodecGopSequence: D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE,
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_DESC {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_DESC {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::default::Default for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE {
    pub DataSize: u32,
    pub Anonymous: D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_0,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub union D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_0 {
    pub pH264GroupOfPictures: *mut D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_H264,
    pub pHEVCGroupOfPictures: *mut D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_HEVC,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_0 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_H264 {
    pub GOPLength: u32,
    pub PPicturePeriod: u32,
    pub pic_order_cnt_type: u8,
    pub log2_max_frame_num_minus4: u8,
    pub log2_max_pic_order_cnt_lsb_minus4: u8,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_H264 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_H264 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_H264 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_H264").field("GOPLength", &self.GOPLength).field("PPicturePeriod", &self.PPicturePeriod).field("pic_order_cnt_type", &self.pic_order_cnt_type).field("log2_max_frame_num_minus4", &self.log2_max_frame_num_minus4).field("log2_max_pic_order_cnt_lsb_minus4", &self.log2_max_pic_order_cnt_lsb_minus4).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_H264 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_H264 {
    fn eq(&self, other: &Self) -> bool {
        self.GOPLength == other.GOPLength && self.PPicturePeriod == other.PPicturePeriod && self.pic_order_cnt_type == other.pic_order_cnt_type && self.log2_max_frame_num_minus4 == other.log2_max_frame_num_minus4 && self.log2_max_pic_order_cnt_lsb_minus4 == other.log2_max_pic_order_cnt_lsb_minus4
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_H264 {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_H264 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_HEVC {
    pub GOPLength: u32,
    pub PPicturePeriod: u32,
    pub log2_max_pic_order_cnt_lsb_minus4: u8,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_HEVC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_HEVC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_HEVC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_HEVC").field("GOPLength", &self.GOPLength).field("PPicturePeriod", &self.PPicturePeriod).field("log2_max_pic_order_cnt_lsb_minus4", &self.log2_max_pic_order_cnt_lsb_minus4).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_HEVC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_HEVC {
    fn eq(&self, other: &Self) -> bool {
        self.GOPLength == other.GOPLength && self.PPicturePeriod == other.PPicturePeriod && self.log2_max_pic_order_cnt_lsb_minus4 == other.log2_max_pic_order_cnt_lsb_minus4
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_HEVC {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_HEVC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub struct D3D12_VIDEO_ENCODE_REFERENCE_FRAMES {
    pub NumTexture2Ds: u32,
    pub ppTexture2Ds: *mut ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>,
    pub pSubresources: *mut u32,
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::marker::Copy for D3D12_VIDEO_ENCODE_REFERENCE_FRAMES {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for D3D12_VIDEO_ENCODE_REFERENCE_FRAMES {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODE_REFERENCE_FRAMES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODE_REFERENCE_FRAMES").field("NumTexture2Ds", &self.NumTexture2Ds).field("ppTexture2Ds", &self.ppTexture2Ds).field("pSubresources", &self.pSubresources).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODE_REFERENCE_FRAMES {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODE_REFERENCE_FRAMES {
    fn eq(&self, other: &Self) -> bool {
        self.NumTexture2Ds == other.NumTexture2Ds && self.ppTexture2Ds == other.ppTexture2Ds && self.pSubresources == other.pSubresources
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODE_REFERENCE_FRAMES {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::default::Default for D3D12_VIDEO_ENCODE_REFERENCE_FRAMES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_EXTENSION_COMMAND_DESC {
    pub NodeMask: u32,
    pub CommandId: ::windows::core::GUID,
}
impl ::core::marker::Copy for D3D12_VIDEO_EXTENSION_COMMAND_DESC {}
impl ::core::clone::Clone for D3D12_VIDEO_EXTENSION_COMMAND_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_EXTENSION_COMMAND_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_EXTENSION_COMMAND_DESC").field("NodeMask", &self.NodeMask).field("CommandId", &self.CommandId).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_EXTENSION_COMMAND_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_EXTENSION_COMMAND_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.NodeMask == other.NodeMask && self.CommandId == other.CommandId
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_EXTENSION_COMMAND_DESC {}
impl ::core::default::Default for D3D12_VIDEO_EXTENSION_COMMAND_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub struct D3D12_VIDEO_EXTENSION_COMMAND_INFO {
    pub CommandId: ::windows::core::GUID,
    pub Name: ::windows::core::PCWSTR,
    pub CommandListSupportFlags: super::super::Graphics::Direct3D12::D3D12_COMMAND_LIST_SUPPORT_FLAGS,
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::marker::Copy for D3D12_VIDEO_EXTENSION_COMMAND_INFO {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for D3D12_VIDEO_EXTENSION_COMMAND_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for D3D12_VIDEO_EXTENSION_COMMAND_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_EXTENSION_COMMAND_INFO").field("CommandId", &self.CommandId).field("Name", &self.Name).field("CommandListSupportFlags", &self.CommandListSupportFlags).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::TypeKind for D3D12_VIDEO_EXTENSION_COMMAND_INFO {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_EXTENSION_COMMAND_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.CommandId == other.CommandId && self.Name == other.Name && self.CommandListSupportFlags == other.CommandListSupportFlags
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for D3D12_VIDEO_EXTENSION_COMMAND_INFO {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::default::Default for D3D12_VIDEO_EXTENSION_COMMAND_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO {
    pub Name: ::windows::core::PCWSTR,
    pub Type: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE,
    pub Flags: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS,
}
impl ::core::marker::Copy for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO {}
impl ::core::clone::Clone for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO").field("Name", &self.Name).field("Type", &self.Type).field("Flags", &self.Flags).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Name == other.Name && self.Type == other.Type && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO {}
impl ::core::default::Default for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
pub struct D3D12_VIDEO_FORMAT {
    pub Format: super::super::Graphics::Dxgi::Common::DXGI_FORMAT,
    pub ColorSpace: super::super::Graphics::Dxgi::Common::DXGI_COLOR_SPACE_TYPE,
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::marker::Copy for D3D12_VIDEO_FORMAT {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::clone::Clone for D3D12_VIDEO_FORMAT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::fmt::Debug for D3D12_VIDEO_FORMAT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_FORMAT").field("Format", &self.Format).field("ColorSpace", &self.ColorSpace).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::windows::core::TypeKind for D3D12_VIDEO_FORMAT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_FORMAT {
    fn eq(&self, other: &Self) -> bool {
        self.Format == other.Format && self.ColorSpace == other.ColorSpace
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::Eq for D3D12_VIDEO_FORMAT {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::default::Default for D3D12_VIDEO_FORMAT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
pub struct D3D12_VIDEO_MOTION_ESTIMATOR_DESC {
    pub NodeMask: u32,
    pub InputFormat: super::super::Graphics::Dxgi::Common::DXGI_FORMAT,
    pub BlockSize: D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE,
    pub Precision: D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION,
    pub SizeRange: D3D12_VIDEO_SIZE_RANGE,
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::marker::Copy for D3D12_VIDEO_MOTION_ESTIMATOR_DESC {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::clone::Clone for D3D12_VIDEO_MOTION_ESTIMATOR_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::fmt::Debug for D3D12_VIDEO_MOTION_ESTIMATOR_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_MOTION_ESTIMATOR_DESC").field("NodeMask", &self.NodeMask).field("InputFormat", &self.InputFormat).field("BlockSize", &self.BlockSize).field("Precision", &self.Precision).field("SizeRange", &self.SizeRange).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::windows::core::TypeKind for D3D12_VIDEO_MOTION_ESTIMATOR_DESC {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_MOTION_ESTIMATOR_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.NodeMask == other.NodeMask && self.InputFormat == other.InputFormat && self.BlockSize == other.BlockSize && self.Precision == other.Precision && self.SizeRange == other.SizeRange
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::Eq for D3D12_VIDEO_MOTION_ESTIMATOR_DESC {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::default::Default for D3D12_VIDEO_MOTION_ESTIMATOR_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub struct D3D12_VIDEO_MOTION_ESTIMATOR_INPUT {
    pub pInputTexture2D: ::std::mem::ManuallyDrop<::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>>,
    pub InputSubresourceIndex: u32,
    pub pReferenceTexture2D: ::std::mem::ManuallyDrop<::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>>,
    pub ReferenceSubresourceIndex: u32,
    pub pHintMotionVectorHeap: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12VideoMotionVectorHeap>>,
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for D3D12_VIDEO_MOTION_ESTIMATOR_INPUT {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for D3D12_VIDEO_MOTION_ESTIMATOR_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_MOTION_ESTIMATOR_INPUT").field("pInputTexture2D", &self.pInputTexture2D).field("InputSubresourceIndex", &self.InputSubresourceIndex).field("pReferenceTexture2D", &self.pReferenceTexture2D).field("ReferenceSubresourceIndex", &self.ReferenceSubresourceIndex).field("pHintMotionVectorHeap", &self.pHintMotionVectorHeap).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::TypeKind for D3D12_VIDEO_MOTION_ESTIMATOR_INPUT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_MOTION_ESTIMATOR_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.pInputTexture2D == other.pInputTexture2D && self.InputSubresourceIndex == other.InputSubresourceIndex && self.pReferenceTexture2D == other.pReferenceTexture2D && self.ReferenceSubresourceIndex == other.ReferenceSubresourceIndex && self.pHintMotionVectorHeap == other.pHintMotionVectorHeap
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for D3D12_VIDEO_MOTION_ESTIMATOR_INPUT {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::default::Default for D3D12_VIDEO_MOTION_ESTIMATOR_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub struct D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT {
    pub pMotionVectorHeap: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12VideoMotionVectorHeap>>,
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT").field("pMotionVectorHeap", &self.pMotionVectorHeap).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::TypeKind for D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.pMotionVectorHeap == other.pMotionVectorHeap
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::default::Default for D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
pub struct D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC {
    pub NodeMask: u32,
    pub InputFormat: super::super::Graphics::Dxgi::Common::DXGI_FORMAT,
    pub BlockSize: D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE,
    pub Precision: D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION,
    pub SizeRange: D3D12_VIDEO_SIZE_RANGE,
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::marker::Copy for D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::clone::Clone for D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::fmt::Debug for D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC").field("NodeMask", &self.NodeMask).field("InputFormat", &self.InputFormat).field("BlockSize", &self.BlockSize).field("Precision", &self.Precision).field("SizeRange", &self.SizeRange).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::windows::core::TypeKind for D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.NodeMask == other.NodeMask && self.InputFormat == other.InputFormat && self.BlockSize == other.BlockSize && self.Precision == other.Precision && self.SizeRange == other.SizeRange
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::Eq for D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::default::Default for D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct D3D12_VIDEO_PROCESS_ALPHA_BLENDING {
    pub Enable: super::super::Foundation::BOOL,
    pub Alpha: f32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_ALPHA_BLENDING {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_ALPHA_BLENDING {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_ALPHA_BLENDING {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_ALPHA_BLENDING").field("Enable", &self.Enable).field("Alpha", &self.Alpha).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_ALPHA_BLENDING {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_ALPHA_BLENDING {
    fn eq(&self, other: &Self) -> bool {
        self.Enable == other.Enable && self.Alpha == other.Alpha
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_ALPHA_BLENDING {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for D3D12_VIDEO_PROCESS_ALPHA_BLENDING {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_PROCESS_FILTER_RANGE {
    pub Minimum: i32,
    pub Maximum: i32,
    pub Default: i32,
    pub Multiplier: f32,
}
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_FILTER_RANGE {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_FILTER_RANGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_FILTER_RANGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_FILTER_RANGE").field("Minimum", &self.Minimum).field("Maximum", &self.Maximum).field("Default", &self.Default).field("Multiplier", &self.Multiplier).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_FILTER_RANGE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_FILTER_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.Minimum == other.Minimum && self.Maximum == other.Maximum && self.Default == other.Default && self.Multiplier == other.Multiplier
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_FILTER_RANGE {}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_FILTER_RANGE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub struct D3D12_VIDEO_PROCESS_INPUT_STREAM {
    pub pTexture2D: ::std::mem::ManuallyDrop<::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>>,
    pub Subresource: u32,
    pub ReferenceSet: D3D12_VIDEO_PROCESS_REFERENCE_SET,
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_INPUT_STREAM {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_INPUT_STREAM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_INPUT_STREAM").field("pTexture2D", &self.pTexture2D).field("Subresource", &self.Subresource).field("ReferenceSet", &self.ReferenceSet).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_INPUT_STREAM {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_INPUT_STREAM {
    fn eq(&self, other: &Self) -> bool {
        self.pTexture2D == other.pTexture2D && self.Subresource == other.Subresource && self.ReferenceSet == other.ReferenceSet
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_INPUT_STREAM {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::default::Default for D3D12_VIDEO_PROCESS_INPUT_STREAM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
pub struct D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS {
    pub InputStream: [D3D12_VIDEO_PROCESS_INPUT_STREAM; 2],
    pub Transform: D3D12_VIDEO_PROCESS_TRANSFORM,
    pub Flags: D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS,
    pub RateInfo: D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE,
    pub FilterLevels: [i32; 32],
    pub AlphaBlending: D3D12_VIDEO_PROCESS_ALPHA_BLENDING,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS").field("InputStream", &self.InputStream).field("Transform", &self.Transform).field("Flags", &self.Flags).field("RateInfo", &self.RateInfo).field("FilterLevels", &self.FilterLevels).field("AlphaBlending", &self.AlphaBlending).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS {
    fn eq(&self, other: &Self) -> bool {
        self.InputStream == other.InputStream && self.Transform == other.Transform && self.Flags == other.Flags && self.RateInfo == other.RateInfo && self.FilterLevels == other.FilterLevels && self.AlphaBlending == other.AlphaBlending
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ::core::default::Default for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
pub struct D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1 {
    pub InputStream: [D3D12_VIDEO_PROCESS_INPUT_STREAM; 2],
    pub Transform: D3D12_VIDEO_PROCESS_TRANSFORM,
    pub Flags: D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS,
    pub RateInfo: D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE,
    pub FilterLevels: [i32; 32],
    pub AlphaBlending: D3D12_VIDEO_PROCESS_ALPHA_BLENDING,
    pub FieldType: D3D12_VIDEO_FIELD_TYPE,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1 {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1").field("InputStream", &self.InputStream).field("Transform", &self.Transform).field("Flags", &self.Flags).field("RateInfo", &self.RateInfo).field("FilterLevels", &self.FilterLevels).field("AlphaBlending", &self.AlphaBlending).field("FieldType", &self.FieldType).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1 {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1 {
    fn eq(&self, other: &Self) -> bool {
        self.InputStream == other.InputStream && self.Transform == other.Transform && self.Flags == other.Flags && self.RateInfo == other.RateInfo && self.FilterLevels == other.FilterLevels && self.AlphaBlending == other.AlphaBlending && self.FieldType == other.FieldType
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1 {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ::core::default::Default for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
pub struct D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC {
    pub Format: super::super::Graphics::Dxgi::Common::DXGI_FORMAT,
    pub ColorSpace: super::super::Graphics::Dxgi::Common::DXGI_COLOR_SPACE_TYPE,
    pub SourceAspectRatio: super::super::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub DestinationAspectRatio: super::super::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub FrameRate: super::super::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub SourceSizeRange: D3D12_VIDEO_SIZE_RANGE,
    pub DestinationSizeRange: D3D12_VIDEO_SIZE_RANGE,
    pub EnableOrientation: super::super::Foundation::BOOL,
    pub FilterFlags: D3D12_VIDEO_PROCESS_FILTER_FLAGS,
    pub StereoFormat: D3D12_VIDEO_FRAME_STEREO_FORMAT,
    pub FieldType: D3D12_VIDEO_FIELD_TYPE,
    pub DeinterlaceMode: D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS,
    pub EnableAlphaBlending: super::super::Foundation::BOOL,
    pub LumaKey: D3D12_VIDEO_PROCESS_LUMA_KEY,
    pub NumPastFrames: u32,
    pub NumFutureFrames: u32,
    pub EnableAutoProcessing: super::super::Foundation::BOOL,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC")
            .field("Format", &self.Format)
            .field("ColorSpace", &self.ColorSpace)
            .field("SourceAspectRatio", &self.SourceAspectRatio)
            .field("DestinationAspectRatio", &self.DestinationAspectRatio)
            .field("FrameRate", &self.FrameRate)
            .field("SourceSizeRange", &self.SourceSizeRange)
            .field("DestinationSizeRange", &self.DestinationSizeRange)
            .field("EnableOrientation", &self.EnableOrientation)
            .field("FilterFlags", &self.FilterFlags)
            .field("StereoFormat", &self.StereoFormat)
            .field("FieldType", &self.FieldType)
            .field("DeinterlaceMode", &self.DeinterlaceMode)
            .field("EnableAlphaBlending", &self.EnableAlphaBlending)
            .field("LumaKey", &self.LumaKey)
            .field("NumPastFrames", &self.NumPastFrames)
            .field("NumFutureFrames", &self.NumFutureFrames)
            .field("EnableAutoProcessing", &self.EnableAutoProcessing)
            .finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Format == other.Format
            && self.ColorSpace == other.ColorSpace
            && self.SourceAspectRatio == other.SourceAspectRatio
            && self.DestinationAspectRatio == other.DestinationAspectRatio
            && self.FrameRate == other.FrameRate
            && self.SourceSizeRange == other.SourceSizeRange
            && self.DestinationSizeRange == other.DestinationSizeRange
            && self.EnableOrientation == other.EnableOrientation
            && self.FilterFlags == other.FilterFlags
            && self.StereoFormat == other.StereoFormat
            && self.FieldType == other.FieldType
            && self.DeinterlaceMode == other.DeinterlaceMode
            && self.EnableAlphaBlending == other.EnableAlphaBlending
            && self.LumaKey == other.LumaKey
            && self.NumPastFrames == other.NumPastFrames
            && self.NumFutureFrames == other.NumFutureFrames
            && self.EnableAutoProcessing == other.EnableAutoProcessing
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::default::Default for D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE {
    pub OutputIndex: u32,
    pub InputFrameOrField: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE").field("OutputIndex", &self.OutputIndex).field("InputFrameOrField", &self.InputFrameOrField).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE {
    fn eq(&self, other: &Self) -> bool {
        self.OutputIndex == other.OutputIndex && self.InputFrameOrField == other.InputFrameOrField
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE {}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct D3D12_VIDEO_PROCESS_LUMA_KEY {
    pub Enable: super::super::Foundation::BOOL,
    pub Lower: f32,
    pub Upper: f32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_LUMA_KEY {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_LUMA_KEY {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_LUMA_KEY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_LUMA_KEY").field("Enable", &self.Enable).field("Lower", &self.Lower).field("Upper", &self.Upper).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_LUMA_KEY {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_LUMA_KEY {
    fn eq(&self, other: &Self) -> bool {
        self.Enable == other.Enable && self.Lower == other.Lower && self.Upper == other.Upper
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_LUMA_KEY {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for D3D12_VIDEO_PROCESS_LUMA_KEY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub struct D3D12_VIDEO_PROCESS_OUTPUT_STREAM {
    pub pTexture2D: ::std::mem::ManuallyDrop<::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>>,
    pub Subresource: u32,
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_OUTPUT_STREAM {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_OUTPUT_STREAM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_OUTPUT_STREAM").field("pTexture2D", &self.pTexture2D).field("Subresource", &self.Subresource).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_OUTPUT_STREAM {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_OUTPUT_STREAM {
    fn eq(&self, other: &Self) -> bool {
        self.pTexture2D == other.pTexture2D && self.Subresource == other.Subresource
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_OUTPUT_STREAM {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::default::Default for D3D12_VIDEO_PROCESS_OUTPUT_STREAM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
pub struct D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS {
    pub OutputStream: [D3D12_VIDEO_PROCESS_OUTPUT_STREAM; 2],
    pub TargetRectangle: super::super::Foundation::RECT,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS").field("OutputStream", &self.OutputStream).field("TargetRectangle", &self.TargetRectangle).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS {
    fn eq(&self, other: &Self) -> bool {
        self.OutputStream == other.OutputStream && self.TargetRectangle == other.TargetRectangle
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ::core::default::Default for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
pub struct D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC {
    pub Format: super::super::Graphics::Dxgi::Common::DXGI_FORMAT,
    pub ColorSpace: super::super::Graphics::Dxgi::Common::DXGI_COLOR_SPACE_TYPE,
    pub AlphaFillMode: D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE,
    pub AlphaFillModeSourceStreamIndex: u32,
    pub BackgroundColor: [f32; 4],
    pub FrameRate: super::super::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub EnableStereo: super::super::Foundation::BOOL,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC").field("Format", &self.Format).field("ColorSpace", &self.ColorSpace).field("AlphaFillMode", &self.AlphaFillMode).field("AlphaFillModeSourceStreamIndex", &self.AlphaFillModeSourceStreamIndex).field("BackgroundColor", &self.BackgroundColor).field("FrameRate", &self.FrameRate).field("EnableStereo", &self.EnableStereo).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Format == other.Format && self.ColorSpace == other.ColorSpace && self.AlphaFillMode == other.AlphaFillMode && self.AlphaFillModeSourceStreamIndex == other.AlphaFillModeSourceStreamIndex && self.BackgroundColor == other.BackgroundColor && self.FrameRate == other.FrameRate && self.EnableStereo == other.EnableStereo
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ::core::default::Default for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D12\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub struct D3D12_VIDEO_PROCESS_REFERENCE_SET {
    pub NumPastFrames: u32,
    pub ppPastFrames: *mut ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>,
    pub pPastSubresources: *mut u32,
    pub NumFutureFrames: u32,
    pub ppFutureFrames: *mut ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>,
    pub pFutureSubresources: *mut u32,
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_REFERENCE_SET {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_REFERENCE_SET {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_REFERENCE_SET {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_REFERENCE_SET").field("NumPastFrames", &self.NumPastFrames).field("ppPastFrames", &self.ppPastFrames).field("pPastSubresources", &self.pPastSubresources).field("NumFutureFrames", &self.NumFutureFrames).field("ppFutureFrames", &self.ppFutureFrames).field("pFutureSubresources", &self.pFutureSubresources).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_REFERENCE_SET {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_REFERENCE_SET {
    fn eq(&self, other: &Self) -> bool {
        self.NumPastFrames == other.NumPastFrames && self.ppPastFrames == other.ppPastFrames && self.pPastSubresources == other.pPastSubresources && self.NumFutureFrames == other.NumFutureFrames && self.ppFutureFrames == other.ppFutureFrames && self.pFutureSubresources == other.pFutureSubresources
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_REFERENCE_SET {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::core::default::Default for D3D12_VIDEO_PROCESS_REFERENCE_SET {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct D3D12_VIDEO_PROCESS_TRANSFORM {
    pub SourceRectangle: super::super::Foundation::RECT,
    pub DestinationRectangle: super::super::Foundation::RECT,
    pub Orientation: D3D12_VIDEO_PROCESS_ORIENTATION,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_TRANSFORM {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_TRANSFORM {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_TRANSFORM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_TRANSFORM").field("SourceRectangle", &self.SourceRectangle).field("DestinationRectangle", &self.DestinationRectangle).field("Orientation", &self.Orientation).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_TRANSFORM {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_TRANSFORM {
    fn eq(&self, other: &Self) -> bool {
        self.SourceRectangle == other.SourceRectangle && self.DestinationRectangle == other.DestinationRectangle && self.Orientation == other.Orientation
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_TRANSFORM {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for D3D12_VIDEO_PROCESS_TRANSFORM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Dxgi_Common\"`*"]
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
pub struct D3D12_VIDEO_SAMPLE {
    pub Width: u32,
    pub Height: u32,
    pub Format: D3D12_VIDEO_FORMAT,
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::marker::Copy for D3D12_VIDEO_SAMPLE {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::clone::Clone for D3D12_VIDEO_SAMPLE {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::fmt::Debug for D3D12_VIDEO_SAMPLE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_SAMPLE").field("Width", &self.Width).field("Height", &self.Height).field("Format", &self.Format).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::windows::core::TypeKind for D3D12_VIDEO_SAMPLE {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::PartialEq for D3D12_VIDEO_SAMPLE {
    fn eq(&self, other: &Self) -> bool {
        self.Width == other.Width && self.Height == other.Height && self.Format == other.Format
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::cmp::Eq for D3D12_VIDEO_SAMPLE {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ::core::default::Default for D3D12_VIDEO_SAMPLE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_SCALE_SUPPORT {
    pub OutputSizeRange: D3D12_VIDEO_SIZE_RANGE,
    pub Flags: D3D12_VIDEO_SCALE_SUPPORT_FLAGS,
}
impl ::core::marker::Copy for D3D12_VIDEO_SCALE_SUPPORT {}
impl ::core::clone::Clone for D3D12_VIDEO_SCALE_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_SCALE_SUPPORT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_SCALE_SUPPORT").field("OutputSizeRange", &self.OutputSizeRange).field("Flags", &self.Flags).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_SCALE_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_SCALE_SUPPORT {
    fn eq(&self, other: &Self) -> bool {
        self.OutputSizeRange == other.OutputSizeRange && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_SCALE_SUPPORT {}
impl ::core::default::Default for D3D12_VIDEO_SCALE_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3D12_VIDEO_SIZE_RANGE {
    pub MaxWidth: u32,
    pub MaxHeight: u32,
    pub MinWidth: u32,
    pub MinHeight: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_SIZE_RANGE {}
impl ::core::clone::Clone for D3D12_VIDEO_SIZE_RANGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_SIZE_RANGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_SIZE_RANGE").field("MaxWidth", &self.MaxWidth).field("MaxHeight", &self.MaxHeight).field("MinWidth", &self.MinWidth).field("MinHeight", &self.MinHeight).finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_SIZE_RANGE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_SIZE_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.MaxWidth == other.MaxWidth && self.MaxHeight == other.MaxHeight && self.MinWidth == other.MinWidth && self.MinHeight == other.MinHeight
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_SIZE_RANGE {}
impl ::core::default::Default for D3D12_VIDEO_SIZE_RANGE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
pub struct D3DCONTENTPROTECTIONCAPS {
    pub Caps: u32,
    pub KeyExchangeType: ::windows::core::GUID,
    pub BufferAlignmentStart: u32,
    pub BlockAlignmentSize: u32,
    pub ProtectedMemorySize: u64,
}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
impl ::core::marker::Copy for D3DCONTENTPROTECTIONCAPS {}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
impl ::core::clone::Clone for D3DCONTENTPROTECTIONCAPS {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
impl ::windows::core::TypeKind for D3DCONTENTPROTECTIONCAPS {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
impl ::core::default::Default for D3DCONTENTPROTECTIONCAPS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
#[cfg(target_arch = "x86")]
pub struct D3DCONTENTPROTECTIONCAPS {
    pub Caps: u32,
    pub KeyExchangeType: ::windows::core::GUID,
    pub BufferAlignmentStart: u32,
    pub BlockAlignmentSize: u32,
    pub ProtectedMemorySize: u64,
}
#[cfg(target_arch = "x86")]
impl ::core::marker::Copy for D3DCONTENTPROTECTIONCAPS {}
#[cfg(target_arch = "x86")]
impl ::core::clone::Clone for D3DCONTENTPROTECTIONCAPS {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(target_arch = "x86")]
impl ::windows::core::TypeKind for D3DCONTENTPROTECTIONCAPS {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(target_arch = "x86")]
impl ::core::default::Default for D3DCONTENTPROTECTIONCAPS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct D3DOVERLAYCAPS {
    pub Caps: u32,
    pub MaxOverlayDisplayWidth: u32,
    pub MaxOverlayDisplayHeight: u32,
}
impl ::core::marker::Copy for D3DOVERLAYCAPS {}
impl ::core::clone::Clone for D3DOVERLAYCAPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3DOVERLAYCAPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3DOVERLAYCAPS").field("Caps", &self.Caps).field("MaxOverlayDisplayWidth", &self.MaxOverlayDisplayWidth).field("MaxOverlayDisplayHeight", &self.MaxOverlayDisplayHeight).finish()
    }
}
impl ::windows::core::TypeKind for D3DOVERLAYCAPS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3DOVERLAYCAPS {
    fn eq(&self, other: &Self) -> bool {
        self.Caps == other.Caps && self.MaxOverlayDisplayWidth == other.MaxOverlayDisplayWidth && self.MaxOverlayDisplayHeight == other.MaxOverlayDisplayHeight
    }
}
impl ::core::cmp::Eq for D3DOVERLAYCAPS {}
impl ::core::default::Default for D3DOVERLAYCAPS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DEVICE_INFO {
    pub pFriendlyDeviceName: ::std::mem::ManuallyDrop<::windows::core::BSTR>,
    pub pUniqueDeviceName: ::std::mem::ManuallyDrop<::windows::core::BSTR>,
    pub pManufacturerName: ::std::mem::ManuallyDrop<::windows::core::BSTR>,
    pub pModelName: ::std::mem::ManuallyDrop<::windows::core::BSTR>,
    pub pIconURL: ::std::mem::ManuallyDrop<::windows::core::BSTR>,
}
impl ::core::clone::Clone for DEVICE_INFO {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for DEVICE_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DEVICE_INFO").field("pFriendlyDeviceName", &self.pFriendlyDeviceName).field("pUniqueDeviceName", &self.pUniqueDeviceName).field("pManufacturerName", &self.pManufacturerName).field("pModelName", &self.pModelName).field("pIconURL", &self.pIconURL).finish()
    }
}
impl ::windows::core::TypeKind for DEVICE_INFO {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DEVICE_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.pFriendlyDeviceName == other.pFriendlyDeviceName && self.pUniqueDeviceName == other.pUniqueDeviceName && self.pManufacturerName == other.pManufacturerName && self.pModelName == other.pModelName && self.pIconURL == other.pIconURL
    }
}
impl ::core::cmp::Eq for DEVICE_INFO {}
impl ::core::default::Default for DEVICE_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct DIRTYRECT_INFO {
    pub FrameNumber: u32,
    pub NumDirtyRects: u32,
    pub DirtyRects: [super::super::Foundation::RECT; 1],
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DIRTYRECT_INFO {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DIRTYRECT_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DIRTYRECT_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DIRTYRECT_INFO").field("FrameNumber", &self.FrameNumber).field("NumDirtyRects", &self.NumDirtyRects).field("DirtyRects", &self.DirtyRects).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for DIRTYRECT_INFO {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DIRTYRECT_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.FrameNumber == other.FrameNumber && self.NumDirtyRects == other.NumDirtyRects && self.DirtyRects == other.DirtyRects
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DIRTYRECT_INFO {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DIRTYRECT_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA2_AES_CTR_IV {
    pub IV: u64,
    pub Count: u64,
}
impl ::core::marker::Copy for DXVA2_AES_CTR_IV {}
impl ::core::clone::Clone for DXVA2_AES_CTR_IV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVA2_AES_CTR_IV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA2_AES_CTR_IV").field("IV", &self.IV).field("Count", &self.Count).finish()
    }
}
impl ::windows::core::TypeKind for DXVA2_AES_CTR_IV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVA2_AES_CTR_IV {
    fn eq(&self, other: &Self) -> bool {
        self.IV == other.IV && self.Count == other.Count
    }
}
impl ::core::cmp::Eq for DXVA2_AES_CTR_IV {}
impl ::core::default::Default for DXVA2_AES_CTR_IV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA2_AYUVSample16 {
    pub Cr: u16,
    pub Cb: u16,
    pub Y: u16,
    pub Alpha: u16,
}
impl ::core::marker::Copy for DXVA2_AYUVSample16 {}
impl ::core::clone::Clone for DXVA2_AYUVSample16 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVA2_AYUVSample16 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA2_AYUVSample16").field("Cr", &self.Cr).field("Cb", &self.Cb).field("Y", &self.Y).field("Alpha", &self.Alpha).finish()
    }
}
impl ::windows::core::TypeKind for DXVA2_AYUVSample16 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVA2_AYUVSample16 {
    fn eq(&self, other: &Self) -> bool {
        self.Cr == other.Cr && self.Cb == other.Cb && self.Y == other.Y && self.Alpha == other.Alpha
    }
}
impl ::core::cmp::Eq for DXVA2_AYUVSample16 {}
impl ::core::default::Default for DXVA2_AYUVSample16 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA2_AYUVSample8 {
    pub Cr: u8,
    pub Cb: u8,
    pub Y: u8,
    pub Alpha: u8,
}
impl ::core::marker::Copy for DXVA2_AYUVSample8 {}
impl ::core::clone::Clone for DXVA2_AYUVSample8 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVA2_AYUVSample8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA2_AYUVSample8").field("Cr", &self.Cr).field("Cb", &self.Cb).field("Y", &self.Y).field("Alpha", &self.Alpha).finish()
    }
}
impl ::windows::core::TypeKind for DXVA2_AYUVSample8 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVA2_AYUVSample8 {
    fn eq(&self, other: &Self) -> bool {
        self.Cr == other.Cr && self.Cb == other.Cb && self.Y == other.Y && self.Alpha == other.Alpha
    }
}
impl ::core::cmp::Eq for DXVA2_AYUVSample8 {}
impl ::core::default::Default for DXVA2_AYUVSample8 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA2_ConfigPictureDecode {
    pub guidConfigBitstreamEncryption: ::windows::core::GUID,
    pub guidConfigMBcontrolEncryption: ::windows::core::GUID,
    pub guidConfigResidDiffEncryption: ::windows::core::GUID,
    pub ConfigBitstreamRaw: u32,
    pub ConfigMBcontrolRasterOrder: u32,
    pub ConfigResidDiffHost: u32,
    pub ConfigSpatialResid8: u32,
    pub ConfigResid8Subtraction: u32,
    pub ConfigSpatialHost8or9Clipping: u32,
    pub ConfigSpatialResidInterleaved: u32,
    pub ConfigIntraResidUnsigned: u32,
    pub ConfigResidDiffAccelerator: u32,
    pub ConfigHostInverseScan: u32,
    pub ConfigSpecificIDCT: u32,
    pub Config4GroupedCoefs: u32,
    pub ConfigMinRenderTargetBuffCount: u16,
    pub ConfigDecoderSpecific: u16,
}
impl ::core::marker::Copy for DXVA2_ConfigPictureDecode {}
impl ::core::clone::Clone for DXVA2_ConfigPictureDecode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVA2_ConfigPictureDecode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA2_ConfigPictureDecode")
            .field("guidConfigBitstreamEncryption", &self.guidConfigBitstreamEncryption)
            .field("guidConfigMBcontrolEncryption", &self.guidConfigMBcontrolEncryption)
            .field("guidConfigResidDiffEncryption", &self.guidConfigResidDiffEncryption)
            .field("ConfigBitstreamRaw", &self.ConfigBitstreamRaw)
            .field("ConfigMBcontrolRasterOrder", &self.ConfigMBcontrolRasterOrder)
            .field("ConfigResidDiffHost", &self.ConfigResidDiffHost)
            .field("ConfigSpatialResid8", &self.ConfigSpatialResid8)
            .field("ConfigResid8Subtraction", &self.ConfigResid8Subtraction)
            .field("ConfigSpatialHost8or9Clipping", &self.ConfigSpatialHost8or9Clipping)
            .field("ConfigSpatialResidInterleaved", &self.ConfigSpatialResidInterleaved)
            .field("ConfigIntraResidUnsigned", &self.ConfigIntraResidUnsigned)
            .field("ConfigResidDiffAccelerator", &self.ConfigResidDiffAccelerator)
            .field("ConfigHostInverseScan", &self.ConfigHostInverseScan)
            .field("ConfigSpecificIDCT", &self.ConfigSpecificIDCT)
            .field("Config4GroupedCoefs", &self.Config4GroupedCoefs)
            .field("ConfigMinRenderTargetBuffCount", &self.ConfigMinRenderTargetBuffCount)
            .field("ConfigDecoderSpecific", &self.ConfigDecoderSpecific)
            .finish()
    }
}
impl ::windows::core::TypeKind for DXVA2_ConfigPictureDecode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVA2_ConfigPictureDecode {
    fn eq(&self, other: &Self) -> bool {
        self.guidConfigBitstreamEncryption == other.guidConfigBitstreamEncryption
            && self.guidConfigMBcontrolEncryption == other.guidConfigMBcontrolEncryption
            && self.guidConfigResidDiffEncryption == other.guidConfigResidDiffEncryption
            && self.ConfigBitstreamRaw == other.ConfigBitstreamRaw
            && self.ConfigMBcontrolRasterOrder == other.ConfigMBcontrolRasterOrder
            && self.ConfigResidDiffHost == other.ConfigResidDiffHost
            && self.ConfigSpatialResid8 == other.ConfigSpatialResid8
            && self.ConfigResid8Subtraction == other.ConfigResid8Subtraction
            && self.ConfigSpatialHost8or9Clipping == other.ConfigSpatialHost8or9Clipping
            && self.ConfigSpatialResidInterleaved == other.ConfigSpatialResidInterleaved
            && self.ConfigIntraResidUnsigned == other.ConfigIntraResidUnsigned
            && self.ConfigResidDiffAccelerator == other.ConfigResidDiffAccelerator
            && self.ConfigHostInverseScan == other.ConfigHostInverseScan
            && self.ConfigSpecificIDCT == other.ConfigSpecificIDCT
            && self.Config4GroupedCoefs == other.Config4GroupedCoefs
            && self.ConfigMinRenderTargetBuffCount == other.ConfigMinRenderTargetBuffCount
            && self.ConfigDecoderSpecific == other.ConfigDecoderSpecific
    }
}
impl ::core::cmp::Eq for DXVA2_ConfigPictureDecode {}
impl ::core::default::Default for DXVA2_ConfigPictureDecode {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA2_DecodeBufferDesc {
    pub CompressedBufferType: DXVA2_BufferfType,
    pub BufferIndex: u32,
    pub DataOffset: u32,
    pub DataSize: u32,
    pub FirstMBaddress: u32,
    pub NumMBsInBuffer: u32,
    pub Width: u32,
    pub Height: u32,
    pub Stride: u32,
    pub ReservedBits: u32,
    pub pvPVPState: *mut ::core::ffi::c_void,
}
impl ::core::marker::Copy for DXVA2_DecodeBufferDesc {}
impl ::core::clone::Clone for DXVA2_DecodeBufferDesc {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVA2_DecodeBufferDesc {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA2_DecodeBufferDesc").field("CompressedBufferType", &self.CompressedBufferType).field("BufferIndex", &self.BufferIndex).field("DataOffset", &self.DataOffset).field("DataSize", &self.DataSize).field("FirstMBaddress", &self.FirstMBaddress).field("NumMBsInBuffer", &self.NumMBsInBuffer).field("Width", &self.Width).field("Height", &self.Height).field("Stride", &self.Stride).field("ReservedBits", &self.ReservedBits).field("pvPVPState", &self.pvPVPState).finish()
    }
}
impl ::windows::core::TypeKind for DXVA2_DecodeBufferDesc {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVA2_DecodeBufferDesc {
    fn eq(&self, other: &Self) -> bool {
        self.CompressedBufferType == other.CompressedBufferType && self.BufferIndex == other.BufferIndex && self.DataOffset == other.DataOffset && self.DataSize == other.DataSize && self.FirstMBaddress == other.FirstMBaddress && self.NumMBsInBuffer == other.NumMBsInBuffer && self.Width == other.Width && self.Height == other.Height && self.Stride == other.Stride && self.ReservedBits == other.ReservedBits && self.pvPVPState == other.pvPVPState
    }
}
impl ::core::cmp::Eq for DXVA2_DecodeBufferDesc {}
impl ::core::default::Default for DXVA2_DecodeBufferDesc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA2_DecodeExecuteParams {
    pub NumCompBuffers: u32,
    pub pCompressedBuffers: *mut DXVA2_DecodeBufferDesc,
    pub pExtensionData: *mut DXVA2_DecodeExtensionData,
}
impl ::core::marker::Copy for DXVA2_DecodeExecuteParams {}
impl ::core::clone::Clone for DXVA2_DecodeExecuteParams {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVA2_DecodeExecuteParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA2_DecodeExecuteParams").field("NumCompBuffers", &self.NumCompBuffers).field("pCompressedBuffers", &self.pCompressedBuffers).field("pExtensionData", &self.pExtensionData).finish()
    }
}
impl ::windows::core::TypeKind for DXVA2_DecodeExecuteParams {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVA2_DecodeExecuteParams {
    fn eq(&self, other: &Self) -> bool {
        self.NumCompBuffers == other.NumCompBuffers && self.pCompressedBuffers == other.pCompressedBuffers && self.pExtensionData == other.pExtensionData
    }
}
impl ::core::cmp::Eq for DXVA2_DecodeExecuteParams {}
impl ::core::default::Default for DXVA2_DecodeExecuteParams {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA2_DecodeExtensionData {
    pub Function: u32,
    pub pPrivateInputData: *mut ::core::ffi::c_void,
    pub PrivateInputDataSize: u32,
    pub pPrivateOutputData: *mut ::core::ffi::c_void,
    pub PrivateOutputDataSize: u32,
}
impl ::core::marker::Copy for DXVA2_DecodeExtensionData {}
impl ::core::clone::Clone for DXVA2_DecodeExtensionData {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVA2_DecodeExtensionData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA2_DecodeExtensionData").field("Function", &self.Function).field("pPrivateInputData", &self.pPrivateInputData).field("PrivateInputDataSize", &self.PrivateInputDataSize).field("pPrivateOutputData", &self.pPrivateOutputData).field("PrivateOutputDataSize", &self.PrivateOutputDataSize).finish()
    }
}
impl ::windows::core::TypeKind for DXVA2_DecodeExtensionData {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVA2_DecodeExtensionData {
    fn eq(&self, other: &Self) -> bool {
        self.Function == other.Function && self.pPrivateInputData == other.pPrivateInputData && self.PrivateInputDataSize == other.PrivateInputDataSize && self.pPrivateOutputData == other.pPrivateOutputData && self.PrivateOutputDataSize == other.PrivateOutputDataSize
    }
}
impl ::core::cmp::Eq for DXVA2_DecodeExtensionData {}
impl ::core::default::Default for DXVA2_DecodeExtensionData {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA2_ExtendedFormat {
    pub Anonymous: DXVA2_ExtendedFormat_0,
}
impl ::core::marker::Copy for DXVA2_ExtendedFormat {}
impl ::core::clone::Clone for DXVA2_ExtendedFormat {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for DXVA2_ExtendedFormat {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for DXVA2_ExtendedFormat {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub union DXVA2_ExtendedFormat_0 {
    pub Anonymous: DXVA2_ExtendedFormat_0_0,
    pub value: u32,
}
impl ::core::marker::Copy for DXVA2_ExtendedFormat_0 {}
impl ::core::clone::Clone for DXVA2_ExtendedFormat_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for DXVA2_ExtendedFormat_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for DXVA2_ExtendedFormat_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA2_ExtendedFormat_0_0 {
    pub _bitfield: u32,
}
impl ::core::marker::Copy for DXVA2_ExtendedFormat_0_0 {}
impl ::core::clone::Clone for DXVA2_ExtendedFormat_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVA2_ExtendedFormat_0_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA2_ExtendedFormat_0_0").field("_bitfield", &self._bitfield).finish()
    }
}
impl ::windows::core::TypeKind for DXVA2_ExtendedFormat_0_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVA2_ExtendedFormat_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::core::cmp::Eq for DXVA2_ExtendedFormat_0_0 {}
impl ::core::default::Default for DXVA2_ExtendedFormat_0_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA2_FilterValues {
    pub Level: DXVA2_Fixed32,
    pub Threshold: DXVA2_Fixed32,
    pub Radius: DXVA2_Fixed32,
}
impl ::core::marker::Copy for DXVA2_FilterValues {}
impl ::core::clone::Clone for DXVA2_FilterValues {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for DXVA2_FilterValues {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for DXVA2_FilterValues {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA2_Fixed32 {
    pub Anonymous: DXVA2_Fixed32_0,
}
impl ::core::marker::Copy for DXVA2_Fixed32 {}
impl ::core::clone::Clone for DXVA2_Fixed32 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for DXVA2_Fixed32 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for DXVA2_Fixed32 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub union DXVA2_Fixed32_0 {
    pub Anonymous: DXVA2_Fixed32_0_0,
    pub ll: i32,
}
impl ::core::marker::Copy for DXVA2_Fixed32_0 {}
impl ::core::clone::Clone for DXVA2_Fixed32_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for DXVA2_Fixed32_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for DXVA2_Fixed32_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA2_Fixed32_0_0 {
    pub Fraction: u16,
    pub Value: i16,
}
impl ::core::marker::Copy for DXVA2_Fixed32_0_0 {}
impl ::core::clone::Clone for DXVA2_Fixed32_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVA2_Fixed32_0_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA2_Fixed32_0_0").field("Fraction", &self.Fraction).field("Value", &self.Value).finish()
    }
}
impl ::windows::core::TypeKind for DXVA2_Fixed32_0_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVA2_Fixed32_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.Fraction == other.Fraction && self.Value == other.Value
    }
}
impl ::core::cmp::Eq for DXVA2_Fixed32_0_0 {}
impl ::core::default::Default for DXVA2_Fixed32_0_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA2_Frequency {
    pub Numerator: u32,
    pub Denominator: u32,
}
impl ::core::marker::Copy for DXVA2_Frequency {}
impl ::core::clone::Clone for DXVA2_Frequency {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVA2_Frequency {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA2_Frequency").field("Numerator", &self.Numerator).field("Denominator", &self.Denominator).finish()
    }
}
impl ::windows::core::TypeKind for DXVA2_Frequency {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVA2_Frequency {
    fn eq(&self, other: &Self) -> bool {
        self.Numerator == other.Numerator && self.Denominator == other.Denominator
    }
}
impl ::core::cmp::Eq for DXVA2_Frequency {}
impl ::core::default::Default for DXVA2_Frequency {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA2_ProcAmpValues {
    pub Brightness: DXVA2_Fixed32,
    pub Contrast: DXVA2_Fixed32,
    pub Hue: DXVA2_Fixed32,
    pub Saturation: DXVA2_Fixed32,
}
impl ::core::marker::Copy for DXVA2_ProcAmpValues {}
impl ::core::clone::Clone for DXVA2_ProcAmpValues {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for DXVA2_ProcAmpValues {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for DXVA2_ProcAmpValues {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA2_ValueRange {
    pub MinValue: DXVA2_Fixed32,
    pub MaxValue: DXVA2_Fixed32,
    pub DefaultValue: DXVA2_Fixed32,
    pub StepSize: DXVA2_Fixed32,
}
impl ::core::marker::Copy for DXVA2_ValueRange {}
impl ::core::clone::Clone for DXVA2_ValueRange {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for DXVA2_ValueRange {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for DXVA2_ValueRange {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct DXVA2_VideoDesc {
    pub SampleWidth: u32,
    pub SampleHeight: u32,
    pub SampleFormat: DXVA2_ExtendedFormat,
    pub Format: super::super::Graphics::Direct3D9::D3DFORMAT,
    pub InputSampleFreq: DXVA2_Frequency,
    pub OutputFrameFreq: DXVA2_Frequency,
    pub UABProtectionLevel: u32,
    pub Reserved: u32,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::marker::Copy for DXVA2_VideoDesc {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::clone::Clone for DXVA2_VideoDesc {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::windows::core::TypeKind for DXVA2_VideoDesc {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::default::Default for DXVA2_VideoDesc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct DXVA2_VideoProcessBltParams {
    pub TargetFrame: i64,
    pub TargetRect: super::super::Foundation::RECT,
    pub ConstrictionSize: super::super::Foundation::SIZE,
    pub StreamingFlags: u32,
    pub BackgroundColor: DXVA2_AYUVSample16,
    pub DestFormat: DXVA2_ExtendedFormat,
    pub ProcAmpValues: DXVA2_ProcAmpValues,
    pub Alpha: DXVA2_Fixed32,
    pub NoiseFilterLuma: DXVA2_FilterValues,
    pub NoiseFilterChroma: DXVA2_FilterValues,
    pub DetailFilterLuma: DXVA2_FilterValues,
    pub DetailFilterChroma: DXVA2_FilterValues,
    pub DestData: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DXVA2_VideoProcessBltParams {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DXVA2_VideoProcessBltParams {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for DXVA2_VideoProcessBltParams {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DXVA2_VideoProcessBltParams {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct DXVA2_VideoProcessorCaps {
    pub DeviceCaps: u32,
    pub InputPool: super::super::Graphics::Direct3D9::D3DPOOL,
    pub NumForwardRefSamples: u32,
    pub NumBackwardRefSamples: u32,
    pub Reserved: u32,
    pub DeinterlaceTechnology: u32,
    pub ProcAmpControlCaps: u32,
    pub VideoProcessorOperations: u32,
    pub NoiseFilterTechnology: u32,
    pub DetailFilterTechnology: u32,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::marker::Copy for DXVA2_VideoProcessorCaps {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::clone::Clone for DXVA2_VideoProcessorCaps {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::fmt::Debug for DXVA2_VideoProcessorCaps {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA2_VideoProcessorCaps")
            .field("DeviceCaps", &self.DeviceCaps)
            .field("InputPool", &self.InputPool)
            .field("NumForwardRefSamples", &self.NumForwardRefSamples)
            .field("NumBackwardRefSamples", &self.NumBackwardRefSamples)
            .field("Reserved", &self.Reserved)
            .field("DeinterlaceTechnology", &self.DeinterlaceTechnology)
            .field("ProcAmpControlCaps", &self.ProcAmpControlCaps)
            .field("VideoProcessorOperations", &self.VideoProcessorOperations)
            .field("NoiseFilterTechnology", &self.NoiseFilterTechnology)
            .field("DetailFilterTechnology", &self.DetailFilterTechnology)
            .finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::windows::core::TypeKind for DXVA2_VideoProcessorCaps {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::cmp::PartialEq for DXVA2_VideoProcessorCaps {
    fn eq(&self, other: &Self) -> bool {
        self.DeviceCaps == other.DeviceCaps && self.InputPool == other.InputPool && self.NumForwardRefSamples == other.NumForwardRefSamples && self.NumBackwardRefSamples == other.NumBackwardRefSamples && self.Reserved == other.Reserved && self.DeinterlaceTechnology == other.DeinterlaceTechnology && self.ProcAmpControlCaps == other.ProcAmpControlCaps && self.VideoProcessorOperations == other.VideoProcessorOperations && self.NoiseFilterTechnology == other.NoiseFilterTechnology && self.DetailFilterTechnology == other.DetailFilterTechnology
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::cmp::Eq for DXVA2_VideoProcessorCaps {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::default::Default for DXVA2_VideoProcessorCaps {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub struct DXVA2_VideoSample {
    pub Start: i64,
    pub End: i64,
    pub SampleFormat: DXVA2_ExtendedFormat,
    pub SrcSurface: ::std::mem::ManuallyDrop<::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>>,
    pub SrcRect: super::super::Foundation::RECT,
    pub DstRect: super::super::Foundation::RECT,
    pub Pal: [DXVA2_AYUVSample8; 16],
    pub PlanarAlpha: DXVA2_Fixed32,
    pub SampleData: u32,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::clone::Clone for DXVA2_VideoSample {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::windows::core::TypeKind for DXVA2_VideoSample {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::default::Default for DXVA2_VideoSample {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVABufferInfo {
    pub pCompSurface: *mut ::core::ffi::c_void,
    pub DataOffset: u32,
    pub DataSize: u32,
}
impl ::core::marker::Copy for DXVABufferInfo {}
impl ::core::clone::Clone for DXVABufferInfo {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVABufferInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVABufferInfo").field("pCompSurface", &self.pCompSurface).field("DataOffset", &self.DataOffset).field("DataSize", &self.DataSize).finish()
    }
}
impl ::windows::core::TypeKind for DXVABufferInfo {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVABufferInfo {
    fn eq(&self, other: &Self) -> bool {
        self.pCompSurface == other.pCompSurface && self.DataOffset == other.DataOffset && self.DataSize == other.DataSize
    }
}
impl ::core::cmp::Eq for DXVABufferInfo {}
impl ::core::default::Default for DXVABufferInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct DXVACompBufferInfo {
    pub NumCompBuffers: u32,
    pub WidthToCreate: u32,
    pub HeightToCreate: u32,
    pub BytesToAllocate: u32,
    pub Usage: u32,
    pub Pool: super::super::Graphics::Direct3D9::D3DPOOL,
    pub Format: super::super::Graphics::Direct3D9::D3DFORMAT,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::marker::Copy for DXVACompBufferInfo {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::clone::Clone for DXVACompBufferInfo {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::fmt::Debug for DXVACompBufferInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVACompBufferInfo").field("NumCompBuffers", &self.NumCompBuffers).field("WidthToCreate", &self.WidthToCreate).field("HeightToCreate", &self.HeightToCreate).field("BytesToAllocate", &self.BytesToAllocate).field("Usage", &self.Usage).field("Pool", &self.Pool).field("Format", &self.Format).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::windows::core::TypeKind for DXVACompBufferInfo {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::cmp::PartialEq for DXVACompBufferInfo {
    fn eq(&self, other: &Self) -> bool {
        self.NumCompBuffers == other.NumCompBuffers && self.WidthToCreate == other.WidthToCreate && self.HeightToCreate == other.HeightToCreate && self.BytesToAllocate == other.BytesToAllocate && self.Usage == other.Usage && self.Pool == other.Pool && self.Format == other.Format
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::cmp::Eq for DXVACompBufferInfo {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::default::Default for DXVACompBufferInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVAHDETW_CREATEVIDEOPROCESSOR {
    pub pObject: u64,
    pub pD3D9Ex: u64,
    pub VPGuid: ::windows::core::GUID,
}
impl ::core::marker::Copy for DXVAHDETW_CREATEVIDEOPROCESSOR {}
impl ::core::clone::Clone for DXVAHDETW_CREATEVIDEOPROCESSOR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVAHDETW_CREATEVIDEOPROCESSOR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHDETW_CREATEVIDEOPROCESSOR").field("pObject", &self.pObject).field("pD3D9Ex", &self.pD3D9Ex).field("VPGuid", &self.VPGuid).finish()
    }
}
impl ::windows::core::TypeKind for DXVAHDETW_CREATEVIDEOPROCESSOR {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVAHDETW_CREATEVIDEOPROCESSOR {
    fn eq(&self, other: &Self) -> bool {
        self.pObject == other.pObject && self.pD3D9Ex == other.pD3D9Ex && self.VPGuid == other.VPGuid
    }
}
impl ::core::cmp::Eq for DXVAHDETW_CREATEVIDEOPROCESSOR {}
impl ::core::default::Default for DXVAHDETW_CREATEVIDEOPROCESSOR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVAHDETW_DESTROYVIDEOPROCESSOR {
    pub pObject: u64,
}
impl ::core::marker::Copy for DXVAHDETW_DESTROYVIDEOPROCESSOR {}
impl ::core::clone::Clone for DXVAHDETW_DESTROYVIDEOPROCESSOR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVAHDETW_DESTROYVIDEOPROCESSOR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHDETW_DESTROYVIDEOPROCESSOR").field("pObject", &self.pObject).finish()
    }
}
impl ::windows::core::TypeKind for DXVAHDETW_DESTROYVIDEOPROCESSOR {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVAHDETW_DESTROYVIDEOPROCESSOR {
    fn eq(&self, other: &Self) -> bool {
        self.pObject == other.pObject
    }
}
impl ::core::cmp::Eq for DXVAHDETW_DESTROYVIDEOPROCESSOR {}
impl ::core::default::Default for DXVAHDETW_DESTROYVIDEOPROCESSOR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub struct DXVAHDETW_VIDEOPROCESSBLTHD {
    pub pObject: u64,
    pub pOutputSurface: u64,
    pub TargetRect: super::super::Foundation::RECT,
    pub OutputFormat: super::super::Graphics::Direct3D9::D3DFORMAT,
    pub ColorSpace: u32,
    pub OutputFrame: u32,
    pub StreamCount: u32,
    pub Enter: super::super::Foundation::BOOL,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::marker::Copy for DXVAHDETW_VIDEOPROCESSBLTHD {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::clone::Clone for DXVAHDETW_VIDEOPROCESSBLTHD {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::fmt::Debug for DXVAHDETW_VIDEOPROCESSBLTHD {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHDETW_VIDEOPROCESSBLTHD").field("pObject", &self.pObject).field("pOutputSurface", &self.pOutputSurface).field("TargetRect", &self.TargetRect).field("OutputFormat", &self.OutputFormat).field("ColorSpace", &self.ColorSpace).field("OutputFrame", &self.OutputFrame).field("StreamCount", &self.StreamCount).field("Enter", &self.Enter).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::windows::core::TypeKind for DXVAHDETW_VIDEOPROCESSBLTHD {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::cmp::PartialEq for DXVAHDETW_VIDEOPROCESSBLTHD {
    fn eq(&self, other: &Self) -> bool {
        self.pObject == other.pObject && self.pOutputSurface == other.pOutputSurface && self.TargetRect == other.TargetRect && self.OutputFormat == other.OutputFormat && self.ColorSpace == other.ColorSpace && self.OutputFrame == other.OutputFrame && self.StreamCount == other.StreamCount && self.Enter == other.Enter
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::cmp::Eq for DXVAHDETW_VIDEOPROCESSBLTHD {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::default::Default for DXVAHDETW_VIDEOPROCESSBLTHD {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub struct DXVAHDETW_VIDEOPROCESSBLTHD_STREAM {
    pub pObject: u64,
    pub pInputSurface: u64,
    pub SourceRect: super::super::Foundation::RECT,
    pub DestinationRect: super::super::Foundation::RECT,
    pub InputFormat: super::super::Graphics::Direct3D9::D3DFORMAT,
    pub FrameFormat: DXVAHD_FRAME_FORMAT,
    pub ColorSpace: u32,
    pub StreamNumber: u32,
    pub OutputIndex: u32,
    pub InputFrameOrField: u32,
    pub PastFrames: u32,
    pub FutureFrames: u32,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::marker::Copy for DXVAHDETW_VIDEOPROCESSBLTHD_STREAM {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::clone::Clone for DXVAHDETW_VIDEOPROCESSBLTHD_STREAM {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::fmt::Debug for DXVAHDETW_VIDEOPROCESSBLTHD_STREAM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHDETW_VIDEOPROCESSBLTHD_STREAM")
            .field("pObject", &self.pObject)
            .field("pInputSurface", &self.pInputSurface)
            .field("SourceRect", &self.SourceRect)
            .field("DestinationRect", &self.DestinationRect)
            .field("InputFormat", &self.InputFormat)
            .field("FrameFormat", &self.FrameFormat)
            .field("ColorSpace", &self.ColorSpace)
            .field("StreamNumber", &self.StreamNumber)
            .field("OutputIndex", &self.OutputIndex)
            .field("InputFrameOrField", &self.InputFrameOrField)
            .field("PastFrames", &self.PastFrames)
            .field("FutureFrames", &self.FutureFrames)
            .finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::windows::core::TypeKind for DXVAHDETW_VIDEOPROCESSBLTHD_STREAM {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::cmp::PartialEq for DXVAHDETW_VIDEOPROCESSBLTHD_STREAM {
    fn eq(&self, other: &Self) -> bool {
        self.pObject == other.pObject && self.pInputSurface == other.pInputSurface && self.SourceRect == other.SourceRect && self.DestinationRect == other.DestinationRect && self.InputFormat == other.InputFormat && self.FrameFormat == other.FrameFormat && self.ColorSpace == other.ColorSpace && self.StreamNumber == other.StreamNumber && self.OutputIndex == other.OutputIndex && self.InputFrameOrField == other.InputFrameOrField && self.PastFrames == other.PastFrames && self.FutureFrames == other.FutureFrames
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::cmp::Eq for DXVAHDETW_VIDEOPROCESSBLTHD_STREAM {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::default::Default for DXVAHDETW_VIDEOPROCESSBLTHD_STREAM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct DXVAHDETW_VIDEOPROCESSBLTSTATE {
    pub pObject: u64,
    pub State: DXVAHD_BLT_STATE,
    pub DataSize: u32,
    pub SetState: super::super::Foundation::BOOL,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DXVAHDETW_VIDEOPROCESSBLTSTATE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DXVAHDETW_VIDEOPROCESSBLTSTATE {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DXVAHDETW_VIDEOPROCESSBLTSTATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHDETW_VIDEOPROCESSBLTSTATE").field("pObject", &self.pObject).field("State", &self.State).field("DataSize", &self.DataSize).field("SetState", &self.SetState).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for DXVAHDETW_VIDEOPROCESSBLTSTATE {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DXVAHDETW_VIDEOPROCESSBLTSTATE {
    fn eq(&self, other: &Self) -> bool {
        self.pObject == other.pObject && self.State == other.State && self.DataSize == other.DataSize && self.SetState == other.SetState
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DXVAHDETW_VIDEOPROCESSBLTSTATE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DXVAHDETW_VIDEOPROCESSBLTSTATE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct DXVAHDETW_VIDEOPROCESSSTREAMSTATE {
    pub pObject: u64,
    pub StreamNumber: u32,
    pub State: DXVAHD_STREAM_STATE,
    pub DataSize: u32,
    pub SetState: super::super::Foundation::BOOL,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DXVAHDETW_VIDEOPROCESSSTREAMSTATE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DXVAHDETW_VIDEOPROCESSSTREAMSTATE {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DXVAHDETW_VIDEOPROCESSSTREAMSTATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHDETW_VIDEOPROCESSSTREAMSTATE").field("pObject", &self.pObject).field("StreamNumber", &self.StreamNumber).field("State", &self.State).field("DataSize", &self.DataSize).field("SetState", &self.SetState).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for DXVAHDETW_VIDEOPROCESSSTREAMSTATE {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DXVAHDETW_VIDEOPROCESSSTREAMSTATE {
    fn eq(&self, other: &Self) -> bool {
        self.pObject == other.pObject && self.StreamNumber == other.StreamNumber && self.State == other.State && self.DataSize == other.DataSize && self.SetState == other.SetState
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DXVAHDETW_VIDEOPROCESSSTREAMSTATE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DXVAHDETW_VIDEOPROCESSSTREAMSTATE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub struct DXVAHDSW_CALLBACKS {
    pub CreateDevice: PDXVAHDSW_CreateDevice,
    pub ProposeVideoPrivateFormat: PDXVAHDSW_ProposeVideoPrivateFormat,
    pub GetVideoProcessorDeviceCaps: PDXVAHDSW_GetVideoProcessorDeviceCaps,
    pub GetVideoProcessorOutputFormats: PDXVAHDSW_GetVideoProcessorOutputFormats,
    pub GetVideoProcessorInputFormats: PDXVAHDSW_GetVideoProcessorInputFormats,
    pub GetVideoProcessorCaps: PDXVAHDSW_GetVideoProcessorCaps,
    pub GetVideoProcessorCustomRates: PDXVAHDSW_GetVideoProcessorCustomRates,
    pub GetVideoProcessorFilterRange: PDXVAHDSW_GetVideoProcessorFilterRange,
    pub DestroyDevice: PDXVAHDSW_DestroyDevice,
    pub CreateVideoProcessor: PDXVAHDSW_CreateVideoProcessor,
    pub SetVideoProcessBltState: PDXVAHDSW_SetVideoProcessBltState,
    pub GetVideoProcessBltStatePrivate: PDXVAHDSW_GetVideoProcessBltStatePrivate,
    pub SetVideoProcessStreamState: PDXVAHDSW_SetVideoProcessStreamState,
    pub GetVideoProcessStreamStatePrivate: PDXVAHDSW_GetVideoProcessStreamStatePrivate,
    pub VideoProcessBltHD: PDXVAHDSW_VideoProcessBltHD,
    pub DestroyVideoProcessor: PDXVAHDSW_DestroyVideoProcessor,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::marker::Copy for DXVAHDSW_CALLBACKS {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::clone::Clone for DXVAHDSW_CALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::fmt::Debug for DXVAHDSW_CALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHDSW_CALLBACKS").finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::windows::core::TypeKind for DXVAHDSW_CALLBACKS {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::default::Default for DXVAHDSW_CALLBACKS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVAHD_BLT_STATE_ALPHA_FILL_DATA {
    pub Mode: DXVAHD_ALPHA_FILL_MODE,
    pub StreamNumber: u32,
}
impl ::core::marker::Copy for DXVAHD_BLT_STATE_ALPHA_FILL_DATA {}
impl ::core::clone::Clone for DXVAHD_BLT_STATE_ALPHA_FILL_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVAHD_BLT_STATE_ALPHA_FILL_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_BLT_STATE_ALPHA_FILL_DATA").field("Mode", &self.Mode).field("StreamNumber", &self.StreamNumber).finish()
    }
}
impl ::windows::core::TypeKind for DXVAHD_BLT_STATE_ALPHA_FILL_DATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVAHD_BLT_STATE_ALPHA_FILL_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Mode == other.Mode && self.StreamNumber == other.StreamNumber
    }
}
impl ::core::cmp::Eq for DXVAHD_BLT_STATE_ALPHA_FILL_DATA {}
impl ::core::default::Default for DXVAHD_BLT_STATE_ALPHA_FILL_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct DXVAHD_BLT_STATE_BACKGROUND_COLOR_DATA {
    pub YCbCr: super::super::Foundation::BOOL,
    pub BackgroundColor: DXVAHD_COLOR,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DXVAHD_BLT_STATE_BACKGROUND_COLOR_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DXVAHD_BLT_STATE_BACKGROUND_COLOR_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for DXVAHD_BLT_STATE_BACKGROUND_COLOR_DATA {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DXVAHD_BLT_STATE_BACKGROUND_COLOR_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct DXVAHD_BLT_STATE_CONSTRICTION_DATA {
    pub Enable: super::super::Foundation::BOOL,
    pub Size: super::super::Foundation::SIZE,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DXVAHD_BLT_STATE_CONSTRICTION_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DXVAHD_BLT_STATE_CONSTRICTION_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DXVAHD_BLT_STATE_CONSTRICTION_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_BLT_STATE_CONSTRICTION_DATA").field("Enable", &self.Enable).field("Size", &self.Size).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for DXVAHD_BLT_STATE_CONSTRICTION_DATA {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DXVAHD_BLT_STATE_CONSTRICTION_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Enable == other.Enable && self.Size == other.Size
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DXVAHD_BLT_STATE_CONSTRICTION_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DXVAHD_BLT_STATE_CONSTRICTION_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA {
    pub Anonymous: DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA_0,
}
impl ::core::marker::Copy for DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA {}
impl ::core::clone::Clone for DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub union DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA_0 {
    pub Anonymous: DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA_0_0,
    pub Value: u32,
}
impl ::core::marker::Copy for DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA_0 {}
impl ::core::clone::Clone for DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA_0_0 {
    pub _bitfield: u32,
}
impl ::core::marker::Copy for DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA_0_0 {}
impl ::core::clone::Clone for DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA_0_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA_0_0").field("_bitfield", &self._bitfield).finish()
    }
}
impl ::windows::core::TypeKind for DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA_0_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::core::cmp::Eq for DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA_0_0 {}
impl ::core::default::Default for DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA_0_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVAHD_BLT_STATE_PRIVATE_DATA {
    pub Guid: ::windows::core::GUID,
    pub DataSize: u32,
    pub pData: *mut ::core::ffi::c_void,
}
impl ::core::marker::Copy for DXVAHD_BLT_STATE_PRIVATE_DATA {}
impl ::core::clone::Clone for DXVAHD_BLT_STATE_PRIVATE_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVAHD_BLT_STATE_PRIVATE_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_BLT_STATE_PRIVATE_DATA").field("Guid", &self.Guid).field("DataSize", &self.DataSize).field("pData", &self.pData).finish()
    }
}
impl ::windows::core::TypeKind for DXVAHD_BLT_STATE_PRIVATE_DATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVAHD_BLT_STATE_PRIVATE_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Guid == other.Guid && self.DataSize == other.DataSize && self.pData == other.pData
    }
}
impl ::core::cmp::Eq for DXVAHD_BLT_STATE_PRIVATE_DATA {}
impl ::core::default::Default for DXVAHD_BLT_STATE_PRIVATE_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct DXVAHD_BLT_STATE_TARGET_RECT_DATA {
    pub Enable: super::super::Foundation::BOOL,
    pub TargetRect: super::super::Foundation::RECT,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DXVAHD_BLT_STATE_TARGET_RECT_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DXVAHD_BLT_STATE_TARGET_RECT_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DXVAHD_BLT_STATE_TARGET_RECT_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_BLT_STATE_TARGET_RECT_DATA").field("Enable", &self.Enable).field("TargetRect", &self.TargetRect).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for DXVAHD_BLT_STATE_TARGET_RECT_DATA {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DXVAHD_BLT_STATE_TARGET_RECT_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Enable == other.Enable && self.TargetRect == other.TargetRect
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DXVAHD_BLT_STATE_TARGET_RECT_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DXVAHD_BLT_STATE_TARGET_RECT_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub union DXVAHD_COLOR {
    pub RGB: DXVAHD_COLOR_RGBA,
    pub YCbCr: DXVAHD_COLOR_YCbCrA,
}
impl ::core::marker::Copy for DXVAHD_COLOR {}
impl ::core::clone::Clone for DXVAHD_COLOR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for DXVAHD_COLOR {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for DXVAHD_COLOR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVAHD_COLOR_RGBA {
    pub R: f32,
    pub G: f32,
    pub B: f32,
    pub A: f32,
}
impl ::core::marker::Copy for DXVAHD_COLOR_RGBA {}
impl ::core::clone::Clone for DXVAHD_COLOR_RGBA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVAHD_COLOR_RGBA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_COLOR_RGBA").field("R", &self.R).field("G", &self.G).field("B", &self.B).field("A", &self.A).finish()
    }
}
impl ::windows::core::TypeKind for DXVAHD_COLOR_RGBA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVAHD_COLOR_RGBA {
    fn eq(&self, other: &Self) -> bool {
        self.R == other.R && self.G == other.G && self.B == other.B && self.A == other.A
    }
}
impl ::core::cmp::Eq for DXVAHD_COLOR_RGBA {}
impl ::core::default::Default for DXVAHD_COLOR_RGBA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVAHD_COLOR_YCbCrA {
    pub Y: f32,
    pub Cb: f32,
    pub Cr: f32,
    pub A: f32,
}
impl ::core::marker::Copy for DXVAHD_COLOR_YCbCrA {}
impl ::core::clone::Clone for DXVAHD_COLOR_YCbCrA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVAHD_COLOR_YCbCrA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_COLOR_YCbCrA").field("Y", &self.Y).field("Cb", &self.Cb).field("Cr", &self.Cr).field("A", &self.A).finish()
    }
}
impl ::windows::core::TypeKind for DXVAHD_COLOR_YCbCrA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVAHD_COLOR_YCbCrA {
    fn eq(&self, other: &Self) -> bool {
        self.Y == other.Y && self.Cb == other.Cb && self.Cr == other.Cr && self.A == other.A
    }
}
impl ::core::cmp::Eq for DXVAHD_COLOR_YCbCrA {}
impl ::core::default::Default for DXVAHD_COLOR_YCbCrA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVAHD_CONTENT_DESC {
    pub InputFrameFormat: DXVAHD_FRAME_FORMAT,
    pub InputFrameRate: DXVAHD_RATIONAL,
    pub InputWidth: u32,
    pub InputHeight: u32,
    pub OutputFrameRate: DXVAHD_RATIONAL,
    pub OutputWidth: u32,
    pub OutputHeight: u32,
}
impl ::core::marker::Copy for DXVAHD_CONTENT_DESC {}
impl ::core::clone::Clone for DXVAHD_CONTENT_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVAHD_CONTENT_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_CONTENT_DESC").field("InputFrameFormat", &self.InputFrameFormat).field("InputFrameRate", &self.InputFrameRate).field("InputWidth", &self.InputWidth).field("InputHeight", &self.InputHeight).field("OutputFrameRate", &self.OutputFrameRate).field("OutputWidth", &self.OutputWidth).field("OutputHeight", &self.OutputHeight).finish()
    }
}
impl ::windows::core::TypeKind for DXVAHD_CONTENT_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVAHD_CONTENT_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.InputFrameFormat == other.InputFrameFormat && self.InputFrameRate == other.InputFrameRate && self.InputWidth == other.InputWidth && self.InputHeight == other.InputHeight && self.OutputFrameRate == other.OutputFrameRate && self.OutputWidth == other.OutputWidth && self.OutputHeight == other.OutputHeight
    }
}
impl ::core::cmp::Eq for DXVAHD_CONTENT_DESC {}
impl ::core::default::Default for DXVAHD_CONTENT_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct DXVAHD_CUSTOM_RATE_DATA {
    pub CustomRate: DXVAHD_RATIONAL,
    pub OutputFrames: u32,
    pub InputInterlaced: super::super::Foundation::BOOL,
    pub InputFramesOrFields: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DXVAHD_CUSTOM_RATE_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DXVAHD_CUSTOM_RATE_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DXVAHD_CUSTOM_RATE_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_CUSTOM_RATE_DATA").field("CustomRate", &self.CustomRate).field("OutputFrames", &self.OutputFrames).field("InputInterlaced", &self.InputInterlaced).field("InputFramesOrFields", &self.InputFramesOrFields).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for DXVAHD_CUSTOM_RATE_DATA {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DXVAHD_CUSTOM_RATE_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.CustomRate == other.CustomRate && self.OutputFrames == other.OutputFrames && self.InputInterlaced == other.InputInterlaced && self.InputFramesOrFields == other.InputFramesOrFields
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DXVAHD_CUSTOM_RATE_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DXVAHD_CUSTOM_RATE_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVAHD_FILTER_RANGE_DATA {
    pub Minimum: i32,
    pub Maximum: i32,
    pub Default: i32,
    pub Multiplier: f32,
}
impl ::core::marker::Copy for DXVAHD_FILTER_RANGE_DATA {}
impl ::core::clone::Clone for DXVAHD_FILTER_RANGE_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVAHD_FILTER_RANGE_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_FILTER_RANGE_DATA").field("Minimum", &self.Minimum).field("Maximum", &self.Maximum).field("Default", &self.Default).field("Multiplier", &self.Multiplier).finish()
    }
}
impl ::windows::core::TypeKind for DXVAHD_FILTER_RANGE_DATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVAHD_FILTER_RANGE_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Minimum == other.Minimum && self.Maximum == other.Maximum && self.Default == other.Default && self.Multiplier == other.Multiplier
    }
}
impl ::core::cmp::Eq for DXVAHD_FILTER_RANGE_DATA {}
impl ::core::default::Default for DXVAHD_FILTER_RANGE_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVAHD_RATIONAL {
    pub Numerator: u32,
    pub Denominator: u32,
}
impl ::core::marker::Copy for DXVAHD_RATIONAL {}
impl ::core::clone::Clone for DXVAHD_RATIONAL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVAHD_RATIONAL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_RATIONAL").field("Numerator", &self.Numerator).field("Denominator", &self.Denominator).finish()
    }
}
impl ::windows::core::TypeKind for DXVAHD_RATIONAL {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVAHD_RATIONAL {
    fn eq(&self, other: &Self) -> bool {
        self.Numerator == other.Numerator && self.Denominator == other.Denominator
    }
}
impl ::core::cmp::Eq for DXVAHD_RATIONAL {}
impl ::core::default::Default for DXVAHD_RATIONAL {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub struct DXVAHD_STREAM_DATA {
    pub Enable: super::super::Foundation::BOOL,
    pub OutputIndex: u32,
    pub InputFrameOrField: u32,
    pub PastFrames: u32,
    pub FutureFrames: u32,
    pub ppPastSurfaces: *mut ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>,
    pub pInputSurface: ::std::mem::ManuallyDrop<::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>>,
    pub ppFutureSurfaces: *mut ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::clone::Clone for DXVAHD_STREAM_DATA {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::fmt::Debug for DXVAHD_STREAM_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_STREAM_DATA").field("Enable", &self.Enable).field("OutputIndex", &self.OutputIndex).field("InputFrameOrField", &self.InputFrameOrField).field("PastFrames", &self.PastFrames).field("FutureFrames", &self.FutureFrames).field("ppPastSurfaces", &self.ppPastSurfaces).field("pInputSurface", &self.pInputSurface).field("ppFutureSurfaces", &self.ppFutureSurfaces).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::windows::core::TypeKind for DXVAHD_STREAM_DATA {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::cmp::PartialEq for DXVAHD_STREAM_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Enable == other.Enable && self.OutputIndex == other.OutputIndex && self.InputFrameOrField == other.InputFrameOrField && self.PastFrames == other.PastFrames && self.FutureFrames == other.FutureFrames && self.ppPastSurfaces == other.ppPastSurfaces && self.pInputSurface == other.pInputSurface && self.ppFutureSurfaces == other.ppFutureSurfaces
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::cmp::Eq for DXVAHD_STREAM_DATA {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl ::core::default::Default for DXVAHD_STREAM_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct DXVAHD_STREAM_STATE_ALPHA_DATA {
    pub Enable: super::super::Foundation::BOOL,
    pub Alpha: f32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DXVAHD_STREAM_STATE_ALPHA_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DXVAHD_STREAM_STATE_ALPHA_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DXVAHD_STREAM_STATE_ALPHA_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_STREAM_STATE_ALPHA_DATA").field("Enable", &self.Enable).field("Alpha", &self.Alpha).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for DXVAHD_STREAM_STATE_ALPHA_DATA {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DXVAHD_STREAM_STATE_ALPHA_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Enable == other.Enable && self.Alpha == other.Alpha
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DXVAHD_STREAM_STATE_ALPHA_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DXVAHD_STREAM_STATE_ALPHA_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct DXVAHD_STREAM_STATE_ASPECT_RATIO_DATA {
    pub Enable: super::super::Foundation::BOOL,
    pub SourceAspectRatio: DXVAHD_RATIONAL,
    pub DestinationAspectRatio: DXVAHD_RATIONAL,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DXVAHD_STREAM_STATE_ASPECT_RATIO_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DXVAHD_STREAM_STATE_ASPECT_RATIO_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DXVAHD_STREAM_STATE_ASPECT_RATIO_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_STREAM_STATE_ASPECT_RATIO_DATA").field("Enable", &self.Enable).field("SourceAspectRatio", &self.SourceAspectRatio).field("DestinationAspectRatio", &self.DestinationAspectRatio).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for DXVAHD_STREAM_STATE_ASPECT_RATIO_DATA {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DXVAHD_STREAM_STATE_ASPECT_RATIO_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Enable == other.Enable && self.SourceAspectRatio == other.SourceAspectRatio && self.DestinationAspectRatio == other.DestinationAspectRatio
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DXVAHD_STREAM_STATE_ASPECT_RATIO_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DXVAHD_STREAM_STATE_ASPECT_RATIO_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct DXVAHD_STREAM_STATE_D3DFORMAT_DATA {
    pub Format: super::super::Graphics::Direct3D9::D3DFORMAT,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::marker::Copy for DXVAHD_STREAM_STATE_D3DFORMAT_DATA {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::clone::Clone for DXVAHD_STREAM_STATE_D3DFORMAT_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::fmt::Debug for DXVAHD_STREAM_STATE_D3DFORMAT_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_STREAM_STATE_D3DFORMAT_DATA").field("Format", &self.Format).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::windows::core::TypeKind for DXVAHD_STREAM_STATE_D3DFORMAT_DATA {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::cmp::PartialEq for DXVAHD_STREAM_STATE_D3DFORMAT_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Format == other.Format
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::cmp::Eq for DXVAHD_STREAM_STATE_D3DFORMAT_DATA {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::default::Default for DXVAHD_STREAM_STATE_D3DFORMAT_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct DXVAHD_STREAM_STATE_DESTINATION_RECT_DATA {
    pub Enable: super::super::Foundation::BOOL,
    pub DestinationRect: super::super::Foundation::RECT,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DXVAHD_STREAM_STATE_DESTINATION_RECT_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DXVAHD_STREAM_STATE_DESTINATION_RECT_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DXVAHD_STREAM_STATE_DESTINATION_RECT_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_STREAM_STATE_DESTINATION_RECT_DATA").field("Enable", &self.Enable).field("DestinationRect", &self.DestinationRect).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for DXVAHD_STREAM_STATE_DESTINATION_RECT_DATA {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DXVAHD_STREAM_STATE_DESTINATION_RECT_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Enable == other.Enable && self.DestinationRect == other.DestinationRect
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DXVAHD_STREAM_STATE_DESTINATION_RECT_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DXVAHD_STREAM_STATE_DESTINATION_RECT_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct DXVAHD_STREAM_STATE_FILTER_DATA {
    pub Enable: super::super::Foundation::BOOL,
    pub Level: i32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DXVAHD_STREAM_STATE_FILTER_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DXVAHD_STREAM_STATE_FILTER_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DXVAHD_STREAM_STATE_FILTER_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_STREAM_STATE_FILTER_DATA").field("Enable", &self.Enable).field("Level", &self.Level).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for DXVAHD_STREAM_STATE_FILTER_DATA {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DXVAHD_STREAM_STATE_FILTER_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Enable == other.Enable && self.Level == other.Level
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DXVAHD_STREAM_STATE_FILTER_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DXVAHD_STREAM_STATE_FILTER_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVAHD_STREAM_STATE_FRAME_FORMAT_DATA {
    pub FrameFormat: DXVAHD_FRAME_FORMAT,
}
impl ::core::marker::Copy for DXVAHD_STREAM_STATE_FRAME_FORMAT_DATA {}
impl ::core::clone::Clone for DXVAHD_STREAM_STATE_FRAME_FORMAT_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVAHD_STREAM_STATE_FRAME_FORMAT_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_STREAM_STATE_FRAME_FORMAT_DATA").field("FrameFormat", &self.FrameFormat).finish()
    }
}
impl ::windows::core::TypeKind for DXVAHD_STREAM_STATE_FRAME_FORMAT_DATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVAHD_STREAM_STATE_FRAME_FORMAT_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.FrameFormat == other.FrameFormat
    }
}
impl ::core::cmp::Eq for DXVAHD_STREAM_STATE_FRAME_FORMAT_DATA {}
impl ::core::default::Default for DXVAHD_STREAM_STATE_FRAME_FORMAT_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA {
    pub Anonymous: DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA_0,
}
impl ::core::marker::Copy for DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA {}
impl ::core::clone::Clone for DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub union DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA_0 {
    pub Anonymous: DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA_0_0,
    pub Value: u32,
}
impl ::core::marker::Copy for DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA_0 {}
impl ::core::clone::Clone for DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA_0_0 {
    pub _bitfield: u32,
}
impl ::core::marker::Copy for DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA_0_0 {}
impl ::core::clone::Clone for DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA_0_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA_0_0").field("_bitfield", &self._bitfield).finish()
    }
}
impl ::windows::core::TypeKind for DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA_0_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::core::cmp::Eq for DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA_0_0 {}
impl ::core::default::Default for DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA_0_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct DXVAHD_STREAM_STATE_LUMA_KEY_DATA {
    pub Enable: super::super::Foundation::BOOL,
    pub Lower: f32,
    pub Upper: f32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DXVAHD_STREAM_STATE_LUMA_KEY_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DXVAHD_STREAM_STATE_LUMA_KEY_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DXVAHD_STREAM_STATE_LUMA_KEY_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_STREAM_STATE_LUMA_KEY_DATA").field("Enable", &self.Enable).field("Lower", &self.Lower).field("Upper", &self.Upper).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for DXVAHD_STREAM_STATE_LUMA_KEY_DATA {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DXVAHD_STREAM_STATE_LUMA_KEY_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Enable == other.Enable && self.Lower == other.Lower && self.Upper == other.Upper
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DXVAHD_STREAM_STATE_LUMA_KEY_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DXVAHD_STREAM_STATE_LUMA_KEY_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct DXVAHD_STREAM_STATE_OUTPUT_RATE_DATA {
    pub RepeatFrame: super::super::Foundation::BOOL,
    pub OutputRate: DXVAHD_OUTPUT_RATE,
    pub CustomRate: DXVAHD_RATIONAL,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DXVAHD_STREAM_STATE_OUTPUT_RATE_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DXVAHD_STREAM_STATE_OUTPUT_RATE_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DXVAHD_STREAM_STATE_OUTPUT_RATE_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_STREAM_STATE_OUTPUT_RATE_DATA").field("RepeatFrame", &self.RepeatFrame).field("OutputRate", &self.OutputRate).field("CustomRate", &self.CustomRate).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for DXVAHD_STREAM_STATE_OUTPUT_RATE_DATA {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DXVAHD_STREAM_STATE_OUTPUT_RATE_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.RepeatFrame == other.RepeatFrame && self.OutputRate == other.OutputRate && self.CustomRate == other.CustomRate
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DXVAHD_STREAM_STATE_OUTPUT_RATE_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DXVAHD_STREAM_STATE_OUTPUT_RATE_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVAHD_STREAM_STATE_PALETTE_DATA {
    pub Count: u32,
    pub pEntries: *mut u32,
}
impl ::core::marker::Copy for DXVAHD_STREAM_STATE_PALETTE_DATA {}
impl ::core::clone::Clone for DXVAHD_STREAM_STATE_PALETTE_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVAHD_STREAM_STATE_PALETTE_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_STREAM_STATE_PALETTE_DATA").field("Count", &self.Count).field("pEntries", &self.pEntries).finish()
    }
}
impl ::windows::core::TypeKind for DXVAHD_STREAM_STATE_PALETTE_DATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVAHD_STREAM_STATE_PALETTE_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Count == other.Count && self.pEntries == other.pEntries
    }
}
impl ::core::cmp::Eq for DXVAHD_STREAM_STATE_PALETTE_DATA {}
impl ::core::default::Default for DXVAHD_STREAM_STATE_PALETTE_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVAHD_STREAM_STATE_PRIVATE_DATA {
    pub Guid: ::windows::core::GUID,
    pub DataSize: u32,
    pub pData: *mut ::core::ffi::c_void,
}
impl ::core::marker::Copy for DXVAHD_STREAM_STATE_PRIVATE_DATA {}
impl ::core::clone::Clone for DXVAHD_STREAM_STATE_PRIVATE_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVAHD_STREAM_STATE_PRIVATE_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_STREAM_STATE_PRIVATE_DATA").field("Guid", &self.Guid).field("DataSize", &self.DataSize).field("pData", &self.pData).finish()
    }
}
impl ::windows::core::TypeKind for DXVAHD_STREAM_STATE_PRIVATE_DATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVAHD_STREAM_STATE_PRIVATE_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Guid == other.Guid && self.DataSize == other.DataSize && self.pData == other.pData
    }
}
impl ::core::cmp::Eq for DXVAHD_STREAM_STATE_PRIVATE_DATA {}
impl ::core::default::Default for DXVAHD_STREAM_STATE_PRIVATE_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct DXVAHD_STREAM_STATE_PRIVATE_IVTC_DATA {
    pub Enable: super::super::Foundation::BOOL,
    pub ITelecineFlags: u32,
    pub Frames: u32,
    pub InputField: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DXVAHD_STREAM_STATE_PRIVATE_IVTC_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DXVAHD_STREAM_STATE_PRIVATE_IVTC_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DXVAHD_STREAM_STATE_PRIVATE_IVTC_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_STREAM_STATE_PRIVATE_IVTC_DATA").field("Enable", &self.Enable).field("ITelecineFlags", &self.ITelecineFlags).field("Frames", &self.Frames).field("InputField", &self.InputField).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for DXVAHD_STREAM_STATE_PRIVATE_IVTC_DATA {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DXVAHD_STREAM_STATE_PRIVATE_IVTC_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Enable == other.Enable && self.ITelecineFlags == other.ITelecineFlags && self.Frames == other.Frames && self.InputField == other.InputField
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DXVAHD_STREAM_STATE_PRIVATE_IVTC_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DXVAHD_STREAM_STATE_PRIVATE_IVTC_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct DXVAHD_STREAM_STATE_SOURCE_RECT_DATA {
    pub Enable: super::super::Foundation::BOOL,
    pub SourceRect: super::super::Foundation::RECT,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DXVAHD_STREAM_STATE_SOURCE_RECT_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DXVAHD_STREAM_STATE_SOURCE_RECT_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DXVAHD_STREAM_STATE_SOURCE_RECT_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_STREAM_STATE_SOURCE_RECT_DATA").field("Enable", &self.Enable).field("SourceRect", &self.SourceRect).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for DXVAHD_STREAM_STATE_SOURCE_RECT_DATA {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DXVAHD_STREAM_STATE_SOURCE_RECT_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Enable == other.Enable && self.SourceRect == other.SourceRect
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DXVAHD_STREAM_STATE_SOURCE_RECT_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DXVAHD_STREAM_STATE_SOURCE_RECT_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVAHD_VPCAPS {
    pub VPGuid: ::windows::core::GUID,
    pub PastFrames: u32,
    pub FutureFrames: u32,
    pub ProcessorCaps: u32,
    pub ITelecineCaps: u32,
    pub CustomRateCount: u32,
}
impl ::core::marker::Copy for DXVAHD_VPCAPS {}
impl ::core::clone::Clone for DXVAHD_VPCAPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVAHD_VPCAPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_VPCAPS").field("VPGuid", &self.VPGuid).field("PastFrames", &self.PastFrames).field("FutureFrames", &self.FutureFrames).field("ProcessorCaps", &self.ProcessorCaps).field("ITelecineCaps", &self.ITelecineCaps).field("CustomRateCount", &self.CustomRateCount).finish()
    }
}
impl ::windows::core::TypeKind for DXVAHD_VPCAPS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVAHD_VPCAPS {
    fn eq(&self, other: &Self) -> bool {
        self.VPGuid == other.VPGuid && self.PastFrames == other.PastFrames && self.FutureFrames == other.FutureFrames && self.ProcessorCaps == other.ProcessorCaps && self.ITelecineCaps == other.ITelecineCaps && self.CustomRateCount == other.CustomRateCount
    }
}
impl ::core::cmp::Eq for DXVAHD_VPCAPS {}
impl ::core::default::Default for DXVAHD_VPCAPS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct DXVAHD_VPDEVCAPS {
    pub DeviceType: DXVAHD_DEVICE_TYPE,
    pub DeviceCaps: u32,
    pub FeatureCaps: u32,
    pub FilterCaps: u32,
    pub InputFormatCaps: u32,
    pub InputPool: super::super::Graphics::Direct3D9::D3DPOOL,
    pub OutputFormatCount: u32,
    pub InputFormatCount: u32,
    pub VideoProcessorCount: u32,
    pub MaxInputStreams: u32,
    pub MaxStreamStates: u32,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::marker::Copy for DXVAHD_VPDEVCAPS {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::clone::Clone for DXVAHD_VPDEVCAPS {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::fmt::Debug for DXVAHD_VPDEVCAPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAHD_VPDEVCAPS")
            .field("DeviceType", &self.DeviceType)
            .field("DeviceCaps", &self.DeviceCaps)
            .field("FeatureCaps", &self.FeatureCaps)
            .field("FilterCaps", &self.FilterCaps)
            .field("InputFormatCaps", &self.InputFormatCaps)
            .field("InputPool", &self.InputPool)
            .field("OutputFormatCount", &self.OutputFormatCount)
            .field("InputFormatCount", &self.InputFormatCount)
            .field("VideoProcessorCount", &self.VideoProcessorCount)
            .field("MaxInputStreams", &self.MaxInputStreams)
            .field("MaxStreamStates", &self.MaxStreamStates)
            .finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::windows::core::TypeKind for DXVAHD_VPDEVCAPS {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::cmp::PartialEq for DXVAHD_VPDEVCAPS {
    fn eq(&self, other: &Self) -> bool {
        self.DeviceType == other.DeviceType && self.DeviceCaps == other.DeviceCaps && self.FeatureCaps == other.FeatureCaps && self.FilterCaps == other.FilterCaps && self.InputFormatCaps == other.InputFormatCaps && self.InputPool == other.InputPool && self.OutputFormatCount == other.OutputFormatCount && self.InputFormatCount == other.InputFormatCount && self.VideoProcessorCount == other.VideoProcessorCount && self.MaxInputStreams == other.MaxInputStreams && self.MaxStreamStates == other.MaxStreamStates
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::cmp::Eq for DXVAHD_VPDEVCAPS {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::default::Default for DXVAHD_VPDEVCAPS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct DXVAUncompDataInfo {
    pub UncompWidth: u32,
    pub UncompHeight: u32,
    pub UncompFormat: super::super::Graphics::Direct3D9::D3DFORMAT,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::marker::Copy for DXVAUncompDataInfo {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::clone::Clone for DXVAUncompDataInfo {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::fmt::Debug for DXVAUncompDataInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVAUncompDataInfo").field("UncompWidth", &self.UncompWidth).field("UncompHeight", &self.UncompHeight).field("UncompFormat", &self.UncompFormat).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::windows::core::TypeKind for DXVAUncompDataInfo {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::cmp::PartialEq for DXVAUncompDataInfo {
    fn eq(&self, other: &Self) -> bool {
        self.UncompWidth == other.UncompWidth && self.UncompHeight == other.UncompHeight && self.UncompFormat == other.UncompFormat
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::cmp::Eq for DXVAUncompDataInfo {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::default::Default for DXVAUncompDataInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA_AYUVsample2 {
    pub bCrValue: u8,
    pub bCbValue: u8,
    pub bY_Value: u8,
    pub bSampleAlpha8: u8,
}
impl ::core::marker::Copy for DXVA_AYUVsample2 {}
impl ::core::clone::Clone for DXVA_AYUVsample2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVA_AYUVsample2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_AYUVsample2").field("bCrValue", &self.bCrValue).field("bCbValue", &self.bCbValue).field("bY_Value", &self.bY_Value).field("bSampleAlpha8", &self.bSampleAlpha8).finish()
    }
}
impl ::windows::core::TypeKind for DXVA_AYUVsample2 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVA_AYUVsample2 {
    fn eq(&self, other: &Self) -> bool {
        self.bCrValue == other.bCrValue && self.bCbValue == other.bCbValue && self.bY_Value == other.bY_Value && self.bSampleAlpha8 == other.bSampleAlpha8
    }
}
impl ::core::cmp::Eq for DXVA_AYUVsample2 {}
impl ::core::default::Default for DXVA_AYUVsample2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA_BufferDescription {
    pub dwTypeIndex: u32,
    pub dwBufferIndex: u32,
    pub dwDataOffset: u32,
    pub dwDataSize: u32,
    pub dwFirstMBaddress: u32,
    pub dwNumMBsInBuffer: u32,
    pub dwWidth: u32,
    pub dwHeight: u32,
    pub dwStride: u32,
    pub dwReservedBits: u32,
}
impl ::core::marker::Copy for DXVA_BufferDescription {}
impl ::core::clone::Clone for DXVA_BufferDescription {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for DXVA_BufferDescription {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for DXVA_BufferDescription {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA_COPPCommand {
    pub macKDI: ::windows::core::GUID,
    pub guidCommandID: ::windows::core::GUID,
    pub dwSequence: u32,
    pub cbSizeData: u32,
    pub CommandData: [u8; 4056],
}
impl ::core::marker::Copy for DXVA_COPPCommand {}
impl ::core::clone::Clone for DXVA_COPPCommand {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVA_COPPCommand {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_COPPCommand").field("macKDI", &self.macKDI).field("guidCommandID", &self.guidCommandID).field("dwSequence", &self.dwSequence).field("cbSizeData", &self.cbSizeData).field("CommandData", &self.CommandData).finish()
    }
}
impl ::windows::core::TypeKind for DXVA_COPPCommand {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVA_COPPCommand {
    fn eq(&self, other: &Self) -> bool {
        self.macKDI == other.macKDI && self.guidCommandID == other.guidCommandID && self.dwSequence == other.dwSequence && self.cbSizeData == other.cbSizeData && self.CommandData == other.CommandData
    }
}
impl ::core::cmp::Eq for DXVA_COPPCommand {}
impl ::core::default::Default for DXVA_COPPCommand {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA_COPPSignature {
    pub Signature: [u8; 256],
}
impl ::core::marker::Copy for DXVA_COPPSignature {}
impl ::core::clone::Clone for DXVA_COPPSignature {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVA_COPPSignature {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_COPPSignature").field("Signature", &self.Signature).finish()
    }
}
impl ::windows::core::TypeKind for DXVA_COPPSignature {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVA_COPPSignature {
    fn eq(&self, other: &Self) -> bool {
        self.Signature == other.Signature
    }
}
impl ::core::cmp::Eq for DXVA_COPPSignature {}
impl ::core::default::Default for DXVA_COPPSignature {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA_COPPStatusInput {
    pub rApp: ::windows::core::GUID,
    pub guidStatusRequestID: ::windows::core::GUID,
    pub dwSequence: u32,
    pub cbSizeData: u32,
    pub StatusData: [u8; 4056],
}
impl ::core::marker::Copy for DXVA_COPPStatusInput {}
impl ::core::clone::Clone for DXVA_COPPStatusInput {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVA_COPPStatusInput {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_COPPStatusInput").field("rApp", &self.rApp).field("guidStatusRequestID", &self.guidStatusRequestID).field("dwSequence", &self.dwSequence).field("cbSizeData", &self.cbSizeData).field("StatusData", &self.StatusData).finish()
    }
}
impl ::windows::core::TypeKind for DXVA_COPPStatusInput {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVA_COPPStatusInput {
    fn eq(&self, other: &Self) -> bool {
        self.rApp == other.rApp && self.guidStatusRequestID == other.guidStatusRequestID && self.dwSequence == other.dwSequence && self.cbSizeData == other.cbSizeData && self.StatusData == other.StatusData
    }
}
impl ::core::cmp::Eq for DXVA_COPPStatusInput {}
impl ::core::default::Default for DXVA_COPPStatusInput {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA_COPPStatusOutput {
    pub macKDI: ::windows::core::GUID,
    pub cbSizeData: u32,
    pub COPPStatus: [u8; 4076],
}
impl ::core::marker::Copy for DXVA_COPPStatusOutput {}
impl ::core::clone::Clone for DXVA_COPPStatusOutput {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVA_COPPStatusOutput {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_COPPStatusOutput").field("macKDI", &self.macKDI).field("cbSizeData", &self.cbSizeData).field("COPPStatus", &self.COPPStatus).finish()
    }
}
impl ::windows::core::TypeKind for DXVA_COPPStatusOutput {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVA_COPPStatusOutput {
    fn eq(&self, other: &Self) -> bool {
        self.macKDI == other.macKDI && self.cbSizeData == other.cbSizeData && self.COPPStatus == other.COPPStatus
    }
}
impl ::core::cmp::Eq for DXVA_COPPStatusOutput {}
impl ::core::default::Default for DXVA_COPPStatusOutput {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA_ConfigPictureDecode {
    pub dwFunction: u32,
    pub dwReservedBits: [u32; 3],
    pub guidConfigBitstreamEncryption: ::windows::core::GUID,
    pub guidConfigMBcontrolEncryption: ::windows::core::GUID,
    pub guidConfigResidDiffEncryption: ::windows::core::GUID,
    pub bConfigBitstreamRaw: u8,
    pub bConfigMBcontrolRasterOrder: u8,
    pub bConfigResidDiffHost: u8,
    pub bConfigSpatialResid8: u8,
    pub bConfigResid8Subtraction: u8,
    pub bConfigSpatialHost8or9Clipping: u8,
    pub bConfigSpatialResidInterleaved: u8,
    pub bConfigIntraResidUnsigned: u8,
    pub bConfigResidDiffAccelerator: u8,
    pub bConfigHostInverseScan: u8,
    pub bConfigSpecificIDCT: u8,
    pub bConfig4GroupedCoefs: u8,
}
impl ::core::marker::Copy for DXVA_ConfigPictureDecode {}
impl ::core::clone::Clone for DXVA_ConfigPictureDecode {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for DXVA_ConfigPictureDecode {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for DXVA_ConfigPictureDecode {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct DXVA_DeinterlaceBlt {
    pub Size: u32,
    pub Reserved: u32,
    pub rtTarget: i64,
    pub DstRect: super::super::Foundation::RECT,
    pub SrcRect: super::super::Foundation::RECT,
    pub NumSourceSurfaces: u32,
    pub Alpha: f32,
    pub Source: [DXVA_VideoSample; 32],
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DXVA_DeinterlaceBlt {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DXVA_DeinterlaceBlt {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DXVA_DeinterlaceBlt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_DeinterlaceBlt").field("Size", &self.Size).field("Reserved", &self.Reserved).field("rtTarget", &self.rtTarget).field("DstRect", &self.DstRect).field("SrcRect", &self.SrcRect).field("NumSourceSurfaces", &self.NumSourceSurfaces).field("Alpha", &self.Alpha).field("Source", &self.Source).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for DXVA_DeinterlaceBlt {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DXVA_DeinterlaceBlt {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.Reserved == other.Reserved && self.rtTarget == other.rtTarget && self.DstRect == other.DstRect && self.SrcRect == other.SrcRect && self.NumSourceSurfaces == other.NumSourceSurfaces && self.Alpha == other.Alpha && self.Source == other.Source
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DXVA_DeinterlaceBlt {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DXVA_DeinterlaceBlt {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct DXVA_DeinterlaceBltEx {
    pub Size: u32,
    pub BackgroundColor: DXVA_AYUVsample2,
    pub rcTarget: super::super::Foundation::RECT,
    pub rtTarget: i64,
    pub NumSourceSurfaces: u32,
    pub Alpha: f32,
    pub Source: [DXVA_VideoSample2; 32],
    pub DestinationFormat: u32,
    pub DestinationFlags: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DXVA_DeinterlaceBltEx {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DXVA_DeinterlaceBltEx {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DXVA_DeinterlaceBltEx {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_DeinterlaceBltEx").field("Size", &self.Size).field("BackgroundColor", &self.BackgroundColor).field("rcTarget", &self.rcTarget).field("rtTarget", &self.rtTarget).field("NumSourceSurfaces", &self.NumSourceSurfaces).field("Alpha", &self.Alpha).field("Source", &self.Source).field("DestinationFormat", &self.DestinationFormat).field("DestinationFlags", &self.DestinationFlags).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for DXVA_DeinterlaceBltEx {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DXVA_DeinterlaceBltEx {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.BackgroundColor == other.BackgroundColor && self.rcTarget == other.rcTarget && self.rtTarget == other.rtTarget && self.NumSourceSurfaces == other.NumSourceSurfaces && self.Alpha == other.Alpha && self.Source == other.Source && self.DestinationFormat == other.DestinationFormat && self.DestinationFlags == other.DestinationFlags
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DXVA_DeinterlaceBltEx {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DXVA_DeinterlaceBltEx {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
pub struct DXVA_DeinterlaceBltEx32 {
    pub Size: u32,
    pub BackgroundColor: DXVA_AYUVsample2,
    pub rcTarget: super::super::Foundation::RECT,
    pub rtTarget: i64,
    pub NumSourceSurfaces: u32,
    pub Alpha: f32,
    pub Source: [DXVA_VideoSample32; 32],
    pub DestinationFormat: u32,
    pub DestinationFlags: u32,
}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DXVA_DeinterlaceBltEx32 {}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DXVA_DeinterlaceBltEx32 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DXVA_DeinterlaceBltEx32 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_DeinterlaceBltEx32").field("Size", &self.Size).field("BackgroundColor", &self.BackgroundColor).field("rcTarget", &self.rcTarget).field("rtTarget", &self.rtTarget).field("NumSourceSurfaces", &self.NumSourceSurfaces).field("Alpha", &self.Alpha).field("Source", &self.Source).field("DestinationFormat", &self.DestinationFormat).field("DestinationFlags", &self.DestinationFlags).finish()
    }
}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for DXVA_DeinterlaceBltEx32 {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DXVA_DeinterlaceBltEx32 {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.BackgroundColor == other.BackgroundColor && self.rcTarget == other.rcTarget && self.rtTarget == other.rtTarget && self.NumSourceSurfaces == other.NumSourceSurfaces && self.Alpha == other.Alpha && self.Source == other.Source && self.DestinationFormat == other.DestinationFormat && self.DestinationFlags == other.DestinationFlags
    }
}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DXVA_DeinterlaceBltEx32 {}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DXVA_DeinterlaceBltEx32 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct DXVA_DeinterlaceCaps {
    pub Size: u32,
    pub NumPreviousOutputFrames: u32,
    pub InputPool: u32,
    pub NumForwardRefSamples: u32,
    pub NumBackwardRefSamples: u32,
    pub d3dOutputFormat: super::super::Graphics::Direct3D9::D3DFORMAT,
    pub VideoProcessingCaps: DXVA_VideoProcessCaps,
    pub DeinterlaceTechnology: DXVA_DeinterlaceTech,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::marker::Copy for DXVA_DeinterlaceCaps {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::clone::Clone for DXVA_DeinterlaceCaps {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::fmt::Debug for DXVA_DeinterlaceCaps {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_DeinterlaceCaps").field("Size", &self.Size).field("NumPreviousOutputFrames", &self.NumPreviousOutputFrames).field("InputPool", &self.InputPool).field("NumForwardRefSamples", &self.NumForwardRefSamples).field("NumBackwardRefSamples", &self.NumBackwardRefSamples).field("d3dOutputFormat", &self.d3dOutputFormat).field("VideoProcessingCaps", &self.VideoProcessingCaps).field("DeinterlaceTechnology", &self.DeinterlaceTechnology).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::windows::core::TypeKind for DXVA_DeinterlaceCaps {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::cmp::PartialEq for DXVA_DeinterlaceCaps {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.NumPreviousOutputFrames == other.NumPreviousOutputFrames && self.InputPool == other.InputPool && self.NumForwardRefSamples == other.NumForwardRefSamples && self.NumBackwardRefSamples == other.NumBackwardRefSamples && self.d3dOutputFormat == other.d3dOutputFormat && self.VideoProcessingCaps == other.VideoProcessingCaps && self.DeinterlaceTechnology == other.DeinterlaceTechnology
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::cmp::Eq for DXVA_DeinterlaceCaps {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::default::Default for DXVA_DeinterlaceCaps {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA_DeinterlaceQueryAvailableModes {
    pub Size: u32,
    pub NumGuids: u32,
    pub Guids: [::windows::core::GUID; 32],
}
impl ::core::marker::Copy for DXVA_DeinterlaceQueryAvailableModes {}
impl ::core::clone::Clone for DXVA_DeinterlaceQueryAvailableModes {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVA_DeinterlaceQueryAvailableModes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_DeinterlaceQueryAvailableModes").field("Size", &self.Size).field("NumGuids", &self.NumGuids).field("Guids", &self.Guids).finish()
    }
}
impl ::windows::core::TypeKind for DXVA_DeinterlaceQueryAvailableModes {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVA_DeinterlaceQueryAvailableModes {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.NumGuids == other.NumGuids && self.Guids == other.Guids
    }
}
impl ::core::cmp::Eq for DXVA_DeinterlaceQueryAvailableModes {}
impl ::core::default::Default for DXVA_DeinterlaceQueryAvailableModes {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct DXVA_DeinterlaceQueryModeCaps {
    pub Size: u32,
    pub Guid: ::windows::core::GUID,
    pub VideoDesc: DXVA_VideoDesc,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::marker::Copy for DXVA_DeinterlaceQueryModeCaps {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::clone::Clone for DXVA_DeinterlaceQueryModeCaps {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::fmt::Debug for DXVA_DeinterlaceQueryModeCaps {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_DeinterlaceQueryModeCaps").field("Size", &self.Size).field("Guid", &self.Guid).field("VideoDesc", &self.VideoDesc).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::windows::core::TypeKind for DXVA_DeinterlaceQueryModeCaps {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::cmp::PartialEq for DXVA_DeinterlaceQueryModeCaps {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.Guid == other.Guid && self.VideoDesc == other.VideoDesc
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::cmp::Eq for DXVA_DeinterlaceQueryModeCaps {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::default::Default for DXVA_DeinterlaceQueryModeCaps {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA_ExtendedFormat {
    pub _bitfield: u32,
}
impl ::core::marker::Copy for DXVA_ExtendedFormat {}
impl ::core::clone::Clone for DXVA_ExtendedFormat {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVA_ExtendedFormat {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_ExtendedFormat").field("_bitfield", &self._bitfield).finish()
    }
}
impl ::windows::core::TypeKind for DXVA_ExtendedFormat {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVA_ExtendedFormat {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::core::cmp::Eq for DXVA_ExtendedFormat {}
impl ::core::default::Default for DXVA_ExtendedFormat {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA_Frequency {
    pub Numerator: u32,
    pub Denominator: u32,
}
impl ::core::marker::Copy for DXVA_Frequency {}
impl ::core::clone::Clone for DXVA_Frequency {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVA_Frequency {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_Frequency").field("Numerator", &self.Numerator).field("Denominator", &self.Denominator).finish()
    }
}
impl ::windows::core::TypeKind for DXVA_Frequency {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVA_Frequency {
    fn eq(&self, other: &Self) -> bool {
        self.Numerator == other.Numerator && self.Denominator == other.Denominator
    }
}
impl ::core::cmp::Eq for DXVA_Frequency {}
impl ::core::default::Default for DXVA_Frequency {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA_PictureParameters {
    pub wDecodedPictureIndex: u16,
    pub wDeblockedPictureIndex: u16,
    pub wForwardRefPictureIndex: u16,
    pub wBackwardRefPictureIndex: u16,
    pub wPicWidthInMBminus1: u16,
    pub wPicHeightInMBminus1: u16,
    pub bMacroblockWidthMinus1: u8,
    pub bMacroblockHeightMinus1: u8,
    pub bBlockWidthMinus1: u8,
    pub bBlockHeightMinus1: u8,
    pub bBPPminus1: u8,
    pub bPicStructure: u8,
    pub bSecondField: u8,
    pub bPicIntra: u8,
    pub bPicBackwardPrediction: u8,
    pub bBidirectionalAveragingMode: u8,
    pub bMVprecisionAndChromaRelation: u8,
    pub bChromaFormat: u8,
    pub bPicScanFixed: u8,
    pub bPicScanMethod: u8,
    pub bPicReadbackRequests: u8,
    pub bRcontrol: u8,
    pub bPicSpatialResid8: u8,
    pub bPicOverflowBlocks: u8,
    pub bPicExtrapolation: u8,
    pub bPicDeblocked: u8,
    pub bPicDeblockConfined: u8,
    pub bPic4MVallowed: u8,
    pub bPicOBMC: u8,
    pub bPicBinPB: u8,
    pub bMV_RPS: u8,
    pub bReservedBits: u8,
    pub wBitstreamFcodes: u16,
    pub wBitstreamPCEelements: u16,
    pub bBitstreamConcealmentNeed: u8,
    pub bBitstreamConcealmentMethod: u8,
}
impl ::core::marker::Copy for DXVA_PictureParameters {}
impl ::core::clone::Clone for DXVA_PictureParameters {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for DXVA_PictureParameters {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for DXVA_PictureParameters {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct DXVA_ProcAmpControlBlt {
    pub Size: u32,
    pub DstRect: super::super::Foundation::RECT,
    pub SrcRect: super::super::Foundation::RECT,
    pub Alpha: f32,
    pub Brightness: f32,
    pub Contrast: f32,
    pub Hue: f32,
    pub Saturation: f32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DXVA_ProcAmpControlBlt {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DXVA_ProcAmpControlBlt {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DXVA_ProcAmpControlBlt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_ProcAmpControlBlt").field("Size", &self.Size).field("DstRect", &self.DstRect).field("SrcRect", &self.SrcRect).field("Alpha", &self.Alpha).field("Brightness", &self.Brightness).field("Contrast", &self.Contrast).field("Hue", &self.Hue).field("Saturation", &self.Saturation).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for DXVA_ProcAmpControlBlt {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DXVA_ProcAmpControlBlt {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.DstRect == other.DstRect && self.SrcRect == other.SrcRect && self.Alpha == other.Alpha && self.Brightness == other.Brightness && self.Contrast == other.Contrast && self.Hue == other.Hue && self.Saturation == other.Saturation
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DXVA_ProcAmpControlBlt {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DXVA_ProcAmpControlBlt {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct DXVA_ProcAmpControlCaps {
    pub Size: u32,
    pub InputPool: u32,
    pub d3dOutputFormat: super::super::Graphics::Direct3D9::D3DFORMAT,
    pub ProcAmpControlProps: u32,
    pub VideoProcessingCaps: u32,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::marker::Copy for DXVA_ProcAmpControlCaps {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::clone::Clone for DXVA_ProcAmpControlCaps {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::fmt::Debug for DXVA_ProcAmpControlCaps {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_ProcAmpControlCaps").field("Size", &self.Size).field("InputPool", &self.InputPool).field("d3dOutputFormat", &self.d3dOutputFormat).field("ProcAmpControlProps", &self.ProcAmpControlProps).field("VideoProcessingCaps", &self.VideoProcessingCaps).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::windows::core::TypeKind for DXVA_ProcAmpControlCaps {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::cmp::PartialEq for DXVA_ProcAmpControlCaps {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.InputPool == other.InputPool && self.d3dOutputFormat == other.d3dOutputFormat && self.ProcAmpControlProps == other.ProcAmpControlProps && self.VideoProcessingCaps == other.VideoProcessingCaps
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::cmp::Eq for DXVA_ProcAmpControlCaps {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::default::Default for DXVA_ProcAmpControlCaps {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct DXVA_ProcAmpControlQueryRange {
    pub Size: u32,
    pub ProcAmpControlProp: DXVA_ProcAmpControlProp,
    pub VideoDesc: DXVA_VideoDesc,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::marker::Copy for DXVA_ProcAmpControlQueryRange {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::clone::Clone for DXVA_ProcAmpControlQueryRange {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::fmt::Debug for DXVA_ProcAmpControlQueryRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_ProcAmpControlQueryRange").field("Size", &self.Size).field("ProcAmpControlProp", &self.ProcAmpControlProp).field("VideoDesc", &self.VideoDesc).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::windows::core::TypeKind for DXVA_ProcAmpControlQueryRange {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::cmp::PartialEq for DXVA_ProcAmpControlQueryRange {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.ProcAmpControlProp == other.ProcAmpControlProp && self.VideoDesc == other.VideoDesc
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::cmp::Eq for DXVA_ProcAmpControlQueryRange {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::default::Default for DXVA_ProcAmpControlQueryRange {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct DXVA_VideoDesc {
    pub Size: u32,
    pub SampleWidth: u32,
    pub SampleHeight: u32,
    pub SampleFormat: u32,
    pub d3dFormat: super::super::Graphics::Direct3D9::D3DFORMAT,
    pub InputSampleFreq: DXVA_Frequency,
    pub OutputFrameFreq: DXVA_Frequency,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::marker::Copy for DXVA_VideoDesc {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::clone::Clone for DXVA_VideoDesc {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::fmt::Debug for DXVA_VideoDesc {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_VideoDesc").field("Size", &self.Size).field("SampleWidth", &self.SampleWidth).field("SampleHeight", &self.SampleHeight).field("SampleFormat", &self.SampleFormat).field("d3dFormat", &self.d3dFormat).field("InputSampleFreq", &self.InputSampleFreq).field("OutputFrameFreq", &self.OutputFrameFreq).finish()
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::windows::core::TypeKind for DXVA_VideoDesc {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::cmp::PartialEq for DXVA_VideoDesc {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.SampleWidth == other.SampleWidth && self.SampleHeight == other.SampleHeight && self.SampleFormat == other.SampleFormat && self.d3dFormat == other.d3dFormat && self.InputSampleFreq == other.InputSampleFreq && self.OutputFrameFreq == other.OutputFrameFreq
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::cmp::Eq for DXVA_VideoDesc {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::default::Default for DXVA_VideoDesc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA_VideoPropertyRange {
    pub MinValue: f32,
    pub MaxValue: f32,
    pub DefaultValue: f32,
    pub StepSize: f32,
}
impl ::core::marker::Copy for DXVA_VideoPropertyRange {}
impl ::core::clone::Clone for DXVA_VideoPropertyRange {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVA_VideoPropertyRange {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_VideoPropertyRange").field("MinValue", &self.MinValue).field("MaxValue", &self.MaxValue).field("DefaultValue", &self.DefaultValue).field("StepSize", &self.StepSize).finish()
    }
}
impl ::windows::core::TypeKind for DXVA_VideoPropertyRange {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVA_VideoPropertyRange {
    fn eq(&self, other: &Self) -> bool {
        self.MinValue == other.MinValue && self.MaxValue == other.MaxValue && self.DefaultValue == other.DefaultValue && self.StepSize == other.StepSize
    }
}
impl ::core::cmp::Eq for DXVA_VideoPropertyRange {}
impl ::core::default::Default for DXVA_VideoPropertyRange {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DXVA_VideoSample {
    pub rtStart: i64,
    pub rtEnd: i64,
    pub SampleFormat: DXVA_SampleFormat,
    pub lpDDSSrcSurface: *mut ::core::ffi::c_void,
}
impl ::core::marker::Copy for DXVA_VideoSample {}
impl ::core::clone::Clone for DXVA_VideoSample {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DXVA_VideoSample {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_VideoSample").field("rtStart", &self.rtStart).field("rtEnd", &self.rtEnd).field("SampleFormat", &self.SampleFormat).field("lpDDSSrcSurface", &self.lpDDSSrcSurface).finish()
    }
}
impl ::windows::core::TypeKind for DXVA_VideoSample {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DXVA_VideoSample {
    fn eq(&self, other: &Self) -> bool {
        self.rtStart == other.rtStart && self.rtEnd == other.rtEnd && self.SampleFormat == other.SampleFormat && self.lpDDSSrcSurface == other.lpDDSSrcSurface
    }
}
impl ::core::cmp::Eq for DXVA_VideoSample {}
impl ::core::default::Default for DXVA_VideoSample {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
pub struct DXVA_VideoSample2 {
    pub Size: u32,
    pub Reserved: u32,
    pub rtStart: i64,
    pub rtEnd: i64,
    pub SampleFormat: u32,
    pub SampleFlags: u32,
    pub lpDDSSrcSurface: *mut ::core::ffi::c_void,
    pub rcSrc: super::super::Foundation::RECT,
    pub rcDst: super::super::Foundation::RECT,
    pub Palette: [DXVA_AYUVsample2; 16],
}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DXVA_VideoSample2 {}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DXVA_VideoSample2 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DXVA_VideoSample2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_VideoSample2").field("Size", &self.Size).field("Reserved", &self.Reserved).field("rtStart", &self.rtStart).field("rtEnd", &self.rtEnd).field("SampleFormat", &self.SampleFormat).field("SampleFlags", &self.SampleFlags).field("lpDDSSrcSurface", &self.lpDDSSrcSurface).field("rcSrc", &self.rcSrc).field("rcDst", &self.rcDst).field("Palette", &self.Palette).finish()
    }
}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for DXVA_VideoSample2 {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DXVA_VideoSample2 {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.Reserved == other.Reserved && self.rtStart == other.rtStart && self.rtEnd == other.rtEnd && self.SampleFormat == other.SampleFormat && self.SampleFlags == other.SampleFlags && self.lpDDSSrcSurface == other.lpDDSSrcSurface && self.rcSrc == other.rcSrc && self.rcDst == other.rcDst && self.Palette == other.Palette
    }
}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DXVA_VideoSample2 {}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DXVA_VideoSample2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(target_arch = "x86")]
#[cfg(feature = "Win32_Foundation")]
pub struct DXVA_VideoSample2 {
    pub rtStart: i64,
    pub rtEnd: i64,
    pub SampleFormat: u32,
    pub SampleFlags: u32,
    pub lpDDSSrcSurface: *mut ::core::ffi::c_void,
    pub rcSrc: super::super::Foundation::RECT,
    pub rcDst: super::super::Foundation::RECT,
    pub Palette: [DXVA_AYUVsample2; 16],
}
#[cfg(target_arch = "x86")]
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DXVA_VideoSample2 {}
#[cfg(target_arch = "x86")]
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DXVA_VideoSample2 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(target_arch = "x86")]
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DXVA_VideoSample2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_VideoSample2").field("rtStart", &self.rtStart).field("rtEnd", &self.rtEnd).field("SampleFormat", &self.SampleFormat).field("SampleFlags", &self.SampleFlags).field("lpDDSSrcSurface", &self.lpDDSSrcSurface).field("rcSrc", &self.rcSrc).field("rcDst", &self.rcDst).field("Palette", &self.Palette).finish()
    }
}
#[cfg(target_arch = "x86")]
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for DXVA_VideoSample2 {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(target_arch = "x86")]
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DXVA_VideoSample2 {
    fn eq(&self, other: &Self) -> bool {
        self.rtStart == other.rtStart && self.rtEnd == other.rtEnd && self.SampleFormat == other.SampleFormat && self.SampleFlags == other.SampleFlags && self.lpDDSSrcSurface == other.lpDDSSrcSurface && self.rcSrc == other.rcSrc && self.rcDst == other.rcDst && self.Palette == other.Palette
    }
}
#[cfg(target_arch = "x86")]
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DXVA_VideoSample2 {}
#[cfg(target_arch = "x86")]
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DXVA_VideoSample2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
pub struct DXVA_VideoSample32 {
    pub rtStart: i64,
    pub rtEnd: i64,
    pub SampleFormat: u32,
    pub SampleFlags: u32,
    pub lpDDSSrcSurface: u32,
    pub rcSrc: super::super::Foundation::RECT,
    pub rcDst: super::super::Foundation::RECT,
    pub Palette: [DXVA_AYUVsample2; 16],
}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DXVA_VideoSample32 {}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DXVA_VideoSample32 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DXVA_VideoSample32 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DXVA_VideoSample32").field("rtStart", &self.rtStart).field("rtEnd", &self.rtEnd).field("SampleFormat", &self.SampleFormat).field("SampleFlags", &self.SampleFlags).field("lpDDSSrcSurface", &self.lpDDSSrcSurface).field("rcSrc", &self.rcSrc).field("rcDst", &self.rcDst).field("Palette", &self.Palette).finish()
    }
}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for DXVA_VideoSample32 {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DXVA_VideoSample32 {
    fn eq(&self, other: &Self) -> bool {
        self.rtStart == other.rtStart && self.rtEnd == other.rtEnd && self.SampleFormat == other.SampleFormat && self.SampleFlags == other.SampleFlags && self.lpDDSSrcSurface == other.lpDDSSrcSurface && self.rcSrc == other.rcSrc && self.rcDst == other.rcDst && self.Palette == other.Palette
    }
}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DXVA_VideoSample32 {}
#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DXVA_VideoSample32 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct DigitalWindowSetting {
    pub OriginX: f64,
    pub OriginY: f64,
    pub WindowSize: f64,
}
impl ::core::marker::Copy for DigitalWindowSetting {}
impl ::core::clone::Clone for DigitalWindowSetting {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DigitalWindowSetting {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DigitalWindowSetting").field("OriginX", &self.OriginX).field("OriginY", &self.OriginY).field("WindowSize", &self.WindowSize).finish()
    }
}
impl ::windows::core::TypeKind for DigitalWindowSetting {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for DigitalWindowSetting {
    fn eq(&self, other: &Self) -> bool {
        self.OriginX == other.OriginX && self.OriginY == other.OriginY && self.WindowSize == other.WindowSize
    }
}
impl ::core::cmp::Eq for DigitalWindowSetting {}
impl ::core::default::Default for DigitalWindowSetting {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MACROBLOCK_DATA {
    pub flags: u32,
    pub motionVectorX: i16,
    pub motionVectorY: i16,
    pub QPDelta: i32,
}
impl ::core::marker::Copy for MACROBLOCK_DATA {}
impl ::core::clone::Clone for MACROBLOCK_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MACROBLOCK_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MACROBLOCK_DATA").field("flags", &self.flags).field("motionVectorX", &self.motionVectorX).field("motionVectorY", &self.motionVectorY).field("QPDelta", &self.QPDelta).finish()
    }
}
impl ::windows::core::TypeKind for MACROBLOCK_DATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MACROBLOCK_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.flags == other.flags && self.motionVectorX == other.motionVectorX && self.motionVectorY == other.motionVectorY && self.QPDelta == other.QPDelta
    }
}
impl ::core::cmp::Eq for MACROBLOCK_DATA {}
impl ::core::default::Default for MACROBLOCK_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFARGB {
    pub rgbBlue: u8,
    pub rgbGreen: u8,
    pub rgbRed: u8,
    pub rgbAlpha: u8,
}
impl ::core::marker::Copy for MFARGB {}
impl ::core::clone::Clone for MFARGB {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFARGB {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFARGB").field("rgbBlue", &self.rgbBlue).field("rgbGreen", &self.rgbGreen).field("rgbRed", &self.rgbRed).field("rgbAlpha", &self.rgbAlpha).finish()
    }
}
impl ::windows::core::TypeKind for MFARGB {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFARGB {
    fn eq(&self, other: &Self) -> bool {
        self.rgbBlue == other.rgbBlue && self.rgbGreen == other.rgbGreen && self.rgbRed == other.rgbRed && self.rgbAlpha == other.rgbAlpha
    }
}
impl ::core::cmp::Eq for MFARGB {}
impl ::core::default::Default for MFARGB {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFAYUVSample {
    pub bCrValue: u8,
    pub bCbValue: u8,
    pub bYValue: u8,
    pub bSampleAlpha8: u8,
}
impl ::core::marker::Copy for MFAYUVSample {}
impl ::core::clone::Clone for MFAYUVSample {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFAYUVSample {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFAYUVSample").field("bCrValue", &self.bCrValue).field("bCbValue", &self.bCbValue).field("bYValue", &self.bYValue).field("bSampleAlpha8", &self.bSampleAlpha8).finish()
    }
}
impl ::windows::core::TypeKind for MFAYUVSample {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFAYUVSample {
    fn eq(&self, other: &Self) -> bool {
        self.bCrValue == other.bCrValue && self.bCbValue == other.bCbValue && self.bYValue == other.bYValue && self.bSampleAlpha8 == other.bSampleAlpha8
    }
}
impl ::core::cmp::Eq for MFAYUVSample {}
impl ::core::default::Default for MFAYUVSample {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFAudioDecoderDegradationInfo {
    pub eDegradationReason: MFT_AUDIO_DECODER_DEGRADATION_REASON,
    pub eType: MFT_AUDIO_DECODER_DEGRADATION_TYPE,
}
impl ::core::marker::Copy for MFAudioDecoderDegradationInfo {}
impl ::core::clone::Clone for MFAudioDecoderDegradationInfo {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFAudioDecoderDegradationInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFAudioDecoderDegradationInfo").field("eDegradationReason", &self.eDegradationReason).field("eType", &self.eType).finish()
    }
}
impl ::windows::core::TypeKind for MFAudioDecoderDegradationInfo {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFAudioDecoderDegradationInfo {
    fn eq(&self, other: &Self) -> bool {
        self.eDegradationReason == other.eDegradationReason && self.eType == other.eType
    }
}
impl ::core::cmp::Eq for MFAudioDecoderDegradationInfo {}
impl ::core::default::Default for MFAudioDecoderDegradationInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFBYTESTREAM_BUFFERING_PARAMS {
    pub cbTotalFileSize: u64,
    pub cbPlayableDataSize: u64,
    pub prgBuckets: *mut MF_LEAKY_BUCKET_PAIR,
    pub cBuckets: u32,
    pub qwNetBufferingTime: u64,
    pub qwExtraBufferingTimeDuringSeek: u64,
    pub qwPlayDuration: u64,
    pub dRate: f32,
}
impl ::core::marker::Copy for MFBYTESTREAM_BUFFERING_PARAMS {}
impl ::core::clone::Clone for MFBYTESTREAM_BUFFERING_PARAMS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFBYTESTREAM_BUFFERING_PARAMS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFBYTESTREAM_BUFFERING_PARAMS").field("cbTotalFileSize", &self.cbTotalFileSize).field("cbPlayableDataSize", &self.cbPlayableDataSize).field("prgBuckets", &self.prgBuckets).field("cBuckets", &self.cBuckets).field("qwNetBufferingTime", &self.qwNetBufferingTime).field("qwExtraBufferingTimeDuringSeek", &self.qwExtraBufferingTimeDuringSeek).field("qwPlayDuration", &self.qwPlayDuration).field("dRate", &self.dRate).finish()
    }
}
impl ::windows::core::TypeKind for MFBYTESTREAM_BUFFERING_PARAMS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFBYTESTREAM_BUFFERING_PARAMS {
    fn eq(&self, other: &Self) -> bool {
        self.cbTotalFileSize == other.cbTotalFileSize && self.cbPlayableDataSize == other.cbPlayableDataSize && self.prgBuckets == other.prgBuckets && self.cBuckets == other.cBuckets && self.qwNetBufferingTime == other.qwNetBufferingTime && self.qwExtraBufferingTimeDuringSeek == other.qwExtraBufferingTimeDuringSeek && self.qwPlayDuration == other.qwPlayDuration && self.dRate == other.dRate
    }
}
impl ::core::cmp::Eq for MFBYTESTREAM_BUFFERING_PARAMS {}
impl ::core::default::Default for MFBYTESTREAM_BUFFERING_PARAMS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFCLOCK_PROPERTIES {
    pub qwCorrelationRate: u64,
    pub guidClockId: ::windows::core::GUID,
    pub dwClockFlags: u32,
    pub qwClockFrequency: u64,
    pub dwClockTolerance: u32,
    pub dwClockJitter: u32,
}
impl ::core::marker::Copy for MFCLOCK_PROPERTIES {}
impl ::core::clone::Clone for MFCLOCK_PROPERTIES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFCLOCK_PROPERTIES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFCLOCK_PROPERTIES").field("qwCorrelationRate", &self.qwCorrelationRate).field("guidClockId", &self.guidClockId).field("dwClockFlags", &self.dwClockFlags).field("qwClockFrequency", &self.qwClockFrequency).field("dwClockTolerance", &self.dwClockTolerance).field("dwClockJitter", &self.dwClockJitter).finish()
    }
}
impl ::windows::core::TypeKind for MFCLOCK_PROPERTIES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFCLOCK_PROPERTIES {
    fn eq(&self, other: &Self) -> bool {
        self.qwCorrelationRate == other.qwCorrelationRate && self.guidClockId == other.guidClockId && self.dwClockFlags == other.dwClockFlags && self.qwClockFrequency == other.qwClockFrequency && self.dwClockTolerance == other.dwClockTolerance && self.dwClockJitter == other.dwClockJitter
    }
}
impl ::core::cmp::Eq for MFCLOCK_PROPERTIES {}
impl ::core::default::Default for MFCLOCK_PROPERTIES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFCONTENTPROTECTIONDEVICE_INPUT_DATA {
    pub HWProtectionFunctionID: u32,
    pub PrivateDataByteCount: u32,
    pub HWProtectionDataByteCount: u32,
    pub Reserved: u32,
    pub InputData: [u8; 4],
}
impl ::core::marker::Copy for MFCONTENTPROTECTIONDEVICE_INPUT_DATA {}
impl ::core::clone::Clone for MFCONTENTPROTECTIONDEVICE_INPUT_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFCONTENTPROTECTIONDEVICE_INPUT_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFCONTENTPROTECTIONDEVICE_INPUT_DATA").field("HWProtectionFunctionID", &self.HWProtectionFunctionID).field("PrivateDataByteCount", &self.PrivateDataByteCount).field("HWProtectionDataByteCount", &self.HWProtectionDataByteCount).field("Reserved", &self.Reserved).field("InputData", &self.InputData).finish()
    }
}
impl ::windows::core::TypeKind for MFCONTENTPROTECTIONDEVICE_INPUT_DATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFCONTENTPROTECTIONDEVICE_INPUT_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.HWProtectionFunctionID == other.HWProtectionFunctionID && self.PrivateDataByteCount == other.PrivateDataByteCount && self.HWProtectionDataByteCount == other.HWProtectionDataByteCount && self.Reserved == other.Reserved && self.InputData == other.InputData
    }
}
impl ::core::cmp::Eq for MFCONTENTPROTECTIONDEVICE_INPUT_DATA {}
impl ::core::default::Default for MFCONTENTPROTECTIONDEVICE_INPUT_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFCONTENTPROTECTIONDEVICE_OUTPUT_DATA {
    pub PrivateDataByteCount: u32,
    pub MaxHWProtectionDataByteCount: u32,
    pub HWProtectionDataByteCount: u32,
    pub Status: ::windows::core::HRESULT,
    pub TransportTimeInHundredsOfNanoseconds: i64,
    pub ExecutionTimeInHundredsOfNanoseconds: i64,
    pub OutputData: [u8; 4],
}
impl ::core::marker::Copy for MFCONTENTPROTECTIONDEVICE_OUTPUT_DATA {}
impl ::core::clone::Clone for MFCONTENTPROTECTIONDEVICE_OUTPUT_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFCONTENTPROTECTIONDEVICE_OUTPUT_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFCONTENTPROTECTIONDEVICE_OUTPUT_DATA")
            .field("PrivateDataByteCount", &self.PrivateDataByteCount)
            .field("MaxHWProtectionDataByteCount", &self.MaxHWProtectionDataByteCount)
            .field("HWProtectionDataByteCount", &self.HWProtectionDataByteCount)
            .field("Status", &self.Status)
            .field("TransportTimeInHundredsOfNanoseconds", &self.TransportTimeInHundredsOfNanoseconds)
            .field("ExecutionTimeInHundredsOfNanoseconds", &self.ExecutionTimeInHundredsOfNanoseconds)
            .field("OutputData", &self.OutputData)
            .finish()
    }
}
impl ::windows::core::TypeKind for MFCONTENTPROTECTIONDEVICE_OUTPUT_DATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFCONTENTPROTECTIONDEVICE_OUTPUT_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.PrivateDataByteCount == other.PrivateDataByteCount && self.MaxHWProtectionDataByteCount == other.MaxHWProtectionDataByteCount && self.HWProtectionDataByteCount == other.HWProtectionDataByteCount && self.Status == other.Status && self.TransportTimeInHundredsOfNanoseconds == other.TransportTimeInHundredsOfNanoseconds && self.ExecutionTimeInHundredsOfNanoseconds == other.ExecutionTimeInHundredsOfNanoseconds && self.OutputData == other.OutputData
    }
}
impl ::core::cmp::Eq for MFCONTENTPROTECTIONDEVICE_OUTPUT_DATA {}
impl ::core::default::Default for MFCONTENTPROTECTIONDEVICE_OUTPUT_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFCONTENTPROTECTIONDEVICE_REALTIMECLIENT_DATA {
    pub TaskIndex: u32,
    pub ClassName: [u16; 260],
    pub BasePriority: i32,
}
impl ::core::marker::Copy for MFCONTENTPROTECTIONDEVICE_REALTIMECLIENT_DATA {}
impl ::core::clone::Clone for MFCONTENTPROTECTIONDEVICE_REALTIMECLIENT_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFCONTENTPROTECTIONDEVICE_REALTIMECLIENT_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFCONTENTPROTECTIONDEVICE_REALTIMECLIENT_DATA").field("TaskIndex", &self.TaskIndex).field("ClassName", &self.ClassName).field("BasePriority", &self.BasePriority).finish()
    }
}
impl ::windows::core::TypeKind for MFCONTENTPROTECTIONDEVICE_REALTIMECLIENT_DATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFCONTENTPROTECTIONDEVICE_REALTIMECLIENT_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.TaskIndex == other.TaskIndex && self.ClassName == other.ClassName && self.BasePriority == other.BasePriority
    }
}
impl ::core::cmp::Eq for MFCONTENTPROTECTIONDEVICE_REALTIMECLIENT_DATA {}
impl ::core::default::Default for MFCONTENTPROTECTIONDEVICE_REALTIMECLIENT_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFCameraExtrinsic_CalibratedTransform {
    pub CalibrationId: ::windows::core::GUID,
    pub Position: MF_FLOAT3,
    pub Orientation: MF_QUATERNION,
}
impl ::core::marker::Copy for MFCameraExtrinsic_CalibratedTransform {}
impl ::core::clone::Clone for MFCameraExtrinsic_CalibratedTransform {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFCameraExtrinsic_CalibratedTransform {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFCameraExtrinsic_CalibratedTransform").field("CalibrationId", &self.CalibrationId).field("Position", &self.Position).field("Orientation", &self.Orientation).finish()
    }
}
impl ::windows::core::TypeKind for MFCameraExtrinsic_CalibratedTransform {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFCameraExtrinsic_CalibratedTransform {
    fn eq(&self, other: &Self) -> bool {
        self.CalibrationId == other.CalibrationId && self.Position == other.Position && self.Orientation == other.Orientation
    }
}
impl ::core::cmp::Eq for MFCameraExtrinsic_CalibratedTransform {}
impl ::core::default::Default for MFCameraExtrinsic_CalibratedTransform {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFCameraExtrinsics {
    pub TransformCount: u32,
    pub CalibratedTransforms: [MFCameraExtrinsic_CalibratedTransform; 1],
}
impl ::core::marker::Copy for MFCameraExtrinsics {}
impl ::core::clone::Clone for MFCameraExtrinsics {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFCameraExtrinsics {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFCameraExtrinsics").field("TransformCount", &self.TransformCount).field("CalibratedTransforms", &self.CalibratedTransforms).finish()
    }
}
impl ::windows::core::TypeKind for MFCameraExtrinsics {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFCameraExtrinsics {
    fn eq(&self, other: &Self) -> bool {
        self.TransformCount == other.TransformCount && self.CalibratedTransforms == other.CalibratedTransforms
    }
}
impl ::core::cmp::Eq for MFCameraExtrinsics {}
impl ::core::default::Default for MFCameraExtrinsics {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFCameraIntrinsic_CameraModel {
    pub FocalLength_x: f32,
    pub FocalLength_y: f32,
    pub PrincipalPoint_x: f32,
    pub PrincipalPoint_y: f32,
}
impl ::core::marker::Copy for MFCameraIntrinsic_CameraModel {}
impl ::core::clone::Clone for MFCameraIntrinsic_CameraModel {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFCameraIntrinsic_CameraModel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFCameraIntrinsic_CameraModel").field("FocalLength_x", &self.FocalLength_x).field("FocalLength_y", &self.FocalLength_y).field("PrincipalPoint_x", &self.PrincipalPoint_x).field("PrincipalPoint_y", &self.PrincipalPoint_y).finish()
    }
}
impl ::windows::core::TypeKind for MFCameraIntrinsic_CameraModel {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFCameraIntrinsic_CameraModel {
    fn eq(&self, other: &Self) -> bool {
        self.FocalLength_x == other.FocalLength_x && self.FocalLength_y == other.FocalLength_y && self.PrincipalPoint_x == other.PrincipalPoint_x && self.PrincipalPoint_y == other.PrincipalPoint_y
    }
}
impl ::core::cmp::Eq for MFCameraIntrinsic_CameraModel {}
impl ::core::default::Default for MFCameraIntrinsic_CameraModel {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFCameraIntrinsic_DistortionModel {
    pub Radial_k1: f32,
    pub Radial_k2: f32,
    pub Radial_k3: f32,
    pub Tangential_p1: f32,
    pub Tangential_p2: f32,
}
impl ::core::marker::Copy for MFCameraIntrinsic_DistortionModel {}
impl ::core::clone::Clone for MFCameraIntrinsic_DistortionModel {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFCameraIntrinsic_DistortionModel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFCameraIntrinsic_DistortionModel").field("Radial_k1", &self.Radial_k1).field("Radial_k2", &self.Radial_k2).field("Radial_k3", &self.Radial_k3).field("Tangential_p1", &self.Tangential_p1).field("Tangential_p2", &self.Tangential_p2).finish()
    }
}
impl ::windows::core::TypeKind for MFCameraIntrinsic_DistortionModel {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFCameraIntrinsic_DistortionModel {
    fn eq(&self, other: &Self) -> bool {
        self.Radial_k1 == other.Radial_k1 && self.Radial_k2 == other.Radial_k2 && self.Radial_k3 == other.Radial_k3 && self.Tangential_p1 == other.Tangential_p1 && self.Tangential_p2 == other.Tangential_p2
    }
}
impl ::core::cmp::Eq for MFCameraIntrinsic_DistortionModel {}
impl ::core::default::Default for MFCameraIntrinsic_DistortionModel {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFCameraIntrinsic_DistortionModel6KT {
    pub Radial_k1: f32,
    pub Radial_k2: f32,
    pub Radial_k3: f32,
    pub Radial_k4: f32,
    pub Radial_k5: f32,
    pub Radial_k6: f32,
    pub Tangential_p1: f32,
    pub Tangential_p2: f32,
}
impl ::core::marker::Copy for MFCameraIntrinsic_DistortionModel6KT {}
impl ::core::clone::Clone for MFCameraIntrinsic_DistortionModel6KT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFCameraIntrinsic_DistortionModel6KT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFCameraIntrinsic_DistortionModel6KT").field("Radial_k1", &self.Radial_k1).field("Radial_k2", &self.Radial_k2).field("Radial_k3", &self.Radial_k3).field("Radial_k4", &self.Radial_k4).field("Radial_k5", &self.Radial_k5).field("Radial_k6", &self.Radial_k6).field("Tangential_p1", &self.Tangential_p1).field("Tangential_p2", &self.Tangential_p2).finish()
    }
}
impl ::windows::core::TypeKind for MFCameraIntrinsic_DistortionModel6KT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFCameraIntrinsic_DistortionModel6KT {
    fn eq(&self, other: &Self) -> bool {
        self.Radial_k1 == other.Radial_k1 && self.Radial_k2 == other.Radial_k2 && self.Radial_k3 == other.Radial_k3 && self.Radial_k4 == other.Radial_k4 && self.Radial_k5 == other.Radial_k5 && self.Radial_k6 == other.Radial_k6 && self.Tangential_p1 == other.Tangential_p1 && self.Tangential_p2 == other.Tangential_p2
    }
}
impl ::core::cmp::Eq for MFCameraIntrinsic_DistortionModel6KT {}
impl ::core::default::Default for MFCameraIntrinsic_DistortionModel6KT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFCameraIntrinsic_DistortionModelArcTan {
    pub Radial_k0: f32,
    pub DistortionCenter_x: f32,
    pub DistortionCenter_y: f32,
    pub Tangential_x: f32,
    pub Tangential_y: f32,
}
impl ::core::marker::Copy for MFCameraIntrinsic_DistortionModelArcTan {}
impl ::core::clone::Clone for MFCameraIntrinsic_DistortionModelArcTan {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFCameraIntrinsic_DistortionModelArcTan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFCameraIntrinsic_DistortionModelArcTan").field("Radial_k0", &self.Radial_k0).field("DistortionCenter_x", &self.DistortionCenter_x).field("DistortionCenter_y", &self.DistortionCenter_y).field("Tangential_x", &self.Tangential_x).field("Tangential_y", &self.Tangential_y).finish()
    }
}
impl ::windows::core::TypeKind for MFCameraIntrinsic_DistortionModelArcTan {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFCameraIntrinsic_DistortionModelArcTan {
    fn eq(&self, other: &Self) -> bool {
        self.Radial_k0 == other.Radial_k0 && self.DistortionCenter_x == other.DistortionCenter_x && self.DistortionCenter_y == other.DistortionCenter_y && self.Tangential_x == other.Tangential_x && self.Tangential_y == other.Tangential_y
    }
}
impl ::core::cmp::Eq for MFCameraIntrinsic_DistortionModelArcTan {}
impl ::core::default::Default for MFCameraIntrinsic_DistortionModelArcTan {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFCameraIntrinsic_PinholeCameraModel {
    pub FocalLength: MF_FLOAT2,
    pub PrincipalPoint: MF_FLOAT2,
}
impl ::core::marker::Copy for MFCameraIntrinsic_PinholeCameraModel {}
impl ::core::clone::Clone for MFCameraIntrinsic_PinholeCameraModel {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFCameraIntrinsic_PinholeCameraModel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFCameraIntrinsic_PinholeCameraModel").field("FocalLength", &self.FocalLength).field("PrincipalPoint", &self.PrincipalPoint).finish()
    }
}
impl ::windows::core::TypeKind for MFCameraIntrinsic_PinholeCameraModel {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFCameraIntrinsic_PinholeCameraModel {
    fn eq(&self, other: &Self) -> bool {
        self.FocalLength == other.FocalLength && self.PrincipalPoint == other.PrincipalPoint
    }
}
impl ::core::cmp::Eq for MFCameraIntrinsic_PinholeCameraModel {}
impl ::core::default::Default for MFCameraIntrinsic_PinholeCameraModel {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFExtendedCameraIntrinsic_IntrinsicModel {
    pub Width: u32,
    pub Height: u32,
    pub SplitFrameId: u32,
    pub CameraModel: MFCameraIntrinsic_CameraModel,
}
impl ::core::marker::Copy for MFExtendedCameraIntrinsic_IntrinsicModel {}
impl ::core::clone::Clone for MFExtendedCameraIntrinsic_IntrinsicModel {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFExtendedCameraIntrinsic_IntrinsicModel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFExtendedCameraIntrinsic_IntrinsicModel").field("Width", &self.Width).field("Height", &self.Height).field("SplitFrameId", &self.SplitFrameId).field("CameraModel", &self.CameraModel).finish()
    }
}
impl ::windows::core::TypeKind for MFExtendedCameraIntrinsic_IntrinsicModel {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFExtendedCameraIntrinsic_IntrinsicModel {
    fn eq(&self, other: &Self) -> bool {
        self.Width == other.Width && self.Height == other.Height && self.SplitFrameId == other.SplitFrameId && self.CameraModel == other.CameraModel
    }
}
impl ::core::cmp::Eq for MFExtendedCameraIntrinsic_IntrinsicModel {}
impl ::core::default::Default for MFExtendedCameraIntrinsic_IntrinsicModel {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFFOLDDOWN_MATRIX {
    pub cbSize: u32,
    pub cSrcChannels: u32,
    pub cDstChannels: u32,
    pub dwChannelMask: u32,
    pub Coeff: [i32; 64],
}
impl ::core::marker::Copy for MFFOLDDOWN_MATRIX {}
impl ::core::clone::Clone for MFFOLDDOWN_MATRIX {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFFOLDDOWN_MATRIX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFFOLDDOWN_MATRIX").field("cbSize", &self.cbSize).field("cSrcChannels", &self.cSrcChannels).field("cDstChannels", &self.cDstChannels).field("dwChannelMask", &self.dwChannelMask).field("Coeff", &self.Coeff).finish()
    }
}
impl ::windows::core::TypeKind for MFFOLDDOWN_MATRIX {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFFOLDDOWN_MATRIX {
    fn eq(&self, other: &Self) -> bool {
        self.cbSize == other.cbSize && self.cSrcChannels == other.cSrcChannels && self.cDstChannels == other.cDstChannels && self.dwChannelMask == other.dwChannelMask && self.Coeff == other.Coeff
    }
}
impl ::core::cmp::Eq for MFFOLDDOWN_MATRIX {}
impl ::core::default::Default for MFFOLDDOWN_MATRIX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFINPUTTRUSTAUTHORITY_ACCESS_ACTION {
    pub Action: MFPOLICYMANAGER_ACTION,
    pub pbTicket: *mut u8,
    pub cbTicket: u32,
}
impl ::core::marker::Copy for MFINPUTTRUSTAUTHORITY_ACCESS_ACTION {}
impl ::core::clone::Clone for MFINPUTTRUSTAUTHORITY_ACCESS_ACTION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFINPUTTRUSTAUTHORITY_ACCESS_ACTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFINPUTTRUSTAUTHORITY_ACCESS_ACTION").field("Action", &self.Action).field("pbTicket", &self.pbTicket).field("cbTicket", &self.cbTicket).finish()
    }
}
impl ::windows::core::TypeKind for MFINPUTTRUSTAUTHORITY_ACCESS_ACTION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFINPUTTRUSTAUTHORITY_ACCESS_ACTION {
    fn eq(&self, other: &Self) -> bool {
        self.Action == other.Action && self.pbTicket == other.pbTicket && self.cbTicket == other.cbTicket
    }
}
impl ::core::cmp::Eq for MFINPUTTRUSTAUTHORITY_ACCESS_ACTION {}
impl ::core::default::Default for MFINPUTTRUSTAUTHORITY_ACCESS_ACTION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS {
    pub dwSize: u32,
    pub dwVer: u32,
    pub cbSignatureOffset: u32,
    pub cbSignatureSize: u32,
    pub cbExtensionOffset: u32,
    pub cbExtensionSize: u32,
    pub cActions: u32,
    pub rgOutputActions: [MFINPUTTRUSTAUTHORITY_ACCESS_ACTION; 1],
}
impl ::core::marker::Copy for MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS {}
impl ::core::clone::Clone for MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS").field("dwSize", &self.dwSize).field("dwVer", &self.dwVer).field("cbSignatureOffset", &self.cbSignatureOffset).field("cbSignatureSize", &self.cbSignatureSize).field("cbExtensionOffset", &self.cbExtensionOffset).field("cbExtensionSize", &self.cbExtensionSize).field("cActions", &self.cActions).field("rgOutputActions", &self.rgOutputActions).finish()
    }
}
impl ::windows::core::TypeKind for MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS {
    fn eq(&self, other: &Self) -> bool {
        self.dwSize == other.dwSize && self.dwVer == other.dwVer && self.cbSignatureOffset == other.cbSignatureOffset && self.cbSignatureSize == other.cbSignatureSize && self.cbExtensionOffset == other.cbExtensionOffset && self.cbExtensionSize == other.cbExtensionSize && self.cActions == other.cActions && self.rgOutputActions == other.rgOutputActions
    }
}
impl ::core::cmp::Eq for MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS {}
impl ::core::default::Default for MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct MFMPEG2DLNASINKSTATS {
    pub cBytesWritten: u64,
    pub fPAL: super::super::Foundation::BOOL,
    pub fccVideo: u32,
    pub dwVideoWidth: u32,
    pub dwVideoHeight: u32,
    pub cVideoFramesReceived: u64,
    pub cVideoFramesEncoded: u64,
    pub cVideoFramesSkipped: u64,
    pub cBlackVideoFramesEncoded: u64,
    pub cVideoFramesDuplicated: u64,
    pub cAudioSamplesPerSec: u32,
    pub cAudioChannels: u32,
    pub cAudioBytesReceived: u64,
    pub cAudioFramesEncoded: u64,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for MFMPEG2DLNASINKSTATS {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for MFMPEG2DLNASINKSTATS {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for MFMPEG2DLNASINKSTATS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFMPEG2DLNASINKSTATS")
            .field("cBytesWritten", &self.cBytesWritten)
            .field("fPAL", &self.fPAL)
            .field("fccVideo", &self.fccVideo)
            .field("dwVideoWidth", &self.dwVideoWidth)
            .field("dwVideoHeight", &self.dwVideoHeight)
            .field("cVideoFramesReceived", &self.cVideoFramesReceived)
            .field("cVideoFramesEncoded", &self.cVideoFramesEncoded)
            .field("cVideoFramesSkipped", &self.cVideoFramesSkipped)
            .field("cBlackVideoFramesEncoded", &self.cBlackVideoFramesEncoded)
            .field("cVideoFramesDuplicated", &self.cVideoFramesDuplicated)
            .field("cAudioSamplesPerSec", &self.cAudioSamplesPerSec)
            .field("cAudioChannels", &self.cAudioChannels)
            .field("cAudioBytesReceived", &self.cAudioBytesReceived)
            .field("cAudioFramesEncoded", &self.cAudioFramesEncoded)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for MFMPEG2DLNASINKSTATS {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for MFMPEG2DLNASINKSTATS {
    fn eq(&self, other: &Self) -> bool {
        self.cBytesWritten == other.cBytesWritten && self.fPAL == other.fPAL && self.fccVideo == other.fccVideo && self.dwVideoWidth == other.dwVideoWidth && self.dwVideoHeight == other.dwVideoHeight && self.cVideoFramesReceived == other.cVideoFramesReceived && self.cVideoFramesEncoded == other.cVideoFramesEncoded && self.cVideoFramesSkipped == other.cVideoFramesSkipped && self.cBlackVideoFramesEncoded == other.cBlackVideoFramesEncoded && self.cVideoFramesDuplicated == other.cVideoFramesDuplicated && self.cAudioSamplesPerSec == other.cAudioSamplesPerSec && self.cAudioChannels == other.cAudioChannels && self.cAudioBytesReceived == other.cAudioBytesReceived && self.cAudioFramesEncoded == other.cAudioFramesEncoded
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for MFMPEG2DLNASINKSTATS {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MFMPEG2DLNASINKSTATS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFMediaKeyStatus {
    pub pbKeyId: *mut u8,
    pub cbKeyId: u32,
    pub eMediaKeyStatus: MF_MEDIAKEY_STATUS,
}
impl ::core::marker::Copy for MFMediaKeyStatus {}
impl ::core::clone::Clone for MFMediaKeyStatus {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFMediaKeyStatus {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFMediaKeyStatus").field("pbKeyId", &self.pbKeyId).field("cbKeyId", &self.cbKeyId).field("eMediaKeyStatus", &self.eMediaKeyStatus).finish()
    }
}
impl ::windows::core::TypeKind for MFMediaKeyStatus {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFMediaKeyStatus {
    fn eq(&self, other: &Self) -> bool {
        self.pbKeyId == other.pbKeyId && self.cbKeyId == other.cbKeyId && self.eMediaKeyStatus == other.eMediaKeyStatus
    }
}
impl ::core::cmp::Eq for MFMediaKeyStatus {}
impl ::core::default::Default for MFMediaKeyStatus {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct MFNetCredentialManagerGetParam {
    pub hrOp: ::windows::core::HRESULT,
    pub fAllowLoggedOnUser: super::super::Foundation::BOOL,
    pub fClearTextPackage: super::super::Foundation::BOOL,
    pub pszUrl: ::windows::core::PCWSTR,
    pub pszSite: ::windows::core::PCWSTR,
    pub pszRealm: ::windows::core::PCWSTR,
    pub pszPackage: ::windows::core::PCWSTR,
    pub nRetries: i32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for MFNetCredentialManagerGetParam {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for MFNetCredentialManagerGetParam {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for MFNetCredentialManagerGetParam {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFNetCredentialManagerGetParam").field("hrOp", &self.hrOp).field("fAllowLoggedOnUser", &self.fAllowLoggedOnUser).field("fClearTextPackage", &self.fClearTextPackage).field("pszUrl", &self.pszUrl).field("pszSite", &self.pszSite).field("pszRealm", &self.pszRealm).field("pszPackage", &self.pszPackage).field("nRetries", &self.nRetries).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for MFNetCredentialManagerGetParam {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for MFNetCredentialManagerGetParam {
    fn eq(&self, other: &Self) -> bool {
        self.hrOp == other.hrOp && self.fAllowLoggedOnUser == other.fAllowLoggedOnUser && self.fClearTextPackage == other.fClearTextPackage && self.pszUrl == other.pszUrl && self.pszSite == other.pszSite && self.pszRealm == other.pszRealm && self.pszPackage == other.pszPackage && self.nRetries == other.nRetries
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for MFNetCredentialManagerGetParam {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MFNetCredentialManagerGetParam {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFOffset {
    pub fract: u16,
    pub value: i16,
}
impl ::core::marker::Copy for MFOffset {}
impl ::core::clone::Clone for MFOffset {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFOffset {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFOffset").field("fract", &self.fract).field("value", &self.value).finish()
    }
}
impl ::windows::core::TypeKind for MFOffset {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFOffset {
    fn eq(&self, other: &Self) -> bool {
        self.fract == other.fract && self.value == other.value
    }
}
impl ::core::cmp::Eq for MFOffset {}
impl ::core::default::Default for MFOffset {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_UI_Shell_PropertiesSystem\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_Shell_PropertiesSystem"))]
pub struct MFP_ACQUIRE_USER_CREDENTIAL_EVENT {
    pub header: MFP_EVENT_HEADER,
    pub dwUserData: usize,
    pub fProceedWithAuthentication: super::super::Foundation::BOOL,
    pub hrAuthenticationStatus: ::windows::core::HRESULT,
    pub pwszURL: ::windows::core::PCWSTR,
    pub pwszSite: ::windows::core::PCWSTR,
    pub pwszRealm: ::windows::core::PCWSTR,
    pub pwszPackage: ::windows::core::PCWSTR,
    pub nRetries: i32,
    pub flags: u32,
    pub pCredential: ::std::mem::ManuallyDrop<::core::option::Option<IMFNetCredential>>,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_Shell_PropertiesSystem"))]
impl ::core::clone::Clone for MFP_ACQUIRE_USER_CREDENTIAL_EVENT {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_Shell_PropertiesSystem"))]
impl ::core::fmt::Debug for MFP_ACQUIRE_USER_CREDENTIAL_EVENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFP_ACQUIRE_USER_CREDENTIAL_EVENT")
            .field("header", &self.header)
            .field("dwUserData", &self.dwUserData)
            .field("fProceedWithAuthentication", &self.fProceedWithAuthentication)
            .field("hrAuthenticationStatus", &self.hrAuthenticationStatus)
            .field("pwszURL", &self.pwszURL)
            .field("pwszSite", &self.pwszSite)
            .field("pwszRealm", &self.pwszRealm)
            .field("pwszPackage", &self.pwszPackage)
            .field("nRetries", &self.nRetries)
            .field("flags", &self.flags)
            .field("pCredential", &self.pCredential)
            .finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_Shell_PropertiesSystem"))]
impl ::windows::core::TypeKind for MFP_ACQUIRE_USER_CREDENTIAL_EVENT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_Shell_PropertiesSystem"))]
impl ::core::cmp::PartialEq for MFP_ACQUIRE_USER_CREDENTIAL_EVENT {
    fn eq(&self, other: &Self) -> bool {
        self.header == other.header && self.dwUserData == other.dwUserData && self.fProceedWithAuthentication == other.fProceedWithAuthentication && self.hrAuthenticationStatus == other.hrAuthenticationStatus && self.pwszURL == other.pwszURL && self.pwszSite == other.pwszSite && self.pwszRealm == other.pwszRealm && self.pwszPackage == other.pwszPackage && self.nRetries == other.nRetries && self.flags == other.flags && self.pCredential == other.pCredential
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_Shell_PropertiesSystem"))]
impl ::core::cmp::Eq for MFP_ACQUIRE_USER_CREDENTIAL_EVENT {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_Shell_PropertiesSystem"))]
impl ::core::default::Default for MFP_ACQUIRE_USER_CREDENTIAL_EVENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_UI_Shell_PropertiesSystem\"`*"]
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub struct MFP_ERROR_EVENT {
    pub header: MFP_EVENT_HEADER,
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::clone::Clone for MFP_ERROR_EVENT {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::fmt::Debug for MFP_ERROR_EVENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFP_ERROR_EVENT").field("header", &self.header).finish()
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::windows::core::TypeKind for MFP_ERROR_EVENT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::PartialEq for MFP_ERROR_EVENT {
    fn eq(&self, other: &Self) -> bool {
        self.header == other.header
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::Eq for MFP_ERROR_EVENT {}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::default::Default for MFP_ERROR_EVENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_UI_Shell_PropertiesSystem\"`*"]
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub struct MFP_EVENT_HEADER {
    pub eEventType: MFP_EVENT_TYPE,
    pub hrEvent: ::windows::core::HRESULT,
    pub pMediaPlayer: ::std::mem::ManuallyDrop<::core::option::Option<IMFPMediaPlayer>>,
    pub eState: MFP_MEDIAPLAYER_STATE,
    pub pPropertyStore: ::std::mem::ManuallyDrop<::core::option::Option<super::super::UI::Shell::PropertiesSystem::IPropertyStore>>,
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::clone::Clone for MFP_EVENT_HEADER {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::fmt::Debug for MFP_EVENT_HEADER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFP_EVENT_HEADER").field("eEventType", &self.eEventType).field("hrEvent", &self.hrEvent).field("pMediaPlayer", &self.pMediaPlayer).field("eState", &self.eState).field("pPropertyStore", &self.pPropertyStore).finish()
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::windows::core::TypeKind for MFP_EVENT_HEADER {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::PartialEq for MFP_EVENT_HEADER {
    fn eq(&self, other: &Self) -> bool {
        self.eEventType == other.eEventType && self.hrEvent == other.hrEvent && self.pMediaPlayer == other.pMediaPlayer && self.eState == other.eState && self.pPropertyStore == other.pPropertyStore
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::Eq for MFP_EVENT_HEADER {}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::default::Default for MFP_EVENT_HEADER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_UI_Shell_PropertiesSystem\"`*"]
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub struct MFP_FRAME_STEP_EVENT {
    pub header: MFP_EVENT_HEADER,
    pub pMediaItem: ::std::mem::ManuallyDrop<::core::option::Option<IMFPMediaItem>>,
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::clone::Clone for MFP_FRAME_STEP_EVENT {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::fmt::Debug for MFP_FRAME_STEP_EVENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFP_FRAME_STEP_EVENT").field("header", &self.header).field("pMediaItem", &self.pMediaItem).finish()
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::windows::core::TypeKind for MFP_FRAME_STEP_EVENT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::PartialEq for MFP_FRAME_STEP_EVENT {
    fn eq(&self, other: &Self) -> bool {
        self.header == other.header && self.pMediaItem == other.pMediaItem
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::Eq for MFP_FRAME_STEP_EVENT {}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::default::Default for MFP_FRAME_STEP_EVENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_UI_Shell_PropertiesSystem\"`*"]
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub struct MFP_MEDIAITEM_CLEARED_EVENT {
    pub header: MFP_EVENT_HEADER,
    pub pMediaItem: ::std::mem::ManuallyDrop<::core::option::Option<IMFPMediaItem>>,
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::clone::Clone for MFP_MEDIAITEM_CLEARED_EVENT {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::fmt::Debug for MFP_MEDIAITEM_CLEARED_EVENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFP_MEDIAITEM_CLEARED_EVENT").field("header", &self.header).field("pMediaItem", &self.pMediaItem).finish()
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::windows::core::TypeKind for MFP_MEDIAITEM_CLEARED_EVENT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::PartialEq for MFP_MEDIAITEM_CLEARED_EVENT {
    fn eq(&self, other: &Self) -> bool {
        self.header == other.header && self.pMediaItem == other.pMediaItem
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::Eq for MFP_MEDIAITEM_CLEARED_EVENT {}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::default::Default for MFP_MEDIAITEM_CLEARED_EVENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_UI_Shell_PropertiesSystem\"`*"]
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub struct MFP_MEDIAITEM_CREATED_EVENT {
    pub header: MFP_EVENT_HEADER,
    pub pMediaItem: ::std::mem::ManuallyDrop<::core::option::Option<IMFPMediaItem>>,
    pub dwUserData: usize,
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::clone::Clone for MFP_MEDIAITEM_CREATED_EVENT {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::fmt::Debug for MFP_MEDIAITEM_CREATED_EVENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFP_MEDIAITEM_CREATED_EVENT").field("header", &self.header).field("pMediaItem", &self.pMediaItem).field("dwUserData", &self.dwUserData).finish()
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::windows::core::TypeKind for MFP_MEDIAITEM_CREATED_EVENT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::PartialEq for MFP_MEDIAITEM_CREATED_EVENT {
    fn eq(&self, other: &Self) -> bool {
        self.header == other.header && self.pMediaItem == other.pMediaItem && self.dwUserData == other.dwUserData
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::Eq for MFP_MEDIAITEM_CREATED_EVENT {}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::default::Default for MFP_MEDIAITEM_CREATED_EVENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_UI_Shell_PropertiesSystem\"`*"]
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub struct MFP_MEDIAITEM_SET_EVENT {
    pub header: MFP_EVENT_HEADER,
    pub pMediaItem: ::std::mem::ManuallyDrop<::core::option::Option<IMFPMediaItem>>,
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::clone::Clone for MFP_MEDIAITEM_SET_EVENT {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::fmt::Debug for MFP_MEDIAITEM_SET_EVENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFP_MEDIAITEM_SET_EVENT").field("header", &self.header).field("pMediaItem", &self.pMediaItem).finish()
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::windows::core::TypeKind for MFP_MEDIAITEM_SET_EVENT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::PartialEq for MFP_MEDIAITEM_SET_EVENT {
    fn eq(&self, other: &Self) -> bool {
        self.header == other.header && self.pMediaItem == other.pMediaItem
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::Eq for MFP_MEDIAITEM_SET_EVENT {}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::default::Default for MFP_MEDIAITEM_SET_EVENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_UI_Shell_PropertiesSystem\"`*"]
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub struct MFP_MF_EVENT {
    pub header: MFP_EVENT_HEADER,
    pub MFEventType: u32,
    pub pMFMediaEvent: ::std::mem::ManuallyDrop<::core::option::Option<IMFMediaEvent>>,
    pub pMediaItem: ::std::mem::ManuallyDrop<::core::option::Option<IMFPMediaItem>>,
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::clone::Clone for MFP_MF_EVENT {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::fmt::Debug for MFP_MF_EVENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFP_MF_EVENT").field("header", &self.header).field("MFEventType", &self.MFEventType).field("pMFMediaEvent", &self.pMFMediaEvent).field("pMediaItem", &self.pMediaItem).finish()
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::windows::core::TypeKind for MFP_MF_EVENT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::PartialEq for MFP_MF_EVENT {
    fn eq(&self, other: &Self) -> bool {
        self.header == other.header && self.MFEventType == other.MFEventType && self.pMFMediaEvent == other.pMFMediaEvent && self.pMediaItem == other.pMediaItem
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::Eq for MFP_MF_EVENT {}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::default::Default for MFP_MF_EVENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_UI_Shell_PropertiesSystem\"`*"]
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub struct MFP_PAUSE_EVENT {
    pub header: MFP_EVENT_HEADER,
    pub pMediaItem: ::std::mem::ManuallyDrop<::core::option::Option<IMFPMediaItem>>,
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::clone::Clone for MFP_PAUSE_EVENT {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::fmt::Debug for MFP_PAUSE_EVENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFP_PAUSE_EVENT").field("header", &self.header).field("pMediaItem", &self.pMediaItem).finish()
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::windows::core::TypeKind for MFP_PAUSE_EVENT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::PartialEq for MFP_PAUSE_EVENT {
    fn eq(&self, other: &Self) -> bool {
        self.header == other.header && self.pMediaItem == other.pMediaItem
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::Eq for MFP_PAUSE_EVENT {}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::default::Default for MFP_PAUSE_EVENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_UI_Shell_PropertiesSystem\"`*"]
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub struct MFP_PLAYBACK_ENDED_EVENT {
    pub header: MFP_EVENT_HEADER,
    pub pMediaItem: ::std::mem::ManuallyDrop<::core::option::Option<IMFPMediaItem>>,
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::clone::Clone for MFP_PLAYBACK_ENDED_EVENT {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::fmt::Debug for MFP_PLAYBACK_ENDED_EVENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFP_PLAYBACK_ENDED_EVENT").field("header", &self.header).field("pMediaItem", &self.pMediaItem).finish()
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::windows::core::TypeKind for MFP_PLAYBACK_ENDED_EVENT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::PartialEq for MFP_PLAYBACK_ENDED_EVENT {
    fn eq(&self, other: &Self) -> bool {
        self.header == other.header && self.pMediaItem == other.pMediaItem
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::Eq for MFP_PLAYBACK_ENDED_EVENT {}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::default::Default for MFP_PLAYBACK_ENDED_EVENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_UI_Shell_PropertiesSystem\"`*"]
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub struct MFP_PLAY_EVENT {
    pub header: MFP_EVENT_HEADER,
    pub pMediaItem: ::std::mem::ManuallyDrop<::core::option::Option<IMFPMediaItem>>,
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::clone::Clone for MFP_PLAY_EVENT {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::fmt::Debug for MFP_PLAY_EVENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFP_PLAY_EVENT").field("header", &self.header).field("pMediaItem", &self.pMediaItem).finish()
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::windows::core::TypeKind for MFP_PLAY_EVENT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::PartialEq for MFP_PLAY_EVENT {
    fn eq(&self, other: &Self) -> bool {
        self.header == other.header && self.pMediaItem == other.pMediaItem
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::Eq for MFP_PLAY_EVENT {}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::default::Default for MFP_PLAY_EVENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_UI_Shell_PropertiesSystem\"`*"]
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub struct MFP_POSITION_SET_EVENT {
    pub header: MFP_EVENT_HEADER,
    pub pMediaItem: ::std::mem::ManuallyDrop<::core::option::Option<IMFPMediaItem>>,
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::clone::Clone for MFP_POSITION_SET_EVENT {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::fmt::Debug for MFP_POSITION_SET_EVENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFP_POSITION_SET_EVENT").field("header", &self.header).field("pMediaItem", &self.pMediaItem).finish()
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::windows::core::TypeKind for MFP_POSITION_SET_EVENT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::PartialEq for MFP_POSITION_SET_EVENT {
    fn eq(&self, other: &Self) -> bool {
        self.header == other.header && self.pMediaItem == other.pMediaItem
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::Eq for MFP_POSITION_SET_EVENT {}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::default::Default for MFP_POSITION_SET_EVENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_UI_Shell_PropertiesSystem\"`*"]
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub struct MFP_RATE_SET_EVENT {
    pub header: MFP_EVENT_HEADER,
    pub pMediaItem: ::std::mem::ManuallyDrop<::core::option::Option<IMFPMediaItem>>,
    pub flRate: f32,
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::clone::Clone for MFP_RATE_SET_EVENT {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::fmt::Debug for MFP_RATE_SET_EVENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFP_RATE_SET_EVENT").field("header", &self.header).field("pMediaItem", &self.pMediaItem).field("flRate", &self.flRate).finish()
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::windows::core::TypeKind for MFP_RATE_SET_EVENT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::PartialEq for MFP_RATE_SET_EVENT {
    fn eq(&self, other: &Self) -> bool {
        self.header == other.header && self.pMediaItem == other.pMediaItem && self.flRate == other.flRate
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::Eq for MFP_RATE_SET_EVENT {}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::default::Default for MFP_RATE_SET_EVENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_UI_Shell_PropertiesSystem\"`*"]
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub struct MFP_STOP_EVENT {
    pub header: MFP_EVENT_HEADER,
    pub pMediaItem: ::std::mem::ManuallyDrop<::core::option::Option<IMFPMediaItem>>,
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::clone::Clone for MFP_STOP_EVENT {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::fmt::Debug for MFP_STOP_EVENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFP_STOP_EVENT").field("header", &self.header).field("pMediaItem", &self.pMediaItem).finish()
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::windows::core::TypeKind for MFP_STOP_EVENT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::PartialEq for MFP_STOP_EVENT {
    fn eq(&self, other: &Self) -> bool {
        self.header == other.header && self.pMediaItem == other.pMediaItem
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::cmp::Eq for MFP_STOP_EVENT {}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl ::core::default::Default for MFP_STOP_EVENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub union MFPaletteEntry {
    pub ARGB: MFARGB,
    pub AYCbCr: MFAYUVSample,
}
impl ::core::marker::Copy for MFPaletteEntry {}
impl ::core::clone::Clone for MFPaletteEntry {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for MFPaletteEntry {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for MFPaletteEntry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFPinholeCameraIntrinsic_IntrinsicModel {
    pub Width: u32,
    pub Height: u32,
    pub CameraModel: MFCameraIntrinsic_PinholeCameraModel,
    pub DistortionModel: MFCameraIntrinsic_DistortionModel,
}
impl ::core::marker::Copy for MFPinholeCameraIntrinsic_IntrinsicModel {}
impl ::core::clone::Clone for MFPinholeCameraIntrinsic_IntrinsicModel {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFPinholeCameraIntrinsic_IntrinsicModel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFPinholeCameraIntrinsic_IntrinsicModel").field("Width", &self.Width).field("Height", &self.Height).field("CameraModel", &self.CameraModel).field("DistortionModel", &self.DistortionModel).finish()
    }
}
impl ::windows::core::TypeKind for MFPinholeCameraIntrinsic_IntrinsicModel {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFPinholeCameraIntrinsic_IntrinsicModel {
    fn eq(&self, other: &Self) -> bool {
        self.Width == other.Width && self.Height == other.Height && self.CameraModel == other.CameraModel && self.DistortionModel == other.DistortionModel
    }
}
impl ::core::cmp::Eq for MFPinholeCameraIntrinsic_IntrinsicModel {}
impl ::core::default::Default for MFPinholeCameraIntrinsic_IntrinsicModel {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFPinholeCameraIntrinsics {
    pub IntrinsicModelCount: u32,
    pub IntrinsicModels: [MFPinholeCameraIntrinsic_IntrinsicModel; 1],
}
impl ::core::marker::Copy for MFPinholeCameraIntrinsics {}
impl ::core::clone::Clone for MFPinholeCameraIntrinsics {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFPinholeCameraIntrinsics {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFPinholeCameraIntrinsics").field("IntrinsicModelCount", &self.IntrinsicModelCount).field("IntrinsicModels", &self.IntrinsicModels).finish()
    }
}
impl ::windows::core::TypeKind for MFPinholeCameraIntrinsics {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFPinholeCameraIntrinsics {
    fn eq(&self, other: &Self) -> bool {
        self.IntrinsicModelCount == other.IntrinsicModelCount && self.IntrinsicModels == other.IntrinsicModels
    }
}
impl ::core::cmp::Eq for MFPinholeCameraIntrinsics {}
impl ::core::default::Default for MFPinholeCameraIntrinsics {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFRR_COMPONENTS {
    pub dwRRInfoVersion: u32,
    pub dwRRComponents: u32,
    pub pRRComponents: *mut MFRR_COMPONENT_HASH_INFO,
}
impl ::core::marker::Copy for MFRR_COMPONENTS {}
impl ::core::clone::Clone for MFRR_COMPONENTS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFRR_COMPONENTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFRR_COMPONENTS").field("dwRRInfoVersion", &self.dwRRInfoVersion).field("dwRRComponents", &self.dwRRComponents).field("pRRComponents", &self.pRRComponents).finish()
    }
}
impl ::windows::core::TypeKind for MFRR_COMPONENTS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFRR_COMPONENTS {
    fn eq(&self, other: &Self) -> bool {
        self.dwRRInfoVersion == other.dwRRInfoVersion && self.dwRRComponents == other.dwRRComponents && self.pRRComponents == other.pRRComponents
    }
}
impl ::core::cmp::Eq for MFRR_COMPONENTS {}
impl ::core::default::Default for MFRR_COMPONENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFRR_COMPONENT_HASH_INFO {
    pub ulReason: u32,
    pub rgHeaderHash: [u16; 43],
    pub rgPublicKeyHash: [u16; 43],
    pub wszName: [u16; 260],
}
impl ::core::marker::Copy for MFRR_COMPONENT_HASH_INFO {}
impl ::core::clone::Clone for MFRR_COMPONENT_HASH_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFRR_COMPONENT_HASH_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFRR_COMPONENT_HASH_INFO").field("ulReason", &self.ulReason).field("rgHeaderHash", &self.rgHeaderHash).field("rgPublicKeyHash", &self.rgPublicKeyHash).field("wszName", &self.wszName).finish()
    }
}
impl ::windows::core::TypeKind for MFRR_COMPONENT_HASH_INFO {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFRR_COMPONENT_HASH_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.ulReason == other.ulReason && self.rgHeaderHash == other.rgHeaderHash && self.rgPublicKeyHash == other.rgPublicKeyHash && self.wszName == other.wszName
    }
}
impl ::core::cmp::Eq for MFRR_COMPONENT_HASH_INFO {}
impl ::core::default::Default for MFRR_COMPONENT_HASH_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFRatio {
    pub Numerator: u32,
    pub Denominator: u32,
}
impl ::core::marker::Copy for MFRatio {}
impl ::core::clone::Clone for MFRatio {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFRatio {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFRatio").field("Numerator", &self.Numerator).field("Denominator", &self.Denominator).finish()
    }
}
impl ::windows::core::TypeKind for MFRatio {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFRatio {
    fn eq(&self, other: &Self) -> bool {
        self.Numerator == other.Numerator && self.Denominator == other.Denominator
    }
}
impl ::core::cmp::Eq for MFRatio {}
impl ::core::default::Default for MFRatio {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFTOPONODE_ATTRIBUTE_UPDATE {
    pub NodeId: u64,
    pub guidAttributeKey: ::windows::core::GUID,
    pub attrType: MF_ATTRIBUTE_TYPE,
    pub Anonymous: MFTOPONODE_ATTRIBUTE_UPDATE_0,
}
impl ::core::marker::Copy for MFTOPONODE_ATTRIBUTE_UPDATE {}
impl ::core::clone::Clone for MFTOPONODE_ATTRIBUTE_UPDATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for MFTOPONODE_ATTRIBUTE_UPDATE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for MFTOPONODE_ATTRIBUTE_UPDATE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub union MFTOPONODE_ATTRIBUTE_UPDATE_0 {
    pub u32: u32,
    pub u64: u64,
    pub d: f64,
}
impl ::core::marker::Copy for MFTOPONODE_ATTRIBUTE_UPDATE_0 {}
impl ::core::clone::Clone for MFTOPONODE_ATTRIBUTE_UPDATE_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for MFTOPONODE_ATTRIBUTE_UPDATE_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for MFTOPONODE_ATTRIBUTE_UPDATE_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFT_INPUT_STREAM_INFO {
    pub hnsMaxLatency: i64,
    pub dwFlags: u32,
    pub cbSize: u32,
    pub cbMaxLookahead: u32,
    pub cbAlignment: u32,
}
impl ::core::marker::Copy for MFT_INPUT_STREAM_INFO {}
impl ::core::clone::Clone for MFT_INPUT_STREAM_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFT_INPUT_STREAM_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFT_INPUT_STREAM_INFO").field("hnsMaxLatency", &self.hnsMaxLatency).field("dwFlags", &self.dwFlags).field("cbSize", &self.cbSize).field("cbMaxLookahead", &self.cbMaxLookahead).field("cbAlignment", &self.cbAlignment).finish()
    }
}
impl ::windows::core::TypeKind for MFT_INPUT_STREAM_INFO {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFT_INPUT_STREAM_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.hnsMaxLatency == other.hnsMaxLatency && self.dwFlags == other.dwFlags && self.cbSize == other.cbSize && self.cbMaxLookahead == other.cbMaxLookahead && self.cbAlignment == other.cbAlignment
    }
}
impl ::core::cmp::Eq for MFT_INPUT_STREAM_INFO {}
impl ::core::default::Default for MFT_INPUT_STREAM_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFT_OUTPUT_DATA_BUFFER {
    pub dwStreamID: u32,
    pub pSample: ::std::mem::ManuallyDrop<::core::option::Option<IMFSample>>,
    pub dwStatus: u32,
    pub pEvents: ::std::mem::ManuallyDrop<::core::option::Option<IMFCollection>>,
}
impl ::core::clone::Clone for MFT_OUTPUT_DATA_BUFFER {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for MFT_OUTPUT_DATA_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFT_OUTPUT_DATA_BUFFER").field("dwStreamID", &self.dwStreamID).field("pSample", &self.pSample).field("dwStatus", &self.dwStatus).field("pEvents", &self.pEvents).finish()
    }
}
impl ::windows::core::TypeKind for MFT_OUTPUT_DATA_BUFFER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFT_OUTPUT_DATA_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.dwStreamID == other.dwStreamID && self.pSample == other.pSample && self.dwStatus == other.dwStatus && self.pEvents == other.pEvents
    }
}
impl ::core::cmp::Eq for MFT_OUTPUT_DATA_BUFFER {}
impl ::core::default::Default for MFT_OUTPUT_DATA_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFT_OUTPUT_STREAM_INFO {
    pub dwFlags: u32,
    pub cbSize: u32,
    pub cbAlignment: u32,
}
impl ::core::marker::Copy for MFT_OUTPUT_STREAM_INFO {}
impl ::core::clone::Clone for MFT_OUTPUT_STREAM_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFT_OUTPUT_STREAM_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFT_OUTPUT_STREAM_INFO").field("dwFlags", &self.dwFlags).field("cbSize", &self.cbSize).field("cbAlignment", &self.cbAlignment).finish()
    }
}
impl ::windows::core::TypeKind for MFT_OUTPUT_STREAM_INFO {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFT_OUTPUT_STREAM_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags && self.cbSize == other.cbSize && self.cbAlignment == other.cbAlignment
    }
}
impl ::core::cmp::Eq for MFT_OUTPUT_STREAM_INFO {}
impl ::core::default::Default for MFT_OUTPUT_STREAM_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFT_REGISTER_TYPE_INFO {
    pub guidMajorType: ::windows::core::GUID,
    pub guidSubtype: ::windows::core::GUID,
}
impl ::core::marker::Copy for MFT_REGISTER_TYPE_INFO {}
impl ::core::clone::Clone for MFT_REGISTER_TYPE_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFT_REGISTER_TYPE_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFT_REGISTER_TYPE_INFO").field("guidMajorType", &self.guidMajorType).field("guidSubtype", &self.guidSubtype).finish()
    }
}
impl ::windows::core::TypeKind for MFT_REGISTER_TYPE_INFO {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFT_REGISTER_TYPE_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.guidMajorType == other.guidMajorType && self.guidSubtype == other.guidSubtype
    }
}
impl ::core::cmp::Eq for MFT_REGISTER_TYPE_INFO {}
impl ::core::default::Default for MFT_REGISTER_TYPE_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFT_REGISTRATION_INFO {
    pub clsid: ::windows::core::GUID,
    pub guidCategory: ::windows::core::GUID,
    pub uiFlags: u32,
    pub pszName: ::windows::core::PCWSTR,
    pub cInTypes: u32,
    pub pInTypes: *mut MFT_REGISTER_TYPE_INFO,
    pub cOutTypes: u32,
    pub pOutTypes: *mut MFT_REGISTER_TYPE_INFO,
}
impl ::core::marker::Copy for MFT_REGISTRATION_INFO {}
impl ::core::clone::Clone for MFT_REGISTRATION_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFT_REGISTRATION_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFT_REGISTRATION_INFO").field("clsid", &self.clsid).field("guidCategory", &self.guidCategory).field("uiFlags", &self.uiFlags).field("pszName", &self.pszName).field("cInTypes", &self.cInTypes).field("pInTypes", &self.pInTypes).field("cOutTypes", &self.cOutTypes).field("pOutTypes", &self.pOutTypes).finish()
    }
}
impl ::windows::core::TypeKind for MFT_REGISTRATION_INFO {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFT_REGISTRATION_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.clsid == other.clsid && self.guidCategory == other.guidCategory && self.uiFlags == other.uiFlags && self.pszName == other.pszName && self.cInTypes == other.cInTypes && self.pInTypes == other.pInTypes && self.cOutTypes == other.cOutTypes && self.pOutTypes == other.pOutTypes
    }
}
impl ::core::cmp::Eq for MFT_REGISTRATION_INFO {}
impl ::core::default::Default for MFT_REGISTRATION_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFT_STREAM_STATE_PARAM {
    pub StreamId: u32,
    pub State: MF_STREAM_STATE,
}
impl ::core::marker::Copy for MFT_STREAM_STATE_PARAM {}
impl ::core::clone::Clone for MFT_STREAM_STATE_PARAM {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFT_STREAM_STATE_PARAM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFT_STREAM_STATE_PARAM").field("StreamId", &self.StreamId).field("State", &self.State).finish()
    }
}
impl ::windows::core::TypeKind for MFT_STREAM_STATE_PARAM {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFT_STREAM_STATE_PARAM {
    fn eq(&self, other: &Self) -> bool {
        self.StreamId == other.StreamId && self.State == other.State
    }
}
impl ::core::cmp::Eq for MFT_STREAM_STATE_PARAM {}
impl ::core::default::Default for MFT_STREAM_STATE_PARAM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct MFVIDEOFORMAT {
    pub dwSize: u32,
    pub videoInfo: MFVideoInfo,
    pub guidFormat: ::windows::core::GUID,
    pub compressedInfo: MFVideoCompressedInfo,
    pub surfaceInfo: MFVideoSurfaceInfo,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for MFVIDEOFORMAT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for MFVIDEOFORMAT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for MFVIDEOFORMAT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MFVIDEOFORMAT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`, `\"Win32_Graphics_Gdi\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
pub struct MFVideoAlphaBitmap {
    pub GetBitmapFromDC: super::super::Foundation::BOOL,
    pub bitmap: MFVideoAlphaBitmap_0,
    pub params: MFVideoAlphaBitmapParams,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
impl ::core::clone::Clone for MFVideoAlphaBitmap {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
impl ::windows::core::TypeKind for MFVideoAlphaBitmap {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
impl ::core::default::Default for MFVideoAlphaBitmap {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`, `\"Win32_Graphics_Gdi\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
pub union MFVideoAlphaBitmap_0 {
    pub hdc: super::super::Graphics::Gdi::HDC,
    pub pDDS: ::std::mem::ManuallyDrop<::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>>,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
impl ::core::clone::Clone for MFVideoAlphaBitmap_0 {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
impl ::windows::core::TypeKind for MFVideoAlphaBitmap_0 {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
impl ::core::default::Default for MFVideoAlphaBitmap_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct MFVideoAlphaBitmapParams {
    pub dwFlags: u32,
    pub clrSrcKey: super::super::Foundation::COLORREF,
    pub rcSrc: super::super::Foundation::RECT,
    pub nrcDest: MFVideoNormalizedRect,
    pub fAlpha: f32,
    pub dwFilterMode: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for MFVideoAlphaBitmapParams {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for MFVideoAlphaBitmapParams {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for MFVideoAlphaBitmapParams {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFVideoAlphaBitmapParams").field("dwFlags", &self.dwFlags).field("clrSrcKey", &self.clrSrcKey).field("rcSrc", &self.rcSrc).field("nrcDest", &self.nrcDest).field("fAlpha", &self.fAlpha).field("dwFilterMode", &self.dwFilterMode).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for MFVideoAlphaBitmapParams {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for MFVideoAlphaBitmapParams {
    fn eq(&self, other: &Self) -> bool {
        self.dwFlags == other.dwFlags && self.clrSrcKey == other.clrSrcKey && self.rcSrc == other.rcSrc && self.nrcDest == other.nrcDest && self.fAlpha == other.fAlpha && self.dwFilterMode == other.dwFilterMode
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for MFVideoAlphaBitmapParams {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MFVideoAlphaBitmapParams {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct MFVideoArea {
    pub OffsetX: MFOffset,
    pub OffsetY: MFOffset,
    pub Area: super::super::Foundation::SIZE,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for MFVideoArea {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for MFVideoArea {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for MFVideoArea {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFVideoArea").field("OffsetX", &self.OffsetX).field("OffsetY", &self.OffsetY).field("Area", &self.Area).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for MFVideoArea {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for MFVideoArea {
    fn eq(&self, other: &Self) -> bool {
        self.OffsetX == other.OffsetX && self.OffsetY == other.OffsetY && self.Area == other.Area
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for MFVideoArea {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MFVideoArea {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFVideoCompressedInfo {
    pub AvgBitrate: i64,
    pub AvgBitErrorRate: i64,
    pub MaxKeyFrameSpacing: u32,
}
impl ::core::marker::Copy for MFVideoCompressedInfo {}
impl ::core::clone::Clone for MFVideoCompressedInfo {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFVideoCompressedInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFVideoCompressedInfo").field("AvgBitrate", &self.AvgBitrate).field("AvgBitErrorRate", &self.AvgBitErrorRate).field("MaxKeyFrameSpacing", &self.MaxKeyFrameSpacing).finish()
    }
}
impl ::windows::core::TypeKind for MFVideoCompressedInfo {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFVideoCompressedInfo {
    fn eq(&self, other: &Self) -> bool {
        self.AvgBitrate == other.AvgBitrate && self.AvgBitErrorRate == other.AvgBitErrorRate && self.MaxKeyFrameSpacing == other.MaxKeyFrameSpacing
    }
}
impl ::core::cmp::Eq for MFVideoCompressedInfo {}
impl ::core::default::Default for MFVideoCompressedInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct MFVideoInfo {
    pub dwWidth: u32,
    pub dwHeight: u32,
    pub PixelAspectRatio: MFRatio,
    pub SourceChromaSubsampling: MFVideoChromaSubsampling,
    pub InterlaceMode: MFVideoInterlaceMode,
    pub TransferFunction: MFVideoTransferFunction,
    pub ColorPrimaries: MFVideoPrimaries,
    pub TransferMatrix: MFVideoTransferMatrix,
    pub SourceLighting: MFVideoLighting,
    pub FramesPerSecond: MFRatio,
    pub NominalRange: MFNominalRange,
    pub GeometricAperture: MFVideoArea,
    pub MinimumDisplayAperture: MFVideoArea,
    pub PanScanAperture: MFVideoArea,
    pub VideoFlags: u64,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for MFVideoInfo {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for MFVideoInfo {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for MFVideoInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFVideoInfo")
            .field("dwWidth", &self.dwWidth)
            .field("dwHeight", &self.dwHeight)
            .field("PixelAspectRatio", &self.PixelAspectRatio)
            .field("SourceChromaSubsampling", &self.SourceChromaSubsampling)
            .field("InterlaceMode", &self.InterlaceMode)
            .field("TransferFunction", &self.TransferFunction)
            .field("ColorPrimaries", &self.ColorPrimaries)
            .field("TransferMatrix", &self.TransferMatrix)
            .field("SourceLighting", &self.SourceLighting)
            .field("FramesPerSecond", &self.FramesPerSecond)
            .field("NominalRange", &self.NominalRange)
            .field("GeometricAperture", &self.GeometricAperture)
            .field("MinimumDisplayAperture", &self.MinimumDisplayAperture)
            .field("PanScanAperture", &self.PanScanAperture)
            .field("VideoFlags", &self.VideoFlags)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for MFVideoInfo {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for MFVideoInfo {
    fn eq(&self, other: &Self) -> bool {
        self.dwWidth == other.dwWidth && self.dwHeight == other.dwHeight && self.PixelAspectRatio == other.PixelAspectRatio && self.SourceChromaSubsampling == other.SourceChromaSubsampling && self.InterlaceMode == other.InterlaceMode && self.TransferFunction == other.TransferFunction && self.ColorPrimaries == other.ColorPrimaries && self.TransferMatrix == other.TransferMatrix && self.SourceLighting == other.SourceLighting && self.FramesPerSecond == other.FramesPerSecond && self.NominalRange == other.NominalRange && self.GeometricAperture == other.GeometricAperture && self.MinimumDisplayAperture == other.MinimumDisplayAperture && self.PanScanAperture == other.PanScanAperture && self.VideoFlags == other.VideoFlags
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for MFVideoInfo {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MFVideoInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFVideoNormalizedRect {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
impl ::core::marker::Copy for MFVideoNormalizedRect {}
impl ::core::clone::Clone for MFVideoNormalizedRect {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFVideoNormalizedRect {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFVideoNormalizedRect").field("left", &self.left).field("top", &self.top).field("right", &self.right).field("bottom", &self.bottom).finish()
    }
}
impl ::windows::core::TypeKind for MFVideoNormalizedRect {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MFVideoNormalizedRect {
    fn eq(&self, other: &Self) -> bool {
        self.left == other.left && self.top == other.top && self.right == other.right && self.bottom == other.bottom
    }
}
impl ::core::cmp::Eq for MFVideoNormalizedRect {}
impl ::core::default::Default for MFVideoNormalizedRect {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MFVideoSurfaceInfo {
    pub Format: u32,
    pub PaletteEntries: u32,
    pub Palette: [MFPaletteEntry; 1],
}
impl ::core::marker::Copy for MFVideoSurfaceInfo {}
impl ::core::clone::Clone for MFVideoSurfaceInfo {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for MFVideoSurfaceInfo {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for MFVideoSurfaceInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MF_BYTE_STREAM_CACHE_RANGE {
    pub qwStartOffset: u64,
    pub qwEndOffset: u64,
}
impl ::core::marker::Copy for MF_BYTE_STREAM_CACHE_RANGE {}
impl ::core::clone::Clone for MF_BYTE_STREAM_CACHE_RANGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MF_BYTE_STREAM_CACHE_RANGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MF_BYTE_STREAM_CACHE_RANGE").field("qwStartOffset", &self.qwStartOffset).field("qwEndOffset", &self.qwEndOffset).finish()
    }
}
impl ::windows::core::TypeKind for MF_BYTE_STREAM_CACHE_RANGE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MF_BYTE_STREAM_CACHE_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.qwStartOffset == other.qwStartOffset && self.qwEndOffset == other.qwEndOffset
    }
}
impl ::core::cmp::Eq for MF_BYTE_STREAM_CACHE_RANGE {}
impl ::core::default::Default for MF_BYTE_STREAM_CACHE_RANGE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MF_CAMERA_CONTROL_RANGE_INFO {
    pub minValue: i32,
    pub maxValue: i32,
    pub stepValue: i32,
    pub defaultValue: i32,
}
impl ::core::marker::Copy for MF_CAMERA_CONTROL_RANGE_INFO {}
impl ::core::clone::Clone for MF_CAMERA_CONTROL_RANGE_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MF_CAMERA_CONTROL_RANGE_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MF_CAMERA_CONTROL_RANGE_INFO").field("minValue", &self.minValue).field("maxValue", &self.maxValue).field("stepValue", &self.stepValue).field("defaultValue", &self.defaultValue).finish()
    }
}
impl ::windows::core::TypeKind for MF_CAMERA_CONTROL_RANGE_INFO {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MF_CAMERA_CONTROL_RANGE_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.minValue == other.minValue && self.maxValue == other.maxValue && self.stepValue == other.stepValue && self.defaultValue == other.defaultValue
    }
}
impl ::core::cmp::Eq for MF_CAMERA_CONTROL_RANGE_INFO {}
impl ::core::default::Default for MF_CAMERA_CONTROL_RANGE_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MF_FLOAT2 {
    pub x: f32,
    pub y: f32,
}
impl ::core::marker::Copy for MF_FLOAT2 {}
impl ::core::clone::Clone for MF_FLOAT2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MF_FLOAT2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MF_FLOAT2").field("x", &self.x).field("y", &self.y).finish()
    }
}
impl ::windows::core::TypeKind for MF_FLOAT2 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MF_FLOAT2 {
    fn eq(&self, other: &Self) -> bool {
        self.x == other.x && self.y == other.y
    }
}
impl ::core::cmp::Eq for MF_FLOAT2 {}
impl ::core::default::Default for MF_FLOAT2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MF_FLOAT3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
impl ::core::marker::Copy for MF_FLOAT3 {}
impl ::core::clone::Clone for MF_FLOAT3 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MF_FLOAT3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MF_FLOAT3").field("x", &self.x).field("y", &self.y).field("z", &self.z).finish()
    }
}
impl ::windows::core::TypeKind for MF_FLOAT3 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MF_FLOAT3 {
    fn eq(&self, other: &Self) -> bool {
        self.x == other.x && self.y == other.y && self.z == other.z
    }
}
impl ::core::cmp::Eq for MF_FLOAT3 {}
impl ::core::default::Default for MF_FLOAT3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MF_LEAKY_BUCKET_PAIR {
    pub dwBitrate: u32,
    pub msBufferWindow: u32,
}
impl ::core::marker::Copy for MF_LEAKY_BUCKET_PAIR {}
impl ::core::clone::Clone for MF_LEAKY_BUCKET_PAIR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MF_LEAKY_BUCKET_PAIR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MF_LEAKY_BUCKET_PAIR").field("dwBitrate", &self.dwBitrate).field("msBufferWindow", &self.msBufferWindow).finish()
    }
}
impl ::windows::core::TypeKind for MF_LEAKY_BUCKET_PAIR {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MF_LEAKY_BUCKET_PAIR {
    fn eq(&self, other: &Self) -> bool {
        self.dwBitrate == other.dwBitrate && self.msBufferWindow == other.msBufferWindow
    }
}
impl ::core::cmp::Eq for MF_LEAKY_BUCKET_PAIR {}
impl ::core::default::Default for MF_LEAKY_BUCKET_PAIR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MF_QUATERNION {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
impl ::core::marker::Copy for MF_QUATERNION {}
impl ::core::clone::Clone for MF_QUATERNION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MF_QUATERNION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MF_QUATERNION").field("x", &self.x).field("y", &self.y).field("z", &self.z).field("w", &self.w).finish()
    }
}
impl ::windows::core::TypeKind for MF_QUATERNION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MF_QUATERNION {
    fn eq(&self, other: &Self) -> bool {
        self.x == other.x && self.y == other.y && self.z == other.z && self.w == other.w
    }
}
impl ::core::cmp::Eq for MF_QUATERNION {}
impl ::core::default::Default for MF_QUATERNION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MF_SINK_WRITER_STATISTICS {
    pub cb: u32,
    pub llLastTimestampReceived: i64,
    pub llLastTimestampEncoded: i64,
    pub llLastTimestampProcessed: i64,
    pub llLastStreamTickReceived: i64,
    pub llLastSinkSampleRequest: i64,
    pub qwNumSamplesReceived: u64,
    pub qwNumSamplesEncoded: u64,
    pub qwNumSamplesProcessed: u64,
    pub qwNumStreamTicksReceived: u64,
    pub dwByteCountQueued: u32,
    pub qwByteCountProcessed: u64,
    pub dwNumOutstandingSinkSampleRequests: u32,
    pub dwAverageSampleRateReceived: u32,
    pub dwAverageSampleRateEncoded: u32,
    pub dwAverageSampleRateProcessed: u32,
}
impl ::core::marker::Copy for MF_SINK_WRITER_STATISTICS {}
impl ::core::clone::Clone for MF_SINK_WRITER_STATISTICS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MF_SINK_WRITER_STATISTICS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MF_SINK_WRITER_STATISTICS")
            .field("cb", &self.cb)
            .field("llLastTimestampReceived", &self.llLastTimestampReceived)
            .field("llLastTimestampEncoded", &self.llLastTimestampEncoded)
            .field("llLastTimestampProcessed", &self.llLastTimestampProcessed)
            .field("llLastStreamTickReceived", &self.llLastStreamTickReceived)
            .field("llLastSinkSampleRequest", &self.llLastSinkSampleRequest)
            .field("qwNumSamplesReceived", &self.qwNumSamplesReceived)
            .field("qwNumSamplesEncoded", &self.qwNumSamplesEncoded)
            .field("qwNumSamplesProcessed", &self.qwNumSamplesProcessed)
            .field("qwNumStreamTicksReceived", &self.qwNumStreamTicksReceived)
            .field("dwByteCountQueued", &self.dwByteCountQueued)
            .field("qwByteCountProcessed", &self.qwByteCountProcessed)
            .field("dwNumOutstandingSinkSampleRequests", &self.dwNumOutstandingSinkSampleRequests)
            .field("dwAverageSampleRateReceived", &self.dwAverageSampleRateReceived)
            .field("dwAverageSampleRateEncoded", &self.dwAverageSampleRateEncoded)
            .field("dwAverageSampleRateProcessed", &self.dwAverageSampleRateProcessed)
            .finish()
    }
}
impl ::windows::core::TypeKind for MF_SINK_WRITER_STATISTICS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MF_SINK_WRITER_STATISTICS {
    fn eq(&self, other: &Self) -> bool {
        self.cb == other.cb
            && self.llLastTimestampReceived == other.llLastTimestampReceived
            && self.llLastTimestampEncoded == other.llLastTimestampEncoded
            && self.llLastTimestampProcessed == other.llLastTimestampProcessed
            && self.llLastStreamTickReceived == other.llLastStreamTickReceived
            && self.llLastSinkSampleRequest == other.llLastSinkSampleRequest
            && self.qwNumSamplesReceived == other.qwNumSamplesReceived
            && self.qwNumSamplesEncoded == other.qwNumSamplesEncoded
            && self.qwNumSamplesProcessed == other.qwNumSamplesProcessed
            && self.qwNumStreamTicksReceived == other.qwNumStreamTicksReceived
            && self.dwByteCountQueued == other.dwByteCountQueued
            && self.qwByteCountProcessed == other.qwByteCountProcessed
            && self.dwNumOutstandingSinkSampleRequests == other.dwNumOutstandingSinkSampleRequests
            && self.dwAverageSampleRateReceived == other.dwAverageSampleRateReceived
            && self.dwAverageSampleRateEncoded == other.dwAverageSampleRateEncoded
            && self.dwAverageSampleRateProcessed == other.dwAverageSampleRateProcessed
    }
}
impl ::core::cmp::Eq for MF_SINK_WRITER_STATISTICS {}
impl ::core::default::Default for MF_SINK_WRITER_STATISTICS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MF_TRANSCODE_SINK_INFO {
    pub dwVideoStreamID: u32,
    pub pVideoMediaType: ::std::mem::ManuallyDrop<::core::option::Option<IMFMediaType>>,
    pub dwAudioStreamID: u32,
    pub pAudioMediaType: ::std::mem::ManuallyDrop<::core::option::Option<IMFMediaType>>,
}
impl ::core::clone::Clone for MF_TRANSCODE_SINK_INFO {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for MF_TRANSCODE_SINK_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MF_TRANSCODE_SINK_INFO").field("dwVideoStreamID", &self.dwVideoStreamID).field("pVideoMediaType", &self.pVideoMediaType).field("dwAudioStreamID", &self.dwAudioStreamID).field("pAudioMediaType", &self.pAudioMediaType).finish()
    }
}
impl ::windows::core::TypeKind for MF_TRANSCODE_SINK_INFO {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MF_TRANSCODE_SINK_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.dwVideoStreamID == other.dwVideoStreamID && self.pVideoMediaType == other.pVideoMediaType && self.dwAudioStreamID == other.dwAudioStreamID && self.pAudioMediaType == other.pAudioMediaType
    }
}
impl ::core::cmp::Eq for MF_TRANSCODE_SINK_INFO {}
impl ::core::default::Default for MF_TRANSCODE_SINK_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MF_VIDEO_SPHERICAL_VIEWDIRECTION {
    pub iHeading: i32,
    pub iPitch: i32,
    pub iRoll: i32,
}
impl ::core::marker::Copy for MF_VIDEO_SPHERICAL_VIEWDIRECTION {}
impl ::core::clone::Clone for MF_VIDEO_SPHERICAL_VIEWDIRECTION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MF_VIDEO_SPHERICAL_VIEWDIRECTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MF_VIDEO_SPHERICAL_VIEWDIRECTION").field("iHeading", &self.iHeading).field("iPitch", &self.iPitch).field("iRoll", &self.iRoll).finish()
    }
}
impl ::windows::core::TypeKind for MF_VIDEO_SPHERICAL_VIEWDIRECTION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MF_VIDEO_SPHERICAL_VIEWDIRECTION {
    fn eq(&self, other: &Self) -> bool {
        self.iHeading == other.iHeading && self.iPitch == other.iPitch && self.iRoll == other.iRoll
    }
}
impl ::core::cmp::Eq for MF_VIDEO_SPHERICAL_VIEWDIRECTION {}
impl ::core::default::Default for MF_VIDEO_SPHERICAL_VIEWDIRECTION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct MOVEREGION_INFO {
    pub FrameNumber: u32,
    pub NumMoveRegions: u32,
    pub MoveRegions: [MOVE_RECT; 1],
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for MOVEREGION_INFO {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for MOVEREGION_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for MOVEREGION_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MOVEREGION_INFO").field("FrameNumber", &self.FrameNumber).field("NumMoveRegions", &self.NumMoveRegions).field("MoveRegions", &self.MoveRegions).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for MOVEREGION_INFO {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for MOVEREGION_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.FrameNumber == other.FrameNumber && self.NumMoveRegions == other.NumMoveRegions && self.MoveRegions == other.MoveRegions
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for MOVEREGION_INFO {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MOVEREGION_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct MOVE_RECT {
    pub SourcePoint: super::super::Foundation::POINT,
    pub DestRect: super::super::Foundation::RECT,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for MOVE_RECT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for MOVE_RECT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for MOVE_RECT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MOVE_RECT").field("SourcePoint", &self.SourcePoint).field("DestRect", &self.DestRect).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for MOVE_RECT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for MOVE_RECT {
    fn eq(&self, other: &Self) -> bool {
        self.SourcePoint == other.SourcePoint && self.DestRect == other.DestRect
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for MOVE_RECT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MOVE_RECT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Gdi\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
pub struct MPEG1VIDEOINFO {
    pub hdr: VIDEOINFOHEADER,
    pub dwStartTimeCode: u32,
    pub cbSequenceHeader: u32,
    pub bSequenceHeader: [u8; 1],
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::marker::Copy for MPEG1VIDEOINFO {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::clone::Clone for MPEG1VIDEOINFO {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::fmt::Debug for MPEG1VIDEOINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MPEG1VIDEOINFO").field("hdr", &self.hdr).field("dwStartTimeCode", &self.dwStartTimeCode).field("cbSequenceHeader", &self.cbSequenceHeader).field("bSequenceHeader", &self.bSequenceHeader).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::windows::core::TypeKind for MPEG1VIDEOINFO {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::cmp::PartialEq for MPEG1VIDEOINFO {
    fn eq(&self, other: &Self) -> bool {
        self.hdr == other.hdr && self.dwStartTimeCode == other.dwStartTimeCode && self.cbSequenceHeader == other.cbSequenceHeader && self.bSequenceHeader == other.bSequenceHeader
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::cmp::Eq for MPEG1VIDEOINFO {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::default::Default for MPEG1VIDEOINFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Gdi\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
pub struct MPEG2VIDEOINFO {
    pub hdr: VIDEOINFOHEADER2,
    pub dwStartTimeCode: u32,
    pub cbSequenceHeader: u32,
    pub dwProfile: u32,
    pub dwLevel: u32,
    pub dwFlags: MPEG2VIDEOINFO_FLAGS,
    pub dwSequenceHeader: [u32; 1],
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::marker::Copy for MPEG2VIDEOINFO {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::clone::Clone for MPEG2VIDEOINFO {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::windows::core::TypeKind for MPEG2VIDEOINFO {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::default::Default for MPEG2VIDEOINFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct MT_ARBITRARY_HEADER {
    pub majortype: ::windows::core::GUID,
    pub subtype: ::windows::core::GUID,
    pub bFixedSizeSamples: super::super::Foundation::BOOL,
    pub bTemporalCompression: super::super::Foundation::BOOL,
    pub lSampleSize: u32,
    pub formattype: ::windows::core::GUID,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for MT_ARBITRARY_HEADER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for MT_ARBITRARY_HEADER {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for MT_ARBITRARY_HEADER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MT_ARBITRARY_HEADER").field("majortype", &self.majortype).field("subtype", &self.subtype).field("bFixedSizeSamples", &self.bFixedSizeSamples).field("bTemporalCompression", &self.bTemporalCompression).field("lSampleSize", &self.lSampleSize).field("formattype", &self.formattype).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for MT_ARBITRARY_HEADER {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for MT_ARBITRARY_HEADER {
    fn eq(&self, other: &Self) -> bool {
        self.majortype == other.majortype && self.subtype == other.subtype && self.bFixedSizeSamples == other.bFixedSizeSamples && self.bTemporalCompression == other.bTemporalCompression && self.lSampleSize == other.lSampleSize && self.formattype == other.formattype
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for MT_ARBITRARY_HEADER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MT_ARBITRARY_HEADER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct MT_CUSTOM_VIDEO_PRIMARIES {
    pub fRx: f32,
    pub fRy: f32,
    pub fGx: f32,
    pub fGy: f32,
    pub fBx: f32,
    pub fBy: f32,
    pub fWx: f32,
    pub fWy: f32,
}
impl ::core::marker::Copy for MT_CUSTOM_VIDEO_PRIMARIES {}
impl ::core::clone::Clone for MT_CUSTOM_VIDEO_PRIMARIES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MT_CUSTOM_VIDEO_PRIMARIES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MT_CUSTOM_VIDEO_PRIMARIES").field("fRx", &self.fRx).field("fRy", &self.fRy).field("fGx", &self.fGx).field("fGy", &self.fGy).field("fBx", &self.fBx).field("fBy", &self.fBy).field("fWx", &self.fWx).field("fWy", &self.fWy).finish()
    }
}
impl ::windows::core::TypeKind for MT_CUSTOM_VIDEO_PRIMARIES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for MT_CUSTOM_VIDEO_PRIMARIES {
    fn eq(&self, other: &Self) -> bool {
        self.fRx == other.fRx && self.fRy == other.fRy && self.fGx == other.fGx && self.fGy == other.fGy && self.fBx == other.fBx && self.fBy == other.fBy && self.fWx == other.fWx && self.fWy == other.fWy
    }
}
impl ::core::cmp::Eq for MT_CUSTOM_VIDEO_PRIMARIES {}
impl ::core::default::Default for MT_CUSTOM_VIDEO_PRIMARIES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct OPM_ACP_AND_CGMSA_SIGNALING {
    pub rnRandomNumber: OPM_RANDOM_NUMBER,
    pub ulStatusFlags: u32,
    pub ulAvailableTVProtectionStandards: u32,
    pub ulActiveTVProtectionStandard: u32,
    pub ulReserved: u32,
    pub ulAspectRatioValidMask1: u32,
    pub ulAspectRatioData1: u32,
    pub ulAspectRatioValidMask2: u32,
    pub ulAspectRatioData2: u32,
    pub ulAspectRatioValidMask3: u32,
    pub ulAspectRatioData3: u32,
    pub ulReserved2: [u32; 4],
    pub ulReserved3: [u32; 4],
}
impl ::core::marker::Copy for OPM_ACP_AND_CGMSA_SIGNALING {}
impl ::core::clone::Clone for OPM_ACP_AND_CGMSA_SIGNALING {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for OPM_ACP_AND_CGMSA_SIGNALING {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for OPM_ACP_AND_CGMSA_SIGNALING {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub struct OPM_ACTUAL_OUTPUT_FORMAT {
    pub rnRandomNumber: OPM_RANDOM_NUMBER,
    pub ulStatusFlags: u32,
    pub ulDisplayWidth: u32,
    pub ulDisplayHeight: u32,
    pub dsfSampleInterleaveFormat: DXVA2_SampleFormat,
    pub d3dFormat: super::super::Graphics::Direct3D9::D3DFORMAT,
    pub ulFrequencyNumerator: u32,
    pub ulFrequencyDenominator: u32,
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::marker::Copy for OPM_ACTUAL_OUTPUT_FORMAT {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::clone::Clone for OPM_ACTUAL_OUTPUT_FORMAT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::windows::core::TypeKind for OPM_ACTUAL_OUTPUT_FORMAT {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl ::core::default::Default for OPM_ACTUAL_OUTPUT_FORMAT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct OPM_CONFIGURE_PARAMETERS {
    pub omac: OPM_OMAC,
    pub guidSetting: ::windows::core::GUID,
    pub ulSequenceNumber: u32,
    pub cbParametersSize: u32,
    pub abParameters: [u8; 4056],
}
impl ::core::marker::Copy for OPM_CONFIGURE_PARAMETERS {}
impl ::core::clone::Clone for OPM_CONFIGURE_PARAMETERS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for OPM_CONFIGURE_PARAMETERS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for OPM_CONFIGURE_PARAMETERS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct OPM_CONNECTED_HDCP_DEVICE_INFORMATION {
    pub rnRandomNumber: OPM_RANDOM_NUMBER,
    pub ulStatusFlags: u32,
    pub ulHDCPFlags: u32,
    pub ksvB: OPM_HDCP_KEY_SELECTION_VECTOR,
    pub Reserved: [u8; 11],
    pub Reserved2: [u8; 16],
    pub Reserved3: [u8; 16],
}
impl ::core::marker::Copy for OPM_CONNECTED_HDCP_DEVICE_INFORMATION {}
impl ::core::clone::Clone for OPM_CONNECTED_HDCP_DEVICE_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for OPM_CONNECTED_HDCP_DEVICE_INFORMATION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for OPM_CONNECTED_HDCP_DEVICE_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS {
    pub rnRandomNumber: OPM_RANDOM_NUMBER,
    pub guidInformation: ::windows::core::GUID,
    pub ulSequenceNumber: u32,
    pub cbParametersSize: u32,
    pub abParameters: [u8; 4056],
}
impl ::core::marker::Copy for OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS {}
impl ::core::clone::Clone for OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct OPM_ENCRYPTED_INITIALIZATION_PARAMETERS {
    pub abEncryptedInitializationParameters: [u8; 256],
}
impl ::core::marker::Copy for OPM_ENCRYPTED_INITIALIZATION_PARAMETERS {}
impl ::core::clone::Clone for OPM_ENCRYPTED_INITIALIZATION_PARAMETERS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for OPM_ENCRYPTED_INITIALIZATION_PARAMETERS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("OPM_ENCRYPTED_INITIALIZATION_PARAMETERS").field("abEncryptedInitializationParameters", &self.abEncryptedInitializationParameters).finish()
    }
}
impl ::windows::core::TypeKind for OPM_ENCRYPTED_INITIALIZATION_PARAMETERS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for OPM_ENCRYPTED_INITIALIZATION_PARAMETERS {
    fn eq(&self, other: &Self) -> bool {
        self.abEncryptedInitializationParameters == other.abEncryptedInitializationParameters
    }
}
impl ::core::cmp::Eq for OPM_ENCRYPTED_INITIALIZATION_PARAMETERS {}
impl ::core::default::Default for OPM_ENCRYPTED_INITIALIZATION_PARAMETERS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct OPM_GET_CODEC_INFO_INFORMATION {
    pub rnRandomNumber: OPM_RANDOM_NUMBER,
    pub Merit: u32,
}
impl ::core::marker::Copy for OPM_GET_CODEC_INFO_INFORMATION {}
impl ::core::clone::Clone for OPM_GET_CODEC_INFO_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for OPM_GET_CODEC_INFO_INFORMATION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for OPM_GET_CODEC_INFO_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct OPM_GET_CODEC_INFO_PARAMETERS {
    pub cbVerifier: u32,
    pub Verifier: [u8; 4052],
}
impl ::core::marker::Copy for OPM_GET_CODEC_INFO_PARAMETERS {}
impl ::core::clone::Clone for OPM_GET_CODEC_INFO_PARAMETERS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for OPM_GET_CODEC_INFO_PARAMETERS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for OPM_GET_CODEC_INFO_PARAMETERS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct OPM_GET_INFO_PARAMETERS {
    pub omac: OPM_OMAC,
    pub rnRandomNumber: OPM_RANDOM_NUMBER,
    pub guidInformation: ::windows::core::GUID,
    pub ulSequenceNumber: u32,
    pub cbParametersSize: u32,
    pub abParameters: [u8; 4056],
}
impl ::core::marker::Copy for OPM_GET_INFO_PARAMETERS {}
impl ::core::clone::Clone for OPM_GET_INFO_PARAMETERS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for OPM_GET_INFO_PARAMETERS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for OPM_GET_INFO_PARAMETERS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct OPM_HDCP_KEY_SELECTION_VECTOR {
    pub abKeySelectionVector: [u8; 5],
}
impl ::core::marker::Copy for OPM_HDCP_KEY_SELECTION_VECTOR {}
impl ::core::clone::Clone for OPM_HDCP_KEY_SELECTION_VECTOR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for OPM_HDCP_KEY_SELECTION_VECTOR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("OPM_HDCP_KEY_SELECTION_VECTOR").field("abKeySelectionVector", &self.abKeySelectionVector).finish()
    }
}
impl ::windows::core::TypeKind for OPM_HDCP_KEY_SELECTION_VECTOR {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for OPM_HDCP_KEY_SELECTION_VECTOR {
    fn eq(&self, other: &Self) -> bool {
        self.abKeySelectionVector == other.abKeySelectionVector
    }
}
impl ::core::cmp::Eq for OPM_HDCP_KEY_SELECTION_VECTOR {}
impl ::core::default::Default for OPM_HDCP_KEY_SELECTION_VECTOR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct OPM_OMAC {
    pub abOMAC: [u8; 16],
}
impl ::core::marker::Copy for OPM_OMAC {}
impl ::core::clone::Clone for OPM_OMAC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for OPM_OMAC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("OPM_OMAC").field("abOMAC", &self.abOMAC).finish()
    }
}
impl ::windows::core::TypeKind for OPM_OMAC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for OPM_OMAC {
    fn eq(&self, other: &Self) -> bool {
        self.abOMAC == other.abOMAC
    }
}
impl ::core::cmp::Eq for OPM_OMAC {}
impl ::core::default::Default for OPM_OMAC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct OPM_OUTPUT_ID_DATA {
    pub rnRandomNumber: OPM_RANDOM_NUMBER,
    pub ulStatusFlags: u32,
    pub OutputId: u64,
}
impl ::core::marker::Copy for OPM_OUTPUT_ID_DATA {}
impl ::core::clone::Clone for OPM_OUTPUT_ID_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for OPM_OUTPUT_ID_DATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for OPM_OUTPUT_ID_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct OPM_RANDOM_NUMBER {
    pub abRandomNumber: [u8; 16],
}
impl ::core::marker::Copy for OPM_RANDOM_NUMBER {}
impl ::core::clone::Clone for OPM_RANDOM_NUMBER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for OPM_RANDOM_NUMBER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("OPM_RANDOM_NUMBER").field("abRandomNumber", &self.abRandomNumber).finish()
    }
}
impl ::windows::core::TypeKind for OPM_RANDOM_NUMBER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for OPM_RANDOM_NUMBER {
    fn eq(&self, other: &Self) -> bool {
        self.abRandomNumber == other.abRandomNumber
    }
}
impl ::core::cmp::Eq for OPM_RANDOM_NUMBER {}
impl ::core::default::Default for OPM_RANDOM_NUMBER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct OPM_REQUESTED_INFORMATION {
    pub omac: OPM_OMAC,
    pub cbRequestedInformationSize: u32,
    pub abRequestedInformation: [u8; 4076],
}
impl ::core::marker::Copy for OPM_REQUESTED_INFORMATION {}
impl ::core::clone::Clone for OPM_REQUESTED_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for OPM_REQUESTED_INFORMATION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for OPM_REQUESTED_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct OPM_SET_ACP_AND_CGMSA_SIGNALING_PARAMETERS {
    pub ulNewTVProtectionStandard: u32,
    pub ulAspectRatioChangeMask1: u32,
    pub ulAspectRatioData1: u32,
    pub ulAspectRatioChangeMask2: u32,
    pub ulAspectRatioData2: u32,
    pub ulAspectRatioChangeMask3: u32,
    pub ulAspectRatioData3: u32,
    pub ulReserved: [u32; 4],
    pub ulReserved2: [u32; 4],
    pub ulReserved3: u32,
}
impl ::core::marker::Copy for OPM_SET_ACP_AND_CGMSA_SIGNALING_PARAMETERS {}
impl ::core::clone::Clone for OPM_SET_ACP_AND_CGMSA_SIGNALING_PARAMETERS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for OPM_SET_ACP_AND_CGMSA_SIGNALING_PARAMETERS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for OPM_SET_ACP_AND_CGMSA_SIGNALING_PARAMETERS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct OPM_SET_HDCP_SRM_PARAMETERS {
    pub ulSRMVersion: u32,
}
impl ::core::marker::Copy for OPM_SET_HDCP_SRM_PARAMETERS {}
impl ::core::clone::Clone for OPM_SET_HDCP_SRM_PARAMETERS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for OPM_SET_HDCP_SRM_PARAMETERS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for OPM_SET_HDCP_SRM_PARAMETERS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct OPM_SET_PROTECTION_LEVEL_PARAMETERS {
    pub ulProtectionType: u32,
    pub ulProtectionLevel: u32,
    pub Reserved: u32,
    pub Reserved2: u32,
}
impl ::core::marker::Copy for OPM_SET_PROTECTION_LEVEL_PARAMETERS {}
impl ::core::clone::Clone for OPM_SET_PROTECTION_LEVEL_PARAMETERS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for OPM_SET_PROTECTION_LEVEL_PARAMETERS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for OPM_SET_PROTECTION_LEVEL_PARAMETERS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct OPM_STANDARD_INFORMATION {
    pub rnRandomNumber: OPM_RANDOM_NUMBER,
    pub ulStatusFlags: u32,
    pub ulInformation: u32,
    pub ulReserved: u32,
    pub ulReserved2: u32,
}
impl ::core::marker::Copy for OPM_STANDARD_INFORMATION {}
impl ::core::clone::Clone for OPM_STANDARD_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for OPM_STANDARD_INFORMATION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for OPM_STANDARD_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct ROI_AREA {
    pub rect: super::super::Foundation::RECT,
    pub QPDelta: i32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for ROI_AREA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for ROI_AREA {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for ROI_AREA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ROI_AREA").field("rect", &self.rect).field("QPDelta", &self.QPDelta).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows::core::TypeKind for ROI_AREA {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for ROI_AREA {
    fn eq(&self, other: &Self) -> bool {
        self.rect == other.rect && self.QPDelta == other.QPDelta
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for ROI_AREA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for ROI_AREA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct SENSORPROFILEID {
    pub Type: ::windows::core::GUID,
    pub Index: u32,
    pub Unused: u32,
}
impl ::core::marker::Copy for SENSORPROFILEID {}
impl ::core::clone::Clone for SENSORPROFILEID {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SENSORPROFILEID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SENSORPROFILEID").field("Type", &self.Type).field("Index", &self.Index).field("Unused", &self.Unused).finish()
    }
}
impl ::windows::core::TypeKind for SENSORPROFILEID {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for SENSORPROFILEID {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type && self.Index == other.Index && self.Unused == other.Unused
    }
}
impl ::core::cmp::Eq for SENSORPROFILEID {}
impl ::core::default::Default for SENSORPROFILEID {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct STREAM_MEDIUM {
    pub gidMedium: ::windows::core::GUID,
    pub unMediumInstance: u32,
}
impl ::core::marker::Copy for STREAM_MEDIUM {}
impl ::core::clone::Clone for STREAM_MEDIUM {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for STREAM_MEDIUM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("STREAM_MEDIUM").field("gidMedium", &self.gidMedium).field("unMediumInstance", &self.unMediumInstance).finish()
    }
}
impl ::windows::core::TypeKind for STREAM_MEDIUM {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for STREAM_MEDIUM {
    fn eq(&self, other: &Self) -> bool {
        self.gidMedium == other.gidMedium && self.unMediumInstance == other.unMediumInstance
    }
}
impl ::core::cmp::Eq for STREAM_MEDIUM {}
impl ::core::default::Default for STREAM_MEDIUM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct TOC_DESCRIPTOR {
    pub guidID: ::windows::core::GUID,
    pub wStreamNumber: u16,
    pub guidType: ::windows::core::GUID,
    pub wLanguageIndex: u16,
}
impl ::core::marker::Copy for TOC_DESCRIPTOR {}
impl ::core::clone::Clone for TOC_DESCRIPTOR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for TOC_DESCRIPTOR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOC_DESCRIPTOR").field("guidID", &self.guidID).field("wStreamNumber", &self.wStreamNumber).field("guidType", &self.guidType).field("wLanguageIndex", &self.wLanguageIndex).finish()
    }
}
impl ::windows::core::TypeKind for TOC_DESCRIPTOR {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for TOC_DESCRIPTOR {
    fn eq(&self, other: &Self) -> bool {
        self.guidID == other.guidID && self.wStreamNumber == other.wStreamNumber && self.guidType == other.guidType && self.wLanguageIndex == other.wLanguageIndex
    }
}
impl ::core::cmp::Eq for TOC_DESCRIPTOR {}
impl ::core::default::Default for TOC_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub struct TOC_ENTRY_DESCRIPTOR {
    pub qwStartTime: u64,
    pub qwEndTime: u64,
    pub qwStartPacketOffset: u64,
    pub qwEndPacketOffset: u64,
    pub qwRepresentativeFrameTime: u64,
}
impl ::core::marker::Copy for TOC_ENTRY_DESCRIPTOR {}
impl ::core::clone::Clone for TOC_ENTRY_DESCRIPTOR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for TOC_ENTRY_DESCRIPTOR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOC_ENTRY_DESCRIPTOR").field("qwStartTime", &self.qwStartTime).field("qwEndTime", &self.qwEndTime).field("qwStartPacketOffset", &self.qwStartPacketOffset).field("qwEndPacketOffset", &self.qwEndPacketOffset).field("qwRepresentativeFrameTime", &self.qwRepresentativeFrameTime).finish()
    }
}
impl ::windows::core::TypeKind for TOC_ENTRY_DESCRIPTOR {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for TOC_ENTRY_DESCRIPTOR {
    fn eq(&self, other: &Self) -> bool {
        self.qwStartTime == other.qwStartTime && self.qwEndTime == other.qwEndTime && self.qwStartPacketOffset == other.qwStartPacketOffset && self.qwEndPacketOffset == other.qwEndPacketOffset && self.qwRepresentativeFrameTime == other.qwRepresentativeFrameTime
    }
}
impl ::core::cmp::Eq for TOC_ENTRY_DESCRIPTOR {}
impl ::core::default::Default for TOC_ENTRY_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Gdi\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
pub struct VIDEOINFOHEADER {
    pub rcSource: super::super::Foundation::RECT,
    pub rcTarget: super::super::Foundation::RECT,
    pub dwBitRate: u32,
    pub dwBitErrorRate: u32,
    pub AvgTimePerFrame: i64,
    pub bmiHeader: super::super::Graphics::Gdi::BITMAPINFOHEADER,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::marker::Copy for VIDEOINFOHEADER {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::clone::Clone for VIDEOINFOHEADER {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::fmt::Debug for VIDEOINFOHEADER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VIDEOINFOHEADER").field("rcSource", &self.rcSource).field("rcTarget", &self.rcTarget).field("dwBitRate", &self.dwBitRate).field("dwBitErrorRate", &self.dwBitErrorRate).field("AvgTimePerFrame", &self.AvgTimePerFrame).field("bmiHeader", &self.bmiHeader).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::windows::core::TypeKind for VIDEOINFOHEADER {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::cmp::PartialEq for VIDEOINFOHEADER {
    fn eq(&self, other: &Self) -> bool {
        self.rcSource == other.rcSource && self.rcTarget == other.rcTarget && self.dwBitRate == other.dwBitRate && self.dwBitErrorRate == other.dwBitErrorRate && self.AvgTimePerFrame == other.AvgTimePerFrame && self.bmiHeader == other.bmiHeader
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::cmp::Eq for VIDEOINFOHEADER {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::default::Default for VIDEOINFOHEADER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Gdi\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
pub struct VIDEOINFOHEADER2 {
    pub rcSource: super::super::Foundation::RECT,
    pub rcTarget: super::super::Foundation::RECT,
    pub dwBitRate: u32,
    pub dwBitErrorRate: u32,
    pub AvgTimePerFrame: i64,
    pub dwInterlaceFlags: u32,
    pub dwCopyProtectFlags: u32,
    pub dwPictAspectRatioX: u32,
    pub dwPictAspectRatioY: u32,
    pub Anonymous: VIDEOINFOHEADER2_0,
    pub dwReserved2: u32,
    pub bmiHeader: super::super::Graphics::Gdi::BITMAPINFOHEADER,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::marker::Copy for VIDEOINFOHEADER2 {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::clone::Clone for VIDEOINFOHEADER2 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::windows::core::TypeKind for VIDEOINFOHEADER2 {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::default::Default for VIDEOINFOHEADER2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Gdi\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
pub union VIDEOINFOHEADER2_0 {
    pub dwControlFlags: u32,
    pub dwReserved1: u32,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::marker::Copy for VIDEOINFOHEADER2_0 {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::clone::Clone for VIDEOINFOHEADER2_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::windows::core::TypeKind for VIDEOINFOHEADER2_0 {
    type TypeKind = ::windows::core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl ::core::default::Default for VIDEOINFOHEADER2_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub type MFPERIODICCALLBACK = ::core::option::Option<unsafe extern "system" fn(pcontext: ::core::option::Option<::windows::core::IUnknown>) -> ()>;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub type PDXVAHDSW_CreateDevice = ::core::option::Option<unsafe extern "system" fn(pd3ddevice: ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DDevice9Ex>, phdevice: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT>;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type PDXVAHDSW_CreateVideoProcessor = ::core::option::Option<unsafe extern "system" fn(hdevice: super::super::Foundation::HANDLE, pvpguid: *const ::windows::core::GUID, phvideoprocessor: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT>;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type PDXVAHDSW_DestroyDevice = ::core::option::Option<unsafe extern "system" fn(hdevice: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT>;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type PDXVAHDSW_DestroyVideoProcessor = ::core::option::Option<unsafe extern "system" fn(hvideoprocessor: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT>;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type PDXVAHDSW_GetVideoProcessBltStatePrivate = ::core::option::Option<unsafe extern "system" fn(hvideoprocessor: super::super::Foundation::HANDLE, pdata: *mut DXVAHD_BLT_STATE_PRIVATE_DATA) -> ::windows::core::HRESULT>;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type PDXVAHDSW_GetVideoProcessStreamStatePrivate = ::core::option::Option<unsafe extern "system" fn(hvideoprocessor: super::super::Foundation::HANDLE, streamnumber: u32, pdata: *mut DXVAHD_STREAM_STATE_PRIVATE_DATA) -> ::windows::core::HRESULT>;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type PDXVAHDSW_GetVideoProcessorCaps = ::core::option::Option<unsafe extern "system" fn(hdevice: super::super::Foundation::HANDLE, pcontentdesc: *const DXVAHD_CONTENT_DESC, usage: DXVAHD_DEVICE_USAGE, count: u32, pcaps: *mut DXVAHD_VPCAPS) -> ::windows::core::HRESULT>;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type PDXVAHDSW_GetVideoProcessorCustomRates = ::core::option::Option<unsafe extern "system" fn(hdevice: super::super::Foundation::HANDLE, pvpguid: *const ::windows::core::GUID, count: u32, prates: *mut DXVAHD_CUSTOM_RATE_DATA) -> ::windows::core::HRESULT>;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub type PDXVAHDSW_GetVideoProcessorDeviceCaps = ::core::option::Option<unsafe extern "system" fn(hdevice: super::super::Foundation::HANDLE, pcontentdesc: *const DXVAHD_CONTENT_DESC, usage: DXVAHD_DEVICE_USAGE, pcaps: *mut DXVAHD_VPDEVCAPS) -> ::windows::core::HRESULT>;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type PDXVAHDSW_GetVideoProcessorFilterRange = ::core::option::Option<unsafe extern "system" fn(hdevice: super::super::Foundation::HANDLE, filter: DXVAHD_FILTER, prange: *mut DXVAHD_FILTER_RANGE_DATA) -> ::windows::core::HRESULT>;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub type PDXVAHDSW_GetVideoProcessorInputFormats = ::core::option::Option<unsafe extern "system" fn(hdevice: super::super::Foundation::HANDLE, pcontentdesc: *const DXVAHD_CONTENT_DESC, usage: DXVAHD_DEVICE_USAGE, count: u32, pformats: *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::HRESULT>;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub type PDXVAHDSW_GetVideoProcessorOutputFormats = ::core::option::Option<unsafe extern "system" fn(hdevice: super::super::Foundation::HANDLE, pcontentdesc: *const DXVAHD_CONTENT_DESC, usage: DXVAHD_DEVICE_USAGE, count: u32, pformats: *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::HRESULT>;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`*"]
pub type PDXVAHDSW_Plugin = ::core::option::Option<unsafe extern "system" fn(size: u32, pcallbacks: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT>;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub type PDXVAHDSW_ProposeVideoPrivateFormat = ::core::option::Option<unsafe extern "system" fn(hdevice: super::super::Foundation::HANDLE, pformat: *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::HRESULT>;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type PDXVAHDSW_SetVideoProcessBltState = ::core::option::Option<unsafe extern "system" fn(hvideoprocessor: super::super::Foundation::HANDLE, state: DXVAHD_BLT_STATE, datasize: u32, pdata: *const ::core::ffi::c_void) -> ::windows::core::HRESULT>;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type PDXVAHDSW_SetVideoProcessStreamState = ::core::option::Option<unsafe extern "system" fn(hvideoprocessor: super::super::Foundation::HANDLE, streamnumber: u32, state: DXVAHD_STREAM_STATE, datasize: u32, pdata: *const ::core::ffi::c_void) -> ::windows::core::HRESULT>;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub type PDXVAHDSW_VideoProcessBltHD = ::core::option::Option<unsafe extern "system" fn(hvideoprocessor: super::super::Foundation::HANDLE, poutputsurface: ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, outputframe: u32, streamcount: u32, pstreams: *const DXVAHD_STREAM_DATA) -> ::windows::core::HRESULT>;
#[doc = "*Required features: `\"Win32_Media_MediaFoundation\"`, `\"Win32_Graphics_Direct3D9\"`*"]
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub type PDXVAHD_CreateDevice = ::core::option::Option<unsafe extern "system" fn(pd3ddevice: ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DDevice9Ex>, pcontentdesc: *const DXVAHD_CONTENT_DESC, usage: DXVAHD_DEVICE_USAGE, pplugin: PDXVAHDSW_Plugin, ppdevice: *mut ::core::option::Option<IDXVAHD_Device>) -> ::windows::core::HRESULT>;
#[cfg(feature = "implement")]
::core::include!("impl.rs");
