pub trait IAdvancedMediaCapture_Impl: Sized + windows_core::IUnknownImpl {
    fn GetAdvancedMediaCaptureSettings(&self) -> windows_core::Result<IAdvancedMediaCaptureSettings>;
}
impl windows_core::RuntimeName for IAdvancedMediaCapture {}
impl IAdvancedMediaCapture_Vtbl {
    pub const fn new<Identity: IAdvancedMediaCapture_Impl, const OFFSET: isize>() -> IAdvancedMediaCapture_Vtbl {
        unsafe extern "system" fn GetAdvancedMediaCaptureSettings<Identity: IAdvancedMediaCapture_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IAdvancedMediaCapture_Impl::GetAdvancedMediaCaptureSettings(this) {
                Ok(ok__) => {
                    value.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetAdvancedMediaCaptureSettings: GetAdvancedMediaCaptureSettings::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAdvancedMediaCapture as windows_core::Interface>::IID
    }
}
pub trait IAdvancedMediaCaptureInitializationSettings_Impl: Sized + windows_core::IUnknownImpl {
    fn SetDirectxDeviceManager(&self, value: Option<&IMFDXGIDeviceManager>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IAdvancedMediaCaptureInitializationSettings {}
impl IAdvancedMediaCaptureInitializationSettings_Vtbl {
    pub const fn new<Identity: IAdvancedMediaCaptureInitializationSettings_Impl, const OFFSET: isize>() -> IAdvancedMediaCaptureInitializationSettings_Vtbl {
        unsafe extern "system" fn SetDirectxDeviceManager<Identity: IAdvancedMediaCaptureInitializationSettings_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IAdvancedMediaCaptureInitializationSettings_Impl::SetDirectxDeviceManager(this, windows_core::from_raw_borrowed(&value)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), SetDirectxDeviceManager: SetDirectxDeviceManager::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAdvancedMediaCaptureInitializationSettings as windows_core::Interface>::IID
    }
}
pub trait IAdvancedMediaCaptureSettings_Impl: Sized + windows_core::IUnknownImpl {
    fn GetDirectxDeviceManager(&self) -> windows_core::Result<IMFDXGIDeviceManager>;
}
impl windows_core::RuntimeName for IAdvancedMediaCaptureSettings {}
impl IAdvancedMediaCaptureSettings_Vtbl {
    pub const fn new<Identity: IAdvancedMediaCaptureSettings_Impl, const OFFSET: isize>() -> IAdvancedMediaCaptureSettings_Vtbl {
        unsafe extern "system" fn GetDirectxDeviceManager<Identity: IAdvancedMediaCaptureSettings_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IAdvancedMediaCaptureSettings_Impl::GetDirectxDeviceManager(this) {
                Ok(ok__) => {
                    value.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetDirectxDeviceManager: GetDirectxDeviceManager::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAdvancedMediaCaptureSettings as windows_core::Interface>::IID
    }
}
pub trait IAudioSourceProvider_Impl: Sized + windows_core::IUnknownImpl {
    fn ProvideInput(&self, dwsamplecount: u32, pdwchannelcount: *mut u32, pinterleavedaudiodata: *mut f32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IAudioSourceProvider {}
impl IAudioSourceProvider_Vtbl {
    pub const fn new<Identity: IAudioSourceProvider_Impl, const OFFSET: isize>() -> IAudioSourceProvider_Vtbl {
        unsafe extern "system" fn ProvideInput<Identity: IAudioSourceProvider_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwsamplecount: u32, pdwchannelcount: *mut u32, pinterleavedaudiodata: *mut f32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IAudioSourceProvider_Impl::ProvideInput(this, core::mem::transmute_copy(&dwsamplecount), core::mem::transmute_copy(&pdwchannelcount), core::mem::transmute_copy(&pinterleavedaudiodata)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), ProvideInput: ProvideInput::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IAudioSourceProvider as windows_core::Interface>::IID
    }
}
pub trait IClusterDetector_Impl: Sized + windows_core::IUnknownImpl {
    fn Initialize(&self, wbaseentrylevel: u16, wclusterentrylevel: u16) -> windows_core::Result<()>;
    fn Detect(&self, dwmaxnumclusters: u32, fminclusterduration: f32, fmaxclusterduration: f32, psrctoc: Option<&IToc>) -> windows_core::Result<IToc>;
}
impl windows_core::RuntimeName for IClusterDetector {}
impl IClusterDetector_Vtbl {
    pub const fn new<Identity: IClusterDetector_Impl, const OFFSET: isize>() -> IClusterDetector_Vtbl {
        unsafe extern "system" fn Initialize<Identity: IClusterDetector_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, wbaseentrylevel: u16, wclusterentrylevel: u16) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IClusterDetector_Impl::Initialize(this, core::mem::transmute_copy(&wbaseentrylevel), core::mem::transmute_copy(&wclusterentrylevel)).into()
        }
        unsafe extern "system" fn Detect<Identity: IClusterDetector_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwmaxnumclusters: u32, fminclusterduration: f32, fmaxclusterduration: f32, psrctoc: *mut core::ffi::c_void, ppdsttoc: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IClusterDetector_Impl::Detect(this, core::mem::transmute_copy(&dwmaxnumclusters), core::mem::transmute_copy(&fminclusterduration), core::mem::transmute_copy(&fmaxclusterduration), windows_core::from_raw_borrowed(&psrctoc)) {
                Ok(ok__) => {
                    ppdsttoc.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Initialize: Initialize::<Identity, OFFSET>, Detect: Detect::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IClusterDetector as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
pub trait ICodecAPI_Impl: Sized + windows_core::IUnknownImpl {
    fn IsSupported(&self, api: *const windows_core::GUID) -> windows_core::Result<()>;
    fn IsModifiable(&self, api: *const windows_core::GUID) -> windows_core::HRESULT;
    fn GetParameterRange(&self, api: *const windows_core::GUID, valuemin: *mut super::super::System::Variant::VARIANT, valuemax: *mut super::super::System::Variant::VARIANT, steppingdelta: *mut super::super::System::Variant::VARIANT) -> windows_core::Result<()>;
    fn GetParameterValues(&self, api: *const windows_core::GUID, values: *mut *mut super::super::System::Variant::VARIANT, valuescount: *mut u32) -> windows_core::Result<()>;
    fn GetDefaultValue(&self, api: *const windows_core::GUID) -> windows_core::Result<super::super::System::Variant::VARIANT>;
    fn GetValue(&self, api: *const windows_core::GUID) -> windows_core::Result<super::super::System::Variant::VARIANT>;
    fn SetValue(&self, api: *const windows_core::GUID, value: *const super::super::System::Variant::VARIANT) -> windows_core::Result<()>;
    fn RegisterForEvent(&self, api: *const windows_core::GUID, userdata: isize) -> windows_core::Result<()>;
    fn UnregisterForEvent(&self, api: *const windows_core::GUID) -> windows_core::Result<()>;
    fn SetAllDefaults(&self) -> windows_core::Result<()>;
    fn SetValueWithNotify(&self, api: *const windows_core::GUID, value: *const super::super::System::Variant::VARIANT, changedparam: *mut *mut windows_core::GUID, changedparamcount: *mut u32) -> windows_core::Result<()>;
    fn SetAllDefaultsWithNotify(&self, changedparam: *mut *mut windows_core::GUID, changedparamcount: *mut u32) -> windows_core::Result<()>;
    fn GetAllSettings(&self, __midl__icodecapi0000: Option<&super::super::System::Com::IStream>) -> windows_core::Result<()>;
    fn SetAllSettings(&self, __midl__icodecapi0001: Option<&super::super::System::Com::IStream>) -> windows_core::Result<()>;
    fn SetAllSettingsWithNotify(&self, __midl__icodecapi0002: Option<&super::super::System::Com::IStream>, changedparam: *mut *mut windows_core::GUID, changedparamcount: *mut u32) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for ICodecAPI {}
#[cfg(all(feature = "Win32_System_Com", feature = "Win32_System_Ole", feature = "Win32_System_Variant"))]
impl ICodecAPI_Vtbl {
    pub const fn new<Identity: ICodecAPI_Impl, const OFFSET: isize>() -> ICodecAPI_Vtbl {
        unsafe extern "system" fn IsSupported<Identity: ICodecAPI_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, api: *const windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ICodecAPI_Impl::IsSupported(this, core::mem::transmute_copy(&api)).into()
        }
        unsafe extern "system" fn IsModifiable<Identity: ICodecAPI_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, api: *const windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ICodecAPI_Impl::IsModifiable(this, core::mem::transmute_copy(&api))
        }
        unsafe extern "system" fn GetParameterRange<Identity: ICodecAPI_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, api: *const windows_core::GUID, valuemin: *mut core::mem::MaybeUninit<super::super::System::Variant::VARIANT>, valuemax: *mut core::mem::MaybeUninit<super::super::System::Variant::VARIANT>, steppingdelta: *mut core::mem::MaybeUninit<super::super::System::Variant::VARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ICodecAPI_Impl::GetParameterRange(this, core::mem::transmute_copy(&api), core::mem::transmute_copy(&valuemin), core::mem::transmute_copy(&valuemax), core::mem::transmute_copy(&steppingdelta)).into()
        }
        unsafe extern "system" fn GetParameterValues<Identity: ICodecAPI_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, api: *const windows_core::GUID, values: *mut *mut super::super::System::Variant::VARIANT, valuescount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ICodecAPI_Impl::GetParameterValues(this, core::mem::transmute_copy(&api), core::mem::transmute_copy(&values), core::mem::transmute_copy(&valuescount)).into()
        }
        unsafe extern "system" fn GetDefaultValue<Identity: ICodecAPI_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, api: *const windows_core::GUID, value: *mut core::mem::MaybeUninit<super::super::System::Variant::VARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match ICodecAPI_Impl::GetDefaultValue(this, core::mem::transmute_copy(&api)) {
                Ok(ok__) => {
                    value.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetValue<Identity: ICodecAPI_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, api: *const windows_core::GUID, value: *mut core::mem::MaybeUninit<super::super::System::Variant::VARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match ICodecAPI_Impl::GetValue(this, core::mem::transmute_copy(&api)) {
                Ok(ok__) => {
                    value.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetValue<Identity: ICodecAPI_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, api: *const windows_core::GUID, value: *const core::mem::MaybeUninit<super::super::System::Variant::VARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ICodecAPI_Impl::SetValue(this, core::mem::transmute_copy(&api), core::mem::transmute_copy(&value)).into()
        }
        unsafe extern "system" fn RegisterForEvent<Identity: ICodecAPI_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, api: *const windows_core::GUID, userdata: isize) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ICodecAPI_Impl::RegisterForEvent(this, core::mem::transmute_copy(&api), core::mem::transmute_copy(&userdata)).into()
        }
        unsafe extern "system" fn UnregisterForEvent<Identity: ICodecAPI_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, api: *const windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ICodecAPI_Impl::UnregisterForEvent(this, core::mem::transmute_copy(&api)).into()
        }
        unsafe extern "system" fn SetAllDefaults<Identity: ICodecAPI_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ICodecAPI_Impl::SetAllDefaults(this).into()
        }
        unsafe extern "system" fn SetValueWithNotify<Identity: ICodecAPI_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, api: *const windows_core::GUID, value: *const core::mem::MaybeUninit<super::super::System::Variant::VARIANT>, changedparam: *mut *mut windows_core::GUID, changedparamcount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ICodecAPI_Impl::SetValueWithNotify(this, core::mem::transmute_copy(&api), core::mem::transmute_copy(&value), core::mem::transmute_copy(&changedparam), core::mem::transmute_copy(&changedparamcount)).into()
        }
        unsafe extern "system" fn SetAllDefaultsWithNotify<Identity: ICodecAPI_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, changedparam: *mut *mut windows_core::GUID, changedparamcount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ICodecAPI_Impl::SetAllDefaultsWithNotify(this, core::mem::transmute_copy(&changedparam), core::mem::transmute_copy(&changedparamcount)).into()
        }
        unsafe extern "system" fn GetAllSettings<Identity: ICodecAPI_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, __midl__icodecapi0000: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ICodecAPI_Impl::GetAllSettings(this, windows_core::from_raw_borrowed(&__midl__icodecapi0000)).into()
        }
        unsafe extern "system" fn SetAllSettings<Identity: ICodecAPI_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, __midl__icodecapi0001: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ICodecAPI_Impl::SetAllSettings(this, windows_core::from_raw_borrowed(&__midl__icodecapi0001)).into()
        }
        unsafe extern "system" fn SetAllSettingsWithNotify<Identity: ICodecAPI_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, __midl__icodecapi0002: *mut core::ffi::c_void, changedparam: *mut *mut windows_core::GUID, changedparamcount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ICodecAPI_Impl::SetAllSettingsWithNotify(this, windows_core::from_raw_borrowed(&__midl__icodecapi0002), core::mem::transmute_copy(&changedparam), core::mem::transmute_copy(&changedparamcount)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            IsSupported: IsSupported::<Identity, OFFSET>,
            IsModifiable: IsModifiable::<Identity, OFFSET>,
            GetParameterRange: GetParameterRange::<Identity, OFFSET>,
            GetParameterValues: GetParameterValues::<Identity, OFFSET>,
            GetDefaultValue: GetDefaultValue::<Identity, OFFSET>,
            GetValue: GetValue::<Identity, OFFSET>,
            SetValue: SetValue::<Identity, OFFSET>,
            RegisterForEvent: RegisterForEvent::<Identity, OFFSET>,
            UnregisterForEvent: UnregisterForEvent::<Identity, OFFSET>,
            SetAllDefaults: SetAllDefaults::<Identity, OFFSET>,
            SetValueWithNotify: SetValueWithNotify::<Identity, OFFSET>,
            SetAllDefaultsWithNotify: SetAllDefaultsWithNotify::<Identity, OFFSET>,
            GetAllSettings: GetAllSettings::<Identity, OFFSET>,
            SetAllSettings: SetAllSettings::<Identity, OFFSET>,
            SetAllSettingsWithNotify: SetAllSettingsWithNotify::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ICodecAPI as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoDecodeCommandList_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12CommandList_Impl {
    fn Close(&self) -> windows_core::Result<()>;
    fn Reset(&self, pallocator: Option<&super::super::Graphics::Direct3D12::ID3D12CommandAllocator>) -> windows_core::Result<()>;
    fn ClearState(&self);
    fn ResourceBarrier(&self, numbarriers: u32, pbarriers: *const super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER);
    fn DiscardResource(&self, presource: Option<&super::super::Graphics::Direct3D12::ID3D12Resource>, pregion: *const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION);
    fn BeginQuery(&self, pqueryheap: Option<&super::super::Graphics::Direct3D12::ID3D12QueryHeap>, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32);
    fn EndQuery(&self, pqueryheap: Option<&super::super::Graphics::Direct3D12::ID3D12QueryHeap>, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32);
    fn ResolveQueryData(&self, pqueryheap: Option<&super::super::Graphics::Direct3D12::ID3D12QueryHeap>, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: Option<&super::super::Graphics::Direct3D12::ID3D12Resource>, aligneddestinationbufferoffset: u64);
    fn SetPredication(&self, pbuffer: Option<&super::super::Graphics::Direct3D12::ID3D12Resource>, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP);
    fn SetMarker(&self, metadata: u32, pdata: *const core::ffi::c_void, size: u32);
    fn BeginEvent(&self, metadata: u32, pdata: *const core::ffi::c_void, size: u32);
    fn EndEvent(&self);
    fn DecodeFrame(&self, pdecoder: Option<&ID3D12VideoDecoder>, poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS, pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS);
    fn WriteBufferImmediate(&self, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE);
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl windows_core::RuntimeName for ID3D12VideoDecodeCommandList {}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoDecodeCommandList_Vtbl {
    pub const fn new<Identity: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>() -> ID3D12VideoDecodeCommandList_Vtbl {
        unsafe extern "system" fn Close<Identity: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDecodeCommandList_Impl::Close(this).into()
        }
        unsafe extern "system" fn Reset<Identity: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pallocator: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDecodeCommandList_Impl::Reset(this, windows_core::from_raw_borrowed(&pallocator)).into()
        }
        unsafe extern "system" fn ClearState<Identity: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDecodeCommandList_Impl::ClearState(this)
        }
        unsafe extern "system" fn ResourceBarrier<Identity: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, numbarriers: u32, pbarriers: *const super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDecodeCommandList_Impl::ResourceBarrier(this, core::mem::transmute_copy(&numbarriers), core::mem::transmute_copy(&pbarriers))
        }
        unsafe extern "system" fn DiscardResource<Identity: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presource: *mut core::ffi::c_void, pregion: *const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDecodeCommandList_Impl::DiscardResource(this, windows_core::from_raw_borrowed(&presource), core::mem::transmute_copy(&pregion))
        }
        unsafe extern "system" fn BeginQuery<Identity: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pqueryheap: *mut core::ffi::c_void, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDecodeCommandList_Impl::BeginQuery(this, windows_core::from_raw_borrowed(&pqueryheap), core::mem::transmute_copy(&r#type), core::mem::transmute_copy(&index))
        }
        unsafe extern "system" fn EndQuery<Identity: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pqueryheap: *mut core::ffi::c_void, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDecodeCommandList_Impl::EndQuery(this, windows_core::from_raw_borrowed(&pqueryheap), core::mem::transmute_copy(&r#type), core::mem::transmute_copy(&index))
        }
        unsafe extern "system" fn ResolveQueryData<Identity: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pqueryheap: *mut core::ffi::c_void, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: *mut core::ffi::c_void, aligneddestinationbufferoffset: u64) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDecodeCommandList_Impl::ResolveQueryData(this, windows_core::from_raw_borrowed(&pqueryheap), core::mem::transmute_copy(&r#type), core::mem::transmute_copy(&startindex), core::mem::transmute_copy(&numqueries), windows_core::from_raw_borrowed(&pdestinationbuffer), core::mem::transmute_copy(&aligneddestinationbufferoffset))
        }
        unsafe extern "system" fn SetPredication<Identity: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbuffer: *mut core::ffi::c_void, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDecodeCommandList_Impl::SetPredication(this, windows_core::from_raw_borrowed(&pbuffer), core::mem::transmute_copy(&alignedbufferoffset), core::mem::transmute_copy(&operation))
        }
        unsafe extern "system" fn SetMarker<Identity: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, metadata: u32, pdata: *const core::ffi::c_void, size: u32) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDecodeCommandList_Impl::SetMarker(this, core::mem::transmute_copy(&metadata), core::mem::transmute_copy(&pdata), core::mem::transmute_copy(&size))
        }
        unsafe extern "system" fn BeginEvent<Identity: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, metadata: u32, pdata: *const core::ffi::c_void, size: u32) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDecodeCommandList_Impl::BeginEvent(this, core::mem::transmute_copy(&metadata), core::mem::transmute_copy(&pdata), core::mem::transmute_copy(&size))
        }
        unsafe extern "system" fn EndEvent<Identity: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDecodeCommandList_Impl::EndEvent(this)
        }
        unsafe extern "system" fn DecodeFrame<Identity: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdecoder: *mut core::ffi::c_void, poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS, pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDecodeCommandList_Impl::DecodeFrame(this, windows_core::from_raw_borrowed(&pdecoder), core::mem::transmute_copy(&poutputarguments), core::mem::transmute_copy(&pinputarguments))
        }
        unsafe extern "system" fn WriteBufferImmediate<Identity: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDecodeCommandList_Impl::WriteBufferImmediate(this, core::mem::transmute_copy(&count), core::mem::transmute_copy(&pparams), core::mem::transmute_copy(&pmodes))
        }
        Self {
            base__: super::super::Graphics::Direct3D12::ID3D12CommandList_Vtbl::new::<Identity, OFFSET>(),
            Close: Close::<Identity, OFFSET>,
            Reset: Reset::<Identity, OFFSET>,
            ClearState: ClearState::<Identity, OFFSET>,
            ResourceBarrier: ResourceBarrier::<Identity, OFFSET>,
            DiscardResource: DiscardResource::<Identity, OFFSET>,
            BeginQuery: BeginQuery::<Identity, OFFSET>,
            EndQuery: EndQuery::<Identity, OFFSET>,
            ResolveQueryData: ResolveQueryData::<Identity, OFFSET>,
            SetPredication: SetPredication::<Identity, OFFSET>,
            SetMarker: SetMarker::<Identity, OFFSET>,
            BeginEvent: BeginEvent::<Identity, OFFSET>,
            EndEvent: EndEvent::<Identity, OFFSET>,
            DecodeFrame: DecodeFrame::<Identity, OFFSET>,
            WriteBufferImmediate: WriteBufferImmediate::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoDecodeCommandList as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Object as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12DeviceChild as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12CommandList as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoDecodeCommandList1_Impl: Sized + ID3D12VideoDecodeCommandList_Impl {
    fn DecodeFrame1(&self, pdecoder: Option<&ID3D12VideoDecoder>, poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1, pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS);
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl windows_core::RuntimeName for ID3D12VideoDecodeCommandList1 {}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoDecodeCommandList1_Vtbl {
    pub const fn new<Identity: ID3D12VideoDecodeCommandList1_Impl, const OFFSET: isize>() -> ID3D12VideoDecodeCommandList1_Vtbl {
        unsafe extern "system" fn DecodeFrame1<Identity: ID3D12VideoDecodeCommandList1_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdecoder: *mut core::ffi::c_void, poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1, pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDecodeCommandList1_Impl::DecodeFrame1(this, windows_core::from_raw_borrowed(&pdecoder), core::mem::transmute_copy(&poutputarguments), core::mem::transmute_copy(&pinputarguments))
        }
        Self { base__: ID3D12VideoDecodeCommandList_Vtbl::new::<Identity, OFFSET>(), DecodeFrame1: DecodeFrame1::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoDecodeCommandList1 as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Object as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12DeviceChild as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12CommandList as windows_core::Interface>::IID || iid == &<ID3D12VideoDecodeCommandList as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoDecodeCommandList2_Impl: Sized + ID3D12VideoDecodeCommandList1_Impl {
    fn SetProtectedResourceSession(&self, pprotectedresourcesession: Option<&super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>);
    fn InitializeExtensionCommand(&self, pextensioncommand: Option<&ID3D12VideoExtensionCommand>, pinitializationparameters: *const core::ffi::c_void, initializationparameterssizeinbytes: usize);
    fn ExecuteExtensionCommand(&self, pextensioncommand: Option<&ID3D12VideoExtensionCommand>, pexecutionparameters: *const core::ffi::c_void, executionparameterssizeinbytes: usize);
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl windows_core::RuntimeName for ID3D12VideoDecodeCommandList2 {}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoDecodeCommandList2_Vtbl {
    pub const fn new<Identity: ID3D12VideoDecodeCommandList2_Impl, const OFFSET: isize>() -> ID3D12VideoDecodeCommandList2_Vtbl {
        unsafe extern "system" fn SetProtectedResourceSession<Identity: ID3D12VideoDecodeCommandList2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pprotectedresourcesession: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDecodeCommandList2_Impl::SetProtectedResourceSession(this, windows_core::from_raw_borrowed(&pprotectedresourcesession))
        }
        unsafe extern "system" fn InitializeExtensionCommand<Identity: ID3D12VideoDecodeCommandList2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pextensioncommand: *mut core::ffi::c_void, pinitializationparameters: *const core::ffi::c_void, initializationparameterssizeinbytes: usize) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDecodeCommandList2_Impl::InitializeExtensionCommand(this, windows_core::from_raw_borrowed(&pextensioncommand), core::mem::transmute_copy(&pinitializationparameters), core::mem::transmute_copy(&initializationparameterssizeinbytes))
        }
        unsafe extern "system" fn ExecuteExtensionCommand<Identity: ID3D12VideoDecodeCommandList2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pextensioncommand: *mut core::ffi::c_void, pexecutionparameters: *const core::ffi::c_void, executionparameterssizeinbytes: usize) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDecodeCommandList2_Impl::ExecuteExtensionCommand(this, windows_core::from_raw_borrowed(&pextensioncommand), core::mem::transmute_copy(&pexecutionparameters), core::mem::transmute_copy(&executionparameterssizeinbytes))
        }
        Self {
            base__: ID3D12VideoDecodeCommandList1_Vtbl::new::<Identity, OFFSET>(),
            SetProtectedResourceSession: SetProtectedResourceSession::<Identity, OFFSET>,
            InitializeExtensionCommand: InitializeExtensionCommand::<Identity, OFFSET>,
            ExecuteExtensionCommand: ExecuteExtensionCommand::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoDecodeCommandList2 as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Object as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12DeviceChild as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12CommandList as windows_core::Interface>::IID || iid == &<ID3D12VideoDecodeCommandList as windows_core::Interface>::IID || iid == &<ID3D12VideoDecodeCommandList1 as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoDecodeCommandList3_Impl: Sized + ID3D12VideoDecodeCommandList2_Impl {
    fn Barrier(&self, numbarriergroups: u32, pbarriergroups: *const super::super::Graphics::Direct3D12::D3D12_BARRIER_GROUP);
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl windows_core::RuntimeName for ID3D12VideoDecodeCommandList3 {}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoDecodeCommandList3_Vtbl {
    pub const fn new<Identity: ID3D12VideoDecodeCommandList3_Impl, const OFFSET: isize>() -> ID3D12VideoDecodeCommandList3_Vtbl {
        unsafe extern "system" fn Barrier<Identity: ID3D12VideoDecodeCommandList3_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, numbarriergroups: u32, pbarriergroups: *const super::super::Graphics::Direct3D12::D3D12_BARRIER_GROUP) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDecodeCommandList3_Impl::Barrier(this, core::mem::transmute_copy(&numbarriergroups), core::mem::transmute_copy(&pbarriergroups))
        }
        Self { base__: ID3D12VideoDecodeCommandList2_Vtbl::new::<Identity, OFFSET>(), Barrier: Barrier::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoDecodeCommandList3 as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Object as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12DeviceChild as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12CommandList as windows_core::Interface>::IID || iid == &<ID3D12VideoDecodeCommandList as windows_core::Interface>::IID || iid == &<ID3D12VideoDecodeCommandList1 as windows_core::Interface>::IID || iid == &<ID3D12VideoDecodeCommandList2 as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoDecoder_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Pageable_Impl {
    fn GetDesc(&self) -> D3D12_VIDEO_DECODER_DESC;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl windows_core::RuntimeName for ID3D12VideoDecoder {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoDecoder_Vtbl {
    pub const fn new<Identity: ID3D12VideoDecoder_Impl, const OFFSET: isize>() -> ID3D12VideoDecoder_Vtbl {
        unsafe extern "system" fn GetDesc<Identity: ID3D12VideoDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, result__: *mut D3D12_VIDEO_DECODER_DESC) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            *result__ = ID3D12VideoDecoder_Impl::GetDesc(this)
        }
        Self { base__: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl::new::<Identity, OFFSET>(), GetDesc: GetDesc::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoDecoder as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Object as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12DeviceChild as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Pageable as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoDecoder1_Impl: Sized + ID3D12VideoDecoder_Impl {
    fn GetProtectedResourceSession(&self, riid: *const windows_core::GUID, ppprotectedsession: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl windows_core::RuntimeName for ID3D12VideoDecoder1 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoDecoder1_Vtbl {
    pub const fn new<Identity: ID3D12VideoDecoder1_Impl, const OFFSET: isize>() -> ID3D12VideoDecoder1_Vtbl {
        unsafe extern "system" fn GetProtectedResourceSession<Identity: ID3D12VideoDecoder1_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppprotectedsession: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDecoder1_Impl::GetProtectedResourceSession(this, core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppprotectedsession)).into()
        }
        Self { base__: ID3D12VideoDecoder_Vtbl::new::<Identity, OFFSET>(), GetProtectedResourceSession: GetProtectedResourceSession::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoDecoder1 as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Object as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12DeviceChild as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Pageable as windows_core::Interface>::IID || iid == &<ID3D12VideoDecoder as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoDecoderHeap_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Pageable_Impl {
    fn GetDesc(&self) -> D3D12_VIDEO_DECODER_HEAP_DESC;
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl windows_core::RuntimeName for ID3D12VideoDecoderHeap {}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoDecoderHeap_Vtbl {
    pub const fn new<Identity: ID3D12VideoDecoderHeap_Impl, const OFFSET: isize>() -> ID3D12VideoDecoderHeap_Vtbl {
        unsafe extern "system" fn GetDesc<Identity: ID3D12VideoDecoderHeap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, result__: *mut D3D12_VIDEO_DECODER_HEAP_DESC) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            *result__ = ID3D12VideoDecoderHeap_Impl::GetDesc(this)
        }
        Self { base__: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl::new::<Identity, OFFSET>(), GetDesc: GetDesc::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoDecoderHeap as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Object as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12DeviceChild as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Pageable as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoDecoderHeap1_Impl: Sized + ID3D12VideoDecoderHeap_Impl {
    fn GetProtectedResourceSession(&self, riid: *const windows_core::GUID, ppprotectedsession: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl windows_core::RuntimeName for ID3D12VideoDecoderHeap1 {}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoDecoderHeap1_Vtbl {
    pub const fn new<Identity: ID3D12VideoDecoderHeap1_Impl, const OFFSET: isize>() -> ID3D12VideoDecoderHeap1_Vtbl {
        unsafe extern "system" fn GetProtectedResourceSession<Identity: ID3D12VideoDecoderHeap1_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppprotectedsession: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDecoderHeap1_Impl::GetProtectedResourceSession(this, core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppprotectedsession)).into()
        }
        Self { base__: ID3D12VideoDecoderHeap_Vtbl::new::<Identity, OFFSET>(), GetProtectedResourceSession: GetProtectedResourceSession::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoDecoderHeap1 as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Object as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12DeviceChild as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Pageable as windows_core::Interface>::IID || iid == &<ID3D12VideoDecoderHeap as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
pub trait ID3D12VideoDevice_Impl: Sized + windows_core::IUnknownImpl {
    fn CheckFeatureSupport(&self, featurevideo: D3D12_FEATURE_VIDEO, pfeaturesupportdata: *mut core::ffi::c_void, featuresupportdatasize: u32) -> windows_core::Result<()>;
    fn CreateVideoDecoder(&self, pdesc: *const D3D12_VIDEO_DECODER_DESC, riid: *const windows_core::GUID, ppvideodecoder: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn CreateVideoDecoderHeap(&self, pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC, riid: *const windows_core::GUID, ppvideodecoderheap: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn CreateVideoProcessor(&self, nodemask: u32, poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC, numinputstreamdescs: u32, pinputstreamdescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC, riid: *const windows_core::GUID, ppvideoprocessor: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl windows_core::RuntimeName for ID3D12VideoDevice {}
#[cfg(feature = "Win32_Graphics_Dxgi_Common")]
impl ID3D12VideoDevice_Vtbl {
    pub const fn new<Identity: ID3D12VideoDevice_Impl, const OFFSET: isize>() -> ID3D12VideoDevice_Vtbl {
        unsafe extern "system" fn CheckFeatureSupport<Identity: ID3D12VideoDevice_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, featurevideo: D3D12_FEATURE_VIDEO, pfeaturesupportdata: *mut core::ffi::c_void, featuresupportdatasize: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDevice_Impl::CheckFeatureSupport(this, core::mem::transmute_copy(&featurevideo), core::mem::transmute_copy(&pfeaturesupportdata), core::mem::transmute_copy(&featuresupportdatasize)).into()
        }
        unsafe extern "system" fn CreateVideoDecoder<Identity: ID3D12VideoDevice_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdesc: *const D3D12_VIDEO_DECODER_DESC, riid: *const windows_core::GUID, ppvideodecoder: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDevice_Impl::CreateVideoDecoder(this, core::mem::transmute_copy(&pdesc), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvideodecoder)).into()
        }
        unsafe extern "system" fn CreateVideoDecoderHeap<Identity: ID3D12VideoDevice_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC, riid: *const windows_core::GUID, ppvideodecoderheap: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDevice_Impl::CreateVideoDecoderHeap(this, core::mem::transmute_copy(&pvideodecoderheapdesc), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvideodecoderheap)).into()
        }
        unsafe extern "system" fn CreateVideoProcessor<Identity: ID3D12VideoDevice_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, nodemask: u32, poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC, numinputstreamdescs: u32, pinputstreamdescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC, riid: *const windows_core::GUID, ppvideoprocessor: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDevice_Impl::CreateVideoProcessor(this, core::mem::transmute_copy(&nodemask), core::mem::transmute_copy(&poutputstreamdesc), core::mem::transmute_copy(&numinputstreamdescs), core::mem::transmute_copy(&pinputstreamdescs), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvideoprocessor)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            CheckFeatureSupport: CheckFeatureSupport::<Identity, OFFSET>,
            CreateVideoDecoder: CreateVideoDecoder::<Identity, OFFSET>,
            CreateVideoDecoderHeap: CreateVideoDecoderHeap::<Identity, OFFSET>,
            CreateVideoProcessor: CreateVideoProcessor::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoDevice as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoDevice1_Impl: Sized + ID3D12VideoDevice_Impl {
    fn CreateVideoMotionEstimator(&self, pdesc: *const D3D12_VIDEO_MOTION_ESTIMATOR_DESC, pprotectedresourcesession: Option<&super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>, riid: *const windows_core::GUID, ppvideomotionestimator: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn CreateVideoMotionVectorHeap(&self, pdesc: *const D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC, pprotectedresourcesession: Option<&super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>, riid: *const windows_core::GUID, ppvideomotionvectorheap: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl windows_core::RuntimeName for ID3D12VideoDevice1 {}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoDevice1_Vtbl {
    pub const fn new<Identity: ID3D12VideoDevice1_Impl, const OFFSET: isize>() -> ID3D12VideoDevice1_Vtbl {
        unsafe extern "system" fn CreateVideoMotionEstimator<Identity: ID3D12VideoDevice1_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdesc: *const D3D12_VIDEO_MOTION_ESTIMATOR_DESC, pprotectedresourcesession: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppvideomotionestimator: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDevice1_Impl::CreateVideoMotionEstimator(this, core::mem::transmute_copy(&pdesc), windows_core::from_raw_borrowed(&pprotectedresourcesession), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvideomotionestimator)).into()
        }
        unsafe extern "system" fn CreateVideoMotionVectorHeap<Identity: ID3D12VideoDevice1_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdesc: *const D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC, pprotectedresourcesession: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppvideomotionvectorheap: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDevice1_Impl::CreateVideoMotionVectorHeap(this, core::mem::transmute_copy(&pdesc), windows_core::from_raw_borrowed(&pprotectedresourcesession), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvideomotionvectorheap)).into()
        }
        Self {
            base__: ID3D12VideoDevice_Vtbl::new::<Identity, OFFSET>(),
            CreateVideoMotionEstimator: CreateVideoMotionEstimator::<Identity, OFFSET>,
            CreateVideoMotionVectorHeap: CreateVideoMotionVectorHeap::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoDevice1 as windows_core::Interface>::IID || iid == &<ID3D12VideoDevice as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoDevice2_Impl: Sized + ID3D12VideoDevice1_Impl {
    fn CreateVideoDecoder1(&self, pdesc: *const D3D12_VIDEO_DECODER_DESC, pprotectedresourcesession: Option<&super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>, riid: *const windows_core::GUID, ppvideodecoder: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn CreateVideoDecoderHeap1(&self, pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC, pprotectedresourcesession: Option<&super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>, riid: *const windows_core::GUID, ppvideodecoderheap: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn CreateVideoProcessor1(&self, nodemask: u32, poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC, numinputstreamdescs: u32, pinputstreamdescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC, pprotectedresourcesession: Option<&super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>, riid: *const windows_core::GUID, ppvideoprocessor: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn CreateVideoExtensionCommand(&self, pdesc: *const D3D12_VIDEO_EXTENSION_COMMAND_DESC, pcreationparameters: *const core::ffi::c_void, creationparametersdatasizeinbytes: usize, pprotectedresourcesession: Option<&super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>, riid: *const windows_core::GUID, ppvideoextensioncommand: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn ExecuteExtensionCommand(&self, pextensioncommand: Option<&ID3D12VideoExtensionCommand>, pexecutionparameters: *const core::ffi::c_void, executionparameterssizeinbytes: usize, poutputdata: *mut core::ffi::c_void, outputdatasizeinbytes: usize) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl windows_core::RuntimeName for ID3D12VideoDevice2 {}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoDevice2_Vtbl {
    pub const fn new<Identity: ID3D12VideoDevice2_Impl, const OFFSET: isize>() -> ID3D12VideoDevice2_Vtbl {
        unsafe extern "system" fn CreateVideoDecoder1<Identity: ID3D12VideoDevice2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdesc: *const D3D12_VIDEO_DECODER_DESC, pprotectedresourcesession: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppvideodecoder: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDevice2_Impl::CreateVideoDecoder1(this, core::mem::transmute_copy(&pdesc), windows_core::from_raw_borrowed(&pprotectedresourcesession), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvideodecoder)).into()
        }
        unsafe extern "system" fn CreateVideoDecoderHeap1<Identity: ID3D12VideoDevice2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC, pprotectedresourcesession: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppvideodecoderheap: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDevice2_Impl::CreateVideoDecoderHeap1(this, core::mem::transmute_copy(&pvideodecoderheapdesc), windows_core::from_raw_borrowed(&pprotectedresourcesession), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvideodecoderheap)).into()
        }
        unsafe extern "system" fn CreateVideoProcessor1<Identity: ID3D12VideoDevice2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, nodemask: u32, poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC, numinputstreamdescs: u32, pinputstreamdescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC, pprotectedresourcesession: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppvideoprocessor: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDevice2_Impl::CreateVideoProcessor1(this, core::mem::transmute_copy(&nodemask), core::mem::transmute_copy(&poutputstreamdesc), core::mem::transmute_copy(&numinputstreamdescs), core::mem::transmute_copy(&pinputstreamdescs), windows_core::from_raw_borrowed(&pprotectedresourcesession), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvideoprocessor)).into()
        }
        unsafe extern "system" fn CreateVideoExtensionCommand<Identity: ID3D12VideoDevice2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdesc: *const D3D12_VIDEO_EXTENSION_COMMAND_DESC, pcreationparameters: *const core::ffi::c_void, creationparametersdatasizeinbytes: usize, pprotectedresourcesession: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppvideoextensioncommand: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDevice2_Impl::CreateVideoExtensionCommand(this, core::mem::transmute_copy(&pdesc), core::mem::transmute_copy(&pcreationparameters), core::mem::transmute_copy(&creationparametersdatasizeinbytes), windows_core::from_raw_borrowed(&pprotectedresourcesession), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvideoextensioncommand)).into()
        }
        unsafe extern "system" fn ExecuteExtensionCommand<Identity: ID3D12VideoDevice2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pextensioncommand: *mut core::ffi::c_void, pexecutionparameters: *const core::ffi::c_void, executionparameterssizeinbytes: usize, poutputdata: *mut core::ffi::c_void, outputdatasizeinbytes: usize) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDevice2_Impl::ExecuteExtensionCommand(this, windows_core::from_raw_borrowed(&pextensioncommand), core::mem::transmute_copy(&pexecutionparameters), core::mem::transmute_copy(&executionparameterssizeinbytes), core::mem::transmute_copy(&poutputdata), core::mem::transmute_copy(&outputdatasizeinbytes)).into()
        }
        Self {
            base__: ID3D12VideoDevice1_Vtbl::new::<Identity, OFFSET>(),
            CreateVideoDecoder1: CreateVideoDecoder1::<Identity, OFFSET>,
            CreateVideoDecoderHeap1: CreateVideoDecoderHeap1::<Identity, OFFSET>,
            CreateVideoProcessor1: CreateVideoProcessor1::<Identity, OFFSET>,
            CreateVideoExtensionCommand: CreateVideoExtensionCommand::<Identity, OFFSET>,
            ExecuteExtensionCommand: ExecuteExtensionCommand::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoDevice2 as windows_core::Interface>::IID || iid == &<ID3D12VideoDevice as windows_core::Interface>::IID || iid == &<ID3D12VideoDevice1 as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoDevice3_Impl: Sized + ID3D12VideoDevice2_Impl {
    fn CreateVideoEncoder(&self, pdesc: *const D3D12_VIDEO_ENCODER_DESC, riid: *const windows_core::GUID, ppvideoencoder: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn CreateVideoEncoderHeap(&self, pdesc: *const D3D12_VIDEO_ENCODER_HEAP_DESC, riid: *const windows_core::GUID, ppvideoencoderheap: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl windows_core::RuntimeName for ID3D12VideoDevice3 {}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoDevice3_Vtbl {
    pub const fn new<Identity: ID3D12VideoDevice3_Impl, const OFFSET: isize>() -> ID3D12VideoDevice3_Vtbl {
        unsafe extern "system" fn CreateVideoEncoder<Identity: ID3D12VideoDevice3_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdesc: *const D3D12_VIDEO_ENCODER_DESC, riid: *const windows_core::GUID, ppvideoencoder: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDevice3_Impl::CreateVideoEncoder(this, core::mem::transmute_copy(&pdesc), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvideoencoder)).into()
        }
        unsafe extern "system" fn CreateVideoEncoderHeap<Identity: ID3D12VideoDevice3_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdesc: *const D3D12_VIDEO_ENCODER_HEAP_DESC, riid: *const windows_core::GUID, ppvideoencoderheap: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoDevice3_Impl::CreateVideoEncoderHeap(this, core::mem::transmute_copy(&pdesc), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvideoencoderheap)).into()
        }
        Self {
            base__: ID3D12VideoDevice2_Vtbl::new::<Identity, OFFSET>(),
            CreateVideoEncoder: CreateVideoEncoder::<Identity, OFFSET>,
            CreateVideoEncoderHeap: CreateVideoEncoderHeap::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoDevice3 as windows_core::Interface>::IID || iid == &<ID3D12VideoDevice as windows_core::Interface>::IID || iid == &<ID3D12VideoDevice1 as windows_core::Interface>::IID || iid == &<ID3D12VideoDevice2 as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoEncodeCommandList_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12CommandList_Impl {
    fn Close(&self) -> windows_core::Result<()>;
    fn Reset(&self, pallocator: Option<&super::super::Graphics::Direct3D12::ID3D12CommandAllocator>) -> windows_core::Result<()>;
    fn ClearState(&self);
    fn ResourceBarrier(&self, numbarriers: u32, pbarriers: *const super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER);
    fn DiscardResource(&self, presource: Option<&super::super::Graphics::Direct3D12::ID3D12Resource>, pregion: *const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION);
    fn BeginQuery(&self, pqueryheap: Option<&super::super::Graphics::Direct3D12::ID3D12QueryHeap>, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32);
    fn EndQuery(&self, pqueryheap: Option<&super::super::Graphics::Direct3D12::ID3D12QueryHeap>, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32);
    fn ResolveQueryData(&self, pqueryheap: Option<&super::super::Graphics::Direct3D12::ID3D12QueryHeap>, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: Option<&super::super::Graphics::Direct3D12::ID3D12Resource>, aligneddestinationbufferoffset: u64);
    fn SetPredication(&self, pbuffer: Option<&super::super::Graphics::Direct3D12::ID3D12Resource>, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP);
    fn SetMarker(&self, metadata: u32, pdata: *const core::ffi::c_void, size: u32);
    fn BeginEvent(&self, metadata: u32, pdata: *const core::ffi::c_void, size: u32);
    fn EndEvent(&self);
    fn EstimateMotion(&self, pmotionestimator: Option<&ID3D12VideoMotionEstimator>, poutputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT, pinputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT);
    fn ResolveMotionVectorHeap(&self, poutputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT, pinputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT);
    fn WriteBufferImmediate(&self, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE);
    fn SetProtectedResourceSession(&self, pprotectedresourcesession: Option<&super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl windows_core::RuntimeName for ID3D12VideoEncodeCommandList {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoEncodeCommandList_Vtbl {
    pub const fn new<Identity: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>() -> ID3D12VideoEncodeCommandList_Vtbl {
        unsafe extern "system" fn Close<Identity: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncodeCommandList_Impl::Close(this).into()
        }
        unsafe extern "system" fn Reset<Identity: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pallocator: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncodeCommandList_Impl::Reset(this, windows_core::from_raw_borrowed(&pallocator)).into()
        }
        unsafe extern "system" fn ClearState<Identity: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncodeCommandList_Impl::ClearState(this)
        }
        unsafe extern "system" fn ResourceBarrier<Identity: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, numbarriers: u32, pbarriers: *const super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncodeCommandList_Impl::ResourceBarrier(this, core::mem::transmute_copy(&numbarriers), core::mem::transmute_copy(&pbarriers))
        }
        unsafe extern "system" fn DiscardResource<Identity: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presource: *mut core::ffi::c_void, pregion: *const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncodeCommandList_Impl::DiscardResource(this, windows_core::from_raw_borrowed(&presource), core::mem::transmute_copy(&pregion))
        }
        unsafe extern "system" fn BeginQuery<Identity: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pqueryheap: *mut core::ffi::c_void, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncodeCommandList_Impl::BeginQuery(this, windows_core::from_raw_borrowed(&pqueryheap), core::mem::transmute_copy(&r#type), core::mem::transmute_copy(&index))
        }
        unsafe extern "system" fn EndQuery<Identity: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pqueryheap: *mut core::ffi::c_void, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncodeCommandList_Impl::EndQuery(this, windows_core::from_raw_borrowed(&pqueryheap), core::mem::transmute_copy(&r#type), core::mem::transmute_copy(&index))
        }
        unsafe extern "system" fn ResolveQueryData<Identity: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pqueryheap: *mut core::ffi::c_void, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: *mut core::ffi::c_void, aligneddestinationbufferoffset: u64) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncodeCommandList_Impl::ResolveQueryData(this, windows_core::from_raw_borrowed(&pqueryheap), core::mem::transmute_copy(&r#type), core::mem::transmute_copy(&startindex), core::mem::transmute_copy(&numqueries), windows_core::from_raw_borrowed(&pdestinationbuffer), core::mem::transmute_copy(&aligneddestinationbufferoffset))
        }
        unsafe extern "system" fn SetPredication<Identity: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbuffer: *mut core::ffi::c_void, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncodeCommandList_Impl::SetPredication(this, windows_core::from_raw_borrowed(&pbuffer), core::mem::transmute_copy(&alignedbufferoffset), core::mem::transmute_copy(&operation))
        }
        unsafe extern "system" fn SetMarker<Identity: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, metadata: u32, pdata: *const core::ffi::c_void, size: u32) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncodeCommandList_Impl::SetMarker(this, core::mem::transmute_copy(&metadata), core::mem::transmute_copy(&pdata), core::mem::transmute_copy(&size))
        }
        unsafe extern "system" fn BeginEvent<Identity: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, metadata: u32, pdata: *const core::ffi::c_void, size: u32) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncodeCommandList_Impl::BeginEvent(this, core::mem::transmute_copy(&metadata), core::mem::transmute_copy(&pdata), core::mem::transmute_copy(&size))
        }
        unsafe extern "system" fn EndEvent<Identity: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncodeCommandList_Impl::EndEvent(this)
        }
        unsafe extern "system" fn EstimateMotion<Identity: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmotionestimator: *mut core::ffi::c_void, poutputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT, pinputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncodeCommandList_Impl::EstimateMotion(this, windows_core::from_raw_borrowed(&pmotionestimator), core::mem::transmute_copy(&poutputarguments), core::mem::transmute_copy(&pinputarguments))
        }
        unsafe extern "system" fn ResolveMotionVectorHeap<Identity: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, poutputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT, pinputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncodeCommandList_Impl::ResolveMotionVectorHeap(this, core::mem::transmute_copy(&poutputarguments), core::mem::transmute_copy(&pinputarguments))
        }
        unsafe extern "system" fn WriteBufferImmediate<Identity: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncodeCommandList_Impl::WriteBufferImmediate(this, core::mem::transmute_copy(&count), core::mem::transmute_copy(&pparams), core::mem::transmute_copy(&pmodes))
        }
        unsafe extern "system" fn SetProtectedResourceSession<Identity: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pprotectedresourcesession: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncodeCommandList_Impl::SetProtectedResourceSession(this, windows_core::from_raw_borrowed(&pprotectedresourcesession))
        }
        Self {
            base__: super::super::Graphics::Direct3D12::ID3D12CommandList_Vtbl::new::<Identity, OFFSET>(),
            Close: Close::<Identity, OFFSET>,
            Reset: Reset::<Identity, OFFSET>,
            ClearState: ClearState::<Identity, OFFSET>,
            ResourceBarrier: ResourceBarrier::<Identity, OFFSET>,
            DiscardResource: DiscardResource::<Identity, OFFSET>,
            BeginQuery: BeginQuery::<Identity, OFFSET>,
            EndQuery: EndQuery::<Identity, OFFSET>,
            ResolveQueryData: ResolveQueryData::<Identity, OFFSET>,
            SetPredication: SetPredication::<Identity, OFFSET>,
            SetMarker: SetMarker::<Identity, OFFSET>,
            BeginEvent: BeginEvent::<Identity, OFFSET>,
            EndEvent: EndEvent::<Identity, OFFSET>,
            EstimateMotion: EstimateMotion::<Identity, OFFSET>,
            ResolveMotionVectorHeap: ResolveMotionVectorHeap::<Identity, OFFSET>,
            WriteBufferImmediate: WriteBufferImmediate::<Identity, OFFSET>,
            SetProtectedResourceSession: SetProtectedResourceSession::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoEncodeCommandList as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Object as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12DeviceChild as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12CommandList as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoEncodeCommandList1_Impl: Sized + ID3D12VideoEncodeCommandList_Impl {
    fn InitializeExtensionCommand(&self, pextensioncommand: Option<&ID3D12VideoExtensionCommand>, pinitializationparameters: *const core::ffi::c_void, initializationparameterssizeinbytes: usize);
    fn ExecuteExtensionCommand(&self, pextensioncommand: Option<&ID3D12VideoExtensionCommand>, pexecutionparameters: *const core::ffi::c_void, executionparameterssizeinbytes: usize);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl windows_core::RuntimeName for ID3D12VideoEncodeCommandList1 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoEncodeCommandList1_Vtbl {
    pub const fn new<Identity: ID3D12VideoEncodeCommandList1_Impl, const OFFSET: isize>() -> ID3D12VideoEncodeCommandList1_Vtbl {
        unsafe extern "system" fn InitializeExtensionCommand<Identity: ID3D12VideoEncodeCommandList1_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pextensioncommand: *mut core::ffi::c_void, pinitializationparameters: *const core::ffi::c_void, initializationparameterssizeinbytes: usize) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncodeCommandList1_Impl::InitializeExtensionCommand(this, windows_core::from_raw_borrowed(&pextensioncommand), core::mem::transmute_copy(&pinitializationparameters), core::mem::transmute_copy(&initializationparameterssizeinbytes))
        }
        unsafe extern "system" fn ExecuteExtensionCommand<Identity: ID3D12VideoEncodeCommandList1_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pextensioncommand: *mut core::ffi::c_void, pexecutionparameters: *const core::ffi::c_void, executionparameterssizeinbytes: usize) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncodeCommandList1_Impl::ExecuteExtensionCommand(this, windows_core::from_raw_borrowed(&pextensioncommand), core::mem::transmute_copy(&pexecutionparameters), core::mem::transmute_copy(&executionparameterssizeinbytes))
        }
        Self {
            base__: ID3D12VideoEncodeCommandList_Vtbl::new::<Identity, OFFSET>(),
            InitializeExtensionCommand: InitializeExtensionCommand::<Identity, OFFSET>,
            ExecuteExtensionCommand: ExecuteExtensionCommand::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoEncodeCommandList1 as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Object as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12DeviceChild as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12CommandList as windows_core::Interface>::IID || iid == &<ID3D12VideoEncodeCommandList as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoEncodeCommandList2_Impl: Sized + ID3D12VideoEncodeCommandList1_Impl {
    fn EncodeFrame(&self, pencoder: Option<&ID3D12VideoEncoder>, pheap: Option<&ID3D12VideoEncoderHeap>, pinputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS, poutputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS);
    fn ResolveEncoderOutputMetadata(&self, pinputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS, poutputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS);
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl windows_core::RuntimeName for ID3D12VideoEncodeCommandList2 {}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoEncodeCommandList2_Vtbl {
    pub const fn new<Identity: ID3D12VideoEncodeCommandList2_Impl, const OFFSET: isize>() -> ID3D12VideoEncodeCommandList2_Vtbl {
        unsafe extern "system" fn EncodeFrame<Identity: ID3D12VideoEncodeCommandList2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pencoder: *mut core::ffi::c_void, pheap: *mut core::ffi::c_void, pinputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS, poutputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncodeCommandList2_Impl::EncodeFrame(this, windows_core::from_raw_borrowed(&pencoder), windows_core::from_raw_borrowed(&pheap), core::mem::transmute_copy(&pinputarguments), core::mem::transmute_copy(&poutputarguments))
        }
        unsafe extern "system" fn ResolveEncoderOutputMetadata<Identity: ID3D12VideoEncodeCommandList2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pinputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS, poutputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncodeCommandList2_Impl::ResolveEncoderOutputMetadata(this, core::mem::transmute_copy(&pinputarguments), core::mem::transmute_copy(&poutputarguments))
        }
        Self {
            base__: ID3D12VideoEncodeCommandList1_Vtbl::new::<Identity, OFFSET>(),
            EncodeFrame: EncodeFrame::<Identity, OFFSET>,
            ResolveEncoderOutputMetadata: ResolveEncoderOutputMetadata::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoEncodeCommandList2 as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Object as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12DeviceChild as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12CommandList as windows_core::Interface>::IID || iid == &<ID3D12VideoEncodeCommandList as windows_core::Interface>::IID || iid == &<ID3D12VideoEncodeCommandList1 as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoEncodeCommandList3_Impl: Sized + ID3D12VideoEncodeCommandList2_Impl {
    fn Barrier(&self, numbarriergroups: u32, pbarriergroups: *const super::super::Graphics::Direct3D12::D3D12_BARRIER_GROUP);
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl windows_core::RuntimeName for ID3D12VideoEncodeCommandList3 {}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoEncodeCommandList3_Vtbl {
    pub const fn new<Identity: ID3D12VideoEncodeCommandList3_Impl, const OFFSET: isize>() -> ID3D12VideoEncodeCommandList3_Vtbl {
        unsafe extern "system" fn Barrier<Identity: ID3D12VideoEncodeCommandList3_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, numbarriergroups: u32, pbarriergroups: *const super::super::Graphics::Direct3D12::D3D12_BARRIER_GROUP) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncodeCommandList3_Impl::Barrier(this, core::mem::transmute_copy(&numbarriergroups), core::mem::transmute_copy(&pbarriergroups))
        }
        Self { base__: ID3D12VideoEncodeCommandList2_Vtbl::new::<Identity, OFFSET>(), Barrier: Barrier::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoEncodeCommandList3 as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Object as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12DeviceChild as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12CommandList as windows_core::Interface>::IID || iid == &<ID3D12VideoEncodeCommandList as windows_core::Interface>::IID || iid == &<ID3D12VideoEncodeCommandList1 as windows_core::Interface>::IID || iid == &<ID3D12VideoEncodeCommandList2 as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoEncoder_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Pageable_Impl {
    fn GetNodeMask(&self) -> u32;
    fn GetEncoderFlags(&self) -> D3D12_VIDEO_ENCODER_FLAGS;
    fn GetCodec(&self) -> D3D12_VIDEO_ENCODER_CODEC;
    fn GetCodecProfile(&self, dstprofile: &D3D12_VIDEO_ENCODER_PROFILE_DESC) -> windows_core::Result<()>;
    fn GetCodecConfiguration(&self, dstcodecconfig: &D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION) -> windows_core::Result<()>;
    fn GetInputFormat(&self) -> super::super::Graphics::Dxgi::Common::DXGI_FORMAT;
    fn GetMaxMotionEstimationPrecision(&self) -> D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE;
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl windows_core::RuntimeName for ID3D12VideoEncoder {}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoEncoder_Vtbl {
    pub const fn new<Identity: ID3D12VideoEncoder_Impl, const OFFSET: isize>() -> ID3D12VideoEncoder_Vtbl {
        unsafe extern "system" fn GetNodeMask<Identity: ID3D12VideoEncoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u32 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncoder_Impl::GetNodeMask(this)
        }
        unsafe extern "system" fn GetEncoderFlags<Identity: ID3D12VideoEncoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> D3D12_VIDEO_ENCODER_FLAGS {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncoder_Impl::GetEncoderFlags(this)
        }
        unsafe extern "system" fn GetCodec<Identity: ID3D12VideoEncoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> D3D12_VIDEO_ENCODER_CODEC {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncoder_Impl::GetCodec(this)
        }
        unsafe extern "system" fn GetCodecProfile<Identity: ID3D12VideoEncoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dstprofile: D3D12_VIDEO_ENCODER_PROFILE_DESC) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncoder_Impl::GetCodecProfile(this, core::mem::transmute(&dstprofile)).into()
        }
        unsafe extern "system" fn GetCodecConfiguration<Identity: ID3D12VideoEncoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dstcodecconfig: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncoder_Impl::GetCodecConfiguration(this, core::mem::transmute(&dstcodecconfig)).into()
        }
        unsafe extern "system" fn GetInputFormat<Identity: ID3D12VideoEncoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> super::super::Graphics::Dxgi::Common::DXGI_FORMAT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncoder_Impl::GetInputFormat(this)
        }
        unsafe extern "system" fn GetMaxMotionEstimationPrecision<Identity: ID3D12VideoEncoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncoder_Impl::GetMaxMotionEstimationPrecision(this)
        }
        Self {
            base__: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl::new::<Identity, OFFSET>(),
            GetNodeMask: GetNodeMask::<Identity, OFFSET>,
            GetEncoderFlags: GetEncoderFlags::<Identity, OFFSET>,
            GetCodec: GetCodec::<Identity, OFFSET>,
            GetCodecProfile: GetCodecProfile::<Identity, OFFSET>,
            GetCodecConfiguration: GetCodecConfiguration::<Identity, OFFSET>,
            GetInputFormat: GetInputFormat::<Identity, OFFSET>,
            GetMaxMotionEstimationPrecision: GetMaxMotionEstimationPrecision::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoEncoder as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Object as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12DeviceChild as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Pageable as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoEncoderHeap_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Pageable_Impl {
    fn GetNodeMask(&self) -> u32;
    fn GetEncoderHeapFlags(&self) -> D3D12_VIDEO_ENCODER_HEAP_FLAGS;
    fn GetCodec(&self) -> D3D12_VIDEO_ENCODER_CODEC;
    fn GetCodecProfile(&self, dstprofile: &D3D12_VIDEO_ENCODER_PROFILE_DESC) -> windows_core::Result<()>;
    fn GetCodecLevel(&self, dstlevel: &D3D12_VIDEO_ENCODER_LEVEL_SETTING) -> windows_core::Result<()>;
    fn GetResolutionListCount(&self) -> u32;
    fn GetResolutionList(&self, resolutionslistcount: u32, presolutionlist: *mut D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl windows_core::RuntimeName for ID3D12VideoEncoderHeap {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoEncoderHeap_Vtbl {
    pub const fn new<Identity: ID3D12VideoEncoderHeap_Impl, const OFFSET: isize>() -> ID3D12VideoEncoderHeap_Vtbl {
        unsafe extern "system" fn GetNodeMask<Identity: ID3D12VideoEncoderHeap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u32 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncoderHeap_Impl::GetNodeMask(this)
        }
        unsafe extern "system" fn GetEncoderHeapFlags<Identity: ID3D12VideoEncoderHeap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> D3D12_VIDEO_ENCODER_HEAP_FLAGS {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncoderHeap_Impl::GetEncoderHeapFlags(this)
        }
        unsafe extern "system" fn GetCodec<Identity: ID3D12VideoEncoderHeap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> D3D12_VIDEO_ENCODER_CODEC {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncoderHeap_Impl::GetCodec(this)
        }
        unsafe extern "system" fn GetCodecProfile<Identity: ID3D12VideoEncoderHeap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dstprofile: D3D12_VIDEO_ENCODER_PROFILE_DESC) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncoderHeap_Impl::GetCodecProfile(this, core::mem::transmute(&dstprofile)).into()
        }
        unsafe extern "system" fn GetCodecLevel<Identity: ID3D12VideoEncoderHeap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dstlevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncoderHeap_Impl::GetCodecLevel(this, core::mem::transmute(&dstlevel)).into()
        }
        unsafe extern "system" fn GetResolutionListCount<Identity: ID3D12VideoEncoderHeap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u32 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncoderHeap_Impl::GetResolutionListCount(this)
        }
        unsafe extern "system" fn GetResolutionList<Identity: ID3D12VideoEncoderHeap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, resolutionslistcount: u32, presolutionlist: *mut D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoEncoderHeap_Impl::GetResolutionList(this, core::mem::transmute_copy(&resolutionslistcount), core::mem::transmute_copy(&presolutionlist)).into()
        }
        Self {
            base__: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl::new::<Identity, OFFSET>(),
            GetNodeMask: GetNodeMask::<Identity, OFFSET>,
            GetEncoderHeapFlags: GetEncoderHeapFlags::<Identity, OFFSET>,
            GetCodec: GetCodec::<Identity, OFFSET>,
            GetCodecProfile: GetCodecProfile::<Identity, OFFSET>,
            GetCodecLevel: GetCodecLevel::<Identity, OFFSET>,
            GetResolutionListCount: GetResolutionListCount::<Identity, OFFSET>,
            GetResolutionList: GetResolutionList::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoEncoderHeap as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Object as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12DeviceChild as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Pageable as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoExtensionCommand_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Pageable_Impl {
    fn GetDesc(&self) -> D3D12_VIDEO_EXTENSION_COMMAND_DESC;
    fn GetProtectedResourceSession(&self, riid: *const windows_core::GUID, ppprotectedsession: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl windows_core::RuntimeName for ID3D12VideoExtensionCommand {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoExtensionCommand_Vtbl {
    pub const fn new<Identity: ID3D12VideoExtensionCommand_Impl, const OFFSET: isize>() -> ID3D12VideoExtensionCommand_Vtbl {
        unsafe extern "system" fn GetDesc<Identity: ID3D12VideoExtensionCommand_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, result__: *mut D3D12_VIDEO_EXTENSION_COMMAND_DESC) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            *result__ = ID3D12VideoExtensionCommand_Impl::GetDesc(this)
        }
        unsafe extern "system" fn GetProtectedResourceSession<Identity: ID3D12VideoExtensionCommand_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppprotectedsession: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoExtensionCommand_Impl::GetProtectedResourceSession(this, core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppprotectedsession)).into()
        }
        Self {
            base__: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl::new::<Identity, OFFSET>(),
            GetDesc: GetDesc::<Identity, OFFSET>,
            GetProtectedResourceSession: GetProtectedResourceSession::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoExtensionCommand as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Object as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12DeviceChild as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Pageable as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoMotionEstimator_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Pageable_Impl {
    fn GetDesc(&self) -> D3D12_VIDEO_MOTION_ESTIMATOR_DESC;
    fn GetProtectedResourceSession(&self, riid: *const windows_core::GUID, ppprotectedsession: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl windows_core::RuntimeName for ID3D12VideoMotionEstimator {}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoMotionEstimator_Vtbl {
    pub const fn new<Identity: ID3D12VideoMotionEstimator_Impl, const OFFSET: isize>() -> ID3D12VideoMotionEstimator_Vtbl {
        unsafe extern "system" fn GetDesc<Identity: ID3D12VideoMotionEstimator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, result__: *mut D3D12_VIDEO_MOTION_ESTIMATOR_DESC) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            *result__ = ID3D12VideoMotionEstimator_Impl::GetDesc(this)
        }
        unsafe extern "system" fn GetProtectedResourceSession<Identity: ID3D12VideoMotionEstimator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppprotectedsession: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoMotionEstimator_Impl::GetProtectedResourceSession(this, core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppprotectedsession)).into()
        }
        Self {
            base__: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl::new::<Identity, OFFSET>(),
            GetDesc: GetDesc::<Identity, OFFSET>,
            GetProtectedResourceSession: GetProtectedResourceSession::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoMotionEstimator as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Object as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12DeviceChild as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Pageable as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoMotionVectorHeap_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Pageable_Impl {
    fn GetDesc(&self) -> D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC;
    fn GetProtectedResourceSession(&self, riid: *const windows_core::GUID, ppprotectedsession: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl windows_core::RuntimeName for ID3D12VideoMotionVectorHeap {}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoMotionVectorHeap_Vtbl {
    pub const fn new<Identity: ID3D12VideoMotionVectorHeap_Impl, const OFFSET: isize>() -> ID3D12VideoMotionVectorHeap_Vtbl {
        unsafe extern "system" fn GetDesc<Identity: ID3D12VideoMotionVectorHeap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, result__: *mut D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            *result__ = ID3D12VideoMotionVectorHeap_Impl::GetDesc(this)
        }
        unsafe extern "system" fn GetProtectedResourceSession<Identity: ID3D12VideoMotionVectorHeap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppprotectedsession: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoMotionVectorHeap_Impl::GetProtectedResourceSession(this, core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppprotectedsession)).into()
        }
        Self {
            base__: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl::new::<Identity, OFFSET>(),
            GetDesc: GetDesc::<Identity, OFFSET>,
            GetProtectedResourceSession: GetProtectedResourceSession::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoMotionVectorHeap as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Object as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12DeviceChild as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Pageable as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoProcessCommandList_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12CommandList_Impl {
    fn Close(&self) -> windows_core::Result<()>;
    fn Reset(&self, pallocator: Option<&super::super::Graphics::Direct3D12::ID3D12CommandAllocator>) -> windows_core::Result<()>;
    fn ClearState(&self);
    fn ResourceBarrier(&self, numbarriers: u32, pbarriers: *const super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER);
    fn DiscardResource(&self, presource: Option<&super::super::Graphics::Direct3D12::ID3D12Resource>, pregion: *const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION);
    fn BeginQuery(&self, pqueryheap: Option<&super::super::Graphics::Direct3D12::ID3D12QueryHeap>, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32);
    fn EndQuery(&self, pqueryheap: Option<&super::super::Graphics::Direct3D12::ID3D12QueryHeap>, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32);
    fn ResolveQueryData(&self, pqueryheap: Option<&super::super::Graphics::Direct3D12::ID3D12QueryHeap>, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: Option<&super::super::Graphics::Direct3D12::ID3D12Resource>, aligneddestinationbufferoffset: u64);
    fn SetPredication(&self, pbuffer: Option<&super::super::Graphics::Direct3D12::ID3D12Resource>, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP);
    fn SetMarker(&self, metadata: u32, pdata: *const core::ffi::c_void, size: u32);
    fn BeginEvent(&self, metadata: u32, pdata: *const core::ffi::c_void, size: u32);
    fn EndEvent(&self);
    fn ProcessFrames(&self, pvideoprocessor: Option<&ID3D12VideoProcessor>, poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS, numinputstreams: u32, pinputarguments: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS);
    fn WriteBufferImmediate(&self, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl windows_core::RuntimeName for ID3D12VideoProcessCommandList {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoProcessCommandList_Vtbl {
    pub const fn new<Identity: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>() -> ID3D12VideoProcessCommandList_Vtbl {
        unsafe extern "system" fn Close<Identity: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoProcessCommandList_Impl::Close(this).into()
        }
        unsafe extern "system" fn Reset<Identity: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pallocator: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoProcessCommandList_Impl::Reset(this, windows_core::from_raw_borrowed(&pallocator)).into()
        }
        unsafe extern "system" fn ClearState<Identity: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoProcessCommandList_Impl::ClearState(this)
        }
        unsafe extern "system" fn ResourceBarrier<Identity: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, numbarriers: u32, pbarriers: *const super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoProcessCommandList_Impl::ResourceBarrier(this, core::mem::transmute_copy(&numbarriers), core::mem::transmute_copy(&pbarriers))
        }
        unsafe extern "system" fn DiscardResource<Identity: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presource: *mut core::ffi::c_void, pregion: *const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoProcessCommandList_Impl::DiscardResource(this, windows_core::from_raw_borrowed(&presource), core::mem::transmute_copy(&pregion))
        }
        unsafe extern "system" fn BeginQuery<Identity: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pqueryheap: *mut core::ffi::c_void, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoProcessCommandList_Impl::BeginQuery(this, windows_core::from_raw_borrowed(&pqueryheap), core::mem::transmute_copy(&r#type), core::mem::transmute_copy(&index))
        }
        unsafe extern "system" fn EndQuery<Identity: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pqueryheap: *mut core::ffi::c_void, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoProcessCommandList_Impl::EndQuery(this, windows_core::from_raw_borrowed(&pqueryheap), core::mem::transmute_copy(&r#type), core::mem::transmute_copy(&index))
        }
        unsafe extern "system" fn ResolveQueryData<Identity: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pqueryheap: *mut core::ffi::c_void, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: *mut core::ffi::c_void, aligneddestinationbufferoffset: u64) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoProcessCommandList_Impl::ResolveQueryData(this, windows_core::from_raw_borrowed(&pqueryheap), core::mem::transmute_copy(&r#type), core::mem::transmute_copy(&startindex), core::mem::transmute_copy(&numqueries), windows_core::from_raw_borrowed(&pdestinationbuffer), core::mem::transmute_copy(&aligneddestinationbufferoffset))
        }
        unsafe extern "system" fn SetPredication<Identity: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbuffer: *mut core::ffi::c_void, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoProcessCommandList_Impl::SetPredication(this, windows_core::from_raw_borrowed(&pbuffer), core::mem::transmute_copy(&alignedbufferoffset), core::mem::transmute_copy(&operation))
        }
        unsafe extern "system" fn SetMarker<Identity: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, metadata: u32, pdata: *const core::ffi::c_void, size: u32) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoProcessCommandList_Impl::SetMarker(this, core::mem::transmute_copy(&metadata), core::mem::transmute_copy(&pdata), core::mem::transmute_copy(&size))
        }
        unsafe extern "system" fn BeginEvent<Identity: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, metadata: u32, pdata: *const core::ffi::c_void, size: u32) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoProcessCommandList_Impl::BeginEvent(this, core::mem::transmute_copy(&metadata), core::mem::transmute_copy(&pdata), core::mem::transmute_copy(&size))
        }
        unsafe extern "system" fn EndEvent<Identity: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoProcessCommandList_Impl::EndEvent(this)
        }
        unsafe extern "system" fn ProcessFrames<Identity: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvideoprocessor: *mut core::ffi::c_void, poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS, numinputstreams: u32, pinputarguments: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoProcessCommandList_Impl::ProcessFrames(this, windows_core::from_raw_borrowed(&pvideoprocessor), core::mem::transmute_copy(&poutputarguments), core::mem::transmute_copy(&numinputstreams), core::mem::transmute_copy(&pinputarguments))
        }
        unsafe extern "system" fn WriteBufferImmediate<Identity: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoProcessCommandList_Impl::WriteBufferImmediate(this, core::mem::transmute_copy(&count), core::mem::transmute_copy(&pparams), core::mem::transmute_copy(&pmodes))
        }
        Self {
            base__: super::super::Graphics::Direct3D12::ID3D12CommandList_Vtbl::new::<Identity, OFFSET>(),
            Close: Close::<Identity, OFFSET>,
            Reset: Reset::<Identity, OFFSET>,
            ClearState: ClearState::<Identity, OFFSET>,
            ResourceBarrier: ResourceBarrier::<Identity, OFFSET>,
            DiscardResource: DiscardResource::<Identity, OFFSET>,
            BeginQuery: BeginQuery::<Identity, OFFSET>,
            EndQuery: EndQuery::<Identity, OFFSET>,
            ResolveQueryData: ResolveQueryData::<Identity, OFFSET>,
            SetPredication: SetPredication::<Identity, OFFSET>,
            SetMarker: SetMarker::<Identity, OFFSET>,
            BeginEvent: BeginEvent::<Identity, OFFSET>,
            EndEvent: EndEvent::<Identity, OFFSET>,
            ProcessFrames: ProcessFrames::<Identity, OFFSET>,
            WriteBufferImmediate: WriteBufferImmediate::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoProcessCommandList as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Object as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12DeviceChild as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12CommandList as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoProcessCommandList1_Impl: Sized + ID3D12VideoProcessCommandList_Impl {
    fn ProcessFrames1(&self, pvideoprocessor: Option<&ID3D12VideoProcessor>, poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS, numinputstreams: u32, pinputarguments: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl windows_core::RuntimeName for ID3D12VideoProcessCommandList1 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoProcessCommandList1_Vtbl {
    pub const fn new<Identity: ID3D12VideoProcessCommandList1_Impl, const OFFSET: isize>() -> ID3D12VideoProcessCommandList1_Vtbl {
        unsafe extern "system" fn ProcessFrames1<Identity: ID3D12VideoProcessCommandList1_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvideoprocessor: *mut core::ffi::c_void, poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS, numinputstreams: u32, pinputarguments: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoProcessCommandList1_Impl::ProcessFrames1(this, windows_core::from_raw_borrowed(&pvideoprocessor), core::mem::transmute_copy(&poutputarguments), core::mem::transmute_copy(&numinputstreams), core::mem::transmute_copy(&pinputarguments))
        }
        Self { base__: ID3D12VideoProcessCommandList_Vtbl::new::<Identity, OFFSET>(), ProcessFrames1: ProcessFrames1::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoProcessCommandList1 as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Object as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12DeviceChild as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12CommandList as windows_core::Interface>::IID || iid == &<ID3D12VideoProcessCommandList as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoProcessCommandList2_Impl: Sized + ID3D12VideoProcessCommandList1_Impl {
    fn SetProtectedResourceSession(&self, pprotectedresourcesession: Option<&super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>);
    fn InitializeExtensionCommand(&self, pextensioncommand: Option<&ID3D12VideoExtensionCommand>, pinitializationparameters: *const core::ffi::c_void, initializationparameterssizeinbytes: usize);
    fn ExecuteExtensionCommand(&self, pextensioncommand: Option<&ID3D12VideoExtensionCommand>, pexecutionparameters: *const core::ffi::c_void, executionparameterssizeinbytes: usize);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl windows_core::RuntimeName for ID3D12VideoProcessCommandList2 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoProcessCommandList2_Vtbl {
    pub const fn new<Identity: ID3D12VideoProcessCommandList2_Impl, const OFFSET: isize>() -> ID3D12VideoProcessCommandList2_Vtbl {
        unsafe extern "system" fn SetProtectedResourceSession<Identity: ID3D12VideoProcessCommandList2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pprotectedresourcesession: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoProcessCommandList2_Impl::SetProtectedResourceSession(this, windows_core::from_raw_borrowed(&pprotectedresourcesession))
        }
        unsafe extern "system" fn InitializeExtensionCommand<Identity: ID3D12VideoProcessCommandList2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pextensioncommand: *mut core::ffi::c_void, pinitializationparameters: *const core::ffi::c_void, initializationparameterssizeinbytes: usize) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoProcessCommandList2_Impl::InitializeExtensionCommand(this, windows_core::from_raw_borrowed(&pextensioncommand), core::mem::transmute_copy(&pinitializationparameters), core::mem::transmute_copy(&initializationparameterssizeinbytes))
        }
        unsafe extern "system" fn ExecuteExtensionCommand<Identity: ID3D12VideoProcessCommandList2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pextensioncommand: *mut core::ffi::c_void, pexecutionparameters: *const core::ffi::c_void, executionparameterssizeinbytes: usize) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoProcessCommandList2_Impl::ExecuteExtensionCommand(this, windows_core::from_raw_borrowed(&pextensioncommand), core::mem::transmute_copy(&pexecutionparameters), core::mem::transmute_copy(&executionparameterssizeinbytes))
        }
        Self {
            base__: ID3D12VideoProcessCommandList1_Vtbl::new::<Identity, OFFSET>(),
            SetProtectedResourceSession: SetProtectedResourceSession::<Identity, OFFSET>,
            InitializeExtensionCommand: InitializeExtensionCommand::<Identity, OFFSET>,
            ExecuteExtensionCommand: ExecuteExtensionCommand::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoProcessCommandList2 as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Object as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12DeviceChild as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12CommandList as windows_core::Interface>::IID || iid == &<ID3D12VideoProcessCommandList as windows_core::Interface>::IID || iid == &<ID3D12VideoProcessCommandList1 as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoProcessCommandList3_Impl: Sized + ID3D12VideoProcessCommandList2_Impl {
    fn Barrier(&self, numbarriergroups: u32, pbarriergroups: *const super::super::Graphics::Direct3D12::D3D12_BARRIER_GROUP);
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl windows_core::RuntimeName for ID3D12VideoProcessCommandList3 {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoProcessCommandList3_Vtbl {
    pub const fn new<Identity: ID3D12VideoProcessCommandList3_Impl, const OFFSET: isize>() -> ID3D12VideoProcessCommandList3_Vtbl {
        unsafe extern "system" fn Barrier<Identity: ID3D12VideoProcessCommandList3_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, numbarriergroups: u32, pbarriergroups: *const super::super::Graphics::Direct3D12::D3D12_BARRIER_GROUP) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoProcessCommandList3_Impl::Barrier(this, core::mem::transmute_copy(&numbarriergroups), core::mem::transmute_copy(&pbarriergroups))
        }
        Self { base__: ID3D12VideoProcessCommandList2_Vtbl::new::<Identity, OFFSET>(), Barrier: Barrier::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoProcessCommandList3 as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Object as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12DeviceChild as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12CommandList as windows_core::Interface>::IID || iid == &<ID3D12VideoProcessCommandList as windows_core::Interface>::IID || iid == &<ID3D12VideoProcessCommandList1 as windows_core::Interface>::IID || iid == &<ID3D12VideoProcessCommandList2 as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoProcessor_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Pageable_Impl {
    fn GetNodeMask(&self) -> u32;
    fn GetNumInputStreamDescs(&self) -> u32;
    fn GetInputStreamDescs(&self, numinputstreamdescs: u32, pinputstreamdescs: *mut D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC) -> windows_core::Result<()>;
    fn GetOutputStreamDesc(&self) -> D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC;
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl windows_core::RuntimeName for ID3D12VideoProcessor {}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoProcessor_Vtbl {
    pub const fn new<Identity: ID3D12VideoProcessor_Impl, const OFFSET: isize>() -> ID3D12VideoProcessor_Vtbl {
        unsafe extern "system" fn GetNodeMask<Identity: ID3D12VideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u32 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoProcessor_Impl::GetNodeMask(this)
        }
        unsafe extern "system" fn GetNumInputStreamDescs<Identity: ID3D12VideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u32 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoProcessor_Impl::GetNumInputStreamDescs(this)
        }
        unsafe extern "system" fn GetInputStreamDescs<Identity: ID3D12VideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, numinputstreamdescs: u32, pinputstreamdescs: *mut D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoProcessor_Impl::GetInputStreamDescs(this, core::mem::transmute_copy(&numinputstreamdescs), core::mem::transmute_copy(&pinputstreamdescs)).into()
        }
        unsafe extern "system" fn GetOutputStreamDesc<Identity: ID3D12VideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, result__: *mut D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            *result__ = ID3D12VideoProcessor_Impl::GetOutputStreamDesc(this)
        }
        Self {
            base__: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl::new::<Identity, OFFSET>(),
            GetNodeMask: GetNodeMask::<Identity, OFFSET>,
            GetNumInputStreamDescs: GetNumInputStreamDescs::<Identity, OFFSET>,
            GetInputStreamDescs: GetInputStreamDescs::<Identity, OFFSET>,
            GetOutputStreamDesc: GetOutputStreamDesc::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoProcessor as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Object as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12DeviceChild as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Pageable as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoProcessor1_Impl: Sized + ID3D12VideoProcessor_Impl {
    fn GetProtectedResourceSession(&self, riid: *const windows_core::GUID, ppprotectedsession: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl windows_core::RuntimeName for ID3D12VideoProcessor1 {}
#[cfg(all(feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoProcessor1_Vtbl {
    pub const fn new<Identity: ID3D12VideoProcessor1_Impl, const OFFSET: isize>() -> ID3D12VideoProcessor1_Vtbl {
        unsafe extern "system" fn GetProtectedResourceSession<Identity: ID3D12VideoProcessor1_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppprotectedsession: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ID3D12VideoProcessor1_Impl::GetProtectedResourceSession(this, core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppprotectedsession)).into()
        }
        Self { base__: ID3D12VideoProcessor_Vtbl::new::<Identity, OFFSET>(), GetProtectedResourceSession: GetProtectedResourceSession::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ID3D12VideoProcessor1 as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Object as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12DeviceChild as windows_core::Interface>::IID || iid == &<super::super::Graphics::Direct3D12::ID3D12Pageable as windows_core::Interface>::IID || iid == &<ID3D12VideoProcessor as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub trait IDXVAHD_Device_Impl: Sized + windows_core::IUnknownImpl {
    fn CreateVideoSurface(&self, width: u32, height: u32, format: super::super::Graphics::Direct3D9::D3DFORMAT, pool: super::super::Graphics::Direct3D9::D3DPOOL, usage: u32, r#type: DXVAHD_SURFACE_TYPE, numsurfaces: u32, ppsurfaces: *mut Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, psharedhandle: *mut super::super::Foundation::HANDLE) -> windows_core::Result<()>;
    fn GetVideoProcessorDeviceCaps(&self, pcaps: *mut DXVAHD_VPDEVCAPS) -> windows_core::Result<()>;
    fn GetVideoProcessorOutputFormats(&self, count: u32, pformats: *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> windows_core::Result<()>;
    fn GetVideoProcessorInputFormats(&self, count: u32, pformats: *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> windows_core::Result<()>;
    fn GetVideoProcessorCaps(&self, count: u32, pcaps: *mut DXVAHD_VPCAPS) -> windows_core::Result<()>;
    fn GetVideoProcessorCustomRates(&self, pvpguid: *const windows_core::GUID, count: u32, prates: *mut DXVAHD_CUSTOM_RATE_DATA) -> windows_core::Result<()>;
    fn GetVideoProcessorFilterRange(&self, filter: DXVAHD_FILTER) -> windows_core::Result<DXVAHD_FILTER_RANGE_DATA>;
    fn CreateVideoProcessor(&self, pvpguid: *const windows_core::GUID) -> windows_core::Result<IDXVAHD_VideoProcessor>;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl windows_core::RuntimeName for IDXVAHD_Device {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl IDXVAHD_Device_Vtbl {
    pub const fn new<Identity: IDXVAHD_Device_Impl, const OFFSET: isize>() -> IDXVAHD_Device_Vtbl {
        unsafe extern "system" fn CreateVideoSurface<Identity: IDXVAHD_Device_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, width: u32, height: u32, format: super::super::Graphics::Direct3D9::D3DFORMAT, pool: super::super::Graphics::Direct3D9::D3DPOOL, usage: u32, r#type: DXVAHD_SURFACE_TYPE, numsurfaces: u32, ppsurfaces: *mut *mut core::ffi::c_void, psharedhandle: *mut super::super::Foundation::HANDLE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDXVAHD_Device_Impl::CreateVideoSurface(this, core::mem::transmute_copy(&width), core::mem::transmute_copy(&height), core::mem::transmute_copy(&format), core::mem::transmute_copy(&pool), core::mem::transmute_copy(&usage), core::mem::transmute_copy(&r#type), core::mem::transmute_copy(&numsurfaces), core::mem::transmute_copy(&ppsurfaces), core::mem::transmute_copy(&psharedhandle)).into()
        }
        unsafe extern "system" fn GetVideoProcessorDeviceCaps<Identity: IDXVAHD_Device_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcaps: *mut DXVAHD_VPDEVCAPS) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDXVAHD_Device_Impl::GetVideoProcessorDeviceCaps(this, core::mem::transmute_copy(&pcaps)).into()
        }
        unsafe extern "system" fn GetVideoProcessorOutputFormats<Identity: IDXVAHD_Device_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, count: u32, pformats: *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDXVAHD_Device_Impl::GetVideoProcessorOutputFormats(this, core::mem::transmute_copy(&count), core::mem::transmute_copy(&pformats)).into()
        }
        unsafe extern "system" fn GetVideoProcessorInputFormats<Identity: IDXVAHD_Device_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, count: u32, pformats: *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDXVAHD_Device_Impl::GetVideoProcessorInputFormats(this, core::mem::transmute_copy(&count), core::mem::transmute_copy(&pformats)).into()
        }
        unsafe extern "system" fn GetVideoProcessorCaps<Identity: IDXVAHD_Device_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, count: u32, pcaps: *mut DXVAHD_VPCAPS) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDXVAHD_Device_Impl::GetVideoProcessorCaps(this, core::mem::transmute_copy(&count), core::mem::transmute_copy(&pcaps)).into()
        }
        unsafe extern "system" fn GetVideoProcessorCustomRates<Identity: IDXVAHD_Device_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvpguid: *const windows_core::GUID, count: u32, prates: *mut DXVAHD_CUSTOM_RATE_DATA) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDXVAHD_Device_Impl::GetVideoProcessorCustomRates(this, core::mem::transmute_copy(&pvpguid), core::mem::transmute_copy(&count), core::mem::transmute_copy(&prates)).into()
        }
        unsafe extern "system" fn GetVideoProcessorFilterRange<Identity: IDXVAHD_Device_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, filter: DXVAHD_FILTER, prange: *mut DXVAHD_FILTER_RANGE_DATA) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IDXVAHD_Device_Impl::GetVideoProcessorFilterRange(this, core::mem::transmute_copy(&filter)) {
                Ok(ok__) => {
                    prange.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateVideoProcessor<Identity: IDXVAHD_Device_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvpguid: *const windows_core::GUID, ppvideoprocessor: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IDXVAHD_Device_Impl::CreateVideoProcessor(this, core::mem::transmute_copy(&pvpguid)) {
                Ok(ok__) => {
                    ppvideoprocessor.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            CreateVideoSurface: CreateVideoSurface::<Identity, OFFSET>,
            GetVideoProcessorDeviceCaps: GetVideoProcessorDeviceCaps::<Identity, OFFSET>,
            GetVideoProcessorOutputFormats: GetVideoProcessorOutputFormats::<Identity, OFFSET>,
            GetVideoProcessorInputFormats: GetVideoProcessorInputFormats::<Identity, OFFSET>,
            GetVideoProcessorCaps: GetVideoProcessorCaps::<Identity, OFFSET>,
            GetVideoProcessorCustomRates: GetVideoProcessorCustomRates::<Identity, OFFSET>,
            GetVideoProcessorFilterRange: GetVideoProcessorFilterRange::<Identity, OFFSET>,
            CreateVideoProcessor: CreateVideoProcessor::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDXVAHD_Device as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub trait IDXVAHD_VideoProcessor_Impl: Sized + windows_core::IUnknownImpl {
    fn SetVideoProcessBltState(&self, state: DXVAHD_BLT_STATE, datasize: u32, pdata: *const core::ffi::c_void) -> windows_core::Result<()>;
    fn GetVideoProcessBltState(&self, state: DXVAHD_BLT_STATE, datasize: u32, pdata: *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn SetVideoProcessStreamState(&self, streamnumber: u32, state: DXVAHD_STREAM_STATE, datasize: u32, pdata: *const core::ffi::c_void) -> windows_core::Result<()>;
    fn GetVideoProcessStreamState(&self, streamnumber: u32, state: DXVAHD_STREAM_STATE, datasize: u32, pdata: *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn VideoProcessBltHD(&self, poutputsurface: Option<&super::super::Graphics::Direct3D9::IDirect3DSurface9>, outputframe: u32, streamcount: u32, pstreams: *const DXVAHD_STREAM_DATA) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl windows_core::RuntimeName for IDXVAHD_VideoProcessor {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl IDXVAHD_VideoProcessor_Vtbl {
    pub const fn new<Identity: IDXVAHD_VideoProcessor_Impl, const OFFSET: isize>() -> IDXVAHD_VideoProcessor_Vtbl {
        unsafe extern "system" fn SetVideoProcessBltState<Identity: IDXVAHD_VideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, state: DXVAHD_BLT_STATE, datasize: u32, pdata: *const core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDXVAHD_VideoProcessor_Impl::SetVideoProcessBltState(this, core::mem::transmute_copy(&state), core::mem::transmute_copy(&datasize), core::mem::transmute_copy(&pdata)).into()
        }
        unsafe extern "system" fn GetVideoProcessBltState<Identity: IDXVAHD_VideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, state: DXVAHD_BLT_STATE, datasize: u32, pdata: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDXVAHD_VideoProcessor_Impl::GetVideoProcessBltState(this, core::mem::transmute_copy(&state), core::mem::transmute_copy(&datasize), core::mem::transmute_copy(&pdata)).into()
        }
        unsafe extern "system" fn SetVideoProcessStreamState<Identity: IDXVAHD_VideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, streamnumber: u32, state: DXVAHD_STREAM_STATE, datasize: u32, pdata: *const core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDXVAHD_VideoProcessor_Impl::SetVideoProcessStreamState(this, core::mem::transmute_copy(&streamnumber), core::mem::transmute_copy(&state), core::mem::transmute_copy(&datasize), core::mem::transmute_copy(&pdata)).into()
        }
        unsafe extern "system" fn GetVideoProcessStreamState<Identity: IDXVAHD_VideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, streamnumber: u32, state: DXVAHD_STREAM_STATE, datasize: u32, pdata: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDXVAHD_VideoProcessor_Impl::GetVideoProcessStreamState(this, core::mem::transmute_copy(&streamnumber), core::mem::transmute_copy(&state), core::mem::transmute_copy(&datasize), core::mem::transmute_copy(&pdata)).into()
        }
        unsafe extern "system" fn VideoProcessBltHD<Identity: IDXVAHD_VideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, poutputsurface: *mut core::ffi::c_void, outputframe: u32, streamcount: u32, pstreams: *const DXVAHD_STREAM_DATA) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDXVAHD_VideoProcessor_Impl::VideoProcessBltHD(this, windows_core::from_raw_borrowed(&poutputsurface), core::mem::transmute_copy(&outputframe), core::mem::transmute_copy(&streamcount), core::mem::transmute_copy(&pstreams)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetVideoProcessBltState: SetVideoProcessBltState::<Identity, OFFSET>,
            GetVideoProcessBltState: GetVideoProcessBltState::<Identity, OFFSET>,
            SetVideoProcessStreamState: SetVideoProcessStreamState::<Identity, OFFSET>,
            GetVideoProcessStreamState: GetVideoProcessStreamState::<Identity, OFFSET>,
            VideoProcessBltHD: VideoProcessBltHD::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDXVAHD_VideoProcessor as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub trait IDirect3D9ExOverlayExtension_Impl: Sized + windows_core::IUnknownImpl {
    fn CheckDeviceOverlayType(&self, adapter: u32, devtype: super::super::Graphics::Direct3D9::D3DDEVTYPE, overlaywidth: u32, overlayheight: u32, overlayformat: super::super::Graphics::Direct3D9::D3DFORMAT, pdisplaymode: *mut super::super::Graphics::Direct3D9::D3DDISPLAYMODEEX, displayrotation: super::super::Graphics::Direct3D9::D3DDISPLAYROTATION, poverlaycaps: *mut D3DOVERLAYCAPS) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl windows_core::RuntimeName for IDirect3D9ExOverlayExtension {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl IDirect3D9ExOverlayExtension_Vtbl {
    pub const fn new<Identity: IDirect3D9ExOverlayExtension_Impl, const OFFSET: isize>() -> IDirect3D9ExOverlayExtension_Vtbl {
        unsafe extern "system" fn CheckDeviceOverlayType<Identity: IDirect3D9ExOverlayExtension_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, adapter: u32, devtype: super::super::Graphics::Direct3D9::D3DDEVTYPE, overlaywidth: u32, overlayheight: u32, overlayformat: super::super::Graphics::Direct3D9::D3DFORMAT, pdisplaymode: *mut super::super::Graphics::Direct3D9::D3DDISPLAYMODEEX, displayrotation: super::super::Graphics::Direct3D9::D3DDISPLAYROTATION, poverlaycaps: *mut D3DOVERLAYCAPS) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3D9ExOverlayExtension_Impl::CheckDeviceOverlayType(this, core::mem::transmute_copy(&adapter), core::mem::transmute_copy(&devtype), core::mem::transmute_copy(&overlaywidth), core::mem::transmute_copy(&overlayheight), core::mem::transmute_copy(&overlayformat), core::mem::transmute_copy(&pdisplaymode), core::mem::transmute_copy(&displayrotation), core::mem::transmute_copy(&poverlaycaps)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), CheckDeviceOverlayType: CheckDeviceOverlayType::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDirect3D9ExOverlayExtension as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub trait IDirect3DAuthenticatedChannel9_Impl: Sized + windows_core::IUnknownImpl {
    fn GetCertificateSize(&self, pcertificatesize: *mut u32) -> windows_core::Result<()>;
    fn GetCertificate(&self, certifactesize: u32, ppcertificate: *mut u8) -> windows_core::Result<()>;
    fn NegotiateKeyExchange(&self, datasize: u32, pdata: *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn Query(&self, inputsize: u32, pinput: *const core::ffi::c_void, outputsize: u32, poutput: *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn Configure(&self, inputsize: u32, pinput: *const core::ffi::c_void, poutput: *mut super::super::Graphics::Direct3D9::D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl windows_core::RuntimeName for IDirect3DAuthenticatedChannel9 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl IDirect3DAuthenticatedChannel9_Vtbl {
    pub const fn new<Identity: IDirect3DAuthenticatedChannel9_Impl, const OFFSET: isize>() -> IDirect3DAuthenticatedChannel9_Vtbl {
        unsafe extern "system" fn GetCertificateSize<Identity: IDirect3DAuthenticatedChannel9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcertificatesize: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3DAuthenticatedChannel9_Impl::GetCertificateSize(this, core::mem::transmute_copy(&pcertificatesize)).into()
        }
        unsafe extern "system" fn GetCertificate<Identity: IDirect3DAuthenticatedChannel9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, certifactesize: u32, ppcertificate: *mut u8) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3DAuthenticatedChannel9_Impl::GetCertificate(this, core::mem::transmute_copy(&certifactesize), core::mem::transmute_copy(&ppcertificate)).into()
        }
        unsafe extern "system" fn NegotiateKeyExchange<Identity: IDirect3DAuthenticatedChannel9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, datasize: u32, pdata: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3DAuthenticatedChannel9_Impl::NegotiateKeyExchange(this, core::mem::transmute_copy(&datasize), core::mem::transmute_copy(&pdata)).into()
        }
        unsafe extern "system" fn Query<Identity: IDirect3DAuthenticatedChannel9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, inputsize: u32, pinput: *const core::ffi::c_void, outputsize: u32, poutput: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3DAuthenticatedChannel9_Impl::Query(this, core::mem::transmute_copy(&inputsize), core::mem::transmute_copy(&pinput), core::mem::transmute_copy(&outputsize), core::mem::transmute_copy(&poutput)).into()
        }
        unsafe extern "system" fn Configure<Identity: IDirect3DAuthenticatedChannel9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, inputsize: u32, pinput: *const core::ffi::c_void, poutput: *mut super::super::Graphics::Direct3D9::D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3DAuthenticatedChannel9_Impl::Configure(this, core::mem::transmute_copy(&inputsize), core::mem::transmute_copy(&pinput), core::mem::transmute_copy(&poutput)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetCertificateSize: GetCertificateSize::<Identity, OFFSET>,
            GetCertificate: GetCertificate::<Identity, OFFSET>,
            NegotiateKeyExchange: NegotiateKeyExchange::<Identity, OFFSET>,
            Query: Query::<Identity, OFFSET>,
            Configure: Configure::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDirect3DAuthenticatedChannel9 as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub trait IDirect3DCryptoSession9_Impl: Sized + windows_core::IUnknownImpl {
    fn GetCertificateSize(&self, pcertificatesize: *mut u32) -> windows_core::Result<()>;
    fn GetCertificate(&self, certifactesize: u32, ppcertificate: *mut u8) -> windows_core::Result<()>;
    fn NegotiateKeyExchange(&self, datasize: u32, pdata: *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn EncryptionBlt(&self, psrcsurface: Option<&super::super::Graphics::Direct3D9::IDirect3DSurface9>, pdstsurface: Option<&super::super::Graphics::Direct3D9::IDirect3DSurface9>, dstsurfacesize: u32, piv: *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn DecryptionBlt(&self, psrcsurface: Option<&super::super::Graphics::Direct3D9::IDirect3DSurface9>, pdstsurface: Option<&super::super::Graphics::Direct3D9::IDirect3DSurface9>, srcsurfacesize: u32, pencryptedblockinfo: *mut super::super::Graphics::Direct3D9::D3DENCRYPTED_BLOCK_INFO, pcontentkey: *mut core::ffi::c_void, piv: *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn GetSurfacePitch(&self, psrcsurface: Option<&super::super::Graphics::Direct3D9::IDirect3DSurface9>, psurfacepitch: *mut u32) -> windows_core::Result<()>;
    fn StartSessionKeyRefresh(&self, prandomnumber: *mut core::ffi::c_void, randomnumbersize: u32) -> windows_core::Result<()>;
    fn FinishSessionKeyRefresh(&self) -> windows_core::Result<()>;
    fn GetEncryptionBltKey(&self, preadbackkey: *mut core::ffi::c_void, keysize: u32) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl windows_core::RuntimeName for IDirect3DCryptoSession9 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl IDirect3DCryptoSession9_Vtbl {
    pub const fn new<Identity: IDirect3DCryptoSession9_Impl, const OFFSET: isize>() -> IDirect3DCryptoSession9_Vtbl {
        unsafe extern "system" fn GetCertificateSize<Identity: IDirect3DCryptoSession9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcertificatesize: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3DCryptoSession9_Impl::GetCertificateSize(this, core::mem::transmute_copy(&pcertificatesize)).into()
        }
        unsafe extern "system" fn GetCertificate<Identity: IDirect3DCryptoSession9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, certifactesize: u32, ppcertificate: *mut u8) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3DCryptoSession9_Impl::GetCertificate(this, core::mem::transmute_copy(&certifactesize), core::mem::transmute_copy(&ppcertificate)).into()
        }
        unsafe extern "system" fn NegotiateKeyExchange<Identity: IDirect3DCryptoSession9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, datasize: u32, pdata: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3DCryptoSession9_Impl::NegotiateKeyExchange(this, core::mem::transmute_copy(&datasize), core::mem::transmute_copy(&pdata)).into()
        }
        unsafe extern "system" fn EncryptionBlt<Identity: IDirect3DCryptoSession9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psrcsurface: *mut core::ffi::c_void, pdstsurface: *mut core::ffi::c_void, dstsurfacesize: u32, piv: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3DCryptoSession9_Impl::EncryptionBlt(this, windows_core::from_raw_borrowed(&psrcsurface), windows_core::from_raw_borrowed(&pdstsurface), core::mem::transmute_copy(&dstsurfacesize), core::mem::transmute_copy(&piv)).into()
        }
        unsafe extern "system" fn DecryptionBlt<Identity: IDirect3DCryptoSession9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psrcsurface: *mut core::ffi::c_void, pdstsurface: *mut core::ffi::c_void, srcsurfacesize: u32, pencryptedblockinfo: *mut super::super::Graphics::Direct3D9::D3DENCRYPTED_BLOCK_INFO, pcontentkey: *mut core::ffi::c_void, piv: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3DCryptoSession9_Impl::DecryptionBlt(this, windows_core::from_raw_borrowed(&psrcsurface), windows_core::from_raw_borrowed(&pdstsurface), core::mem::transmute_copy(&srcsurfacesize), core::mem::transmute_copy(&pencryptedblockinfo), core::mem::transmute_copy(&pcontentkey), core::mem::transmute_copy(&piv)).into()
        }
        unsafe extern "system" fn GetSurfacePitch<Identity: IDirect3DCryptoSession9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psrcsurface: *mut core::ffi::c_void, psurfacepitch: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3DCryptoSession9_Impl::GetSurfacePitch(this, windows_core::from_raw_borrowed(&psrcsurface), core::mem::transmute_copy(&psurfacepitch)).into()
        }
        unsafe extern "system" fn StartSessionKeyRefresh<Identity: IDirect3DCryptoSession9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, prandomnumber: *mut core::ffi::c_void, randomnumbersize: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3DCryptoSession9_Impl::StartSessionKeyRefresh(this, core::mem::transmute_copy(&prandomnumber), core::mem::transmute_copy(&randomnumbersize)).into()
        }
        unsafe extern "system" fn FinishSessionKeyRefresh<Identity: IDirect3DCryptoSession9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3DCryptoSession9_Impl::FinishSessionKeyRefresh(this).into()
        }
        unsafe extern "system" fn GetEncryptionBltKey<Identity: IDirect3DCryptoSession9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, preadbackkey: *mut core::ffi::c_void, keysize: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3DCryptoSession9_Impl::GetEncryptionBltKey(this, core::mem::transmute_copy(&preadbackkey), core::mem::transmute_copy(&keysize)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetCertificateSize: GetCertificateSize::<Identity, OFFSET>,
            GetCertificate: GetCertificate::<Identity, OFFSET>,
            NegotiateKeyExchange: NegotiateKeyExchange::<Identity, OFFSET>,
            EncryptionBlt: EncryptionBlt::<Identity, OFFSET>,
            DecryptionBlt: DecryptionBlt::<Identity, OFFSET>,
            GetSurfacePitch: GetSurfacePitch::<Identity, OFFSET>,
            StartSessionKeyRefresh: StartSessionKeyRefresh::<Identity, OFFSET>,
            FinishSessionKeyRefresh: FinishSessionKeyRefresh::<Identity, OFFSET>,
            GetEncryptionBltKey: GetEncryptionBltKey::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDirect3DCryptoSession9 as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub trait IDirect3DDevice9Video_Impl: Sized + windows_core::IUnknownImpl {
    fn GetContentProtectionCaps(&self, pcryptotype: *const windows_core::GUID, pdecodeprofile: *const windows_core::GUID, pcaps: *mut D3DCONTENTPROTECTIONCAPS) -> windows_core::Result<()>;
    fn CreateAuthenticatedChannel(&self, channeltype: super::super::Graphics::Direct3D9::D3DAUTHENTICATEDCHANNELTYPE, ppauthenticatedchannel: *mut Option<IDirect3DAuthenticatedChannel9>, pchannelhandle: *mut super::super::Foundation::HANDLE) -> windows_core::Result<()>;
    fn CreateCryptoSession(&self, pcryptotype: *const windows_core::GUID, pdecodeprofile: *const windows_core::GUID, ppcryptosession: *mut Option<IDirect3DCryptoSession9>, pcryptohandle: *mut super::super::Foundation::HANDLE) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl windows_core::RuntimeName for IDirect3DDevice9Video {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl IDirect3DDevice9Video_Vtbl {
    pub const fn new<Identity: IDirect3DDevice9Video_Impl, const OFFSET: isize>() -> IDirect3DDevice9Video_Vtbl {
        unsafe extern "system" fn GetContentProtectionCaps<Identity: IDirect3DDevice9Video_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcryptotype: *const windows_core::GUID, pdecodeprofile: *const windows_core::GUID, pcaps: *mut D3DCONTENTPROTECTIONCAPS) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3DDevice9Video_Impl::GetContentProtectionCaps(this, core::mem::transmute_copy(&pcryptotype), core::mem::transmute_copy(&pdecodeprofile), core::mem::transmute_copy(&pcaps)).into()
        }
        unsafe extern "system" fn CreateAuthenticatedChannel<Identity: IDirect3DDevice9Video_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, channeltype: super::super::Graphics::Direct3D9::D3DAUTHENTICATEDCHANNELTYPE, ppauthenticatedchannel: *mut *mut core::ffi::c_void, pchannelhandle: *mut super::super::Foundation::HANDLE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3DDevice9Video_Impl::CreateAuthenticatedChannel(this, core::mem::transmute_copy(&channeltype), core::mem::transmute_copy(&ppauthenticatedchannel), core::mem::transmute_copy(&pchannelhandle)).into()
        }
        unsafe extern "system" fn CreateCryptoSession<Identity: IDirect3DDevice9Video_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcryptotype: *const windows_core::GUID, pdecodeprofile: *const windows_core::GUID, ppcryptosession: *mut *mut core::ffi::c_void, pcryptohandle: *mut super::super::Foundation::HANDLE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3DDevice9Video_Impl::CreateCryptoSession(this, core::mem::transmute_copy(&pcryptotype), core::mem::transmute_copy(&pdecodeprofile), core::mem::transmute_copy(&ppcryptosession), core::mem::transmute_copy(&pcryptohandle)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetContentProtectionCaps: GetContentProtectionCaps::<Identity, OFFSET>,
            CreateAuthenticatedChannel: CreateAuthenticatedChannel::<Identity, OFFSET>,
            CreateCryptoSession: CreateCryptoSession::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDirect3DDevice9Video as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub trait IDirect3DDeviceManager9_Impl: Sized + windows_core::IUnknownImpl {
    fn ResetDevice(&self, pdevice: Option<&super::super::Graphics::Direct3D9::IDirect3DDevice9>, resettoken: u32) -> windows_core::Result<()>;
    fn OpenDeviceHandle(&self) -> windows_core::Result<super::super::Foundation::HANDLE>;
    fn CloseDeviceHandle(&self, hdevice: super::super::Foundation::HANDLE) -> windows_core::Result<()>;
    fn TestDevice(&self, hdevice: super::super::Foundation::HANDLE) -> windows_core::Result<()>;
    fn LockDevice(&self, hdevice: super::super::Foundation::HANDLE, ppdevice: *mut Option<super::super::Graphics::Direct3D9::IDirect3DDevice9>, fblock: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn UnlockDevice(&self, hdevice: super::super::Foundation::HANDLE, fsavestate: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn GetVideoService(&self, hdevice: super::super::Foundation::HANDLE, riid: *const windows_core::GUID, ppservice: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl windows_core::RuntimeName for IDirect3DDeviceManager9 {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl IDirect3DDeviceManager9_Vtbl {
    pub const fn new<Identity: IDirect3DDeviceManager9_Impl, const OFFSET: isize>() -> IDirect3DDeviceManager9_Vtbl {
        unsafe extern "system" fn ResetDevice<Identity: IDirect3DDeviceManager9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdevice: *mut core::ffi::c_void, resettoken: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3DDeviceManager9_Impl::ResetDevice(this, windows_core::from_raw_borrowed(&pdevice), core::mem::transmute_copy(&resettoken)).into()
        }
        unsafe extern "system" fn OpenDeviceHandle<Identity: IDirect3DDeviceManager9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, phdevice: *mut super::super::Foundation::HANDLE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IDirect3DDeviceManager9_Impl::OpenDeviceHandle(this) {
                Ok(ok__) => {
                    phdevice.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CloseDeviceHandle<Identity: IDirect3DDeviceManager9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hdevice: super::super::Foundation::HANDLE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3DDeviceManager9_Impl::CloseDeviceHandle(this, core::mem::transmute_copy(&hdevice)).into()
        }
        unsafe extern "system" fn TestDevice<Identity: IDirect3DDeviceManager9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hdevice: super::super::Foundation::HANDLE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3DDeviceManager9_Impl::TestDevice(this, core::mem::transmute_copy(&hdevice)).into()
        }
        unsafe extern "system" fn LockDevice<Identity: IDirect3DDeviceManager9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, ppdevice: *mut *mut core::ffi::c_void, fblock: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3DDeviceManager9_Impl::LockDevice(this, core::mem::transmute_copy(&hdevice), core::mem::transmute_copy(&ppdevice), core::mem::transmute_copy(&fblock)).into()
        }
        unsafe extern "system" fn UnlockDevice<Identity: IDirect3DDeviceManager9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, fsavestate: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3DDeviceManager9_Impl::UnlockDevice(this, core::mem::transmute_copy(&hdevice), core::mem::transmute_copy(&fsavestate)).into()
        }
        unsafe extern "system" fn GetVideoService<Identity: IDirect3DDeviceManager9_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, riid: *const windows_core::GUID, ppservice: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirect3DDeviceManager9_Impl::GetVideoService(this, core::mem::transmute_copy(&hdevice), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppservice)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            ResetDevice: ResetDevice::<Identity, OFFSET>,
            OpenDeviceHandle: OpenDeviceHandle::<Identity, OFFSET>,
            CloseDeviceHandle: CloseDeviceHandle::<Identity, OFFSET>,
            TestDevice: TestDevice::<Identity, OFFSET>,
            LockDevice: LockDevice::<Identity, OFFSET>,
            UnlockDevice: UnlockDevice::<Identity, OFFSET>,
            GetVideoService: GetVideoService::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDirect3DDeviceManager9 as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub trait IDirectXVideoAccelerationService_Impl: Sized + windows_core::IUnknownImpl {
    fn CreateSurface(&self, width: u32, height: u32, backbuffers: u32, format: super::super::Graphics::Direct3D9::D3DFORMAT, pool: super::super::Graphics::Direct3D9::D3DPOOL, usage: u32, dxvatype: &DXVA2_VideoRenderTargetType, ppsurface: *mut Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, psharedhandle: *mut super::super::Foundation::HANDLE) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl windows_core::RuntimeName for IDirectXVideoAccelerationService {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl IDirectXVideoAccelerationService_Vtbl {
    pub const fn new<Identity: IDirectXVideoAccelerationService_Impl, const OFFSET: isize>() -> IDirectXVideoAccelerationService_Vtbl {
        unsafe extern "system" fn CreateSurface<Identity: IDirectXVideoAccelerationService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, width: u32, height: u32, backbuffers: u32, format: super::super::Graphics::Direct3D9::D3DFORMAT, pool: super::super::Graphics::Direct3D9::D3DPOOL, usage: u32, dxvatype: u32, ppsurface: *mut *mut core::ffi::c_void, psharedhandle: *mut super::super::Foundation::HANDLE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirectXVideoAccelerationService_Impl::CreateSurface(this, core::mem::transmute_copy(&width), core::mem::transmute_copy(&height), core::mem::transmute_copy(&backbuffers), core::mem::transmute_copy(&format), core::mem::transmute_copy(&pool), core::mem::transmute_copy(&usage), core::mem::transmute(&dxvatype), core::mem::transmute_copy(&ppsurface), core::mem::transmute_copy(&psharedhandle)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), CreateSurface: CreateSurface::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDirectXVideoAccelerationService as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub trait IDirectXVideoDecoder_Impl: Sized + windows_core::IUnknownImpl {
    fn GetVideoDecoderService(&self) -> windows_core::Result<IDirectXVideoDecoderService>;
    fn GetCreationParameters(&self, pdeviceguid: *mut windows_core::GUID, pvideodesc: *mut DXVA2_VideoDesc, pconfig: *mut DXVA2_ConfigPictureDecode, pdecoderrendertargets: *mut *mut Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, pnumsurfaces: *mut u32) -> windows_core::Result<()>;
    fn GetBuffer(&self, buffertype: &DXVA2_BufferfType, ppbuffer: *mut *mut core::ffi::c_void, pbuffersize: *mut u32) -> windows_core::Result<()>;
    fn ReleaseBuffer(&self, buffertype: u32) -> windows_core::Result<()>;
    fn BeginFrame(&self, prendertarget: Option<&super::super::Graphics::Direct3D9::IDirect3DSurface9>, pvpvpdata: *const core::ffi::c_void) -> windows_core::Result<()>;
    fn EndFrame(&self, phandlecomplete: *mut super::super::Foundation::HANDLE) -> windows_core::Result<()>;
    fn Execute(&self, pexecuteparams: *const DXVA2_DecodeExecuteParams) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl windows_core::RuntimeName for IDirectXVideoDecoder {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl IDirectXVideoDecoder_Vtbl {
    pub const fn new<Identity: IDirectXVideoDecoder_Impl, const OFFSET: isize>() -> IDirectXVideoDecoder_Vtbl {
        unsafe extern "system" fn GetVideoDecoderService<Identity: IDirectXVideoDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppservice: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IDirectXVideoDecoder_Impl::GetVideoDecoderService(this) {
                Ok(ok__) => {
                    ppservice.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCreationParameters<Identity: IDirectXVideoDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdeviceguid: *mut windows_core::GUID, pvideodesc: *mut DXVA2_VideoDesc, pconfig: *mut DXVA2_ConfigPictureDecode, pdecoderrendertargets: *mut *mut Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, pnumsurfaces: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirectXVideoDecoder_Impl::GetCreationParameters(this, core::mem::transmute_copy(&pdeviceguid), core::mem::transmute_copy(&pvideodesc), core::mem::transmute_copy(&pconfig), core::mem::transmute_copy(&pdecoderrendertargets), core::mem::transmute_copy(&pnumsurfaces)).into()
        }
        unsafe extern "system" fn GetBuffer<Identity: IDirectXVideoDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, buffertype: u32, ppbuffer: *mut *mut core::ffi::c_void, pbuffersize: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirectXVideoDecoder_Impl::GetBuffer(this, core::mem::transmute(&buffertype), core::mem::transmute_copy(&ppbuffer), core::mem::transmute_copy(&pbuffersize)).into()
        }
        unsafe extern "system" fn ReleaseBuffer<Identity: IDirectXVideoDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, buffertype: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirectXVideoDecoder_Impl::ReleaseBuffer(this, core::mem::transmute_copy(&buffertype)).into()
        }
        unsafe extern "system" fn BeginFrame<Identity: IDirectXVideoDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, prendertarget: *mut core::ffi::c_void, pvpvpdata: *const core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirectXVideoDecoder_Impl::BeginFrame(this, windows_core::from_raw_borrowed(&prendertarget), core::mem::transmute_copy(&pvpvpdata)).into()
        }
        unsafe extern "system" fn EndFrame<Identity: IDirectXVideoDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, phandlecomplete: *mut super::super::Foundation::HANDLE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirectXVideoDecoder_Impl::EndFrame(this, core::mem::transmute_copy(&phandlecomplete)).into()
        }
        unsafe extern "system" fn Execute<Identity: IDirectXVideoDecoder_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pexecuteparams: *const DXVA2_DecodeExecuteParams) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirectXVideoDecoder_Impl::Execute(this, core::mem::transmute_copy(&pexecuteparams)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetVideoDecoderService: GetVideoDecoderService::<Identity, OFFSET>,
            GetCreationParameters: GetCreationParameters::<Identity, OFFSET>,
            GetBuffer: GetBuffer::<Identity, OFFSET>,
            ReleaseBuffer: ReleaseBuffer::<Identity, OFFSET>,
            BeginFrame: BeginFrame::<Identity, OFFSET>,
            EndFrame: EndFrame::<Identity, OFFSET>,
            Execute: Execute::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDirectXVideoDecoder as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub trait IDirectXVideoDecoderService_Impl: Sized + IDirectXVideoAccelerationService_Impl {
    fn GetDecoderDeviceGuids(&self, pcount: *mut u32, pguids: *mut *mut windows_core::GUID) -> windows_core::Result<()>;
    fn GetDecoderRenderTargets(&self, guid: *const windows_core::GUID, pcount: *mut u32, pformats: *mut *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> windows_core::Result<()>;
    fn GetDecoderConfigurations(&self, guid: *const windows_core::GUID, pvideodesc: *const DXVA2_VideoDesc, preserved: *const core::ffi::c_void, pcount: *mut u32, ppconfigs: *mut *mut DXVA2_ConfigPictureDecode) -> windows_core::Result<()>;
    fn CreateVideoDecoder(&self, guid: *const windows_core::GUID, pvideodesc: *const DXVA2_VideoDesc, pconfig: *const DXVA2_ConfigPictureDecode, ppdecoderrendertargets: *const Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, numrendertargets: u32) -> windows_core::Result<IDirectXVideoDecoder>;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl windows_core::RuntimeName for IDirectXVideoDecoderService {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl IDirectXVideoDecoderService_Vtbl {
    pub const fn new<Identity: IDirectXVideoDecoderService_Impl, const OFFSET: isize>() -> IDirectXVideoDecoderService_Vtbl {
        unsafe extern "system" fn GetDecoderDeviceGuids<Identity: IDirectXVideoDecoderService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcount: *mut u32, pguids: *mut *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirectXVideoDecoderService_Impl::GetDecoderDeviceGuids(this, core::mem::transmute_copy(&pcount), core::mem::transmute_copy(&pguids)).into()
        }
        unsafe extern "system" fn GetDecoderRenderTargets<Identity: IDirectXVideoDecoderService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guid: *const windows_core::GUID, pcount: *mut u32, pformats: *mut *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirectXVideoDecoderService_Impl::GetDecoderRenderTargets(this, core::mem::transmute_copy(&guid), core::mem::transmute_copy(&pcount), core::mem::transmute_copy(&pformats)).into()
        }
        unsafe extern "system" fn GetDecoderConfigurations<Identity: IDirectXVideoDecoderService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guid: *const windows_core::GUID, pvideodesc: *const DXVA2_VideoDesc, preserved: *const core::ffi::c_void, pcount: *mut u32, ppconfigs: *mut *mut DXVA2_ConfigPictureDecode) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirectXVideoDecoderService_Impl::GetDecoderConfigurations(this, core::mem::transmute_copy(&guid), core::mem::transmute_copy(&pvideodesc), core::mem::transmute_copy(&preserved), core::mem::transmute_copy(&pcount), core::mem::transmute_copy(&ppconfigs)).into()
        }
        unsafe extern "system" fn CreateVideoDecoder<Identity: IDirectXVideoDecoderService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guid: *const windows_core::GUID, pvideodesc: *const DXVA2_VideoDesc, pconfig: *const DXVA2_ConfigPictureDecode, ppdecoderrendertargets: *const *mut core::ffi::c_void, numrendertargets: u32, ppdecode: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IDirectXVideoDecoderService_Impl::CreateVideoDecoder(this, core::mem::transmute_copy(&guid), core::mem::transmute_copy(&pvideodesc), core::mem::transmute_copy(&pconfig), core::mem::transmute_copy(&ppdecoderrendertargets), core::mem::transmute_copy(&numrendertargets)) {
                Ok(ok__) => {
                    ppdecode.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IDirectXVideoAccelerationService_Vtbl::new::<Identity, OFFSET>(),
            GetDecoderDeviceGuids: GetDecoderDeviceGuids::<Identity, OFFSET>,
            GetDecoderRenderTargets: GetDecoderRenderTargets::<Identity, OFFSET>,
            GetDecoderConfigurations: GetDecoderConfigurations::<Identity, OFFSET>,
            CreateVideoDecoder: CreateVideoDecoder::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDirectXVideoDecoderService as windows_core::Interface>::IID || iid == &<IDirectXVideoAccelerationService as windows_core::Interface>::IID
    }
}
pub trait IDirectXVideoMemoryConfiguration_Impl: Sized + windows_core::IUnknownImpl {
    fn GetAvailableSurfaceTypeByIndex(&self, dwtypeindex: u32) -> windows_core::Result<DXVA2_SurfaceType>;
    fn SetSurfaceType(&self, dwtype: DXVA2_SurfaceType) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IDirectXVideoMemoryConfiguration {}
impl IDirectXVideoMemoryConfiguration_Vtbl {
    pub const fn new<Identity: IDirectXVideoMemoryConfiguration_Impl, const OFFSET: isize>() -> IDirectXVideoMemoryConfiguration_Vtbl {
        unsafe extern "system" fn GetAvailableSurfaceTypeByIndex<Identity: IDirectXVideoMemoryConfiguration_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwtypeindex: u32, pdwtype: *mut DXVA2_SurfaceType) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IDirectXVideoMemoryConfiguration_Impl::GetAvailableSurfaceTypeByIndex(this, core::mem::transmute_copy(&dwtypeindex)) {
                Ok(ok__) => {
                    pdwtype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSurfaceType<Identity: IDirectXVideoMemoryConfiguration_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwtype: DXVA2_SurfaceType) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirectXVideoMemoryConfiguration_Impl::SetSurfaceType(this, core::mem::transmute_copy(&dwtype)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetAvailableSurfaceTypeByIndex: GetAvailableSurfaceTypeByIndex::<Identity, OFFSET>,
            SetSurfaceType: SetSurfaceType::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDirectXVideoMemoryConfiguration as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub trait IDirectXVideoProcessor_Impl: Sized + windows_core::IUnknownImpl {
    fn GetVideoProcessorService(&self) -> windows_core::Result<IDirectXVideoProcessorService>;
    fn GetCreationParameters(&self, pdeviceguid: *mut windows_core::GUID, pvideodesc: *mut DXVA2_VideoDesc, prendertargetformat: *mut super::super::Graphics::Direct3D9::D3DFORMAT, pmaxnumsubstreams: *mut u32) -> windows_core::Result<()>;
    fn GetVideoProcessorCaps(&self, pcaps: *mut DXVA2_VideoProcessorCaps) -> windows_core::Result<()>;
    fn GetProcAmpRange(&self, procampcap: u32) -> windows_core::Result<DXVA2_ValueRange>;
    fn GetFilterPropertyRange(&self, filtersetting: u32) -> windows_core::Result<DXVA2_ValueRange>;
    fn VideoProcessBlt(&self, prendertarget: Option<&super::super::Graphics::Direct3D9::IDirect3DSurface9>, pbltparams: *const DXVA2_VideoProcessBltParams, psamples: *const DXVA2_VideoSample, numsamples: u32, phandlecomplete: *mut super::super::Foundation::HANDLE) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl windows_core::RuntimeName for IDirectXVideoProcessor {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl IDirectXVideoProcessor_Vtbl {
    pub const fn new<Identity: IDirectXVideoProcessor_Impl, const OFFSET: isize>() -> IDirectXVideoProcessor_Vtbl {
        unsafe extern "system" fn GetVideoProcessorService<Identity: IDirectXVideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppservice: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IDirectXVideoProcessor_Impl::GetVideoProcessorService(this) {
                Ok(ok__) => {
                    ppservice.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCreationParameters<Identity: IDirectXVideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdeviceguid: *mut windows_core::GUID, pvideodesc: *mut DXVA2_VideoDesc, prendertargetformat: *mut super::super::Graphics::Direct3D9::D3DFORMAT, pmaxnumsubstreams: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirectXVideoProcessor_Impl::GetCreationParameters(this, core::mem::transmute_copy(&pdeviceguid), core::mem::transmute_copy(&pvideodesc), core::mem::transmute_copy(&prendertargetformat), core::mem::transmute_copy(&pmaxnumsubstreams)).into()
        }
        unsafe extern "system" fn GetVideoProcessorCaps<Identity: IDirectXVideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcaps: *mut DXVA2_VideoProcessorCaps) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirectXVideoProcessor_Impl::GetVideoProcessorCaps(this, core::mem::transmute_copy(&pcaps)).into()
        }
        unsafe extern "system" fn GetProcAmpRange<Identity: IDirectXVideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, procampcap: u32, prange: *mut DXVA2_ValueRange) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IDirectXVideoProcessor_Impl::GetProcAmpRange(this, core::mem::transmute_copy(&procampcap)) {
                Ok(ok__) => {
                    prange.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFilterPropertyRange<Identity: IDirectXVideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, filtersetting: u32, prange: *mut DXVA2_ValueRange) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IDirectXVideoProcessor_Impl::GetFilterPropertyRange(this, core::mem::transmute_copy(&filtersetting)) {
                Ok(ok__) => {
                    prange.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VideoProcessBlt<Identity: IDirectXVideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, prendertarget: *mut core::ffi::c_void, pbltparams: *const DXVA2_VideoProcessBltParams, psamples: *const DXVA2_VideoSample, numsamples: u32, phandlecomplete: *mut super::super::Foundation::HANDLE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirectXVideoProcessor_Impl::VideoProcessBlt(this, windows_core::from_raw_borrowed(&prendertarget), core::mem::transmute_copy(&pbltparams), core::mem::transmute_copy(&psamples), core::mem::transmute_copy(&numsamples), core::mem::transmute_copy(&phandlecomplete)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetVideoProcessorService: GetVideoProcessorService::<Identity, OFFSET>,
            GetCreationParameters: GetCreationParameters::<Identity, OFFSET>,
            GetVideoProcessorCaps: GetVideoProcessorCaps::<Identity, OFFSET>,
            GetProcAmpRange: GetProcAmpRange::<Identity, OFFSET>,
            GetFilterPropertyRange: GetFilterPropertyRange::<Identity, OFFSET>,
            VideoProcessBlt: VideoProcessBlt::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDirectXVideoProcessor as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub trait IDirectXVideoProcessorService_Impl: Sized + IDirectXVideoAccelerationService_Impl {
    fn RegisterVideoProcessorSoftwareDevice(&self, pcallbacks: *const core::ffi::c_void) -> windows_core::Result<()>;
    fn GetVideoProcessorDeviceGuids(&self, pvideodesc: *const DXVA2_VideoDesc, pcount: *mut u32, pguids: *mut *mut windows_core::GUID) -> windows_core::Result<()>;
    fn GetVideoProcessorRenderTargets(&self, videoprocdeviceguid: *const windows_core::GUID, pvideodesc: *const DXVA2_VideoDesc, pcount: *mut u32, pformats: *mut *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> windows_core::Result<()>;
    fn GetVideoProcessorSubStreamFormats(&self, videoprocdeviceguid: *const windows_core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, pcount: *mut u32, pformats: *mut *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> windows_core::Result<()>;
    fn GetVideoProcessorCaps(&self, videoprocdeviceguid: *const windows_core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, pcaps: *mut DXVA2_VideoProcessorCaps) -> windows_core::Result<()>;
    fn GetProcAmpRange(&self, videoprocdeviceguid: *const windows_core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, procampcap: u32) -> windows_core::Result<DXVA2_ValueRange>;
    fn GetFilterPropertyRange(&self, videoprocdeviceguid: *const windows_core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, filtersetting: u32) -> windows_core::Result<DXVA2_ValueRange>;
    fn CreateVideoProcessor(&self, videoprocdeviceguid: *const windows_core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, maxnumsubstreams: u32) -> windows_core::Result<IDirectXVideoProcessor>;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl windows_core::RuntimeName for IDirectXVideoProcessorService {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl IDirectXVideoProcessorService_Vtbl {
    pub const fn new<Identity: IDirectXVideoProcessorService_Impl, const OFFSET: isize>() -> IDirectXVideoProcessorService_Vtbl {
        unsafe extern "system" fn RegisterVideoProcessorSoftwareDevice<Identity: IDirectXVideoProcessorService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcallbacks: *const core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirectXVideoProcessorService_Impl::RegisterVideoProcessorSoftwareDevice(this, core::mem::transmute_copy(&pcallbacks)).into()
        }
        unsafe extern "system" fn GetVideoProcessorDeviceGuids<Identity: IDirectXVideoProcessorService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvideodesc: *const DXVA2_VideoDesc, pcount: *mut u32, pguids: *mut *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirectXVideoProcessorService_Impl::GetVideoProcessorDeviceGuids(this, core::mem::transmute_copy(&pvideodesc), core::mem::transmute_copy(&pcount), core::mem::transmute_copy(&pguids)).into()
        }
        unsafe extern "system" fn GetVideoProcessorRenderTargets<Identity: IDirectXVideoProcessorService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, videoprocdeviceguid: *const windows_core::GUID, pvideodesc: *const DXVA2_VideoDesc, pcount: *mut u32, pformats: *mut *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirectXVideoProcessorService_Impl::GetVideoProcessorRenderTargets(this, core::mem::transmute_copy(&videoprocdeviceguid), core::mem::transmute_copy(&pvideodesc), core::mem::transmute_copy(&pcount), core::mem::transmute_copy(&pformats)).into()
        }
        unsafe extern "system" fn GetVideoProcessorSubStreamFormats<Identity: IDirectXVideoProcessorService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, videoprocdeviceguid: *const windows_core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, pcount: *mut u32, pformats: *mut *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirectXVideoProcessorService_Impl::GetVideoProcessorSubStreamFormats(this, core::mem::transmute_copy(&videoprocdeviceguid), core::mem::transmute_copy(&pvideodesc), core::mem::transmute_copy(&rendertargetformat), core::mem::transmute_copy(&pcount), core::mem::transmute_copy(&pformats)).into()
        }
        unsafe extern "system" fn GetVideoProcessorCaps<Identity: IDirectXVideoProcessorService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, videoprocdeviceguid: *const windows_core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, pcaps: *mut DXVA2_VideoProcessorCaps) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IDirectXVideoProcessorService_Impl::GetVideoProcessorCaps(this, core::mem::transmute_copy(&videoprocdeviceguid), core::mem::transmute_copy(&pvideodesc), core::mem::transmute_copy(&rendertargetformat), core::mem::transmute_copy(&pcaps)).into()
        }
        unsafe extern "system" fn GetProcAmpRange<Identity: IDirectXVideoProcessorService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, videoprocdeviceguid: *const windows_core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, procampcap: u32, prange: *mut DXVA2_ValueRange) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IDirectXVideoProcessorService_Impl::GetProcAmpRange(this, core::mem::transmute_copy(&videoprocdeviceguid), core::mem::transmute_copy(&pvideodesc), core::mem::transmute_copy(&rendertargetformat), core::mem::transmute_copy(&procampcap)) {
                Ok(ok__) => {
                    prange.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFilterPropertyRange<Identity: IDirectXVideoProcessorService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, videoprocdeviceguid: *const windows_core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, filtersetting: u32, prange: *mut DXVA2_ValueRange) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IDirectXVideoProcessorService_Impl::GetFilterPropertyRange(this, core::mem::transmute_copy(&videoprocdeviceguid), core::mem::transmute_copy(&pvideodesc), core::mem::transmute_copy(&rendertargetformat), core::mem::transmute_copy(&filtersetting)) {
                Ok(ok__) => {
                    prange.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateVideoProcessor<Identity: IDirectXVideoProcessorService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, videoprocdeviceguid: *const windows_core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, maxnumsubstreams: u32, ppvidprocess: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IDirectXVideoProcessorService_Impl::CreateVideoProcessor(this, core::mem::transmute_copy(&videoprocdeviceguid), core::mem::transmute_copy(&pvideodesc), core::mem::transmute_copy(&rendertargetformat), core::mem::transmute_copy(&maxnumsubstreams)) {
                Ok(ok__) => {
                    ppvidprocess.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IDirectXVideoAccelerationService_Vtbl::new::<Identity, OFFSET>(),
            RegisterVideoProcessorSoftwareDevice: RegisterVideoProcessorSoftwareDevice::<Identity, OFFSET>,
            GetVideoProcessorDeviceGuids: GetVideoProcessorDeviceGuids::<Identity, OFFSET>,
            GetVideoProcessorRenderTargets: GetVideoProcessorRenderTargets::<Identity, OFFSET>,
            GetVideoProcessorSubStreamFormats: GetVideoProcessorSubStreamFormats::<Identity, OFFSET>,
            GetVideoProcessorCaps: GetVideoProcessorCaps::<Identity, OFFSET>,
            GetProcAmpRange: GetProcAmpRange::<Identity, OFFSET>,
            GetFilterPropertyRange: GetFilterPropertyRange::<Identity, OFFSET>,
            CreateVideoProcessor: CreateVideoProcessor::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IDirectXVideoProcessorService as windows_core::Interface>::IID || iid == &<IDirectXVideoAccelerationService as windows_core::Interface>::IID
    }
}
pub trait IEVRFilterConfig_Impl: Sized + windows_core::IUnknownImpl {
    fn SetNumberOfStreams(&self, dwmaxstreams: u32) -> windows_core::Result<()>;
    fn GetNumberOfStreams(&self) -> windows_core::Result<u32>;
}
impl windows_core::RuntimeName for IEVRFilterConfig {}
impl IEVRFilterConfig_Vtbl {
    pub const fn new<Identity: IEVRFilterConfig_Impl, const OFFSET: isize>() -> IEVRFilterConfig_Vtbl {
        unsafe extern "system" fn SetNumberOfStreams<Identity: IEVRFilterConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwmaxstreams: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IEVRFilterConfig_Impl::SetNumberOfStreams(this, core::mem::transmute_copy(&dwmaxstreams)).into()
        }
        unsafe extern "system" fn GetNumberOfStreams<Identity: IEVRFilterConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwmaxstreams: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IEVRFilterConfig_Impl::GetNumberOfStreams(this) {
                Ok(ok__) => {
                    pdwmaxstreams.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetNumberOfStreams: SetNumberOfStreams::<Identity, OFFSET>,
            GetNumberOfStreams: GetNumberOfStreams::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IEVRFilterConfig as windows_core::Interface>::IID
    }
}
pub trait IEVRFilterConfigEx_Impl: Sized + IEVRFilterConfig_Impl {
    fn SetConfigPrefs(&self, dwconfigflags: u32) -> windows_core::Result<()>;
    fn GetConfigPrefs(&self) -> windows_core::Result<u32>;
}
impl windows_core::RuntimeName for IEVRFilterConfigEx {}
impl IEVRFilterConfigEx_Vtbl {
    pub const fn new<Identity: IEVRFilterConfigEx_Impl, const OFFSET: isize>() -> IEVRFilterConfigEx_Vtbl {
        unsafe extern "system" fn SetConfigPrefs<Identity: IEVRFilterConfigEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwconfigflags: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IEVRFilterConfigEx_Impl::SetConfigPrefs(this, core::mem::transmute_copy(&dwconfigflags)).into()
        }
        unsafe extern "system" fn GetConfigPrefs<Identity: IEVRFilterConfigEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwconfigflags: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IEVRFilterConfigEx_Impl::GetConfigPrefs(this) {
                Ok(ok__) => {
                    pdwconfigflags.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IEVRFilterConfig_Vtbl::new::<Identity, OFFSET>(),
            SetConfigPrefs: SetConfigPrefs::<Identity, OFFSET>,
            GetConfigPrefs: GetConfigPrefs::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IEVRFilterConfigEx as windows_core::Interface>::IID || iid == &<IEVRFilterConfig as windows_core::Interface>::IID
    }
}
pub trait IEVRTrustedVideoPlugin_Impl: Sized + windows_core::IUnknownImpl {
    fn IsInTrustedVideoMode(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn CanConstrict(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn SetConstriction(&self, dwkpix: u32) -> windows_core::Result<()>;
    fn DisableImageExport(&self, bdisable: super::super::Foundation::BOOL) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IEVRTrustedVideoPlugin {}
impl IEVRTrustedVideoPlugin_Vtbl {
    pub const fn new<Identity: IEVRTrustedVideoPlugin_Impl, const OFFSET: isize>() -> IEVRTrustedVideoPlugin_Vtbl {
        unsafe extern "system" fn IsInTrustedVideoMode<Identity: IEVRTrustedVideoPlugin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pyes: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IEVRTrustedVideoPlugin_Impl::IsInTrustedVideoMode(this) {
                Ok(ok__) => {
                    pyes.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanConstrict<Identity: IEVRTrustedVideoPlugin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pyes: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IEVRTrustedVideoPlugin_Impl::CanConstrict(this) {
                Ok(ok__) => {
                    pyes.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetConstriction<Identity: IEVRTrustedVideoPlugin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwkpix: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IEVRTrustedVideoPlugin_Impl::SetConstriction(this, core::mem::transmute_copy(&dwkpix)).into()
        }
        unsafe extern "system" fn DisableImageExport<Identity: IEVRTrustedVideoPlugin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bdisable: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IEVRTrustedVideoPlugin_Impl::DisableImageExport(this, core::mem::transmute_copy(&bdisable)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            IsInTrustedVideoMode: IsInTrustedVideoMode::<Identity, OFFSET>,
            CanConstrict: CanConstrict::<Identity, OFFSET>,
            SetConstriction: SetConstriction::<Identity, OFFSET>,
            DisableImageExport: DisableImageExport::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IEVRTrustedVideoPlugin as windows_core::Interface>::IID
    }
}
pub trait IEVRVideoStreamControl_Impl: Sized + windows_core::IUnknownImpl {
    fn SetStreamActiveState(&self, factive: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn GetStreamActiveState(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
}
impl windows_core::RuntimeName for IEVRVideoStreamControl {}
impl IEVRVideoStreamControl_Vtbl {
    pub const fn new<Identity: IEVRVideoStreamControl_Impl, const OFFSET: isize>() -> IEVRVideoStreamControl_Vtbl {
        unsafe extern "system" fn SetStreamActiveState<Identity: IEVRVideoStreamControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, factive: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IEVRVideoStreamControl_Impl::SetStreamActiveState(this, core::mem::transmute_copy(&factive)).into()
        }
        unsafe extern "system" fn GetStreamActiveState<Identity: IEVRVideoStreamControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpfactive: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IEVRVideoStreamControl_Impl::GetStreamActiveState(this) {
                Ok(ok__) => {
                    lpfactive.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetStreamActiveState: SetStreamActiveState::<Identity, OFFSET>,
            GetStreamActiveState: GetStreamActiveState::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IEVRVideoStreamControl as windows_core::Interface>::IID
    }
}
pub trait IFileClient_Impl: Sized + windows_core::IUnknownImpl {
    fn GetObjectDiskSize(&self, pqwsize: *mut u64) -> windows_core::Result<()>;
    fn Write(&self, pfio: Option<&IFileIo>) -> windows_core::Result<()>;
    fn Read(&self, pfio: Option<&IFileIo>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IFileClient {}
impl IFileClient_Vtbl {
    pub const fn new<Identity: IFileClient_Impl, const OFFSET: isize>() -> IFileClient_Vtbl {
        unsafe extern "system" fn GetObjectDiskSize<Identity: IFileClient_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pqwsize: *mut u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IFileClient_Impl::GetObjectDiskSize(this, core::mem::transmute_copy(&pqwsize)).into()
        }
        unsafe extern "system" fn Write<Identity: IFileClient_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfio: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IFileClient_Impl::Write(this, windows_core::from_raw_borrowed(&pfio)).into()
        }
        unsafe extern "system" fn Read<Identity: IFileClient_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfio: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IFileClient_Impl::Read(this, windows_core::from_raw_borrowed(&pfio)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetObjectDiskSize: GetObjectDiskSize::<Identity, OFFSET>,
            Write: Write::<Identity, OFFSET>,
            Read: Read::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IFileClient as windows_core::Interface>::IID
    }
}
pub trait IFileIo_Impl: Sized + windows_core::IUnknownImpl {
    fn Initialize(&self, eaccessmode: FILE_ACCESSMODE, eopenmode: FILE_OPENMODE, pwszfilename: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn GetLength(&self, pqwlength: *mut u64) -> windows_core::Result<()>;
    fn SetLength(&self, qwlength: u64) -> windows_core::Result<()>;
    fn GetCurrentPosition(&self, pqwposition: *mut u64) -> windows_core::Result<()>;
    fn SetCurrentPosition(&self, qwposition: u64) -> windows_core::Result<()>;
    fn IsEndOfStream(&self, pbendofstream: *mut super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn Read(&self, pbt: *mut u8, ul: u32, pulread: *mut u32) -> windows_core::Result<()>;
    fn Write(&self, pbt: *mut u8, ul: u32, pulwritten: *mut u32) -> windows_core::Result<()>;
    fn Seek(&self, eseekorigin: SEEK_ORIGIN, qwseekoffset: u64, dwseekflags: u32, pqwcurrentposition: *mut u64) -> windows_core::Result<()>;
    fn Close(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IFileIo {}
impl IFileIo_Vtbl {
    pub const fn new<Identity: IFileIo_Impl, const OFFSET: isize>() -> IFileIo_Vtbl {
        unsafe extern "system" fn Initialize<Identity: IFileIo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, eaccessmode: FILE_ACCESSMODE, eopenmode: FILE_OPENMODE, pwszfilename: windows_core::PCWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IFileIo_Impl::Initialize(this, core::mem::transmute_copy(&eaccessmode), core::mem::transmute_copy(&eopenmode), core::mem::transmute(&pwszfilename)).into()
        }
        unsafe extern "system" fn GetLength<Identity: IFileIo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pqwlength: *mut u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IFileIo_Impl::GetLength(this, core::mem::transmute_copy(&pqwlength)).into()
        }
        unsafe extern "system" fn SetLength<Identity: IFileIo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, qwlength: u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IFileIo_Impl::SetLength(this, core::mem::transmute_copy(&qwlength)).into()
        }
        unsafe extern "system" fn GetCurrentPosition<Identity: IFileIo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pqwposition: *mut u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IFileIo_Impl::GetCurrentPosition(this, core::mem::transmute_copy(&pqwposition)).into()
        }
        unsafe extern "system" fn SetCurrentPosition<Identity: IFileIo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, qwposition: u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IFileIo_Impl::SetCurrentPosition(this, core::mem::transmute_copy(&qwposition)).into()
        }
        unsafe extern "system" fn IsEndOfStream<Identity: IFileIo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbendofstream: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IFileIo_Impl::IsEndOfStream(this, core::mem::transmute_copy(&pbendofstream)).into()
        }
        unsafe extern "system" fn Read<Identity: IFileIo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbt: *mut u8, ul: u32, pulread: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IFileIo_Impl::Read(this, core::mem::transmute_copy(&pbt), core::mem::transmute_copy(&ul), core::mem::transmute_copy(&pulread)).into()
        }
        unsafe extern "system" fn Write<Identity: IFileIo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbt: *mut u8, ul: u32, pulwritten: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IFileIo_Impl::Write(this, core::mem::transmute_copy(&pbt), core::mem::transmute_copy(&ul), core::mem::transmute_copy(&pulwritten)).into()
        }
        unsafe extern "system" fn Seek<Identity: IFileIo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, eseekorigin: SEEK_ORIGIN, qwseekoffset: u64, dwseekflags: u32, pqwcurrentposition: *mut u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IFileIo_Impl::Seek(this, core::mem::transmute_copy(&eseekorigin), core::mem::transmute_copy(&qwseekoffset), core::mem::transmute_copy(&dwseekflags), core::mem::transmute_copy(&pqwcurrentposition)).into()
        }
        unsafe extern "system" fn Close<Identity: IFileIo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IFileIo_Impl::Close(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Initialize: Initialize::<Identity, OFFSET>,
            GetLength: GetLength::<Identity, OFFSET>,
            SetLength: SetLength::<Identity, OFFSET>,
            GetCurrentPosition: GetCurrentPosition::<Identity, OFFSET>,
            SetCurrentPosition: SetCurrentPosition::<Identity, OFFSET>,
            IsEndOfStream: IsEndOfStream::<Identity, OFFSET>,
            Read: Read::<Identity, OFFSET>,
            Write: Write::<Identity, OFFSET>,
            Seek: Seek::<Identity, OFFSET>,
            Close: Close::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IFileIo as windows_core::Interface>::IID
    }
}
pub trait IMF2DBuffer_Impl: Sized + windows_core::IUnknownImpl {
    fn Lock2D(&self, ppbscanline0: *mut *mut u8, plpitch: *mut i32) -> windows_core::Result<()>;
    fn Unlock2D(&self) -> windows_core::Result<()>;
    fn GetScanline0AndPitch(&self, pbscanline0: *mut *mut u8, plpitch: *mut i32) -> windows_core::Result<()>;
    fn IsContiguousFormat(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn GetContiguousLength(&self) -> windows_core::Result<u32>;
    fn ContiguousCopyTo(&self, pbdestbuffer: *mut u8, cbdestbuffer: u32) -> windows_core::Result<()>;
    fn ContiguousCopyFrom(&self, pbsrcbuffer: *const u8, cbsrcbuffer: u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMF2DBuffer {}
impl IMF2DBuffer_Vtbl {
    pub const fn new<Identity: IMF2DBuffer_Impl, const OFFSET: isize>() -> IMF2DBuffer_Vtbl {
        unsafe extern "system" fn Lock2D<Identity: IMF2DBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppbscanline0: *mut *mut u8, plpitch: *mut i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMF2DBuffer_Impl::Lock2D(this, core::mem::transmute_copy(&ppbscanline0), core::mem::transmute_copy(&plpitch)).into()
        }
        unsafe extern "system" fn Unlock2D<Identity: IMF2DBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMF2DBuffer_Impl::Unlock2D(this).into()
        }
        unsafe extern "system" fn GetScanline0AndPitch<Identity: IMF2DBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbscanline0: *mut *mut u8, plpitch: *mut i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMF2DBuffer_Impl::GetScanline0AndPitch(this, core::mem::transmute_copy(&pbscanline0), core::mem::transmute_copy(&plpitch)).into()
        }
        unsafe extern "system" fn IsContiguousFormat<Identity: IMF2DBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfiscontiguous: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMF2DBuffer_Impl::IsContiguousFormat(this) {
                Ok(ok__) => {
                    pfiscontiguous.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetContiguousLength<Identity: IMF2DBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcblength: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMF2DBuffer_Impl::GetContiguousLength(this) {
                Ok(ok__) => {
                    pcblength.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContiguousCopyTo<Identity: IMF2DBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbdestbuffer: *mut u8, cbdestbuffer: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMF2DBuffer_Impl::ContiguousCopyTo(this, core::mem::transmute_copy(&pbdestbuffer), core::mem::transmute_copy(&cbdestbuffer)).into()
        }
        unsafe extern "system" fn ContiguousCopyFrom<Identity: IMF2DBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbsrcbuffer: *const u8, cbsrcbuffer: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMF2DBuffer_Impl::ContiguousCopyFrom(this, core::mem::transmute_copy(&pbsrcbuffer), core::mem::transmute_copy(&cbsrcbuffer)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Lock2D: Lock2D::<Identity, OFFSET>,
            Unlock2D: Unlock2D::<Identity, OFFSET>,
            GetScanline0AndPitch: GetScanline0AndPitch::<Identity, OFFSET>,
            IsContiguousFormat: IsContiguousFormat::<Identity, OFFSET>,
            GetContiguousLength: GetContiguousLength::<Identity, OFFSET>,
            ContiguousCopyTo: ContiguousCopyTo::<Identity, OFFSET>,
            ContiguousCopyFrom: ContiguousCopyFrom::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMF2DBuffer as windows_core::Interface>::IID
    }
}
pub trait IMF2DBuffer2_Impl: Sized + IMF2DBuffer_Impl {
    fn Lock2DSize(&self, lockflags: MF2DBuffer_LockFlags, ppbscanline0: *mut *mut u8, plpitch: *mut i32, ppbbufferstart: *mut *mut u8, pcbbufferlength: *mut u32) -> windows_core::Result<()>;
    fn Copy2DTo(&self, pdestbuffer: Option<&IMF2DBuffer2>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMF2DBuffer2 {}
impl IMF2DBuffer2_Vtbl {
    pub const fn new<Identity: IMF2DBuffer2_Impl, const OFFSET: isize>() -> IMF2DBuffer2_Vtbl {
        unsafe extern "system" fn Lock2DSize<Identity: IMF2DBuffer2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lockflags: MF2DBuffer_LockFlags, ppbscanline0: *mut *mut u8, plpitch: *mut i32, ppbbufferstart: *mut *mut u8, pcbbufferlength: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMF2DBuffer2_Impl::Lock2DSize(this, core::mem::transmute_copy(&lockflags), core::mem::transmute_copy(&ppbscanline0), core::mem::transmute_copy(&plpitch), core::mem::transmute_copy(&ppbbufferstart), core::mem::transmute_copy(&pcbbufferlength)).into()
        }
        unsafe extern "system" fn Copy2DTo<Identity: IMF2DBuffer2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdestbuffer: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMF2DBuffer2_Impl::Copy2DTo(this, windows_core::from_raw_borrowed(&pdestbuffer)).into()
        }
        Self { base__: IMF2DBuffer_Vtbl::new::<Identity, OFFSET>(), Lock2DSize: Lock2DSize::<Identity, OFFSET>, Copy2DTo: Copy2DTo::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMF2DBuffer2 as windows_core::Interface>::IID || iid == &<IMF2DBuffer as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub trait IMFASFContentInfo_Impl: Sized + windows_core::IUnknownImpl {
    fn GetHeaderSize(&self, pistartofcontent: Option<&IMFMediaBuffer>) -> windows_core::Result<u64>;
    fn ParseHeader(&self, piheaderbuffer: Option<&IMFMediaBuffer>, cboffsetwithinheader: u64) -> windows_core::Result<()>;
    fn GenerateHeader(&self, piheader: Option<&IMFMediaBuffer>) -> windows_core::Result<u32>;
    fn GetProfile(&self) -> windows_core::Result<IMFASFProfile>;
    fn SetProfile(&self, piprofile: Option<&IMFASFProfile>) -> windows_core::Result<()>;
    fn GeneratePresentationDescriptor(&self) -> windows_core::Result<IMFPresentationDescriptor>;
    fn GetEncodingConfigurationPropertyStore(&self, wstreamnumber: u16) -> windows_core::Result<super::super::UI::Shell::PropertiesSystem::IPropertyStore>;
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl windows_core::RuntimeName for IMFASFContentInfo {}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl IMFASFContentInfo_Vtbl {
    pub const fn new<Identity: IMFASFContentInfo_Impl, const OFFSET: isize>() -> IMFASFContentInfo_Vtbl {
        unsafe extern "system" fn GetHeaderSize<Identity: IMFASFContentInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pistartofcontent: *mut core::ffi::c_void, cbheadersize: *mut u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFContentInfo_Impl::GetHeaderSize(this, windows_core::from_raw_borrowed(&pistartofcontent)) {
                Ok(ok__) => {
                    cbheadersize.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ParseHeader<Identity: IMFASFContentInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, piheaderbuffer: *mut core::ffi::c_void, cboffsetwithinheader: u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFContentInfo_Impl::ParseHeader(this, windows_core::from_raw_borrowed(&piheaderbuffer), core::mem::transmute_copy(&cboffsetwithinheader)).into()
        }
        unsafe extern "system" fn GenerateHeader<Identity: IMFASFContentInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, piheader: *mut core::ffi::c_void, pcbheader: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFContentInfo_Impl::GenerateHeader(this, windows_core::from_raw_borrowed(&piheader)) {
                Ok(ok__) => {
                    pcbheader.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProfile<Identity: IMFASFContentInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppiprofile: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFContentInfo_Impl::GetProfile(this) {
                Ok(ok__) => {
                    ppiprofile.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProfile<Identity: IMFASFContentInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, piprofile: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFContentInfo_Impl::SetProfile(this, windows_core::from_raw_borrowed(&piprofile)).into()
        }
        unsafe extern "system" fn GeneratePresentationDescriptor<Identity: IMFASFContentInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppipresentationdescriptor: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFContentInfo_Impl::GeneratePresentationDescriptor(this) {
                Ok(ok__) => {
                    ppipresentationdescriptor.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEncodingConfigurationPropertyStore<Identity: IMFASFContentInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, wstreamnumber: u16, ppistore: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFContentInfo_Impl::GetEncodingConfigurationPropertyStore(this, core::mem::transmute_copy(&wstreamnumber)) {
                Ok(ok__) => {
                    ppistore.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetHeaderSize: GetHeaderSize::<Identity, OFFSET>,
            ParseHeader: ParseHeader::<Identity, OFFSET>,
            GenerateHeader: GenerateHeader::<Identity, OFFSET>,
            GetProfile: GetProfile::<Identity, OFFSET>,
            SetProfile: SetProfile::<Identity, OFFSET>,
            GeneratePresentationDescriptor: GeneratePresentationDescriptor::<Identity, OFFSET>,
            GetEncodingConfigurationPropertyStore: GetEncodingConfigurationPropertyStore::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFASFContentInfo as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFASFIndexer_Impl: Sized + windows_core::IUnknownImpl {
    fn SetFlags(&self, dwflags: u32) -> windows_core::Result<()>;
    fn GetFlags(&self) -> windows_core::Result<u32>;
    fn Initialize(&self, picontentinfo: Option<&IMFASFContentInfo>) -> windows_core::Result<()>;
    fn GetIndexPosition(&self, picontentinfo: Option<&IMFASFContentInfo>) -> windows_core::Result<u64>;
    fn SetIndexByteStreams(&self, ppibytestreams: *const Option<IMFByteStream>, cbytestreams: u32) -> windows_core::Result<()>;
    fn GetIndexByteStreamCount(&self) -> windows_core::Result<u32>;
    fn GetIndexStatus(&self, pindexidentifier: *const ASF_INDEX_IDENTIFIER, pfisindexed: *mut super::super::Foundation::BOOL, pbindexdescriptor: *mut u8, pcbindexdescriptor: *mut u32) -> windows_core::Result<()>;
    fn SetIndexStatus(&self, pbindexdescriptor: *const u8, cbindexdescriptor: u32, fgenerateindex: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn GetSeekPositionForValue(&self, pvarvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pindexidentifier: *const ASF_INDEX_IDENTIFIER, pcboffsetwithindata: *mut u64, phnsapproxtime: *mut i64, pdwpayloadnumberofstreamwithinpacket: *mut u32) -> windows_core::Result<()>;
    fn GenerateIndexEntries(&self, piasfpacketsample: Option<&IMFSample>) -> windows_core::Result<()>;
    fn CommitIndex(&self, picontentinfo: Option<&IMFASFContentInfo>) -> windows_core::Result<()>;
    fn GetIndexWriteSpace(&self) -> windows_core::Result<u64>;
    fn GetCompletedIndex(&self, piindexbuffer: Option<&IMFMediaBuffer>, cboffsetwithinindex: u64) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFASFIndexer {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFASFIndexer_Vtbl {
    pub const fn new<Identity: IMFASFIndexer_Impl, const OFFSET: isize>() -> IMFASFIndexer_Vtbl {
        unsafe extern "system" fn SetFlags<Identity: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFIndexer_Impl::SetFlags(this, core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn GetFlags<Identity: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwflags: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFIndexer_Impl::GetFlags(this) {
                Ok(ok__) => {
                    pdwflags.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Initialize<Identity: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, picontentinfo: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFIndexer_Impl::Initialize(this, windows_core::from_raw_borrowed(&picontentinfo)).into()
        }
        unsafe extern "system" fn GetIndexPosition<Identity: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, picontentinfo: *mut core::ffi::c_void, pcbindexoffset: *mut u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFIndexer_Impl::GetIndexPosition(this, windows_core::from_raw_borrowed(&picontentinfo)) {
                Ok(ok__) => {
                    pcbindexoffset.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIndexByteStreams<Identity: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppibytestreams: *const *mut core::ffi::c_void, cbytestreams: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFIndexer_Impl::SetIndexByteStreams(this, core::mem::transmute_copy(&ppibytestreams), core::mem::transmute_copy(&cbytestreams)).into()
        }
        unsafe extern "system" fn GetIndexByteStreamCount<Identity: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcbytestreams: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFIndexer_Impl::GetIndexByteStreamCount(this) {
                Ok(ok__) => {
                    pcbytestreams.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIndexStatus<Identity: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pindexidentifier: *const ASF_INDEX_IDENTIFIER, pfisindexed: *mut super::super::Foundation::BOOL, pbindexdescriptor: *mut u8, pcbindexdescriptor: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFIndexer_Impl::GetIndexStatus(this, core::mem::transmute_copy(&pindexidentifier), core::mem::transmute_copy(&pfisindexed), core::mem::transmute_copy(&pbindexdescriptor), core::mem::transmute_copy(&pcbindexdescriptor)).into()
        }
        unsafe extern "system" fn SetIndexStatus<Identity: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbindexdescriptor: *const u8, cbindexdescriptor: u32, fgenerateindex: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFIndexer_Impl::SetIndexStatus(this, core::mem::transmute_copy(&pbindexdescriptor), core::mem::transmute_copy(&cbindexdescriptor), core::mem::transmute_copy(&fgenerateindex)).into()
        }
        unsafe extern "system" fn GetSeekPositionForValue<Identity: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvarvalue: *const core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>, pindexidentifier: *const ASF_INDEX_IDENTIFIER, pcboffsetwithindata: *mut u64, phnsapproxtime: *mut i64, pdwpayloadnumberofstreamwithinpacket: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFIndexer_Impl::GetSeekPositionForValue(this, core::mem::transmute_copy(&pvarvalue), core::mem::transmute_copy(&pindexidentifier), core::mem::transmute_copy(&pcboffsetwithindata), core::mem::transmute_copy(&phnsapproxtime), core::mem::transmute_copy(&pdwpayloadnumberofstreamwithinpacket)).into()
        }
        unsafe extern "system" fn GenerateIndexEntries<Identity: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, piasfpacketsample: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFIndexer_Impl::GenerateIndexEntries(this, windows_core::from_raw_borrowed(&piasfpacketsample)).into()
        }
        unsafe extern "system" fn CommitIndex<Identity: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, picontentinfo: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFIndexer_Impl::CommitIndex(this, windows_core::from_raw_borrowed(&picontentinfo)).into()
        }
        unsafe extern "system" fn GetIndexWriteSpace<Identity: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcbindexwritespace: *mut u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFIndexer_Impl::GetIndexWriteSpace(this) {
                Ok(ok__) => {
                    pcbindexwritespace.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCompletedIndex<Identity: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, piindexbuffer: *mut core::ffi::c_void, cboffsetwithinindex: u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFIndexer_Impl::GetCompletedIndex(this, windows_core::from_raw_borrowed(&piindexbuffer), core::mem::transmute_copy(&cboffsetwithinindex)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetFlags: SetFlags::<Identity, OFFSET>,
            GetFlags: GetFlags::<Identity, OFFSET>,
            Initialize: Initialize::<Identity, OFFSET>,
            GetIndexPosition: GetIndexPosition::<Identity, OFFSET>,
            SetIndexByteStreams: SetIndexByteStreams::<Identity, OFFSET>,
            GetIndexByteStreamCount: GetIndexByteStreamCount::<Identity, OFFSET>,
            GetIndexStatus: GetIndexStatus::<Identity, OFFSET>,
            SetIndexStatus: SetIndexStatus::<Identity, OFFSET>,
            GetSeekPositionForValue: GetSeekPositionForValue::<Identity, OFFSET>,
            GenerateIndexEntries: GenerateIndexEntries::<Identity, OFFSET>,
            CommitIndex: CommitIndex::<Identity, OFFSET>,
            GetIndexWriteSpace: GetIndexWriteSpace::<Identity, OFFSET>,
            GetCompletedIndex: GetCompletedIndex::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFASFIndexer as windows_core::Interface>::IID
    }
}
pub trait IMFASFMultiplexer_Impl: Sized + windows_core::IUnknownImpl {
    fn Initialize(&self, picontentinfo: Option<&IMFASFContentInfo>) -> windows_core::Result<()>;
    fn SetFlags(&self, dwflags: u32) -> windows_core::Result<()>;
    fn GetFlags(&self) -> windows_core::Result<u32>;
    fn ProcessSample(&self, wstreamnumber: u16, pisample: Option<&IMFSample>, hnstimestampadjust: i64) -> windows_core::Result<()>;
    fn GetNextPacket(&self, pdwstatusflags: *mut u32, ppipacket: *mut Option<IMFSample>) -> windows_core::Result<()>;
    fn Flush(&self) -> windows_core::Result<()>;
    fn End(&self, picontentinfo: Option<&IMFASFContentInfo>) -> windows_core::Result<()>;
    fn GetStatistics(&self, wstreamnumber: u16) -> windows_core::Result<ASF_MUX_STATISTICS>;
    fn SetSyncTolerance(&self, mssynctolerance: u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFASFMultiplexer {}
impl IMFASFMultiplexer_Vtbl {
    pub const fn new<Identity: IMFASFMultiplexer_Impl, const OFFSET: isize>() -> IMFASFMultiplexer_Vtbl {
        unsafe extern "system" fn Initialize<Identity: IMFASFMultiplexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, picontentinfo: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFMultiplexer_Impl::Initialize(this, windows_core::from_raw_borrowed(&picontentinfo)).into()
        }
        unsafe extern "system" fn SetFlags<Identity: IMFASFMultiplexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFMultiplexer_Impl::SetFlags(this, core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn GetFlags<Identity: IMFASFMultiplexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwflags: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFMultiplexer_Impl::GetFlags(this) {
                Ok(ok__) => {
                    pdwflags.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProcessSample<Identity: IMFASFMultiplexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, wstreamnumber: u16, pisample: *mut core::ffi::c_void, hnstimestampadjust: i64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFMultiplexer_Impl::ProcessSample(this, core::mem::transmute_copy(&wstreamnumber), windows_core::from_raw_borrowed(&pisample), core::mem::transmute_copy(&hnstimestampadjust)).into()
        }
        unsafe extern "system" fn GetNextPacket<Identity: IMFASFMultiplexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwstatusflags: *mut u32, ppipacket: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFMultiplexer_Impl::GetNextPacket(this, core::mem::transmute_copy(&pdwstatusflags), core::mem::transmute_copy(&ppipacket)).into()
        }
        unsafe extern "system" fn Flush<Identity: IMFASFMultiplexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFMultiplexer_Impl::Flush(this).into()
        }
        unsafe extern "system" fn End<Identity: IMFASFMultiplexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, picontentinfo: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFMultiplexer_Impl::End(this, windows_core::from_raw_borrowed(&picontentinfo)).into()
        }
        unsafe extern "system" fn GetStatistics<Identity: IMFASFMultiplexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, wstreamnumber: u16, pmuxstats: *mut ASF_MUX_STATISTICS) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFMultiplexer_Impl::GetStatistics(this, core::mem::transmute_copy(&wstreamnumber)) {
                Ok(ok__) => {
                    pmuxstats.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSyncTolerance<Identity: IMFASFMultiplexer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, mssynctolerance: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFMultiplexer_Impl::SetSyncTolerance(this, core::mem::transmute_copy(&mssynctolerance)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Initialize: Initialize::<Identity, OFFSET>,
            SetFlags: SetFlags::<Identity, OFFSET>,
            GetFlags: GetFlags::<Identity, OFFSET>,
            ProcessSample: ProcessSample::<Identity, OFFSET>,
            GetNextPacket: GetNextPacket::<Identity, OFFSET>,
            Flush: Flush::<Identity, OFFSET>,
            End: End::<Identity, OFFSET>,
            GetStatistics: GetStatistics::<Identity, OFFSET>,
            SetSyncTolerance: SetSyncTolerance::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFASFMultiplexer as windows_core::Interface>::IID
    }
}
pub trait IMFASFMutualExclusion_Impl: Sized + windows_core::IUnknownImpl {
    fn GetType(&self) -> windows_core::Result<windows_core::GUID>;
    fn SetType(&self, guidtype: *const windows_core::GUID) -> windows_core::Result<()>;
    fn GetRecordCount(&self) -> windows_core::Result<u32>;
    fn GetStreamsForRecord(&self, dwrecordnumber: u32, pwstreamnumarray: *mut u16, pcstreams: *mut u32) -> windows_core::Result<()>;
    fn AddStreamForRecord(&self, dwrecordnumber: u32, wstreamnumber: u16) -> windows_core::Result<()>;
    fn RemoveStreamFromRecord(&self, dwrecordnumber: u32, wstreamnumber: u16) -> windows_core::Result<()>;
    fn RemoveRecord(&self, dwrecordnumber: u32) -> windows_core::Result<()>;
    fn AddRecord(&self) -> windows_core::Result<u32>;
    fn Clone(&self) -> windows_core::Result<IMFASFMutualExclusion>;
}
impl windows_core::RuntimeName for IMFASFMutualExclusion {}
impl IMFASFMutualExclusion_Vtbl {
    pub const fn new<Identity: IMFASFMutualExclusion_Impl, const OFFSET: isize>() -> IMFASFMutualExclusion_Vtbl {
        unsafe extern "system" fn GetType<Identity: IMFASFMutualExclusion_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguidtype: *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFMutualExclusion_Impl::GetType(this) {
                Ok(ok__) => {
                    pguidtype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetType<Identity: IMFASFMutualExclusion_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidtype: *const windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFMutualExclusion_Impl::SetType(this, core::mem::transmute_copy(&guidtype)).into()
        }
        unsafe extern "system" fn GetRecordCount<Identity: IMFASFMutualExclusion_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwrecordcount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFMutualExclusion_Impl::GetRecordCount(this) {
                Ok(ok__) => {
                    pdwrecordcount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamsForRecord<Identity: IMFASFMutualExclusion_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwrecordnumber: u32, pwstreamnumarray: *mut u16, pcstreams: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFMutualExclusion_Impl::GetStreamsForRecord(this, core::mem::transmute_copy(&dwrecordnumber), core::mem::transmute_copy(&pwstreamnumarray), core::mem::transmute_copy(&pcstreams)).into()
        }
        unsafe extern "system" fn AddStreamForRecord<Identity: IMFASFMutualExclusion_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwrecordnumber: u32, wstreamnumber: u16) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFMutualExclusion_Impl::AddStreamForRecord(this, core::mem::transmute_copy(&dwrecordnumber), core::mem::transmute_copy(&wstreamnumber)).into()
        }
        unsafe extern "system" fn RemoveStreamFromRecord<Identity: IMFASFMutualExclusion_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwrecordnumber: u32, wstreamnumber: u16) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFMutualExclusion_Impl::RemoveStreamFromRecord(this, core::mem::transmute_copy(&dwrecordnumber), core::mem::transmute_copy(&wstreamnumber)).into()
        }
        unsafe extern "system" fn RemoveRecord<Identity: IMFASFMutualExclusion_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwrecordnumber: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFMutualExclusion_Impl::RemoveRecord(this, core::mem::transmute_copy(&dwrecordnumber)).into()
        }
        unsafe extern "system" fn AddRecord<Identity: IMFASFMutualExclusion_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwrecordnumber: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFMutualExclusion_Impl::AddRecord(this) {
                Ok(ok__) => {
                    pdwrecordnumber.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Identity: IMFASFMutualExclusion_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppimutex: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFMutualExclusion_Impl::Clone(this) {
                Ok(ok__) => {
                    ppimutex.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetType: GetType::<Identity, OFFSET>,
            SetType: SetType::<Identity, OFFSET>,
            GetRecordCount: GetRecordCount::<Identity, OFFSET>,
            GetStreamsForRecord: GetStreamsForRecord::<Identity, OFFSET>,
            AddStreamForRecord: AddStreamForRecord::<Identity, OFFSET>,
            RemoveStreamFromRecord: RemoveStreamFromRecord::<Identity, OFFSET>,
            RemoveRecord: RemoveRecord::<Identity, OFFSET>,
            AddRecord: AddRecord::<Identity, OFFSET>,
            Clone: Clone::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFASFMutualExclusion as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFASFProfile_Impl: Sized + IMFAttributes_Impl {
    fn GetStreamCount(&self) -> windows_core::Result<u32>;
    fn GetStream(&self, dwstreamindex: u32, pwstreamnumber: *mut u16, ppistream: *mut Option<IMFASFStreamConfig>) -> windows_core::Result<()>;
    fn GetStreamByNumber(&self, wstreamnumber: u16) -> windows_core::Result<IMFASFStreamConfig>;
    fn SetStream(&self, pistream: Option<&IMFASFStreamConfig>) -> windows_core::Result<()>;
    fn RemoveStream(&self, wstreamnumber: u16) -> windows_core::Result<()>;
    fn CreateStream(&self, pimediatype: Option<&IMFMediaType>) -> windows_core::Result<IMFASFStreamConfig>;
    fn GetMutualExclusionCount(&self) -> windows_core::Result<u32>;
    fn GetMutualExclusion(&self, dwmutexindex: u32) -> windows_core::Result<IMFASFMutualExclusion>;
    fn AddMutualExclusion(&self, pimutex: Option<&IMFASFMutualExclusion>) -> windows_core::Result<()>;
    fn RemoveMutualExclusion(&self, dwmutexindex: u32) -> windows_core::Result<()>;
    fn CreateMutualExclusion(&self) -> windows_core::Result<IMFASFMutualExclusion>;
    fn GetStreamPrioritization(&self) -> windows_core::Result<IMFASFStreamPrioritization>;
    fn AddStreamPrioritization(&self, pistreamprioritization: Option<&IMFASFStreamPrioritization>) -> windows_core::Result<()>;
    fn RemoveStreamPrioritization(&self) -> windows_core::Result<()>;
    fn CreateStreamPrioritization(&self) -> windows_core::Result<IMFASFStreamPrioritization>;
    fn Clone(&self) -> windows_core::Result<IMFASFProfile>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFASFProfile {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFASFProfile_Vtbl {
    pub const fn new<Identity: IMFASFProfile_Impl, const OFFSET: isize>() -> IMFASFProfile_Vtbl {
        unsafe extern "system" fn GetStreamCount<Identity: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcstreams: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFProfile_Impl::GetStreamCount(this) {
                Ok(ok__) => {
                    pcstreams.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStream<Identity: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, pwstreamnumber: *mut u16, ppistream: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFProfile_Impl::GetStream(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&pwstreamnumber), core::mem::transmute_copy(&ppistream)).into()
        }
        unsafe extern "system" fn GetStreamByNumber<Identity: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, wstreamnumber: u16, ppistream: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFProfile_Impl::GetStreamByNumber(this, core::mem::transmute_copy(&wstreamnumber)) {
                Ok(ok__) => {
                    ppistream.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStream<Identity: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pistream: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFProfile_Impl::SetStream(this, windows_core::from_raw_borrowed(&pistream)).into()
        }
        unsafe extern "system" fn RemoveStream<Identity: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, wstreamnumber: u16) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFProfile_Impl::RemoveStream(this, core::mem::transmute_copy(&wstreamnumber)).into()
        }
        unsafe extern "system" fn CreateStream<Identity: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pimediatype: *mut core::ffi::c_void, ppistream: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFProfile_Impl::CreateStream(this, windows_core::from_raw_borrowed(&pimediatype)) {
                Ok(ok__) => {
                    ppistream.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMutualExclusionCount<Identity: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcmutexs: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFProfile_Impl::GetMutualExclusionCount(this) {
                Ok(ok__) => {
                    pcmutexs.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMutualExclusion<Identity: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwmutexindex: u32, ppimutex: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFProfile_Impl::GetMutualExclusion(this, core::mem::transmute_copy(&dwmutexindex)) {
                Ok(ok__) => {
                    ppimutex.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddMutualExclusion<Identity: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pimutex: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFProfile_Impl::AddMutualExclusion(this, windows_core::from_raw_borrowed(&pimutex)).into()
        }
        unsafe extern "system" fn RemoveMutualExclusion<Identity: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwmutexindex: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFProfile_Impl::RemoveMutualExclusion(this, core::mem::transmute_copy(&dwmutexindex)).into()
        }
        unsafe extern "system" fn CreateMutualExclusion<Identity: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppimutex: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFProfile_Impl::CreateMutualExclusion(this) {
                Ok(ok__) => {
                    ppimutex.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamPrioritization<Identity: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppistreamprioritization: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFProfile_Impl::GetStreamPrioritization(this) {
                Ok(ok__) => {
                    ppistreamprioritization.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddStreamPrioritization<Identity: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pistreamprioritization: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFProfile_Impl::AddStreamPrioritization(this, windows_core::from_raw_borrowed(&pistreamprioritization)).into()
        }
        unsafe extern "system" fn RemoveStreamPrioritization<Identity: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFProfile_Impl::RemoveStreamPrioritization(this).into()
        }
        unsafe extern "system" fn CreateStreamPrioritization<Identity: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppistreamprioritization: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFProfile_Impl::CreateStreamPrioritization(this) {
                Ok(ok__) => {
                    ppistreamprioritization.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Identity: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppiprofile: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFProfile_Impl::Clone(this) {
                Ok(ok__) => {
                    ppiprofile.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IMFAttributes_Vtbl::new::<Identity, OFFSET>(),
            GetStreamCount: GetStreamCount::<Identity, OFFSET>,
            GetStream: GetStream::<Identity, OFFSET>,
            GetStreamByNumber: GetStreamByNumber::<Identity, OFFSET>,
            SetStream: SetStream::<Identity, OFFSET>,
            RemoveStream: RemoveStream::<Identity, OFFSET>,
            CreateStream: CreateStream::<Identity, OFFSET>,
            GetMutualExclusionCount: GetMutualExclusionCount::<Identity, OFFSET>,
            GetMutualExclusion: GetMutualExclusion::<Identity, OFFSET>,
            AddMutualExclusion: AddMutualExclusion::<Identity, OFFSET>,
            RemoveMutualExclusion: RemoveMutualExclusion::<Identity, OFFSET>,
            CreateMutualExclusion: CreateMutualExclusion::<Identity, OFFSET>,
            GetStreamPrioritization: GetStreamPrioritization::<Identity, OFFSET>,
            AddStreamPrioritization: AddStreamPrioritization::<Identity, OFFSET>,
            RemoveStreamPrioritization: RemoveStreamPrioritization::<Identity, OFFSET>,
            CreateStreamPrioritization: CreateStreamPrioritization::<Identity, OFFSET>,
            Clone: Clone::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFASFProfile as windows_core::Interface>::IID || iid == &<IMFAttributes as windows_core::Interface>::IID
    }
}
pub trait IMFASFSplitter_Impl: Sized + windows_core::IUnknownImpl {
    fn Initialize(&self, picontentinfo: Option<&IMFASFContentInfo>) -> windows_core::Result<()>;
    fn SetFlags(&self, dwflags: u32) -> windows_core::Result<()>;
    fn GetFlags(&self) -> windows_core::Result<u32>;
    fn SelectStreams(&self, pwstreamnumbers: *const u16, wnumstreams: u16) -> windows_core::Result<()>;
    fn GetSelectedStreams(&self, pwstreamnumbers: *mut u16, pwnumstreams: *mut u16) -> windows_core::Result<()>;
    fn ParseData(&self, pibuffer: Option<&IMFMediaBuffer>, cbbufferoffset: u32, cblength: u32) -> windows_core::Result<()>;
    fn GetNextSample(&self, pdwstatusflags: *mut ASF_STATUSFLAGS, pwstreamnumber: *mut u16, ppisample: *mut Option<IMFSample>) -> windows_core::Result<()>;
    fn Flush(&self) -> windows_core::Result<()>;
    fn GetLastSendTime(&self) -> windows_core::Result<u32>;
}
impl windows_core::RuntimeName for IMFASFSplitter {}
impl IMFASFSplitter_Vtbl {
    pub const fn new<Identity: IMFASFSplitter_Impl, const OFFSET: isize>() -> IMFASFSplitter_Vtbl {
        unsafe extern "system" fn Initialize<Identity: IMFASFSplitter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, picontentinfo: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFSplitter_Impl::Initialize(this, windows_core::from_raw_borrowed(&picontentinfo)).into()
        }
        unsafe extern "system" fn SetFlags<Identity: IMFASFSplitter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFSplitter_Impl::SetFlags(this, core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn GetFlags<Identity: IMFASFSplitter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwflags: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFSplitter_Impl::GetFlags(this) {
                Ok(ok__) => {
                    pdwflags.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectStreams<Identity: IMFASFSplitter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwstreamnumbers: *const u16, wnumstreams: u16) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFSplitter_Impl::SelectStreams(this, core::mem::transmute_copy(&pwstreamnumbers), core::mem::transmute_copy(&wnumstreams)).into()
        }
        unsafe extern "system" fn GetSelectedStreams<Identity: IMFASFSplitter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwstreamnumbers: *mut u16, pwnumstreams: *mut u16) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFSplitter_Impl::GetSelectedStreams(this, core::mem::transmute_copy(&pwstreamnumbers), core::mem::transmute_copy(&pwnumstreams)).into()
        }
        unsafe extern "system" fn ParseData<Identity: IMFASFSplitter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pibuffer: *mut core::ffi::c_void, cbbufferoffset: u32, cblength: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFSplitter_Impl::ParseData(this, windows_core::from_raw_borrowed(&pibuffer), core::mem::transmute_copy(&cbbufferoffset), core::mem::transmute_copy(&cblength)).into()
        }
        unsafe extern "system" fn GetNextSample<Identity: IMFASFSplitter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwstatusflags: *mut ASF_STATUSFLAGS, pwstreamnumber: *mut u16, ppisample: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFSplitter_Impl::GetNextSample(this, core::mem::transmute_copy(&pdwstatusflags), core::mem::transmute_copy(&pwstreamnumber), core::mem::transmute_copy(&ppisample)).into()
        }
        unsafe extern "system" fn Flush<Identity: IMFASFSplitter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFSplitter_Impl::Flush(this).into()
        }
        unsafe extern "system" fn GetLastSendTime<Identity: IMFASFSplitter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwlastsendtime: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFSplitter_Impl::GetLastSendTime(this) {
                Ok(ok__) => {
                    pdwlastsendtime.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Initialize: Initialize::<Identity, OFFSET>,
            SetFlags: SetFlags::<Identity, OFFSET>,
            GetFlags: GetFlags::<Identity, OFFSET>,
            SelectStreams: SelectStreams::<Identity, OFFSET>,
            GetSelectedStreams: GetSelectedStreams::<Identity, OFFSET>,
            ParseData: ParseData::<Identity, OFFSET>,
            GetNextSample: GetNextSample::<Identity, OFFSET>,
            Flush: Flush::<Identity, OFFSET>,
            GetLastSendTime: GetLastSendTime::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFASFSplitter as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFASFStreamConfig_Impl: Sized + IMFAttributes_Impl {
    fn GetStreamType(&self) -> windows_core::Result<windows_core::GUID>;
    fn GetStreamNumber(&self) -> u16;
    fn SetStreamNumber(&self, wstreamnum: u16) -> windows_core::Result<()>;
    fn GetMediaType(&self) -> windows_core::Result<IMFMediaType>;
    fn SetMediaType(&self, pimediatype: Option<&IMFMediaType>) -> windows_core::Result<()>;
    fn GetPayloadExtensionCount(&self) -> windows_core::Result<u16>;
    fn GetPayloadExtension(&self, wpayloadextensionnumber: u16, pguidextensionsystemid: *mut windows_core::GUID, pcbextensiondatasize: *mut u16, pbextensionsysteminfo: *mut u8, pcbextensionsysteminfo: *mut u32) -> windows_core::Result<()>;
    fn AddPayloadExtension(&self, guidextensionsystemid: &windows_core::GUID, cbextensiondatasize: u16, pbextensionsysteminfo: *const u8, cbextensionsysteminfo: u32) -> windows_core::Result<()>;
    fn RemoveAllPayloadExtensions(&self) -> windows_core::Result<()>;
    fn Clone(&self) -> windows_core::Result<IMFASFStreamConfig>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFASFStreamConfig {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFASFStreamConfig_Vtbl {
    pub const fn new<Identity: IMFASFStreamConfig_Impl, const OFFSET: isize>() -> IMFASFStreamConfig_Vtbl {
        unsafe extern "system" fn GetStreamType<Identity: IMFASFStreamConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguidstreamtype: *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFStreamConfig_Impl::GetStreamType(this) {
                Ok(ok__) => {
                    pguidstreamtype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamNumber<Identity: IMFASFStreamConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u16 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFStreamConfig_Impl::GetStreamNumber(this)
        }
        unsafe extern "system" fn SetStreamNumber<Identity: IMFASFStreamConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, wstreamnum: u16) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFStreamConfig_Impl::SetStreamNumber(this, core::mem::transmute_copy(&wstreamnum)).into()
        }
        unsafe extern "system" fn GetMediaType<Identity: IMFASFStreamConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppimediatype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFStreamConfig_Impl::GetMediaType(this) {
                Ok(ok__) => {
                    ppimediatype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaType<Identity: IMFASFStreamConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pimediatype: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFStreamConfig_Impl::SetMediaType(this, windows_core::from_raw_borrowed(&pimediatype)).into()
        }
        unsafe extern "system" fn GetPayloadExtensionCount<Identity: IMFASFStreamConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcpayloadextensions: *mut u16) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFStreamConfig_Impl::GetPayloadExtensionCount(this) {
                Ok(ok__) => {
                    pcpayloadextensions.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPayloadExtension<Identity: IMFASFStreamConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, wpayloadextensionnumber: u16, pguidextensionsystemid: *mut windows_core::GUID, pcbextensiondatasize: *mut u16, pbextensionsysteminfo: *mut u8, pcbextensionsysteminfo: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFStreamConfig_Impl::GetPayloadExtension(this, core::mem::transmute_copy(&wpayloadextensionnumber), core::mem::transmute_copy(&pguidextensionsystemid), core::mem::transmute_copy(&pcbextensiondatasize), core::mem::transmute_copy(&pbextensionsysteminfo), core::mem::transmute_copy(&pcbextensionsysteminfo)).into()
        }
        unsafe extern "system" fn AddPayloadExtension<Identity: IMFASFStreamConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidextensionsystemid: windows_core::GUID, cbextensiondatasize: u16, pbextensionsysteminfo: *const u8, cbextensionsysteminfo: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFStreamConfig_Impl::AddPayloadExtension(this, core::mem::transmute(&guidextensionsystemid), core::mem::transmute_copy(&cbextensiondatasize), core::mem::transmute_copy(&pbextensionsysteminfo), core::mem::transmute_copy(&cbextensionsysteminfo)).into()
        }
        unsafe extern "system" fn RemoveAllPayloadExtensions<Identity: IMFASFStreamConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFStreamConfig_Impl::RemoveAllPayloadExtensions(this).into()
        }
        unsafe extern "system" fn Clone<Identity: IMFASFStreamConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppistreamconfig: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFStreamConfig_Impl::Clone(this) {
                Ok(ok__) => {
                    ppistreamconfig.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IMFAttributes_Vtbl::new::<Identity, OFFSET>(),
            GetStreamType: GetStreamType::<Identity, OFFSET>,
            GetStreamNumber: GetStreamNumber::<Identity, OFFSET>,
            SetStreamNumber: SetStreamNumber::<Identity, OFFSET>,
            GetMediaType: GetMediaType::<Identity, OFFSET>,
            SetMediaType: SetMediaType::<Identity, OFFSET>,
            GetPayloadExtensionCount: GetPayloadExtensionCount::<Identity, OFFSET>,
            GetPayloadExtension: GetPayloadExtension::<Identity, OFFSET>,
            AddPayloadExtension: AddPayloadExtension::<Identity, OFFSET>,
            RemoveAllPayloadExtensions: RemoveAllPayloadExtensions::<Identity, OFFSET>,
            Clone: Clone::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFASFStreamConfig as windows_core::Interface>::IID || iid == &<IMFAttributes as windows_core::Interface>::IID
    }
}
pub trait IMFASFStreamPrioritization_Impl: Sized + windows_core::IUnknownImpl {
    fn GetStreamCount(&self) -> windows_core::Result<u32>;
    fn GetStream(&self, dwstreamindex: u32, pwstreamnumber: *mut u16, pwstreamflags: *mut u16) -> windows_core::Result<()>;
    fn AddStream(&self, wstreamnumber: u16, wstreamflags: u16) -> windows_core::Result<()>;
    fn RemoveStream(&self, dwstreamindex: u32) -> windows_core::Result<()>;
    fn Clone(&self) -> windows_core::Result<IMFASFStreamPrioritization>;
}
impl windows_core::RuntimeName for IMFASFStreamPrioritization {}
impl IMFASFStreamPrioritization_Vtbl {
    pub const fn new<Identity: IMFASFStreamPrioritization_Impl, const OFFSET: isize>() -> IMFASFStreamPrioritization_Vtbl {
        unsafe extern "system" fn GetStreamCount<Identity: IMFASFStreamPrioritization_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwstreamcount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFStreamPrioritization_Impl::GetStreamCount(this) {
                Ok(ok__) => {
                    pdwstreamcount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStream<Identity: IMFASFStreamPrioritization_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, pwstreamnumber: *mut u16, pwstreamflags: *mut u16) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFStreamPrioritization_Impl::GetStream(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&pwstreamnumber), core::mem::transmute_copy(&pwstreamflags)).into()
        }
        unsafe extern "system" fn AddStream<Identity: IMFASFStreamPrioritization_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, wstreamnumber: u16, wstreamflags: u16) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFStreamPrioritization_Impl::AddStream(this, core::mem::transmute_copy(&wstreamnumber), core::mem::transmute_copy(&wstreamflags)).into()
        }
        unsafe extern "system" fn RemoveStream<Identity: IMFASFStreamPrioritization_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFStreamPrioritization_Impl::RemoveStream(this, core::mem::transmute_copy(&dwstreamindex)).into()
        }
        unsafe extern "system" fn Clone<Identity: IMFASFStreamPrioritization_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppistreamprioritization: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFStreamPrioritization_Impl::Clone(this) {
                Ok(ok__) => {
                    ppistreamprioritization.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetStreamCount: GetStreamCount::<Identity, OFFSET>,
            GetStream: GetStream::<Identity, OFFSET>,
            AddStream: AddStream::<Identity, OFFSET>,
            RemoveStream: RemoveStream::<Identity, OFFSET>,
            Clone: Clone::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFASFStreamPrioritization as windows_core::Interface>::IID
    }
}
pub trait IMFASFStreamSelector_Impl: Sized + windows_core::IUnknownImpl {
    fn GetStreamCount(&self) -> windows_core::Result<u32>;
    fn GetOutputCount(&self) -> windows_core::Result<u32>;
    fn GetOutputStreamCount(&self, dwoutputnum: u32) -> windows_core::Result<u32>;
    fn GetOutputStreamNumbers(&self, dwoutputnum: u32) -> windows_core::Result<u16>;
    fn GetOutputFromStream(&self, wstreamnum: u16) -> windows_core::Result<u32>;
    fn GetOutputOverride(&self, dwoutputnum: u32) -> windows_core::Result<ASF_SELECTION_STATUS>;
    fn SetOutputOverride(&self, dwoutputnum: u32, selection: ASF_SELECTION_STATUS) -> windows_core::Result<()>;
    fn GetOutputMutexCount(&self, dwoutputnum: u32) -> windows_core::Result<u32>;
    fn GetOutputMutex(&self, dwoutputnum: u32, dwmutexnum: u32) -> windows_core::Result<windows_core::IUnknown>;
    fn SetOutputMutexSelection(&self, dwoutputnum: u32, dwmutexnum: u32, wselectedrecord: u16) -> windows_core::Result<()>;
    fn GetBandwidthStepCount(&self) -> windows_core::Result<u32>;
    fn GetBandwidthStep(&self, dwstepnum: u32, pdwbitrate: *mut u32, rgwstreamnumbers: *mut u16, rgselections: *mut ASF_SELECTION_STATUS) -> windows_core::Result<()>;
    fn BitrateToStepNumber(&self, dwbitrate: u32) -> windows_core::Result<u32>;
    fn SetStreamSelectorFlags(&self, dwstreamselectorflags: u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFASFStreamSelector {}
impl IMFASFStreamSelector_Vtbl {
    pub const fn new<Identity: IMFASFStreamSelector_Impl, const OFFSET: isize>() -> IMFASFStreamSelector_Vtbl {
        unsafe extern "system" fn GetStreamCount<Identity: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcstreams: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFStreamSelector_Impl::GetStreamCount(this) {
                Ok(ok__) => {
                    pcstreams.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputCount<Identity: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcoutputs: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFStreamSelector_Impl::GetOutputCount(this) {
                Ok(ok__) => {
                    pcoutputs.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputStreamCount<Identity: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwoutputnum: u32, pcstreams: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFStreamSelector_Impl::GetOutputStreamCount(this, core::mem::transmute_copy(&dwoutputnum)) {
                Ok(ok__) => {
                    pcstreams.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputStreamNumbers<Identity: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwoutputnum: u32, rgwstreamnumbers: *mut u16) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFStreamSelector_Impl::GetOutputStreamNumbers(this, core::mem::transmute_copy(&dwoutputnum)) {
                Ok(ok__) => {
                    rgwstreamnumbers.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputFromStream<Identity: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, wstreamnum: u16, pdwoutput: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFStreamSelector_Impl::GetOutputFromStream(this, core::mem::transmute_copy(&wstreamnum)) {
                Ok(ok__) => {
                    pdwoutput.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputOverride<Identity: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwoutputnum: u32, pselection: *mut ASF_SELECTION_STATUS) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFStreamSelector_Impl::GetOutputOverride(this, core::mem::transmute_copy(&dwoutputnum)) {
                Ok(ok__) => {
                    pselection.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputOverride<Identity: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwoutputnum: u32, selection: ASF_SELECTION_STATUS) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFStreamSelector_Impl::SetOutputOverride(this, core::mem::transmute_copy(&dwoutputnum), core::mem::transmute_copy(&selection)).into()
        }
        unsafe extern "system" fn GetOutputMutexCount<Identity: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwoutputnum: u32, pcmutexes: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFStreamSelector_Impl::GetOutputMutexCount(this, core::mem::transmute_copy(&dwoutputnum)) {
                Ok(ok__) => {
                    pcmutexes.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputMutex<Identity: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwoutputnum: u32, dwmutexnum: u32, ppmutex: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFStreamSelector_Impl::GetOutputMutex(this, core::mem::transmute_copy(&dwoutputnum), core::mem::transmute_copy(&dwmutexnum)) {
                Ok(ok__) => {
                    ppmutex.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputMutexSelection<Identity: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwoutputnum: u32, dwmutexnum: u32, wselectedrecord: u16) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFStreamSelector_Impl::SetOutputMutexSelection(this, core::mem::transmute_copy(&dwoutputnum), core::mem::transmute_copy(&dwmutexnum), core::mem::transmute_copy(&wselectedrecord)).into()
        }
        unsafe extern "system" fn GetBandwidthStepCount<Identity: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcstepcount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFStreamSelector_Impl::GetBandwidthStepCount(this) {
                Ok(ok__) => {
                    pcstepcount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBandwidthStep<Identity: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstepnum: u32, pdwbitrate: *mut u32, rgwstreamnumbers: *mut u16, rgselections: *mut ASF_SELECTION_STATUS) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFStreamSelector_Impl::GetBandwidthStep(this, core::mem::transmute_copy(&dwstepnum), core::mem::transmute_copy(&pdwbitrate), core::mem::transmute_copy(&rgwstreamnumbers), core::mem::transmute_copy(&rgselections)).into()
        }
        unsafe extern "system" fn BitrateToStepNumber<Identity: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwbitrate: u32, pdwstepnum: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFASFStreamSelector_Impl::BitrateToStepNumber(this, core::mem::transmute_copy(&dwbitrate)) {
                Ok(ok__) => {
                    pdwstepnum.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamSelectorFlags<Identity: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamselectorflags: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFASFStreamSelector_Impl::SetStreamSelectorFlags(this, core::mem::transmute_copy(&dwstreamselectorflags)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetStreamCount: GetStreamCount::<Identity, OFFSET>,
            GetOutputCount: GetOutputCount::<Identity, OFFSET>,
            GetOutputStreamCount: GetOutputStreamCount::<Identity, OFFSET>,
            GetOutputStreamNumbers: GetOutputStreamNumbers::<Identity, OFFSET>,
            GetOutputFromStream: GetOutputFromStream::<Identity, OFFSET>,
            GetOutputOverride: GetOutputOverride::<Identity, OFFSET>,
            SetOutputOverride: SetOutputOverride::<Identity, OFFSET>,
            GetOutputMutexCount: GetOutputMutexCount::<Identity, OFFSET>,
            GetOutputMutex: GetOutputMutex::<Identity, OFFSET>,
            SetOutputMutexSelection: SetOutputMutexSelection::<Identity, OFFSET>,
            GetBandwidthStepCount: GetBandwidthStepCount::<Identity, OFFSET>,
            GetBandwidthStep: GetBandwidthStep::<Identity, OFFSET>,
            BitrateToStepNumber: BitrateToStepNumber::<Identity, OFFSET>,
            SetStreamSelectorFlags: SetStreamSelectorFlags::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFASFStreamSelector as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFActivate_Impl: Sized + IMFAttributes_Impl {
    fn ActivateObject(&self, riid: *const windows_core::GUID, ppv: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn ShutdownObject(&self) -> windows_core::Result<()>;
    fn DetachObject(&self) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFActivate {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFActivate_Vtbl {
    pub const fn new<Identity: IMFActivate_Impl, const OFFSET: isize>() -> IMFActivate_Vtbl {
        unsafe extern "system" fn ActivateObject<Identity: IMFActivate_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppv: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFActivate_Impl::ActivateObject(this, core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppv)).into()
        }
        unsafe extern "system" fn ShutdownObject<Identity: IMFActivate_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFActivate_Impl::ShutdownObject(this).into()
        }
        unsafe extern "system" fn DetachObject<Identity: IMFActivate_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFActivate_Impl::DetachObject(this).into()
        }
        Self {
            base__: IMFAttributes_Vtbl::new::<Identity, OFFSET>(),
            ActivateObject: ActivateObject::<Identity, OFFSET>,
            ShutdownObject: ShutdownObject::<Identity, OFFSET>,
            DetachObject: DetachObject::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFActivate as windows_core::Interface>::IID || iid == &<IMFAttributes as windows_core::Interface>::IID
    }
}
pub trait IMFAsyncCallback_Impl: Sized + windows_core::IUnknownImpl {
    fn GetParameters(&self, pdwflags: *mut u32, pdwqueue: *mut u32) -> windows_core::Result<()>;
    fn Invoke(&self, pasyncresult: Option<&IMFAsyncResult>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFAsyncCallback {}
impl IMFAsyncCallback_Vtbl {
    pub const fn new<Identity: IMFAsyncCallback_Impl, const OFFSET: isize>() -> IMFAsyncCallback_Vtbl {
        unsafe extern "system" fn GetParameters<Identity: IMFAsyncCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwflags: *mut u32, pdwqueue: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAsyncCallback_Impl::GetParameters(this, core::mem::transmute_copy(&pdwflags), core::mem::transmute_copy(&pdwqueue)).into()
        }
        unsafe extern "system" fn Invoke<Identity: IMFAsyncCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pasyncresult: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAsyncCallback_Impl::Invoke(this, windows_core::from_raw_borrowed(&pasyncresult)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetParameters: GetParameters::<Identity, OFFSET>,
            Invoke: Invoke::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFAsyncCallback as windows_core::Interface>::IID
    }
}
pub trait IMFAsyncCallbackLogging_Impl: Sized + IMFAsyncCallback_Impl {
    fn GetObjectPointer(&self) -> *mut core::ffi::c_void;
    fn GetObjectTag(&self) -> u32;
}
impl windows_core::RuntimeName for IMFAsyncCallbackLogging {}
impl IMFAsyncCallbackLogging_Vtbl {
    pub const fn new<Identity: IMFAsyncCallbackLogging_Impl, const OFFSET: isize>() -> IMFAsyncCallbackLogging_Vtbl {
        unsafe extern "system" fn GetObjectPointer<Identity: IMFAsyncCallbackLogging_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> *mut core::ffi::c_void {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAsyncCallbackLogging_Impl::GetObjectPointer(this)
        }
        unsafe extern "system" fn GetObjectTag<Identity: IMFAsyncCallbackLogging_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u32 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAsyncCallbackLogging_Impl::GetObjectTag(this)
        }
        Self {
            base__: IMFAsyncCallback_Vtbl::new::<Identity, OFFSET>(),
            GetObjectPointer: GetObjectPointer::<Identity, OFFSET>,
            GetObjectTag: GetObjectTag::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFAsyncCallbackLogging as windows_core::Interface>::IID || iid == &<IMFAsyncCallback as windows_core::Interface>::IID
    }
}
pub trait IMFAsyncResult_Impl: Sized + windows_core::IUnknownImpl {
    fn GetState(&self) -> windows_core::Result<windows_core::IUnknown>;
    fn GetStatus(&self) -> windows_core::Result<()>;
    fn SetStatus(&self, hrstatus: windows_core::HRESULT) -> windows_core::Result<()>;
    fn GetObject(&self) -> windows_core::Result<windows_core::IUnknown>;
    fn GetStateNoAddRef(&self) -> Option<windows_core::IUnknown>;
}
impl windows_core::RuntimeName for IMFAsyncResult {}
impl IMFAsyncResult_Vtbl {
    pub const fn new<Identity: IMFAsyncResult_Impl, const OFFSET: isize>() -> IMFAsyncResult_Vtbl {
        unsafe extern "system" fn GetState<Identity: IMFAsyncResult_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppunkstate: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFAsyncResult_Impl::GetState(this) {
                Ok(ok__) => {
                    ppunkstate.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStatus<Identity: IMFAsyncResult_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAsyncResult_Impl::GetStatus(this).into()
        }
        unsafe extern "system" fn SetStatus<Identity: IMFAsyncResult_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hrstatus: windows_core::HRESULT) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAsyncResult_Impl::SetStatus(this, core::mem::transmute_copy(&hrstatus)).into()
        }
        unsafe extern "system" fn GetObject<Identity: IMFAsyncResult_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFAsyncResult_Impl::GetObject(this) {
                Ok(ok__) => {
                    ppobject.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStateNoAddRef<Identity: IMFAsyncResult_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> Option<windows_core::IUnknown> {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAsyncResult_Impl::GetStateNoAddRef(this)
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetState: GetState::<Identity, OFFSET>,
            GetStatus: GetStatus::<Identity, OFFSET>,
            SetStatus: SetStatus::<Identity, OFFSET>,
            GetObject: GetObject::<Identity, OFFSET>,
            GetStateNoAddRef: GetStateNoAddRef::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFAsyncResult as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFAttributes_Impl: Sized + windows_core::IUnknownImpl {
    fn GetItem(&self, guidkey: *const windows_core::GUID, pvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> windows_core::Result<()>;
    fn GetItemType(&self, guidkey: *const windows_core::GUID) -> windows_core::Result<MF_ATTRIBUTE_TYPE>;
    fn CompareItem(&self, guidkey: *const windows_core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn Compare(&self, ptheirs: Option<&IMFAttributes>, matchtype: MF_ATTRIBUTES_MATCH_TYPE) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn GetUINT32(&self, guidkey: *const windows_core::GUID) -> windows_core::Result<u32>;
    fn GetUINT64(&self, guidkey: *const windows_core::GUID) -> windows_core::Result<u64>;
    fn GetDouble(&self, guidkey: *const windows_core::GUID) -> windows_core::Result<f64>;
    fn GetGUID(&self, guidkey: *const windows_core::GUID) -> windows_core::Result<windows_core::GUID>;
    fn GetStringLength(&self, guidkey: *const windows_core::GUID) -> windows_core::Result<u32>;
    fn GetString(&self, guidkey: *const windows_core::GUID, pwszvalue: windows_core::PWSTR, cchbufsize: u32, pcchlength: *mut u32) -> windows_core::Result<()>;
    fn GetAllocatedString(&self, guidkey: *const windows_core::GUID, ppwszvalue: *mut windows_core::PWSTR, pcchlength: *mut u32) -> windows_core::Result<()>;
    fn GetBlobSize(&self, guidkey: *const windows_core::GUID) -> windows_core::Result<u32>;
    fn GetBlob(&self, guidkey: *const windows_core::GUID, pbuf: *mut u8, cbbufsize: u32, pcbblobsize: *mut u32) -> windows_core::Result<()>;
    fn GetAllocatedBlob(&self, guidkey: *const windows_core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> windows_core::Result<()>;
    fn GetUnknown(&self, guidkey: *const windows_core::GUID, riid: *const windows_core::GUID, ppv: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn SetItem(&self, guidkey: *const windows_core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> windows_core::Result<()>;
    fn DeleteItem(&self, guidkey: *const windows_core::GUID) -> windows_core::Result<()>;
    fn DeleteAllItems(&self) -> windows_core::Result<()>;
    fn SetUINT32(&self, guidkey: *const windows_core::GUID, unvalue: u32) -> windows_core::Result<()>;
    fn SetUINT64(&self, guidkey: *const windows_core::GUID, unvalue: u64) -> windows_core::Result<()>;
    fn SetDouble(&self, guidkey: *const windows_core::GUID, fvalue: f64) -> windows_core::Result<()>;
    fn SetGUID(&self, guidkey: *const windows_core::GUID, guidvalue: *const windows_core::GUID) -> windows_core::Result<()>;
    fn SetString(&self, guidkey: *const windows_core::GUID, wszvalue: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn SetBlob(&self, guidkey: *const windows_core::GUID, pbuf: *const u8, cbbufsize: u32) -> windows_core::Result<()>;
    fn SetUnknown(&self, guidkey: *const windows_core::GUID, punknown: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn LockStore(&self) -> windows_core::Result<()>;
    fn UnlockStore(&self) -> windows_core::Result<()>;
    fn GetCount(&self) -> windows_core::Result<u32>;
    fn GetItemByIndex(&self, unindex: u32, pguidkey: *mut windows_core::GUID, pvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> windows_core::Result<()>;
    fn CopyAllItems(&self, pdest: Option<&IMFAttributes>) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFAttributes {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFAttributes_Vtbl {
    pub const fn new<Identity: IMFAttributes_Impl, const OFFSET: isize>() -> IMFAttributes_Vtbl {
        unsafe extern "system" fn GetItem<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidkey: *const windows_core::GUID, pvalue: *mut core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAttributes_Impl::GetItem(this, core::mem::transmute_copy(&guidkey), core::mem::transmute_copy(&pvalue)).into()
        }
        unsafe extern "system" fn GetItemType<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidkey: *const windows_core::GUID, ptype: *mut MF_ATTRIBUTE_TYPE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFAttributes_Impl::GetItemType(this, core::mem::transmute_copy(&guidkey)) {
                Ok(ok__) => {
                    ptype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompareItem<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidkey: *const windows_core::GUID, value: *const core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>, pbresult: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFAttributes_Impl::CompareItem(this, core::mem::transmute_copy(&guidkey), core::mem::transmute_copy(&value)) {
                Ok(ok__) => {
                    pbresult.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Compare<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptheirs: *mut core::ffi::c_void, matchtype: MF_ATTRIBUTES_MATCH_TYPE, pbresult: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFAttributes_Impl::Compare(this, windows_core::from_raw_borrowed(&ptheirs), core::mem::transmute_copy(&matchtype)) {
                Ok(ok__) => {
                    pbresult.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetUINT32<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidkey: *const windows_core::GUID, punvalue: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFAttributes_Impl::GetUINT32(this, core::mem::transmute_copy(&guidkey)) {
                Ok(ok__) => {
                    punvalue.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetUINT64<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidkey: *const windows_core::GUID, punvalue: *mut u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFAttributes_Impl::GetUINT64(this, core::mem::transmute_copy(&guidkey)) {
                Ok(ok__) => {
                    punvalue.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDouble<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidkey: *const windows_core::GUID, pfvalue: *mut f64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFAttributes_Impl::GetDouble(this, core::mem::transmute_copy(&guidkey)) {
                Ok(ok__) => {
                    pfvalue.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetGUID<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidkey: *const windows_core::GUID, pguidvalue: *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFAttributes_Impl::GetGUID(this, core::mem::transmute_copy(&guidkey)) {
                Ok(ok__) => {
                    pguidvalue.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStringLength<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidkey: *const windows_core::GUID, pcchlength: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFAttributes_Impl::GetStringLength(this, core::mem::transmute_copy(&guidkey)) {
                Ok(ok__) => {
                    pcchlength.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetString<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidkey: *const windows_core::GUID, pwszvalue: windows_core::PWSTR, cchbufsize: u32, pcchlength: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAttributes_Impl::GetString(this, core::mem::transmute_copy(&guidkey), core::mem::transmute_copy(&pwszvalue), core::mem::transmute_copy(&cchbufsize), core::mem::transmute_copy(&pcchlength)).into()
        }
        unsafe extern "system" fn GetAllocatedString<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidkey: *const windows_core::GUID, ppwszvalue: *mut windows_core::PWSTR, pcchlength: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAttributes_Impl::GetAllocatedString(this, core::mem::transmute_copy(&guidkey), core::mem::transmute_copy(&ppwszvalue), core::mem::transmute_copy(&pcchlength)).into()
        }
        unsafe extern "system" fn GetBlobSize<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidkey: *const windows_core::GUID, pcbblobsize: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFAttributes_Impl::GetBlobSize(this, core::mem::transmute_copy(&guidkey)) {
                Ok(ok__) => {
                    pcbblobsize.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBlob<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidkey: *const windows_core::GUID, pbuf: *mut u8, cbbufsize: u32, pcbblobsize: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAttributes_Impl::GetBlob(this, core::mem::transmute_copy(&guidkey), core::mem::transmute_copy(&pbuf), core::mem::transmute_copy(&cbbufsize), core::mem::transmute_copy(&pcbblobsize)).into()
        }
        unsafe extern "system" fn GetAllocatedBlob<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidkey: *const windows_core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAttributes_Impl::GetAllocatedBlob(this, core::mem::transmute_copy(&guidkey), core::mem::transmute_copy(&ppbuf), core::mem::transmute_copy(&pcbsize)).into()
        }
        unsafe extern "system" fn GetUnknown<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidkey: *const windows_core::GUID, riid: *const windows_core::GUID, ppv: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAttributes_Impl::GetUnknown(this, core::mem::transmute_copy(&guidkey), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppv)).into()
        }
        unsafe extern "system" fn SetItem<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidkey: *const windows_core::GUID, value: *const core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAttributes_Impl::SetItem(this, core::mem::transmute_copy(&guidkey), core::mem::transmute_copy(&value)).into()
        }
        unsafe extern "system" fn DeleteItem<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidkey: *const windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAttributes_Impl::DeleteItem(this, core::mem::transmute_copy(&guidkey)).into()
        }
        unsafe extern "system" fn DeleteAllItems<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAttributes_Impl::DeleteAllItems(this).into()
        }
        unsafe extern "system" fn SetUINT32<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidkey: *const windows_core::GUID, unvalue: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAttributes_Impl::SetUINT32(this, core::mem::transmute_copy(&guidkey), core::mem::transmute_copy(&unvalue)).into()
        }
        unsafe extern "system" fn SetUINT64<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidkey: *const windows_core::GUID, unvalue: u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAttributes_Impl::SetUINT64(this, core::mem::transmute_copy(&guidkey), core::mem::transmute_copy(&unvalue)).into()
        }
        unsafe extern "system" fn SetDouble<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidkey: *const windows_core::GUID, fvalue: f64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAttributes_Impl::SetDouble(this, core::mem::transmute_copy(&guidkey), core::mem::transmute_copy(&fvalue)).into()
        }
        unsafe extern "system" fn SetGUID<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidkey: *const windows_core::GUID, guidvalue: *const windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAttributes_Impl::SetGUID(this, core::mem::transmute_copy(&guidkey), core::mem::transmute_copy(&guidvalue)).into()
        }
        unsafe extern "system" fn SetString<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidkey: *const windows_core::GUID, wszvalue: windows_core::PCWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAttributes_Impl::SetString(this, core::mem::transmute_copy(&guidkey), core::mem::transmute(&wszvalue)).into()
        }
        unsafe extern "system" fn SetBlob<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidkey: *const windows_core::GUID, pbuf: *const u8, cbbufsize: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAttributes_Impl::SetBlob(this, core::mem::transmute_copy(&guidkey), core::mem::transmute_copy(&pbuf), core::mem::transmute_copy(&cbbufsize)).into()
        }
        unsafe extern "system" fn SetUnknown<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidkey: *const windows_core::GUID, punknown: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAttributes_Impl::SetUnknown(this, core::mem::transmute_copy(&guidkey), windows_core::from_raw_borrowed(&punknown)).into()
        }
        unsafe extern "system" fn LockStore<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAttributes_Impl::LockStore(this).into()
        }
        unsafe extern "system" fn UnlockStore<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAttributes_Impl::UnlockStore(this).into()
        }
        unsafe extern "system" fn GetCount<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcitems: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFAttributes_Impl::GetCount(this) {
                Ok(ok__) => {
                    pcitems.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetItemByIndex<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, unindex: u32, pguidkey: *mut windows_core::GUID, pvalue: *mut core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAttributes_Impl::GetItemByIndex(this, core::mem::transmute_copy(&unindex), core::mem::transmute_copy(&pguidkey), core::mem::transmute_copy(&pvalue)).into()
        }
        unsafe extern "system" fn CopyAllItems<Identity: IMFAttributes_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdest: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAttributes_Impl::CopyAllItems(this, windows_core::from_raw_borrowed(&pdest)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetItem: GetItem::<Identity, OFFSET>,
            GetItemType: GetItemType::<Identity, OFFSET>,
            CompareItem: CompareItem::<Identity, OFFSET>,
            Compare: Compare::<Identity, OFFSET>,
            GetUINT32: GetUINT32::<Identity, OFFSET>,
            GetUINT64: GetUINT64::<Identity, OFFSET>,
            GetDouble: GetDouble::<Identity, OFFSET>,
            GetGUID: GetGUID::<Identity, OFFSET>,
            GetStringLength: GetStringLength::<Identity, OFFSET>,
            GetString: GetString::<Identity, OFFSET>,
            GetAllocatedString: GetAllocatedString::<Identity, OFFSET>,
            GetBlobSize: GetBlobSize::<Identity, OFFSET>,
            GetBlob: GetBlob::<Identity, OFFSET>,
            GetAllocatedBlob: GetAllocatedBlob::<Identity, OFFSET>,
            GetUnknown: GetUnknown::<Identity, OFFSET>,
            SetItem: SetItem::<Identity, OFFSET>,
            DeleteItem: DeleteItem::<Identity, OFFSET>,
            DeleteAllItems: DeleteAllItems::<Identity, OFFSET>,
            SetUINT32: SetUINT32::<Identity, OFFSET>,
            SetUINT64: SetUINT64::<Identity, OFFSET>,
            SetDouble: SetDouble::<Identity, OFFSET>,
            SetGUID: SetGUID::<Identity, OFFSET>,
            SetString: SetString::<Identity, OFFSET>,
            SetBlob: SetBlob::<Identity, OFFSET>,
            SetUnknown: SetUnknown::<Identity, OFFSET>,
            LockStore: LockStore::<Identity, OFFSET>,
            UnlockStore: UnlockStore::<Identity, OFFSET>,
            GetCount: GetCount::<Identity, OFFSET>,
            GetItemByIndex: GetItemByIndex::<Identity, OFFSET>,
            CopyAllItems: CopyAllItems::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFAttributes as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Media_Audio", feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFAudioMediaType_Impl: Sized + IMFMediaType_Impl {
    fn GetAudioFormat(&self) -> *mut super::Audio::WAVEFORMATEX;
}
#[cfg(all(feature = "Win32_Media_Audio", feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFAudioMediaType {}
#[cfg(all(feature = "Win32_Media_Audio", feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFAudioMediaType_Vtbl {
    pub const fn new<Identity: IMFAudioMediaType_Impl, const OFFSET: isize>() -> IMFAudioMediaType_Vtbl {
        unsafe extern "system" fn GetAudioFormat<Identity: IMFAudioMediaType_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> *mut super::Audio::WAVEFORMATEX {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAudioMediaType_Impl::GetAudioFormat(this)
        }
        Self { base__: IMFMediaType_Vtbl::new::<Identity, OFFSET>(), GetAudioFormat: GetAudioFormat::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFAudioMediaType as windows_core::Interface>::IID || iid == &<IMFAttributes as windows_core::Interface>::IID || iid == &<IMFMediaType as windows_core::Interface>::IID
    }
}
pub trait IMFAudioPolicy_Impl: Sized + windows_core::IUnknownImpl {
    fn SetGroupingParam(&self, rguidclass: *const windows_core::GUID) -> windows_core::Result<()>;
    fn GetGroupingParam(&self) -> windows_core::Result<windows_core::GUID>;
    fn SetDisplayName(&self, pszname: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn GetDisplayName(&self) -> windows_core::Result<windows_core::PWSTR>;
    fn SetIconPath(&self, pszpath: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn GetIconPath(&self) -> windows_core::Result<windows_core::PWSTR>;
}
impl windows_core::RuntimeName for IMFAudioPolicy {}
impl IMFAudioPolicy_Vtbl {
    pub const fn new<Identity: IMFAudioPolicy_Impl, const OFFSET: isize>() -> IMFAudioPolicy_Vtbl {
        unsafe extern "system" fn SetGroupingParam<Identity: IMFAudioPolicy_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, rguidclass: *const windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAudioPolicy_Impl::SetGroupingParam(this, core::mem::transmute_copy(&rguidclass)).into()
        }
        unsafe extern "system" fn GetGroupingParam<Identity: IMFAudioPolicy_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguidclass: *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFAudioPolicy_Impl::GetGroupingParam(this) {
                Ok(ok__) => {
                    pguidclass.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisplayName<Identity: IMFAudioPolicy_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszname: windows_core::PCWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAudioPolicy_Impl::SetDisplayName(this, core::mem::transmute(&pszname)).into()
        }
        unsafe extern "system" fn GetDisplayName<Identity: IMFAudioPolicy_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszname: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFAudioPolicy_Impl::GetDisplayName(this) {
                Ok(ok__) => {
                    pszname.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIconPath<Identity: IMFAudioPolicy_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszpath: windows_core::PCWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAudioPolicy_Impl::SetIconPath(this, core::mem::transmute(&pszpath)).into()
        }
        unsafe extern "system" fn GetIconPath<Identity: IMFAudioPolicy_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszpath: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFAudioPolicy_Impl::GetIconPath(this) {
                Ok(ok__) => {
                    pszpath.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetGroupingParam: SetGroupingParam::<Identity, OFFSET>,
            GetGroupingParam: GetGroupingParam::<Identity, OFFSET>,
            SetDisplayName: SetDisplayName::<Identity, OFFSET>,
            GetDisplayName: GetDisplayName::<Identity, OFFSET>,
            SetIconPath: SetIconPath::<Identity, OFFSET>,
            GetIconPath: GetIconPath::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFAudioPolicy as windows_core::Interface>::IID
    }
}
pub trait IMFAudioStreamVolume_Impl: Sized + windows_core::IUnknownImpl {
    fn GetChannelCount(&self) -> windows_core::Result<u32>;
    fn SetChannelVolume(&self, dwindex: u32, flevel: f32) -> windows_core::Result<()>;
    fn GetChannelVolume(&self, dwindex: u32) -> windows_core::Result<f32>;
    fn SetAllVolumes(&self, dwcount: u32, pfvolumes: *const f32) -> windows_core::Result<()>;
    fn GetAllVolumes(&self, dwcount: u32, pfvolumes: *mut f32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFAudioStreamVolume {}
impl IMFAudioStreamVolume_Vtbl {
    pub const fn new<Identity: IMFAudioStreamVolume_Impl, const OFFSET: isize>() -> IMFAudioStreamVolume_Vtbl {
        unsafe extern "system" fn GetChannelCount<Identity: IMFAudioStreamVolume_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwcount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFAudioStreamVolume_Impl::GetChannelCount(this) {
                Ok(ok__) => {
                    pdwcount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChannelVolume<Identity: IMFAudioStreamVolume_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwindex: u32, flevel: f32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAudioStreamVolume_Impl::SetChannelVolume(this, core::mem::transmute_copy(&dwindex), core::mem::transmute_copy(&flevel)).into()
        }
        unsafe extern "system" fn GetChannelVolume<Identity: IMFAudioStreamVolume_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwindex: u32, pflevel: *mut f32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFAudioStreamVolume_Impl::GetChannelVolume(this, core::mem::transmute_copy(&dwindex)) {
                Ok(ok__) => {
                    pflevel.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAllVolumes<Identity: IMFAudioStreamVolume_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwcount: u32, pfvolumes: *const f32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAudioStreamVolume_Impl::SetAllVolumes(this, core::mem::transmute_copy(&dwcount), core::mem::transmute_copy(&pfvolumes)).into()
        }
        unsafe extern "system" fn GetAllVolumes<Identity: IMFAudioStreamVolume_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwcount: u32, pfvolumes: *mut f32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFAudioStreamVolume_Impl::GetAllVolumes(this, core::mem::transmute_copy(&dwcount), core::mem::transmute_copy(&pfvolumes)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetChannelCount: GetChannelCount::<Identity, OFFSET>,
            SetChannelVolume: SetChannelVolume::<Identity, OFFSET>,
            GetChannelVolume: GetChannelVolume::<Identity, OFFSET>,
            SetAllVolumes: SetAllVolumes::<Identity, OFFSET>,
            GetAllVolumes: GetAllVolumes::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFAudioStreamVolume as windows_core::Interface>::IID
    }
}
pub trait IMFBufferListNotify_Impl: Sized + windows_core::IUnknownImpl {
    fn OnAddSourceBuffer(&self);
    fn OnRemoveSourceBuffer(&self);
}
impl windows_core::RuntimeName for IMFBufferListNotify {}
impl IMFBufferListNotify_Vtbl {
    pub const fn new<Identity: IMFBufferListNotify_Impl, const OFFSET: isize>() -> IMFBufferListNotify_Vtbl {
        unsafe extern "system" fn OnAddSourceBuffer<Identity: IMFBufferListNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFBufferListNotify_Impl::OnAddSourceBuffer(this)
        }
        unsafe extern "system" fn OnRemoveSourceBuffer<Identity: IMFBufferListNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFBufferListNotify_Impl::OnRemoveSourceBuffer(this)
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            OnAddSourceBuffer: OnAddSourceBuffer::<Identity, OFFSET>,
            OnRemoveSourceBuffer: OnRemoveSourceBuffer::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFBufferListNotify as windows_core::Interface>::IID
    }
}
pub trait IMFByteStream_Impl: Sized + windows_core::IUnknownImpl {
    fn GetCapabilities(&self) -> windows_core::Result<u32>;
    fn GetLength(&self) -> windows_core::Result<u64>;
    fn SetLength(&self, qwlength: u64) -> windows_core::Result<()>;
    fn GetCurrentPosition(&self) -> windows_core::Result<u64>;
    fn SetCurrentPosition(&self, qwposition: u64) -> windows_core::Result<()>;
    fn IsEndOfStream(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn Read(&self, pb: *mut u8, cb: u32, pcbread: *mut u32) -> windows_core::Result<()>;
    fn BeginRead(&self, pb: *mut u8, cb: u32, pcallback: Option<&IMFAsyncCallback>, punkstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndRead(&self, presult: Option<&IMFAsyncResult>) -> windows_core::Result<u32>;
    fn Write(&self, pb: *const u8, cb: u32) -> windows_core::Result<u32>;
    fn BeginWrite(&self, pb: *const u8, cb: u32, pcallback: Option<&IMFAsyncCallback>, punkstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndWrite(&self, presult: Option<&IMFAsyncResult>) -> windows_core::Result<u32>;
    fn Seek(&self, seekorigin: MFBYTESTREAM_SEEK_ORIGIN, llseekoffset: i64, dwseekflags: u32) -> windows_core::Result<u64>;
    fn Flush(&self) -> windows_core::Result<()>;
    fn Close(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFByteStream {}
impl IMFByteStream_Vtbl {
    pub const fn new<Identity: IMFByteStream_Impl, const OFFSET: isize>() -> IMFByteStream_Vtbl {
        unsafe extern "system" fn GetCapabilities<Identity: IMFByteStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwcapabilities: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFByteStream_Impl::GetCapabilities(this) {
                Ok(ok__) => {
                    pdwcapabilities.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Identity: IMFByteStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pqwlength: *mut u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFByteStream_Impl::GetLength(this) {
                Ok(ok__) => {
                    pqwlength.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLength<Identity: IMFByteStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, qwlength: u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFByteStream_Impl::SetLength(this, core::mem::transmute_copy(&qwlength)).into()
        }
        unsafe extern "system" fn GetCurrentPosition<Identity: IMFByteStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pqwposition: *mut u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFByteStream_Impl::GetCurrentPosition(this) {
                Ok(ok__) => {
                    pqwposition.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentPosition<Identity: IMFByteStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, qwposition: u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFByteStream_Impl::SetCurrentPosition(this, core::mem::transmute_copy(&qwposition)).into()
        }
        unsafe extern "system" fn IsEndOfStream<Identity: IMFByteStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfendofstream: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFByteStream_Impl::IsEndOfStream(this) {
                Ok(ok__) => {
                    pfendofstream.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Read<Identity: IMFByteStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pb: *mut u8, cb: u32, pcbread: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFByteStream_Impl::Read(this, core::mem::transmute_copy(&pb), core::mem::transmute_copy(&cb), core::mem::transmute_copy(&pcbread)).into()
        }
        unsafe extern "system" fn BeginRead<Identity: IMFByteStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pb: *mut u8, cb: u32, pcallback: *mut core::ffi::c_void, punkstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFByteStream_Impl::BeginRead(this, core::mem::transmute_copy(&pb), core::mem::transmute_copy(&cb), windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&punkstate)).into()
        }
        unsafe extern "system" fn EndRead<Identity: IMFByteStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void, pcbread: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFByteStream_Impl::EndRead(this, windows_core::from_raw_borrowed(&presult)) {
                Ok(ok__) => {
                    pcbread.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Write<Identity: IMFByteStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pb: *const u8, cb: u32, pcbwritten: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFByteStream_Impl::Write(this, core::mem::transmute_copy(&pb), core::mem::transmute_copy(&cb)) {
                Ok(ok__) => {
                    pcbwritten.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginWrite<Identity: IMFByteStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pb: *const u8, cb: u32, pcallback: *mut core::ffi::c_void, punkstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFByteStream_Impl::BeginWrite(this, core::mem::transmute_copy(&pb), core::mem::transmute_copy(&cb), windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&punkstate)).into()
        }
        unsafe extern "system" fn EndWrite<Identity: IMFByteStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void, pcbwritten: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFByteStream_Impl::EndWrite(this, windows_core::from_raw_borrowed(&presult)) {
                Ok(ok__) => {
                    pcbwritten.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Seek<Identity: IMFByteStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, seekorigin: MFBYTESTREAM_SEEK_ORIGIN, llseekoffset: i64, dwseekflags: u32, pqwcurrentposition: *mut u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFByteStream_Impl::Seek(this, core::mem::transmute_copy(&seekorigin), core::mem::transmute_copy(&llseekoffset), core::mem::transmute_copy(&dwseekflags)) {
                Ok(ok__) => {
                    pqwcurrentposition.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Flush<Identity: IMFByteStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFByteStream_Impl::Flush(this).into()
        }
        unsafe extern "system" fn Close<Identity: IMFByteStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFByteStream_Impl::Close(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetCapabilities: GetCapabilities::<Identity, OFFSET>,
            GetLength: GetLength::<Identity, OFFSET>,
            SetLength: SetLength::<Identity, OFFSET>,
            GetCurrentPosition: GetCurrentPosition::<Identity, OFFSET>,
            SetCurrentPosition: SetCurrentPosition::<Identity, OFFSET>,
            IsEndOfStream: IsEndOfStream::<Identity, OFFSET>,
            Read: Read::<Identity, OFFSET>,
            BeginRead: BeginRead::<Identity, OFFSET>,
            EndRead: EndRead::<Identity, OFFSET>,
            Write: Write::<Identity, OFFSET>,
            BeginWrite: BeginWrite::<Identity, OFFSET>,
            EndWrite: EndWrite::<Identity, OFFSET>,
            Seek: Seek::<Identity, OFFSET>,
            Flush: Flush::<Identity, OFFSET>,
            Close: Close::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFByteStream as windows_core::Interface>::IID
    }
}
pub trait IMFByteStreamBuffering_Impl: Sized + windows_core::IUnknownImpl {
    fn SetBufferingParams(&self, pparams: *const MFBYTESTREAM_BUFFERING_PARAMS) -> windows_core::Result<()>;
    fn EnableBuffering(&self, fenable: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn StopBuffering(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFByteStreamBuffering {}
impl IMFByteStreamBuffering_Vtbl {
    pub const fn new<Identity: IMFByteStreamBuffering_Impl, const OFFSET: isize>() -> IMFByteStreamBuffering_Vtbl {
        unsafe extern "system" fn SetBufferingParams<Identity: IMFByteStreamBuffering_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pparams: *const MFBYTESTREAM_BUFFERING_PARAMS) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFByteStreamBuffering_Impl::SetBufferingParams(this, core::mem::transmute_copy(&pparams)).into()
        }
        unsafe extern "system" fn EnableBuffering<Identity: IMFByteStreamBuffering_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fenable: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFByteStreamBuffering_Impl::EnableBuffering(this, core::mem::transmute_copy(&fenable)).into()
        }
        unsafe extern "system" fn StopBuffering<Identity: IMFByteStreamBuffering_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFByteStreamBuffering_Impl::StopBuffering(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetBufferingParams: SetBufferingParams::<Identity, OFFSET>,
            EnableBuffering: EnableBuffering::<Identity, OFFSET>,
            StopBuffering: StopBuffering::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFByteStreamBuffering as windows_core::Interface>::IID
    }
}
pub trait IMFByteStreamCacheControl_Impl: Sized + windows_core::IUnknownImpl {
    fn StopBackgroundTransfer(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFByteStreamCacheControl {}
impl IMFByteStreamCacheControl_Vtbl {
    pub const fn new<Identity: IMFByteStreamCacheControl_Impl, const OFFSET: isize>() -> IMFByteStreamCacheControl_Vtbl {
        unsafe extern "system" fn StopBackgroundTransfer<Identity: IMFByteStreamCacheControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFByteStreamCacheControl_Impl::StopBackgroundTransfer(this).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), StopBackgroundTransfer: StopBackgroundTransfer::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFByteStreamCacheControl as windows_core::Interface>::IID
    }
}
pub trait IMFByteStreamCacheControl2_Impl: Sized + IMFByteStreamCacheControl_Impl {
    fn GetByteRanges(&self, pcranges: *mut u32, ppranges: *mut *mut MF_BYTE_STREAM_CACHE_RANGE) -> windows_core::Result<()>;
    fn SetCacheLimit(&self, qwbytes: u64) -> windows_core::Result<()>;
    fn IsBackgroundTransferActive(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
}
impl windows_core::RuntimeName for IMFByteStreamCacheControl2 {}
impl IMFByteStreamCacheControl2_Vtbl {
    pub const fn new<Identity: IMFByteStreamCacheControl2_Impl, const OFFSET: isize>() -> IMFByteStreamCacheControl2_Vtbl {
        unsafe extern "system" fn GetByteRanges<Identity: IMFByteStreamCacheControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcranges: *mut u32, ppranges: *mut *mut MF_BYTE_STREAM_CACHE_RANGE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFByteStreamCacheControl2_Impl::GetByteRanges(this, core::mem::transmute_copy(&pcranges), core::mem::transmute_copy(&ppranges)).into()
        }
        unsafe extern "system" fn SetCacheLimit<Identity: IMFByteStreamCacheControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, qwbytes: u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFByteStreamCacheControl2_Impl::SetCacheLimit(this, core::mem::transmute_copy(&qwbytes)).into()
        }
        unsafe extern "system" fn IsBackgroundTransferActive<Identity: IMFByteStreamCacheControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfactive: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFByteStreamCacheControl2_Impl::IsBackgroundTransferActive(this) {
                Ok(ok__) => {
                    pfactive.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IMFByteStreamCacheControl_Vtbl::new::<Identity, OFFSET>(),
            GetByteRanges: GetByteRanges::<Identity, OFFSET>,
            SetCacheLimit: SetCacheLimit::<Identity, OFFSET>,
            IsBackgroundTransferActive: IsBackgroundTransferActive::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFByteStreamCacheControl2 as windows_core::Interface>::IID || iid == &<IMFByteStreamCacheControl as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub trait IMFByteStreamHandler_Impl: Sized + windows_core::IUnknownImpl {
    fn BeginCreateObject(&self, pbytestream: Option<&IMFByteStream>, pwszurl: &windows_core::PCWSTR, dwflags: u32, pprops: Option<&super::super::UI::Shell::PropertiesSystem::IPropertyStore>, ppiunknowncancelcookie: *mut Option<windows_core::IUnknown>, pcallback: Option<&IMFAsyncCallback>, punkstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndCreateObject(&self, presult: Option<&IMFAsyncResult>, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut Option<windows_core::IUnknown>) -> windows_core::Result<()>;
    fn CancelObjectCreation(&self, piunknowncancelcookie: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn GetMaxNumberOfBytesRequiredForResolution(&self) -> windows_core::Result<u64>;
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl windows_core::RuntimeName for IMFByteStreamHandler {}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl IMFByteStreamHandler_Vtbl {
    pub const fn new<Identity: IMFByteStreamHandler_Impl, const OFFSET: isize>() -> IMFByteStreamHandler_Vtbl {
        unsafe extern "system" fn BeginCreateObject<Identity: IMFByteStreamHandler_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbytestream: *mut core::ffi::c_void, pwszurl: windows_core::PCWSTR, dwflags: u32, pprops: *mut core::ffi::c_void, ppiunknowncancelcookie: *mut *mut core::ffi::c_void, pcallback: *mut core::ffi::c_void, punkstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFByteStreamHandler_Impl::BeginCreateObject(this, windows_core::from_raw_borrowed(&pbytestream), core::mem::transmute(&pwszurl), core::mem::transmute_copy(&dwflags), windows_core::from_raw_borrowed(&pprops), core::mem::transmute_copy(&ppiunknowncancelcookie), windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&punkstate)).into()
        }
        unsafe extern "system" fn EndCreateObject<Identity: IMFByteStreamHandler_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFByteStreamHandler_Impl::EndCreateObject(this, windows_core::from_raw_borrowed(&presult), core::mem::transmute_copy(&pobjecttype), core::mem::transmute_copy(&ppobject)).into()
        }
        unsafe extern "system" fn CancelObjectCreation<Identity: IMFByteStreamHandler_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, piunknowncancelcookie: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFByteStreamHandler_Impl::CancelObjectCreation(this, windows_core::from_raw_borrowed(&piunknowncancelcookie)).into()
        }
        unsafe extern "system" fn GetMaxNumberOfBytesRequiredForResolution<Identity: IMFByteStreamHandler_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pqwbytes: *mut u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFByteStreamHandler_Impl::GetMaxNumberOfBytesRequiredForResolution(this) {
                Ok(ok__) => {
                    pqwbytes.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            BeginCreateObject: BeginCreateObject::<Identity, OFFSET>,
            EndCreateObject: EndCreateObject::<Identity, OFFSET>,
            CancelObjectCreation: CancelObjectCreation::<Identity, OFFSET>,
            GetMaxNumberOfBytesRequiredForResolution: GetMaxNumberOfBytesRequiredForResolution::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFByteStreamHandler as windows_core::Interface>::IID
    }
}
pub trait IMFByteStreamProxyClassFactory_Impl: Sized + windows_core::IUnknownImpl {
    fn CreateByteStreamProxy(&self, pbytestream: Option<&IMFByteStream>, pattributes: Option<&IMFAttributes>, riid: *const windows_core::GUID, ppvobject: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFByteStreamProxyClassFactory {}
impl IMFByteStreamProxyClassFactory_Vtbl {
    pub const fn new<Identity: IMFByteStreamProxyClassFactory_Impl, const OFFSET: isize>() -> IMFByteStreamProxyClassFactory_Vtbl {
        unsafe extern "system" fn CreateByteStreamProxy<Identity: IMFByteStreamProxyClassFactory_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbytestream: *mut core::ffi::c_void, pattributes: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppvobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFByteStreamProxyClassFactory_Impl::CreateByteStreamProxy(this, windows_core::from_raw_borrowed(&pbytestream), windows_core::from_raw_borrowed(&pattributes), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvobject)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), CreateByteStreamProxy: CreateByteStreamProxy::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFByteStreamProxyClassFactory as windows_core::Interface>::IID
    }
}
pub trait IMFByteStreamTimeSeek_Impl: Sized + windows_core::IUnknownImpl {
    fn IsTimeSeekSupported(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn TimeSeek(&self, qwtimeposition: u64) -> windows_core::Result<()>;
    fn GetTimeSeekResult(&self, pqwstarttime: *mut u64, pqwstoptime: *mut u64, pqwduration: *mut u64) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFByteStreamTimeSeek {}
impl IMFByteStreamTimeSeek_Vtbl {
    pub const fn new<Identity: IMFByteStreamTimeSeek_Impl, const OFFSET: isize>() -> IMFByteStreamTimeSeek_Vtbl {
        unsafe extern "system" fn IsTimeSeekSupported<Identity: IMFByteStreamTimeSeek_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pftimeseekissupported: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFByteStreamTimeSeek_Impl::IsTimeSeekSupported(this) {
                Ok(ok__) => {
                    pftimeseekissupported.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TimeSeek<Identity: IMFByteStreamTimeSeek_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, qwtimeposition: u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFByteStreamTimeSeek_Impl::TimeSeek(this, core::mem::transmute_copy(&qwtimeposition)).into()
        }
        unsafe extern "system" fn GetTimeSeekResult<Identity: IMFByteStreamTimeSeek_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pqwstarttime: *mut u64, pqwstoptime: *mut u64, pqwduration: *mut u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFByteStreamTimeSeek_Impl::GetTimeSeekResult(this, core::mem::transmute_copy(&pqwstarttime), core::mem::transmute_copy(&pqwstoptime), core::mem::transmute_copy(&pqwduration)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            IsTimeSeekSupported: IsTimeSeekSupported::<Identity, OFFSET>,
            TimeSeek: TimeSeek::<Identity, OFFSET>,
            GetTimeSeekResult: GetTimeSeekResult::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFByteStreamTimeSeek as windows_core::Interface>::IID
    }
}
pub trait IMFCameraConfigurationManager_Impl: Sized + windows_core::IUnknownImpl {
    fn LoadDefaults(&self, cameraattributes: Option<&IMFAttributes>) -> windows_core::Result<IMFCameraControlDefaultsCollection>;
    fn SaveDefaults(&self, configurations: Option<&IMFCameraControlDefaultsCollection>) -> windows_core::Result<()>;
    fn Shutdown(&self);
}
impl windows_core::RuntimeName for IMFCameraConfigurationManager {}
impl IMFCameraConfigurationManager_Vtbl {
    pub const fn new<Identity: IMFCameraConfigurationManager_Impl, const OFFSET: isize>() -> IMFCameraConfigurationManager_Vtbl {
        unsafe extern "system" fn LoadDefaults<Identity: IMFCameraConfigurationManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cameraattributes: *mut core::ffi::c_void, configurations: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFCameraConfigurationManager_Impl::LoadDefaults(this, windows_core::from_raw_borrowed(&cameraattributes)) {
                Ok(ok__) => {
                    configurations.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SaveDefaults<Identity: IMFCameraConfigurationManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, configurations: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCameraConfigurationManager_Impl::SaveDefaults(this, windows_core::from_raw_borrowed(&configurations)).into()
        }
        unsafe extern "system" fn Shutdown<Identity: IMFCameraConfigurationManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCameraConfigurationManager_Impl::Shutdown(this)
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            LoadDefaults: LoadDefaults::<Identity, OFFSET>,
            SaveDefaults: SaveDefaults::<Identity, OFFSET>,
            Shutdown: Shutdown::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFCameraConfigurationManager as windows_core::Interface>::IID
    }
}
pub trait IMFCameraControlDefaults_Impl: Sized + windows_core::IUnknownImpl {
    fn GetType(&self) -> MF_CAMERA_CONTROL_CONFIGURATION_TYPE;
    fn GetRangeInfo(&self) -> windows_core::Result<MF_CAMERA_CONTROL_RANGE_INFO>;
    fn LockControlData(&self, control: *mut *mut core::ffi::c_void, controlsize: *mut u32, data: *mut *mut core::ffi::c_void, datasize: *mut u32) -> windows_core::Result<()>;
    fn UnlockControlData(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFCameraControlDefaults {}
impl IMFCameraControlDefaults_Vtbl {
    pub const fn new<Identity: IMFCameraControlDefaults_Impl, const OFFSET: isize>() -> IMFCameraControlDefaults_Vtbl {
        unsafe extern "system" fn GetType<Identity: IMFCameraControlDefaults_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> MF_CAMERA_CONTROL_CONFIGURATION_TYPE {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCameraControlDefaults_Impl::GetType(this)
        }
        unsafe extern "system" fn GetRangeInfo<Identity: IMFCameraControlDefaults_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, rangeinfo: *mut MF_CAMERA_CONTROL_RANGE_INFO) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFCameraControlDefaults_Impl::GetRangeInfo(this) {
                Ok(ok__) => {
                    rangeinfo.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LockControlData<Identity: IMFCameraControlDefaults_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, control: *mut *mut core::ffi::c_void, controlsize: *mut u32, data: *mut *mut core::ffi::c_void, datasize: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCameraControlDefaults_Impl::LockControlData(this, core::mem::transmute_copy(&control), core::mem::transmute_copy(&controlsize), core::mem::transmute_copy(&data), core::mem::transmute_copy(&datasize)).into()
        }
        unsafe extern "system" fn UnlockControlData<Identity: IMFCameraControlDefaults_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCameraControlDefaults_Impl::UnlockControlData(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetType: GetType::<Identity, OFFSET>,
            GetRangeInfo: GetRangeInfo::<Identity, OFFSET>,
            LockControlData: LockControlData::<Identity, OFFSET>,
            UnlockControlData: UnlockControlData::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFCameraControlDefaults as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFCameraControlDefaultsCollection_Impl: Sized + IMFAttributes_Impl {
    fn GetControlCount(&self) -> u32;
    fn GetControl(&self, index: u32) -> windows_core::Result<IMFCameraControlDefaults>;
    fn GetOrAddExtendedControl(&self, configtype: MF_CAMERA_CONTROL_CONFIGURATION_TYPE, constrolid: u32, streamid: u32, datasize: u32) -> windows_core::Result<IMFCameraControlDefaults>;
    fn GetOrAddControl(&self, configtype: MF_CAMERA_CONTROL_CONFIGURATION_TYPE, controlset: *const windows_core::GUID, constrolid: u32, controlsize: u32, datasize: u32) -> windows_core::Result<IMFCameraControlDefaults>;
    fn RemoveControl(&self, controlset: *const windows_core::GUID, constrolid: u32) -> windows_core::Result<()>;
    fn RemoveAllControls(&self) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFCameraControlDefaultsCollection {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFCameraControlDefaultsCollection_Vtbl {
    pub const fn new<Identity: IMFCameraControlDefaultsCollection_Impl, const OFFSET: isize>() -> IMFCameraControlDefaultsCollection_Vtbl {
        unsafe extern "system" fn GetControlCount<Identity: IMFCameraControlDefaultsCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u32 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCameraControlDefaultsCollection_Impl::GetControlCount(this)
        }
        unsafe extern "system" fn GetControl<Identity: IMFCameraControlDefaultsCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, index: u32, configuration: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFCameraControlDefaultsCollection_Impl::GetControl(this, core::mem::transmute_copy(&index)) {
                Ok(ok__) => {
                    configuration.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOrAddExtendedControl<Identity: IMFCameraControlDefaultsCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, configtype: MF_CAMERA_CONTROL_CONFIGURATION_TYPE, constrolid: u32, streamid: u32, datasize: u32, defaults: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFCameraControlDefaultsCollection_Impl::GetOrAddExtendedControl(this, core::mem::transmute_copy(&configtype), core::mem::transmute_copy(&constrolid), core::mem::transmute_copy(&streamid), core::mem::transmute_copy(&datasize)) {
                Ok(ok__) => {
                    defaults.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOrAddControl<Identity: IMFCameraControlDefaultsCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, configtype: MF_CAMERA_CONTROL_CONFIGURATION_TYPE, controlset: *const windows_core::GUID, constrolid: u32, controlsize: u32, datasize: u32, defaults: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFCameraControlDefaultsCollection_Impl::GetOrAddControl(this, core::mem::transmute_copy(&configtype), core::mem::transmute_copy(&controlset), core::mem::transmute_copy(&constrolid), core::mem::transmute_copy(&controlsize), core::mem::transmute_copy(&datasize)) {
                Ok(ok__) => {
                    defaults.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveControl<Identity: IMFCameraControlDefaultsCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, controlset: *const windows_core::GUID, constrolid: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCameraControlDefaultsCollection_Impl::RemoveControl(this, core::mem::transmute_copy(&controlset), core::mem::transmute_copy(&constrolid)).into()
        }
        unsafe extern "system" fn RemoveAllControls<Identity: IMFCameraControlDefaultsCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCameraControlDefaultsCollection_Impl::RemoveAllControls(this).into()
        }
        Self {
            base__: IMFAttributes_Vtbl::new::<Identity, OFFSET>(),
            GetControlCount: GetControlCount::<Identity, OFFSET>,
            GetControl: GetControl::<Identity, OFFSET>,
            GetOrAddExtendedControl: GetOrAddExtendedControl::<Identity, OFFSET>,
            GetOrAddControl: GetOrAddControl::<Identity, OFFSET>,
            RemoveControl: RemoveControl::<Identity, OFFSET>,
            RemoveAllControls: RemoveAllControls::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFCameraControlDefaultsCollection as windows_core::Interface>::IID || iid == &<IMFAttributes as windows_core::Interface>::IID
    }
}
pub trait IMFCameraControlMonitor_Impl: Sized + windows_core::IUnknownImpl {
    fn Start(&self) -> windows_core::Result<()>;
    fn Stop(&self) -> windows_core::Result<()>;
    fn AddControlSubscription(&self, controlset: &windows_core::GUID, id: u32) -> windows_core::Result<()>;
    fn RemoveControlSubscription(&self, controlset: &windows_core::GUID, id: u32) -> windows_core::Result<()>;
    fn Shutdown(&self);
}
impl windows_core::RuntimeName for IMFCameraControlMonitor {}
impl IMFCameraControlMonitor_Vtbl {
    pub const fn new<Identity: IMFCameraControlMonitor_Impl, const OFFSET: isize>() -> IMFCameraControlMonitor_Vtbl {
        unsafe extern "system" fn Start<Identity: IMFCameraControlMonitor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCameraControlMonitor_Impl::Start(this).into()
        }
        unsafe extern "system" fn Stop<Identity: IMFCameraControlMonitor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCameraControlMonitor_Impl::Stop(this).into()
        }
        unsafe extern "system" fn AddControlSubscription<Identity: IMFCameraControlMonitor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, controlset: windows_core::GUID, id: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCameraControlMonitor_Impl::AddControlSubscription(this, core::mem::transmute(&controlset), core::mem::transmute_copy(&id)).into()
        }
        unsafe extern "system" fn RemoveControlSubscription<Identity: IMFCameraControlMonitor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, controlset: windows_core::GUID, id: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCameraControlMonitor_Impl::RemoveControlSubscription(this, core::mem::transmute(&controlset), core::mem::transmute_copy(&id)).into()
        }
        unsafe extern "system" fn Shutdown<Identity: IMFCameraControlMonitor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCameraControlMonitor_Impl::Shutdown(this)
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Start: Start::<Identity, OFFSET>,
            Stop: Stop::<Identity, OFFSET>,
            AddControlSubscription: AddControlSubscription::<Identity, OFFSET>,
            RemoveControlSubscription: RemoveControlSubscription::<Identity, OFFSET>,
            Shutdown: Shutdown::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFCameraControlMonitor as windows_core::Interface>::IID
    }
}
pub trait IMFCameraControlNotify_Impl: Sized + windows_core::IUnknownImpl {
    fn OnChange(&self, controlset: *const windows_core::GUID, id: u32);
    fn OnError(&self, hrstatus: windows_core::HRESULT);
}
impl windows_core::RuntimeName for IMFCameraControlNotify {}
impl IMFCameraControlNotify_Vtbl {
    pub const fn new<Identity: IMFCameraControlNotify_Impl, const OFFSET: isize>() -> IMFCameraControlNotify_Vtbl {
        unsafe extern "system" fn OnChange<Identity: IMFCameraControlNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, controlset: *const windows_core::GUID, id: u32) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCameraControlNotify_Impl::OnChange(this, core::mem::transmute_copy(&controlset), core::mem::transmute_copy(&id))
        }
        unsafe extern "system" fn OnError<Identity: IMFCameraControlNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hrstatus: windows_core::HRESULT) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCameraControlNotify_Impl::OnError(this, core::mem::transmute_copy(&hrstatus))
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), OnChange: OnChange::<Identity, OFFSET>, OnError: OnError::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFCameraControlNotify as windows_core::Interface>::IID
    }
}
pub trait IMFCameraOcclusionStateMonitor_Impl: Sized + windows_core::IUnknownImpl {
    fn Start(&self) -> windows_core::Result<()>;
    fn Stop(&self) -> windows_core::Result<()>;
    fn GetSupportedStates(&self) -> u32;
}
impl windows_core::RuntimeName for IMFCameraOcclusionStateMonitor {}
impl IMFCameraOcclusionStateMonitor_Vtbl {
    pub const fn new<Identity: IMFCameraOcclusionStateMonitor_Impl, const OFFSET: isize>() -> IMFCameraOcclusionStateMonitor_Vtbl {
        unsafe extern "system" fn Start<Identity: IMFCameraOcclusionStateMonitor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCameraOcclusionStateMonitor_Impl::Start(this).into()
        }
        unsafe extern "system" fn Stop<Identity: IMFCameraOcclusionStateMonitor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCameraOcclusionStateMonitor_Impl::Stop(this).into()
        }
        unsafe extern "system" fn GetSupportedStates<Identity: IMFCameraOcclusionStateMonitor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u32 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCameraOcclusionStateMonitor_Impl::GetSupportedStates(this)
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Start: Start::<Identity, OFFSET>,
            Stop: Stop::<Identity, OFFSET>,
            GetSupportedStates: GetSupportedStates::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFCameraOcclusionStateMonitor as windows_core::Interface>::IID
    }
}
pub trait IMFCameraOcclusionStateReport_Impl: Sized + windows_core::IUnknownImpl {
    fn GetOcclusionState(&self) -> windows_core::Result<u32>;
}
impl windows_core::RuntimeName for IMFCameraOcclusionStateReport {}
impl IMFCameraOcclusionStateReport_Vtbl {
    pub const fn new<Identity: IMFCameraOcclusionStateReport_Impl, const OFFSET: isize>() -> IMFCameraOcclusionStateReport_Vtbl {
        unsafe extern "system" fn GetOcclusionState<Identity: IMFCameraOcclusionStateReport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, occlusionstate: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFCameraOcclusionStateReport_Impl::GetOcclusionState(this) {
                Ok(ok__) => {
                    occlusionstate.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetOcclusionState: GetOcclusionState::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFCameraOcclusionStateReport as windows_core::Interface>::IID
    }
}
pub trait IMFCameraOcclusionStateReportCallback_Impl: Sized + windows_core::IUnknownImpl {
    fn OnOcclusionStateReport(&self, occlusionstatereport: Option<&IMFCameraOcclusionStateReport>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFCameraOcclusionStateReportCallback {}
impl IMFCameraOcclusionStateReportCallback_Vtbl {
    pub const fn new<Identity: IMFCameraOcclusionStateReportCallback_Impl, const OFFSET: isize>() -> IMFCameraOcclusionStateReportCallback_Vtbl {
        unsafe extern "system" fn OnOcclusionStateReport<Identity: IMFCameraOcclusionStateReportCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, occlusionstatereport: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCameraOcclusionStateReportCallback_Impl::OnOcclusionStateReport(this, windows_core::from_raw_borrowed(&occlusionstatereport)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), OnOcclusionStateReport: OnOcclusionStateReport::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFCameraOcclusionStateReportCallback as windows_core::Interface>::IID
    }
}
pub trait IMFCameraSyncObject_Impl: Sized + windows_core::IUnknownImpl {
    fn WaitOnSignal(&self, timeoutinms: u32) -> windows_core::Result<()>;
    fn Shutdown(&self);
}
impl windows_core::RuntimeName for IMFCameraSyncObject {}
impl IMFCameraSyncObject_Vtbl {
    pub const fn new<Identity: IMFCameraSyncObject_Impl, const OFFSET: isize>() -> IMFCameraSyncObject_Vtbl {
        unsafe extern "system" fn WaitOnSignal<Identity: IMFCameraSyncObject_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, timeoutinms: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCameraSyncObject_Impl::WaitOnSignal(this, core::mem::transmute_copy(&timeoutinms)).into()
        }
        unsafe extern "system" fn Shutdown<Identity: IMFCameraSyncObject_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCameraSyncObject_Impl::Shutdown(this)
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            WaitOnSignal: WaitOnSignal::<Identity, OFFSET>,
            Shutdown: Shutdown::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFCameraSyncObject as windows_core::Interface>::IID
    }
}
pub trait IMFCaptureEngine_Impl: Sized + windows_core::IUnknownImpl {
    fn Initialize(&self, peventcallback: Option<&IMFCaptureEngineOnEventCallback>, pattributes: Option<&IMFAttributes>, paudiosource: Option<&windows_core::IUnknown>, pvideosource: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn StartPreview(&self) -> windows_core::Result<()>;
    fn StopPreview(&self) -> windows_core::Result<()>;
    fn StartRecord(&self) -> windows_core::Result<()>;
    fn StopRecord(&self, bfinalize: super::super::Foundation::BOOL, bflushunprocessedsamples: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn TakePhoto(&self) -> windows_core::Result<()>;
    fn GetSink(&self, mfcaptureenginesinktype: MF_CAPTURE_ENGINE_SINK_TYPE) -> windows_core::Result<IMFCaptureSink>;
    fn GetSource(&self) -> windows_core::Result<IMFCaptureSource>;
}
impl windows_core::RuntimeName for IMFCaptureEngine {}
impl IMFCaptureEngine_Vtbl {
    pub const fn new<Identity: IMFCaptureEngine_Impl, const OFFSET: isize>() -> IMFCaptureEngine_Vtbl {
        unsafe extern "system" fn Initialize<Identity: IMFCaptureEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, peventcallback: *mut core::ffi::c_void, pattributes: *mut core::ffi::c_void, paudiosource: *mut core::ffi::c_void, pvideosource: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureEngine_Impl::Initialize(this, windows_core::from_raw_borrowed(&peventcallback), windows_core::from_raw_borrowed(&pattributes), windows_core::from_raw_borrowed(&paudiosource), windows_core::from_raw_borrowed(&pvideosource)).into()
        }
        unsafe extern "system" fn StartPreview<Identity: IMFCaptureEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureEngine_Impl::StartPreview(this).into()
        }
        unsafe extern "system" fn StopPreview<Identity: IMFCaptureEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureEngine_Impl::StopPreview(this).into()
        }
        unsafe extern "system" fn StartRecord<Identity: IMFCaptureEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureEngine_Impl::StartRecord(this).into()
        }
        unsafe extern "system" fn StopRecord<Identity: IMFCaptureEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bfinalize: super::super::Foundation::BOOL, bflushunprocessedsamples: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureEngine_Impl::StopRecord(this, core::mem::transmute_copy(&bfinalize), core::mem::transmute_copy(&bflushunprocessedsamples)).into()
        }
        unsafe extern "system" fn TakePhoto<Identity: IMFCaptureEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureEngine_Impl::TakePhoto(this).into()
        }
        unsafe extern "system" fn GetSink<Identity: IMFCaptureEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, mfcaptureenginesinktype: MF_CAPTURE_ENGINE_SINK_TYPE, ppsink: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFCaptureEngine_Impl::GetSink(this, core::mem::transmute_copy(&mfcaptureenginesinktype)) {
                Ok(ok__) => {
                    ppsink.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSource<Identity: IMFCaptureEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppsource: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFCaptureEngine_Impl::GetSource(this) {
                Ok(ok__) => {
                    ppsource.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Initialize: Initialize::<Identity, OFFSET>,
            StartPreview: StartPreview::<Identity, OFFSET>,
            StopPreview: StopPreview::<Identity, OFFSET>,
            StartRecord: StartRecord::<Identity, OFFSET>,
            StopRecord: StopRecord::<Identity, OFFSET>,
            TakePhoto: TakePhoto::<Identity, OFFSET>,
            GetSink: GetSink::<Identity, OFFSET>,
            GetSource: GetSource::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFCaptureEngine as windows_core::Interface>::IID
    }
}
pub trait IMFCaptureEngineClassFactory_Impl: Sized + windows_core::IUnknownImpl {
    fn CreateInstance(&self, clsid: *const windows_core::GUID, riid: *const windows_core::GUID, ppvobject: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFCaptureEngineClassFactory {}
impl IMFCaptureEngineClassFactory_Vtbl {
    pub const fn new<Identity: IMFCaptureEngineClassFactory_Impl, const OFFSET: isize>() -> IMFCaptureEngineClassFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Identity: IMFCaptureEngineClassFactory_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clsid: *const windows_core::GUID, riid: *const windows_core::GUID, ppvobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureEngineClassFactory_Impl::CreateInstance(this, core::mem::transmute_copy(&clsid), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvobject)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), CreateInstance: CreateInstance::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFCaptureEngineClassFactory as windows_core::Interface>::IID
    }
}
pub trait IMFCaptureEngineOnEventCallback_Impl: Sized + windows_core::IUnknownImpl {
    fn OnEvent(&self, pevent: Option<&IMFMediaEvent>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFCaptureEngineOnEventCallback {}
impl IMFCaptureEngineOnEventCallback_Vtbl {
    pub const fn new<Identity: IMFCaptureEngineOnEventCallback_Impl, const OFFSET: isize>() -> IMFCaptureEngineOnEventCallback_Vtbl {
        unsafe extern "system" fn OnEvent<Identity: IMFCaptureEngineOnEventCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pevent: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureEngineOnEventCallback_Impl::OnEvent(this, windows_core::from_raw_borrowed(&pevent)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), OnEvent: OnEvent::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFCaptureEngineOnEventCallback as windows_core::Interface>::IID
    }
}
pub trait IMFCaptureEngineOnSampleCallback_Impl: Sized + windows_core::IUnknownImpl {
    fn OnSample(&self, psample: Option<&IMFSample>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFCaptureEngineOnSampleCallback {}
impl IMFCaptureEngineOnSampleCallback_Vtbl {
    pub const fn new<Identity: IMFCaptureEngineOnSampleCallback_Impl, const OFFSET: isize>() -> IMFCaptureEngineOnSampleCallback_Vtbl {
        unsafe extern "system" fn OnSample<Identity: IMFCaptureEngineOnSampleCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psample: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureEngineOnSampleCallback_Impl::OnSample(this, windows_core::from_raw_borrowed(&psample)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), OnSample: OnSample::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFCaptureEngineOnSampleCallback as windows_core::Interface>::IID
    }
}
pub trait IMFCaptureEngineOnSampleCallback2_Impl: Sized + IMFCaptureEngineOnSampleCallback_Impl {
    fn OnSynchronizedEvent(&self, pevent: Option<&IMFMediaEvent>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFCaptureEngineOnSampleCallback2 {}
impl IMFCaptureEngineOnSampleCallback2_Vtbl {
    pub const fn new<Identity: IMFCaptureEngineOnSampleCallback2_Impl, const OFFSET: isize>() -> IMFCaptureEngineOnSampleCallback2_Vtbl {
        unsafe extern "system" fn OnSynchronizedEvent<Identity: IMFCaptureEngineOnSampleCallback2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pevent: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureEngineOnSampleCallback2_Impl::OnSynchronizedEvent(this, windows_core::from_raw_borrowed(&pevent)).into()
        }
        Self { base__: IMFCaptureEngineOnSampleCallback_Vtbl::new::<Identity, OFFSET>(), OnSynchronizedEvent: OnSynchronizedEvent::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFCaptureEngineOnSampleCallback2 as windows_core::Interface>::IID || iid == &<IMFCaptureEngineOnSampleCallback as windows_core::Interface>::IID
    }
}
pub trait IMFCapturePhotoConfirmation_Impl: Sized + windows_core::IUnknownImpl {
    fn SetPhotoConfirmationCallback(&self, pnotificationcallback: Option<&IMFAsyncCallback>) -> windows_core::Result<()>;
    fn SetPixelFormat(&self, subtype: &windows_core::GUID) -> windows_core::Result<()>;
    fn GetPixelFormat(&self) -> windows_core::Result<windows_core::GUID>;
}
impl windows_core::RuntimeName for IMFCapturePhotoConfirmation {}
impl IMFCapturePhotoConfirmation_Vtbl {
    pub const fn new<Identity: IMFCapturePhotoConfirmation_Impl, const OFFSET: isize>() -> IMFCapturePhotoConfirmation_Vtbl {
        unsafe extern "system" fn SetPhotoConfirmationCallback<Identity: IMFCapturePhotoConfirmation_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pnotificationcallback: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCapturePhotoConfirmation_Impl::SetPhotoConfirmationCallback(this, windows_core::from_raw_borrowed(&pnotificationcallback)).into()
        }
        unsafe extern "system" fn SetPixelFormat<Identity: IMFCapturePhotoConfirmation_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, subtype: windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCapturePhotoConfirmation_Impl::SetPixelFormat(this, core::mem::transmute(&subtype)).into()
        }
        unsafe extern "system" fn GetPixelFormat<Identity: IMFCapturePhotoConfirmation_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, subtype: *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFCapturePhotoConfirmation_Impl::GetPixelFormat(this) {
                Ok(ok__) => {
                    subtype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetPhotoConfirmationCallback: SetPhotoConfirmationCallback::<Identity, OFFSET>,
            SetPixelFormat: SetPixelFormat::<Identity, OFFSET>,
            GetPixelFormat: GetPixelFormat::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFCapturePhotoConfirmation as windows_core::Interface>::IID
    }
}
pub trait IMFCapturePhotoSink_Impl: Sized + IMFCaptureSink_Impl {
    fn SetOutputFileName(&self, filename: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn SetSampleCallback(&self, pcallback: Option<&IMFCaptureEngineOnSampleCallback>) -> windows_core::Result<()>;
    fn SetOutputByteStream(&self, pbytestream: Option<&IMFByteStream>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFCapturePhotoSink {}
impl IMFCapturePhotoSink_Vtbl {
    pub const fn new<Identity: IMFCapturePhotoSink_Impl, const OFFSET: isize>() -> IMFCapturePhotoSink_Vtbl {
        unsafe extern "system" fn SetOutputFileName<Identity: IMFCapturePhotoSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, filename: windows_core::PCWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCapturePhotoSink_Impl::SetOutputFileName(this, core::mem::transmute(&filename)).into()
        }
        unsafe extern "system" fn SetSampleCallback<Identity: IMFCapturePhotoSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcallback: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCapturePhotoSink_Impl::SetSampleCallback(this, windows_core::from_raw_borrowed(&pcallback)).into()
        }
        unsafe extern "system" fn SetOutputByteStream<Identity: IMFCapturePhotoSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbytestream: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCapturePhotoSink_Impl::SetOutputByteStream(this, windows_core::from_raw_borrowed(&pbytestream)).into()
        }
        Self {
            base__: IMFCaptureSink_Vtbl::new::<Identity, OFFSET>(),
            SetOutputFileName: SetOutputFileName::<Identity, OFFSET>,
            SetSampleCallback: SetSampleCallback::<Identity, OFFSET>,
            SetOutputByteStream: SetOutputByteStream::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFCapturePhotoSink as windows_core::Interface>::IID || iid == &<IMFCaptureSink as windows_core::Interface>::IID
    }
}
pub trait IMFCapturePreviewSink_Impl: Sized + IMFCaptureSink_Impl {
    fn SetRenderHandle(&self, handle: super::super::Foundation::HANDLE) -> windows_core::Result<()>;
    fn SetRenderSurface(&self, psurface: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn UpdateVideo(&self, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const super::super::Foundation::COLORREF) -> windows_core::Result<()>;
    fn SetSampleCallback(&self, dwstreamsinkindex: u32, pcallback: Option<&IMFCaptureEngineOnSampleCallback>) -> windows_core::Result<()>;
    fn GetMirrorState(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn SetMirrorState(&self, fmirrorstate: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn GetRotation(&self, dwstreamindex: u32) -> windows_core::Result<u32>;
    fn SetRotation(&self, dwstreamindex: u32, dwrotationvalue: u32) -> windows_core::Result<()>;
    fn SetCustomSink(&self, pmediasink: Option<&IMFMediaSink>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFCapturePreviewSink {}
impl IMFCapturePreviewSink_Vtbl {
    pub const fn new<Identity: IMFCapturePreviewSink_Impl, const OFFSET: isize>() -> IMFCapturePreviewSink_Vtbl {
        unsafe extern "system" fn SetRenderHandle<Identity: IMFCapturePreviewSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, handle: super::super::Foundation::HANDLE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCapturePreviewSink_Impl::SetRenderHandle(this, core::mem::transmute_copy(&handle)).into()
        }
        unsafe extern "system" fn SetRenderSurface<Identity: IMFCapturePreviewSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psurface: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCapturePreviewSink_Impl::SetRenderSurface(this, windows_core::from_raw_borrowed(&psurface)).into()
        }
        unsafe extern "system" fn UpdateVideo<Identity: IMFCapturePreviewSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const super::super::Foundation::COLORREF) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCapturePreviewSink_Impl::UpdateVideo(this, core::mem::transmute_copy(&psrc), core::mem::transmute_copy(&pdst), core::mem::transmute_copy(&pborderclr)).into()
        }
        unsafe extern "system" fn SetSampleCallback<Identity: IMFCapturePreviewSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamsinkindex: u32, pcallback: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCapturePreviewSink_Impl::SetSampleCallback(this, core::mem::transmute_copy(&dwstreamsinkindex), windows_core::from_raw_borrowed(&pcallback)).into()
        }
        unsafe extern "system" fn GetMirrorState<Identity: IMFCapturePreviewSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfmirrorstate: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFCapturePreviewSink_Impl::GetMirrorState(this) {
                Ok(ok__) => {
                    pfmirrorstate.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMirrorState<Identity: IMFCapturePreviewSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fmirrorstate: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCapturePreviewSink_Impl::SetMirrorState(this, core::mem::transmute_copy(&fmirrorstate)).into()
        }
        unsafe extern "system" fn GetRotation<Identity: IMFCapturePreviewSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, pdwrotationvalue: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFCapturePreviewSink_Impl::GetRotation(this, core::mem::transmute_copy(&dwstreamindex)) {
                Ok(ok__) => {
                    pdwrotationvalue.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRotation<Identity: IMFCapturePreviewSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, dwrotationvalue: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCapturePreviewSink_Impl::SetRotation(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&dwrotationvalue)).into()
        }
        unsafe extern "system" fn SetCustomSink<Identity: IMFCapturePreviewSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmediasink: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCapturePreviewSink_Impl::SetCustomSink(this, windows_core::from_raw_borrowed(&pmediasink)).into()
        }
        Self {
            base__: IMFCaptureSink_Vtbl::new::<Identity, OFFSET>(),
            SetRenderHandle: SetRenderHandle::<Identity, OFFSET>,
            SetRenderSurface: SetRenderSurface::<Identity, OFFSET>,
            UpdateVideo: UpdateVideo::<Identity, OFFSET>,
            SetSampleCallback: SetSampleCallback::<Identity, OFFSET>,
            GetMirrorState: GetMirrorState::<Identity, OFFSET>,
            SetMirrorState: SetMirrorState::<Identity, OFFSET>,
            GetRotation: GetRotation::<Identity, OFFSET>,
            SetRotation: SetRotation::<Identity, OFFSET>,
            SetCustomSink: SetCustomSink::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFCapturePreviewSink as windows_core::Interface>::IID || iid == &<IMFCaptureSink as windows_core::Interface>::IID
    }
}
pub trait IMFCaptureRecordSink_Impl: Sized + IMFCaptureSink_Impl {
    fn SetOutputByteStream(&self, pbytestream: Option<&IMFByteStream>, guidcontainertype: *const windows_core::GUID) -> windows_core::Result<()>;
    fn SetOutputFileName(&self, filename: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn SetSampleCallback(&self, dwstreamsinkindex: u32, pcallback: Option<&IMFCaptureEngineOnSampleCallback>) -> windows_core::Result<()>;
    fn SetCustomSink(&self, pmediasink: Option<&IMFMediaSink>) -> windows_core::Result<()>;
    fn GetRotation(&self, dwstreamindex: u32) -> windows_core::Result<u32>;
    fn SetRotation(&self, dwstreamindex: u32, dwrotationvalue: u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFCaptureRecordSink {}
impl IMFCaptureRecordSink_Vtbl {
    pub const fn new<Identity: IMFCaptureRecordSink_Impl, const OFFSET: isize>() -> IMFCaptureRecordSink_Vtbl {
        unsafe extern "system" fn SetOutputByteStream<Identity: IMFCaptureRecordSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbytestream: *mut core::ffi::c_void, guidcontainertype: *const windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureRecordSink_Impl::SetOutputByteStream(this, windows_core::from_raw_borrowed(&pbytestream), core::mem::transmute_copy(&guidcontainertype)).into()
        }
        unsafe extern "system" fn SetOutputFileName<Identity: IMFCaptureRecordSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, filename: windows_core::PCWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureRecordSink_Impl::SetOutputFileName(this, core::mem::transmute(&filename)).into()
        }
        unsafe extern "system" fn SetSampleCallback<Identity: IMFCaptureRecordSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamsinkindex: u32, pcallback: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureRecordSink_Impl::SetSampleCallback(this, core::mem::transmute_copy(&dwstreamsinkindex), windows_core::from_raw_borrowed(&pcallback)).into()
        }
        unsafe extern "system" fn SetCustomSink<Identity: IMFCaptureRecordSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmediasink: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureRecordSink_Impl::SetCustomSink(this, windows_core::from_raw_borrowed(&pmediasink)).into()
        }
        unsafe extern "system" fn GetRotation<Identity: IMFCaptureRecordSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, pdwrotationvalue: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFCaptureRecordSink_Impl::GetRotation(this, core::mem::transmute_copy(&dwstreamindex)) {
                Ok(ok__) => {
                    pdwrotationvalue.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRotation<Identity: IMFCaptureRecordSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, dwrotationvalue: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureRecordSink_Impl::SetRotation(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&dwrotationvalue)).into()
        }
        Self {
            base__: IMFCaptureSink_Vtbl::new::<Identity, OFFSET>(),
            SetOutputByteStream: SetOutputByteStream::<Identity, OFFSET>,
            SetOutputFileName: SetOutputFileName::<Identity, OFFSET>,
            SetSampleCallback: SetSampleCallback::<Identity, OFFSET>,
            SetCustomSink: SetCustomSink::<Identity, OFFSET>,
            GetRotation: GetRotation::<Identity, OFFSET>,
            SetRotation: SetRotation::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFCaptureRecordSink as windows_core::Interface>::IID || iid == &<IMFCaptureSink as windows_core::Interface>::IID
    }
}
pub trait IMFCaptureSink_Impl: Sized + windows_core::IUnknownImpl {
    fn GetOutputMediaType(&self, dwsinkstreamindex: u32, ppmediatype: *mut Option<IMFMediaType>) -> windows_core::Result<()>;
    fn GetService(&self, dwsinkstreamindex: u32, rguidservice: *const windows_core::GUID, riid: *const windows_core::GUID, ppunknown: *mut Option<windows_core::IUnknown>) -> windows_core::Result<()>;
    fn AddStream(&self, dwsourcestreamindex: u32, pmediatype: Option<&IMFMediaType>, pattributes: Option<&IMFAttributes>, pdwsinkstreamindex: *mut u32) -> windows_core::Result<()>;
    fn Prepare(&self) -> windows_core::Result<()>;
    fn RemoveAllStreams(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFCaptureSink {}
impl IMFCaptureSink_Vtbl {
    pub const fn new<Identity: IMFCaptureSink_Impl, const OFFSET: isize>() -> IMFCaptureSink_Vtbl {
        unsafe extern "system" fn GetOutputMediaType<Identity: IMFCaptureSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwsinkstreamindex: u32, ppmediatype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureSink_Impl::GetOutputMediaType(this, core::mem::transmute_copy(&dwsinkstreamindex), core::mem::transmute_copy(&ppmediatype)).into()
        }
        unsafe extern "system" fn GetService<Identity: IMFCaptureSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwsinkstreamindex: u32, rguidservice: *const windows_core::GUID, riid: *const windows_core::GUID, ppunknown: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureSink_Impl::GetService(this, core::mem::transmute_copy(&dwsinkstreamindex), core::mem::transmute_copy(&rguidservice), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppunknown)).into()
        }
        unsafe extern "system" fn AddStream<Identity: IMFCaptureSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwsourcestreamindex: u32, pmediatype: *mut core::ffi::c_void, pattributes: *mut core::ffi::c_void, pdwsinkstreamindex: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureSink_Impl::AddStream(this, core::mem::transmute_copy(&dwsourcestreamindex), windows_core::from_raw_borrowed(&pmediatype), windows_core::from_raw_borrowed(&pattributes), core::mem::transmute_copy(&pdwsinkstreamindex)).into()
        }
        unsafe extern "system" fn Prepare<Identity: IMFCaptureSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureSink_Impl::Prepare(this).into()
        }
        unsafe extern "system" fn RemoveAllStreams<Identity: IMFCaptureSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureSink_Impl::RemoveAllStreams(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetOutputMediaType: GetOutputMediaType::<Identity, OFFSET>,
            GetService: GetService::<Identity, OFFSET>,
            AddStream: AddStream::<Identity, OFFSET>,
            Prepare: Prepare::<Identity, OFFSET>,
            RemoveAllStreams: RemoveAllStreams::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFCaptureSink as windows_core::Interface>::IID
    }
}
pub trait IMFCaptureSink2_Impl: Sized + IMFCaptureSink_Impl {
    fn SetOutputMediaType(&self, dwstreamindex: u32, pmediatype: Option<&IMFMediaType>, pencodingattributes: Option<&IMFAttributes>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFCaptureSink2 {}
impl IMFCaptureSink2_Vtbl {
    pub const fn new<Identity: IMFCaptureSink2_Impl, const OFFSET: isize>() -> IMFCaptureSink2_Vtbl {
        unsafe extern "system" fn SetOutputMediaType<Identity: IMFCaptureSink2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, pmediatype: *mut core::ffi::c_void, pencodingattributes: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureSink2_Impl::SetOutputMediaType(this, core::mem::transmute_copy(&dwstreamindex), windows_core::from_raw_borrowed(&pmediatype), windows_core::from_raw_borrowed(&pencodingattributes)).into()
        }
        Self { base__: IMFCaptureSink_Vtbl::new::<Identity, OFFSET>(), SetOutputMediaType: SetOutputMediaType::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFCaptureSink2 as windows_core::Interface>::IID || iid == &<IMFCaptureSink as windows_core::Interface>::IID
    }
}
pub trait IMFCaptureSource_Impl: Sized + windows_core::IUnknownImpl {
    fn GetCaptureDeviceSource(&self, mfcaptureenginedevicetype: MF_CAPTURE_ENGINE_DEVICE_TYPE, ppmediasource: *mut Option<IMFMediaSource>) -> windows_core::Result<()>;
    fn GetCaptureDeviceActivate(&self, mfcaptureenginedevicetype: MF_CAPTURE_ENGINE_DEVICE_TYPE, ppactivate: *mut Option<IMFActivate>) -> windows_core::Result<()>;
    fn GetService(&self, rguidservice: *const windows_core::GUID, riid: *const windows_core::GUID, ppunknown: *mut Option<windows_core::IUnknown>) -> windows_core::Result<()>;
    fn AddEffect(&self, dwsourcestreamindex: u32, punknown: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn RemoveEffect(&self, dwsourcestreamindex: u32, punknown: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn RemoveAllEffects(&self, dwsourcestreamindex: u32) -> windows_core::Result<()>;
    fn GetAvailableDeviceMediaType(&self, dwsourcestreamindex: u32, dwmediatypeindex: u32, ppmediatype: *mut Option<IMFMediaType>) -> windows_core::Result<()>;
    fn SetCurrentDeviceMediaType(&self, dwsourcestreamindex: u32, pmediatype: Option<&IMFMediaType>) -> windows_core::Result<()>;
    fn GetCurrentDeviceMediaType(&self, dwsourcestreamindex: u32) -> windows_core::Result<IMFMediaType>;
    fn GetDeviceStreamCount(&self) -> windows_core::Result<u32>;
    fn GetDeviceStreamCategory(&self, dwsourcestreamindex: u32) -> windows_core::Result<MF_CAPTURE_ENGINE_STREAM_CATEGORY>;
    fn GetMirrorState(&self, dwstreamindex: u32) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn SetMirrorState(&self, dwstreamindex: u32, fmirrorstate: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn GetStreamIndexFromFriendlyName(&self, uifriendlyname: u32) -> windows_core::Result<u32>;
}
impl windows_core::RuntimeName for IMFCaptureSource {}
impl IMFCaptureSource_Vtbl {
    pub const fn new<Identity: IMFCaptureSource_Impl, const OFFSET: isize>() -> IMFCaptureSource_Vtbl {
        unsafe extern "system" fn GetCaptureDeviceSource<Identity: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, mfcaptureenginedevicetype: MF_CAPTURE_ENGINE_DEVICE_TYPE, ppmediasource: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureSource_Impl::GetCaptureDeviceSource(this, core::mem::transmute_copy(&mfcaptureenginedevicetype), core::mem::transmute_copy(&ppmediasource)).into()
        }
        unsafe extern "system" fn GetCaptureDeviceActivate<Identity: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, mfcaptureenginedevicetype: MF_CAPTURE_ENGINE_DEVICE_TYPE, ppactivate: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureSource_Impl::GetCaptureDeviceActivate(this, core::mem::transmute_copy(&mfcaptureenginedevicetype), core::mem::transmute_copy(&ppactivate)).into()
        }
        unsafe extern "system" fn GetService<Identity: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, rguidservice: *const windows_core::GUID, riid: *const windows_core::GUID, ppunknown: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureSource_Impl::GetService(this, core::mem::transmute_copy(&rguidservice), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppunknown)).into()
        }
        unsafe extern "system" fn AddEffect<Identity: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwsourcestreamindex: u32, punknown: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureSource_Impl::AddEffect(this, core::mem::transmute_copy(&dwsourcestreamindex), windows_core::from_raw_borrowed(&punknown)).into()
        }
        unsafe extern "system" fn RemoveEffect<Identity: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwsourcestreamindex: u32, punknown: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureSource_Impl::RemoveEffect(this, core::mem::transmute_copy(&dwsourcestreamindex), windows_core::from_raw_borrowed(&punknown)).into()
        }
        unsafe extern "system" fn RemoveAllEffects<Identity: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwsourcestreamindex: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureSource_Impl::RemoveAllEffects(this, core::mem::transmute_copy(&dwsourcestreamindex)).into()
        }
        unsafe extern "system" fn GetAvailableDeviceMediaType<Identity: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwsourcestreamindex: u32, dwmediatypeindex: u32, ppmediatype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureSource_Impl::GetAvailableDeviceMediaType(this, core::mem::transmute_copy(&dwsourcestreamindex), core::mem::transmute_copy(&dwmediatypeindex), core::mem::transmute_copy(&ppmediatype)).into()
        }
        unsafe extern "system" fn SetCurrentDeviceMediaType<Identity: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwsourcestreamindex: u32, pmediatype: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureSource_Impl::SetCurrentDeviceMediaType(this, core::mem::transmute_copy(&dwsourcestreamindex), windows_core::from_raw_borrowed(&pmediatype)).into()
        }
        unsafe extern "system" fn GetCurrentDeviceMediaType<Identity: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwsourcestreamindex: u32, ppmediatype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFCaptureSource_Impl::GetCurrentDeviceMediaType(this, core::mem::transmute_copy(&dwsourcestreamindex)) {
                Ok(ok__) => {
                    ppmediatype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDeviceStreamCount<Identity: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwstreamcount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFCaptureSource_Impl::GetDeviceStreamCount(this) {
                Ok(ok__) => {
                    pdwstreamcount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDeviceStreamCategory<Identity: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwsourcestreamindex: u32, pstreamcategory: *mut MF_CAPTURE_ENGINE_STREAM_CATEGORY) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFCaptureSource_Impl::GetDeviceStreamCategory(this, core::mem::transmute_copy(&dwsourcestreamindex)) {
                Ok(ok__) => {
                    pstreamcategory.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMirrorState<Identity: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, pfmirrorstate: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFCaptureSource_Impl::GetMirrorState(this, core::mem::transmute_copy(&dwstreamindex)) {
                Ok(ok__) => {
                    pfmirrorstate.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMirrorState<Identity: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, fmirrorstate: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCaptureSource_Impl::SetMirrorState(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&fmirrorstate)).into()
        }
        unsafe extern "system" fn GetStreamIndexFromFriendlyName<Identity: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, uifriendlyname: u32, pdwactualstreamindex: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFCaptureSource_Impl::GetStreamIndexFromFriendlyName(this, core::mem::transmute_copy(&uifriendlyname)) {
                Ok(ok__) => {
                    pdwactualstreamindex.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetCaptureDeviceSource: GetCaptureDeviceSource::<Identity, OFFSET>,
            GetCaptureDeviceActivate: GetCaptureDeviceActivate::<Identity, OFFSET>,
            GetService: GetService::<Identity, OFFSET>,
            AddEffect: AddEffect::<Identity, OFFSET>,
            RemoveEffect: RemoveEffect::<Identity, OFFSET>,
            RemoveAllEffects: RemoveAllEffects::<Identity, OFFSET>,
            GetAvailableDeviceMediaType: GetAvailableDeviceMediaType::<Identity, OFFSET>,
            SetCurrentDeviceMediaType: SetCurrentDeviceMediaType::<Identity, OFFSET>,
            GetCurrentDeviceMediaType: GetCurrentDeviceMediaType::<Identity, OFFSET>,
            GetDeviceStreamCount: GetDeviceStreamCount::<Identity, OFFSET>,
            GetDeviceStreamCategory: GetDeviceStreamCategory::<Identity, OFFSET>,
            GetMirrorState: GetMirrorState::<Identity, OFFSET>,
            SetMirrorState: SetMirrorState::<Identity, OFFSET>,
            GetStreamIndexFromFriendlyName: GetStreamIndexFromFriendlyName::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFCaptureSource as windows_core::Interface>::IID
    }
}
pub trait IMFCdmSuspendNotify_Impl: Sized + windows_core::IUnknownImpl {
    fn Begin(&self) -> windows_core::Result<()>;
    fn End(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFCdmSuspendNotify {}
impl IMFCdmSuspendNotify_Vtbl {
    pub const fn new<Identity: IMFCdmSuspendNotify_Impl, const OFFSET: isize>() -> IMFCdmSuspendNotify_Vtbl {
        unsafe extern "system" fn Begin<Identity: IMFCdmSuspendNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCdmSuspendNotify_Impl::Begin(this).into()
        }
        unsafe extern "system" fn End<Identity: IMFCdmSuspendNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCdmSuspendNotify_Impl::End(this).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Begin: Begin::<Identity, OFFSET>, End: End::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFCdmSuspendNotify as windows_core::Interface>::IID
    }
}
pub trait IMFClock_Impl: Sized + windows_core::IUnknownImpl {
    fn GetClockCharacteristics(&self) -> windows_core::Result<u32>;
    fn GetCorrelatedTime(&self, dwreserved: u32, pllclocktime: *mut i64, phnssystemtime: *mut i64) -> windows_core::Result<()>;
    fn GetContinuityKey(&self) -> windows_core::Result<u32>;
    fn GetState(&self, dwreserved: u32) -> windows_core::Result<MFCLOCK_STATE>;
    fn GetProperties(&self, pclockproperties: *mut MFCLOCK_PROPERTIES) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFClock {}
impl IMFClock_Vtbl {
    pub const fn new<Identity: IMFClock_Impl, const OFFSET: isize>() -> IMFClock_Vtbl {
        unsafe extern "system" fn GetClockCharacteristics<Identity: IMFClock_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwcharacteristics: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFClock_Impl::GetClockCharacteristics(this) {
                Ok(ok__) => {
                    pdwcharacteristics.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCorrelatedTime<Identity: IMFClock_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwreserved: u32, pllclocktime: *mut i64, phnssystemtime: *mut i64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFClock_Impl::GetCorrelatedTime(this, core::mem::transmute_copy(&dwreserved), core::mem::transmute_copy(&pllclocktime), core::mem::transmute_copy(&phnssystemtime)).into()
        }
        unsafe extern "system" fn GetContinuityKey<Identity: IMFClock_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwcontinuitykey: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFClock_Impl::GetContinuityKey(this) {
                Ok(ok__) => {
                    pdwcontinuitykey.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetState<Identity: IMFClock_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwreserved: u32, peclockstate: *mut MFCLOCK_STATE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFClock_Impl::GetState(this, core::mem::transmute_copy(&dwreserved)) {
                Ok(ok__) => {
                    peclockstate.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProperties<Identity: IMFClock_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pclockproperties: *mut MFCLOCK_PROPERTIES) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFClock_Impl::GetProperties(this, core::mem::transmute_copy(&pclockproperties)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetClockCharacteristics: GetClockCharacteristics::<Identity, OFFSET>,
            GetCorrelatedTime: GetCorrelatedTime::<Identity, OFFSET>,
            GetContinuityKey: GetContinuityKey::<Identity, OFFSET>,
            GetState: GetState::<Identity, OFFSET>,
            GetProperties: GetProperties::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFClock as windows_core::Interface>::IID
    }
}
pub trait IMFClockConsumer_Impl: Sized + windows_core::IUnknownImpl {
    fn SetPresentationClock(&self, ppresentationclock: Option<&IMFPresentationClock>) -> windows_core::Result<()>;
    fn GetPresentationClock(&self) -> windows_core::Result<IMFPresentationClock>;
}
impl windows_core::RuntimeName for IMFClockConsumer {}
impl IMFClockConsumer_Vtbl {
    pub const fn new<Identity: IMFClockConsumer_Impl, const OFFSET: isize>() -> IMFClockConsumer_Vtbl {
        unsafe extern "system" fn SetPresentationClock<Identity: IMFClockConsumer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppresentationclock: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFClockConsumer_Impl::SetPresentationClock(this, windows_core::from_raw_borrowed(&ppresentationclock)).into()
        }
        unsafe extern "system" fn GetPresentationClock<Identity: IMFClockConsumer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pppresentationclock: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFClockConsumer_Impl::GetPresentationClock(this) {
                Ok(ok__) => {
                    pppresentationclock.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetPresentationClock: SetPresentationClock::<Identity, OFFSET>,
            GetPresentationClock: GetPresentationClock::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFClockConsumer as windows_core::Interface>::IID
    }
}
pub trait IMFClockStateSink_Impl: Sized + windows_core::IUnknownImpl {
    fn OnClockStart(&self, hnssystemtime: i64, llclockstartoffset: i64) -> windows_core::Result<()>;
    fn OnClockStop(&self, hnssystemtime: i64) -> windows_core::Result<()>;
    fn OnClockPause(&self, hnssystemtime: i64) -> windows_core::Result<()>;
    fn OnClockRestart(&self, hnssystemtime: i64) -> windows_core::Result<()>;
    fn OnClockSetRate(&self, hnssystemtime: i64, flrate: f32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFClockStateSink {}
impl IMFClockStateSink_Vtbl {
    pub const fn new<Identity: IMFClockStateSink_Impl, const OFFSET: isize>() -> IMFClockStateSink_Vtbl {
        unsafe extern "system" fn OnClockStart<Identity: IMFClockStateSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hnssystemtime: i64, llclockstartoffset: i64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFClockStateSink_Impl::OnClockStart(this, core::mem::transmute_copy(&hnssystemtime), core::mem::transmute_copy(&llclockstartoffset)).into()
        }
        unsafe extern "system" fn OnClockStop<Identity: IMFClockStateSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hnssystemtime: i64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFClockStateSink_Impl::OnClockStop(this, core::mem::transmute_copy(&hnssystemtime)).into()
        }
        unsafe extern "system" fn OnClockPause<Identity: IMFClockStateSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hnssystemtime: i64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFClockStateSink_Impl::OnClockPause(this, core::mem::transmute_copy(&hnssystemtime)).into()
        }
        unsafe extern "system" fn OnClockRestart<Identity: IMFClockStateSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hnssystemtime: i64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFClockStateSink_Impl::OnClockRestart(this, core::mem::transmute_copy(&hnssystemtime)).into()
        }
        unsafe extern "system" fn OnClockSetRate<Identity: IMFClockStateSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hnssystemtime: i64, flrate: f32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFClockStateSink_Impl::OnClockSetRate(this, core::mem::transmute_copy(&hnssystemtime), core::mem::transmute_copy(&flrate)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            OnClockStart: OnClockStart::<Identity, OFFSET>,
            OnClockStop: OnClockStop::<Identity, OFFSET>,
            OnClockPause: OnClockPause::<Identity, OFFSET>,
            OnClockRestart: OnClockRestart::<Identity, OFFSET>,
            OnClockSetRate: OnClockSetRate::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFClockStateSink as windows_core::Interface>::IID
    }
}
pub trait IMFCollection_Impl: Sized + windows_core::IUnknownImpl {
    fn GetElementCount(&self) -> windows_core::Result<u32>;
    fn GetElement(&self, dwelementindex: u32) -> windows_core::Result<windows_core::IUnknown>;
    fn AddElement(&self, punkelement: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn RemoveElement(&self, dwelementindex: u32) -> windows_core::Result<windows_core::IUnknown>;
    fn InsertElementAt(&self, dwindex: u32, punknown: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn RemoveAllElements(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFCollection {}
impl IMFCollection_Vtbl {
    pub const fn new<Identity: IMFCollection_Impl, const OFFSET: isize>() -> IMFCollection_Vtbl {
        unsafe extern "system" fn GetElementCount<Identity: IMFCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcelements: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFCollection_Impl::GetElementCount(this) {
                Ok(ok__) => {
                    pcelements.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetElement<Identity: IMFCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwelementindex: u32, ppunkelement: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFCollection_Impl::GetElement(this, core::mem::transmute_copy(&dwelementindex)) {
                Ok(ok__) => {
                    ppunkelement.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddElement<Identity: IMFCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, punkelement: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCollection_Impl::AddElement(this, windows_core::from_raw_borrowed(&punkelement)).into()
        }
        unsafe extern "system" fn RemoveElement<Identity: IMFCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwelementindex: u32, ppunkelement: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFCollection_Impl::RemoveElement(this, core::mem::transmute_copy(&dwelementindex)) {
                Ok(ok__) => {
                    ppunkelement.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InsertElementAt<Identity: IMFCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwindex: u32, punknown: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCollection_Impl::InsertElementAt(this, core::mem::transmute_copy(&dwindex), windows_core::from_raw_borrowed(&punknown)).into()
        }
        unsafe extern "system" fn RemoveAllElements<Identity: IMFCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFCollection_Impl::RemoveAllElements(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetElementCount: GetElementCount::<Identity, OFFSET>,
            GetElement: GetElement::<Identity, OFFSET>,
            AddElement: AddElement::<Identity, OFFSET>,
            RemoveElement: RemoveElement::<Identity, OFFSET>,
            InsertElementAt: InsertElementAt::<Identity, OFFSET>,
            RemoveAllElements: RemoveAllElements::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFCollection as windows_core::Interface>::IID
    }
}
pub trait IMFContentDecryptionModule_Impl: Sized + windows_core::IUnknownImpl {
    fn SetContentEnabler(&self, contentenabler: Option<&IMFContentEnabler>, result: Option<&IMFAsyncResult>) -> windows_core::Result<()>;
    fn GetSuspendNotify(&self) -> windows_core::Result<IMFCdmSuspendNotify>;
    fn SetPMPHostApp(&self, pmphostapp: Option<&IMFPMPHostApp>) -> windows_core::Result<()>;
    fn CreateSession(&self, sessiontype: MF_MEDIAKEYSESSION_TYPE, callbacks: Option<&IMFContentDecryptionModuleSessionCallbacks>) -> windows_core::Result<IMFContentDecryptionModuleSession>;
    fn SetServerCertificate(&self, certificate: *const u8, certificatesize: u32) -> windows_core::Result<()>;
    fn CreateTrustedInput(&self, contentinitdata: *const u8, contentinitdatasize: u32) -> windows_core::Result<IMFTrustedInput>;
    fn GetProtectionSystemIds(&self, systemids: *mut *mut windows_core::GUID, count: *mut u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFContentDecryptionModule {}
impl IMFContentDecryptionModule_Vtbl {
    pub const fn new<Identity: IMFContentDecryptionModule_Impl, const OFFSET: isize>() -> IMFContentDecryptionModule_Vtbl {
        unsafe extern "system" fn SetContentEnabler<Identity: IMFContentDecryptionModule_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, contentenabler: *mut core::ffi::c_void, result: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFContentDecryptionModule_Impl::SetContentEnabler(this, windows_core::from_raw_borrowed(&contentenabler), windows_core::from_raw_borrowed(&result)).into()
        }
        unsafe extern "system" fn GetSuspendNotify<Identity: IMFContentDecryptionModule_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, notify: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFContentDecryptionModule_Impl::GetSuspendNotify(this) {
                Ok(ok__) => {
                    notify.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPMPHostApp<Identity: IMFContentDecryptionModule_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmphostapp: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFContentDecryptionModule_Impl::SetPMPHostApp(this, windows_core::from_raw_borrowed(&pmphostapp)).into()
        }
        unsafe extern "system" fn CreateSession<Identity: IMFContentDecryptionModule_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, sessiontype: MF_MEDIAKEYSESSION_TYPE, callbacks: *mut core::ffi::c_void, session: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFContentDecryptionModule_Impl::CreateSession(this, core::mem::transmute_copy(&sessiontype), windows_core::from_raw_borrowed(&callbacks)) {
                Ok(ok__) => {
                    session.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetServerCertificate<Identity: IMFContentDecryptionModule_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, certificate: *const u8, certificatesize: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFContentDecryptionModule_Impl::SetServerCertificate(this, core::mem::transmute_copy(&certificate), core::mem::transmute_copy(&certificatesize)).into()
        }
        unsafe extern "system" fn CreateTrustedInput<Identity: IMFContentDecryptionModule_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, contentinitdata: *const u8, contentinitdatasize: u32, trustedinput: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFContentDecryptionModule_Impl::CreateTrustedInput(this, core::mem::transmute_copy(&contentinitdata), core::mem::transmute_copy(&contentinitdatasize)) {
                Ok(ok__) => {
                    trustedinput.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProtectionSystemIds<Identity: IMFContentDecryptionModule_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, systemids: *mut *mut windows_core::GUID, count: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFContentDecryptionModule_Impl::GetProtectionSystemIds(this, core::mem::transmute_copy(&systemids), core::mem::transmute_copy(&count)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetContentEnabler: SetContentEnabler::<Identity, OFFSET>,
            GetSuspendNotify: GetSuspendNotify::<Identity, OFFSET>,
            SetPMPHostApp: SetPMPHostApp::<Identity, OFFSET>,
            CreateSession: CreateSession::<Identity, OFFSET>,
            SetServerCertificate: SetServerCertificate::<Identity, OFFSET>,
            CreateTrustedInput: CreateTrustedInput::<Identity, OFFSET>,
            GetProtectionSystemIds: GetProtectionSystemIds::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFContentDecryptionModule as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub trait IMFContentDecryptionModuleAccess_Impl: Sized + windows_core::IUnknownImpl {
    fn CreateContentDecryptionModule(&self, contentdecryptionmoduleproperties: Option<&super::super::UI::Shell::PropertiesSystem::IPropertyStore>) -> windows_core::Result<IMFContentDecryptionModule>;
    fn GetConfiguration(&self) -> windows_core::Result<super::super::UI::Shell::PropertiesSystem::IPropertyStore>;
    fn GetKeySystem(&self) -> windows_core::Result<windows_core::PWSTR>;
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl windows_core::RuntimeName for IMFContentDecryptionModuleAccess {}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl IMFContentDecryptionModuleAccess_Vtbl {
    pub const fn new<Identity: IMFContentDecryptionModuleAccess_Impl, const OFFSET: isize>() -> IMFContentDecryptionModuleAccess_Vtbl {
        unsafe extern "system" fn CreateContentDecryptionModule<Identity: IMFContentDecryptionModuleAccess_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, contentdecryptionmoduleproperties: *mut core::ffi::c_void, contentdecryptionmodule: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFContentDecryptionModuleAccess_Impl::CreateContentDecryptionModule(this, windows_core::from_raw_borrowed(&contentdecryptionmoduleproperties)) {
                Ok(ok__) => {
                    contentdecryptionmodule.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetConfiguration<Identity: IMFContentDecryptionModuleAccess_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, configuration: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFContentDecryptionModuleAccess_Impl::GetConfiguration(this) {
                Ok(ok__) => {
                    configuration.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetKeySystem<Identity: IMFContentDecryptionModuleAccess_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, keysystem: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFContentDecryptionModuleAccess_Impl::GetKeySystem(this) {
                Ok(ok__) => {
                    keysystem.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            CreateContentDecryptionModule: CreateContentDecryptionModule::<Identity, OFFSET>,
            GetConfiguration: GetConfiguration::<Identity, OFFSET>,
            GetKeySystem: GetKeySystem::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFContentDecryptionModuleAccess as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub trait IMFContentDecryptionModuleFactory_Impl: Sized + windows_core::IUnknownImpl {
    fn IsTypeSupported(&self, keysystem: &windows_core::PCWSTR, contenttype: &windows_core::PCWSTR) -> super::super::Foundation::BOOL;
    fn CreateContentDecryptionModuleAccess(&self, keysystem: &windows_core::PCWSTR, configurations: *const Option<super::super::UI::Shell::PropertiesSystem::IPropertyStore>, numconfigurations: u32) -> windows_core::Result<IMFContentDecryptionModuleAccess>;
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl windows_core::RuntimeName for IMFContentDecryptionModuleFactory {}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl IMFContentDecryptionModuleFactory_Vtbl {
    pub const fn new<Identity: IMFContentDecryptionModuleFactory_Impl, const OFFSET: isize>() -> IMFContentDecryptionModuleFactory_Vtbl {
        unsafe extern "system" fn IsTypeSupported<Identity: IMFContentDecryptionModuleFactory_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, keysystem: windows_core::PCWSTR, contenttype: windows_core::PCWSTR) -> super::super::Foundation::BOOL {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFContentDecryptionModuleFactory_Impl::IsTypeSupported(this, core::mem::transmute(&keysystem), core::mem::transmute(&contenttype))
        }
        unsafe extern "system" fn CreateContentDecryptionModuleAccess<Identity: IMFContentDecryptionModuleFactory_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, keysystem: windows_core::PCWSTR, configurations: *const *mut core::ffi::c_void, numconfigurations: u32, contentdecryptionmoduleaccess: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFContentDecryptionModuleFactory_Impl::CreateContentDecryptionModuleAccess(this, core::mem::transmute(&keysystem), core::mem::transmute_copy(&configurations), core::mem::transmute_copy(&numconfigurations)) {
                Ok(ok__) => {
                    contentdecryptionmoduleaccess.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            IsTypeSupported: IsTypeSupported::<Identity, OFFSET>,
            CreateContentDecryptionModuleAccess: CreateContentDecryptionModuleAccess::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFContentDecryptionModuleFactory as windows_core::Interface>::IID
    }
}
pub trait IMFContentDecryptionModuleSession_Impl: Sized + windows_core::IUnknownImpl {
    fn GetSessionId(&self) -> windows_core::Result<windows_core::PWSTR>;
    fn GetExpiration(&self) -> windows_core::Result<f64>;
    fn GetKeyStatuses(&self, keystatuses: *mut *mut MFMediaKeyStatus, numkeystatuses: *mut u32) -> windows_core::Result<()>;
    fn Load(&self, sessionid: &windows_core::PCWSTR) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn GenerateRequest(&self, initdatatype: &windows_core::PCWSTR, initdata: *const u8, initdatasize: u32) -> windows_core::Result<()>;
    fn Update(&self, response: *const u8, responsesize: u32) -> windows_core::Result<()>;
    fn Close(&self) -> windows_core::Result<()>;
    fn Remove(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFContentDecryptionModuleSession {}
impl IMFContentDecryptionModuleSession_Vtbl {
    pub const fn new<Identity: IMFContentDecryptionModuleSession_Impl, const OFFSET: isize>() -> IMFContentDecryptionModuleSession_Vtbl {
        unsafe extern "system" fn GetSessionId<Identity: IMFContentDecryptionModuleSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, sessionid: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFContentDecryptionModuleSession_Impl::GetSessionId(this) {
                Ok(ok__) => {
                    sessionid.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetExpiration<Identity: IMFContentDecryptionModuleSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, expiration: *mut f64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFContentDecryptionModuleSession_Impl::GetExpiration(this) {
                Ok(ok__) => {
                    expiration.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetKeyStatuses<Identity: IMFContentDecryptionModuleSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, keystatuses: *mut *mut MFMediaKeyStatus, numkeystatuses: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFContentDecryptionModuleSession_Impl::GetKeyStatuses(this, core::mem::transmute_copy(&keystatuses), core::mem::transmute_copy(&numkeystatuses)).into()
        }
        unsafe extern "system" fn Load<Identity: IMFContentDecryptionModuleSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, sessionid: windows_core::PCWSTR, loaded: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFContentDecryptionModuleSession_Impl::Load(this, core::mem::transmute(&sessionid)) {
                Ok(ok__) => {
                    loaded.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GenerateRequest<Identity: IMFContentDecryptionModuleSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, initdatatype: windows_core::PCWSTR, initdata: *const u8, initdatasize: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFContentDecryptionModuleSession_Impl::GenerateRequest(this, core::mem::transmute(&initdatatype), core::mem::transmute_copy(&initdata), core::mem::transmute_copy(&initdatasize)).into()
        }
        unsafe extern "system" fn Update<Identity: IMFContentDecryptionModuleSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, response: *const u8, responsesize: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFContentDecryptionModuleSession_Impl::Update(this, core::mem::transmute_copy(&response), core::mem::transmute_copy(&responsesize)).into()
        }
        unsafe extern "system" fn Close<Identity: IMFContentDecryptionModuleSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFContentDecryptionModuleSession_Impl::Close(this).into()
        }
        unsafe extern "system" fn Remove<Identity: IMFContentDecryptionModuleSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFContentDecryptionModuleSession_Impl::Remove(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetSessionId: GetSessionId::<Identity, OFFSET>,
            GetExpiration: GetExpiration::<Identity, OFFSET>,
            GetKeyStatuses: GetKeyStatuses::<Identity, OFFSET>,
            Load: Load::<Identity, OFFSET>,
            GenerateRequest: GenerateRequest::<Identity, OFFSET>,
            Update: Update::<Identity, OFFSET>,
            Close: Close::<Identity, OFFSET>,
            Remove: Remove::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFContentDecryptionModuleSession as windows_core::Interface>::IID
    }
}
pub trait IMFContentDecryptionModuleSessionCallbacks_Impl: Sized + windows_core::IUnknownImpl {
    fn KeyMessage(&self, messagetype: MF_MEDIAKEYSESSION_MESSAGETYPE, message: *const u8, messagesize: u32, destinationurl: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn KeyStatusChanged(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFContentDecryptionModuleSessionCallbacks {}
impl IMFContentDecryptionModuleSessionCallbacks_Vtbl {
    pub const fn new<Identity: IMFContentDecryptionModuleSessionCallbacks_Impl, const OFFSET: isize>() -> IMFContentDecryptionModuleSessionCallbacks_Vtbl {
        unsafe extern "system" fn KeyMessage<Identity: IMFContentDecryptionModuleSessionCallbacks_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, messagetype: MF_MEDIAKEYSESSION_MESSAGETYPE, message: *const u8, messagesize: u32, destinationurl: windows_core::PCWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFContentDecryptionModuleSessionCallbacks_Impl::KeyMessage(this, core::mem::transmute_copy(&messagetype), core::mem::transmute_copy(&message), core::mem::transmute_copy(&messagesize), core::mem::transmute(&destinationurl)).into()
        }
        unsafe extern "system" fn KeyStatusChanged<Identity: IMFContentDecryptionModuleSessionCallbacks_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFContentDecryptionModuleSessionCallbacks_Impl::KeyStatusChanged(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            KeyMessage: KeyMessage::<Identity, OFFSET>,
            KeyStatusChanged: KeyStatusChanged::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFContentDecryptionModuleSessionCallbacks as windows_core::Interface>::IID
    }
}
pub trait IMFContentDecryptorContext_Impl: Sized + windows_core::IUnknownImpl {
    fn InitializeHardwareKey(&self, inputprivatedatabytecount: u32, inputprivatedata: *const core::ffi::c_void) -> windows_core::Result<u64>;
}
impl windows_core::RuntimeName for IMFContentDecryptorContext {}
impl IMFContentDecryptorContext_Vtbl {
    pub const fn new<Identity: IMFContentDecryptorContext_Impl, const OFFSET: isize>() -> IMFContentDecryptorContext_Vtbl {
        unsafe extern "system" fn InitializeHardwareKey<Identity: IMFContentDecryptorContext_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, inputprivatedatabytecount: u32, inputprivatedata: *const core::ffi::c_void, outputprivatedata: *mut u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFContentDecryptorContext_Impl::InitializeHardwareKey(this, core::mem::transmute_copy(&inputprivatedatabytecount), core::mem::transmute_copy(&inputprivatedata)) {
                Ok(ok__) => {
                    outputprivatedata.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), InitializeHardwareKey: InitializeHardwareKey::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFContentDecryptorContext as windows_core::Interface>::IID
    }
}
pub trait IMFContentEnabler_Impl: Sized + windows_core::IUnknownImpl {
    fn GetEnableType(&self) -> windows_core::Result<windows_core::GUID>;
    fn GetEnableURL(&self, ppwszurl: *mut windows_core::PWSTR, pcchurl: *mut u32, ptruststatus: *mut MF_URL_TRUST_STATUS) -> windows_core::Result<()>;
    fn GetEnableData(&self, ppbdata: *mut *mut u8, pcbdata: *mut u32) -> windows_core::Result<()>;
    fn IsAutomaticSupported(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn AutomaticEnable(&self) -> windows_core::Result<()>;
    fn MonitorEnable(&self) -> windows_core::Result<()>;
    fn Cancel(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFContentEnabler {}
impl IMFContentEnabler_Vtbl {
    pub const fn new<Identity: IMFContentEnabler_Impl, const OFFSET: isize>() -> IMFContentEnabler_Vtbl {
        unsafe extern "system" fn GetEnableType<Identity: IMFContentEnabler_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptype: *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFContentEnabler_Impl::GetEnableType(this) {
                Ok(ok__) => {
                    ptype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEnableURL<Identity: IMFContentEnabler_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppwszurl: *mut windows_core::PWSTR, pcchurl: *mut u32, ptruststatus: *mut MF_URL_TRUST_STATUS) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFContentEnabler_Impl::GetEnableURL(this, core::mem::transmute_copy(&ppwszurl), core::mem::transmute_copy(&pcchurl), core::mem::transmute_copy(&ptruststatus)).into()
        }
        unsafe extern "system" fn GetEnableData<Identity: IMFContentEnabler_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppbdata: *mut *mut u8, pcbdata: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFContentEnabler_Impl::GetEnableData(this, core::mem::transmute_copy(&ppbdata), core::mem::transmute_copy(&pcbdata)).into()
        }
        unsafe extern "system" fn IsAutomaticSupported<Identity: IMFContentEnabler_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfautomatic: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFContentEnabler_Impl::IsAutomaticSupported(this) {
                Ok(ok__) => {
                    pfautomatic.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutomaticEnable<Identity: IMFContentEnabler_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFContentEnabler_Impl::AutomaticEnable(this).into()
        }
        unsafe extern "system" fn MonitorEnable<Identity: IMFContentEnabler_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFContentEnabler_Impl::MonitorEnable(this).into()
        }
        unsafe extern "system" fn Cancel<Identity: IMFContentEnabler_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFContentEnabler_Impl::Cancel(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetEnableType: GetEnableType::<Identity, OFFSET>,
            GetEnableURL: GetEnableURL::<Identity, OFFSET>,
            GetEnableData: GetEnableData::<Identity, OFFSET>,
            IsAutomaticSupported: IsAutomaticSupported::<Identity, OFFSET>,
            AutomaticEnable: AutomaticEnable::<Identity, OFFSET>,
            MonitorEnable: MonitorEnable::<Identity, OFFSET>,
            Cancel: Cancel::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFContentEnabler as windows_core::Interface>::IID
    }
}
pub trait IMFContentProtectionDevice_Impl: Sized + windows_core::IUnknownImpl {
    fn InvokeFunction(&self, functionid: u32, inputbufferbytecount: u32, inputbuffer: *const u8, outputbufferbytecount: *mut u32, outputbuffer: *mut u8) -> windows_core::Result<()>;
    fn GetPrivateDataByteCount(&self, privateinputbytecount: *mut u32, privateoutputbytecount: *mut u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFContentProtectionDevice {}
impl IMFContentProtectionDevice_Vtbl {
    pub const fn new<Identity: IMFContentProtectionDevice_Impl, const OFFSET: isize>() -> IMFContentProtectionDevice_Vtbl {
        unsafe extern "system" fn InvokeFunction<Identity: IMFContentProtectionDevice_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, functionid: u32, inputbufferbytecount: u32, inputbuffer: *const u8, outputbufferbytecount: *mut u32, outputbuffer: *mut u8) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFContentProtectionDevice_Impl::InvokeFunction(this, core::mem::transmute_copy(&functionid), core::mem::transmute_copy(&inputbufferbytecount), core::mem::transmute_copy(&inputbuffer), core::mem::transmute_copy(&outputbufferbytecount), core::mem::transmute_copy(&outputbuffer)).into()
        }
        unsafe extern "system" fn GetPrivateDataByteCount<Identity: IMFContentProtectionDevice_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, privateinputbytecount: *mut u32, privateoutputbytecount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFContentProtectionDevice_Impl::GetPrivateDataByteCount(this, core::mem::transmute_copy(&privateinputbytecount), core::mem::transmute_copy(&privateoutputbytecount)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            InvokeFunction: InvokeFunction::<Identity, OFFSET>,
            GetPrivateDataByteCount: GetPrivateDataByteCount::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFContentProtectionDevice as windows_core::Interface>::IID
    }
}
pub trait IMFContentProtectionManager_Impl: Sized + windows_core::IUnknownImpl {
    fn BeginEnableContent(&self, penableractivate: Option<&IMFActivate>, ptopo: Option<&IMFTopology>, pcallback: Option<&IMFAsyncCallback>, punkstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndEnableContent(&self, presult: Option<&IMFAsyncResult>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFContentProtectionManager {}
impl IMFContentProtectionManager_Vtbl {
    pub const fn new<Identity: IMFContentProtectionManager_Impl, const OFFSET: isize>() -> IMFContentProtectionManager_Vtbl {
        unsafe extern "system" fn BeginEnableContent<Identity: IMFContentProtectionManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, penableractivate: *mut core::ffi::c_void, ptopo: *mut core::ffi::c_void, pcallback: *mut core::ffi::c_void, punkstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFContentProtectionManager_Impl::BeginEnableContent(this, windows_core::from_raw_borrowed(&penableractivate), windows_core::from_raw_borrowed(&ptopo), windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&punkstate)).into()
        }
        unsafe extern "system" fn EndEnableContent<Identity: IMFContentProtectionManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFContentProtectionManager_Impl::EndEnableContent(this, windows_core::from_raw_borrowed(&presult)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            BeginEnableContent: BeginEnableContent::<Identity, OFFSET>,
            EndEnableContent: EndEnableContent::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFContentProtectionManager as windows_core::Interface>::IID
    }
}
pub trait IMFD3D12SynchronizationObject_Impl: Sized + windows_core::IUnknownImpl {
    fn SignalEventOnFinalResourceRelease(&self, hevent: super::super::Foundation::HANDLE) -> windows_core::Result<()>;
    fn Reset(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFD3D12SynchronizationObject {}
impl IMFD3D12SynchronizationObject_Vtbl {
    pub const fn new<Identity: IMFD3D12SynchronizationObject_Impl, const OFFSET: isize>() -> IMFD3D12SynchronizationObject_Vtbl {
        unsafe extern "system" fn SignalEventOnFinalResourceRelease<Identity: IMFD3D12SynchronizationObject_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hevent: super::super::Foundation::HANDLE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFD3D12SynchronizationObject_Impl::SignalEventOnFinalResourceRelease(this, core::mem::transmute_copy(&hevent)).into()
        }
        unsafe extern "system" fn Reset<Identity: IMFD3D12SynchronizationObject_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFD3D12SynchronizationObject_Impl::Reset(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SignalEventOnFinalResourceRelease: SignalEventOnFinalResourceRelease::<Identity, OFFSET>,
            Reset: Reset::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFD3D12SynchronizationObject as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait IMFD3D12SynchronizationObjectCommands_Impl: Sized + windows_core::IUnknownImpl {
    fn EnqueueResourceReady(&self, pproducercommandqueue: Option<&super::super::Graphics::Direct3D12::ID3D12CommandQueue>) -> windows_core::Result<()>;
    fn EnqueueResourceReadyWait(&self, pconsumercommandqueue: Option<&super::super::Graphics::Direct3D12::ID3D12CommandQueue>) -> windows_core::Result<()>;
    fn SignalEventOnResourceReady(&self, hevent: super::super::Foundation::HANDLE) -> windows_core::Result<()>;
    fn EnqueueResourceRelease(&self, pconsumercommandqueue: Option<&super::super::Graphics::Direct3D12::ID3D12CommandQueue>) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl windows_core::RuntimeName for IMFD3D12SynchronizationObjectCommands {}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl IMFD3D12SynchronizationObjectCommands_Vtbl {
    pub const fn new<Identity: IMFD3D12SynchronizationObjectCommands_Impl, const OFFSET: isize>() -> IMFD3D12SynchronizationObjectCommands_Vtbl {
        unsafe extern "system" fn EnqueueResourceReady<Identity: IMFD3D12SynchronizationObjectCommands_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pproducercommandqueue: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFD3D12SynchronizationObjectCommands_Impl::EnqueueResourceReady(this, windows_core::from_raw_borrowed(&pproducercommandqueue)).into()
        }
        unsafe extern "system" fn EnqueueResourceReadyWait<Identity: IMFD3D12SynchronizationObjectCommands_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pconsumercommandqueue: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFD3D12SynchronizationObjectCommands_Impl::EnqueueResourceReadyWait(this, windows_core::from_raw_borrowed(&pconsumercommandqueue)).into()
        }
        unsafe extern "system" fn SignalEventOnResourceReady<Identity: IMFD3D12SynchronizationObjectCommands_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hevent: super::super::Foundation::HANDLE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFD3D12SynchronizationObjectCommands_Impl::SignalEventOnResourceReady(this, core::mem::transmute_copy(&hevent)).into()
        }
        unsafe extern "system" fn EnqueueResourceRelease<Identity: IMFD3D12SynchronizationObjectCommands_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pconsumercommandqueue: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFD3D12SynchronizationObjectCommands_Impl::EnqueueResourceRelease(this, windows_core::from_raw_borrowed(&pconsumercommandqueue)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            EnqueueResourceReady: EnqueueResourceReady::<Identity, OFFSET>,
            EnqueueResourceReadyWait: EnqueueResourceReadyWait::<Identity, OFFSET>,
            SignalEventOnResourceReady: SignalEventOnResourceReady::<Identity, OFFSET>,
            EnqueueResourceRelease: EnqueueResourceRelease::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFD3D12SynchronizationObjectCommands as windows_core::Interface>::IID
    }
}
pub trait IMFDLNASinkInit_Impl: Sized + windows_core::IUnknownImpl {
    fn Initialize(&self, pbytestream: Option<&IMFByteStream>, fpal: super::super::Foundation::BOOL) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFDLNASinkInit {}
impl IMFDLNASinkInit_Vtbl {
    pub const fn new<Identity: IMFDLNASinkInit_Impl, const OFFSET: isize>() -> IMFDLNASinkInit_Vtbl {
        unsafe extern "system" fn Initialize<Identity: IMFDLNASinkInit_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbytestream: *mut core::ffi::c_void, fpal: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDLNASinkInit_Impl::Initialize(this, windows_core::from_raw_borrowed(&pbytestream), core::mem::transmute_copy(&fpal)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Initialize: Initialize::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFDLNASinkInit as windows_core::Interface>::IID
    }
}
pub trait IMFDRMNetHelper_Impl: Sized + windows_core::IUnknownImpl {
    fn ProcessLicenseRequest(&self, plicenserequest: *const u8, cblicenserequest: u32, pplicenseresponse: *mut *mut u8, pcblicenseresponse: *mut u32, pbstrkid: *mut windows_core::BSTR) -> windows_core::Result<()>;
    fn GetChainedLicenseResponse(&self, pplicenseresponse: *mut *mut u8, pcblicenseresponse: *mut u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFDRMNetHelper {}
impl IMFDRMNetHelper_Vtbl {
    pub const fn new<Identity: IMFDRMNetHelper_Impl, const OFFSET: isize>() -> IMFDRMNetHelper_Vtbl {
        unsafe extern "system" fn ProcessLicenseRequest<Identity: IMFDRMNetHelper_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plicenserequest: *const u8, cblicenserequest: u32, pplicenseresponse: *mut *mut u8, pcblicenseresponse: *mut u32, pbstrkid: *mut core::mem::MaybeUninit<windows_core::BSTR>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDRMNetHelper_Impl::ProcessLicenseRequest(this, core::mem::transmute_copy(&plicenserequest), core::mem::transmute_copy(&cblicenserequest), core::mem::transmute_copy(&pplicenseresponse), core::mem::transmute_copy(&pcblicenseresponse), core::mem::transmute_copy(&pbstrkid)).into()
        }
        unsafe extern "system" fn GetChainedLicenseResponse<Identity: IMFDRMNetHelper_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pplicenseresponse: *mut *mut u8, pcblicenseresponse: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDRMNetHelper_Impl::GetChainedLicenseResponse(this, core::mem::transmute_copy(&pplicenseresponse), core::mem::transmute_copy(&pcblicenseresponse)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            ProcessLicenseRequest: ProcessLicenseRequest::<Identity, OFFSET>,
            GetChainedLicenseResponse: GetChainedLicenseResponse::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFDRMNetHelper as windows_core::Interface>::IID
    }
}
pub trait IMFDXGIBuffer_Impl: Sized + windows_core::IUnknownImpl {
    fn GetResource(&self, riid: *const windows_core::GUID, ppvobject: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn GetSubresourceIndex(&self) -> windows_core::Result<u32>;
    fn GetUnknown(&self, guid: *const windows_core::GUID, riid: *const windows_core::GUID, ppvobject: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn SetUnknown(&self, guid: *const windows_core::GUID, punkdata: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFDXGIBuffer {}
impl IMFDXGIBuffer_Vtbl {
    pub const fn new<Identity: IMFDXGIBuffer_Impl, const OFFSET: isize>() -> IMFDXGIBuffer_Vtbl {
        unsafe extern "system" fn GetResource<Identity: IMFDXGIBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppvobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDXGIBuffer_Impl::GetResource(this, core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvobject)).into()
        }
        unsafe extern "system" fn GetSubresourceIndex<Identity: IMFDXGIBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pusubresource: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFDXGIBuffer_Impl::GetSubresourceIndex(this) {
                Ok(ok__) => {
                    pusubresource.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetUnknown<Identity: IMFDXGIBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guid: *const windows_core::GUID, riid: *const windows_core::GUID, ppvobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDXGIBuffer_Impl::GetUnknown(this, core::mem::transmute_copy(&guid), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvobject)).into()
        }
        unsafe extern "system" fn SetUnknown<Identity: IMFDXGIBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guid: *const windows_core::GUID, punkdata: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDXGIBuffer_Impl::SetUnknown(this, core::mem::transmute_copy(&guid), windows_core::from_raw_borrowed(&punkdata)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetResource: GetResource::<Identity, OFFSET>,
            GetSubresourceIndex: GetSubresourceIndex::<Identity, OFFSET>,
            GetUnknown: GetUnknown::<Identity, OFFSET>,
            SetUnknown: SetUnknown::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFDXGIBuffer as windows_core::Interface>::IID
    }
}
pub trait IMFDXGIDeviceManager_Impl: Sized + windows_core::IUnknownImpl {
    fn CloseDeviceHandle(&self, hdevice: super::super::Foundation::HANDLE) -> windows_core::Result<()>;
    fn GetVideoService(&self, hdevice: super::super::Foundation::HANDLE, riid: *const windows_core::GUID, ppservice: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn LockDevice(&self, hdevice: super::super::Foundation::HANDLE, riid: *const windows_core::GUID, ppunkdevice: *mut *mut core::ffi::c_void, fblock: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn OpenDeviceHandle(&self) -> windows_core::Result<super::super::Foundation::HANDLE>;
    fn ResetDevice(&self, punkdevice: Option<&windows_core::IUnknown>, resettoken: u32) -> windows_core::Result<()>;
    fn TestDevice(&self, hdevice: super::super::Foundation::HANDLE) -> windows_core::Result<()>;
    fn UnlockDevice(&self, hdevice: super::super::Foundation::HANDLE, fsavestate: super::super::Foundation::BOOL) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFDXGIDeviceManager {}
impl IMFDXGIDeviceManager_Vtbl {
    pub const fn new<Identity: IMFDXGIDeviceManager_Impl, const OFFSET: isize>() -> IMFDXGIDeviceManager_Vtbl {
        unsafe extern "system" fn CloseDeviceHandle<Identity: IMFDXGIDeviceManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hdevice: super::super::Foundation::HANDLE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDXGIDeviceManager_Impl::CloseDeviceHandle(this, core::mem::transmute_copy(&hdevice)).into()
        }
        unsafe extern "system" fn GetVideoService<Identity: IMFDXGIDeviceManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, riid: *const windows_core::GUID, ppservice: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDXGIDeviceManager_Impl::GetVideoService(this, core::mem::transmute_copy(&hdevice), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppservice)).into()
        }
        unsafe extern "system" fn LockDevice<Identity: IMFDXGIDeviceManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, riid: *const windows_core::GUID, ppunkdevice: *mut *mut core::ffi::c_void, fblock: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDXGIDeviceManager_Impl::LockDevice(this, core::mem::transmute_copy(&hdevice), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppunkdevice), core::mem::transmute_copy(&fblock)).into()
        }
        unsafe extern "system" fn OpenDeviceHandle<Identity: IMFDXGIDeviceManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, phdevice: *mut super::super::Foundation::HANDLE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFDXGIDeviceManager_Impl::OpenDeviceHandle(this) {
                Ok(ok__) => {
                    phdevice.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ResetDevice<Identity: IMFDXGIDeviceManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, punkdevice: *mut core::ffi::c_void, resettoken: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDXGIDeviceManager_Impl::ResetDevice(this, windows_core::from_raw_borrowed(&punkdevice), core::mem::transmute_copy(&resettoken)).into()
        }
        unsafe extern "system" fn TestDevice<Identity: IMFDXGIDeviceManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hdevice: super::super::Foundation::HANDLE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDXGIDeviceManager_Impl::TestDevice(this, core::mem::transmute_copy(&hdevice)).into()
        }
        unsafe extern "system" fn UnlockDevice<Identity: IMFDXGIDeviceManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, fsavestate: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDXGIDeviceManager_Impl::UnlockDevice(this, core::mem::transmute_copy(&hdevice), core::mem::transmute_copy(&fsavestate)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            CloseDeviceHandle: CloseDeviceHandle::<Identity, OFFSET>,
            GetVideoService: GetVideoService::<Identity, OFFSET>,
            LockDevice: LockDevice::<Identity, OFFSET>,
            OpenDeviceHandle: OpenDeviceHandle::<Identity, OFFSET>,
            ResetDevice: ResetDevice::<Identity, OFFSET>,
            TestDevice: TestDevice::<Identity, OFFSET>,
            UnlockDevice: UnlockDevice::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFDXGIDeviceManager as windows_core::Interface>::IID
    }
}
pub trait IMFDXGIDeviceManagerSource_Impl: Sized + windows_core::IUnknownImpl {
    fn GetManager(&self) -> windows_core::Result<IMFDXGIDeviceManager>;
}
impl windows_core::RuntimeName for IMFDXGIDeviceManagerSource {}
impl IMFDXGIDeviceManagerSource_Vtbl {
    pub const fn new<Identity: IMFDXGIDeviceManagerSource_Impl, const OFFSET: isize>() -> IMFDXGIDeviceManagerSource_Vtbl {
        unsafe extern "system" fn GetManager<Identity: IMFDXGIDeviceManagerSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppmanager: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFDXGIDeviceManagerSource_Impl::GetManager(this) {
                Ok(ok__) => {
                    ppmanager.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetManager: GetManager::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFDXGIDeviceManagerSource as windows_core::Interface>::IID
    }
}
pub trait IMFDesiredSample_Impl: Sized + windows_core::IUnknownImpl {
    fn GetDesiredSampleTimeAndDuration(&self, phnssampletime: *mut i64, phnssampleduration: *mut i64) -> windows_core::Result<()>;
    fn SetDesiredSampleTimeAndDuration(&self, hnssampletime: i64, hnssampleduration: i64);
    fn Clear(&self);
}
impl windows_core::RuntimeName for IMFDesiredSample {}
impl IMFDesiredSample_Vtbl {
    pub const fn new<Identity: IMFDesiredSample_Impl, const OFFSET: isize>() -> IMFDesiredSample_Vtbl {
        unsafe extern "system" fn GetDesiredSampleTimeAndDuration<Identity: IMFDesiredSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, phnssampletime: *mut i64, phnssampleduration: *mut i64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDesiredSample_Impl::GetDesiredSampleTimeAndDuration(this, core::mem::transmute_copy(&phnssampletime), core::mem::transmute_copy(&phnssampleduration)).into()
        }
        unsafe extern "system" fn SetDesiredSampleTimeAndDuration<Identity: IMFDesiredSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hnssampletime: i64, hnssampleduration: i64) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDesiredSample_Impl::SetDesiredSampleTimeAndDuration(this, core::mem::transmute_copy(&hnssampletime), core::mem::transmute_copy(&hnssampleduration))
        }
        unsafe extern "system" fn Clear<Identity: IMFDesiredSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDesiredSample_Impl::Clear(this)
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetDesiredSampleTimeAndDuration: GetDesiredSampleTimeAndDuration::<Identity, OFFSET>,
            SetDesiredSampleTimeAndDuration: SetDesiredSampleTimeAndDuration::<Identity, OFFSET>,
            Clear: Clear::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFDesiredSample as windows_core::Interface>::IID
    }
}
pub trait IMFDeviceTransform_Impl: Sized + windows_core::IUnknownImpl {
    fn InitializeTransform(&self, pattributes: Option<&IMFAttributes>) -> windows_core::Result<()>;
    fn GetInputAvailableType(&self, dwinputstreamid: u32, dwtypeindex: u32) -> windows_core::Result<IMFMediaType>;
    fn GetInputCurrentType(&self, dwinputstreamid: u32) -> windows_core::Result<IMFMediaType>;
    fn GetInputStreamAttributes(&self, dwinputstreamid: u32) -> windows_core::Result<IMFAttributes>;
    fn GetOutputAvailableType(&self, dwoutputstreamid: u32, dwtypeindex: u32) -> windows_core::Result<IMFMediaType>;
    fn GetOutputCurrentType(&self, dwoutputstreamid: u32) -> windows_core::Result<IMFMediaType>;
    fn GetOutputStreamAttributes(&self, dwoutputstreamid: u32) -> windows_core::Result<IMFAttributes>;
    fn GetStreamCount(&self, pcinputstreams: *mut u32, pcoutputstreams: *mut u32) -> windows_core::Result<()>;
    fn GetStreamIDs(&self, dwinputidarraysize: u32, pdwinputstreamids: *mut u32, dwoutputidarraysize: u32, pdwoutputstreamids: *mut u32) -> windows_core::Result<()>;
    fn ProcessEvent(&self, dwinputstreamid: u32, pevent: Option<&IMFMediaEvent>) -> windows_core::Result<()>;
    fn ProcessInput(&self, dwinputstreamid: u32, psample: Option<&IMFSample>, dwflags: u32) -> windows_core::Result<()>;
    fn ProcessMessage(&self, emessage: MFT_MESSAGE_TYPE, ulparam: usize) -> windows_core::Result<()>;
    fn ProcessOutput(&self, dwflags: u32, coutputbuffercount: u32, poutputsample: *mut MFT_OUTPUT_DATA_BUFFER, pdwstatus: *mut u32) -> windows_core::Result<()>;
    fn SetInputStreamState(&self, dwstreamid: u32, pmediatype: Option<&IMFMediaType>, value: DeviceStreamState, dwflags: u32) -> windows_core::Result<()>;
    fn GetInputStreamState(&self, dwstreamid: u32) -> windows_core::Result<DeviceStreamState>;
    fn SetOutputStreamState(&self, dwstreamid: u32, pmediatype: Option<&IMFMediaType>, value: DeviceStreamState, dwflags: u32) -> windows_core::Result<()>;
    fn GetOutputStreamState(&self, dwstreamid: u32) -> windows_core::Result<DeviceStreamState>;
    fn GetInputStreamPreferredState(&self, dwstreamid: u32, value: *mut DeviceStreamState, ppmediatype: *mut Option<IMFMediaType>) -> windows_core::Result<()>;
    fn FlushInputStream(&self, dwstreamindex: u32, dwflags: u32) -> windows_core::Result<()>;
    fn FlushOutputStream(&self, dwstreamindex: u32, dwflags: u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFDeviceTransform {}
impl IMFDeviceTransform_Vtbl {
    pub const fn new<Identity: IMFDeviceTransform_Impl, const OFFSET: isize>() -> IMFDeviceTransform_Vtbl {
        unsafe extern "system" fn InitializeTransform<Identity: IMFDeviceTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pattributes: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDeviceTransform_Impl::InitializeTransform(this, windows_core::from_raw_borrowed(&pattributes)).into()
        }
        unsafe extern "system" fn GetInputAvailableType<Identity: IMFDeviceTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwinputstreamid: u32, dwtypeindex: u32, pmediatype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFDeviceTransform_Impl::GetInputAvailableType(this, core::mem::transmute_copy(&dwinputstreamid), core::mem::transmute_copy(&dwtypeindex)) {
                Ok(ok__) => {
                    pmediatype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInputCurrentType<Identity: IMFDeviceTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwinputstreamid: u32, pmediatype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFDeviceTransform_Impl::GetInputCurrentType(this, core::mem::transmute_copy(&dwinputstreamid)) {
                Ok(ok__) => {
                    pmediatype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInputStreamAttributes<Identity: IMFDeviceTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwinputstreamid: u32, ppattributes: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFDeviceTransform_Impl::GetInputStreamAttributes(this, core::mem::transmute_copy(&dwinputstreamid)) {
                Ok(ok__) => {
                    ppattributes.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputAvailableType<Identity: IMFDeviceTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwoutputstreamid: u32, dwtypeindex: u32, pmediatype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFDeviceTransform_Impl::GetOutputAvailableType(this, core::mem::transmute_copy(&dwoutputstreamid), core::mem::transmute_copy(&dwtypeindex)) {
                Ok(ok__) => {
                    pmediatype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputCurrentType<Identity: IMFDeviceTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwoutputstreamid: u32, pmediatype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFDeviceTransform_Impl::GetOutputCurrentType(this, core::mem::transmute_copy(&dwoutputstreamid)) {
                Ok(ok__) => {
                    pmediatype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputStreamAttributes<Identity: IMFDeviceTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwoutputstreamid: u32, ppattributes: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFDeviceTransform_Impl::GetOutputStreamAttributes(this, core::mem::transmute_copy(&dwoutputstreamid)) {
                Ok(ok__) => {
                    ppattributes.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamCount<Identity: IMFDeviceTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcinputstreams: *mut u32, pcoutputstreams: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDeviceTransform_Impl::GetStreamCount(this, core::mem::transmute_copy(&pcinputstreams), core::mem::transmute_copy(&pcoutputstreams)).into()
        }
        unsafe extern "system" fn GetStreamIDs<Identity: IMFDeviceTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwinputidarraysize: u32, pdwinputstreamids: *mut u32, dwoutputidarraysize: u32, pdwoutputstreamids: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDeviceTransform_Impl::GetStreamIDs(this, core::mem::transmute_copy(&dwinputidarraysize), core::mem::transmute_copy(&pdwinputstreamids), core::mem::transmute_copy(&dwoutputidarraysize), core::mem::transmute_copy(&pdwoutputstreamids)).into()
        }
        unsafe extern "system" fn ProcessEvent<Identity: IMFDeviceTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwinputstreamid: u32, pevent: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDeviceTransform_Impl::ProcessEvent(this, core::mem::transmute_copy(&dwinputstreamid), windows_core::from_raw_borrowed(&pevent)).into()
        }
        unsafe extern "system" fn ProcessInput<Identity: IMFDeviceTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwinputstreamid: u32, psample: *mut core::ffi::c_void, dwflags: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDeviceTransform_Impl::ProcessInput(this, core::mem::transmute_copy(&dwinputstreamid), windows_core::from_raw_borrowed(&psample), core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn ProcessMessage<Identity: IMFDeviceTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, emessage: MFT_MESSAGE_TYPE, ulparam: usize) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDeviceTransform_Impl::ProcessMessage(this, core::mem::transmute_copy(&emessage), core::mem::transmute_copy(&ulparam)).into()
        }
        unsafe extern "system" fn ProcessOutput<Identity: IMFDeviceTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32, coutputbuffercount: u32, poutputsample: *mut MFT_OUTPUT_DATA_BUFFER, pdwstatus: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDeviceTransform_Impl::ProcessOutput(this, core::mem::transmute_copy(&dwflags), core::mem::transmute_copy(&coutputbuffercount), core::mem::transmute_copy(&poutputsample), core::mem::transmute_copy(&pdwstatus)).into()
        }
        unsafe extern "system" fn SetInputStreamState<Identity: IMFDeviceTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, pmediatype: *mut core::ffi::c_void, value: DeviceStreamState, dwflags: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDeviceTransform_Impl::SetInputStreamState(this, core::mem::transmute_copy(&dwstreamid), windows_core::from_raw_borrowed(&pmediatype), core::mem::transmute_copy(&value), core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn GetInputStreamState<Identity: IMFDeviceTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, value: *mut DeviceStreamState) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFDeviceTransform_Impl::GetInputStreamState(this, core::mem::transmute_copy(&dwstreamid)) {
                Ok(ok__) => {
                    value.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputStreamState<Identity: IMFDeviceTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, pmediatype: *mut core::ffi::c_void, value: DeviceStreamState, dwflags: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDeviceTransform_Impl::SetOutputStreamState(this, core::mem::transmute_copy(&dwstreamid), windows_core::from_raw_borrowed(&pmediatype), core::mem::transmute_copy(&value), core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn GetOutputStreamState<Identity: IMFDeviceTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, value: *mut DeviceStreamState) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFDeviceTransform_Impl::GetOutputStreamState(this, core::mem::transmute_copy(&dwstreamid)) {
                Ok(ok__) => {
                    value.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInputStreamPreferredState<Identity: IMFDeviceTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, value: *mut DeviceStreamState, ppmediatype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDeviceTransform_Impl::GetInputStreamPreferredState(this, core::mem::transmute_copy(&dwstreamid), core::mem::transmute_copy(&value), core::mem::transmute_copy(&ppmediatype)).into()
        }
        unsafe extern "system" fn FlushInputStream<Identity: IMFDeviceTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, dwflags: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDeviceTransform_Impl::FlushInputStream(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn FlushOutputStream<Identity: IMFDeviceTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, dwflags: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDeviceTransform_Impl::FlushOutputStream(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&dwflags)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            InitializeTransform: InitializeTransform::<Identity, OFFSET>,
            GetInputAvailableType: GetInputAvailableType::<Identity, OFFSET>,
            GetInputCurrentType: GetInputCurrentType::<Identity, OFFSET>,
            GetInputStreamAttributes: GetInputStreamAttributes::<Identity, OFFSET>,
            GetOutputAvailableType: GetOutputAvailableType::<Identity, OFFSET>,
            GetOutputCurrentType: GetOutputCurrentType::<Identity, OFFSET>,
            GetOutputStreamAttributes: GetOutputStreamAttributes::<Identity, OFFSET>,
            GetStreamCount: GetStreamCount::<Identity, OFFSET>,
            GetStreamIDs: GetStreamIDs::<Identity, OFFSET>,
            ProcessEvent: ProcessEvent::<Identity, OFFSET>,
            ProcessInput: ProcessInput::<Identity, OFFSET>,
            ProcessMessage: ProcessMessage::<Identity, OFFSET>,
            ProcessOutput: ProcessOutput::<Identity, OFFSET>,
            SetInputStreamState: SetInputStreamState::<Identity, OFFSET>,
            GetInputStreamState: GetInputStreamState::<Identity, OFFSET>,
            SetOutputStreamState: SetOutputStreamState::<Identity, OFFSET>,
            GetOutputStreamState: GetOutputStreamState::<Identity, OFFSET>,
            GetInputStreamPreferredState: GetInputStreamPreferredState::<Identity, OFFSET>,
            FlushInputStream: FlushInputStream::<Identity, OFFSET>,
            FlushOutputStream: FlushOutputStream::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFDeviceTransform as windows_core::Interface>::IID
    }
}
pub trait IMFDeviceTransformCallback_Impl: Sized + windows_core::IUnknownImpl {
    fn OnBufferSent(&self, pcallbackattributes: Option<&IMFAttributes>, pinid: u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFDeviceTransformCallback {}
impl IMFDeviceTransformCallback_Vtbl {
    pub const fn new<Identity: IMFDeviceTransformCallback_Impl, const OFFSET: isize>() -> IMFDeviceTransformCallback_Vtbl {
        unsafe extern "system" fn OnBufferSent<Identity: IMFDeviceTransformCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcallbackattributes: *mut core::ffi::c_void, pinid: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFDeviceTransformCallback_Impl::OnBufferSent(this, windows_core::from_raw_borrowed(&pcallbackattributes), core::mem::transmute_copy(&pinid)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), OnBufferSent: OnBufferSent::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFDeviceTransformCallback as windows_core::Interface>::IID
    }
}
pub trait IMFExtendedCameraControl_Impl: Sized + windows_core::IUnknownImpl {
    fn GetCapabilities(&self) -> u64;
    fn SetFlags(&self, ulflags: u64) -> windows_core::Result<()>;
    fn GetFlags(&self) -> u64;
    fn LockPayload(&self, pppayload: *mut *mut u8, pulpayload: *mut u32) -> windows_core::Result<()>;
    fn UnlockPayload(&self) -> windows_core::Result<()>;
    fn CommitSettings(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFExtendedCameraControl {}
impl IMFExtendedCameraControl_Vtbl {
    pub const fn new<Identity: IMFExtendedCameraControl_Impl, const OFFSET: isize>() -> IMFExtendedCameraControl_Vtbl {
        unsafe extern "system" fn GetCapabilities<Identity: IMFExtendedCameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u64 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFExtendedCameraControl_Impl::GetCapabilities(this)
        }
        unsafe extern "system" fn SetFlags<Identity: IMFExtendedCameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulflags: u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFExtendedCameraControl_Impl::SetFlags(this, core::mem::transmute_copy(&ulflags)).into()
        }
        unsafe extern "system" fn GetFlags<Identity: IMFExtendedCameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u64 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFExtendedCameraControl_Impl::GetFlags(this)
        }
        unsafe extern "system" fn LockPayload<Identity: IMFExtendedCameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pppayload: *mut *mut u8, pulpayload: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFExtendedCameraControl_Impl::LockPayload(this, core::mem::transmute_copy(&pppayload), core::mem::transmute_copy(&pulpayload)).into()
        }
        unsafe extern "system" fn UnlockPayload<Identity: IMFExtendedCameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFExtendedCameraControl_Impl::UnlockPayload(this).into()
        }
        unsafe extern "system" fn CommitSettings<Identity: IMFExtendedCameraControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFExtendedCameraControl_Impl::CommitSettings(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetCapabilities: GetCapabilities::<Identity, OFFSET>,
            SetFlags: SetFlags::<Identity, OFFSET>,
            GetFlags: GetFlags::<Identity, OFFSET>,
            LockPayload: LockPayload::<Identity, OFFSET>,
            UnlockPayload: UnlockPayload::<Identity, OFFSET>,
            CommitSettings: CommitSettings::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFExtendedCameraControl as windows_core::Interface>::IID
    }
}
pub trait IMFExtendedCameraController_Impl: Sized + windows_core::IUnknownImpl {
    fn GetExtendedCameraControl(&self, dwstreamindex: u32, ulpropertyid: u32) -> windows_core::Result<IMFExtendedCameraControl>;
}
impl windows_core::RuntimeName for IMFExtendedCameraController {}
impl IMFExtendedCameraController_Vtbl {
    pub const fn new<Identity: IMFExtendedCameraController_Impl, const OFFSET: isize>() -> IMFExtendedCameraController_Vtbl {
        unsafe extern "system" fn GetExtendedCameraControl<Identity: IMFExtendedCameraController_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, ulpropertyid: u32, ppcontrol: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFExtendedCameraController_Impl::GetExtendedCameraControl(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&ulpropertyid)) {
                Ok(ok__) => {
                    ppcontrol.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetExtendedCameraControl: GetExtendedCameraControl::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFExtendedCameraController as windows_core::Interface>::IID
    }
}
pub trait IMFExtendedCameraIntrinsicModel_Impl: Sized + windows_core::IUnknownImpl {
    fn GetModel(&self, pintrinsicmodel: *mut MFExtendedCameraIntrinsic_IntrinsicModel) -> windows_core::Result<()>;
    fn SetModel(&self, pintrinsicmodel: *const MFExtendedCameraIntrinsic_IntrinsicModel) -> windows_core::Result<()>;
    fn GetDistortionModelType(&self) -> windows_core::Result<MFCameraIntrinsic_DistortionModelType>;
}
impl windows_core::RuntimeName for IMFExtendedCameraIntrinsicModel {}
impl IMFExtendedCameraIntrinsicModel_Vtbl {
    pub const fn new<Identity: IMFExtendedCameraIntrinsicModel_Impl, const OFFSET: isize>() -> IMFExtendedCameraIntrinsicModel_Vtbl {
        unsafe extern "system" fn GetModel<Identity: IMFExtendedCameraIntrinsicModel_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pintrinsicmodel: *mut MFExtendedCameraIntrinsic_IntrinsicModel) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFExtendedCameraIntrinsicModel_Impl::GetModel(this, core::mem::transmute_copy(&pintrinsicmodel)).into()
        }
        unsafe extern "system" fn SetModel<Identity: IMFExtendedCameraIntrinsicModel_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pintrinsicmodel: *const MFExtendedCameraIntrinsic_IntrinsicModel) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFExtendedCameraIntrinsicModel_Impl::SetModel(this, core::mem::transmute_copy(&pintrinsicmodel)).into()
        }
        unsafe extern "system" fn GetDistortionModelType<Identity: IMFExtendedCameraIntrinsicModel_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdistortionmodeltype: *mut MFCameraIntrinsic_DistortionModelType) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFExtendedCameraIntrinsicModel_Impl::GetDistortionModelType(this) {
                Ok(ok__) => {
                    pdistortionmodeltype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetModel: GetModel::<Identity, OFFSET>,
            SetModel: SetModel::<Identity, OFFSET>,
            GetDistortionModelType: GetDistortionModelType::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFExtendedCameraIntrinsicModel as windows_core::Interface>::IID
    }
}
pub trait IMFExtendedCameraIntrinsics_Impl: Sized + windows_core::IUnknownImpl {
    fn InitializeFromBuffer(&self, pbbuffer: *const u8, dwbuffersize: u32) -> windows_core::Result<()>;
    fn GetBufferSize(&self) -> windows_core::Result<u32>;
    fn SerializeToBuffer(&self, pbbuffer: *mut u8, pdwbuffersize: *mut u32) -> windows_core::Result<()>;
    fn GetIntrinsicModelCount(&self) -> windows_core::Result<u32>;
    fn GetIntrinsicModelByIndex(&self, dwindex: u32) -> windows_core::Result<IMFExtendedCameraIntrinsicModel>;
    fn AddIntrinsicModel(&self, pintrinsicmodel: Option<&IMFExtendedCameraIntrinsicModel>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFExtendedCameraIntrinsics {}
impl IMFExtendedCameraIntrinsics_Vtbl {
    pub const fn new<Identity: IMFExtendedCameraIntrinsics_Impl, const OFFSET: isize>() -> IMFExtendedCameraIntrinsics_Vtbl {
        unsafe extern "system" fn InitializeFromBuffer<Identity: IMFExtendedCameraIntrinsics_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbbuffer: *const u8, dwbuffersize: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFExtendedCameraIntrinsics_Impl::InitializeFromBuffer(this, core::mem::transmute_copy(&pbbuffer), core::mem::transmute_copy(&dwbuffersize)).into()
        }
        unsafe extern "system" fn GetBufferSize<Identity: IMFExtendedCameraIntrinsics_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwbuffersize: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFExtendedCameraIntrinsics_Impl::GetBufferSize(this) {
                Ok(ok__) => {
                    pdwbuffersize.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SerializeToBuffer<Identity: IMFExtendedCameraIntrinsics_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbbuffer: *mut u8, pdwbuffersize: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFExtendedCameraIntrinsics_Impl::SerializeToBuffer(this, core::mem::transmute_copy(&pbbuffer), core::mem::transmute_copy(&pdwbuffersize)).into()
        }
        unsafe extern "system" fn GetIntrinsicModelCount<Identity: IMFExtendedCameraIntrinsics_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwcount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFExtendedCameraIntrinsics_Impl::GetIntrinsicModelCount(this) {
                Ok(ok__) => {
                    pdwcount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIntrinsicModelByIndex<Identity: IMFExtendedCameraIntrinsics_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwindex: u32, ppintrinsicmodel: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFExtendedCameraIntrinsics_Impl::GetIntrinsicModelByIndex(this, core::mem::transmute_copy(&dwindex)) {
                Ok(ok__) => {
                    ppintrinsicmodel.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddIntrinsicModel<Identity: IMFExtendedCameraIntrinsics_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pintrinsicmodel: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFExtendedCameraIntrinsics_Impl::AddIntrinsicModel(this, windows_core::from_raw_borrowed(&pintrinsicmodel)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            InitializeFromBuffer: InitializeFromBuffer::<Identity, OFFSET>,
            GetBufferSize: GetBufferSize::<Identity, OFFSET>,
            SerializeToBuffer: SerializeToBuffer::<Identity, OFFSET>,
            GetIntrinsicModelCount: GetIntrinsicModelCount::<Identity, OFFSET>,
            GetIntrinsicModelByIndex: GetIntrinsicModelByIndex::<Identity, OFFSET>,
            AddIntrinsicModel: AddIntrinsicModel::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFExtendedCameraIntrinsics as windows_core::Interface>::IID
    }
}
pub trait IMFExtendedCameraIntrinsicsDistortionModel6KT_Impl: Sized + windows_core::IUnknownImpl {
    fn GetDistortionModel(&self, pdistortionmodel: *mut MFCameraIntrinsic_DistortionModel6KT) -> windows_core::Result<()>;
    fn SetDistortionModel(&self, pdistortionmodel: *const MFCameraIntrinsic_DistortionModel6KT) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFExtendedCameraIntrinsicsDistortionModel6KT {}
impl IMFExtendedCameraIntrinsicsDistortionModel6KT_Vtbl {
    pub const fn new<Identity: IMFExtendedCameraIntrinsicsDistortionModel6KT_Impl, const OFFSET: isize>() -> IMFExtendedCameraIntrinsicsDistortionModel6KT_Vtbl {
        unsafe extern "system" fn GetDistortionModel<Identity: IMFExtendedCameraIntrinsicsDistortionModel6KT_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdistortionmodel: *mut MFCameraIntrinsic_DistortionModel6KT) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFExtendedCameraIntrinsicsDistortionModel6KT_Impl::GetDistortionModel(this, core::mem::transmute_copy(&pdistortionmodel)).into()
        }
        unsafe extern "system" fn SetDistortionModel<Identity: IMFExtendedCameraIntrinsicsDistortionModel6KT_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdistortionmodel: *const MFCameraIntrinsic_DistortionModel6KT) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFExtendedCameraIntrinsicsDistortionModel6KT_Impl::SetDistortionModel(this, core::mem::transmute_copy(&pdistortionmodel)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetDistortionModel: GetDistortionModel::<Identity, OFFSET>,
            SetDistortionModel: SetDistortionModel::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFExtendedCameraIntrinsicsDistortionModel6KT as windows_core::Interface>::IID
    }
}
pub trait IMFExtendedCameraIntrinsicsDistortionModelArcTan_Impl: Sized + windows_core::IUnknownImpl {
    fn GetDistortionModel(&self, pdistortionmodel: *mut MFCameraIntrinsic_DistortionModelArcTan) -> windows_core::Result<()>;
    fn SetDistortionModel(&self, pdistortionmodel: *const MFCameraIntrinsic_DistortionModelArcTan) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFExtendedCameraIntrinsicsDistortionModelArcTan {}
impl IMFExtendedCameraIntrinsicsDistortionModelArcTan_Vtbl {
    pub const fn new<Identity: IMFExtendedCameraIntrinsicsDistortionModelArcTan_Impl, const OFFSET: isize>() -> IMFExtendedCameraIntrinsicsDistortionModelArcTan_Vtbl {
        unsafe extern "system" fn GetDistortionModel<Identity: IMFExtendedCameraIntrinsicsDistortionModelArcTan_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdistortionmodel: *mut MFCameraIntrinsic_DistortionModelArcTan) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFExtendedCameraIntrinsicsDistortionModelArcTan_Impl::GetDistortionModel(this, core::mem::transmute_copy(&pdistortionmodel)).into()
        }
        unsafe extern "system" fn SetDistortionModel<Identity: IMFExtendedCameraIntrinsicsDistortionModelArcTan_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdistortionmodel: *const MFCameraIntrinsic_DistortionModelArcTan) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFExtendedCameraIntrinsicsDistortionModelArcTan_Impl::SetDistortionModel(this, core::mem::transmute_copy(&pdistortionmodel)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetDistortionModel: GetDistortionModel::<Identity, OFFSET>,
            SetDistortionModel: SetDistortionModel::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFExtendedCameraIntrinsicsDistortionModelArcTan as windows_core::Interface>::IID
    }
}
pub trait IMFExtendedDRMTypeSupport_Impl: Sized + windows_core::IUnknownImpl {
    fn IsTypeSupportedEx(&self, r#type: &windows_core::BSTR, keysystem: &windows_core::BSTR) -> windows_core::Result<MF_MEDIA_ENGINE_CANPLAY>;
}
impl windows_core::RuntimeName for IMFExtendedDRMTypeSupport {}
impl IMFExtendedDRMTypeSupport_Vtbl {
    pub const fn new<Identity: IMFExtendedDRMTypeSupport_Impl, const OFFSET: isize>() -> IMFExtendedDRMTypeSupport_Vtbl {
        unsafe extern "system" fn IsTypeSupportedEx<Identity: IMFExtendedDRMTypeSupport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, r#type: core::mem::MaybeUninit<windows_core::BSTR>, keysystem: core::mem::MaybeUninit<windows_core::BSTR>, panswer: *mut MF_MEDIA_ENGINE_CANPLAY) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFExtendedDRMTypeSupport_Impl::IsTypeSupportedEx(this, core::mem::transmute(&r#type), core::mem::transmute(&keysystem)) {
                Ok(ok__) => {
                    panswer.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), IsTypeSupportedEx: IsTypeSupportedEx::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFExtendedDRMTypeSupport as windows_core::Interface>::IID
    }
}
pub trait IMFFieldOfUseMFTUnlock_Impl: Sized + windows_core::IUnknownImpl {
    fn Unlock(&self, punkmft: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFFieldOfUseMFTUnlock {}
impl IMFFieldOfUseMFTUnlock_Vtbl {
    pub const fn new<Identity: IMFFieldOfUseMFTUnlock_Impl, const OFFSET: isize>() -> IMFFieldOfUseMFTUnlock_Vtbl {
        unsafe extern "system" fn Unlock<Identity: IMFFieldOfUseMFTUnlock_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, punkmft: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFFieldOfUseMFTUnlock_Impl::Unlock(this, windows_core::from_raw_borrowed(&punkmft)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Unlock: Unlock::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFFieldOfUseMFTUnlock as windows_core::Interface>::IID
    }
}
pub trait IMFFinalizableMediaSink_Impl: Sized + IMFMediaSink_Impl {
    fn BeginFinalize(&self, pcallback: Option<&IMFAsyncCallback>, punkstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndFinalize(&self, presult: Option<&IMFAsyncResult>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFFinalizableMediaSink {}
impl IMFFinalizableMediaSink_Vtbl {
    pub const fn new<Identity: IMFFinalizableMediaSink_Impl, const OFFSET: isize>() -> IMFFinalizableMediaSink_Vtbl {
        unsafe extern "system" fn BeginFinalize<Identity: IMFFinalizableMediaSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcallback: *mut core::ffi::c_void, punkstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFFinalizableMediaSink_Impl::BeginFinalize(this, windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&punkstate)).into()
        }
        unsafe extern "system" fn EndFinalize<Identity: IMFFinalizableMediaSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFFinalizableMediaSink_Impl::EndFinalize(this, windows_core::from_raw_borrowed(&presult)).into()
        }
        Self {
            base__: IMFMediaSink_Vtbl::new::<Identity, OFFSET>(),
            BeginFinalize: BeginFinalize::<Identity, OFFSET>,
            EndFinalize: EndFinalize::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFFinalizableMediaSink as windows_core::Interface>::IID || iid == &<IMFMediaSink as windows_core::Interface>::IID
    }
}
pub trait IMFGetService_Impl: Sized + windows_core::IUnknownImpl {
    fn GetService(&self, guidservice: *const windows_core::GUID, riid: *const windows_core::GUID, ppvobject: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFGetService {}
impl IMFGetService_Vtbl {
    pub const fn new<Identity: IMFGetService_Impl, const OFFSET: isize>() -> IMFGetService_Vtbl {
        unsafe extern "system" fn GetService<Identity: IMFGetService_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidservice: *const windows_core::GUID, riid: *const windows_core::GUID, ppvobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFGetService_Impl::GetService(this, core::mem::transmute_copy(&guidservice), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvobject)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetService: GetService::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFGetService as windows_core::Interface>::IID
    }
}
pub trait IMFHDCPStatus_Impl: Sized + windows_core::IUnknownImpl {
    fn Query(&self, pstatus: *mut MF_HDCP_STATUS, pfstatus: *mut super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn Set(&self, status: MF_HDCP_STATUS) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFHDCPStatus {}
impl IMFHDCPStatus_Vtbl {
    pub const fn new<Identity: IMFHDCPStatus_Impl, const OFFSET: isize>() -> IMFHDCPStatus_Vtbl {
        unsafe extern "system" fn Query<Identity: IMFHDCPStatus_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstatus: *mut MF_HDCP_STATUS, pfstatus: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFHDCPStatus_Impl::Query(this, core::mem::transmute_copy(&pstatus), core::mem::transmute_copy(&pfstatus)).into()
        }
        unsafe extern "system" fn Set<Identity: IMFHDCPStatus_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, status: MF_HDCP_STATUS) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFHDCPStatus_Impl::Set(this, core::mem::transmute_copy(&status)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Query: Query::<Identity, OFFSET>, Set: Set::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFHDCPStatus as windows_core::Interface>::IID
    }
}
pub trait IMFHttpDownloadRequest_Impl: Sized + windows_core::IUnknownImpl {
    fn AddHeader(&self, szheader: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn BeginSendRequest(&self, pbpayload: *const u8, cbpayload: u32, pcallback: Option<&IMFAsyncCallback>, punkstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndSendRequest(&self, presult: Option<&IMFAsyncResult>) -> windows_core::Result<()>;
    fn BeginReceiveResponse(&self, pcallback: Option<&IMFAsyncCallback>, punkstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndReceiveResponse(&self, presult: Option<&IMFAsyncResult>) -> windows_core::Result<()>;
    fn BeginReadPayload(&self, pb: *mut u8, cb: u32, pcallback: Option<&IMFAsyncCallback>, punkstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndReadPayload(&self, presult: Option<&IMFAsyncResult>, pqwoffset: *mut u64, pcbread: *mut u32) -> windows_core::Result<()>;
    fn QueryHeader(&self, szheadername: &windows_core::PCWSTR, dwindex: u32) -> windows_core::Result<windows_core::PWSTR>;
    fn GetURL(&self) -> windows_core::Result<windows_core::PWSTR>;
    fn HasNullSourceOrigin(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn GetTimeSeekResult(&self, pqwstarttime: *mut u64, pqwstoptime: *mut u64, pqwduration: *mut u64) -> windows_core::Result<()>;
    fn GetHttpStatus(&self) -> windows_core::Result<u32>;
    fn GetAtEndOfPayload(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn GetTotalLength(&self) -> windows_core::Result<u64>;
    fn GetRangeEndOffset(&self) -> windows_core::Result<u64>;
    fn Close(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFHttpDownloadRequest {}
impl IMFHttpDownloadRequest_Vtbl {
    pub const fn new<Identity: IMFHttpDownloadRequest_Impl, const OFFSET: isize>() -> IMFHttpDownloadRequest_Vtbl {
        unsafe extern "system" fn AddHeader<Identity: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, szheader: windows_core::PCWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFHttpDownloadRequest_Impl::AddHeader(this, core::mem::transmute(&szheader)).into()
        }
        unsafe extern "system" fn BeginSendRequest<Identity: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbpayload: *const u8, cbpayload: u32, pcallback: *mut core::ffi::c_void, punkstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFHttpDownloadRequest_Impl::BeginSendRequest(this, core::mem::transmute_copy(&pbpayload), core::mem::transmute_copy(&cbpayload), windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&punkstate)).into()
        }
        unsafe extern "system" fn EndSendRequest<Identity: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFHttpDownloadRequest_Impl::EndSendRequest(this, windows_core::from_raw_borrowed(&presult)).into()
        }
        unsafe extern "system" fn BeginReceiveResponse<Identity: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcallback: *mut core::ffi::c_void, punkstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFHttpDownloadRequest_Impl::BeginReceiveResponse(this, windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&punkstate)).into()
        }
        unsafe extern "system" fn EndReceiveResponse<Identity: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFHttpDownloadRequest_Impl::EndReceiveResponse(this, windows_core::from_raw_borrowed(&presult)).into()
        }
        unsafe extern "system" fn BeginReadPayload<Identity: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pb: *mut u8, cb: u32, pcallback: *mut core::ffi::c_void, punkstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFHttpDownloadRequest_Impl::BeginReadPayload(this, core::mem::transmute_copy(&pb), core::mem::transmute_copy(&cb), windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&punkstate)).into()
        }
        unsafe extern "system" fn EndReadPayload<Identity: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void, pqwoffset: *mut u64, pcbread: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFHttpDownloadRequest_Impl::EndReadPayload(this, windows_core::from_raw_borrowed(&presult), core::mem::transmute_copy(&pqwoffset), core::mem::transmute_copy(&pcbread)).into()
        }
        unsafe extern "system" fn QueryHeader<Identity: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, szheadername: windows_core::PCWSTR, dwindex: u32, ppszheadervalue: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFHttpDownloadRequest_Impl::QueryHeader(this, core::mem::transmute(&szheadername), core::mem::transmute_copy(&dwindex)) {
                Ok(ok__) => {
                    ppszheadervalue.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetURL<Identity: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppszurl: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFHttpDownloadRequest_Impl::GetURL(this) {
                Ok(ok__) => {
                    ppszurl.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HasNullSourceOrigin<Identity: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfnullsourceorigin: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFHttpDownloadRequest_Impl::HasNullSourceOrigin(this) {
                Ok(ok__) => {
                    pfnullsourceorigin.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTimeSeekResult<Identity: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pqwstarttime: *mut u64, pqwstoptime: *mut u64, pqwduration: *mut u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFHttpDownloadRequest_Impl::GetTimeSeekResult(this, core::mem::transmute_copy(&pqwstarttime), core::mem::transmute_copy(&pqwstoptime), core::mem::transmute_copy(&pqwduration)).into()
        }
        unsafe extern "system" fn GetHttpStatus<Identity: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwhttpstatus: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFHttpDownloadRequest_Impl::GetHttpStatus(this) {
                Ok(ok__) => {
                    pdwhttpstatus.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAtEndOfPayload<Identity: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfatendofpayload: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFHttpDownloadRequest_Impl::GetAtEndOfPayload(this) {
                Ok(ok__) => {
                    pfatendofpayload.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTotalLength<Identity: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pqwtotallength: *mut u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFHttpDownloadRequest_Impl::GetTotalLength(this) {
                Ok(ok__) => {
                    pqwtotallength.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRangeEndOffset<Identity: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pqwrangeend: *mut u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFHttpDownloadRequest_Impl::GetRangeEndOffset(this) {
                Ok(ok__) => {
                    pqwrangeend.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Close<Identity: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFHttpDownloadRequest_Impl::Close(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            AddHeader: AddHeader::<Identity, OFFSET>,
            BeginSendRequest: BeginSendRequest::<Identity, OFFSET>,
            EndSendRequest: EndSendRequest::<Identity, OFFSET>,
            BeginReceiveResponse: BeginReceiveResponse::<Identity, OFFSET>,
            EndReceiveResponse: EndReceiveResponse::<Identity, OFFSET>,
            BeginReadPayload: BeginReadPayload::<Identity, OFFSET>,
            EndReadPayload: EndReadPayload::<Identity, OFFSET>,
            QueryHeader: QueryHeader::<Identity, OFFSET>,
            GetURL: GetURL::<Identity, OFFSET>,
            HasNullSourceOrigin: HasNullSourceOrigin::<Identity, OFFSET>,
            GetTimeSeekResult: GetTimeSeekResult::<Identity, OFFSET>,
            GetHttpStatus: GetHttpStatus::<Identity, OFFSET>,
            GetAtEndOfPayload: GetAtEndOfPayload::<Identity, OFFSET>,
            GetTotalLength: GetTotalLength::<Identity, OFFSET>,
            GetRangeEndOffset: GetRangeEndOffset::<Identity, OFFSET>,
            Close: Close::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFHttpDownloadRequest as windows_core::Interface>::IID
    }
}
pub trait IMFHttpDownloadSession_Impl: Sized + windows_core::IUnknownImpl {
    fn SetServer(&self, szservername: &windows_core::PCWSTR, nport: u32) -> windows_core::Result<()>;
    fn CreateRequest(&self, szobjectname: &windows_core::PCWSTR, fbypassproxycache: super::super::Foundation::BOOL, fsecure: super::super::Foundation::BOOL, szverb: &windows_core::PCWSTR, szreferrer: &windows_core::PCWSTR) -> windows_core::Result<IMFHttpDownloadRequest>;
    fn Close(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFHttpDownloadSession {}
impl IMFHttpDownloadSession_Vtbl {
    pub const fn new<Identity: IMFHttpDownloadSession_Impl, const OFFSET: isize>() -> IMFHttpDownloadSession_Vtbl {
        unsafe extern "system" fn SetServer<Identity: IMFHttpDownloadSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, szservername: windows_core::PCWSTR, nport: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFHttpDownloadSession_Impl::SetServer(this, core::mem::transmute(&szservername), core::mem::transmute_copy(&nport)).into()
        }
        unsafe extern "system" fn CreateRequest<Identity: IMFHttpDownloadSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, szobjectname: windows_core::PCWSTR, fbypassproxycache: super::super::Foundation::BOOL, fsecure: super::super::Foundation::BOOL, szverb: windows_core::PCWSTR, szreferrer: windows_core::PCWSTR, pprequest: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFHttpDownloadSession_Impl::CreateRequest(this, core::mem::transmute(&szobjectname), core::mem::transmute_copy(&fbypassproxycache), core::mem::transmute_copy(&fsecure), core::mem::transmute(&szverb), core::mem::transmute(&szreferrer)) {
                Ok(ok__) => {
                    pprequest.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Close<Identity: IMFHttpDownloadSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFHttpDownloadSession_Impl::Close(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetServer: SetServer::<Identity, OFFSET>,
            CreateRequest: CreateRequest::<Identity, OFFSET>,
            Close: Close::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFHttpDownloadSession as windows_core::Interface>::IID
    }
}
pub trait IMFHttpDownloadSessionProvider_Impl: Sized + windows_core::IUnknownImpl {
    fn CreateHttpDownloadSession(&self, wszscheme: &windows_core::PCWSTR) -> windows_core::Result<IMFHttpDownloadSession>;
}
impl windows_core::RuntimeName for IMFHttpDownloadSessionProvider {}
impl IMFHttpDownloadSessionProvider_Vtbl {
    pub const fn new<Identity: IMFHttpDownloadSessionProvider_Impl, const OFFSET: isize>() -> IMFHttpDownloadSessionProvider_Vtbl {
        unsafe extern "system" fn CreateHttpDownloadSession<Identity: IMFHttpDownloadSessionProvider_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, wszscheme: windows_core::PCWSTR, ppdownloadsession: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFHttpDownloadSessionProvider_Impl::CreateHttpDownloadSession(this, core::mem::transmute(&wszscheme)) {
                Ok(ok__) => {
                    ppdownloadsession.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), CreateHttpDownloadSession: CreateHttpDownloadSession::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFHttpDownloadSessionProvider as windows_core::Interface>::IID
    }
}
pub trait IMFImageSharingEngine_Impl: Sized + windows_core::IUnknownImpl {
    fn SetSource(&self, pstream: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn GetDevice(&self, pdevice: *mut DEVICE_INFO) -> windows_core::Result<()>;
    fn Shutdown(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFImageSharingEngine {}
impl IMFImageSharingEngine_Vtbl {
    pub const fn new<Identity: IMFImageSharingEngine_Impl, const OFFSET: isize>() -> IMFImageSharingEngine_Vtbl {
        unsafe extern "system" fn SetSource<Identity: IMFImageSharingEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstream: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFImageSharingEngine_Impl::SetSource(this, windows_core::from_raw_borrowed(&pstream)).into()
        }
        unsafe extern "system" fn GetDevice<Identity: IMFImageSharingEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdevice: *mut DEVICE_INFO) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFImageSharingEngine_Impl::GetDevice(this, core::mem::transmute_copy(&pdevice)).into()
        }
        unsafe extern "system" fn Shutdown<Identity: IMFImageSharingEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFImageSharingEngine_Impl::Shutdown(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetSource: SetSource::<Identity, OFFSET>,
            GetDevice: GetDevice::<Identity, OFFSET>,
            Shutdown: Shutdown::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFImageSharingEngine as windows_core::Interface>::IID
    }
}
pub trait IMFImageSharingEngineClassFactory_Impl: Sized + windows_core::IUnknownImpl {
    fn CreateInstanceFromUDN(&self, puniquedevicename: &windows_core::BSTR) -> windows_core::Result<IMFImageSharingEngine>;
}
impl windows_core::RuntimeName for IMFImageSharingEngineClassFactory {}
impl IMFImageSharingEngineClassFactory_Vtbl {
    pub const fn new<Identity: IMFImageSharingEngineClassFactory_Impl, const OFFSET: isize>() -> IMFImageSharingEngineClassFactory_Vtbl {
        unsafe extern "system" fn CreateInstanceFromUDN<Identity: IMFImageSharingEngineClassFactory_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, puniquedevicename: core::mem::MaybeUninit<windows_core::BSTR>, ppengine: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFImageSharingEngineClassFactory_Impl::CreateInstanceFromUDN(this, core::mem::transmute(&puniquedevicename)) {
                Ok(ok__) => {
                    ppengine.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), CreateInstanceFromUDN: CreateInstanceFromUDN::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFImageSharingEngineClassFactory as windows_core::Interface>::IID
    }
}
pub trait IMFInputTrustAuthority_Impl: Sized + windows_core::IUnknownImpl {
    fn GetDecrypter(&self, riid: *const windows_core::GUID, ppv: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn RequestAccess(&self, action: MFPOLICYMANAGER_ACTION) -> windows_core::Result<IMFActivate>;
    fn GetPolicy(&self, action: MFPOLICYMANAGER_ACTION) -> windows_core::Result<IMFOutputPolicy>;
    fn BindAccess(&self, pparam: *const MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS) -> windows_core::Result<()>;
    fn UpdateAccess(&self, pparam: *const MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS) -> windows_core::Result<()>;
    fn Reset(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFInputTrustAuthority {}
impl IMFInputTrustAuthority_Vtbl {
    pub const fn new<Identity: IMFInputTrustAuthority_Impl, const OFFSET: isize>() -> IMFInputTrustAuthority_Vtbl {
        unsafe extern "system" fn GetDecrypter<Identity: IMFInputTrustAuthority_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppv: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFInputTrustAuthority_Impl::GetDecrypter(this, core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppv)).into()
        }
        unsafe extern "system" fn RequestAccess<Identity: IMFInputTrustAuthority_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, action: MFPOLICYMANAGER_ACTION, ppcontentenableractivate: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFInputTrustAuthority_Impl::RequestAccess(this, core::mem::transmute_copy(&action)) {
                Ok(ok__) => {
                    ppcontentenableractivate.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPolicy<Identity: IMFInputTrustAuthority_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, action: MFPOLICYMANAGER_ACTION, pppolicy: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFInputTrustAuthority_Impl::GetPolicy(this, core::mem::transmute_copy(&action)) {
                Ok(ok__) => {
                    pppolicy.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BindAccess<Identity: IMFInputTrustAuthority_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pparam: *const MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFInputTrustAuthority_Impl::BindAccess(this, core::mem::transmute_copy(&pparam)).into()
        }
        unsafe extern "system" fn UpdateAccess<Identity: IMFInputTrustAuthority_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pparam: *const MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFInputTrustAuthority_Impl::UpdateAccess(this, core::mem::transmute_copy(&pparam)).into()
        }
        unsafe extern "system" fn Reset<Identity: IMFInputTrustAuthority_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFInputTrustAuthority_Impl::Reset(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetDecrypter: GetDecrypter::<Identity, OFFSET>,
            RequestAccess: RequestAccess::<Identity, OFFSET>,
            GetPolicy: GetPolicy::<Identity, OFFSET>,
            BindAccess: BindAccess::<Identity, OFFSET>,
            UpdateAccess: UpdateAccess::<Identity, OFFSET>,
            Reset: Reset::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFInputTrustAuthority as windows_core::Interface>::IID
    }
}
pub trait IMFLocalMFTRegistration_Impl: Sized + windows_core::IUnknownImpl {
    fn RegisterMFTs(&self, pmfts: *const MFT_REGISTRATION_INFO, cmfts: u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFLocalMFTRegistration {}
impl IMFLocalMFTRegistration_Vtbl {
    pub const fn new<Identity: IMFLocalMFTRegistration_Impl, const OFFSET: isize>() -> IMFLocalMFTRegistration_Vtbl {
        unsafe extern "system" fn RegisterMFTs<Identity: IMFLocalMFTRegistration_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmfts: *const MFT_REGISTRATION_INFO, cmfts: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFLocalMFTRegistration_Impl::RegisterMFTs(this, core::mem::transmute_copy(&pmfts), core::mem::transmute_copy(&cmfts)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), RegisterMFTs: RegisterMFTs::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFLocalMFTRegistration as windows_core::Interface>::IID
    }
}
pub trait IMFMediaBuffer_Impl: Sized + windows_core::IUnknownImpl {
    fn Lock(&self, ppbbuffer: *mut *mut u8, pcbmaxlength: *mut u32, pcbcurrentlength: *mut u32) -> windows_core::Result<()>;
    fn Unlock(&self) -> windows_core::Result<()>;
    fn GetCurrentLength(&self) -> windows_core::Result<u32>;
    fn SetCurrentLength(&self, cbcurrentlength: u32) -> windows_core::Result<()>;
    fn GetMaxLength(&self) -> windows_core::Result<u32>;
}
impl windows_core::RuntimeName for IMFMediaBuffer {}
impl IMFMediaBuffer_Vtbl {
    pub const fn new<Identity: IMFMediaBuffer_Impl, const OFFSET: isize>() -> IMFMediaBuffer_Vtbl {
        unsafe extern "system" fn Lock<Identity: IMFMediaBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppbbuffer: *mut *mut u8, pcbmaxlength: *mut u32, pcbcurrentlength: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaBuffer_Impl::Lock(this, core::mem::transmute_copy(&ppbbuffer), core::mem::transmute_copy(&pcbmaxlength), core::mem::transmute_copy(&pcbcurrentlength)).into()
        }
        unsafe extern "system" fn Unlock<Identity: IMFMediaBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaBuffer_Impl::Unlock(this).into()
        }
        unsafe extern "system" fn GetCurrentLength<Identity: IMFMediaBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcbcurrentlength: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaBuffer_Impl::GetCurrentLength(this) {
                Ok(ok__) => {
                    pcbcurrentlength.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentLength<Identity: IMFMediaBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cbcurrentlength: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaBuffer_Impl::SetCurrentLength(this, core::mem::transmute_copy(&cbcurrentlength)).into()
        }
        unsafe extern "system" fn GetMaxLength<Identity: IMFMediaBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcbmaxlength: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaBuffer_Impl::GetMaxLength(this) {
                Ok(ok__) => {
                    pcbmaxlength.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Lock: Lock::<Identity, OFFSET>,
            Unlock: Unlock::<Identity, OFFSET>,
            GetCurrentLength: GetCurrentLength::<Identity, OFFSET>,
            SetCurrentLength: SetCurrentLength::<Identity, OFFSET>,
            GetMaxLength: GetMaxLength::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaBuffer as windows_core::Interface>::IID
    }
}
pub trait IMFMediaEngine_Impl: Sized + windows_core::IUnknownImpl {
    fn GetError(&self) -> windows_core::Result<IMFMediaError>;
    fn SetErrorCode(&self, error: MF_MEDIA_ENGINE_ERR) -> windows_core::Result<()>;
    fn SetSourceElements(&self, psrcelements: Option<&IMFMediaEngineSrcElements>) -> windows_core::Result<()>;
    fn SetSource(&self, purl: &windows_core::BSTR) -> windows_core::Result<()>;
    fn GetCurrentSource(&self) -> windows_core::Result<windows_core::BSTR>;
    fn GetNetworkState(&self) -> u16;
    fn GetPreload(&self) -> MF_MEDIA_ENGINE_PRELOAD;
    fn SetPreload(&self, preload: MF_MEDIA_ENGINE_PRELOAD) -> windows_core::Result<()>;
    fn GetBuffered(&self) -> windows_core::Result<IMFMediaTimeRange>;
    fn Load(&self) -> windows_core::Result<()>;
    fn CanPlayType(&self, r#type: &windows_core::BSTR) -> windows_core::Result<MF_MEDIA_ENGINE_CANPLAY>;
    fn GetReadyState(&self) -> u16;
    fn IsSeeking(&self) -> super::super::Foundation::BOOL;
    fn GetCurrentTime(&self) -> f64;
    fn SetCurrentTime(&self, seektime: f64) -> windows_core::Result<()>;
    fn GetStartTime(&self) -> f64;
    fn GetDuration(&self) -> f64;
    fn IsPaused(&self) -> super::super::Foundation::BOOL;
    fn GetDefaultPlaybackRate(&self) -> f64;
    fn SetDefaultPlaybackRate(&self, rate: f64) -> windows_core::Result<()>;
    fn GetPlaybackRate(&self) -> f64;
    fn SetPlaybackRate(&self, rate: f64) -> windows_core::Result<()>;
    fn GetPlayed(&self) -> windows_core::Result<IMFMediaTimeRange>;
    fn GetSeekable(&self) -> windows_core::Result<IMFMediaTimeRange>;
    fn IsEnded(&self) -> super::super::Foundation::BOOL;
    fn GetAutoPlay(&self) -> super::super::Foundation::BOOL;
    fn SetAutoPlay(&self, autoplay: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn GetLoop(&self) -> super::super::Foundation::BOOL;
    fn SetLoop(&self, r#loop: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn Play(&self) -> windows_core::Result<()>;
    fn Pause(&self) -> windows_core::Result<()>;
    fn GetMuted(&self) -> super::super::Foundation::BOOL;
    fn SetMuted(&self, muted: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn GetVolume(&self) -> f64;
    fn SetVolume(&self, volume: f64) -> windows_core::Result<()>;
    fn HasVideo(&self) -> super::super::Foundation::BOOL;
    fn HasAudio(&self) -> super::super::Foundation::BOOL;
    fn GetNativeVideoSize(&self, cx: *mut u32, cy: *mut u32) -> windows_core::Result<()>;
    fn GetVideoAspectRatio(&self, cx: *mut u32, cy: *mut u32) -> windows_core::Result<()>;
    fn Shutdown(&self) -> windows_core::Result<()>;
    fn TransferVideoFrame(&self, pdstsurf: Option<&windows_core::IUnknown>, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const MFARGB) -> windows_core::Result<()>;
    fn OnVideoStreamTick(&self) -> windows_core::Result<i64>;
}
impl windows_core::RuntimeName for IMFMediaEngine {}
impl IMFMediaEngine_Vtbl {
    pub const fn new<Identity: IMFMediaEngine_Impl, const OFFSET: isize>() -> IMFMediaEngine_Vtbl {
        unsafe extern "system" fn GetError<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pperror: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngine_Impl::GetError(this) {
                Ok(ok__) => {
                    pperror.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetErrorCode<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, error: MF_MEDIA_ENGINE_ERR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::SetErrorCode(this, core::mem::transmute_copy(&error)).into()
        }
        unsafe extern "system" fn SetSourceElements<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psrcelements: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::SetSourceElements(this, windows_core::from_raw_borrowed(&psrcelements)).into()
        }
        unsafe extern "system" fn SetSource<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, purl: core::mem::MaybeUninit<windows_core::BSTR>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::SetSource(this, core::mem::transmute(&purl)).into()
        }
        unsafe extern "system" fn GetCurrentSource<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppurl: *mut core::mem::MaybeUninit<windows_core::BSTR>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngine_Impl::GetCurrentSource(this) {
                Ok(ok__) => {
                    ppurl.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNetworkState<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u16 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::GetNetworkState(this)
        }
        unsafe extern "system" fn GetPreload<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> MF_MEDIA_ENGINE_PRELOAD {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::GetPreload(this)
        }
        unsafe extern "system" fn SetPreload<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, preload: MF_MEDIA_ENGINE_PRELOAD) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::SetPreload(this, core::mem::transmute_copy(&preload)).into()
        }
        unsafe extern "system" fn GetBuffered<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppbuffered: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngine_Impl::GetBuffered(this) {
                Ok(ok__) => {
                    ppbuffered.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Load<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::Load(this).into()
        }
        unsafe extern "system" fn CanPlayType<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, r#type: core::mem::MaybeUninit<windows_core::BSTR>, panswer: *mut MF_MEDIA_ENGINE_CANPLAY) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngine_Impl::CanPlayType(this, core::mem::transmute(&r#type)) {
                Ok(ok__) => {
                    panswer.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetReadyState<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u16 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::GetReadyState(this)
        }
        unsafe extern "system" fn IsSeeking<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::IsSeeking(this)
        }
        unsafe extern "system" fn GetCurrentTime<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> f64 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::GetCurrentTime(this)
        }
        unsafe extern "system" fn SetCurrentTime<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, seektime: f64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::SetCurrentTime(this, core::mem::transmute_copy(&seektime)).into()
        }
        unsafe extern "system" fn GetStartTime<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> f64 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::GetStartTime(this)
        }
        unsafe extern "system" fn GetDuration<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> f64 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::GetDuration(this)
        }
        unsafe extern "system" fn IsPaused<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::IsPaused(this)
        }
        unsafe extern "system" fn GetDefaultPlaybackRate<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> f64 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::GetDefaultPlaybackRate(this)
        }
        unsafe extern "system" fn SetDefaultPlaybackRate<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, rate: f64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::SetDefaultPlaybackRate(this, core::mem::transmute_copy(&rate)).into()
        }
        unsafe extern "system" fn GetPlaybackRate<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> f64 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::GetPlaybackRate(this)
        }
        unsafe extern "system" fn SetPlaybackRate<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, rate: f64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::SetPlaybackRate(this, core::mem::transmute_copy(&rate)).into()
        }
        unsafe extern "system" fn GetPlayed<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppplayed: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngine_Impl::GetPlayed(this) {
                Ok(ok__) => {
                    ppplayed.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSeekable<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppseekable: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngine_Impl::GetSeekable(this) {
                Ok(ok__) => {
                    ppseekable.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsEnded<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::IsEnded(this)
        }
        unsafe extern "system" fn GetAutoPlay<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::GetAutoPlay(this)
        }
        unsafe extern "system" fn SetAutoPlay<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, autoplay: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::SetAutoPlay(this, core::mem::transmute_copy(&autoplay)).into()
        }
        unsafe extern "system" fn GetLoop<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::GetLoop(this)
        }
        unsafe extern "system" fn SetLoop<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, r#loop: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::SetLoop(this, core::mem::transmute_copy(&r#loop)).into()
        }
        unsafe extern "system" fn Play<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::Play(this).into()
        }
        unsafe extern "system" fn Pause<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::Pause(this).into()
        }
        unsafe extern "system" fn GetMuted<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::GetMuted(this)
        }
        unsafe extern "system" fn SetMuted<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, muted: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::SetMuted(this, core::mem::transmute_copy(&muted)).into()
        }
        unsafe extern "system" fn GetVolume<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> f64 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::GetVolume(this)
        }
        unsafe extern "system" fn SetVolume<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, volume: f64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::SetVolume(this, core::mem::transmute_copy(&volume)).into()
        }
        unsafe extern "system" fn HasVideo<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::HasVideo(this)
        }
        unsafe extern "system" fn HasAudio<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::HasAudio(this)
        }
        unsafe extern "system" fn GetNativeVideoSize<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cx: *mut u32, cy: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::GetNativeVideoSize(this, core::mem::transmute_copy(&cx), core::mem::transmute_copy(&cy)).into()
        }
        unsafe extern "system" fn GetVideoAspectRatio<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cx: *mut u32, cy: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::GetVideoAspectRatio(this, core::mem::transmute_copy(&cx), core::mem::transmute_copy(&cy)).into()
        }
        unsafe extern "system" fn Shutdown<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::Shutdown(this).into()
        }
        unsafe extern "system" fn TransferVideoFrame<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdstsurf: *mut core::ffi::c_void, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const MFARGB) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngine_Impl::TransferVideoFrame(this, windows_core::from_raw_borrowed(&pdstsurf), core::mem::transmute_copy(&psrc), core::mem::transmute_copy(&pdst), core::mem::transmute_copy(&pborderclr)).into()
        }
        unsafe extern "system" fn OnVideoStreamTick<Identity: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppts: *mut i64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngine_Impl::OnVideoStreamTick(this) {
                Ok(ok__) => {
                    ppts.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetError: GetError::<Identity, OFFSET>,
            SetErrorCode: SetErrorCode::<Identity, OFFSET>,
            SetSourceElements: SetSourceElements::<Identity, OFFSET>,
            SetSource: SetSource::<Identity, OFFSET>,
            GetCurrentSource: GetCurrentSource::<Identity, OFFSET>,
            GetNetworkState: GetNetworkState::<Identity, OFFSET>,
            GetPreload: GetPreload::<Identity, OFFSET>,
            SetPreload: SetPreload::<Identity, OFFSET>,
            GetBuffered: GetBuffered::<Identity, OFFSET>,
            Load: Load::<Identity, OFFSET>,
            CanPlayType: CanPlayType::<Identity, OFFSET>,
            GetReadyState: GetReadyState::<Identity, OFFSET>,
            IsSeeking: IsSeeking::<Identity, OFFSET>,
            GetCurrentTime: GetCurrentTime::<Identity, OFFSET>,
            SetCurrentTime: SetCurrentTime::<Identity, OFFSET>,
            GetStartTime: GetStartTime::<Identity, OFFSET>,
            GetDuration: GetDuration::<Identity, OFFSET>,
            IsPaused: IsPaused::<Identity, OFFSET>,
            GetDefaultPlaybackRate: GetDefaultPlaybackRate::<Identity, OFFSET>,
            SetDefaultPlaybackRate: SetDefaultPlaybackRate::<Identity, OFFSET>,
            GetPlaybackRate: GetPlaybackRate::<Identity, OFFSET>,
            SetPlaybackRate: SetPlaybackRate::<Identity, OFFSET>,
            GetPlayed: GetPlayed::<Identity, OFFSET>,
            GetSeekable: GetSeekable::<Identity, OFFSET>,
            IsEnded: IsEnded::<Identity, OFFSET>,
            GetAutoPlay: GetAutoPlay::<Identity, OFFSET>,
            SetAutoPlay: SetAutoPlay::<Identity, OFFSET>,
            GetLoop: GetLoop::<Identity, OFFSET>,
            SetLoop: SetLoop::<Identity, OFFSET>,
            Play: Play::<Identity, OFFSET>,
            Pause: Pause::<Identity, OFFSET>,
            GetMuted: GetMuted::<Identity, OFFSET>,
            SetMuted: SetMuted::<Identity, OFFSET>,
            GetVolume: GetVolume::<Identity, OFFSET>,
            SetVolume: SetVolume::<Identity, OFFSET>,
            HasVideo: HasVideo::<Identity, OFFSET>,
            HasAudio: HasAudio::<Identity, OFFSET>,
            GetNativeVideoSize: GetNativeVideoSize::<Identity, OFFSET>,
            GetVideoAspectRatio: GetVideoAspectRatio::<Identity, OFFSET>,
            Shutdown: Shutdown::<Identity, OFFSET>,
            TransferVideoFrame: TransferVideoFrame::<Identity, OFFSET>,
            OnVideoStreamTick: OnVideoStreamTick::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaEngine as windows_core::Interface>::IID
    }
}
pub trait IMFMediaEngineAudioEndpointId_Impl: Sized + windows_core::IUnknownImpl {
    fn SetAudioEndpointId(&self, pszendpointid: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn GetAudioEndpointId(&self) -> windows_core::Result<windows_core::PWSTR>;
}
impl windows_core::RuntimeName for IMFMediaEngineAudioEndpointId {}
impl IMFMediaEngineAudioEndpointId_Vtbl {
    pub const fn new<Identity: IMFMediaEngineAudioEndpointId_Impl, const OFFSET: isize>() -> IMFMediaEngineAudioEndpointId_Vtbl {
        unsafe extern "system" fn SetAudioEndpointId<Identity: IMFMediaEngineAudioEndpointId_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszendpointid: windows_core::PCWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineAudioEndpointId_Impl::SetAudioEndpointId(this, core::mem::transmute(&pszendpointid)).into()
        }
        unsafe extern "system" fn GetAudioEndpointId<Identity: IMFMediaEngineAudioEndpointId_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppszendpointid: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineAudioEndpointId_Impl::GetAudioEndpointId(this) {
                Ok(ok__) => {
                    ppszendpointid.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetAudioEndpointId: SetAudioEndpointId::<Identity, OFFSET>,
            GetAudioEndpointId: GetAudioEndpointId::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaEngineAudioEndpointId as windows_core::Interface>::IID
    }
}
pub trait IMFMediaEngineClassFactory_Impl: Sized + windows_core::IUnknownImpl {
    fn CreateInstance(&self, dwflags: u32, pattr: Option<&IMFAttributes>) -> windows_core::Result<IMFMediaEngine>;
    fn CreateTimeRange(&self) -> windows_core::Result<IMFMediaTimeRange>;
    fn CreateError(&self) -> windows_core::Result<IMFMediaError>;
}
impl windows_core::RuntimeName for IMFMediaEngineClassFactory {}
impl IMFMediaEngineClassFactory_Vtbl {
    pub const fn new<Identity: IMFMediaEngineClassFactory_Impl, const OFFSET: isize>() -> IMFMediaEngineClassFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Identity: IMFMediaEngineClassFactory_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32, pattr: *mut core::ffi::c_void, ppplayer: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineClassFactory_Impl::CreateInstance(this, core::mem::transmute_copy(&dwflags), windows_core::from_raw_borrowed(&pattr)) {
                Ok(ok__) => {
                    ppplayer.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateTimeRange<Identity: IMFMediaEngineClassFactory_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pptimerange: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineClassFactory_Impl::CreateTimeRange(this) {
                Ok(ok__) => {
                    pptimerange.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateError<Identity: IMFMediaEngineClassFactory_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pperror: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineClassFactory_Impl::CreateError(this) {
                Ok(ok__) => {
                    pperror.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            CreateInstance: CreateInstance::<Identity, OFFSET>,
            CreateTimeRange: CreateTimeRange::<Identity, OFFSET>,
            CreateError: CreateError::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaEngineClassFactory as windows_core::Interface>::IID
    }
}
pub trait IMFMediaEngineClassFactory2_Impl: Sized + windows_core::IUnknownImpl {
    fn CreateMediaKeys2(&self, keysystem: &windows_core::BSTR, defaultcdmstorepath: &windows_core::BSTR, inprivatecdmstorepath: &windows_core::BSTR) -> windows_core::Result<IMFMediaKeys>;
}
impl windows_core::RuntimeName for IMFMediaEngineClassFactory2 {}
impl IMFMediaEngineClassFactory2_Vtbl {
    pub const fn new<Identity: IMFMediaEngineClassFactory2_Impl, const OFFSET: isize>() -> IMFMediaEngineClassFactory2_Vtbl {
        unsafe extern "system" fn CreateMediaKeys2<Identity: IMFMediaEngineClassFactory2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, keysystem: core::mem::MaybeUninit<windows_core::BSTR>, defaultcdmstorepath: core::mem::MaybeUninit<windows_core::BSTR>, inprivatecdmstorepath: core::mem::MaybeUninit<windows_core::BSTR>, ppkeys: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineClassFactory2_Impl::CreateMediaKeys2(this, core::mem::transmute(&keysystem), core::mem::transmute(&defaultcdmstorepath), core::mem::transmute(&inprivatecdmstorepath)) {
                Ok(ok__) => {
                    ppkeys.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), CreateMediaKeys2: CreateMediaKeys2::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaEngineClassFactory2 as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub trait IMFMediaEngineClassFactory3_Impl: Sized + windows_core::IUnknownImpl {
    fn CreateMediaKeySystemAccess(&self, keysystem: &windows_core::BSTR, ppsupportedconfigurationsarray: *const Option<super::super::UI::Shell::PropertiesSystem::IPropertyStore>, usize: u32) -> windows_core::Result<IMFMediaKeySystemAccess>;
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl windows_core::RuntimeName for IMFMediaEngineClassFactory3 {}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl IMFMediaEngineClassFactory3_Vtbl {
    pub const fn new<Identity: IMFMediaEngineClassFactory3_Impl, const OFFSET: isize>() -> IMFMediaEngineClassFactory3_Vtbl {
        unsafe extern "system" fn CreateMediaKeySystemAccess<Identity: IMFMediaEngineClassFactory3_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, keysystem: core::mem::MaybeUninit<windows_core::BSTR>, ppsupportedconfigurationsarray: *const *mut core::ffi::c_void, usize: u32, ppkeyaccess: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineClassFactory3_Impl::CreateMediaKeySystemAccess(this, core::mem::transmute(&keysystem), core::mem::transmute_copy(&ppsupportedconfigurationsarray), core::mem::transmute_copy(&usize)) {
                Ok(ok__) => {
                    ppkeyaccess.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), CreateMediaKeySystemAccess: CreateMediaKeySystemAccess::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaEngineClassFactory3 as windows_core::Interface>::IID
    }
}
pub trait IMFMediaEngineClassFactory4_Impl: Sized + windows_core::IUnknownImpl {
    fn CreateContentDecryptionModuleFactory(&self, keysystem: &windows_core::PCWSTR, riid: *const windows_core::GUID, ppvobject: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFMediaEngineClassFactory4 {}
impl IMFMediaEngineClassFactory4_Vtbl {
    pub const fn new<Identity: IMFMediaEngineClassFactory4_Impl, const OFFSET: isize>() -> IMFMediaEngineClassFactory4_Vtbl {
        unsafe extern "system" fn CreateContentDecryptionModuleFactory<Identity: IMFMediaEngineClassFactory4_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, keysystem: windows_core::PCWSTR, riid: *const windows_core::GUID, ppvobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineClassFactory4_Impl::CreateContentDecryptionModuleFactory(this, core::mem::transmute(&keysystem), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvobject)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            CreateContentDecryptionModuleFactory: CreateContentDecryptionModuleFactory::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaEngineClassFactory4 as windows_core::Interface>::IID
    }
}
pub trait IMFMediaEngineClassFactoryEx_Impl: Sized + IMFMediaEngineClassFactory_Impl {
    fn CreateMediaSourceExtension(&self, dwflags: u32, pattr: Option<&IMFAttributes>) -> windows_core::Result<IMFMediaSourceExtension>;
    fn CreateMediaKeys(&self, keysystem: &windows_core::BSTR, cdmstorepath: &windows_core::BSTR) -> windows_core::Result<IMFMediaKeys>;
    fn IsTypeSupported(&self, r#type: &windows_core::BSTR, keysystem: &windows_core::BSTR) -> windows_core::Result<super::super::Foundation::BOOL>;
}
impl windows_core::RuntimeName for IMFMediaEngineClassFactoryEx {}
impl IMFMediaEngineClassFactoryEx_Vtbl {
    pub const fn new<Identity: IMFMediaEngineClassFactoryEx_Impl, const OFFSET: isize>() -> IMFMediaEngineClassFactoryEx_Vtbl {
        unsafe extern "system" fn CreateMediaSourceExtension<Identity: IMFMediaEngineClassFactoryEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32, pattr: *mut core::ffi::c_void, ppmse: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineClassFactoryEx_Impl::CreateMediaSourceExtension(this, core::mem::transmute_copy(&dwflags), windows_core::from_raw_borrowed(&pattr)) {
                Ok(ok__) => {
                    ppmse.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateMediaKeys<Identity: IMFMediaEngineClassFactoryEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, keysystem: core::mem::MaybeUninit<windows_core::BSTR>, cdmstorepath: core::mem::MaybeUninit<windows_core::BSTR>, ppkeys: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineClassFactoryEx_Impl::CreateMediaKeys(this, core::mem::transmute(&keysystem), core::mem::transmute(&cdmstorepath)) {
                Ok(ok__) => {
                    ppkeys.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTypeSupported<Identity: IMFMediaEngineClassFactoryEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, r#type: core::mem::MaybeUninit<windows_core::BSTR>, keysystem: core::mem::MaybeUninit<windows_core::BSTR>, issupported: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineClassFactoryEx_Impl::IsTypeSupported(this, core::mem::transmute(&r#type), core::mem::transmute(&keysystem)) {
                Ok(ok__) => {
                    issupported.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IMFMediaEngineClassFactory_Vtbl::new::<Identity, OFFSET>(),
            CreateMediaSourceExtension: CreateMediaSourceExtension::<Identity, OFFSET>,
            CreateMediaKeys: CreateMediaKeys::<Identity, OFFSET>,
            IsTypeSupported: IsTypeSupported::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaEngineClassFactoryEx as windows_core::Interface>::IID || iid == &<IMFMediaEngineClassFactory as windows_core::Interface>::IID
    }
}
pub trait IMFMediaEngineEME_Impl: Sized + windows_core::IUnknownImpl {
    fn Keys(&self) -> windows_core::Result<IMFMediaKeys>;
    fn SetMediaKeys(&self, keys: Option<&IMFMediaKeys>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFMediaEngineEME {}
impl IMFMediaEngineEME_Vtbl {
    pub const fn new<Identity: IMFMediaEngineEME_Impl, const OFFSET: isize>() -> IMFMediaEngineEME_Vtbl {
        unsafe extern "system" fn Keys<Identity: IMFMediaEngineEME_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, keys: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineEME_Impl::Keys(this) {
                Ok(ok__) => {
                    keys.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaKeys<Identity: IMFMediaEngineEME_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, keys: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEME_Impl::SetMediaKeys(this, windows_core::from_raw_borrowed(&keys)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Keys: Keys::<Identity, OFFSET>, SetMediaKeys: SetMediaKeys::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaEngineEME as windows_core::Interface>::IID
    }
}
pub trait IMFMediaEngineEMENotify_Impl: Sized + windows_core::IUnknownImpl {
    fn Encrypted(&self, pbinitdata: *const u8, cb: u32, bstrinitdatatype: &windows_core::BSTR);
    fn WaitingForKey(&self);
}
impl windows_core::RuntimeName for IMFMediaEngineEMENotify {}
impl IMFMediaEngineEMENotify_Vtbl {
    pub const fn new<Identity: IMFMediaEngineEMENotify_Impl, const OFFSET: isize>() -> IMFMediaEngineEMENotify_Vtbl {
        unsafe extern "system" fn Encrypted<Identity: IMFMediaEngineEMENotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbinitdata: *const u8, cb: u32, bstrinitdatatype: core::mem::MaybeUninit<windows_core::BSTR>) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEMENotify_Impl::Encrypted(this, core::mem::transmute_copy(&pbinitdata), core::mem::transmute_copy(&cb), core::mem::transmute(&bstrinitdatatype))
        }
        unsafe extern "system" fn WaitingForKey<Identity: IMFMediaEngineEMENotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEMENotify_Impl::WaitingForKey(this)
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Encrypted: Encrypted::<Identity, OFFSET>,
            WaitingForKey: WaitingForKey::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaEngineEMENotify as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFMediaEngineEx_Impl: Sized + IMFMediaEngine_Impl {
    fn SetSourceFromByteStream(&self, pbytestream: Option<&IMFByteStream>, purl: &windows_core::BSTR) -> windows_core::Result<()>;
    fn GetStatistics(&self, statisticid: MF_MEDIA_ENGINE_STATISTIC) -> windows_core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
    fn UpdateVideoStream(&self, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const MFARGB) -> windows_core::Result<()>;
    fn GetBalance(&self) -> f64;
    fn SetBalance(&self, balance: f64) -> windows_core::Result<()>;
    fn IsPlaybackRateSupported(&self, rate: f64) -> super::super::Foundation::BOOL;
    fn FrameStep(&self, forward: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn GetResourceCharacteristics(&self) -> windows_core::Result<u32>;
    fn GetPresentationAttribute(&self, guidmfattribute: *const windows_core::GUID) -> windows_core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
    fn GetNumberOfStreams(&self) -> windows_core::Result<u32>;
    fn GetStreamAttribute(&self, dwstreamindex: u32, guidmfattribute: *const windows_core::GUID) -> windows_core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
    fn GetStreamSelection(&self, dwstreamindex: u32) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn SetStreamSelection(&self, dwstreamindex: u32, enabled: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn ApplyStreamSelections(&self) -> windows_core::Result<()>;
    fn IsProtected(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn InsertVideoEffect(&self, peffect: Option<&windows_core::IUnknown>, foptional: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn InsertAudioEffect(&self, peffect: Option<&windows_core::IUnknown>, foptional: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn RemoveAllEffects(&self) -> windows_core::Result<()>;
    fn SetTimelineMarkerTimer(&self, timetofire: f64) -> windows_core::Result<()>;
    fn GetTimelineMarkerTimer(&self) -> windows_core::Result<f64>;
    fn CancelTimelineMarkerTimer(&self) -> windows_core::Result<()>;
    fn IsStereo3D(&self) -> super::super::Foundation::BOOL;
    fn GetStereo3DFramePackingMode(&self) -> windows_core::Result<MF_MEDIA_ENGINE_S3D_PACKING_MODE>;
    fn SetStereo3DFramePackingMode(&self, packmode: MF_MEDIA_ENGINE_S3D_PACKING_MODE) -> windows_core::Result<()>;
    fn GetStereo3DRenderMode(&self) -> windows_core::Result<MF3DVideoOutputType>;
    fn SetStereo3DRenderMode(&self, outputtype: MF3DVideoOutputType) -> windows_core::Result<()>;
    fn EnableWindowlessSwapchainMode(&self, fenable: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn GetVideoSwapchainHandle(&self) -> windows_core::Result<super::super::Foundation::HANDLE>;
    fn EnableHorizontalMirrorMode(&self, fenable: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn GetAudioStreamCategory(&self) -> windows_core::Result<u32>;
    fn SetAudioStreamCategory(&self, category: u32) -> windows_core::Result<()>;
    fn GetAudioEndpointRole(&self) -> windows_core::Result<u32>;
    fn SetAudioEndpointRole(&self, role: u32) -> windows_core::Result<()>;
    fn GetRealTimeMode(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn SetRealTimeMode(&self, fenable: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn SetCurrentTimeEx(&self, seektime: f64, seekmode: MF_MEDIA_ENGINE_SEEK_MODE) -> windows_core::Result<()>;
    fn EnableTimeUpdateTimer(&self, fenabletimer: super::super::Foundation::BOOL) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFMediaEngineEx {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFMediaEngineEx_Vtbl {
    pub const fn new<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>() -> IMFMediaEngineEx_Vtbl {
        unsafe extern "system" fn SetSourceFromByteStream<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbytestream: *mut core::ffi::c_void, purl: core::mem::MaybeUninit<windows_core::BSTR>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEx_Impl::SetSourceFromByteStream(this, windows_core::from_raw_borrowed(&pbytestream), core::mem::transmute(&purl)).into()
        }
        unsafe extern "system" fn GetStatistics<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, statisticid: MF_MEDIA_ENGINE_STATISTIC, pstatistic: *mut core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineEx_Impl::GetStatistics(this, core::mem::transmute_copy(&statisticid)) {
                Ok(ok__) => {
                    pstatistic.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UpdateVideoStream<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const MFARGB) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEx_Impl::UpdateVideoStream(this, core::mem::transmute_copy(&psrc), core::mem::transmute_copy(&pdst), core::mem::transmute_copy(&pborderclr)).into()
        }
        unsafe extern "system" fn GetBalance<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> f64 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEx_Impl::GetBalance(this)
        }
        unsafe extern "system" fn SetBalance<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, balance: f64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEx_Impl::SetBalance(this, core::mem::transmute_copy(&balance)).into()
        }
        unsafe extern "system" fn IsPlaybackRateSupported<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, rate: f64) -> super::super::Foundation::BOOL {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEx_Impl::IsPlaybackRateSupported(this, core::mem::transmute_copy(&rate))
        }
        unsafe extern "system" fn FrameStep<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, forward: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEx_Impl::FrameStep(this, core::mem::transmute_copy(&forward)).into()
        }
        unsafe extern "system" fn GetResourceCharacteristics<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcharacteristics: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineEx_Impl::GetResourceCharacteristics(this) {
                Ok(ok__) => {
                    pcharacteristics.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPresentationAttribute<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidmfattribute: *const windows_core::GUID, pvvalue: *mut core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineEx_Impl::GetPresentationAttribute(this, core::mem::transmute_copy(&guidmfattribute)) {
                Ok(ok__) => {
                    pvvalue.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNumberOfStreams<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwstreamcount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineEx_Impl::GetNumberOfStreams(this) {
                Ok(ok__) => {
                    pdwstreamcount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamAttribute<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, guidmfattribute: *const windows_core::GUID, pvvalue: *mut core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineEx_Impl::GetStreamAttribute(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&guidmfattribute)) {
                Ok(ok__) => {
                    pvvalue.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamSelection<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, penabled: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineEx_Impl::GetStreamSelection(this, core::mem::transmute_copy(&dwstreamindex)) {
                Ok(ok__) => {
                    penabled.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamSelection<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, enabled: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEx_Impl::SetStreamSelection(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&enabled)).into()
        }
        unsafe extern "system" fn ApplyStreamSelections<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEx_Impl::ApplyStreamSelections(this).into()
        }
        unsafe extern "system" fn IsProtected<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pprotected: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineEx_Impl::IsProtected(this) {
                Ok(ok__) => {
                    pprotected.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InsertVideoEffect<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, peffect: *mut core::ffi::c_void, foptional: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEx_Impl::InsertVideoEffect(this, windows_core::from_raw_borrowed(&peffect), core::mem::transmute_copy(&foptional)).into()
        }
        unsafe extern "system" fn InsertAudioEffect<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, peffect: *mut core::ffi::c_void, foptional: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEx_Impl::InsertAudioEffect(this, windows_core::from_raw_borrowed(&peffect), core::mem::transmute_copy(&foptional)).into()
        }
        unsafe extern "system" fn RemoveAllEffects<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEx_Impl::RemoveAllEffects(this).into()
        }
        unsafe extern "system" fn SetTimelineMarkerTimer<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, timetofire: f64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEx_Impl::SetTimelineMarkerTimer(this, core::mem::transmute_copy(&timetofire)).into()
        }
        unsafe extern "system" fn GetTimelineMarkerTimer<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptimetofire: *mut f64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineEx_Impl::GetTimelineMarkerTimer(this) {
                Ok(ok__) => {
                    ptimetofire.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CancelTimelineMarkerTimer<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEx_Impl::CancelTimelineMarkerTimer(this).into()
        }
        unsafe extern "system" fn IsStereo3D<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEx_Impl::IsStereo3D(this)
        }
        unsafe extern "system" fn GetStereo3DFramePackingMode<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, packmode: *mut MF_MEDIA_ENGINE_S3D_PACKING_MODE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineEx_Impl::GetStereo3DFramePackingMode(this) {
                Ok(ok__) => {
                    packmode.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStereo3DFramePackingMode<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, packmode: MF_MEDIA_ENGINE_S3D_PACKING_MODE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEx_Impl::SetStereo3DFramePackingMode(this, core::mem::transmute_copy(&packmode)).into()
        }
        unsafe extern "system" fn GetStereo3DRenderMode<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, outputtype: *mut MF3DVideoOutputType) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineEx_Impl::GetStereo3DRenderMode(this) {
                Ok(ok__) => {
                    outputtype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStereo3DRenderMode<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, outputtype: MF3DVideoOutputType) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEx_Impl::SetStereo3DRenderMode(this, core::mem::transmute_copy(&outputtype)).into()
        }
        unsafe extern "system" fn EnableWindowlessSwapchainMode<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fenable: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEx_Impl::EnableWindowlessSwapchainMode(this, core::mem::transmute_copy(&fenable)).into()
        }
        unsafe extern "system" fn GetVideoSwapchainHandle<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, phswapchain: *mut super::super::Foundation::HANDLE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineEx_Impl::GetVideoSwapchainHandle(this) {
                Ok(ok__) => {
                    phswapchain.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnableHorizontalMirrorMode<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fenable: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEx_Impl::EnableHorizontalMirrorMode(this, core::mem::transmute_copy(&fenable)).into()
        }
        unsafe extern "system" fn GetAudioStreamCategory<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcategory: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineEx_Impl::GetAudioStreamCategory(this) {
                Ok(ok__) => {
                    pcategory.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAudioStreamCategory<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, category: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEx_Impl::SetAudioStreamCategory(this, core::mem::transmute_copy(&category)).into()
        }
        unsafe extern "system" fn GetAudioEndpointRole<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, prole: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineEx_Impl::GetAudioEndpointRole(this) {
                Ok(ok__) => {
                    prole.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAudioEndpointRole<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, role: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEx_Impl::SetAudioEndpointRole(this, core::mem::transmute_copy(&role)).into()
        }
        unsafe extern "system" fn GetRealTimeMode<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfenabled: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineEx_Impl::GetRealTimeMode(this) {
                Ok(ok__) => {
                    pfenabled.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRealTimeMode<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fenable: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEx_Impl::SetRealTimeMode(this, core::mem::transmute_copy(&fenable)).into()
        }
        unsafe extern "system" fn SetCurrentTimeEx<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, seektime: f64, seekmode: MF_MEDIA_ENGINE_SEEK_MODE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEx_Impl::SetCurrentTimeEx(this, core::mem::transmute_copy(&seektime), core::mem::transmute_copy(&seekmode)).into()
        }
        unsafe extern "system" fn EnableTimeUpdateTimer<Identity: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fenabletimer: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineEx_Impl::EnableTimeUpdateTimer(this, core::mem::transmute_copy(&fenabletimer)).into()
        }
        Self {
            base__: IMFMediaEngine_Vtbl::new::<Identity, OFFSET>(),
            SetSourceFromByteStream: SetSourceFromByteStream::<Identity, OFFSET>,
            GetStatistics: GetStatistics::<Identity, OFFSET>,
            UpdateVideoStream: UpdateVideoStream::<Identity, OFFSET>,
            GetBalance: GetBalance::<Identity, OFFSET>,
            SetBalance: SetBalance::<Identity, OFFSET>,
            IsPlaybackRateSupported: IsPlaybackRateSupported::<Identity, OFFSET>,
            FrameStep: FrameStep::<Identity, OFFSET>,
            GetResourceCharacteristics: GetResourceCharacteristics::<Identity, OFFSET>,
            GetPresentationAttribute: GetPresentationAttribute::<Identity, OFFSET>,
            GetNumberOfStreams: GetNumberOfStreams::<Identity, OFFSET>,
            GetStreamAttribute: GetStreamAttribute::<Identity, OFFSET>,
            GetStreamSelection: GetStreamSelection::<Identity, OFFSET>,
            SetStreamSelection: SetStreamSelection::<Identity, OFFSET>,
            ApplyStreamSelections: ApplyStreamSelections::<Identity, OFFSET>,
            IsProtected: IsProtected::<Identity, OFFSET>,
            InsertVideoEffect: InsertVideoEffect::<Identity, OFFSET>,
            InsertAudioEffect: InsertAudioEffect::<Identity, OFFSET>,
            RemoveAllEffects: RemoveAllEffects::<Identity, OFFSET>,
            SetTimelineMarkerTimer: SetTimelineMarkerTimer::<Identity, OFFSET>,
            GetTimelineMarkerTimer: GetTimelineMarkerTimer::<Identity, OFFSET>,
            CancelTimelineMarkerTimer: CancelTimelineMarkerTimer::<Identity, OFFSET>,
            IsStereo3D: IsStereo3D::<Identity, OFFSET>,
            GetStereo3DFramePackingMode: GetStereo3DFramePackingMode::<Identity, OFFSET>,
            SetStereo3DFramePackingMode: SetStereo3DFramePackingMode::<Identity, OFFSET>,
            GetStereo3DRenderMode: GetStereo3DRenderMode::<Identity, OFFSET>,
            SetStereo3DRenderMode: SetStereo3DRenderMode::<Identity, OFFSET>,
            EnableWindowlessSwapchainMode: EnableWindowlessSwapchainMode::<Identity, OFFSET>,
            GetVideoSwapchainHandle: GetVideoSwapchainHandle::<Identity, OFFSET>,
            EnableHorizontalMirrorMode: EnableHorizontalMirrorMode::<Identity, OFFSET>,
            GetAudioStreamCategory: GetAudioStreamCategory::<Identity, OFFSET>,
            SetAudioStreamCategory: SetAudioStreamCategory::<Identity, OFFSET>,
            GetAudioEndpointRole: GetAudioEndpointRole::<Identity, OFFSET>,
            SetAudioEndpointRole: SetAudioEndpointRole::<Identity, OFFSET>,
            GetRealTimeMode: GetRealTimeMode::<Identity, OFFSET>,
            SetRealTimeMode: SetRealTimeMode::<Identity, OFFSET>,
            SetCurrentTimeEx: SetCurrentTimeEx::<Identity, OFFSET>,
            EnableTimeUpdateTimer: EnableTimeUpdateTimer::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaEngineEx as windows_core::Interface>::IID || iid == &<IMFMediaEngine as windows_core::Interface>::IID
    }
}
pub trait IMFMediaEngineExtension_Impl: Sized + windows_core::IUnknownImpl {
    fn CanPlayType(&self, audioonly: super::super::Foundation::BOOL, mimetype: &windows_core::BSTR) -> windows_core::Result<MF_MEDIA_ENGINE_CANPLAY>;
    fn BeginCreateObject(&self, bstrurl: &windows_core::BSTR, pbytestream: Option<&IMFByteStream>, r#type: MF_OBJECT_TYPE, ppiunknowncancelcookie: *mut Option<windows_core::IUnknown>, pcallback: Option<&IMFAsyncCallback>, punkstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn CancelObjectCreation(&self, piunknowncancelcookie: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndCreateObject(&self, presult: Option<&IMFAsyncResult>) -> windows_core::Result<windows_core::IUnknown>;
}
impl windows_core::RuntimeName for IMFMediaEngineExtension {}
impl IMFMediaEngineExtension_Vtbl {
    pub const fn new<Identity: IMFMediaEngineExtension_Impl, const OFFSET: isize>() -> IMFMediaEngineExtension_Vtbl {
        unsafe extern "system" fn CanPlayType<Identity: IMFMediaEngineExtension_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, audioonly: super::super::Foundation::BOOL, mimetype: core::mem::MaybeUninit<windows_core::BSTR>, panswer: *mut MF_MEDIA_ENGINE_CANPLAY) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineExtension_Impl::CanPlayType(this, core::mem::transmute_copy(&audioonly), core::mem::transmute(&mimetype)) {
                Ok(ok__) => {
                    panswer.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginCreateObject<Identity: IMFMediaEngineExtension_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bstrurl: core::mem::MaybeUninit<windows_core::BSTR>, pbytestream: *mut core::ffi::c_void, r#type: MF_OBJECT_TYPE, ppiunknowncancelcookie: *mut *mut core::ffi::c_void, pcallback: *mut core::ffi::c_void, punkstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineExtension_Impl::BeginCreateObject(this, core::mem::transmute(&bstrurl), windows_core::from_raw_borrowed(&pbytestream), core::mem::transmute_copy(&r#type), core::mem::transmute_copy(&ppiunknowncancelcookie), windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&punkstate)).into()
        }
        unsafe extern "system" fn CancelObjectCreation<Identity: IMFMediaEngineExtension_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, piunknowncancelcookie: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineExtension_Impl::CancelObjectCreation(this, windows_core::from_raw_borrowed(&piunknowncancelcookie)).into()
        }
        unsafe extern "system" fn EndCreateObject<Identity: IMFMediaEngineExtension_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void, ppobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineExtension_Impl::EndCreateObject(this, windows_core::from_raw_borrowed(&presult)) {
                Ok(ok__) => {
                    ppobject.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            CanPlayType: CanPlayType::<Identity, OFFSET>,
            BeginCreateObject: BeginCreateObject::<Identity, OFFSET>,
            CancelObjectCreation: CancelObjectCreation::<Identity, OFFSET>,
            EndCreateObject: EndCreateObject::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaEngineExtension as windows_core::Interface>::IID
    }
}
pub trait IMFMediaEngineNeedKeyNotify_Impl: Sized + windows_core::IUnknownImpl {
    fn NeedKey(&self, initdata: *const u8, cb: u32);
}
impl windows_core::RuntimeName for IMFMediaEngineNeedKeyNotify {}
impl IMFMediaEngineNeedKeyNotify_Vtbl {
    pub const fn new<Identity: IMFMediaEngineNeedKeyNotify_Impl, const OFFSET: isize>() -> IMFMediaEngineNeedKeyNotify_Vtbl {
        unsafe extern "system" fn NeedKey<Identity: IMFMediaEngineNeedKeyNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, initdata: *const u8, cb: u32) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineNeedKeyNotify_Impl::NeedKey(this, core::mem::transmute_copy(&initdata), core::mem::transmute_copy(&cb))
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), NeedKey: NeedKey::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaEngineNeedKeyNotify as windows_core::Interface>::IID
    }
}
pub trait IMFMediaEngineNotify_Impl: Sized + windows_core::IUnknownImpl {
    fn EventNotify(&self, event: u32, param1: usize, param2: u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFMediaEngineNotify {}
impl IMFMediaEngineNotify_Vtbl {
    pub const fn new<Identity: IMFMediaEngineNotify_Impl, const OFFSET: isize>() -> IMFMediaEngineNotify_Vtbl {
        unsafe extern "system" fn EventNotify<Identity: IMFMediaEngineNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, event: u32, param1: usize, param2: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineNotify_Impl::EventNotify(this, core::mem::transmute_copy(&event), core::mem::transmute_copy(&param1), core::mem::transmute_copy(&param2)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), EventNotify: EventNotify::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaEngineNotify as windows_core::Interface>::IID
    }
}
pub trait IMFMediaEngineOPMInfo_Impl: Sized + windows_core::IUnknownImpl {
    fn GetOPMInfo(&self, pstatus: *mut MF_MEDIA_ENGINE_OPM_STATUS, pconstricted: *mut super::super::Foundation::BOOL) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFMediaEngineOPMInfo {}
impl IMFMediaEngineOPMInfo_Vtbl {
    pub const fn new<Identity: IMFMediaEngineOPMInfo_Impl, const OFFSET: isize>() -> IMFMediaEngineOPMInfo_Vtbl {
        unsafe extern "system" fn GetOPMInfo<Identity: IMFMediaEngineOPMInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstatus: *mut MF_MEDIA_ENGINE_OPM_STATUS, pconstricted: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineOPMInfo_Impl::GetOPMInfo(this, core::mem::transmute_copy(&pstatus), core::mem::transmute_copy(&pconstricted)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetOPMInfo: GetOPMInfo::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaEngineOPMInfo as windows_core::Interface>::IID
    }
}
pub trait IMFMediaEngineProtectedContent_Impl: Sized + windows_core::IUnknownImpl {
    fn ShareResources(&self, punkdevicecontext: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn GetRequiredProtections(&self) -> windows_core::Result<u32>;
    fn SetOPMWindow(&self, hwnd: super::super::Foundation::HWND) -> windows_core::Result<()>;
    fn TransferVideoFrame(&self, pdstsurf: Option<&windows_core::IUnknown>, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const MFARGB) -> windows_core::Result<u32>;
    fn SetContentProtectionManager(&self, pcpm: Option<&IMFContentProtectionManager>) -> windows_core::Result<()>;
    fn SetApplicationCertificate(&self, pbblob: *const u8, cbblob: u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFMediaEngineProtectedContent {}
impl IMFMediaEngineProtectedContent_Vtbl {
    pub const fn new<Identity: IMFMediaEngineProtectedContent_Impl, const OFFSET: isize>() -> IMFMediaEngineProtectedContent_Vtbl {
        unsafe extern "system" fn ShareResources<Identity: IMFMediaEngineProtectedContent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, punkdevicecontext: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineProtectedContent_Impl::ShareResources(this, windows_core::from_raw_borrowed(&punkdevicecontext)).into()
        }
        unsafe extern "system" fn GetRequiredProtections<Identity: IMFMediaEngineProtectedContent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pframeprotectionflags: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineProtectedContent_Impl::GetRequiredProtections(this) {
                Ok(ok__) => {
                    pframeprotectionflags.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOPMWindow<Identity: IMFMediaEngineProtectedContent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hwnd: super::super::Foundation::HWND) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineProtectedContent_Impl::SetOPMWindow(this, core::mem::transmute_copy(&hwnd)).into()
        }
        unsafe extern "system" fn TransferVideoFrame<Identity: IMFMediaEngineProtectedContent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdstsurf: *mut core::ffi::c_void, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const MFARGB, pframeprotectionflags: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineProtectedContent_Impl::TransferVideoFrame(this, windows_core::from_raw_borrowed(&pdstsurf), core::mem::transmute_copy(&psrc), core::mem::transmute_copy(&pdst), core::mem::transmute_copy(&pborderclr)) {
                Ok(ok__) => {
                    pframeprotectionflags.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentProtectionManager<Identity: IMFMediaEngineProtectedContent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcpm: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineProtectedContent_Impl::SetContentProtectionManager(this, windows_core::from_raw_borrowed(&pcpm)).into()
        }
        unsafe extern "system" fn SetApplicationCertificate<Identity: IMFMediaEngineProtectedContent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbblob: *const u8, cbblob: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineProtectedContent_Impl::SetApplicationCertificate(this, core::mem::transmute_copy(&pbblob), core::mem::transmute_copy(&cbblob)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            ShareResources: ShareResources::<Identity, OFFSET>,
            GetRequiredProtections: GetRequiredProtections::<Identity, OFFSET>,
            SetOPMWindow: SetOPMWindow::<Identity, OFFSET>,
            TransferVideoFrame: TransferVideoFrame::<Identity, OFFSET>,
            SetContentProtectionManager: SetContentProtectionManager::<Identity, OFFSET>,
            SetApplicationCertificate: SetApplicationCertificate::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaEngineProtectedContent as windows_core::Interface>::IID
    }
}
pub trait IMFMediaEngineSrcElements_Impl: Sized + windows_core::IUnknownImpl {
    fn GetLength(&self) -> u32;
    fn GetURL(&self, index: u32) -> windows_core::Result<windows_core::BSTR>;
    fn GetType(&self, index: u32) -> windows_core::Result<windows_core::BSTR>;
    fn GetMedia(&self, index: u32) -> windows_core::Result<windows_core::BSTR>;
    fn AddElement(&self, purl: &windows_core::BSTR, ptype: &windows_core::BSTR, pmedia: &windows_core::BSTR) -> windows_core::Result<()>;
    fn RemoveAllElements(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFMediaEngineSrcElements {}
impl IMFMediaEngineSrcElements_Vtbl {
    pub const fn new<Identity: IMFMediaEngineSrcElements_Impl, const OFFSET: isize>() -> IMFMediaEngineSrcElements_Vtbl {
        unsafe extern "system" fn GetLength<Identity: IMFMediaEngineSrcElements_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u32 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineSrcElements_Impl::GetLength(this)
        }
        unsafe extern "system" fn GetURL<Identity: IMFMediaEngineSrcElements_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, index: u32, purl: *mut core::mem::MaybeUninit<windows_core::BSTR>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineSrcElements_Impl::GetURL(this, core::mem::transmute_copy(&index)) {
                Ok(ok__) => {
                    purl.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetType<Identity: IMFMediaEngineSrcElements_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, index: u32, ptype: *mut core::mem::MaybeUninit<windows_core::BSTR>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineSrcElements_Impl::GetType(this, core::mem::transmute_copy(&index)) {
                Ok(ok__) => {
                    ptype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMedia<Identity: IMFMediaEngineSrcElements_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, index: u32, pmedia: *mut core::mem::MaybeUninit<windows_core::BSTR>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineSrcElements_Impl::GetMedia(this, core::mem::transmute_copy(&index)) {
                Ok(ok__) => {
                    pmedia.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddElement<Identity: IMFMediaEngineSrcElements_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, purl: core::mem::MaybeUninit<windows_core::BSTR>, ptype: core::mem::MaybeUninit<windows_core::BSTR>, pmedia: core::mem::MaybeUninit<windows_core::BSTR>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineSrcElements_Impl::AddElement(this, core::mem::transmute(&purl), core::mem::transmute(&ptype), core::mem::transmute(&pmedia)).into()
        }
        unsafe extern "system" fn RemoveAllElements<Identity: IMFMediaEngineSrcElements_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineSrcElements_Impl::RemoveAllElements(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetLength: GetLength::<Identity, OFFSET>,
            GetURL: GetURL::<Identity, OFFSET>,
            GetType: GetType::<Identity, OFFSET>,
            GetMedia: GetMedia::<Identity, OFFSET>,
            AddElement: AddElement::<Identity, OFFSET>,
            RemoveAllElements: RemoveAllElements::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaEngineSrcElements as windows_core::Interface>::IID
    }
}
pub trait IMFMediaEngineSrcElementsEx_Impl: Sized + IMFMediaEngineSrcElements_Impl {
    fn AddElementEx(&self, purl: &windows_core::BSTR, ptype: &windows_core::BSTR, pmedia: &windows_core::BSTR, keysystem: &windows_core::BSTR) -> windows_core::Result<()>;
    fn GetKeySystem(&self, index: u32) -> windows_core::Result<windows_core::BSTR>;
}
impl windows_core::RuntimeName for IMFMediaEngineSrcElementsEx {}
impl IMFMediaEngineSrcElementsEx_Vtbl {
    pub const fn new<Identity: IMFMediaEngineSrcElementsEx_Impl, const OFFSET: isize>() -> IMFMediaEngineSrcElementsEx_Vtbl {
        unsafe extern "system" fn AddElementEx<Identity: IMFMediaEngineSrcElementsEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, purl: core::mem::MaybeUninit<windows_core::BSTR>, ptype: core::mem::MaybeUninit<windows_core::BSTR>, pmedia: core::mem::MaybeUninit<windows_core::BSTR>, keysystem: core::mem::MaybeUninit<windows_core::BSTR>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineSrcElementsEx_Impl::AddElementEx(this, core::mem::transmute(&purl), core::mem::transmute(&ptype), core::mem::transmute(&pmedia), core::mem::transmute(&keysystem)).into()
        }
        unsafe extern "system" fn GetKeySystem<Identity: IMFMediaEngineSrcElementsEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, index: u32, ptype: *mut core::mem::MaybeUninit<windows_core::BSTR>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineSrcElementsEx_Impl::GetKeySystem(this, core::mem::transmute_copy(&index)) {
                Ok(ok__) => {
                    ptype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IMFMediaEngineSrcElements_Vtbl::new::<Identity, OFFSET>(),
            AddElementEx: AddElementEx::<Identity, OFFSET>,
            GetKeySystem: GetKeySystem::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaEngineSrcElementsEx as windows_core::Interface>::IID || iid == &<IMFMediaEngineSrcElements as windows_core::Interface>::IID
    }
}
pub trait IMFMediaEngineSupportsSourceTransfer_Impl: Sized + windows_core::IUnknownImpl {
    fn ShouldTransferSource(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn DetachMediaSource(&self, ppbytestream: *mut Option<IMFByteStream>, ppmediasource: *mut Option<IMFMediaSource>, ppmse: *mut Option<IMFMediaSourceExtension>) -> windows_core::Result<()>;
    fn AttachMediaSource(&self, pbytestream: Option<&IMFByteStream>, pmediasource: Option<&IMFMediaSource>, pmse: Option<&IMFMediaSourceExtension>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFMediaEngineSupportsSourceTransfer {}
impl IMFMediaEngineSupportsSourceTransfer_Vtbl {
    pub const fn new<Identity: IMFMediaEngineSupportsSourceTransfer_Impl, const OFFSET: isize>() -> IMFMediaEngineSupportsSourceTransfer_Vtbl {
        unsafe extern "system" fn ShouldTransferSource<Identity: IMFMediaEngineSupportsSourceTransfer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfshouldtransfer: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineSupportsSourceTransfer_Impl::ShouldTransferSource(this) {
                Ok(ok__) => {
                    pfshouldtransfer.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DetachMediaSource<Identity: IMFMediaEngineSupportsSourceTransfer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppbytestream: *mut *mut core::ffi::c_void, ppmediasource: *mut *mut core::ffi::c_void, ppmse: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineSupportsSourceTransfer_Impl::DetachMediaSource(this, core::mem::transmute_copy(&ppbytestream), core::mem::transmute_copy(&ppmediasource), core::mem::transmute_copy(&ppmse)).into()
        }
        unsafe extern "system" fn AttachMediaSource<Identity: IMFMediaEngineSupportsSourceTransfer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbytestream: *mut core::ffi::c_void, pmediasource: *mut core::ffi::c_void, pmse: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineSupportsSourceTransfer_Impl::AttachMediaSource(this, windows_core::from_raw_borrowed(&pbytestream), windows_core::from_raw_borrowed(&pmediasource), windows_core::from_raw_borrowed(&pmse)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            ShouldTransferSource: ShouldTransferSource::<Identity, OFFSET>,
            DetachMediaSource: DetachMediaSource::<Identity, OFFSET>,
            AttachMediaSource: AttachMediaSource::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaEngineSupportsSourceTransfer as windows_core::Interface>::IID
    }
}
pub trait IMFMediaEngineTransferSource_Impl: Sized + windows_core::IUnknownImpl {
    fn TransferSourceToMediaEngine(&self, destination: Option<&IMFMediaEngine>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFMediaEngineTransferSource {}
impl IMFMediaEngineTransferSource_Vtbl {
    pub const fn new<Identity: IMFMediaEngineTransferSource_Impl, const OFFSET: isize>() -> IMFMediaEngineTransferSource_Vtbl {
        unsafe extern "system" fn TransferSourceToMediaEngine<Identity: IMFMediaEngineTransferSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, destination: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineTransferSource_Impl::TransferSourceToMediaEngine(this, windows_core::from_raw_borrowed(&destination)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), TransferSourceToMediaEngine: TransferSourceToMediaEngine::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaEngineTransferSource as windows_core::Interface>::IID
    }
}
pub trait IMFMediaEngineWebSupport_Impl: Sized + windows_core::IUnknownImpl {
    fn ShouldDelayTheLoadEvent(&self) -> super::super::Foundation::BOOL;
    fn ConnectWebAudio(&self, dwsamplerate: u32) -> windows_core::Result<IAudioSourceProvider>;
    fn DisconnectWebAudio(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFMediaEngineWebSupport {}
impl IMFMediaEngineWebSupport_Vtbl {
    pub const fn new<Identity: IMFMediaEngineWebSupport_Impl, const OFFSET: isize>() -> IMFMediaEngineWebSupport_Vtbl {
        unsafe extern "system" fn ShouldDelayTheLoadEvent<Identity: IMFMediaEngineWebSupport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineWebSupport_Impl::ShouldDelayTheLoadEvent(this)
        }
        unsafe extern "system" fn ConnectWebAudio<Identity: IMFMediaEngineWebSupport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwsamplerate: u32, ppsourceprovider: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEngineWebSupport_Impl::ConnectWebAudio(this, core::mem::transmute_copy(&dwsamplerate)) {
                Ok(ok__) => {
                    ppsourceprovider.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisconnectWebAudio<Identity: IMFMediaEngineWebSupport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEngineWebSupport_Impl::DisconnectWebAudio(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            ShouldDelayTheLoadEvent: ShouldDelayTheLoadEvent::<Identity, OFFSET>,
            ConnectWebAudio: ConnectWebAudio::<Identity, OFFSET>,
            DisconnectWebAudio: DisconnectWebAudio::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaEngineWebSupport as windows_core::Interface>::IID
    }
}
pub trait IMFMediaError_Impl: Sized + windows_core::IUnknownImpl {
    fn GetErrorCode(&self) -> u16;
    fn GetExtendedErrorCode(&self) -> windows_core::Result<()>;
    fn SetErrorCode(&self, error: MF_MEDIA_ENGINE_ERR) -> windows_core::Result<()>;
    fn SetExtendedErrorCode(&self, error: windows_core::HRESULT) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFMediaError {}
impl IMFMediaError_Vtbl {
    pub const fn new<Identity: IMFMediaError_Impl, const OFFSET: isize>() -> IMFMediaError_Vtbl {
        unsafe extern "system" fn GetErrorCode<Identity: IMFMediaError_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u16 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaError_Impl::GetErrorCode(this)
        }
        unsafe extern "system" fn GetExtendedErrorCode<Identity: IMFMediaError_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaError_Impl::GetExtendedErrorCode(this).into()
        }
        unsafe extern "system" fn SetErrorCode<Identity: IMFMediaError_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, error: MF_MEDIA_ENGINE_ERR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaError_Impl::SetErrorCode(this, core::mem::transmute_copy(&error)).into()
        }
        unsafe extern "system" fn SetExtendedErrorCode<Identity: IMFMediaError_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, error: windows_core::HRESULT) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaError_Impl::SetExtendedErrorCode(this, core::mem::transmute_copy(&error)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetErrorCode: GetErrorCode::<Identity, OFFSET>,
            GetExtendedErrorCode: GetExtendedErrorCode::<Identity, OFFSET>,
            SetErrorCode: SetErrorCode::<Identity, OFFSET>,
            SetExtendedErrorCode: SetExtendedErrorCode::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaError as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFMediaEvent_Impl: Sized + IMFAttributes_Impl {
    fn GetType(&self) -> windows_core::Result<u32>;
    fn GetExtendedType(&self) -> windows_core::Result<windows_core::GUID>;
    fn GetStatus(&self) -> windows_core::Result<windows_core::HRESULT>;
    fn GetValue(&self) -> windows_core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFMediaEvent {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFMediaEvent_Vtbl {
    pub const fn new<Identity: IMFMediaEvent_Impl, const OFFSET: isize>() -> IMFMediaEvent_Vtbl {
        unsafe extern "system" fn GetType<Identity: IMFMediaEvent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmet: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEvent_Impl::GetType(this) {
                Ok(ok__) => {
                    pmet.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetExtendedType<Identity: IMFMediaEvent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguidextendedtype: *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEvent_Impl::GetExtendedType(this) {
                Ok(ok__) => {
                    pguidextendedtype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStatus<Identity: IMFMediaEvent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, phrstatus: *mut windows_core::HRESULT) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEvent_Impl::GetStatus(this) {
                Ok(ok__) => {
                    phrstatus.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetValue<Identity: IMFMediaEvent_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvvalue: *mut core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEvent_Impl::GetValue(this) {
                Ok(ok__) => {
                    pvvalue.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IMFAttributes_Vtbl::new::<Identity, OFFSET>(),
            GetType: GetType::<Identity, OFFSET>,
            GetExtendedType: GetExtendedType::<Identity, OFFSET>,
            GetStatus: GetStatus::<Identity, OFFSET>,
            GetValue: GetValue::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaEvent as windows_core::Interface>::IID || iid == &<IMFAttributes as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFMediaEventGenerator_Impl: Sized + windows_core::IUnknownImpl {
    fn GetEvent(&self, dwflags: MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS) -> windows_core::Result<IMFMediaEvent>;
    fn BeginGetEvent(&self, pcallback: Option<&IMFAsyncCallback>, punkstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndGetEvent(&self, presult: Option<&IMFAsyncResult>) -> windows_core::Result<IMFMediaEvent>;
    fn QueueEvent(&self, met: u32, guidextendedtype: *const windows_core::GUID, hrstatus: windows_core::HRESULT, pvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFMediaEventGenerator {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFMediaEventGenerator_Vtbl {
    pub const fn new<Identity: IMFMediaEventGenerator_Impl, const OFFSET: isize>() -> IMFMediaEventGenerator_Vtbl {
        unsafe extern "system" fn GetEvent<Identity: IMFMediaEventGenerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS, ppevent: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEventGenerator_Impl::GetEvent(this, core::mem::transmute_copy(&dwflags)) {
                Ok(ok__) => {
                    ppevent.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginGetEvent<Identity: IMFMediaEventGenerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcallback: *mut core::ffi::c_void, punkstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEventGenerator_Impl::BeginGetEvent(this, windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&punkstate)).into()
        }
        unsafe extern "system" fn EndGetEvent<Identity: IMFMediaEventGenerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void, ppevent: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEventGenerator_Impl::EndGetEvent(this, windows_core::from_raw_borrowed(&presult)) {
                Ok(ok__) => {
                    ppevent.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueueEvent<Identity: IMFMediaEventGenerator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, met: u32, guidextendedtype: *const windows_core::GUID, hrstatus: windows_core::HRESULT, pvvalue: *const core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEventGenerator_Impl::QueueEvent(this, core::mem::transmute_copy(&met), core::mem::transmute_copy(&guidextendedtype), core::mem::transmute_copy(&hrstatus), core::mem::transmute_copy(&pvvalue)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetEvent: GetEvent::<Identity, OFFSET>,
            BeginGetEvent: BeginGetEvent::<Identity, OFFSET>,
            EndGetEvent: EndGetEvent::<Identity, OFFSET>,
            QueueEvent: QueueEvent::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaEventGenerator as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFMediaEventQueue_Impl: Sized + windows_core::IUnknownImpl {
    fn GetEvent(&self, dwflags: u32) -> windows_core::Result<IMFMediaEvent>;
    fn BeginGetEvent(&self, pcallback: Option<&IMFAsyncCallback>, punkstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndGetEvent(&self, presult: Option<&IMFAsyncResult>) -> windows_core::Result<IMFMediaEvent>;
    fn QueueEvent(&self, pevent: Option<&IMFMediaEvent>) -> windows_core::Result<()>;
    fn QueueEventParamVar(&self, met: u32, guidextendedtype: *const windows_core::GUID, hrstatus: windows_core::HRESULT, pvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> windows_core::Result<()>;
    fn QueueEventParamUnk(&self, met: u32, guidextendedtype: *const windows_core::GUID, hrstatus: windows_core::HRESULT, punk: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn Shutdown(&self) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFMediaEventQueue {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFMediaEventQueue_Vtbl {
    pub const fn new<Identity: IMFMediaEventQueue_Impl, const OFFSET: isize>() -> IMFMediaEventQueue_Vtbl {
        unsafe extern "system" fn GetEvent<Identity: IMFMediaEventQueue_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32, ppevent: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEventQueue_Impl::GetEvent(this, core::mem::transmute_copy(&dwflags)) {
                Ok(ok__) => {
                    ppevent.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginGetEvent<Identity: IMFMediaEventQueue_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcallback: *mut core::ffi::c_void, punkstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEventQueue_Impl::BeginGetEvent(this, windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&punkstate)).into()
        }
        unsafe extern "system" fn EndGetEvent<Identity: IMFMediaEventQueue_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void, ppevent: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaEventQueue_Impl::EndGetEvent(this, windows_core::from_raw_borrowed(&presult)) {
                Ok(ok__) => {
                    ppevent.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueueEvent<Identity: IMFMediaEventQueue_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pevent: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEventQueue_Impl::QueueEvent(this, windows_core::from_raw_borrowed(&pevent)).into()
        }
        unsafe extern "system" fn QueueEventParamVar<Identity: IMFMediaEventQueue_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, met: u32, guidextendedtype: *const windows_core::GUID, hrstatus: windows_core::HRESULT, pvvalue: *const core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEventQueue_Impl::QueueEventParamVar(this, core::mem::transmute_copy(&met), core::mem::transmute_copy(&guidextendedtype), core::mem::transmute_copy(&hrstatus), core::mem::transmute_copy(&pvvalue)).into()
        }
        unsafe extern "system" fn QueueEventParamUnk<Identity: IMFMediaEventQueue_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, met: u32, guidextendedtype: *const windows_core::GUID, hrstatus: windows_core::HRESULT, punk: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEventQueue_Impl::QueueEventParamUnk(this, core::mem::transmute_copy(&met), core::mem::transmute_copy(&guidextendedtype), core::mem::transmute_copy(&hrstatus), windows_core::from_raw_borrowed(&punk)).into()
        }
        unsafe extern "system" fn Shutdown<Identity: IMFMediaEventQueue_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaEventQueue_Impl::Shutdown(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetEvent: GetEvent::<Identity, OFFSET>,
            BeginGetEvent: BeginGetEvent::<Identity, OFFSET>,
            EndGetEvent: EndGetEvent::<Identity, OFFSET>,
            QueueEvent: QueueEvent::<Identity, OFFSET>,
            QueueEventParamVar: QueueEventParamVar::<Identity, OFFSET>,
            QueueEventParamUnk: QueueEventParamUnk::<Identity, OFFSET>,
            Shutdown: Shutdown::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaEventQueue as windows_core::Interface>::IID
    }
}
pub trait IMFMediaKeySession_Impl: Sized + windows_core::IUnknownImpl {
    fn GetError(&self, code: *mut u16, systemcode: *mut u32) -> windows_core::Result<()>;
    fn KeySystem(&self) -> windows_core::Result<windows_core::BSTR>;
    fn SessionId(&self) -> windows_core::Result<windows_core::BSTR>;
    fn Update(&self, key: *const u8, cb: u32) -> windows_core::Result<()>;
    fn Close(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFMediaKeySession {}
impl IMFMediaKeySession_Vtbl {
    pub const fn new<Identity: IMFMediaKeySession_Impl, const OFFSET: isize>() -> IMFMediaKeySession_Vtbl {
        unsafe extern "system" fn GetError<Identity: IMFMediaKeySession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, code: *mut u16, systemcode: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaKeySession_Impl::GetError(this, core::mem::transmute_copy(&code), core::mem::transmute_copy(&systemcode)).into()
        }
        unsafe extern "system" fn KeySystem<Identity: IMFMediaKeySession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, keysystem: *mut core::mem::MaybeUninit<windows_core::BSTR>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaKeySession_Impl::KeySystem(this) {
                Ok(ok__) => {
                    keysystem.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SessionId<Identity: IMFMediaKeySession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, sessionid: *mut core::mem::MaybeUninit<windows_core::BSTR>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaKeySession_Impl::SessionId(this) {
                Ok(ok__) => {
                    sessionid.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Update<Identity: IMFMediaKeySession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, key: *const u8, cb: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaKeySession_Impl::Update(this, core::mem::transmute_copy(&key), core::mem::transmute_copy(&cb)).into()
        }
        unsafe extern "system" fn Close<Identity: IMFMediaKeySession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaKeySession_Impl::Close(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetError: GetError::<Identity, OFFSET>,
            KeySystem: KeySystem::<Identity, OFFSET>,
            SessionId: SessionId::<Identity, OFFSET>,
            Update: Update::<Identity, OFFSET>,
            Close: Close::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaKeySession as windows_core::Interface>::IID
    }
}
pub trait IMFMediaKeySession2_Impl: Sized + IMFMediaKeySession_Impl {
    fn get_KeyStatuses(&self, pkeystatusesarray: *mut *mut MFMediaKeyStatus, pusize: *mut u32) -> windows_core::Result<()>;
    fn Load(&self, bstrsessionid: &windows_core::BSTR) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn GenerateRequest(&self, initdatatype: &windows_core::BSTR, pbinitdata: *const u8, cb: u32) -> windows_core::Result<()>;
    fn Expiration(&self) -> windows_core::Result<f64>;
    fn Remove(&self) -> windows_core::Result<()>;
    fn Shutdown(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFMediaKeySession2 {}
impl IMFMediaKeySession2_Vtbl {
    pub const fn new<Identity: IMFMediaKeySession2_Impl, const OFFSET: isize>() -> IMFMediaKeySession2_Vtbl {
        unsafe extern "system" fn get_KeyStatuses<Identity: IMFMediaKeySession2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pkeystatusesarray: *mut *mut MFMediaKeyStatus, pusize: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaKeySession2_Impl::get_KeyStatuses(this, core::mem::transmute_copy(&pkeystatusesarray), core::mem::transmute_copy(&pusize)).into()
        }
        unsafe extern "system" fn Load<Identity: IMFMediaKeySession2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bstrsessionid: core::mem::MaybeUninit<windows_core::BSTR>, pfloaded: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaKeySession2_Impl::Load(this, core::mem::transmute(&bstrsessionid)) {
                Ok(ok__) => {
                    pfloaded.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GenerateRequest<Identity: IMFMediaKeySession2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, initdatatype: core::mem::MaybeUninit<windows_core::BSTR>, pbinitdata: *const u8, cb: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaKeySession2_Impl::GenerateRequest(this, core::mem::transmute(&initdatatype), core::mem::transmute_copy(&pbinitdata), core::mem::transmute_copy(&cb)).into()
        }
        unsafe extern "system" fn Expiration<Identity: IMFMediaKeySession2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dblexpiration: *mut f64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaKeySession2_Impl::Expiration(this) {
                Ok(ok__) => {
                    dblexpiration.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Remove<Identity: IMFMediaKeySession2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaKeySession2_Impl::Remove(this).into()
        }
        unsafe extern "system" fn Shutdown<Identity: IMFMediaKeySession2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaKeySession2_Impl::Shutdown(this).into()
        }
        Self {
            base__: IMFMediaKeySession_Vtbl::new::<Identity, OFFSET>(),
            get_KeyStatuses: get_KeyStatuses::<Identity, OFFSET>,
            Load: Load::<Identity, OFFSET>,
            GenerateRequest: GenerateRequest::<Identity, OFFSET>,
            Expiration: Expiration::<Identity, OFFSET>,
            Remove: Remove::<Identity, OFFSET>,
            Shutdown: Shutdown::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaKeySession2 as windows_core::Interface>::IID || iid == &<IMFMediaKeySession as windows_core::Interface>::IID
    }
}
pub trait IMFMediaKeySessionNotify_Impl: Sized + windows_core::IUnknownImpl {
    fn KeyMessage(&self, destinationurl: &windows_core::BSTR, message: *const u8, cb: u32);
    fn KeyAdded(&self);
    fn KeyError(&self, code: u16, systemcode: u32);
}
impl windows_core::RuntimeName for IMFMediaKeySessionNotify {}
impl IMFMediaKeySessionNotify_Vtbl {
    pub const fn new<Identity: IMFMediaKeySessionNotify_Impl, const OFFSET: isize>() -> IMFMediaKeySessionNotify_Vtbl {
        unsafe extern "system" fn KeyMessage<Identity: IMFMediaKeySessionNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, destinationurl: core::mem::MaybeUninit<windows_core::BSTR>, message: *const u8, cb: u32) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaKeySessionNotify_Impl::KeyMessage(this, core::mem::transmute(&destinationurl), core::mem::transmute_copy(&message), core::mem::transmute_copy(&cb))
        }
        unsafe extern "system" fn KeyAdded<Identity: IMFMediaKeySessionNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaKeySessionNotify_Impl::KeyAdded(this)
        }
        unsafe extern "system" fn KeyError<Identity: IMFMediaKeySessionNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, code: u16, systemcode: u32) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaKeySessionNotify_Impl::KeyError(this, core::mem::transmute_copy(&code), core::mem::transmute_copy(&systemcode))
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            KeyMessage: KeyMessage::<Identity, OFFSET>,
            KeyAdded: KeyAdded::<Identity, OFFSET>,
            KeyError: KeyError::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaKeySessionNotify as windows_core::Interface>::IID
    }
}
pub trait IMFMediaKeySessionNotify2_Impl: Sized + IMFMediaKeySessionNotify_Impl {
    fn KeyMessage2(&self, emessagetype: MF_MEDIAKEYSESSION_MESSAGETYPE, destinationurl: &windows_core::BSTR, pbmessage: *const u8, cbmessage: u32);
    fn KeyStatusChange(&self);
}
impl windows_core::RuntimeName for IMFMediaKeySessionNotify2 {}
impl IMFMediaKeySessionNotify2_Vtbl {
    pub const fn new<Identity: IMFMediaKeySessionNotify2_Impl, const OFFSET: isize>() -> IMFMediaKeySessionNotify2_Vtbl {
        unsafe extern "system" fn KeyMessage2<Identity: IMFMediaKeySessionNotify2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, emessagetype: MF_MEDIAKEYSESSION_MESSAGETYPE, destinationurl: core::mem::MaybeUninit<windows_core::BSTR>, pbmessage: *const u8, cbmessage: u32) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaKeySessionNotify2_Impl::KeyMessage2(this, core::mem::transmute_copy(&emessagetype), core::mem::transmute(&destinationurl), core::mem::transmute_copy(&pbmessage), core::mem::transmute_copy(&cbmessage))
        }
        unsafe extern "system" fn KeyStatusChange<Identity: IMFMediaKeySessionNotify2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaKeySessionNotify2_Impl::KeyStatusChange(this)
        }
        Self {
            base__: IMFMediaKeySessionNotify_Vtbl::new::<Identity, OFFSET>(),
            KeyMessage2: KeyMessage2::<Identity, OFFSET>,
            KeyStatusChange: KeyStatusChange::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaKeySessionNotify2 as windows_core::Interface>::IID || iid == &<IMFMediaKeySessionNotify as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub trait IMFMediaKeySystemAccess_Impl: Sized + windows_core::IUnknownImpl {
    fn CreateMediaKeys(&self, pcdmcustomconfig: Option<&super::super::UI::Shell::PropertiesSystem::IPropertyStore>) -> windows_core::Result<IMFMediaKeys2>;
    fn SupportedConfiguration(&self) -> windows_core::Result<super::super::UI::Shell::PropertiesSystem::IPropertyStore>;
    fn KeySystem(&self) -> windows_core::Result<windows_core::BSTR>;
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl windows_core::RuntimeName for IMFMediaKeySystemAccess {}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl IMFMediaKeySystemAccess_Vtbl {
    pub const fn new<Identity: IMFMediaKeySystemAccess_Impl, const OFFSET: isize>() -> IMFMediaKeySystemAccess_Vtbl {
        unsafe extern "system" fn CreateMediaKeys<Identity: IMFMediaKeySystemAccess_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcdmcustomconfig: *mut core::ffi::c_void, ppkeys: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaKeySystemAccess_Impl::CreateMediaKeys(this, windows_core::from_raw_borrowed(&pcdmcustomconfig)) {
                Ok(ok__) => {
                    ppkeys.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SupportedConfiguration<Identity: IMFMediaKeySystemAccess_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppsupportedconfiguration: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaKeySystemAccess_Impl::SupportedConfiguration(this) {
                Ok(ok__) => {
                    ppsupportedconfiguration.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KeySystem<Identity: IMFMediaKeySystemAccess_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pkeysystem: *mut core::mem::MaybeUninit<windows_core::BSTR>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaKeySystemAccess_Impl::KeySystem(this) {
                Ok(ok__) => {
                    pkeysystem.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            CreateMediaKeys: CreateMediaKeys::<Identity, OFFSET>,
            SupportedConfiguration: SupportedConfiguration::<Identity, OFFSET>,
            KeySystem: KeySystem::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaKeySystemAccess as windows_core::Interface>::IID
    }
}
pub trait IMFMediaKeys_Impl: Sized + windows_core::IUnknownImpl {
    fn CreateSession(&self, mimetype: &windows_core::BSTR, initdata: *const u8, cb: u32, customdata: *const u8, cbcustomdata: u32, notify: Option<&IMFMediaKeySessionNotify>) -> windows_core::Result<IMFMediaKeySession>;
    fn KeySystem(&self) -> windows_core::Result<windows_core::BSTR>;
    fn Shutdown(&self) -> windows_core::Result<()>;
    fn GetSuspendNotify(&self) -> windows_core::Result<IMFCdmSuspendNotify>;
}
impl windows_core::RuntimeName for IMFMediaKeys {}
impl IMFMediaKeys_Vtbl {
    pub const fn new<Identity: IMFMediaKeys_Impl, const OFFSET: isize>() -> IMFMediaKeys_Vtbl {
        unsafe extern "system" fn CreateSession<Identity: IMFMediaKeys_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, mimetype: core::mem::MaybeUninit<windows_core::BSTR>, initdata: *const u8, cb: u32, customdata: *const u8, cbcustomdata: u32, notify: *mut core::ffi::c_void, ppsession: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaKeys_Impl::CreateSession(this, core::mem::transmute(&mimetype), core::mem::transmute_copy(&initdata), core::mem::transmute_copy(&cb), core::mem::transmute_copy(&customdata), core::mem::transmute_copy(&cbcustomdata), windows_core::from_raw_borrowed(&notify)) {
                Ok(ok__) => {
                    ppsession.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KeySystem<Identity: IMFMediaKeys_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, keysystem: *mut core::mem::MaybeUninit<windows_core::BSTR>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaKeys_Impl::KeySystem(this) {
                Ok(ok__) => {
                    keysystem.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Shutdown<Identity: IMFMediaKeys_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaKeys_Impl::Shutdown(this).into()
        }
        unsafe extern "system" fn GetSuspendNotify<Identity: IMFMediaKeys_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, notify: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaKeys_Impl::GetSuspendNotify(this) {
                Ok(ok__) => {
                    notify.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            CreateSession: CreateSession::<Identity, OFFSET>,
            KeySystem: KeySystem::<Identity, OFFSET>,
            Shutdown: Shutdown::<Identity, OFFSET>,
            GetSuspendNotify: GetSuspendNotify::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaKeys as windows_core::Interface>::IID
    }
}
pub trait IMFMediaKeys2_Impl: Sized + IMFMediaKeys_Impl {
    fn CreateSession2(&self, esessiontype: MF_MEDIAKEYSESSION_TYPE, pmfmediakeysessionnotify2: Option<&IMFMediaKeySessionNotify2>) -> windows_core::Result<IMFMediaKeySession2>;
    fn SetServerCertificate(&self, pbservercertificate: *const u8, cb: u32) -> windows_core::Result<()>;
    fn GetDOMException(&self, systemcode: windows_core::HRESULT) -> windows_core::Result<windows_core::HRESULT>;
}
impl windows_core::RuntimeName for IMFMediaKeys2 {}
impl IMFMediaKeys2_Vtbl {
    pub const fn new<Identity: IMFMediaKeys2_Impl, const OFFSET: isize>() -> IMFMediaKeys2_Vtbl {
        unsafe extern "system" fn CreateSession2<Identity: IMFMediaKeys2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, esessiontype: MF_MEDIAKEYSESSION_TYPE, pmfmediakeysessionnotify2: *mut core::ffi::c_void, ppsession: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaKeys2_Impl::CreateSession2(this, core::mem::transmute_copy(&esessiontype), windows_core::from_raw_borrowed(&pmfmediakeysessionnotify2)) {
                Ok(ok__) => {
                    ppsession.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetServerCertificate<Identity: IMFMediaKeys2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbservercertificate: *const u8, cb: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaKeys2_Impl::SetServerCertificate(this, core::mem::transmute_copy(&pbservercertificate), core::mem::transmute_copy(&cb)).into()
        }
        unsafe extern "system" fn GetDOMException<Identity: IMFMediaKeys2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, systemcode: windows_core::HRESULT, code: *mut windows_core::HRESULT) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaKeys2_Impl::GetDOMException(this, core::mem::transmute_copy(&systemcode)) {
                Ok(ok__) => {
                    code.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IMFMediaKeys_Vtbl::new::<Identity, OFFSET>(),
            CreateSession2: CreateSession2::<Identity, OFFSET>,
            SetServerCertificate: SetServerCertificate::<Identity, OFFSET>,
            GetDOMException: GetDOMException::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaKeys2 as windows_core::Interface>::IID || iid == &<IMFMediaKeys as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFMediaSession_Impl: Sized + IMFMediaEventGenerator_Impl {
    fn SetTopology(&self, dwsettopologyflags: u32, ptopology: Option<&IMFTopology>) -> windows_core::Result<()>;
    fn ClearTopologies(&self) -> windows_core::Result<()>;
    fn Start(&self, pguidtimeformat: *const windows_core::GUID, pvarstartposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> windows_core::Result<()>;
    fn Pause(&self) -> windows_core::Result<()>;
    fn Stop(&self) -> windows_core::Result<()>;
    fn Close(&self) -> windows_core::Result<()>;
    fn Shutdown(&self) -> windows_core::Result<()>;
    fn GetClock(&self) -> windows_core::Result<IMFClock>;
    fn GetSessionCapabilities(&self) -> windows_core::Result<u32>;
    fn GetFullTopology(&self, dwgetfulltopologyflags: u32, topoid: u64) -> windows_core::Result<IMFTopology>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFMediaSession {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFMediaSession_Vtbl {
    pub const fn new<Identity: IMFMediaSession_Impl, const OFFSET: isize>() -> IMFMediaSession_Vtbl {
        unsafe extern "system" fn SetTopology<Identity: IMFMediaSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwsettopologyflags: u32, ptopology: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSession_Impl::SetTopology(this, core::mem::transmute_copy(&dwsettopologyflags), windows_core::from_raw_borrowed(&ptopology)).into()
        }
        unsafe extern "system" fn ClearTopologies<Identity: IMFMediaSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSession_Impl::ClearTopologies(this).into()
        }
        unsafe extern "system" fn Start<Identity: IMFMediaSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguidtimeformat: *const windows_core::GUID, pvarstartposition: *const core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSession_Impl::Start(this, core::mem::transmute_copy(&pguidtimeformat), core::mem::transmute_copy(&pvarstartposition)).into()
        }
        unsafe extern "system" fn Pause<Identity: IMFMediaSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSession_Impl::Pause(this).into()
        }
        unsafe extern "system" fn Stop<Identity: IMFMediaSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSession_Impl::Stop(this).into()
        }
        unsafe extern "system" fn Close<Identity: IMFMediaSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSession_Impl::Close(this).into()
        }
        unsafe extern "system" fn Shutdown<Identity: IMFMediaSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSession_Impl::Shutdown(this).into()
        }
        unsafe extern "system" fn GetClock<Identity: IMFMediaSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppclock: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaSession_Impl::GetClock(this) {
                Ok(ok__) => {
                    ppclock.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSessionCapabilities<Identity: IMFMediaSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwcaps: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaSession_Impl::GetSessionCapabilities(this) {
                Ok(ok__) => {
                    pdwcaps.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFullTopology<Identity: IMFMediaSession_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwgetfulltopologyflags: u32, topoid: u64, ppfulltopology: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaSession_Impl::GetFullTopology(this, core::mem::transmute_copy(&dwgetfulltopologyflags), core::mem::transmute_copy(&topoid)) {
                Ok(ok__) => {
                    ppfulltopology.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IMFMediaEventGenerator_Vtbl::new::<Identity, OFFSET>(),
            SetTopology: SetTopology::<Identity, OFFSET>,
            ClearTopologies: ClearTopologies::<Identity, OFFSET>,
            Start: Start::<Identity, OFFSET>,
            Pause: Pause::<Identity, OFFSET>,
            Stop: Stop::<Identity, OFFSET>,
            Close: Close::<Identity, OFFSET>,
            Shutdown: Shutdown::<Identity, OFFSET>,
            GetClock: GetClock::<Identity, OFFSET>,
            GetSessionCapabilities: GetSessionCapabilities::<Identity, OFFSET>,
            GetFullTopology: GetFullTopology::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaSession as windows_core::Interface>::IID || iid == &<IMFMediaEventGenerator as windows_core::Interface>::IID
    }
}
pub trait IMFMediaSharingEngine_Impl: Sized + IMFMediaEngine_Impl {
    fn GetDevice(&self, pdevice: *mut DEVICE_INFO) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFMediaSharingEngine {}
impl IMFMediaSharingEngine_Vtbl {
    pub const fn new<Identity: IMFMediaSharingEngine_Impl, const OFFSET: isize>() -> IMFMediaSharingEngine_Vtbl {
        unsafe extern "system" fn GetDevice<Identity: IMFMediaSharingEngine_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdevice: *mut DEVICE_INFO) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSharingEngine_Impl::GetDevice(this, core::mem::transmute_copy(&pdevice)).into()
        }
        Self { base__: IMFMediaEngine_Vtbl::new::<Identity, OFFSET>(), GetDevice: GetDevice::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaSharingEngine as windows_core::Interface>::IID || iid == &<IMFMediaEngine as windows_core::Interface>::IID
    }
}
pub trait IMFMediaSharingEngineClassFactory_Impl: Sized + windows_core::IUnknownImpl {
    fn CreateInstance(&self, dwflags: u32, pattr: Option<&IMFAttributes>) -> windows_core::Result<IMFMediaSharingEngine>;
}
impl windows_core::RuntimeName for IMFMediaSharingEngineClassFactory {}
impl IMFMediaSharingEngineClassFactory_Vtbl {
    pub const fn new<Identity: IMFMediaSharingEngineClassFactory_Impl, const OFFSET: isize>() -> IMFMediaSharingEngineClassFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Identity: IMFMediaSharingEngineClassFactory_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32, pattr: *mut core::ffi::c_void, ppengine: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaSharingEngineClassFactory_Impl::CreateInstance(this, core::mem::transmute_copy(&dwflags), windows_core::from_raw_borrowed(&pattr)) {
                Ok(ok__) => {
                    ppengine.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), CreateInstance: CreateInstance::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaSharingEngineClassFactory as windows_core::Interface>::IID
    }
}
pub trait IMFMediaSink_Impl: Sized + windows_core::IUnknownImpl {
    fn GetCharacteristics(&self) -> windows_core::Result<u32>;
    fn AddStreamSink(&self, dwstreamsinkidentifier: u32, pmediatype: Option<&IMFMediaType>) -> windows_core::Result<IMFStreamSink>;
    fn RemoveStreamSink(&self, dwstreamsinkidentifier: u32) -> windows_core::Result<()>;
    fn GetStreamSinkCount(&self) -> windows_core::Result<u32>;
    fn GetStreamSinkByIndex(&self, dwindex: u32) -> windows_core::Result<IMFStreamSink>;
    fn GetStreamSinkById(&self, dwstreamsinkidentifier: u32) -> windows_core::Result<IMFStreamSink>;
    fn SetPresentationClock(&self, ppresentationclock: Option<&IMFPresentationClock>) -> windows_core::Result<()>;
    fn GetPresentationClock(&self) -> windows_core::Result<IMFPresentationClock>;
    fn Shutdown(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFMediaSink {}
impl IMFMediaSink_Vtbl {
    pub const fn new<Identity: IMFMediaSink_Impl, const OFFSET: isize>() -> IMFMediaSink_Vtbl {
        unsafe extern "system" fn GetCharacteristics<Identity: IMFMediaSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwcharacteristics: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaSink_Impl::GetCharacteristics(this) {
                Ok(ok__) => {
                    pdwcharacteristics.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddStreamSink<Identity: IMFMediaSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamsinkidentifier: u32, pmediatype: *mut core::ffi::c_void, ppstreamsink: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaSink_Impl::AddStreamSink(this, core::mem::transmute_copy(&dwstreamsinkidentifier), windows_core::from_raw_borrowed(&pmediatype)) {
                Ok(ok__) => {
                    ppstreamsink.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveStreamSink<Identity: IMFMediaSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamsinkidentifier: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSink_Impl::RemoveStreamSink(this, core::mem::transmute_copy(&dwstreamsinkidentifier)).into()
        }
        unsafe extern "system" fn GetStreamSinkCount<Identity: IMFMediaSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcstreamsinkcount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaSink_Impl::GetStreamSinkCount(this) {
                Ok(ok__) => {
                    pcstreamsinkcount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamSinkByIndex<Identity: IMFMediaSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwindex: u32, ppstreamsink: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaSink_Impl::GetStreamSinkByIndex(this, core::mem::transmute_copy(&dwindex)) {
                Ok(ok__) => {
                    ppstreamsink.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamSinkById<Identity: IMFMediaSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamsinkidentifier: u32, ppstreamsink: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaSink_Impl::GetStreamSinkById(this, core::mem::transmute_copy(&dwstreamsinkidentifier)) {
                Ok(ok__) => {
                    ppstreamsink.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPresentationClock<Identity: IMFMediaSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppresentationclock: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSink_Impl::SetPresentationClock(this, windows_core::from_raw_borrowed(&ppresentationclock)).into()
        }
        unsafe extern "system" fn GetPresentationClock<Identity: IMFMediaSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pppresentationclock: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaSink_Impl::GetPresentationClock(this) {
                Ok(ok__) => {
                    pppresentationclock.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Shutdown<Identity: IMFMediaSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSink_Impl::Shutdown(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetCharacteristics: GetCharacteristics::<Identity, OFFSET>,
            AddStreamSink: AddStreamSink::<Identity, OFFSET>,
            RemoveStreamSink: RemoveStreamSink::<Identity, OFFSET>,
            GetStreamSinkCount: GetStreamSinkCount::<Identity, OFFSET>,
            GetStreamSinkByIndex: GetStreamSinkByIndex::<Identity, OFFSET>,
            GetStreamSinkById: GetStreamSinkById::<Identity, OFFSET>,
            SetPresentationClock: SetPresentationClock::<Identity, OFFSET>,
            GetPresentationClock: GetPresentationClock::<Identity, OFFSET>,
            Shutdown: Shutdown::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaSink as windows_core::Interface>::IID
    }
}
pub trait IMFMediaSinkPreroll_Impl: Sized + windows_core::IUnknownImpl {
    fn NotifyPreroll(&self, hnsupcomingstarttime: i64) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFMediaSinkPreroll {}
impl IMFMediaSinkPreroll_Vtbl {
    pub const fn new<Identity: IMFMediaSinkPreroll_Impl, const OFFSET: isize>() -> IMFMediaSinkPreroll_Vtbl {
        unsafe extern "system" fn NotifyPreroll<Identity: IMFMediaSinkPreroll_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hnsupcomingstarttime: i64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSinkPreroll_Impl::NotifyPreroll(this, core::mem::transmute_copy(&hnsupcomingstarttime)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), NotifyPreroll: NotifyPreroll::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaSinkPreroll as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFMediaSource_Impl: Sized + IMFMediaEventGenerator_Impl {
    fn GetCharacteristics(&self) -> windows_core::Result<u32>;
    fn CreatePresentationDescriptor(&self) -> windows_core::Result<IMFPresentationDescriptor>;
    fn Start(&self, ppresentationdescriptor: Option<&IMFPresentationDescriptor>, pguidtimeformat: *const windows_core::GUID, pvarstartposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> windows_core::Result<()>;
    fn Stop(&self) -> windows_core::Result<()>;
    fn Pause(&self) -> windows_core::Result<()>;
    fn Shutdown(&self) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFMediaSource {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFMediaSource_Vtbl {
    pub const fn new<Identity: IMFMediaSource_Impl, const OFFSET: isize>() -> IMFMediaSource_Vtbl {
        unsafe extern "system" fn GetCharacteristics<Identity: IMFMediaSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwcharacteristics: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaSource_Impl::GetCharacteristics(this) {
                Ok(ok__) => {
                    pdwcharacteristics.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreatePresentationDescriptor<Identity: IMFMediaSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pppresentationdescriptor: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaSource_Impl::CreatePresentationDescriptor(this) {
                Ok(ok__) => {
                    pppresentationdescriptor.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Start<Identity: IMFMediaSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppresentationdescriptor: *mut core::ffi::c_void, pguidtimeformat: *const windows_core::GUID, pvarstartposition: *const core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSource_Impl::Start(this, windows_core::from_raw_borrowed(&ppresentationdescriptor), core::mem::transmute_copy(&pguidtimeformat), core::mem::transmute_copy(&pvarstartposition)).into()
        }
        unsafe extern "system" fn Stop<Identity: IMFMediaSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSource_Impl::Stop(this).into()
        }
        unsafe extern "system" fn Pause<Identity: IMFMediaSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSource_Impl::Pause(this).into()
        }
        unsafe extern "system" fn Shutdown<Identity: IMFMediaSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSource_Impl::Shutdown(this).into()
        }
        Self {
            base__: IMFMediaEventGenerator_Vtbl::new::<Identity, OFFSET>(),
            GetCharacteristics: GetCharacteristics::<Identity, OFFSET>,
            CreatePresentationDescriptor: CreatePresentationDescriptor::<Identity, OFFSET>,
            Start: Start::<Identity, OFFSET>,
            Stop: Stop::<Identity, OFFSET>,
            Pause: Pause::<Identity, OFFSET>,
            Shutdown: Shutdown::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaSource as windows_core::Interface>::IID || iid == &<IMFMediaEventGenerator as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFMediaSource2_Impl: Sized + IMFMediaSourceEx_Impl {
    fn SetMediaType(&self, dwstreamid: u32, pmediatype: Option<&IMFMediaType>) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFMediaSource2 {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFMediaSource2_Vtbl {
    pub const fn new<Identity: IMFMediaSource2_Impl, const OFFSET: isize>() -> IMFMediaSource2_Vtbl {
        unsafe extern "system" fn SetMediaType<Identity: IMFMediaSource2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, pmediatype: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSource2_Impl::SetMediaType(this, core::mem::transmute_copy(&dwstreamid), windows_core::from_raw_borrowed(&pmediatype)).into()
        }
        Self { base__: IMFMediaSourceEx_Vtbl::new::<Identity, OFFSET>(), SetMediaType: SetMediaType::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaSource2 as windows_core::Interface>::IID || iid == &<IMFMediaEventGenerator as windows_core::Interface>::IID || iid == &<IMFMediaSource as windows_core::Interface>::IID || iid == &<IMFMediaSourceEx as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFMediaSourceEx_Impl: Sized + IMFMediaSource_Impl {
    fn GetSourceAttributes(&self) -> windows_core::Result<IMFAttributes>;
    fn GetStreamAttributes(&self, dwstreamidentifier: u32) -> windows_core::Result<IMFAttributes>;
    fn SetD3DManager(&self, pmanager: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFMediaSourceEx {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFMediaSourceEx_Vtbl {
    pub const fn new<Identity: IMFMediaSourceEx_Impl, const OFFSET: isize>() -> IMFMediaSourceEx_Vtbl {
        unsafe extern "system" fn GetSourceAttributes<Identity: IMFMediaSourceEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppattributes: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaSourceEx_Impl::GetSourceAttributes(this) {
                Ok(ok__) => {
                    ppattributes.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamAttributes<Identity: IMFMediaSourceEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamidentifier: u32, ppattributes: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaSourceEx_Impl::GetStreamAttributes(this, core::mem::transmute_copy(&dwstreamidentifier)) {
                Ok(ok__) => {
                    ppattributes.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetD3DManager<Identity: IMFMediaSourceEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmanager: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSourceEx_Impl::SetD3DManager(this, windows_core::from_raw_borrowed(&pmanager)).into()
        }
        Self {
            base__: IMFMediaSource_Vtbl::new::<Identity, OFFSET>(),
            GetSourceAttributes: GetSourceAttributes::<Identity, OFFSET>,
            GetStreamAttributes: GetStreamAttributes::<Identity, OFFSET>,
            SetD3DManager: SetD3DManager::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaSourceEx as windows_core::Interface>::IID || iid == &<IMFMediaEventGenerator as windows_core::Interface>::IID || iid == &<IMFMediaSource as windows_core::Interface>::IID
    }
}
pub trait IMFMediaSourceExtension_Impl: Sized + windows_core::IUnknownImpl {
    fn GetSourceBuffers(&self) -> Option<IMFSourceBufferList>;
    fn GetActiveSourceBuffers(&self) -> Option<IMFSourceBufferList>;
    fn GetReadyState(&self) -> MF_MSE_READY;
    fn GetDuration(&self) -> f64;
    fn SetDuration(&self, duration: f64) -> windows_core::Result<()>;
    fn AddSourceBuffer(&self, r#type: &windows_core::BSTR, pnotify: Option<&IMFSourceBufferNotify>) -> windows_core::Result<IMFSourceBuffer>;
    fn RemoveSourceBuffer(&self, psourcebuffer: Option<&IMFSourceBuffer>) -> windows_core::Result<()>;
    fn SetEndOfStream(&self, error: MF_MSE_ERROR) -> windows_core::Result<()>;
    fn IsTypeSupported(&self, r#type: &windows_core::BSTR) -> super::super::Foundation::BOOL;
    fn GetSourceBuffer(&self, dwstreamindex: u32) -> Option<IMFSourceBuffer>;
}
impl windows_core::RuntimeName for IMFMediaSourceExtension {}
impl IMFMediaSourceExtension_Vtbl {
    pub const fn new<Identity: IMFMediaSourceExtension_Impl, const OFFSET: isize>() -> IMFMediaSourceExtension_Vtbl {
        unsafe extern "system" fn GetSourceBuffers<Identity: IMFMediaSourceExtension_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> Option<IMFSourceBufferList> {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSourceExtension_Impl::GetSourceBuffers(this)
        }
        unsafe extern "system" fn GetActiveSourceBuffers<Identity: IMFMediaSourceExtension_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> Option<IMFSourceBufferList> {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSourceExtension_Impl::GetActiveSourceBuffers(this)
        }
        unsafe extern "system" fn GetReadyState<Identity: IMFMediaSourceExtension_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> MF_MSE_READY {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSourceExtension_Impl::GetReadyState(this)
        }
        unsafe extern "system" fn GetDuration<Identity: IMFMediaSourceExtension_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> f64 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSourceExtension_Impl::GetDuration(this)
        }
        unsafe extern "system" fn SetDuration<Identity: IMFMediaSourceExtension_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, duration: f64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSourceExtension_Impl::SetDuration(this, core::mem::transmute_copy(&duration)).into()
        }
        unsafe extern "system" fn AddSourceBuffer<Identity: IMFMediaSourceExtension_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, r#type: core::mem::MaybeUninit<windows_core::BSTR>, pnotify: *mut core::ffi::c_void, ppsourcebuffer: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaSourceExtension_Impl::AddSourceBuffer(this, core::mem::transmute(&r#type), windows_core::from_raw_borrowed(&pnotify)) {
                Ok(ok__) => {
                    ppsourcebuffer.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSourceBuffer<Identity: IMFMediaSourceExtension_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psourcebuffer: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSourceExtension_Impl::RemoveSourceBuffer(this, windows_core::from_raw_borrowed(&psourcebuffer)).into()
        }
        unsafe extern "system" fn SetEndOfStream<Identity: IMFMediaSourceExtension_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, error: MF_MSE_ERROR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSourceExtension_Impl::SetEndOfStream(this, core::mem::transmute_copy(&error)).into()
        }
        unsafe extern "system" fn IsTypeSupported<Identity: IMFMediaSourceExtension_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, r#type: core::mem::MaybeUninit<windows_core::BSTR>) -> super::super::Foundation::BOOL {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSourceExtension_Impl::IsTypeSupported(this, core::mem::transmute(&r#type))
        }
        unsafe extern "system" fn GetSourceBuffer<Identity: IMFMediaSourceExtension_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32) -> Option<IMFSourceBuffer> {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSourceExtension_Impl::GetSourceBuffer(this, core::mem::transmute_copy(&dwstreamindex))
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetSourceBuffers: GetSourceBuffers::<Identity, OFFSET>,
            GetActiveSourceBuffers: GetActiveSourceBuffers::<Identity, OFFSET>,
            GetReadyState: GetReadyState::<Identity, OFFSET>,
            GetDuration: GetDuration::<Identity, OFFSET>,
            SetDuration: SetDuration::<Identity, OFFSET>,
            AddSourceBuffer: AddSourceBuffer::<Identity, OFFSET>,
            RemoveSourceBuffer: RemoveSourceBuffer::<Identity, OFFSET>,
            SetEndOfStream: SetEndOfStream::<Identity, OFFSET>,
            IsTypeSupported: IsTypeSupported::<Identity, OFFSET>,
            GetSourceBuffer: GetSourceBuffer::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaSourceExtension as windows_core::Interface>::IID
    }
}
pub trait IMFMediaSourceExtensionLiveSeekableRange_Impl: Sized + windows_core::IUnknownImpl {
    fn SetLiveSeekableRange(&self, start: f64, end: f64) -> windows_core::Result<()>;
    fn ClearLiveSeekableRange(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFMediaSourceExtensionLiveSeekableRange {}
impl IMFMediaSourceExtensionLiveSeekableRange_Vtbl {
    pub const fn new<Identity: IMFMediaSourceExtensionLiveSeekableRange_Impl, const OFFSET: isize>() -> IMFMediaSourceExtensionLiveSeekableRange_Vtbl {
        unsafe extern "system" fn SetLiveSeekableRange<Identity: IMFMediaSourceExtensionLiveSeekableRange_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, start: f64, end: f64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSourceExtensionLiveSeekableRange_Impl::SetLiveSeekableRange(this, core::mem::transmute_copy(&start), core::mem::transmute_copy(&end)).into()
        }
        unsafe extern "system" fn ClearLiveSeekableRange<Identity: IMFMediaSourceExtensionLiveSeekableRange_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSourceExtensionLiveSeekableRange_Impl::ClearLiveSeekableRange(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetLiveSeekableRange: SetLiveSeekableRange::<Identity, OFFSET>,
            ClearLiveSeekableRange: ClearLiveSeekableRange::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaSourceExtensionLiveSeekableRange as windows_core::Interface>::IID
    }
}
pub trait IMFMediaSourceExtensionNotify_Impl: Sized + windows_core::IUnknownImpl {
    fn OnSourceOpen(&self);
    fn OnSourceEnded(&self);
    fn OnSourceClose(&self);
}
impl windows_core::RuntimeName for IMFMediaSourceExtensionNotify {}
impl IMFMediaSourceExtensionNotify_Vtbl {
    pub const fn new<Identity: IMFMediaSourceExtensionNotify_Impl, const OFFSET: isize>() -> IMFMediaSourceExtensionNotify_Vtbl {
        unsafe extern "system" fn OnSourceOpen<Identity: IMFMediaSourceExtensionNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSourceExtensionNotify_Impl::OnSourceOpen(this)
        }
        unsafe extern "system" fn OnSourceEnded<Identity: IMFMediaSourceExtensionNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSourceExtensionNotify_Impl::OnSourceEnded(this)
        }
        unsafe extern "system" fn OnSourceClose<Identity: IMFMediaSourceExtensionNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSourceExtensionNotify_Impl::OnSourceClose(this)
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            OnSourceOpen: OnSourceOpen::<Identity, OFFSET>,
            OnSourceEnded: OnSourceEnded::<Identity, OFFSET>,
            OnSourceClose: OnSourceClose::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaSourceExtensionNotify as windows_core::Interface>::IID
    }
}
pub trait IMFMediaSourcePresentationProvider_Impl: Sized + windows_core::IUnknownImpl {
    fn ForceEndOfPresentation(&self, ppresentationdescriptor: Option<&IMFPresentationDescriptor>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFMediaSourcePresentationProvider {}
impl IMFMediaSourcePresentationProvider_Vtbl {
    pub const fn new<Identity: IMFMediaSourcePresentationProvider_Impl, const OFFSET: isize>() -> IMFMediaSourcePresentationProvider_Vtbl {
        unsafe extern "system" fn ForceEndOfPresentation<Identity: IMFMediaSourcePresentationProvider_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppresentationdescriptor: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaSourcePresentationProvider_Impl::ForceEndOfPresentation(this, windows_core::from_raw_borrowed(&ppresentationdescriptor)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), ForceEndOfPresentation: ForceEndOfPresentation::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaSourcePresentationProvider as windows_core::Interface>::IID
    }
}
pub trait IMFMediaSourceTopologyProvider_Impl: Sized + windows_core::IUnknownImpl {
    fn GetMediaSourceTopology(&self, ppresentationdescriptor: Option<&IMFPresentationDescriptor>) -> windows_core::Result<IMFTopology>;
}
impl windows_core::RuntimeName for IMFMediaSourceTopologyProvider {}
impl IMFMediaSourceTopologyProvider_Vtbl {
    pub const fn new<Identity: IMFMediaSourceTopologyProvider_Impl, const OFFSET: isize>() -> IMFMediaSourceTopologyProvider_Vtbl {
        unsafe extern "system" fn GetMediaSourceTopology<Identity: IMFMediaSourceTopologyProvider_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppresentationdescriptor: *mut core::ffi::c_void, pptopology: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaSourceTopologyProvider_Impl::GetMediaSourceTopology(this, windows_core::from_raw_borrowed(&ppresentationdescriptor)) {
                Ok(ok__) => {
                    pptopology.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetMediaSourceTopology: GetMediaSourceTopology::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaSourceTopologyProvider as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFMediaStream_Impl: Sized + IMFMediaEventGenerator_Impl {
    fn GetMediaSource(&self) -> windows_core::Result<IMFMediaSource>;
    fn GetStreamDescriptor(&self) -> windows_core::Result<IMFStreamDescriptor>;
    fn RequestSample(&self, ptoken: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFMediaStream {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFMediaStream_Vtbl {
    pub const fn new<Identity: IMFMediaStream_Impl, const OFFSET: isize>() -> IMFMediaStream_Vtbl {
        unsafe extern "system" fn GetMediaSource<Identity: IMFMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppmediasource: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaStream_Impl::GetMediaSource(this) {
                Ok(ok__) => {
                    ppmediasource.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamDescriptor<Identity: IMFMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppstreamdescriptor: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaStream_Impl::GetStreamDescriptor(this) {
                Ok(ok__) => {
                    ppstreamdescriptor.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RequestSample<Identity: IMFMediaStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptoken: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaStream_Impl::RequestSample(this, windows_core::from_raw_borrowed(&ptoken)).into()
        }
        Self {
            base__: IMFMediaEventGenerator_Vtbl::new::<Identity, OFFSET>(),
            GetMediaSource: GetMediaSource::<Identity, OFFSET>,
            GetStreamDescriptor: GetStreamDescriptor::<Identity, OFFSET>,
            RequestSample: RequestSample::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaStream as windows_core::Interface>::IID || iid == &<IMFMediaEventGenerator as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFMediaStream2_Impl: Sized + IMFMediaStream_Impl {
    fn SetStreamState(&self, value: MF_STREAM_STATE) -> windows_core::Result<()>;
    fn GetStreamState(&self) -> windows_core::Result<MF_STREAM_STATE>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFMediaStream2 {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFMediaStream2_Vtbl {
    pub const fn new<Identity: IMFMediaStream2_Impl, const OFFSET: isize>() -> IMFMediaStream2_Vtbl {
        unsafe extern "system" fn SetStreamState<Identity: IMFMediaStream2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: MF_STREAM_STATE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaStream2_Impl::SetStreamState(this, core::mem::transmute_copy(&value)).into()
        }
        unsafe extern "system" fn GetStreamState<Identity: IMFMediaStream2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: *mut MF_STREAM_STATE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaStream2_Impl::GetStreamState(this) {
                Ok(ok__) => {
                    value.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IMFMediaStream_Vtbl::new::<Identity, OFFSET>(),
            SetStreamState: SetStreamState::<Identity, OFFSET>,
            GetStreamState: GetStreamState::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaStream2 as windows_core::Interface>::IID || iid == &<IMFMediaEventGenerator as windows_core::Interface>::IID || iid == &<IMFMediaStream as windows_core::Interface>::IID
    }
}
pub trait IMFMediaStreamSourceSampleRequest_Impl: Sized + windows_core::IUnknownImpl {
    fn SetSample(&self, value: Option<&IMFSample>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFMediaStreamSourceSampleRequest {}
impl IMFMediaStreamSourceSampleRequest_Vtbl {
    pub const fn new<Identity: IMFMediaStreamSourceSampleRequest_Impl, const OFFSET: isize>() -> IMFMediaStreamSourceSampleRequest_Vtbl {
        unsafe extern "system" fn SetSample<Identity: IMFMediaStreamSourceSampleRequest_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaStreamSourceSampleRequest_Impl::SetSample(this, windows_core::from_raw_borrowed(&value)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), SetSample: SetSample::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaStreamSourceSampleRequest as windows_core::Interface>::IID
    }
}
pub trait IMFMediaTimeRange_Impl: Sized + windows_core::IUnknownImpl {
    fn GetLength(&self) -> u32;
    fn GetStart(&self, index: u32) -> windows_core::Result<f64>;
    fn GetEnd(&self, index: u32) -> windows_core::Result<f64>;
    fn ContainsTime(&self, time: f64) -> super::super::Foundation::BOOL;
    fn AddRange(&self, starttime: f64, endtime: f64) -> windows_core::Result<()>;
    fn Clear(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFMediaTimeRange {}
impl IMFMediaTimeRange_Vtbl {
    pub const fn new<Identity: IMFMediaTimeRange_Impl, const OFFSET: isize>() -> IMFMediaTimeRange_Vtbl {
        unsafe extern "system" fn GetLength<Identity: IMFMediaTimeRange_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u32 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaTimeRange_Impl::GetLength(this)
        }
        unsafe extern "system" fn GetStart<Identity: IMFMediaTimeRange_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, index: u32, pstart: *mut f64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaTimeRange_Impl::GetStart(this, core::mem::transmute_copy(&index)) {
                Ok(ok__) => {
                    pstart.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEnd<Identity: IMFMediaTimeRange_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, index: u32, pend: *mut f64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaTimeRange_Impl::GetEnd(this, core::mem::transmute_copy(&index)) {
                Ok(ok__) => {
                    pend.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainsTime<Identity: IMFMediaTimeRange_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, time: f64) -> super::super::Foundation::BOOL {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaTimeRange_Impl::ContainsTime(this, core::mem::transmute_copy(&time))
        }
        unsafe extern "system" fn AddRange<Identity: IMFMediaTimeRange_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, starttime: f64, endtime: f64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaTimeRange_Impl::AddRange(this, core::mem::transmute_copy(&starttime), core::mem::transmute_copy(&endtime)).into()
        }
        unsafe extern "system" fn Clear<Identity: IMFMediaTimeRange_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaTimeRange_Impl::Clear(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetLength: GetLength::<Identity, OFFSET>,
            GetStart: GetStart::<Identity, OFFSET>,
            GetEnd: GetEnd::<Identity, OFFSET>,
            ContainsTime: ContainsTime::<Identity, OFFSET>,
            AddRange: AddRange::<Identity, OFFSET>,
            Clear: Clear::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaTimeRange as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFMediaType_Impl: Sized + IMFAttributes_Impl {
    fn GetMajorType(&self) -> windows_core::Result<windows_core::GUID>;
    fn IsCompressedFormat(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn IsEqual(&self, pimediatype: Option<&IMFMediaType>) -> windows_core::Result<u32>;
    fn GetRepresentation(&self, guidrepresentation: &windows_core::GUID, ppvrepresentation: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn FreeRepresentation(&self, guidrepresentation: &windows_core::GUID, pvrepresentation: *const core::ffi::c_void) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFMediaType {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFMediaType_Vtbl {
    pub const fn new<Identity: IMFMediaType_Impl, const OFFSET: isize>() -> IMFMediaType_Vtbl {
        unsafe extern "system" fn GetMajorType<Identity: IMFMediaType_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguidmajortype: *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaType_Impl::GetMajorType(this) {
                Ok(ok__) => {
                    pguidmajortype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCompressedFormat<Identity: IMFMediaType_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfcompressed: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaType_Impl::IsCompressedFormat(this) {
                Ok(ok__) => {
                    pfcompressed.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsEqual<Identity: IMFMediaType_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pimediatype: *mut core::ffi::c_void, pdwflags: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaType_Impl::IsEqual(this, windows_core::from_raw_borrowed(&pimediatype)) {
                Ok(ok__) => {
                    pdwflags.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRepresentation<Identity: IMFMediaType_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidrepresentation: windows_core::GUID, ppvrepresentation: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaType_Impl::GetRepresentation(this, core::mem::transmute(&guidrepresentation), core::mem::transmute_copy(&ppvrepresentation)).into()
        }
        unsafe extern "system" fn FreeRepresentation<Identity: IMFMediaType_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidrepresentation: windows_core::GUID, pvrepresentation: *const core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaType_Impl::FreeRepresentation(this, core::mem::transmute(&guidrepresentation), core::mem::transmute_copy(&pvrepresentation)).into()
        }
        Self {
            base__: IMFAttributes_Vtbl::new::<Identity, OFFSET>(),
            GetMajorType: GetMajorType::<Identity, OFFSET>,
            IsCompressedFormat: IsCompressedFormat::<Identity, OFFSET>,
            IsEqual: IsEqual::<Identity, OFFSET>,
            GetRepresentation: GetRepresentation::<Identity, OFFSET>,
            FreeRepresentation: FreeRepresentation::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaType as windows_core::Interface>::IID || iid == &<IMFAttributes as windows_core::Interface>::IID
    }
}
pub trait IMFMediaTypeHandler_Impl: Sized + windows_core::IUnknownImpl {
    fn IsMediaTypeSupported(&self, pmediatype: Option<&IMFMediaType>, ppmediatype: *mut Option<IMFMediaType>) -> windows_core::Result<()>;
    fn GetMediaTypeCount(&self) -> windows_core::Result<u32>;
    fn GetMediaTypeByIndex(&self, dwindex: u32) -> windows_core::Result<IMFMediaType>;
    fn SetCurrentMediaType(&self, pmediatype: Option<&IMFMediaType>) -> windows_core::Result<()>;
    fn GetCurrentMediaType(&self) -> windows_core::Result<IMFMediaType>;
    fn GetMajorType(&self) -> windows_core::Result<windows_core::GUID>;
}
impl windows_core::RuntimeName for IMFMediaTypeHandler {}
impl IMFMediaTypeHandler_Vtbl {
    pub const fn new<Identity: IMFMediaTypeHandler_Impl, const OFFSET: isize>() -> IMFMediaTypeHandler_Vtbl {
        unsafe extern "system" fn IsMediaTypeSupported<Identity: IMFMediaTypeHandler_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmediatype: *mut core::ffi::c_void, ppmediatype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaTypeHandler_Impl::IsMediaTypeSupported(this, windows_core::from_raw_borrowed(&pmediatype), core::mem::transmute_copy(&ppmediatype)).into()
        }
        unsafe extern "system" fn GetMediaTypeCount<Identity: IMFMediaTypeHandler_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwtypecount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaTypeHandler_Impl::GetMediaTypeCount(this) {
                Ok(ok__) => {
                    pdwtypecount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaTypeByIndex<Identity: IMFMediaTypeHandler_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwindex: u32, pptype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaTypeHandler_Impl::GetMediaTypeByIndex(this, core::mem::transmute_copy(&dwindex)) {
                Ok(ok__) => {
                    pptype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentMediaType<Identity: IMFMediaTypeHandler_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmediatype: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMediaTypeHandler_Impl::SetCurrentMediaType(this, windows_core::from_raw_borrowed(&pmediatype)).into()
        }
        unsafe extern "system" fn GetCurrentMediaType<Identity: IMFMediaTypeHandler_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppmediatype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaTypeHandler_Impl::GetCurrentMediaType(this) {
                Ok(ok__) => {
                    ppmediatype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMajorType<Identity: IMFMediaTypeHandler_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguidmajortype: *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMediaTypeHandler_Impl::GetMajorType(this) {
                Ok(ok__) => {
                    pguidmajortype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            IsMediaTypeSupported: IsMediaTypeSupported::<Identity, OFFSET>,
            GetMediaTypeCount: GetMediaTypeCount::<Identity, OFFSET>,
            GetMediaTypeByIndex: GetMediaTypeByIndex::<Identity, OFFSET>,
            SetCurrentMediaType: SetCurrentMediaType::<Identity, OFFSET>,
            GetCurrentMediaType: GetCurrentMediaType::<Identity, OFFSET>,
            GetMajorType: GetMajorType::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMediaTypeHandler as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFMetadata_Impl: Sized + windows_core::IUnknownImpl {
    fn SetLanguage(&self, pwszrfc1766: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn GetLanguage(&self) -> windows_core::Result<windows_core::PWSTR>;
    fn GetAllLanguages(&self) -> windows_core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
    fn SetProperty(&self, pwszname: &windows_core::PCWSTR, ppvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> windows_core::Result<()>;
    fn GetProperty(&self, pwszname: &windows_core::PCWSTR) -> windows_core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
    fn DeleteProperty(&self, pwszname: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn GetAllPropertyNames(&self) -> windows_core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFMetadata {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFMetadata_Vtbl {
    pub const fn new<Identity: IMFMetadata_Impl, const OFFSET: isize>() -> IMFMetadata_Vtbl {
        unsafe extern "system" fn SetLanguage<Identity: IMFMetadata_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwszrfc1766: windows_core::PCWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMetadata_Impl::SetLanguage(this, core::mem::transmute(&pwszrfc1766)).into()
        }
        unsafe extern "system" fn GetLanguage<Identity: IMFMetadata_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppwszrfc1766: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMetadata_Impl::GetLanguage(this) {
                Ok(ok__) => {
                    ppwszrfc1766.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAllLanguages<Identity: IMFMetadata_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppvlanguages: *mut core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMetadata_Impl::GetAllLanguages(this) {
                Ok(ok__) => {
                    ppvlanguages.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProperty<Identity: IMFMetadata_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwszname: windows_core::PCWSTR, ppvvalue: *const core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMetadata_Impl::SetProperty(this, core::mem::transmute(&pwszname), core::mem::transmute_copy(&ppvvalue)).into()
        }
        unsafe extern "system" fn GetProperty<Identity: IMFMetadata_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwszname: windows_core::PCWSTR, ppvvalue: *mut core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMetadata_Impl::GetProperty(this, core::mem::transmute(&pwszname)) {
                Ok(ok__) => {
                    ppvvalue.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DeleteProperty<Identity: IMFMetadata_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwszname: windows_core::PCWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMetadata_Impl::DeleteProperty(this, core::mem::transmute(&pwszname)).into()
        }
        unsafe extern "system" fn GetAllPropertyNames<Identity: IMFMetadata_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppvnames: *mut core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMetadata_Impl::GetAllPropertyNames(this) {
                Ok(ok__) => {
                    ppvnames.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetLanguage: SetLanguage::<Identity, OFFSET>,
            GetLanguage: GetLanguage::<Identity, OFFSET>,
            GetAllLanguages: GetAllLanguages::<Identity, OFFSET>,
            SetProperty: SetProperty::<Identity, OFFSET>,
            GetProperty: GetProperty::<Identity, OFFSET>,
            DeleteProperty: DeleteProperty::<Identity, OFFSET>,
            GetAllPropertyNames: GetAllPropertyNames::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMetadata as windows_core::Interface>::IID
    }
}
pub trait IMFMetadataProvider_Impl: Sized + windows_core::IUnknownImpl {
    fn GetMFMetadata(&self, ppresentationdescriptor: Option<&IMFPresentationDescriptor>, dwstreamidentifier: u32, dwflags: u32) -> windows_core::Result<IMFMetadata>;
}
impl windows_core::RuntimeName for IMFMetadataProvider {}
impl IMFMetadataProvider_Vtbl {
    pub const fn new<Identity: IMFMetadataProvider_Impl, const OFFSET: isize>() -> IMFMetadataProvider_Vtbl {
        unsafe extern "system" fn GetMFMetadata<Identity: IMFMetadataProvider_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppresentationdescriptor: *mut core::ffi::c_void, dwstreamidentifier: u32, dwflags: u32, ppmfmetadata: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMetadataProvider_Impl::GetMFMetadata(this, windows_core::from_raw_borrowed(&ppresentationdescriptor), core::mem::transmute_copy(&dwstreamidentifier), core::mem::transmute_copy(&dwflags)) {
                Ok(ok__) => {
                    ppmfmetadata.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetMFMetadata: GetMFMetadata::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMetadataProvider as windows_core::Interface>::IID
    }
}
pub trait IMFMuxStreamAttributesManager_Impl: Sized + windows_core::IUnknownImpl {
    fn GetStreamCount(&self) -> windows_core::Result<u32>;
    fn GetAttributes(&self, dwmuxstreamindex: u32) -> windows_core::Result<IMFAttributes>;
}
impl windows_core::RuntimeName for IMFMuxStreamAttributesManager {}
impl IMFMuxStreamAttributesManager_Vtbl {
    pub const fn new<Identity: IMFMuxStreamAttributesManager_Impl, const OFFSET: isize>() -> IMFMuxStreamAttributesManager_Vtbl {
        unsafe extern "system" fn GetStreamCount<Identity: IMFMuxStreamAttributesManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwmuxstreamcount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMuxStreamAttributesManager_Impl::GetStreamCount(this) {
                Ok(ok__) => {
                    pdwmuxstreamcount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAttributes<Identity: IMFMuxStreamAttributesManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwmuxstreamindex: u32, ppstreamattributes: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMuxStreamAttributesManager_Impl::GetAttributes(this, core::mem::transmute_copy(&dwmuxstreamindex)) {
                Ok(ok__) => {
                    ppstreamattributes.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetStreamCount: GetStreamCount::<Identity, OFFSET>,
            GetAttributes: GetAttributes::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMuxStreamAttributesManager as windows_core::Interface>::IID
    }
}
pub trait IMFMuxStreamMediaTypeManager_Impl: Sized + windows_core::IUnknownImpl {
    fn GetStreamCount(&self) -> windows_core::Result<u32>;
    fn GetMediaType(&self, dwmuxstreamindex: u32) -> windows_core::Result<IMFMediaType>;
    fn GetStreamConfigurationCount(&self) -> windows_core::Result<u32>;
    fn AddStreamConfiguration(&self, ullstreammask: u64) -> windows_core::Result<()>;
    fn RemoveStreamConfiguration(&self, ullstreammask: u64) -> windows_core::Result<()>;
    fn GetStreamConfiguration(&self, ulindex: u32) -> windows_core::Result<u64>;
}
impl windows_core::RuntimeName for IMFMuxStreamMediaTypeManager {}
impl IMFMuxStreamMediaTypeManager_Vtbl {
    pub const fn new<Identity: IMFMuxStreamMediaTypeManager_Impl, const OFFSET: isize>() -> IMFMuxStreamMediaTypeManager_Vtbl {
        unsafe extern "system" fn GetStreamCount<Identity: IMFMuxStreamMediaTypeManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwmuxstreamcount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMuxStreamMediaTypeManager_Impl::GetStreamCount(this) {
                Ok(ok__) => {
                    pdwmuxstreamcount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaType<Identity: IMFMuxStreamMediaTypeManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwmuxstreamindex: u32, ppmediatype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMuxStreamMediaTypeManager_Impl::GetMediaType(this, core::mem::transmute_copy(&dwmuxstreamindex)) {
                Ok(ok__) => {
                    ppmediatype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamConfigurationCount<Identity: IMFMuxStreamMediaTypeManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwcount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMuxStreamMediaTypeManager_Impl::GetStreamConfigurationCount(this) {
                Ok(ok__) => {
                    pdwcount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddStreamConfiguration<Identity: IMFMuxStreamMediaTypeManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ullstreammask: u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMuxStreamMediaTypeManager_Impl::AddStreamConfiguration(this, core::mem::transmute_copy(&ullstreammask)).into()
        }
        unsafe extern "system" fn RemoveStreamConfiguration<Identity: IMFMuxStreamMediaTypeManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ullstreammask: u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMuxStreamMediaTypeManager_Impl::RemoveStreamConfiguration(this, core::mem::transmute_copy(&ullstreammask)).into()
        }
        unsafe extern "system" fn GetStreamConfiguration<Identity: IMFMuxStreamMediaTypeManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulindex: u32, pullstreammask: *mut u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMuxStreamMediaTypeManager_Impl::GetStreamConfiguration(this, core::mem::transmute_copy(&ulindex)) {
                Ok(ok__) => {
                    pullstreammask.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetStreamCount: GetStreamCount::<Identity, OFFSET>,
            GetMediaType: GetMediaType::<Identity, OFFSET>,
            GetStreamConfigurationCount: GetStreamConfigurationCount::<Identity, OFFSET>,
            AddStreamConfiguration: AddStreamConfiguration::<Identity, OFFSET>,
            RemoveStreamConfiguration: RemoveStreamConfiguration::<Identity, OFFSET>,
            GetStreamConfiguration: GetStreamConfiguration::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMuxStreamMediaTypeManager as windows_core::Interface>::IID
    }
}
pub trait IMFMuxStreamSampleManager_Impl: Sized + windows_core::IUnknownImpl {
    fn GetStreamCount(&self) -> windows_core::Result<u32>;
    fn GetSample(&self, dwmuxstreamindex: u32) -> windows_core::Result<IMFSample>;
    fn GetStreamConfiguration(&self) -> u64;
}
impl windows_core::RuntimeName for IMFMuxStreamSampleManager {}
impl IMFMuxStreamSampleManager_Vtbl {
    pub const fn new<Identity: IMFMuxStreamSampleManager_Impl, const OFFSET: isize>() -> IMFMuxStreamSampleManager_Vtbl {
        unsafe extern "system" fn GetStreamCount<Identity: IMFMuxStreamSampleManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwmuxstreamcount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMuxStreamSampleManager_Impl::GetStreamCount(this) {
                Ok(ok__) => {
                    pdwmuxstreamcount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSample<Identity: IMFMuxStreamSampleManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwmuxstreamindex: u32, ppsample: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFMuxStreamSampleManager_Impl::GetSample(this, core::mem::transmute_copy(&dwmuxstreamindex)) {
                Ok(ok__) => {
                    ppsample.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamConfiguration<Identity: IMFMuxStreamSampleManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u64 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFMuxStreamSampleManager_Impl::GetStreamConfiguration(this)
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetStreamCount: GetStreamCount::<Identity, OFFSET>,
            GetSample: GetSample::<Identity, OFFSET>,
            GetStreamConfiguration: GetStreamConfiguration::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFMuxStreamSampleManager as windows_core::Interface>::IID
    }
}
pub trait IMFNetCredential_Impl: Sized + windows_core::IUnknownImpl {
    fn SetUser(&self, pbdata: *const u8, cbdata: u32, fdataisencrypted: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn SetPassword(&self, pbdata: *const u8, cbdata: u32, fdataisencrypted: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn GetUser(&self, pbdata: *mut u8, pcbdata: *mut u32, fencryptdata: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn GetPassword(&self, pbdata: *mut u8, pcbdata: *mut u32, fencryptdata: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn LoggedOnUser(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
}
impl windows_core::RuntimeName for IMFNetCredential {}
impl IMFNetCredential_Vtbl {
    pub const fn new<Identity: IMFNetCredential_Impl, const OFFSET: isize>() -> IMFNetCredential_Vtbl {
        unsafe extern "system" fn SetUser<Identity: IMFNetCredential_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbdata: *const u8, cbdata: u32, fdataisencrypted: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFNetCredential_Impl::SetUser(this, core::mem::transmute_copy(&pbdata), core::mem::transmute_copy(&cbdata), core::mem::transmute_copy(&fdataisencrypted)).into()
        }
        unsafe extern "system" fn SetPassword<Identity: IMFNetCredential_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbdata: *const u8, cbdata: u32, fdataisencrypted: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFNetCredential_Impl::SetPassword(this, core::mem::transmute_copy(&pbdata), core::mem::transmute_copy(&cbdata), core::mem::transmute_copy(&fdataisencrypted)).into()
        }
        unsafe extern "system" fn GetUser<Identity: IMFNetCredential_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbdata: *mut u8, pcbdata: *mut u32, fencryptdata: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFNetCredential_Impl::GetUser(this, core::mem::transmute_copy(&pbdata), core::mem::transmute_copy(&pcbdata), core::mem::transmute_copy(&fencryptdata)).into()
        }
        unsafe extern "system" fn GetPassword<Identity: IMFNetCredential_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbdata: *mut u8, pcbdata: *mut u32, fencryptdata: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFNetCredential_Impl::GetPassword(this, core::mem::transmute_copy(&pbdata), core::mem::transmute_copy(&pcbdata), core::mem::transmute_copy(&fencryptdata)).into()
        }
        unsafe extern "system" fn LoggedOnUser<Identity: IMFNetCredential_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfloggedonuser: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFNetCredential_Impl::LoggedOnUser(this) {
                Ok(ok__) => {
                    pfloggedonuser.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetUser: SetUser::<Identity, OFFSET>,
            SetPassword: SetPassword::<Identity, OFFSET>,
            GetUser: GetUser::<Identity, OFFSET>,
            GetPassword: GetPassword::<Identity, OFFSET>,
            LoggedOnUser: LoggedOnUser::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFNetCredential as windows_core::Interface>::IID
    }
}
pub trait IMFNetCredentialCache_Impl: Sized + windows_core::IUnknownImpl {
    fn GetCredential(&self, pszurl: &windows_core::PCWSTR, pszrealm: &windows_core::PCWSTR, dwauthenticationflags: u32, ppcred: *mut Option<IMFNetCredential>, pdwrequirementsflags: *mut u32) -> windows_core::Result<()>;
    fn SetGood(&self, pcred: Option<&IMFNetCredential>, fgood: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn SetUserOptions(&self, pcred: Option<&IMFNetCredential>, dwoptionsflags: u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFNetCredentialCache {}
impl IMFNetCredentialCache_Vtbl {
    pub const fn new<Identity: IMFNetCredentialCache_Impl, const OFFSET: isize>() -> IMFNetCredentialCache_Vtbl {
        unsafe extern "system" fn GetCredential<Identity: IMFNetCredentialCache_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszurl: windows_core::PCWSTR, pszrealm: windows_core::PCWSTR, dwauthenticationflags: u32, ppcred: *mut *mut core::ffi::c_void, pdwrequirementsflags: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFNetCredentialCache_Impl::GetCredential(this, core::mem::transmute(&pszurl), core::mem::transmute(&pszrealm), core::mem::transmute_copy(&dwauthenticationflags), core::mem::transmute_copy(&ppcred), core::mem::transmute_copy(&pdwrequirementsflags)).into()
        }
        unsafe extern "system" fn SetGood<Identity: IMFNetCredentialCache_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcred: *mut core::ffi::c_void, fgood: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFNetCredentialCache_Impl::SetGood(this, windows_core::from_raw_borrowed(&pcred), core::mem::transmute_copy(&fgood)).into()
        }
        unsafe extern "system" fn SetUserOptions<Identity: IMFNetCredentialCache_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcred: *mut core::ffi::c_void, dwoptionsflags: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFNetCredentialCache_Impl::SetUserOptions(this, windows_core::from_raw_borrowed(&pcred), core::mem::transmute_copy(&dwoptionsflags)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetCredential: GetCredential::<Identity, OFFSET>,
            SetGood: SetGood::<Identity, OFFSET>,
            SetUserOptions: SetUserOptions::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFNetCredentialCache as windows_core::Interface>::IID
    }
}
pub trait IMFNetCredentialManager_Impl: Sized + windows_core::IUnknownImpl {
    fn BeginGetCredentials(&self, pparam: *const MFNetCredentialManagerGetParam, pcallback: Option<&IMFAsyncCallback>, pstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndGetCredentials(&self, presult: Option<&IMFAsyncResult>) -> windows_core::Result<IMFNetCredential>;
    fn SetGood(&self, pcred: Option<&IMFNetCredential>, fgood: super::super::Foundation::BOOL) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFNetCredentialManager {}
impl IMFNetCredentialManager_Vtbl {
    pub const fn new<Identity: IMFNetCredentialManager_Impl, const OFFSET: isize>() -> IMFNetCredentialManager_Vtbl {
        unsafe extern "system" fn BeginGetCredentials<Identity: IMFNetCredentialManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pparam: *const MFNetCredentialManagerGetParam, pcallback: *mut core::ffi::c_void, pstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFNetCredentialManager_Impl::BeginGetCredentials(this, core::mem::transmute_copy(&pparam), windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&pstate)).into()
        }
        unsafe extern "system" fn EndGetCredentials<Identity: IMFNetCredentialManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void, ppcred: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFNetCredentialManager_Impl::EndGetCredentials(this, windows_core::from_raw_borrowed(&presult)) {
                Ok(ok__) => {
                    ppcred.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGood<Identity: IMFNetCredentialManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcred: *mut core::ffi::c_void, fgood: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFNetCredentialManager_Impl::SetGood(this, windows_core::from_raw_borrowed(&pcred), core::mem::transmute_copy(&fgood)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            BeginGetCredentials: BeginGetCredentials::<Identity, OFFSET>,
            EndGetCredentials: EndGetCredentials::<Identity, OFFSET>,
            SetGood: SetGood::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFNetCredentialManager as windows_core::Interface>::IID
    }
}
pub trait IMFNetCrossOriginSupport_Impl: Sized + windows_core::IUnknownImpl {
    fn GetCrossOriginPolicy(&self) -> windows_core::Result<MF_CROSS_ORIGIN_POLICY>;
    fn GetSourceOrigin(&self) -> windows_core::Result<windows_core::PWSTR>;
    fn IsSameOrigin(&self, wszurl: &windows_core::PCWSTR) -> windows_core::Result<super::super::Foundation::BOOL>;
}
impl windows_core::RuntimeName for IMFNetCrossOriginSupport {}
impl IMFNetCrossOriginSupport_Vtbl {
    pub const fn new<Identity: IMFNetCrossOriginSupport_Impl, const OFFSET: isize>() -> IMFNetCrossOriginSupport_Vtbl {
        unsafe extern "system" fn GetCrossOriginPolicy<Identity: IMFNetCrossOriginSupport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppolicy: *mut MF_CROSS_ORIGIN_POLICY) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFNetCrossOriginSupport_Impl::GetCrossOriginPolicy(this) {
                Ok(ok__) => {
                    ppolicy.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceOrigin<Identity: IMFNetCrossOriginSupport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, wszsourceorigin: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFNetCrossOriginSupport_Impl::GetSourceOrigin(this) {
                Ok(ok__) => {
                    wszsourceorigin.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSameOrigin<Identity: IMFNetCrossOriginSupport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, wszurl: windows_core::PCWSTR, pfissameorigin: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFNetCrossOriginSupport_Impl::IsSameOrigin(this, core::mem::transmute(&wszurl)) {
                Ok(ok__) => {
                    pfissameorigin.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetCrossOriginPolicy: GetCrossOriginPolicy::<Identity, OFFSET>,
            GetSourceOrigin: GetSourceOrigin::<Identity, OFFSET>,
            IsSameOrigin: IsSameOrigin::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFNetCrossOriginSupport as windows_core::Interface>::IID
    }
}
pub trait IMFNetProxyLocator_Impl: Sized + windows_core::IUnknownImpl {
    fn FindFirstProxy(&self, pszhost: &windows_core::PCWSTR, pszurl: &windows_core::PCWSTR, freserved: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn FindNextProxy(&self) -> windows_core::Result<()>;
    fn RegisterProxyResult(&self, hrop: windows_core::HRESULT) -> windows_core::Result<()>;
    fn GetCurrentProxy(&self, pszstr: windows_core::PWSTR, pcchstr: *mut u32) -> windows_core::Result<()>;
    fn Clone(&self) -> windows_core::Result<IMFNetProxyLocator>;
}
impl windows_core::RuntimeName for IMFNetProxyLocator {}
impl IMFNetProxyLocator_Vtbl {
    pub const fn new<Identity: IMFNetProxyLocator_Impl, const OFFSET: isize>() -> IMFNetProxyLocator_Vtbl {
        unsafe extern "system" fn FindFirstProxy<Identity: IMFNetProxyLocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszhost: windows_core::PCWSTR, pszurl: windows_core::PCWSTR, freserved: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFNetProxyLocator_Impl::FindFirstProxy(this, core::mem::transmute(&pszhost), core::mem::transmute(&pszurl), core::mem::transmute_copy(&freserved)).into()
        }
        unsafe extern "system" fn FindNextProxy<Identity: IMFNetProxyLocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFNetProxyLocator_Impl::FindNextProxy(this).into()
        }
        unsafe extern "system" fn RegisterProxyResult<Identity: IMFNetProxyLocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hrop: windows_core::HRESULT) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFNetProxyLocator_Impl::RegisterProxyResult(this, core::mem::transmute_copy(&hrop)).into()
        }
        unsafe extern "system" fn GetCurrentProxy<Identity: IMFNetProxyLocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszstr: windows_core::PWSTR, pcchstr: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFNetProxyLocator_Impl::GetCurrentProxy(this, core::mem::transmute_copy(&pszstr), core::mem::transmute_copy(&pcchstr)).into()
        }
        unsafe extern "system" fn Clone<Identity: IMFNetProxyLocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppproxylocator: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFNetProxyLocator_Impl::Clone(this) {
                Ok(ok__) => {
                    ppproxylocator.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            FindFirstProxy: FindFirstProxy::<Identity, OFFSET>,
            FindNextProxy: FindNextProxy::<Identity, OFFSET>,
            RegisterProxyResult: RegisterProxyResult::<Identity, OFFSET>,
            GetCurrentProxy: GetCurrentProxy::<Identity, OFFSET>,
            Clone: Clone::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFNetProxyLocator as windows_core::Interface>::IID
    }
}
pub trait IMFNetProxyLocatorFactory_Impl: Sized + windows_core::IUnknownImpl {
    fn CreateProxyLocator(&self, pszprotocol: &windows_core::PCWSTR) -> windows_core::Result<IMFNetProxyLocator>;
}
impl windows_core::RuntimeName for IMFNetProxyLocatorFactory {}
impl IMFNetProxyLocatorFactory_Vtbl {
    pub const fn new<Identity: IMFNetProxyLocatorFactory_Impl, const OFFSET: isize>() -> IMFNetProxyLocatorFactory_Vtbl {
        unsafe extern "system" fn CreateProxyLocator<Identity: IMFNetProxyLocatorFactory_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszprotocol: windows_core::PCWSTR, ppproxylocator: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFNetProxyLocatorFactory_Impl::CreateProxyLocator(this, core::mem::transmute(&pszprotocol)) {
                Ok(ok__) => {
                    ppproxylocator.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), CreateProxyLocator: CreateProxyLocator::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFNetProxyLocatorFactory as windows_core::Interface>::IID
    }
}
pub trait IMFNetResourceFilter_Impl: Sized + windows_core::IUnknownImpl {
    fn OnRedirect(&self, pszurl: &windows_core::PCWSTR) -> windows_core::Result<super::super::Foundation::VARIANT_BOOL>;
    fn OnSendingRequest(&self, pszurl: &windows_core::PCWSTR) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFNetResourceFilter {}
impl IMFNetResourceFilter_Vtbl {
    pub const fn new<Identity: IMFNetResourceFilter_Impl, const OFFSET: isize>() -> IMFNetResourceFilter_Vtbl {
        unsafe extern "system" fn OnRedirect<Identity: IMFNetResourceFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszurl: windows_core::PCWSTR, pvbcancel: *mut super::super::Foundation::VARIANT_BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFNetResourceFilter_Impl::OnRedirect(this, core::mem::transmute(&pszurl)) {
                Ok(ok__) => {
                    pvbcancel.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnSendingRequest<Identity: IMFNetResourceFilter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszurl: windows_core::PCWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFNetResourceFilter_Impl::OnSendingRequest(this, core::mem::transmute(&pszurl)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            OnRedirect: OnRedirect::<Identity, OFFSET>,
            OnSendingRequest: OnSendingRequest::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFNetResourceFilter as windows_core::Interface>::IID
    }
}
pub trait IMFNetSchemeHandlerConfig_Impl: Sized + windows_core::IUnknownImpl {
    fn GetNumberOfSupportedProtocols(&self) -> windows_core::Result<u32>;
    fn GetSupportedProtocolType(&self, nprotocolindex: u32) -> windows_core::Result<MFNETSOURCE_PROTOCOL_TYPE>;
    fn ResetProtocolRolloverSettings(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFNetSchemeHandlerConfig {}
impl IMFNetSchemeHandlerConfig_Vtbl {
    pub const fn new<Identity: IMFNetSchemeHandlerConfig_Impl, const OFFSET: isize>() -> IMFNetSchemeHandlerConfig_Vtbl {
        unsafe extern "system" fn GetNumberOfSupportedProtocols<Identity: IMFNetSchemeHandlerConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcprotocols: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFNetSchemeHandlerConfig_Impl::GetNumberOfSupportedProtocols(this) {
                Ok(ok__) => {
                    pcprotocols.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSupportedProtocolType<Identity: IMFNetSchemeHandlerConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, nprotocolindex: u32, pnprotocoltype: *mut MFNETSOURCE_PROTOCOL_TYPE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFNetSchemeHandlerConfig_Impl::GetSupportedProtocolType(this, core::mem::transmute_copy(&nprotocolindex)) {
                Ok(ok__) => {
                    pnprotocoltype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ResetProtocolRolloverSettings<Identity: IMFNetSchemeHandlerConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFNetSchemeHandlerConfig_Impl::ResetProtocolRolloverSettings(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetNumberOfSupportedProtocols: GetNumberOfSupportedProtocols::<Identity, OFFSET>,
            GetSupportedProtocolType: GetSupportedProtocolType::<Identity, OFFSET>,
            ResetProtocolRolloverSettings: ResetProtocolRolloverSettings::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFNetSchemeHandlerConfig as windows_core::Interface>::IID
    }
}
pub trait IMFObjectReferenceStream_Impl: Sized + windows_core::IUnknownImpl {
    fn SaveReference(&self, riid: *const windows_core::GUID, punk: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn LoadReference(&self, riid: *const windows_core::GUID, ppv: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFObjectReferenceStream {}
impl IMFObjectReferenceStream_Vtbl {
    pub const fn new<Identity: IMFObjectReferenceStream_Impl, const OFFSET: isize>() -> IMFObjectReferenceStream_Vtbl {
        unsafe extern "system" fn SaveReference<Identity: IMFObjectReferenceStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, riid: *const windows_core::GUID, punk: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFObjectReferenceStream_Impl::SaveReference(this, core::mem::transmute_copy(&riid), windows_core::from_raw_borrowed(&punk)).into()
        }
        unsafe extern "system" fn LoadReference<Identity: IMFObjectReferenceStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppv: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFObjectReferenceStream_Impl::LoadReference(this, core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppv)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SaveReference: SaveReference::<Identity, OFFSET>,
            LoadReference: LoadReference::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFObjectReferenceStream as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFOutputPolicy_Impl: Sized + IMFAttributes_Impl {
    fn GenerateRequiredSchemas(&self, dwattributes: u32, guidoutputsubtype: &windows_core::GUID, rgguidprotectionschemassupported: *const windows_core::GUID, cprotectionschemassupported: u32) -> windows_core::Result<IMFCollection>;
    fn GetOriginatorID(&self) -> windows_core::Result<windows_core::GUID>;
    fn GetMinimumGRLVersion(&self) -> windows_core::Result<u32>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFOutputPolicy {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFOutputPolicy_Vtbl {
    pub const fn new<Identity: IMFOutputPolicy_Impl, const OFFSET: isize>() -> IMFOutputPolicy_Vtbl {
        unsafe extern "system" fn GenerateRequiredSchemas<Identity: IMFOutputPolicy_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwattributes: u32, guidoutputsubtype: windows_core::GUID, rgguidprotectionschemassupported: *const windows_core::GUID, cprotectionschemassupported: u32, pprequiredprotectionschemas: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFOutputPolicy_Impl::GenerateRequiredSchemas(this, core::mem::transmute_copy(&dwattributes), core::mem::transmute(&guidoutputsubtype), core::mem::transmute_copy(&rgguidprotectionschemassupported), core::mem::transmute_copy(&cprotectionschemassupported)) {
                Ok(ok__) => {
                    pprequiredprotectionschemas.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginatorID<Identity: IMFOutputPolicy_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguidoriginatorid: *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFOutputPolicy_Impl::GetOriginatorID(this) {
                Ok(ok__) => {
                    pguidoriginatorid.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMinimumGRLVersion<Identity: IMFOutputPolicy_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwminimumgrlversion: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFOutputPolicy_Impl::GetMinimumGRLVersion(this) {
                Ok(ok__) => {
                    pdwminimumgrlversion.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IMFAttributes_Vtbl::new::<Identity, OFFSET>(),
            GenerateRequiredSchemas: GenerateRequiredSchemas::<Identity, OFFSET>,
            GetOriginatorID: GetOriginatorID::<Identity, OFFSET>,
            GetMinimumGRLVersion: GetMinimumGRLVersion::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFOutputPolicy as windows_core::Interface>::IID || iid == &<IMFAttributes as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFOutputSchema_Impl: Sized + IMFAttributes_Impl {
    fn GetSchemaType(&self) -> windows_core::Result<windows_core::GUID>;
    fn GetConfigurationData(&self) -> windows_core::Result<u32>;
    fn GetOriginatorID(&self) -> windows_core::Result<windows_core::GUID>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFOutputSchema {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFOutputSchema_Vtbl {
    pub const fn new<Identity: IMFOutputSchema_Impl, const OFFSET: isize>() -> IMFOutputSchema_Vtbl {
        unsafe extern "system" fn GetSchemaType<Identity: IMFOutputSchema_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguidschematype: *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFOutputSchema_Impl::GetSchemaType(this) {
                Ok(ok__) => {
                    pguidschematype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetConfigurationData<Identity: IMFOutputSchema_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwval: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFOutputSchema_Impl::GetConfigurationData(this) {
                Ok(ok__) => {
                    pdwval.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginatorID<Identity: IMFOutputSchema_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguidoriginatorid: *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFOutputSchema_Impl::GetOriginatorID(this) {
                Ok(ok__) => {
                    pguidoriginatorid.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IMFAttributes_Vtbl::new::<Identity, OFFSET>(),
            GetSchemaType: GetSchemaType::<Identity, OFFSET>,
            GetConfigurationData: GetConfigurationData::<Identity, OFFSET>,
            GetOriginatorID: GetOriginatorID::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFOutputSchema as windows_core::Interface>::IID || iid == &<IMFAttributes as windows_core::Interface>::IID
    }
}
pub trait IMFOutputTrustAuthority_Impl: Sized + windows_core::IUnknownImpl {
    fn GetAction(&self) -> windows_core::Result<MFPOLICYMANAGER_ACTION>;
    fn SetPolicy(&self, pppolicy: *const Option<IMFOutputPolicy>, npolicy: u32, ppbticket: *mut *mut u8, pcbticket: *mut u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFOutputTrustAuthority {}
impl IMFOutputTrustAuthority_Vtbl {
    pub const fn new<Identity: IMFOutputTrustAuthority_Impl, const OFFSET: isize>() -> IMFOutputTrustAuthority_Vtbl {
        unsafe extern "system" fn GetAction<Identity: IMFOutputTrustAuthority_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, paction: *mut MFPOLICYMANAGER_ACTION) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFOutputTrustAuthority_Impl::GetAction(this) {
                Ok(ok__) => {
                    paction.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPolicy<Identity: IMFOutputTrustAuthority_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pppolicy: *const *mut core::ffi::c_void, npolicy: u32, ppbticket: *mut *mut u8, pcbticket: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFOutputTrustAuthority_Impl::SetPolicy(this, core::mem::transmute_copy(&pppolicy), core::mem::transmute_copy(&npolicy), core::mem::transmute_copy(&ppbticket), core::mem::transmute_copy(&pcbticket)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetAction: GetAction::<Identity, OFFSET>,
            SetPolicy: SetPolicy::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFOutputTrustAuthority as windows_core::Interface>::IID
    }
}
pub trait IMFPMPClient_Impl: Sized + windows_core::IUnknownImpl {
    fn SetPMPHost(&self, ppmphost: Option<&IMFPMPHost>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFPMPClient {}
impl IMFPMPClient_Vtbl {
    pub const fn new<Identity: IMFPMPClient_Impl, const OFFSET: isize>() -> IMFPMPClient_Vtbl {
        unsafe extern "system" fn SetPMPHost<Identity: IMFPMPClient_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppmphost: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMPClient_Impl::SetPMPHost(this, windows_core::from_raw_borrowed(&ppmphost)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), SetPMPHost: SetPMPHost::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFPMPClient as windows_core::Interface>::IID
    }
}
pub trait IMFPMPClientApp_Impl: Sized + windows_core::IUnknownImpl {
    fn SetPMPHost(&self, ppmphost: Option<&IMFPMPHostApp>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFPMPClientApp {}
impl IMFPMPClientApp_Vtbl {
    pub const fn new<Identity: IMFPMPClientApp_Impl, const OFFSET: isize>() -> IMFPMPClientApp_Vtbl {
        unsafe extern "system" fn SetPMPHost<Identity: IMFPMPClientApp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppmphost: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMPClientApp_Impl::SetPMPHost(this, windows_core::from_raw_borrowed(&ppmphost)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), SetPMPHost: SetPMPHost::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFPMPClientApp as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMFPMPHost_Impl: Sized + windows_core::IUnknownImpl {
    fn LockProcess(&self) -> windows_core::Result<()>;
    fn UnlockProcess(&self) -> windows_core::Result<()>;
    fn CreateObjectByCLSID(&self, clsid: *const windows_core::GUID, pstream: Option<&super::super::System::Com::IStream>, riid: *const windows_core::GUID, ppv: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_System_Com")]
impl windows_core::RuntimeName for IMFPMPHost {}
#[cfg(feature = "Win32_System_Com")]
impl IMFPMPHost_Vtbl {
    pub const fn new<Identity: IMFPMPHost_Impl, const OFFSET: isize>() -> IMFPMPHost_Vtbl {
        unsafe extern "system" fn LockProcess<Identity: IMFPMPHost_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMPHost_Impl::LockProcess(this).into()
        }
        unsafe extern "system" fn UnlockProcess<Identity: IMFPMPHost_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMPHost_Impl::UnlockProcess(this).into()
        }
        unsafe extern "system" fn CreateObjectByCLSID<Identity: IMFPMPHost_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clsid: *const windows_core::GUID, pstream: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppv: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMPHost_Impl::CreateObjectByCLSID(this, core::mem::transmute_copy(&clsid), windows_core::from_raw_borrowed(&pstream), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppv)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            LockProcess: LockProcess::<Identity, OFFSET>,
            UnlockProcess: UnlockProcess::<Identity, OFFSET>,
            CreateObjectByCLSID: CreateObjectByCLSID::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFPMPHost as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMFPMPHostApp_Impl: Sized + windows_core::IUnknownImpl {
    fn LockProcess(&self) -> windows_core::Result<()>;
    fn UnlockProcess(&self) -> windows_core::Result<()>;
    fn ActivateClassById(&self, id: &windows_core::PCWSTR, pstream: Option<&super::super::System::Com::IStream>, riid: *const windows_core::GUID, ppv: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_System_Com")]
impl windows_core::RuntimeName for IMFPMPHostApp {}
#[cfg(feature = "Win32_System_Com")]
impl IMFPMPHostApp_Vtbl {
    pub const fn new<Identity: IMFPMPHostApp_Impl, const OFFSET: isize>() -> IMFPMPHostApp_Vtbl {
        unsafe extern "system" fn LockProcess<Identity: IMFPMPHostApp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMPHostApp_Impl::LockProcess(this).into()
        }
        unsafe extern "system" fn UnlockProcess<Identity: IMFPMPHostApp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMPHostApp_Impl::UnlockProcess(this).into()
        }
        unsafe extern "system" fn ActivateClassById<Identity: IMFPMPHostApp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, id: windows_core::PCWSTR, pstream: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppv: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMPHostApp_Impl::ActivateClassById(this, core::mem::transmute(&id), windows_core::from_raw_borrowed(&pstream), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppv)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            LockProcess: LockProcess::<Identity, OFFSET>,
            UnlockProcess: UnlockProcess::<Identity, OFFSET>,
            ActivateClassById: ActivateClassById::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFPMPHostApp as windows_core::Interface>::IID
    }
}
pub trait IMFPMPServer_Impl: Sized + windows_core::IUnknownImpl {
    fn LockProcess(&self) -> windows_core::Result<()>;
    fn UnlockProcess(&self) -> windows_core::Result<()>;
    fn CreateObjectByCLSID(&self, clsid: *const windows_core::GUID, riid: *const windows_core::GUID, ppobject: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFPMPServer {}
impl IMFPMPServer_Vtbl {
    pub const fn new<Identity: IMFPMPServer_Impl, const OFFSET: isize>() -> IMFPMPServer_Vtbl {
        unsafe extern "system" fn LockProcess<Identity: IMFPMPServer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMPServer_Impl::LockProcess(this).into()
        }
        unsafe extern "system" fn UnlockProcess<Identity: IMFPMPServer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMPServer_Impl::UnlockProcess(this).into()
        }
        unsafe extern "system" fn CreateObjectByCLSID<Identity: IMFPMPServer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clsid: *const windows_core::GUID, riid: *const windows_core::GUID, ppobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMPServer_Impl::CreateObjectByCLSID(this, core::mem::transmute_copy(&clsid), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppobject)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            LockProcess: LockProcess::<Identity, OFFSET>,
            UnlockProcess: UnlockProcess::<Identity, OFFSET>,
            CreateObjectByCLSID: CreateObjectByCLSID::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFPMPServer as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant", feature = "Win32_UI_Shell_PropertiesSystem"))]
pub trait IMFPMediaItem_Impl: Sized + windows_core::IUnknownImpl {
    fn GetMediaPlayer(&self) -> windows_core::Result<IMFPMediaPlayer>;
    fn GetURL(&self) -> windows_core::Result<windows_core::PWSTR>;
    fn GetObject(&self) -> windows_core::Result<windows_core::IUnknown>;
    fn GetUserData(&self) -> windows_core::Result<usize>;
    fn SetUserData(&self, dwuserdata: usize) -> windows_core::Result<()>;
    fn GetStartStopPosition(&self, pguidstartpositiontype: *mut windows_core::GUID, pvstartvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT, pguidstoppositiontype: *mut windows_core::GUID, pvstopvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> windows_core::Result<()>;
    fn SetStartStopPosition(&self, pguidstartpositiontype: *const windows_core::GUID, pvstartvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pguidstoppositiontype: *const windows_core::GUID, pvstopvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> windows_core::Result<()>;
    fn HasVideo(&self, pfhasvideo: *mut super::super::Foundation::BOOL, pfselected: *mut super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn HasAudio(&self, pfhasaudio: *mut super::super::Foundation::BOOL, pfselected: *mut super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn IsProtected(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn GetDuration(&self, guidpositiontype: *const windows_core::GUID) -> windows_core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
    fn GetNumberOfStreams(&self) -> windows_core::Result<u32>;
    fn GetStreamSelection(&self, dwstreamindex: u32) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn SetStreamSelection(&self, dwstreamindex: u32, fenabled: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn GetStreamAttribute(&self, dwstreamindex: u32, guidmfattribute: *const windows_core::GUID) -> windows_core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
    fn GetPresentationAttribute(&self, guidmfattribute: *const windows_core::GUID) -> windows_core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
    fn GetCharacteristics(&self) -> windows_core::Result<u32>;
    fn SetStreamSink(&self, dwstreamindex: u32, pmediasink: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn GetMetadata(&self) -> windows_core::Result<super::super::UI::Shell::PropertiesSystem::IPropertyStore>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant", feature = "Win32_UI_Shell_PropertiesSystem"))]
impl windows_core::RuntimeName for IMFPMediaItem {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant", feature = "Win32_UI_Shell_PropertiesSystem"))]
impl IMFPMediaItem_Vtbl {
    pub const fn new<Identity: IMFPMediaItem_Impl, const OFFSET: isize>() -> IMFPMediaItem_Vtbl {
        unsafe extern "system" fn GetMediaPlayer<Identity: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppmediaplayer: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaItem_Impl::GetMediaPlayer(this) {
                Ok(ok__) => {
                    ppmediaplayer.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetURL<Identity: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppwszurl: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaItem_Impl::GetURL(this) {
                Ok(ok__) => {
                    ppwszurl.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetObject<Identity: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppiunknown: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaItem_Impl::GetObject(this) {
                Ok(ok__) => {
                    ppiunknown.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetUserData<Identity: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwuserdata: *mut usize) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaItem_Impl::GetUserData(this) {
                Ok(ok__) => {
                    pdwuserdata.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUserData<Identity: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwuserdata: usize) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaItem_Impl::SetUserData(this, core::mem::transmute_copy(&dwuserdata)).into()
        }
        unsafe extern "system" fn GetStartStopPosition<Identity: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguidstartpositiontype: *mut windows_core::GUID, pvstartvalue: *mut core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>, pguidstoppositiontype: *mut windows_core::GUID, pvstopvalue: *mut core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaItem_Impl::GetStartStopPosition(this, core::mem::transmute_copy(&pguidstartpositiontype), core::mem::transmute_copy(&pvstartvalue), core::mem::transmute_copy(&pguidstoppositiontype), core::mem::transmute_copy(&pvstopvalue)).into()
        }
        unsafe extern "system" fn SetStartStopPosition<Identity: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguidstartpositiontype: *const windows_core::GUID, pvstartvalue: *const core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>, pguidstoppositiontype: *const windows_core::GUID, pvstopvalue: *const core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaItem_Impl::SetStartStopPosition(this, core::mem::transmute_copy(&pguidstartpositiontype), core::mem::transmute_copy(&pvstartvalue), core::mem::transmute_copy(&pguidstoppositiontype), core::mem::transmute_copy(&pvstopvalue)).into()
        }
        unsafe extern "system" fn HasVideo<Identity: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfhasvideo: *mut super::super::Foundation::BOOL, pfselected: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaItem_Impl::HasVideo(this, core::mem::transmute_copy(&pfhasvideo), core::mem::transmute_copy(&pfselected)).into()
        }
        unsafe extern "system" fn HasAudio<Identity: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfhasaudio: *mut super::super::Foundation::BOOL, pfselected: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaItem_Impl::HasAudio(this, core::mem::transmute_copy(&pfhasaudio), core::mem::transmute_copy(&pfselected)).into()
        }
        unsafe extern "system" fn IsProtected<Identity: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfprotected: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaItem_Impl::IsProtected(this) {
                Ok(ok__) => {
                    pfprotected.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDuration<Identity: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidpositiontype: *const windows_core::GUID, pvdurationvalue: *mut core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaItem_Impl::GetDuration(this, core::mem::transmute_copy(&guidpositiontype)) {
                Ok(ok__) => {
                    pvdurationvalue.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNumberOfStreams<Identity: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwstreamcount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaItem_Impl::GetNumberOfStreams(this) {
                Ok(ok__) => {
                    pdwstreamcount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamSelection<Identity: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, pfenabled: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaItem_Impl::GetStreamSelection(this, core::mem::transmute_copy(&dwstreamindex)) {
                Ok(ok__) => {
                    pfenabled.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamSelection<Identity: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, fenabled: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaItem_Impl::SetStreamSelection(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&fenabled)).into()
        }
        unsafe extern "system" fn GetStreamAttribute<Identity: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, guidmfattribute: *const windows_core::GUID, pvvalue: *mut core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaItem_Impl::GetStreamAttribute(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&guidmfattribute)) {
                Ok(ok__) => {
                    pvvalue.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPresentationAttribute<Identity: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidmfattribute: *const windows_core::GUID, pvvalue: *mut core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaItem_Impl::GetPresentationAttribute(this, core::mem::transmute_copy(&guidmfattribute)) {
                Ok(ok__) => {
                    pvvalue.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCharacteristics<Identity: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcharacteristics: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaItem_Impl::GetCharacteristics(this) {
                Ok(ok__) => {
                    pcharacteristics.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamSink<Identity: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, pmediasink: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaItem_Impl::SetStreamSink(this, core::mem::transmute_copy(&dwstreamindex), windows_core::from_raw_borrowed(&pmediasink)).into()
        }
        unsafe extern "system" fn GetMetadata<Identity: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppmetadatastore: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaItem_Impl::GetMetadata(this) {
                Ok(ok__) => {
                    ppmetadatastore.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetMediaPlayer: GetMediaPlayer::<Identity, OFFSET>,
            GetURL: GetURL::<Identity, OFFSET>,
            GetObject: GetObject::<Identity, OFFSET>,
            GetUserData: GetUserData::<Identity, OFFSET>,
            SetUserData: SetUserData::<Identity, OFFSET>,
            GetStartStopPosition: GetStartStopPosition::<Identity, OFFSET>,
            SetStartStopPosition: SetStartStopPosition::<Identity, OFFSET>,
            HasVideo: HasVideo::<Identity, OFFSET>,
            HasAudio: HasAudio::<Identity, OFFSET>,
            IsProtected: IsProtected::<Identity, OFFSET>,
            GetDuration: GetDuration::<Identity, OFFSET>,
            GetNumberOfStreams: GetNumberOfStreams::<Identity, OFFSET>,
            GetStreamSelection: GetStreamSelection::<Identity, OFFSET>,
            SetStreamSelection: SetStreamSelection::<Identity, OFFSET>,
            GetStreamAttribute: GetStreamAttribute::<Identity, OFFSET>,
            GetPresentationAttribute: GetPresentationAttribute::<Identity, OFFSET>,
            GetCharacteristics: GetCharacteristics::<Identity, OFFSET>,
            SetStreamSink: SetStreamSink::<Identity, OFFSET>,
            GetMetadata: GetMetadata::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFPMediaItem as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFPMediaPlayer_Impl: Sized + windows_core::IUnknownImpl {
    fn Play(&self) -> windows_core::Result<()>;
    fn Pause(&self) -> windows_core::Result<()>;
    fn Stop(&self) -> windows_core::Result<()>;
    fn FrameStep(&self) -> windows_core::Result<()>;
    fn SetPosition(&self, guidpositiontype: *const windows_core::GUID, pvpositionvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> windows_core::Result<()>;
    fn GetPosition(&self, guidpositiontype: *const windows_core::GUID) -> windows_core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
    fn GetDuration(&self, guidpositiontype: *const windows_core::GUID) -> windows_core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
    fn SetRate(&self, flrate: f32) -> windows_core::Result<()>;
    fn GetRate(&self) -> windows_core::Result<f32>;
    fn GetSupportedRates(&self, fforwarddirection: super::super::Foundation::BOOL, pflslowestrate: *mut f32, pflfastestrate: *mut f32) -> windows_core::Result<()>;
    fn GetState(&self) -> windows_core::Result<MFP_MEDIAPLAYER_STATE>;
    fn CreateMediaItemFromURL(&self, pwszurl: &windows_core::PCWSTR, fsync: super::super::Foundation::BOOL, dwuserdata: usize, ppmediaitem: *mut Option<IMFPMediaItem>) -> windows_core::Result<()>;
    fn CreateMediaItemFromObject(&self, piunknownobj: Option<&windows_core::IUnknown>, fsync: super::super::Foundation::BOOL, dwuserdata: usize, ppmediaitem: *mut Option<IMFPMediaItem>) -> windows_core::Result<()>;
    fn SetMediaItem(&self, pimfpmediaitem: Option<&IMFPMediaItem>) -> windows_core::Result<()>;
    fn ClearMediaItem(&self) -> windows_core::Result<()>;
    fn GetMediaItem(&self) -> windows_core::Result<IMFPMediaItem>;
    fn GetVolume(&self) -> windows_core::Result<f32>;
    fn SetVolume(&self, flvolume: f32) -> windows_core::Result<()>;
    fn GetBalance(&self) -> windows_core::Result<f32>;
    fn SetBalance(&self, flbalance: f32) -> windows_core::Result<()>;
    fn GetMute(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn SetMute(&self, fmute: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn GetNativeVideoSize(&self, pszvideo: *mut super::super::Foundation::SIZE, pszarvideo: *mut super::super::Foundation::SIZE) -> windows_core::Result<()>;
    fn GetIdealVideoSize(&self, pszmin: *mut super::super::Foundation::SIZE, pszmax: *mut super::super::Foundation::SIZE) -> windows_core::Result<()>;
    fn SetVideoSourceRect(&self, pnrcsource: *const MFVideoNormalizedRect) -> windows_core::Result<()>;
    fn GetVideoSourceRect(&self) -> windows_core::Result<MFVideoNormalizedRect>;
    fn SetAspectRatioMode(&self, dwaspectratiomode: u32) -> windows_core::Result<()>;
    fn GetAspectRatioMode(&self) -> windows_core::Result<u32>;
    fn GetVideoWindow(&self) -> windows_core::Result<super::super::Foundation::HWND>;
    fn UpdateVideo(&self) -> windows_core::Result<()>;
    fn SetBorderColor(&self, clr: super::super::Foundation::COLORREF) -> windows_core::Result<()>;
    fn GetBorderColor(&self) -> windows_core::Result<super::super::Foundation::COLORREF>;
    fn InsertEffect(&self, peffect: Option<&windows_core::IUnknown>, foptional: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn RemoveEffect(&self, peffect: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn RemoveAllEffects(&self) -> windows_core::Result<()>;
    fn Shutdown(&self) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFPMediaPlayer {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFPMediaPlayer_Vtbl {
    pub const fn new<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>() -> IMFPMediaPlayer_Vtbl {
        unsafe extern "system" fn Play<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::Play(this).into()
        }
        unsafe extern "system" fn Pause<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::Pause(this).into()
        }
        unsafe extern "system" fn Stop<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::Stop(this).into()
        }
        unsafe extern "system" fn FrameStep<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::FrameStep(this).into()
        }
        unsafe extern "system" fn SetPosition<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidpositiontype: *const windows_core::GUID, pvpositionvalue: *const core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::SetPosition(this, core::mem::transmute_copy(&guidpositiontype), core::mem::transmute_copy(&pvpositionvalue)).into()
        }
        unsafe extern "system" fn GetPosition<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidpositiontype: *const windows_core::GUID, pvpositionvalue: *mut core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaPlayer_Impl::GetPosition(this, core::mem::transmute_copy(&guidpositiontype)) {
                Ok(ok__) => {
                    pvpositionvalue.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDuration<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidpositiontype: *const windows_core::GUID, pvdurationvalue: *mut core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaPlayer_Impl::GetDuration(this, core::mem::transmute_copy(&guidpositiontype)) {
                Ok(ok__) => {
                    pvdurationvalue.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRate<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, flrate: f32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::SetRate(this, core::mem::transmute_copy(&flrate)).into()
        }
        unsafe extern "system" fn GetRate<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pflrate: *mut f32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaPlayer_Impl::GetRate(this) {
                Ok(ok__) => {
                    pflrate.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSupportedRates<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fforwarddirection: super::super::Foundation::BOOL, pflslowestrate: *mut f32, pflfastestrate: *mut f32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::GetSupportedRates(this, core::mem::transmute_copy(&fforwarddirection), core::mem::transmute_copy(&pflslowestrate), core::mem::transmute_copy(&pflfastestrate)).into()
        }
        unsafe extern "system" fn GetState<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pestate: *mut MFP_MEDIAPLAYER_STATE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaPlayer_Impl::GetState(this) {
                Ok(ok__) => {
                    pestate.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateMediaItemFromURL<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwszurl: windows_core::PCWSTR, fsync: super::super::Foundation::BOOL, dwuserdata: usize, ppmediaitem: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::CreateMediaItemFromURL(this, core::mem::transmute(&pwszurl), core::mem::transmute_copy(&fsync), core::mem::transmute_copy(&dwuserdata), core::mem::transmute_copy(&ppmediaitem)).into()
        }
        unsafe extern "system" fn CreateMediaItemFromObject<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, piunknownobj: *mut core::ffi::c_void, fsync: super::super::Foundation::BOOL, dwuserdata: usize, ppmediaitem: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::CreateMediaItemFromObject(this, windows_core::from_raw_borrowed(&piunknownobj), core::mem::transmute_copy(&fsync), core::mem::transmute_copy(&dwuserdata), core::mem::transmute_copy(&ppmediaitem)).into()
        }
        unsafe extern "system" fn SetMediaItem<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pimfpmediaitem: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::SetMediaItem(this, windows_core::from_raw_borrowed(&pimfpmediaitem)).into()
        }
        unsafe extern "system" fn ClearMediaItem<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::ClearMediaItem(this).into()
        }
        unsafe extern "system" fn GetMediaItem<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppimfpmediaitem: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaPlayer_Impl::GetMediaItem(this) {
                Ok(ok__) => {
                    ppimfpmediaitem.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVolume<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pflvolume: *mut f32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaPlayer_Impl::GetVolume(this) {
                Ok(ok__) => {
                    pflvolume.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVolume<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, flvolume: f32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::SetVolume(this, core::mem::transmute_copy(&flvolume)).into()
        }
        unsafe extern "system" fn GetBalance<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pflbalance: *mut f32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaPlayer_Impl::GetBalance(this) {
                Ok(ok__) => {
                    pflbalance.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBalance<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, flbalance: f32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::SetBalance(this, core::mem::transmute_copy(&flbalance)).into()
        }
        unsafe extern "system" fn GetMute<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfmute: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaPlayer_Impl::GetMute(this) {
                Ok(ok__) => {
                    pfmute.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMute<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fmute: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::SetMute(this, core::mem::transmute_copy(&fmute)).into()
        }
        unsafe extern "system" fn GetNativeVideoSize<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszvideo: *mut super::super::Foundation::SIZE, pszarvideo: *mut super::super::Foundation::SIZE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::GetNativeVideoSize(this, core::mem::transmute_copy(&pszvideo), core::mem::transmute_copy(&pszarvideo)).into()
        }
        unsafe extern "system" fn GetIdealVideoSize<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszmin: *mut super::super::Foundation::SIZE, pszmax: *mut super::super::Foundation::SIZE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::GetIdealVideoSize(this, core::mem::transmute_copy(&pszmin), core::mem::transmute_copy(&pszmax)).into()
        }
        unsafe extern "system" fn SetVideoSourceRect<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pnrcsource: *const MFVideoNormalizedRect) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::SetVideoSourceRect(this, core::mem::transmute_copy(&pnrcsource)).into()
        }
        unsafe extern "system" fn GetVideoSourceRect<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pnrcsource: *mut MFVideoNormalizedRect) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaPlayer_Impl::GetVideoSourceRect(this) {
                Ok(ok__) => {
                    pnrcsource.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAspectRatioMode<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwaspectratiomode: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::SetAspectRatioMode(this, core::mem::transmute_copy(&dwaspectratiomode)).into()
        }
        unsafe extern "system" fn GetAspectRatioMode<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwaspectratiomode: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaPlayer_Impl::GetAspectRatioMode(this) {
                Ok(ok__) => {
                    pdwaspectratiomode.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoWindow<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, phwndvideo: *mut super::super::Foundation::HWND) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaPlayer_Impl::GetVideoWindow(this) {
                Ok(ok__) => {
                    phwndvideo.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UpdateVideo<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::UpdateVideo(this).into()
        }
        unsafe extern "system" fn SetBorderColor<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clr: super::super::Foundation::COLORREF) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::SetBorderColor(this, core::mem::transmute_copy(&clr)).into()
        }
        unsafe extern "system" fn GetBorderColor<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pclr: *mut super::super::Foundation::COLORREF) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPMediaPlayer_Impl::GetBorderColor(this) {
                Ok(ok__) => {
                    pclr.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InsertEffect<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, peffect: *mut core::ffi::c_void, foptional: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::InsertEffect(this, windows_core::from_raw_borrowed(&peffect), core::mem::transmute_copy(&foptional)).into()
        }
        unsafe extern "system" fn RemoveEffect<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, peffect: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::RemoveEffect(this, windows_core::from_raw_borrowed(&peffect)).into()
        }
        unsafe extern "system" fn RemoveAllEffects<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::RemoveAllEffects(this).into()
        }
        unsafe extern "system" fn Shutdown<Identity: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayer_Impl::Shutdown(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Play: Play::<Identity, OFFSET>,
            Pause: Pause::<Identity, OFFSET>,
            Stop: Stop::<Identity, OFFSET>,
            FrameStep: FrameStep::<Identity, OFFSET>,
            SetPosition: SetPosition::<Identity, OFFSET>,
            GetPosition: GetPosition::<Identity, OFFSET>,
            GetDuration: GetDuration::<Identity, OFFSET>,
            SetRate: SetRate::<Identity, OFFSET>,
            GetRate: GetRate::<Identity, OFFSET>,
            GetSupportedRates: GetSupportedRates::<Identity, OFFSET>,
            GetState: GetState::<Identity, OFFSET>,
            CreateMediaItemFromURL: CreateMediaItemFromURL::<Identity, OFFSET>,
            CreateMediaItemFromObject: CreateMediaItemFromObject::<Identity, OFFSET>,
            SetMediaItem: SetMediaItem::<Identity, OFFSET>,
            ClearMediaItem: ClearMediaItem::<Identity, OFFSET>,
            GetMediaItem: GetMediaItem::<Identity, OFFSET>,
            GetVolume: GetVolume::<Identity, OFFSET>,
            SetVolume: SetVolume::<Identity, OFFSET>,
            GetBalance: GetBalance::<Identity, OFFSET>,
            SetBalance: SetBalance::<Identity, OFFSET>,
            GetMute: GetMute::<Identity, OFFSET>,
            SetMute: SetMute::<Identity, OFFSET>,
            GetNativeVideoSize: GetNativeVideoSize::<Identity, OFFSET>,
            GetIdealVideoSize: GetIdealVideoSize::<Identity, OFFSET>,
            SetVideoSourceRect: SetVideoSourceRect::<Identity, OFFSET>,
            GetVideoSourceRect: GetVideoSourceRect::<Identity, OFFSET>,
            SetAspectRatioMode: SetAspectRatioMode::<Identity, OFFSET>,
            GetAspectRatioMode: GetAspectRatioMode::<Identity, OFFSET>,
            GetVideoWindow: GetVideoWindow::<Identity, OFFSET>,
            UpdateVideo: UpdateVideo::<Identity, OFFSET>,
            SetBorderColor: SetBorderColor::<Identity, OFFSET>,
            GetBorderColor: GetBorderColor::<Identity, OFFSET>,
            InsertEffect: InsertEffect::<Identity, OFFSET>,
            RemoveEffect: RemoveEffect::<Identity, OFFSET>,
            RemoveAllEffects: RemoveAllEffects::<Identity, OFFSET>,
            Shutdown: Shutdown::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFPMediaPlayer as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub trait IMFPMediaPlayerCallback_Impl: Sized + windows_core::IUnknownImpl {
    fn OnMediaPlayerEvent(&self, peventheader: *const MFP_EVENT_HEADER);
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl windows_core::RuntimeName for IMFPMediaPlayerCallback {}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl IMFPMediaPlayerCallback_Vtbl {
    pub const fn new<Identity: IMFPMediaPlayerCallback_Impl, const OFFSET: isize>() -> IMFPMediaPlayerCallback_Vtbl {
        unsafe extern "system" fn OnMediaPlayerEvent<Identity: IMFPMediaPlayerCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, peventheader: *const MFP_EVENT_HEADER) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPMediaPlayerCallback_Impl::OnMediaPlayerEvent(this, core::mem::transmute_copy(&peventheader))
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), OnMediaPlayerEvent: OnMediaPlayerEvent::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFPMediaPlayerCallback as windows_core::Interface>::IID
    }
}
pub trait IMFPluginControl_Impl: Sized + windows_core::IUnknownImpl {
    fn GetPreferredClsid(&self, plugintype: u32, selector: &windows_core::PCWSTR) -> windows_core::Result<windows_core::GUID>;
    fn GetPreferredClsidByIndex(&self, plugintype: u32, index: u32, selector: *mut windows_core::PWSTR, clsid: *mut windows_core::GUID) -> windows_core::Result<()>;
    fn SetPreferredClsid(&self, plugintype: u32, selector: &windows_core::PCWSTR, clsid: *const windows_core::GUID) -> windows_core::Result<()>;
    fn IsDisabled(&self, plugintype: u32, clsid: *const windows_core::GUID) -> windows_core::Result<()>;
    fn GetDisabledByIndex(&self, plugintype: u32, index: u32) -> windows_core::Result<windows_core::GUID>;
    fn SetDisabled(&self, plugintype: u32, clsid: *const windows_core::GUID, disabled: super::super::Foundation::BOOL) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFPluginControl {}
impl IMFPluginControl_Vtbl {
    pub const fn new<Identity: IMFPluginControl_Impl, const OFFSET: isize>() -> IMFPluginControl_Vtbl {
        unsafe extern "system" fn GetPreferredClsid<Identity: IMFPluginControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plugintype: u32, selector: windows_core::PCWSTR, clsid: *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPluginControl_Impl::GetPreferredClsid(this, core::mem::transmute_copy(&plugintype), core::mem::transmute(&selector)) {
                Ok(ok__) => {
                    clsid.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPreferredClsidByIndex<Identity: IMFPluginControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plugintype: u32, index: u32, selector: *mut windows_core::PWSTR, clsid: *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPluginControl_Impl::GetPreferredClsidByIndex(this, core::mem::transmute_copy(&plugintype), core::mem::transmute_copy(&index), core::mem::transmute_copy(&selector), core::mem::transmute_copy(&clsid)).into()
        }
        unsafe extern "system" fn SetPreferredClsid<Identity: IMFPluginControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plugintype: u32, selector: windows_core::PCWSTR, clsid: *const windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPluginControl_Impl::SetPreferredClsid(this, core::mem::transmute_copy(&plugintype), core::mem::transmute(&selector), core::mem::transmute_copy(&clsid)).into()
        }
        unsafe extern "system" fn IsDisabled<Identity: IMFPluginControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plugintype: u32, clsid: *const windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPluginControl_Impl::IsDisabled(this, core::mem::transmute_copy(&plugintype), core::mem::transmute_copy(&clsid)).into()
        }
        unsafe extern "system" fn GetDisabledByIndex<Identity: IMFPluginControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plugintype: u32, index: u32, clsid: *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPluginControl_Impl::GetDisabledByIndex(this, core::mem::transmute_copy(&plugintype), core::mem::transmute_copy(&index)) {
                Ok(ok__) => {
                    clsid.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisabled<Identity: IMFPluginControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plugintype: u32, clsid: *const windows_core::GUID, disabled: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPluginControl_Impl::SetDisabled(this, core::mem::transmute_copy(&plugintype), core::mem::transmute_copy(&clsid), core::mem::transmute_copy(&disabled)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetPreferredClsid: GetPreferredClsid::<Identity, OFFSET>,
            GetPreferredClsidByIndex: GetPreferredClsidByIndex::<Identity, OFFSET>,
            SetPreferredClsid: SetPreferredClsid::<Identity, OFFSET>,
            IsDisabled: IsDisabled::<Identity, OFFSET>,
            GetDisabledByIndex: GetDisabledByIndex::<Identity, OFFSET>,
            SetDisabled: SetDisabled::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFPluginControl as windows_core::Interface>::IID
    }
}
pub trait IMFPluginControl2_Impl: Sized + IMFPluginControl_Impl {
    fn SetPolicy(&self, policy: MF_PLUGIN_CONTROL_POLICY) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFPluginControl2 {}
impl IMFPluginControl2_Vtbl {
    pub const fn new<Identity: IMFPluginControl2_Impl, const OFFSET: isize>() -> IMFPluginControl2_Vtbl {
        unsafe extern "system" fn SetPolicy<Identity: IMFPluginControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, policy: MF_PLUGIN_CONTROL_POLICY) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPluginControl2_Impl::SetPolicy(this, core::mem::transmute_copy(&policy)).into()
        }
        Self { base__: IMFPluginControl_Vtbl::new::<Identity, OFFSET>(), SetPolicy: SetPolicy::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFPluginControl2 as windows_core::Interface>::IID || iid == &<IMFPluginControl as windows_core::Interface>::IID
    }
}
pub trait IMFPresentationClock_Impl: Sized + IMFClock_Impl {
    fn SetTimeSource(&self, ptimesource: Option<&IMFPresentationTimeSource>) -> windows_core::Result<()>;
    fn GetTimeSource(&self) -> windows_core::Result<IMFPresentationTimeSource>;
    fn GetTime(&self) -> windows_core::Result<i64>;
    fn AddClockStateSink(&self, pstatesink: Option<&IMFClockStateSink>) -> windows_core::Result<()>;
    fn RemoveClockStateSink(&self, pstatesink: Option<&IMFClockStateSink>) -> windows_core::Result<()>;
    fn Start(&self, llclockstartoffset: i64) -> windows_core::Result<()>;
    fn Stop(&self) -> windows_core::Result<()>;
    fn Pause(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFPresentationClock {}
impl IMFPresentationClock_Vtbl {
    pub const fn new<Identity: IMFPresentationClock_Impl, const OFFSET: isize>() -> IMFPresentationClock_Vtbl {
        unsafe extern "system" fn SetTimeSource<Identity: IMFPresentationClock_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptimesource: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPresentationClock_Impl::SetTimeSource(this, windows_core::from_raw_borrowed(&ptimesource)).into()
        }
        unsafe extern "system" fn GetTimeSource<Identity: IMFPresentationClock_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pptimesource: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPresentationClock_Impl::GetTimeSource(this) {
                Ok(ok__) => {
                    pptimesource.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTime<Identity: IMFPresentationClock_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, phnsclocktime: *mut i64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPresentationClock_Impl::GetTime(this) {
                Ok(ok__) => {
                    phnsclocktime.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddClockStateSink<Identity: IMFPresentationClock_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstatesink: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPresentationClock_Impl::AddClockStateSink(this, windows_core::from_raw_borrowed(&pstatesink)).into()
        }
        unsafe extern "system" fn RemoveClockStateSink<Identity: IMFPresentationClock_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstatesink: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPresentationClock_Impl::RemoveClockStateSink(this, windows_core::from_raw_borrowed(&pstatesink)).into()
        }
        unsafe extern "system" fn Start<Identity: IMFPresentationClock_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, llclockstartoffset: i64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPresentationClock_Impl::Start(this, core::mem::transmute_copy(&llclockstartoffset)).into()
        }
        unsafe extern "system" fn Stop<Identity: IMFPresentationClock_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPresentationClock_Impl::Stop(this).into()
        }
        unsafe extern "system" fn Pause<Identity: IMFPresentationClock_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPresentationClock_Impl::Pause(this).into()
        }
        Self {
            base__: IMFClock_Vtbl::new::<Identity, OFFSET>(),
            SetTimeSource: SetTimeSource::<Identity, OFFSET>,
            GetTimeSource: GetTimeSource::<Identity, OFFSET>,
            GetTime: GetTime::<Identity, OFFSET>,
            AddClockStateSink: AddClockStateSink::<Identity, OFFSET>,
            RemoveClockStateSink: RemoveClockStateSink::<Identity, OFFSET>,
            Start: Start::<Identity, OFFSET>,
            Stop: Stop::<Identity, OFFSET>,
            Pause: Pause::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFPresentationClock as windows_core::Interface>::IID || iid == &<IMFClock as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFPresentationDescriptor_Impl: Sized + IMFAttributes_Impl {
    fn GetStreamDescriptorCount(&self) -> windows_core::Result<u32>;
    fn GetStreamDescriptorByIndex(&self, dwindex: u32, pfselected: *mut super::super::Foundation::BOOL, ppdescriptor: *mut Option<IMFStreamDescriptor>) -> windows_core::Result<()>;
    fn SelectStream(&self, dwdescriptorindex: u32) -> windows_core::Result<()>;
    fn DeselectStream(&self, dwdescriptorindex: u32) -> windows_core::Result<()>;
    fn Clone(&self) -> windows_core::Result<IMFPresentationDescriptor>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFPresentationDescriptor {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFPresentationDescriptor_Vtbl {
    pub const fn new<Identity: IMFPresentationDescriptor_Impl, const OFFSET: isize>() -> IMFPresentationDescriptor_Vtbl {
        unsafe extern "system" fn GetStreamDescriptorCount<Identity: IMFPresentationDescriptor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwdescriptorcount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPresentationDescriptor_Impl::GetStreamDescriptorCount(this) {
                Ok(ok__) => {
                    pdwdescriptorcount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamDescriptorByIndex<Identity: IMFPresentationDescriptor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwindex: u32, pfselected: *mut super::super::Foundation::BOOL, ppdescriptor: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPresentationDescriptor_Impl::GetStreamDescriptorByIndex(this, core::mem::transmute_copy(&dwindex), core::mem::transmute_copy(&pfselected), core::mem::transmute_copy(&ppdescriptor)).into()
        }
        unsafe extern "system" fn SelectStream<Identity: IMFPresentationDescriptor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwdescriptorindex: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPresentationDescriptor_Impl::SelectStream(this, core::mem::transmute_copy(&dwdescriptorindex)).into()
        }
        unsafe extern "system" fn DeselectStream<Identity: IMFPresentationDescriptor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwdescriptorindex: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFPresentationDescriptor_Impl::DeselectStream(this, core::mem::transmute_copy(&dwdescriptorindex)).into()
        }
        unsafe extern "system" fn Clone<Identity: IMFPresentationDescriptor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pppresentationdescriptor: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPresentationDescriptor_Impl::Clone(this) {
                Ok(ok__) => {
                    pppresentationdescriptor.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IMFAttributes_Vtbl::new::<Identity, OFFSET>(),
            GetStreamDescriptorCount: GetStreamDescriptorCount::<Identity, OFFSET>,
            GetStreamDescriptorByIndex: GetStreamDescriptorByIndex::<Identity, OFFSET>,
            SelectStream: SelectStream::<Identity, OFFSET>,
            DeselectStream: DeselectStream::<Identity, OFFSET>,
            Clone: Clone::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFPresentationDescriptor as windows_core::Interface>::IID || iid == &<IMFAttributes as windows_core::Interface>::IID
    }
}
pub trait IMFPresentationTimeSource_Impl: Sized + IMFClock_Impl {
    fn GetUnderlyingClock(&self) -> windows_core::Result<IMFClock>;
}
impl windows_core::RuntimeName for IMFPresentationTimeSource {}
impl IMFPresentationTimeSource_Vtbl {
    pub const fn new<Identity: IMFPresentationTimeSource_Impl, const OFFSET: isize>() -> IMFPresentationTimeSource_Vtbl {
        unsafe extern "system" fn GetUnderlyingClock<Identity: IMFPresentationTimeSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppclock: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFPresentationTimeSource_Impl::GetUnderlyingClock(this) {
                Ok(ok__) => {
                    ppclock.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: IMFClock_Vtbl::new::<Identity, OFFSET>(), GetUnderlyingClock: GetUnderlyingClock::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFPresentationTimeSource as windows_core::Interface>::IID || iid == &<IMFClock as windows_core::Interface>::IID
    }
}
pub trait IMFProtectedEnvironmentAccess_Impl: Sized + windows_core::IUnknownImpl {
    fn Call(&self, inputlength: u32, input: *const u8, outputlength: u32, output: *mut u8) -> windows_core::Result<()>;
    fn ReadGRL(&self, outputlength: *mut u32, output: *mut *mut u8) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFProtectedEnvironmentAccess {}
impl IMFProtectedEnvironmentAccess_Vtbl {
    pub const fn new<Identity: IMFProtectedEnvironmentAccess_Impl, const OFFSET: isize>() -> IMFProtectedEnvironmentAccess_Vtbl {
        unsafe extern "system" fn Call<Identity: IMFProtectedEnvironmentAccess_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, inputlength: u32, input: *const u8, outputlength: u32, output: *mut u8) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFProtectedEnvironmentAccess_Impl::Call(this, core::mem::transmute_copy(&inputlength), core::mem::transmute_copy(&input), core::mem::transmute_copy(&outputlength), core::mem::transmute_copy(&output)).into()
        }
        unsafe extern "system" fn ReadGRL<Identity: IMFProtectedEnvironmentAccess_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, outputlength: *mut u32, output: *mut *mut u8) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFProtectedEnvironmentAccess_Impl::ReadGRL(this, core::mem::transmute_copy(&outputlength), core::mem::transmute_copy(&output)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Call: Call::<Identity, OFFSET>, ReadGRL: ReadGRL::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFProtectedEnvironmentAccess as windows_core::Interface>::IID
    }
}
pub trait IMFQualityAdvise_Impl: Sized + windows_core::IUnknownImpl {
    fn SetDropMode(&self, edropmode: MF_QUALITY_DROP_MODE) -> windows_core::Result<()>;
    fn SetQualityLevel(&self, equalitylevel: MF_QUALITY_LEVEL) -> windows_core::Result<()>;
    fn GetDropMode(&self) -> windows_core::Result<MF_QUALITY_DROP_MODE>;
    fn GetQualityLevel(&self) -> windows_core::Result<MF_QUALITY_LEVEL>;
    fn DropTime(&self, hnsamounttodrop: i64) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFQualityAdvise {}
impl IMFQualityAdvise_Vtbl {
    pub const fn new<Identity: IMFQualityAdvise_Impl, const OFFSET: isize>() -> IMFQualityAdvise_Vtbl {
        unsafe extern "system" fn SetDropMode<Identity: IMFQualityAdvise_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, edropmode: MF_QUALITY_DROP_MODE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFQualityAdvise_Impl::SetDropMode(this, core::mem::transmute_copy(&edropmode)).into()
        }
        unsafe extern "system" fn SetQualityLevel<Identity: IMFQualityAdvise_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, equalitylevel: MF_QUALITY_LEVEL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFQualityAdvise_Impl::SetQualityLevel(this, core::mem::transmute_copy(&equalitylevel)).into()
        }
        unsafe extern "system" fn GetDropMode<Identity: IMFQualityAdvise_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pedropmode: *mut MF_QUALITY_DROP_MODE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFQualityAdvise_Impl::GetDropMode(this) {
                Ok(ok__) => {
                    pedropmode.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetQualityLevel<Identity: IMFQualityAdvise_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pequalitylevel: *mut MF_QUALITY_LEVEL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFQualityAdvise_Impl::GetQualityLevel(this) {
                Ok(ok__) => {
                    pequalitylevel.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DropTime<Identity: IMFQualityAdvise_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hnsamounttodrop: i64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFQualityAdvise_Impl::DropTime(this, core::mem::transmute_copy(&hnsamounttodrop)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetDropMode: SetDropMode::<Identity, OFFSET>,
            SetQualityLevel: SetQualityLevel::<Identity, OFFSET>,
            GetDropMode: GetDropMode::<Identity, OFFSET>,
            GetQualityLevel: GetQualityLevel::<Identity, OFFSET>,
            DropTime: DropTime::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFQualityAdvise as windows_core::Interface>::IID
    }
}
pub trait IMFQualityAdvise2_Impl: Sized + IMFQualityAdvise_Impl {
    fn NotifyQualityEvent(&self, pevent: Option<&IMFMediaEvent>) -> windows_core::Result<u32>;
}
impl windows_core::RuntimeName for IMFQualityAdvise2 {}
impl IMFQualityAdvise2_Vtbl {
    pub const fn new<Identity: IMFQualityAdvise2_Impl, const OFFSET: isize>() -> IMFQualityAdvise2_Vtbl {
        unsafe extern "system" fn NotifyQualityEvent<Identity: IMFQualityAdvise2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pevent: *mut core::ffi::c_void, pdwflags: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFQualityAdvise2_Impl::NotifyQualityEvent(this, windows_core::from_raw_borrowed(&pevent)) {
                Ok(ok__) => {
                    pdwflags.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: IMFQualityAdvise_Vtbl::new::<Identity, OFFSET>(), NotifyQualityEvent: NotifyQualityEvent::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFQualityAdvise2 as windows_core::Interface>::IID || iid == &<IMFQualityAdvise as windows_core::Interface>::IID
    }
}
pub trait IMFQualityAdviseLimits_Impl: Sized + windows_core::IUnknownImpl {
    fn GetMaximumDropMode(&self) -> windows_core::Result<MF_QUALITY_DROP_MODE>;
    fn GetMinimumQualityLevel(&self) -> windows_core::Result<MF_QUALITY_LEVEL>;
}
impl windows_core::RuntimeName for IMFQualityAdviseLimits {}
impl IMFQualityAdviseLimits_Vtbl {
    pub const fn new<Identity: IMFQualityAdviseLimits_Impl, const OFFSET: isize>() -> IMFQualityAdviseLimits_Vtbl {
        unsafe extern "system" fn GetMaximumDropMode<Identity: IMFQualityAdviseLimits_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pedropmode: *mut MF_QUALITY_DROP_MODE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFQualityAdviseLimits_Impl::GetMaximumDropMode(this) {
                Ok(ok__) => {
                    pedropmode.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMinimumQualityLevel<Identity: IMFQualityAdviseLimits_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pequalitylevel: *mut MF_QUALITY_LEVEL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFQualityAdviseLimits_Impl::GetMinimumQualityLevel(this) {
                Ok(ok__) => {
                    pequalitylevel.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetMaximumDropMode: GetMaximumDropMode::<Identity, OFFSET>,
            GetMinimumQualityLevel: GetMinimumQualityLevel::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFQualityAdviseLimits as windows_core::Interface>::IID
    }
}
pub trait IMFQualityManager_Impl: Sized + windows_core::IUnknownImpl {
    fn NotifyTopology(&self, ptopology: Option<&IMFTopology>) -> windows_core::Result<()>;
    fn NotifyPresentationClock(&self, pclock: Option<&IMFPresentationClock>) -> windows_core::Result<()>;
    fn NotifyProcessInput(&self, pnode: Option<&IMFTopologyNode>, linputindex: i32, psample: Option<&IMFSample>) -> windows_core::Result<()>;
    fn NotifyProcessOutput(&self, pnode: Option<&IMFTopologyNode>, loutputindex: i32, psample: Option<&IMFSample>) -> windows_core::Result<()>;
    fn NotifyQualityEvent(&self, pobject: Option<&windows_core::IUnknown>, pevent: Option<&IMFMediaEvent>) -> windows_core::Result<()>;
    fn Shutdown(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFQualityManager {}
impl IMFQualityManager_Vtbl {
    pub const fn new<Identity: IMFQualityManager_Impl, const OFFSET: isize>() -> IMFQualityManager_Vtbl {
        unsafe extern "system" fn NotifyTopology<Identity: IMFQualityManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptopology: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFQualityManager_Impl::NotifyTopology(this, windows_core::from_raw_borrowed(&ptopology)).into()
        }
        unsafe extern "system" fn NotifyPresentationClock<Identity: IMFQualityManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pclock: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFQualityManager_Impl::NotifyPresentationClock(this, windows_core::from_raw_borrowed(&pclock)).into()
        }
        unsafe extern "system" fn NotifyProcessInput<Identity: IMFQualityManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pnode: *mut core::ffi::c_void, linputindex: i32, psample: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFQualityManager_Impl::NotifyProcessInput(this, windows_core::from_raw_borrowed(&pnode), core::mem::transmute_copy(&linputindex), windows_core::from_raw_borrowed(&psample)).into()
        }
        unsafe extern "system" fn NotifyProcessOutput<Identity: IMFQualityManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pnode: *mut core::ffi::c_void, loutputindex: i32, psample: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFQualityManager_Impl::NotifyProcessOutput(this, windows_core::from_raw_borrowed(&pnode), core::mem::transmute_copy(&loutputindex), windows_core::from_raw_borrowed(&psample)).into()
        }
        unsafe extern "system" fn NotifyQualityEvent<Identity: IMFQualityManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pobject: *mut core::ffi::c_void, pevent: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFQualityManager_Impl::NotifyQualityEvent(this, windows_core::from_raw_borrowed(&pobject), windows_core::from_raw_borrowed(&pevent)).into()
        }
        unsafe extern "system" fn Shutdown<Identity: IMFQualityManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFQualityManager_Impl::Shutdown(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            NotifyTopology: NotifyTopology::<Identity, OFFSET>,
            NotifyPresentationClock: NotifyPresentationClock::<Identity, OFFSET>,
            NotifyProcessInput: NotifyProcessInput::<Identity, OFFSET>,
            NotifyProcessOutput: NotifyProcessOutput::<Identity, OFFSET>,
            NotifyQualityEvent: NotifyQualityEvent::<Identity, OFFSET>,
            Shutdown: Shutdown::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFQualityManager as windows_core::Interface>::IID
    }
}
pub trait IMFRateControl_Impl: Sized + windows_core::IUnknownImpl {
    fn SetRate(&self, fthin: super::super::Foundation::BOOL, flrate: f32) -> windows_core::Result<()>;
    fn GetRate(&self, pfthin: *mut super::super::Foundation::BOOL, pflrate: *mut f32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFRateControl {}
impl IMFRateControl_Vtbl {
    pub const fn new<Identity: IMFRateControl_Impl, const OFFSET: isize>() -> IMFRateControl_Vtbl {
        unsafe extern "system" fn SetRate<Identity: IMFRateControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fthin: super::super::Foundation::BOOL, flrate: f32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFRateControl_Impl::SetRate(this, core::mem::transmute_copy(&fthin), core::mem::transmute_copy(&flrate)).into()
        }
        unsafe extern "system" fn GetRate<Identity: IMFRateControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfthin: *mut super::super::Foundation::BOOL, pflrate: *mut f32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFRateControl_Impl::GetRate(this, core::mem::transmute_copy(&pfthin), core::mem::transmute_copy(&pflrate)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), SetRate: SetRate::<Identity, OFFSET>, GetRate: GetRate::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFRateControl as windows_core::Interface>::IID
    }
}
pub trait IMFRateSupport_Impl: Sized + windows_core::IUnknownImpl {
    fn GetSlowestRate(&self, edirection: MFRATE_DIRECTION, fthin: super::super::Foundation::BOOL) -> windows_core::Result<f32>;
    fn GetFastestRate(&self, edirection: MFRATE_DIRECTION, fthin: super::super::Foundation::BOOL) -> windows_core::Result<f32>;
    fn IsRateSupported(&self, fthin: super::super::Foundation::BOOL, flrate: f32, pflnearestsupportedrate: *mut f32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFRateSupport {}
impl IMFRateSupport_Vtbl {
    pub const fn new<Identity: IMFRateSupport_Impl, const OFFSET: isize>() -> IMFRateSupport_Vtbl {
        unsafe extern "system" fn GetSlowestRate<Identity: IMFRateSupport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, edirection: MFRATE_DIRECTION, fthin: super::super::Foundation::BOOL, pflrate: *mut f32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFRateSupport_Impl::GetSlowestRate(this, core::mem::transmute_copy(&edirection), core::mem::transmute_copy(&fthin)) {
                Ok(ok__) => {
                    pflrate.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFastestRate<Identity: IMFRateSupport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, edirection: MFRATE_DIRECTION, fthin: super::super::Foundation::BOOL, pflrate: *mut f32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFRateSupport_Impl::GetFastestRate(this, core::mem::transmute_copy(&edirection), core::mem::transmute_copy(&fthin)) {
                Ok(ok__) => {
                    pflrate.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsRateSupported<Identity: IMFRateSupport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fthin: super::super::Foundation::BOOL, flrate: f32, pflnearestsupportedrate: *mut f32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFRateSupport_Impl::IsRateSupported(this, core::mem::transmute_copy(&fthin), core::mem::transmute_copy(&flrate), core::mem::transmute_copy(&pflnearestsupportedrate)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetSlowestRate: GetSlowestRate::<Identity, OFFSET>,
            GetFastestRate: GetFastestRate::<Identity, OFFSET>,
            IsRateSupported: IsRateSupported::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFRateSupport as windows_core::Interface>::IID
    }
}
pub trait IMFReadWriteClassFactory_Impl: Sized + windows_core::IUnknownImpl {
    fn CreateInstanceFromURL(&self, clsid: *const windows_core::GUID, pwszurl: &windows_core::PCWSTR, pattributes: Option<&IMFAttributes>, riid: *const windows_core::GUID, ppvobject: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn CreateInstanceFromObject(&self, clsid: *const windows_core::GUID, punkobject: Option<&windows_core::IUnknown>, pattributes: Option<&IMFAttributes>, riid: *const windows_core::GUID, ppvobject: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFReadWriteClassFactory {}
impl IMFReadWriteClassFactory_Vtbl {
    pub const fn new<Identity: IMFReadWriteClassFactory_Impl, const OFFSET: isize>() -> IMFReadWriteClassFactory_Vtbl {
        unsafe extern "system" fn CreateInstanceFromURL<Identity: IMFReadWriteClassFactory_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clsid: *const windows_core::GUID, pwszurl: windows_core::PCWSTR, pattributes: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppvobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFReadWriteClassFactory_Impl::CreateInstanceFromURL(this, core::mem::transmute_copy(&clsid), core::mem::transmute(&pwszurl), windows_core::from_raw_borrowed(&pattributes), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvobject)).into()
        }
        unsafe extern "system" fn CreateInstanceFromObject<Identity: IMFReadWriteClassFactory_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clsid: *const windows_core::GUID, punkobject: *mut core::ffi::c_void, pattributes: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppvobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFReadWriteClassFactory_Impl::CreateInstanceFromObject(this, core::mem::transmute_copy(&clsid), windows_core::from_raw_borrowed(&punkobject), windows_core::from_raw_borrowed(&pattributes), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvobject)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            CreateInstanceFromURL: CreateInstanceFromURL::<Identity, OFFSET>,
            CreateInstanceFromObject: CreateInstanceFromObject::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFReadWriteClassFactory as windows_core::Interface>::IID
    }
}
pub trait IMFRealTimeClient_Impl: Sized + windows_core::IUnknownImpl {
    fn RegisterThreads(&self, dwtaskindex: u32, wszclass: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn UnregisterThreads(&self) -> windows_core::Result<()>;
    fn SetWorkQueue(&self, dwworkqueueid: u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFRealTimeClient {}
impl IMFRealTimeClient_Vtbl {
    pub const fn new<Identity: IMFRealTimeClient_Impl, const OFFSET: isize>() -> IMFRealTimeClient_Vtbl {
        unsafe extern "system" fn RegisterThreads<Identity: IMFRealTimeClient_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwtaskindex: u32, wszclass: windows_core::PCWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFRealTimeClient_Impl::RegisterThreads(this, core::mem::transmute_copy(&dwtaskindex), core::mem::transmute(&wszclass)).into()
        }
        unsafe extern "system" fn UnregisterThreads<Identity: IMFRealTimeClient_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFRealTimeClient_Impl::UnregisterThreads(this).into()
        }
        unsafe extern "system" fn SetWorkQueue<Identity: IMFRealTimeClient_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwworkqueueid: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFRealTimeClient_Impl::SetWorkQueue(this, core::mem::transmute_copy(&dwworkqueueid)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            RegisterThreads: RegisterThreads::<Identity, OFFSET>,
            UnregisterThreads: UnregisterThreads::<Identity, OFFSET>,
            SetWorkQueue: SetWorkQueue::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFRealTimeClient as windows_core::Interface>::IID
    }
}
pub trait IMFRealTimeClientEx_Impl: Sized + windows_core::IUnknownImpl {
    fn RegisterThreadsEx(&self, pdwtaskindex: *mut u32, wszclassname: &windows_core::PCWSTR, lbasepriority: i32) -> windows_core::Result<()>;
    fn UnregisterThreads(&self) -> windows_core::Result<()>;
    fn SetWorkQueueEx(&self, dwmultithreadedworkqueueid: u32, lworkitembasepriority: i32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFRealTimeClientEx {}
impl IMFRealTimeClientEx_Vtbl {
    pub const fn new<Identity: IMFRealTimeClientEx_Impl, const OFFSET: isize>() -> IMFRealTimeClientEx_Vtbl {
        unsafe extern "system" fn RegisterThreadsEx<Identity: IMFRealTimeClientEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwtaskindex: *mut u32, wszclassname: windows_core::PCWSTR, lbasepriority: i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFRealTimeClientEx_Impl::RegisterThreadsEx(this, core::mem::transmute_copy(&pdwtaskindex), core::mem::transmute(&wszclassname), core::mem::transmute_copy(&lbasepriority)).into()
        }
        unsafe extern "system" fn UnregisterThreads<Identity: IMFRealTimeClientEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFRealTimeClientEx_Impl::UnregisterThreads(this).into()
        }
        unsafe extern "system" fn SetWorkQueueEx<Identity: IMFRealTimeClientEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwmultithreadedworkqueueid: u32, lworkitembasepriority: i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFRealTimeClientEx_Impl::SetWorkQueueEx(this, core::mem::transmute_copy(&dwmultithreadedworkqueueid), core::mem::transmute_copy(&lworkitembasepriority)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            RegisterThreadsEx: RegisterThreadsEx::<Identity, OFFSET>,
            UnregisterThreads: UnregisterThreads::<Identity, OFFSET>,
            SetWorkQueueEx: SetWorkQueueEx::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFRealTimeClientEx as windows_core::Interface>::IID
    }
}
pub trait IMFRelativePanelReport_Impl: Sized + windows_core::IUnknownImpl {
    fn GetRelativePanel(&self) -> windows_core::Result<u32>;
}
impl windows_core::RuntimeName for IMFRelativePanelReport {}
impl IMFRelativePanelReport_Vtbl {
    pub const fn new<Identity: IMFRelativePanelReport_Impl, const OFFSET: isize>() -> IMFRelativePanelReport_Vtbl {
        unsafe extern "system" fn GetRelativePanel<Identity: IMFRelativePanelReport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, panel: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFRelativePanelReport_Impl::GetRelativePanel(this) {
                Ok(ok__) => {
                    panel.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetRelativePanel: GetRelativePanel::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFRelativePanelReport as windows_core::Interface>::IID
    }
}
pub trait IMFRelativePanelWatcher_Impl: Sized + IMFShutdown_Impl {
    fn BeginGetReport(&self, pcallback: Option<&IMFAsyncCallback>, pstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndGetReport(&self, presult: Option<&IMFAsyncResult>) -> windows_core::Result<IMFRelativePanelReport>;
    fn GetReport(&self) -> windows_core::Result<IMFRelativePanelReport>;
}
impl windows_core::RuntimeName for IMFRelativePanelWatcher {}
impl IMFRelativePanelWatcher_Vtbl {
    pub const fn new<Identity: IMFRelativePanelWatcher_Impl, const OFFSET: isize>() -> IMFRelativePanelWatcher_Vtbl {
        unsafe extern "system" fn BeginGetReport<Identity: IMFRelativePanelWatcher_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcallback: *mut core::ffi::c_void, pstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFRelativePanelWatcher_Impl::BeginGetReport(this, windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&pstate)).into()
        }
        unsafe extern "system" fn EndGetReport<Identity: IMFRelativePanelWatcher_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void, pprelativepanelreport: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFRelativePanelWatcher_Impl::EndGetReport(this, windows_core::from_raw_borrowed(&presult)) {
                Ok(ok__) => {
                    pprelativepanelreport.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetReport<Identity: IMFRelativePanelWatcher_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pprelativepanelreport: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFRelativePanelWatcher_Impl::GetReport(this) {
                Ok(ok__) => {
                    pprelativepanelreport.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IMFShutdown_Vtbl::new::<Identity, OFFSET>(),
            BeginGetReport: BeginGetReport::<Identity, OFFSET>,
            EndGetReport: EndGetReport::<Identity, OFFSET>,
            GetReport: GetReport::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFRelativePanelWatcher as windows_core::Interface>::IID || iid == &<IMFShutdown as windows_core::Interface>::IID
    }
}
pub trait IMFRemoteAsyncCallback_Impl: Sized + windows_core::IUnknownImpl {
    fn Invoke(&self, hr: windows_core::HRESULT, premoteresult: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFRemoteAsyncCallback {}
impl IMFRemoteAsyncCallback_Vtbl {
    pub const fn new<Identity: IMFRemoteAsyncCallback_Impl, const OFFSET: isize>() -> IMFRemoteAsyncCallback_Vtbl {
        unsafe extern "system" fn Invoke<Identity: IMFRemoteAsyncCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hr: windows_core::HRESULT, premoteresult: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFRemoteAsyncCallback_Impl::Invoke(this, core::mem::transmute_copy(&hr), windows_core::from_raw_borrowed(&premoteresult)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Invoke: Invoke::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFRemoteAsyncCallback as windows_core::Interface>::IID
    }
}
pub trait IMFRemoteDesktopPlugin_Impl: Sized + windows_core::IUnknownImpl {
    fn UpdateTopology(&self, ptopology: Option<&IMFTopology>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFRemoteDesktopPlugin {}
impl IMFRemoteDesktopPlugin_Vtbl {
    pub const fn new<Identity: IMFRemoteDesktopPlugin_Impl, const OFFSET: isize>() -> IMFRemoteDesktopPlugin_Vtbl {
        unsafe extern "system" fn UpdateTopology<Identity: IMFRemoteDesktopPlugin_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptopology: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFRemoteDesktopPlugin_Impl::UpdateTopology(this, windows_core::from_raw_borrowed(&ptopology)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), UpdateTopology: UpdateTopology::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFRemoteDesktopPlugin as windows_core::Interface>::IID
    }
}
pub trait IMFRemoteProxy_Impl: Sized + windows_core::IUnknownImpl {
    fn GetRemoteObject(&self, riid: *const windows_core::GUID, ppv: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn GetRemoteHost(&self, riid: *const windows_core::GUID, ppv: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFRemoteProxy {}
impl IMFRemoteProxy_Vtbl {
    pub const fn new<Identity: IMFRemoteProxy_Impl, const OFFSET: isize>() -> IMFRemoteProxy_Vtbl {
        unsafe extern "system" fn GetRemoteObject<Identity: IMFRemoteProxy_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppv: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFRemoteProxy_Impl::GetRemoteObject(this, core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppv)).into()
        }
        unsafe extern "system" fn GetRemoteHost<Identity: IMFRemoteProxy_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, riid: *const windows_core::GUID, ppv: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFRemoteProxy_Impl::GetRemoteHost(this, core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppv)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetRemoteObject: GetRemoteObject::<Identity, OFFSET>,
            GetRemoteHost: GetRemoteHost::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFRemoteProxy as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFSAMIStyle_Impl: Sized + windows_core::IUnknownImpl {
    fn GetStyleCount(&self) -> windows_core::Result<u32>;
    fn GetStyles(&self) -> windows_core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
    fn SetSelectedStyle(&self, pwszstyle: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn GetSelectedStyle(&self) -> windows_core::Result<windows_core::PWSTR>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFSAMIStyle {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFSAMIStyle_Vtbl {
    pub const fn new<Identity: IMFSAMIStyle_Impl, const OFFSET: isize>() -> IMFSAMIStyle_Vtbl {
        unsafe extern "system" fn GetStyleCount<Identity: IMFSAMIStyle_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwcount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSAMIStyle_Impl::GetStyleCount(this) {
                Ok(ok__) => {
                    pdwcount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStyles<Identity: IMFSAMIStyle_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppropvarstylearray: *mut core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSAMIStyle_Impl::GetStyles(this) {
                Ok(ok__) => {
                    ppropvarstylearray.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedStyle<Identity: IMFSAMIStyle_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwszstyle: windows_core::PCWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSAMIStyle_Impl::SetSelectedStyle(this, core::mem::transmute(&pwszstyle)).into()
        }
        unsafe extern "system" fn GetSelectedStyle<Identity: IMFSAMIStyle_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppwszstyle: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSAMIStyle_Impl::GetSelectedStyle(this) {
                Ok(ok__) => {
                    ppwszstyle.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetStyleCount: GetStyleCount::<Identity, OFFSET>,
            GetStyles: GetStyles::<Identity, OFFSET>,
            SetSelectedStyle: SetSelectedStyle::<Identity, OFFSET>,
            GetSelectedStyle: GetSelectedStyle::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSAMIStyle as windows_core::Interface>::IID
    }
}
pub trait IMFSSLCertificateManager_Impl: Sized + windows_core::IUnknownImpl {
    fn GetClientCertificate(&self, pszurl: &windows_core::PCWSTR, ppbdata: *mut *mut u8, pcbdata: *mut u32) -> windows_core::Result<()>;
    fn BeginGetClientCertificate(&self, pszurl: &windows_core::PCWSTR, pcallback: Option<&IMFAsyncCallback>, pstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndGetClientCertificate(&self, presult: Option<&IMFAsyncResult>, ppbdata: *mut *mut u8, pcbdata: *mut u32) -> windows_core::Result<()>;
    fn GetCertificatePolicy(&self, pszurl: &windows_core::PCWSTR, pfoverrideautomaticcheck: *mut super::super::Foundation::BOOL, pfclientcertificateavailable: *mut super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn OnServerCertificate(&self, pszurl: &windows_core::PCWSTR, pbdata: *const u8, cbdata: u32) -> windows_core::Result<super::super::Foundation::BOOL>;
}
impl windows_core::RuntimeName for IMFSSLCertificateManager {}
impl IMFSSLCertificateManager_Vtbl {
    pub const fn new<Identity: IMFSSLCertificateManager_Impl, const OFFSET: isize>() -> IMFSSLCertificateManager_Vtbl {
        unsafe extern "system" fn GetClientCertificate<Identity: IMFSSLCertificateManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszurl: windows_core::PCWSTR, ppbdata: *mut *mut u8, pcbdata: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSSLCertificateManager_Impl::GetClientCertificate(this, core::mem::transmute(&pszurl), core::mem::transmute_copy(&ppbdata), core::mem::transmute_copy(&pcbdata)).into()
        }
        unsafe extern "system" fn BeginGetClientCertificate<Identity: IMFSSLCertificateManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszurl: windows_core::PCWSTR, pcallback: *mut core::ffi::c_void, pstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSSLCertificateManager_Impl::BeginGetClientCertificate(this, core::mem::transmute(&pszurl), windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&pstate)).into()
        }
        unsafe extern "system" fn EndGetClientCertificate<Identity: IMFSSLCertificateManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void, ppbdata: *mut *mut u8, pcbdata: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSSLCertificateManager_Impl::EndGetClientCertificate(this, windows_core::from_raw_borrowed(&presult), core::mem::transmute_copy(&ppbdata), core::mem::transmute_copy(&pcbdata)).into()
        }
        unsafe extern "system" fn GetCertificatePolicy<Identity: IMFSSLCertificateManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszurl: windows_core::PCWSTR, pfoverrideautomaticcheck: *mut super::super::Foundation::BOOL, pfclientcertificateavailable: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSSLCertificateManager_Impl::GetCertificatePolicy(this, core::mem::transmute(&pszurl), core::mem::transmute_copy(&pfoverrideautomaticcheck), core::mem::transmute_copy(&pfclientcertificateavailable)).into()
        }
        unsafe extern "system" fn OnServerCertificate<Identity: IMFSSLCertificateManager_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszurl: windows_core::PCWSTR, pbdata: *const u8, cbdata: u32, pfisgood: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSSLCertificateManager_Impl::OnServerCertificate(this, core::mem::transmute(&pszurl), core::mem::transmute_copy(&pbdata), core::mem::transmute_copy(&cbdata)) {
                Ok(ok__) => {
                    pfisgood.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetClientCertificate: GetClientCertificate::<Identity, OFFSET>,
            BeginGetClientCertificate: BeginGetClientCertificate::<Identity, OFFSET>,
            EndGetClientCertificate: EndGetClientCertificate::<Identity, OFFSET>,
            GetCertificatePolicy: GetCertificatePolicy::<Identity, OFFSET>,
            OnServerCertificate: OnServerCertificate::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSSLCertificateManager as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFSample_Impl: Sized + IMFAttributes_Impl {
    fn GetSampleFlags(&self) -> windows_core::Result<u32>;
    fn SetSampleFlags(&self, dwsampleflags: u32) -> windows_core::Result<()>;
    fn GetSampleTime(&self) -> windows_core::Result<i64>;
    fn SetSampleTime(&self, hnssampletime: i64) -> windows_core::Result<()>;
    fn GetSampleDuration(&self) -> windows_core::Result<i64>;
    fn SetSampleDuration(&self, hnssampleduration: i64) -> windows_core::Result<()>;
    fn GetBufferCount(&self) -> windows_core::Result<u32>;
    fn GetBufferByIndex(&self, dwindex: u32) -> windows_core::Result<IMFMediaBuffer>;
    fn ConvertToContiguousBuffer(&self) -> windows_core::Result<IMFMediaBuffer>;
    fn AddBuffer(&self, pbuffer: Option<&IMFMediaBuffer>) -> windows_core::Result<()>;
    fn RemoveBufferByIndex(&self, dwindex: u32) -> windows_core::Result<()>;
    fn RemoveAllBuffers(&self) -> windows_core::Result<()>;
    fn GetTotalLength(&self) -> windows_core::Result<u32>;
    fn CopyToBuffer(&self, pbuffer: Option<&IMFMediaBuffer>) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFSample {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFSample_Vtbl {
    pub const fn new<Identity: IMFSample_Impl, const OFFSET: isize>() -> IMFSample_Vtbl {
        unsafe extern "system" fn GetSampleFlags<Identity: IMFSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwsampleflags: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSample_Impl::GetSampleFlags(this) {
                Ok(ok__) => {
                    pdwsampleflags.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSampleFlags<Identity: IMFSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwsampleflags: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSample_Impl::SetSampleFlags(this, core::mem::transmute_copy(&dwsampleflags)).into()
        }
        unsafe extern "system" fn GetSampleTime<Identity: IMFSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, phnssampletime: *mut i64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSample_Impl::GetSampleTime(this) {
                Ok(ok__) => {
                    phnssampletime.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSampleTime<Identity: IMFSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hnssampletime: i64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSample_Impl::SetSampleTime(this, core::mem::transmute_copy(&hnssampletime)).into()
        }
        unsafe extern "system" fn GetSampleDuration<Identity: IMFSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, phnssampleduration: *mut i64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSample_Impl::GetSampleDuration(this) {
                Ok(ok__) => {
                    phnssampleduration.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSampleDuration<Identity: IMFSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hnssampleduration: i64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSample_Impl::SetSampleDuration(this, core::mem::transmute_copy(&hnssampleduration)).into()
        }
        unsafe extern "system" fn GetBufferCount<Identity: IMFSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwbuffercount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSample_Impl::GetBufferCount(this) {
                Ok(ok__) => {
                    pdwbuffercount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBufferByIndex<Identity: IMFSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwindex: u32, ppbuffer: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSample_Impl::GetBufferByIndex(this, core::mem::transmute_copy(&dwindex)) {
                Ok(ok__) => {
                    ppbuffer.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConvertToContiguousBuffer<Identity: IMFSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppbuffer: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSample_Impl::ConvertToContiguousBuffer(this) {
                Ok(ok__) => {
                    ppbuffer.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddBuffer<Identity: IMFSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbuffer: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSample_Impl::AddBuffer(this, windows_core::from_raw_borrowed(&pbuffer)).into()
        }
        unsafe extern "system" fn RemoveBufferByIndex<Identity: IMFSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwindex: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSample_Impl::RemoveBufferByIndex(this, core::mem::transmute_copy(&dwindex)).into()
        }
        unsafe extern "system" fn RemoveAllBuffers<Identity: IMFSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSample_Impl::RemoveAllBuffers(this).into()
        }
        unsafe extern "system" fn GetTotalLength<Identity: IMFSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcbtotallength: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSample_Impl::GetTotalLength(this) {
                Ok(ok__) => {
                    pcbtotallength.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CopyToBuffer<Identity: IMFSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbuffer: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSample_Impl::CopyToBuffer(this, windows_core::from_raw_borrowed(&pbuffer)).into()
        }
        Self {
            base__: IMFAttributes_Vtbl::new::<Identity, OFFSET>(),
            GetSampleFlags: GetSampleFlags::<Identity, OFFSET>,
            SetSampleFlags: SetSampleFlags::<Identity, OFFSET>,
            GetSampleTime: GetSampleTime::<Identity, OFFSET>,
            SetSampleTime: SetSampleTime::<Identity, OFFSET>,
            GetSampleDuration: GetSampleDuration::<Identity, OFFSET>,
            SetSampleDuration: SetSampleDuration::<Identity, OFFSET>,
            GetBufferCount: GetBufferCount::<Identity, OFFSET>,
            GetBufferByIndex: GetBufferByIndex::<Identity, OFFSET>,
            ConvertToContiguousBuffer: ConvertToContiguousBuffer::<Identity, OFFSET>,
            AddBuffer: AddBuffer::<Identity, OFFSET>,
            RemoveBufferByIndex: RemoveBufferByIndex::<Identity, OFFSET>,
            RemoveAllBuffers: RemoveAllBuffers::<Identity, OFFSET>,
            GetTotalLength: GetTotalLength::<Identity, OFFSET>,
            CopyToBuffer: CopyToBuffer::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSample as windows_core::Interface>::IID || iid == &<IMFAttributes as windows_core::Interface>::IID
    }
}
pub trait IMFSampleAllocatorControl_Impl: Sized + windows_core::IUnknownImpl {
    fn SetDefaultAllocator(&self, dwoutputstreamid: u32, pallocator: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn GetAllocatorUsage(&self, dwoutputstreamid: u32, pdwinputstreamid: *mut u32, peusage: *mut MFSampleAllocatorUsage) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFSampleAllocatorControl {}
impl IMFSampleAllocatorControl_Vtbl {
    pub const fn new<Identity: IMFSampleAllocatorControl_Impl, const OFFSET: isize>() -> IMFSampleAllocatorControl_Vtbl {
        unsafe extern "system" fn SetDefaultAllocator<Identity: IMFSampleAllocatorControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwoutputstreamid: u32, pallocator: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSampleAllocatorControl_Impl::SetDefaultAllocator(this, core::mem::transmute_copy(&dwoutputstreamid), windows_core::from_raw_borrowed(&pallocator)).into()
        }
        unsafe extern "system" fn GetAllocatorUsage<Identity: IMFSampleAllocatorControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwoutputstreamid: u32, pdwinputstreamid: *mut u32, peusage: *mut MFSampleAllocatorUsage) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSampleAllocatorControl_Impl::GetAllocatorUsage(this, core::mem::transmute_copy(&dwoutputstreamid), core::mem::transmute_copy(&pdwinputstreamid), core::mem::transmute_copy(&peusage)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetDefaultAllocator: SetDefaultAllocator::<Identity, OFFSET>,
            GetAllocatorUsage: GetAllocatorUsage::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSampleAllocatorControl as windows_core::Interface>::IID
    }
}
pub trait IMFSampleGrabberSinkCallback_Impl: Sized + IMFClockStateSink_Impl {
    fn OnSetPresentationClock(&self, ppresentationclock: Option<&IMFPresentationClock>) -> windows_core::Result<()>;
    fn OnProcessSample(&self, guidmajormediatype: *const windows_core::GUID, dwsampleflags: u32, llsampletime: i64, llsampleduration: i64, psamplebuffer: *const u8, dwsamplesize: u32) -> windows_core::Result<()>;
    fn OnShutdown(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFSampleGrabberSinkCallback {}
impl IMFSampleGrabberSinkCallback_Vtbl {
    pub const fn new<Identity: IMFSampleGrabberSinkCallback_Impl, const OFFSET: isize>() -> IMFSampleGrabberSinkCallback_Vtbl {
        unsafe extern "system" fn OnSetPresentationClock<Identity: IMFSampleGrabberSinkCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppresentationclock: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSampleGrabberSinkCallback_Impl::OnSetPresentationClock(this, windows_core::from_raw_borrowed(&ppresentationclock)).into()
        }
        unsafe extern "system" fn OnProcessSample<Identity: IMFSampleGrabberSinkCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidmajormediatype: *const windows_core::GUID, dwsampleflags: u32, llsampletime: i64, llsampleduration: i64, psamplebuffer: *const u8, dwsamplesize: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSampleGrabberSinkCallback_Impl::OnProcessSample(this, core::mem::transmute_copy(&guidmajormediatype), core::mem::transmute_copy(&dwsampleflags), core::mem::transmute_copy(&llsampletime), core::mem::transmute_copy(&llsampleduration), core::mem::transmute_copy(&psamplebuffer), core::mem::transmute_copy(&dwsamplesize)).into()
        }
        unsafe extern "system" fn OnShutdown<Identity: IMFSampleGrabberSinkCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSampleGrabberSinkCallback_Impl::OnShutdown(this).into()
        }
        Self {
            base__: IMFClockStateSink_Vtbl::new::<Identity, OFFSET>(),
            OnSetPresentationClock: OnSetPresentationClock::<Identity, OFFSET>,
            OnProcessSample: OnProcessSample::<Identity, OFFSET>,
            OnShutdown: OnShutdown::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSampleGrabberSinkCallback as windows_core::Interface>::IID || iid == &<IMFClockStateSink as windows_core::Interface>::IID
    }
}
pub trait IMFSampleGrabberSinkCallback2_Impl: Sized + IMFSampleGrabberSinkCallback_Impl {
    fn OnProcessSampleEx(&self, guidmajormediatype: *const windows_core::GUID, dwsampleflags: u32, llsampletime: i64, llsampleduration: i64, psamplebuffer: *const u8, dwsamplesize: u32, pattributes: Option<&IMFAttributes>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFSampleGrabberSinkCallback2 {}
impl IMFSampleGrabberSinkCallback2_Vtbl {
    pub const fn new<Identity: IMFSampleGrabberSinkCallback2_Impl, const OFFSET: isize>() -> IMFSampleGrabberSinkCallback2_Vtbl {
        unsafe extern "system" fn OnProcessSampleEx<Identity: IMFSampleGrabberSinkCallback2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidmajormediatype: *const windows_core::GUID, dwsampleflags: u32, llsampletime: i64, llsampleduration: i64, psamplebuffer: *const u8, dwsamplesize: u32, pattributes: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSampleGrabberSinkCallback2_Impl::OnProcessSampleEx(this, core::mem::transmute_copy(&guidmajormediatype), core::mem::transmute_copy(&dwsampleflags), core::mem::transmute_copy(&llsampletime), core::mem::transmute_copy(&llsampleduration), core::mem::transmute_copy(&psamplebuffer), core::mem::transmute_copy(&dwsamplesize), windows_core::from_raw_borrowed(&pattributes)).into()
        }
        Self { base__: IMFSampleGrabberSinkCallback_Vtbl::new::<Identity, OFFSET>(), OnProcessSampleEx: OnProcessSampleEx::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSampleGrabberSinkCallback2 as windows_core::Interface>::IID || iid == &<IMFClockStateSink as windows_core::Interface>::IID || iid == &<IMFSampleGrabberSinkCallback as windows_core::Interface>::IID
    }
}
pub trait IMFSampleOutputStream_Impl: Sized + windows_core::IUnknownImpl {
    fn BeginWriteSample(&self, psample: Option<&IMFSample>, pcallback: Option<&IMFAsyncCallback>, punkstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndWriteSample(&self, presult: Option<&IMFAsyncResult>) -> windows_core::Result<()>;
    fn Close(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFSampleOutputStream {}
impl IMFSampleOutputStream_Vtbl {
    pub const fn new<Identity: IMFSampleOutputStream_Impl, const OFFSET: isize>() -> IMFSampleOutputStream_Vtbl {
        unsafe extern "system" fn BeginWriteSample<Identity: IMFSampleOutputStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psample: *mut core::ffi::c_void, pcallback: *mut core::ffi::c_void, punkstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSampleOutputStream_Impl::BeginWriteSample(this, windows_core::from_raw_borrowed(&psample), windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&punkstate)).into()
        }
        unsafe extern "system" fn EndWriteSample<Identity: IMFSampleOutputStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSampleOutputStream_Impl::EndWriteSample(this, windows_core::from_raw_borrowed(&presult)).into()
        }
        unsafe extern "system" fn Close<Identity: IMFSampleOutputStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSampleOutputStream_Impl::Close(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            BeginWriteSample: BeginWriteSample::<Identity, OFFSET>,
            EndWriteSample: EndWriteSample::<Identity, OFFSET>,
            Close: Close::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSampleOutputStream as windows_core::Interface>::IID
    }
}
pub trait IMFSampleProtection_Impl: Sized + windows_core::IUnknownImpl {
    fn GetInputProtectionVersion(&self) -> windows_core::Result<u32>;
    fn GetOutputProtectionVersion(&self) -> windows_core::Result<u32>;
    fn GetProtectionCertificate(&self, dwversion: u32, ppcert: *mut *mut u8, pcbcert: *mut u32) -> windows_core::Result<()>;
    fn InitOutputProtection(&self, dwversion: u32, dwoutputid: u32, pbcert: *const u8, cbcert: u32, ppbseed: *mut *mut u8, pcbseed: *mut u32) -> windows_core::Result<()>;
    fn InitInputProtection(&self, dwversion: u32, dwinputid: u32, pbseed: *const u8, cbseed: u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFSampleProtection {}
impl IMFSampleProtection_Vtbl {
    pub const fn new<Identity: IMFSampleProtection_Impl, const OFFSET: isize>() -> IMFSampleProtection_Vtbl {
        unsafe extern "system" fn GetInputProtectionVersion<Identity: IMFSampleProtection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwversion: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSampleProtection_Impl::GetInputProtectionVersion(this) {
                Ok(ok__) => {
                    pdwversion.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputProtectionVersion<Identity: IMFSampleProtection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwversion: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSampleProtection_Impl::GetOutputProtectionVersion(this) {
                Ok(ok__) => {
                    pdwversion.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProtectionCertificate<Identity: IMFSampleProtection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwversion: u32, ppcert: *mut *mut u8, pcbcert: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSampleProtection_Impl::GetProtectionCertificate(this, core::mem::transmute_copy(&dwversion), core::mem::transmute_copy(&ppcert), core::mem::transmute_copy(&pcbcert)).into()
        }
        unsafe extern "system" fn InitOutputProtection<Identity: IMFSampleProtection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwversion: u32, dwoutputid: u32, pbcert: *const u8, cbcert: u32, ppbseed: *mut *mut u8, pcbseed: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSampleProtection_Impl::InitOutputProtection(this, core::mem::transmute_copy(&dwversion), core::mem::transmute_copy(&dwoutputid), core::mem::transmute_copy(&pbcert), core::mem::transmute_copy(&cbcert), core::mem::transmute_copy(&ppbseed), core::mem::transmute_copy(&pcbseed)).into()
        }
        unsafe extern "system" fn InitInputProtection<Identity: IMFSampleProtection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwversion: u32, dwinputid: u32, pbseed: *const u8, cbseed: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSampleProtection_Impl::InitInputProtection(this, core::mem::transmute_copy(&dwversion), core::mem::transmute_copy(&dwinputid), core::mem::transmute_copy(&pbseed), core::mem::transmute_copy(&cbseed)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetInputProtectionVersion: GetInputProtectionVersion::<Identity, OFFSET>,
            GetOutputProtectionVersion: GetOutputProtectionVersion::<Identity, OFFSET>,
            GetProtectionCertificate: GetProtectionCertificate::<Identity, OFFSET>,
            InitOutputProtection: InitOutputProtection::<Identity, OFFSET>,
            InitInputProtection: InitInputProtection::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSampleProtection as windows_core::Interface>::IID
    }
}
pub trait IMFSaveJob_Impl: Sized + windows_core::IUnknownImpl {
    fn BeginSave(&self, pstream: Option<&IMFByteStream>, pcallback: Option<&IMFAsyncCallback>, pstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndSave(&self, presult: Option<&IMFAsyncResult>) -> windows_core::Result<()>;
    fn CancelSave(&self) -> windows_core::Result<()>;
    fn GetProgress(&self) -> windows_core::Result<u32>;
}
impl windows_core::RuntimeName for IMFSaveJob {}
impl IMFSaveJob_Vtbl {
    pub const fn new<Identity: IMFSaveJob_Impl, const OFFSET: isize>() -> IMFSaveJob_Vtbl {
        unsafe extern "system" fn BeginSave<Identity: IMFSaveJob_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstream: *mut core::ffi::c_void, pcallback: *mut core::ffi::c_void, pstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSaveJob_Impl::BeginSave(this, windows_core::from_raw_borrowed(&pstream), windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&pstate)).into()
        }
        unsafe extern "system" fn EndSave<Identity: IMFSaveJob_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSaveJob_Impl::EndSave(this, windows_core::from_raw_borrowed(&presult)).into()
        }
        unsafe extern "system" fn CancelSave<Identity: IMFSaveJob_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSaveJob_Impl::CancelSave(this).into()
        }
        unsafe extern "system" fn GetProgress<Identity: IMFSaveJob_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwpercentcomplete: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSaveJob_Impl::GetProgress(this) {
                Ok(ok__) => {
                    pdwpercentcomplete.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            BeginSave: BeginSave::<Identity, OFFSET>,
            EndSave: EndSave::<Identity, OFFSET>,
            CancelSave: CancelSave::<Identity, OFFSET>,
            GetProgress: GetProgress::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSaveJob as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub trait IMFSchemeHandler_Impl: Sized + windows_core::IUnknownImpl {
    fn BeginCreateObject(&self, pwszurl: &windows_core::PCWSTR, dwflags: u32, pprops: Option<&super::super::UI::Shell::PropertiesSystem::IPropertyStore>, ppiunknowncancelcookie: *mut Option<windows_core::IUnknown>, pcallback: Option<&IMFAsyncCallback>, punkstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndCreateObject(&self, presult: Option<&IMFAsyncResult>, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut Option<windows_core::IUnknown>) -> windows_core::Result<()>;
    fn CancelObjectCreation(&self, piunknowncancelcookie: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl windows_core::RuntimeName for IMFSchemeHandler {}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl IMFSchemeHandler_Vtbl {
    pub const fn new<Identity: IMFSchemeHandler_Impl, const OFFSET: isize>() -> IMFSchemeHandler_Vtbl {
        unsafe extern "system" fn BeginCreateObject<Identity: IMFSchemeHandler_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwszurl: windows_core::PCWSTR, dwflags: u32, pprops: *mut core::ffi::c_void, ppiunknowncancelcookie: *mut *mut core::ffi::c_void, pcallback: *mut core::ffi::c_void, punkstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSchemeHandler_Impl::BeginCreateObject(this, core::mem::transmute(&pwszurl), core::mem::transmute_copy(&dwflags), windows_core::from_raw_borrowed(&pprops), core::mem::transmute_copy(&ppiunknowncancelcookie), windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&punkstate)).into()
        }
        unsafe extern "system" fn EndCreateObject<Identity: IMFSchemeHandler_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSchemeHandler_Impl::EndCreateObject(this, windows_core::from_raw_borrowed(&presult), core::mem::transmute_copy(&pobjecttype), core::mem::transmute_copy(&ppobject)).into()
        }
        unsafe extern "system" fn CancelObjectCreation<Identity: IMFSchemeHandler_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, piunknowncancelcookie: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSchemeHandler_Impl::CancelObjectCreation(this, windows_core::from_raw_borrowed(&piunknowncancelcookie)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            BeginCreateObject: BeginCreateObject::<Identity, OFFSET>,
            EndCreateObject: EndCreateObject::<Identity, OFFSET>,
            CancelObjectCreation: CancelObjectCreation::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSchemeHandler as windows_core::Interface>::IID
    }
}
pub trait IMFSecureBuffer_Impl: Sized + windows_core::IUnknownImpl {
    fn GetIdentifier(&self) -> windows_core::Result<windows_core::GUID>;
}
impl windows_core::RuntimeName for IMFSecureBuffer {}
impl IMFSecureBuffer_Vtbl {
    pub const fn new<Identity: IMFSecureBuffer_Impl, const OFFSET: isize>() -> IMFSecureBuffer_Vtbl {
        unsafe extern "system" fn GetIdentifier<Identity: IMFSecureBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguididentifier: *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSecureBuffer_Impl::GetIdentifier(this) {
                Ok(ok__) => {
                    pguididentifier.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetIdentifier: GetIdentifier::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSecureBuffer as windows_core::Interface>::IID
    }
}
pub trait IMFSecureChannel_Impl: Sized + windows_core::IUnknownImpl {
    fn GetCertificate(&self, ppcert: *mut *mut u8, pcbcert: *mut u32) -> windows_core::Result<()>;
    fn SetupSession(&self, pbencryptedsessionkey: *const u8, cbsessionkey: u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFSecureChannel {}
impl IMFSecureChannel_Vtbl {
    pub const fn new<Identity: IMFSecureChannel_Impl, const OFFSET: isize>() -> IMFSecureChannel_Vtbl {
        unsafe extern "system" fn GetCertificate<Identity: IMFSecureChannel_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppcert: *mut *mut u8, pcbcert: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSecureChannel_Impl::GetCertificate(this, core::mem::transmute_copy(&ppcert), core::mem::transmute_copy(&pcbcert)).into()
        }
        unsafe extern "system" fn SetupSession<Identity: IMFSecureChannel_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbencryptedsessionkey: *const u8, cbsessionkey: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSecureChannel_Impl::SetupSession(this, core::mem::transmute_copy(&pbencryptedsessionkey), core::mem::transmute_copy(&cbsessionkey)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetCertificate: GetCertificate::<Identity, OFFSET>,
            SetupSession: SetupSession::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSecureChannel as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFSeekInfo_Impl: Sized + windows_core::IUnknownImpl {
    fn GetNearestKeyFrames(&self, pguidtimeformat: *const windows_core::GUID, pvarstartposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pvarpreviouskeyframe: *mut super::super::System::Com::StructuredStorage::PROPVARIANT, pvarnextkeyframe: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFSeekInfo {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFSeekInfo_Vtbl {
    pub const fn new<Identity: IMFSeekInfo_Impl, const OFFSET: isize>() -> IMFSeekInfo_Vtbl {
        unsafe extern "system" fn GetNearestKeyFrames<Identity: IMFSeekInfo_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pguidtimeformat: *const windows_core::GUID, pvarstartposition: *const core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>, pvarpreviouskeyframe: *mut core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>, pvarnextkeyframe: *mut core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSeekInfo_Impl::GetNearestKeyFrames(this, core::mem::transmute_copy(&pguidtimeformat), core::mem::transmute_copy(&pvarstartposition), core::mem::transmute_copy(&pvarpreviouskeyframe), core::mem::transmute_copy(&pvarnextkeyframe)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetNearestKeyFrames: GetNearestKeyFrames::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSeekInfo as windows_core::Interface>::IID
    }
}
pub trait IMFSensorActivitiesReport_Impl: Sized + windows_core::IUnknownImpl {
    fn GetCount(&self) -> windows_core::Result<u32>;
    fn GetActivityReport(&self, index: u32) -> windows_core::Result<IMFSensorActivityReport>;
    fn GetActivityReportByDeviceName(&self, symbolicname: &windows_core::PCWSTR) -> windows_core::Result<IMFSensorActivityReport>;
}
impl windows_core::RuntimeName for IMFSensorActivitiesReport {}
impl IMFSensorActivitiesReport_Vtbl {
    pub const fn new<Identity: IMFSensorActivitiesReport_Impl, const OFFSET: isize>() -> IMFSensorActivitiesReport_Vtbl {
        unsafe extern "system" fn GetCount<Identity: IMFSensorActivitiesReport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pccount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorActivitiesReport_Impl::GetCount(this) {
                Ok(ok__) => {
                    pccount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetActivityReport<Identity: IMFSensorActivitiesReport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, index: u32, sensoractivityreport: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorActivitiesReport_Impl::GetActivityReport(this, core::mem::transmute_copy(&index)) {
                Ok(ok__) => {
                    sensoractivityreport.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetActivityReportByDeviceName<Identity: IMFSensorActivitiesReport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, symbolicname: windows_core::PCWSTR, sensoractivityreport: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorActivitiesReport_Impl::GetActivityReportByDeviceName(this, core::mem::transmute(&symbolicname)) {
                Ok(ok__) => {
                    sensoractivityreport.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetCount: GetCount::<Identity, OFFSET>,
            GetActivityReport: GetActivityReport::<Identity, OFFSET>,
            GetActivityReportByDeviceName: GetActivityReportByDeviceName::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSensorActivitiesReport as windows_core::Interface>::IID
    }
}
pub trait IMFSensorActivitiesReportCallback_Impl: Sized + windows_core::IUnknownImpl {
    fn OnActivitiesReport(&self, sensoractivitiesreport: Option<&IMFSensorActivitiesReport>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFSensorActivitiesReportCallback {}
impl IMFSensorActivitiesReportCallback_Vtbl {
    pub const fn new<Identity: IMFSensorActivitiesReportCallback_Impl, const OFFSET: isize>() -> IMFSensorActivitiesReportCallback_Vtbl {
        unsafe extern "system" fn OnActivitiesReport<Identity: IMFSensorActivitiesReportCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, sensoractivitiesreport: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSensorActivitiesReportCallback_Impl::OnActivitiesReport(this, windows_core::from_raw_borrowed(&sensoractivitiesreport)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), OnActivitiesReport: OnActivitiesReport::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSensorActivitiesReportCallback as windows_core::Interface>::IID
    }
}
pub trait IMFSensorActivityMonitor_Impl: Sized + windows_core::IUnknownImpl {
    fn Start(&self) -> windows_core::Result<()>;
    fn Stop(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFSensorActivityMonitor {}
impl IMFSensorActivityMonitor_Vtbl {
    pub const fn new<Identity: IMFSensorActivityMonitor_Impl, const OFFSET: isize>() -> IMFSensorActivityMonitor_Vtbl {
        unsafe extern "system" fn Start<Identity: IMFSensorActivityMonitor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSensorActivityMonitor_Impl::Start(this).into()
        }
        unsafe extern "system" fn Stop<Identity: IMFSensorActivityMonitor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSensorActivityMonitor_Impl::Stop(this).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Start: Start::<Identity, OFFSET>, Stop: Stop::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSensorActivityMonitor as windows_core::Interface>::IID
    }
}
pub trait IMFSensorActivityReport_Impl: Sized + windows_core::IUnknownImpl {
    fn GetFriendlyName(&self, friendlyname: windows_core::PWSTR, cchfriendlyname: u32, pcchwritten: *mut u32) -> windows_core::Result<()>;
    fn GetSymbolicLink(&self, symboliclink: windows_core::PWSTR, cchsymboliclink: u32, pcchwritten: *mut u32) -> windows_core::Result<()>;
    fn GetProcessCount(&self) -> windows_core::Result<u32>;
    fn GetProcessActivity(&self, index: u32) -> windows_core::Result<IMFSensorProcessActivity>;
}
impl windows_core::RuntimeName for IMFSensorActivityReport {}
impl IMFSensorActivityReport_Vtbl {
    pub const fn new<Identity: IMFSensorActivityReport_Impl, const OFFSET: isize>() -> IMFSensorActivityReport_Vtbl {
        unsafe extern "system" fn GetFriendlyName<Identity: IMFSensorActivityReport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, friendlyname: windows_core::PWSTR, cchfriendlyname: u32, pcchwritten: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSensorActivityReport_Impl::GetFriendlyName(this, core::mem::transmute_copy(&friendlyname), core::mem::transmute_copy(&cchfriendlyname), core::mem::transmute_copy(&pcchwritten)).into()
        }
        unsafe extern "system" fn GetSymbolicLink<Identity: IMFSensorActivityReport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, symboliclink: windows_core::PWSTR, cchsymboliclink: u32, pcchwritten: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSensorActivityReport_Impl::GetSymbolicLink(this, core::mem::transmute_copy(&symboliclink), core::mem::transmute_copy(&cchsymboliclink), core::mem::transmute_copy(&pcchwritten)).into()
        }
        unsafe extern "system" fn GetProcessCount<Identity: IMFSensorActivityReport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pccount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorActivityReport_Impl::GetProcessCount(this) {
                Ok(ok__) => {
                    pccount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProcessActivity<Identity: IMFSensorActivityReport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, index: u32, ppprocessactivity: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorActivityReport_Impl::GetProcessActivity(this, core::mem::transmute_copy(&index)) {
                Ok(ok__) => {
                    ppprocessactivity.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetFriendlyName: GetFriendlyName::<Identity, OFFSET>,
            GetSymbolicLink: GetSymbolicLink::<Identity, OFFSET>,
            GetProcessCount: GetProcessCount::<Identity, OFFSET>,
            GetProcessActivity: GetProcessActivity::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSensorActivityReport as windows_core::Interface>::IID
    }
}
pub trait IMFSensorDevice_Impl: Sized + windows_core::IUnknownImpl {
    fn GetDeviceId(&self) -> windows_core::Result<u64>;
    fn GetDeviceType(&self) -> windows_core::Result<MFSensorDeviceType>;
    fn GetFlags(&self) -> windows_core::Result<u64>;
    fn GetSymbolicLink(&self, symboliclink: windows_core::PWSTR, cchsymboliclink: i32, pcchwritten: *mut i32) -> windows_core::Result<()>;
    fn GetDeviceAttributes(&self) -> windows_core::Result<IMFAttributes>;
    fn GetStreamAttributesCount(&self, etype: MFSensorStreamType) -> windows_core::Result<u32>;
    fn GetStreamAttributes(&self, etype: MFSensorStreamType, dwindex: u32) -> windows_core::Result<IMFAttributes>;
    fn SetSensorDeviceMode(&self, emode: MFSensorDeviceMode) -> windows_core::Result<()>;
    fn GetSensorDeviceMode(&self) -> windows_core::Result<MFSensorDeviceMode>;
}
impl windows_core::RuntimeName for IMFSensorDevice {}
impl IMFSensorDevice_Vtbl {
    pub const fn new<Identity: IMFSensorDevice_Impl, const OFFSET: isize>() -> IMFSensorDevice_Vtbl {
        unsafe extern "system" fn GetDeviceId<Identity: IMFSensorDevice_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdeviceid: *mut u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorDevice_Impl::GetDeviceId(this) {
                Ok(ok__) => {
                    pdeviceid.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDeviceType<Identity: IMFSensorDevice_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptype: *mut MFSensorDeviceType) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorDevice_Impl::GetDeviceType(this) {
                Ok(ok__) => {
                    ptype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFlags<Identity: IMFSensorDevice_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pflags: *mut u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorDevice_Impl::GetFlags(this) {
                Ok(ok__) => {
                    pflags.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSymbolicLink<Identity: IMFSensorDevice_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, symboliclink: windows_core::PWSTR, cchsymboliclink: i32, pcchwritten: *mut i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSensorDevice_Impl::GetSymbolicLink(this, core::mem::transmute_copy(&symboliclink), core::mem::transmute_copy(&cchsymboliclink), core::mem::transmute_copy(&pcchwritten)).into()
        }
        unsafe extern "system" fn GetDeviceAttributes<Identity: IMFSensorDevice_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppattributes: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorDevice_Impl::GetDeviceAttributes(this) {
                Ok(ok__) => {
                    ppattributes.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamAttributesCount<Identity: IMFSensorDevice_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, etype: MFSensorStreamType, pdwcount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorDevice_Impl::GetStreamAttributesCount(this, core::mem::transmute_copy(&etype)) {
                Ok(ok__) => {
                    pdwcount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamAttributes<Identity: IMFSensorDevice_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, etype: MFSensorStreamType, dwindex: u32, ppattributes: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorDevice_Impl::GetStreamAttributes(this, core::mem::transmute_copy(&etype), core::mem::transmute_copy(&dwindex)) {
                Ok(ok__) => {
                    ppattributes.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSensorDeviceMode<Identity: IMFSensorDevice_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, emode: MFSensorDeviceMode) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSensorDevice_Impl::SetSensorDeviceMode(this, core::mem::transmute_copy(&emode)).into()
        }
        unsafe extern "system" fn GetSensorDeviceMode<Identity: IMFSensorDevice_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pemode: *mut MFSensorDeviceMode) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorDevice_Impl::GetSensorDeviceMode(this) {
                Ok(ok__) => {
                    pemode.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetDeviceId: GetDeviceId::<Identity, OFFSET>,
            GetDeviceType: GetDeviceType::<Identity, OFFSET>,
            GetFlags: GetFlags::<Identity, OFFSET>,
            GetSymbolicLink: GetSymbolicLink::<Identity, OFFSET>,
            GetDeviceAttributes: GetDeviceAttributes::<Identity, OFFSET>,
            GetStreamAttributesCount: GetStreamAttributesCount::<Identity, OFFSET>,
            GetStreamAttributes: GetStreamAttributes::<Identity, OFFSET>,
            SetSensorDeviceMode: SetSensorDeviceMode::<Identity, OFFSET>,
            GetSensorDeviceMode: GetSensorDeviceMode::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSensorDevice as windows_core::Interface>::IID
    }
}
pub trait IMFSensorGroup_Impl: Sized + windows_core::IUnknownImpl {
    fn GetSymbolicLink(&self, symboliclink: windows_core::PWSTR, cchsymboliclink: i32, pcchwritten: *mut i32) -> windows_core::Result<()>;
    fn GetFlags(&self) -> windows_core::Result<u64>;
    fn GetSensorGroupAttributes(&self) -> windows_core::Result<IMFAttributes>;
    fn GetSensorDeviceCount(&self) -> windows_core::Result<u32>;
    fn GetSensorDevice(&self, dwindex: u32) -> windows_core::Result<IMFSensorDevice>;
    fn SetDefaultSensorDeviceIndex(&self, dwindex: u32) -> windows_core::Result<()>;
    fn GetDefaultSensorDeviceIndex(&self) -> windows_core::Result<u32>;
    fn CreateMediaSource(&self) -> windows_core::Result<IMFMediaSource>;
}
impl windows_core::RuntimeName for IMFSensorGroup {}
impl IMFSensorGroup_Vtbl {
    pub const fn new<Identity: IMFSensorGroup_Impl, const OFFSET: isize>() -> IMFSensorGroup_Vtbl {
        unsafe extern "system" fn GetSymbolicLink<Identity: IMFSensorGroup_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, symboliclink: windows_core::PWSTR, cchsymboliclink: i32, pcchwritten: *mut i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSensorGroup_Impl::GetSymbolicLink(this, core::mem::transmute_copy(&symboliclink), core::mem::transmute_copy(&cchsymboliclink), core::mem::transmute_copy(&pcchwritten)).into()
        }
        unsafe extern "system" fn GetFlags<Identity: IMFSensorGroup_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pflags: *mut u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorGroup_Impl::GetFlags(this) {
                Ok(ok__) => {
                    pflags.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSensorGroupAttributes<Identity: IMFSensorGroup_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppattributes: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorGroup_Impl::GetSensorGroupAttributes(this) {
                Ok(ok__) => {
                    ppattributes.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSensorDeviceCount<Identity: IMFSensorGroup_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwcount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorGroup_Impl::GetSensorDeviceCount(this) {
                Ok(ok__) => {
                    pdwcount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSensorDevice<Identity: IMFSensorGroup_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwindex: u32, ppdevice: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorGroup_Impl::GetSensorDevice(this, core::mem::transmute_copy(&dwindex)) {
                Ok(ok__) => {
                    ppdevice.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultSensorDeviceIndex<Identity: IMFSensorGroup_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwindex: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSensorGroup_Impl::SetDefaultSensorDeviceIndex(this, core::mem::transmute_copy(&dwindex)).into()
        }
        unsafe extern "system" fn GetDefaultSensorDeviceIndex<Identity: IMFSensorGroup_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwindex: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorGroup_Impl::GetDefaultSensorDeviceIndex(this) {
                Ok(ok__) => {
                    pdwindex.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateMediaSource<Identity: IMFSensorGroup_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppsource: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorGroup_Impl::CreateMediaSource(this) {
                Ok(ok__) => {
                    ppsource.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetSymbolicLink: GetSymbolicLink::<Identity, OFFSET>,
            GetFlags: GetFlags::<Identity, OFFSET>,
            GetSensorGroupAttributes: GetSensorGroupAttributes::<Identity, OFFSET>,
            GetSensorDeviceCount: GetSensorDeviceCount::<Identity, OFFSET>,
            GetSensorDevice: GetSensorDevice::<Identity, OFFSET>,
            SetDefaultSensorDeviceIndex: SetDefaultSensorDeviceIndex::<Identity, OFFSET>,
            GetDefaultSensorDeviceIndex: GetDefaultSensorDeviceIndex::<Identity, OFFSET>,
            CreateMediaSource: CreateMediaSource::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSensorGroup as windows_core::Interface>::IID
    }
}
pub trait IMFSensorProcessActivity_Impl: Sized + windows_core::IUnknownImpl {
    fn GetProcessId(&self) -> windows_core::Result<u32>;
    fn GetStreamingState(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn GetStreamingMode(&self) -> windows_core::Result<MFSensorDeviceMode>;
    fn GetReportTime(&self) -> windows_core::Result<super::super::Foundation::FILETIME>;
}
impl windows_core::RuntimeName for IMFSensorProcessActivity {}
impl IMFSensorProcessActivity_Vtbl {
    pub const fn new<Identity: IMFSensorProcessActivity_Impl, const OFFSET: isize>() -> IMFSensorProcessActivity_Vtbl {
        unsafe extern "system" fn GetProcessId<Identity: IMFSensorProcessActivity_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppid: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorProcessActivity_Impl::GetProcessId(this) {
                Ok(ok__) => {
                    ppid.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamingState<Identity: IMFSensorProcessActivity_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfstreaming: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorProcessActivity_Impl::GetStreamingState(this) {
                Ok(ok__) => {
                    pfstreaming.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamingMode<Identity: IMFSensorProcessActivity_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmode: *mut MFSensorDeviceMode) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorProcessActivity_Impl::GetStreamingMode(this) {
                Ok(ok__) => {
                    pmode.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetReportTime<Identity: IMFSensorProcessActivity_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pft: *mut super::super::Foundation::FILETIME) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorProcessActivity_Impl::GetReportTime(this) {
                Ok(ok__) => {
                    pft.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetProcessId: GetProcessId::<Identity, OFFSET>,
            GetStreamingState: GetStreamingState::<Identity, OFFSET>,
            GetStreamingMode: GetStreamingMode::<Identity, OFFSET>,
            GetReportTime: GetReportTime::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSensorProcessActivity as windows_core::Interface>::IID
    }
}
pub trait IMFSensorProfile_Impl: Sized + windows_core::IUnknownImpl {
    fn GetProfileId(&self, pid: *mut SENSORPROFILEID) -> windows_core::Result<()>;
    fn AddProfileFilter(&self, streamid: u32, wzfiltersetstring: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn IsMediaTypeSupported(&self, streamid: u32, pmediatype: Option<&IMFMediaType>) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn AddBlockedControl(&self, wzblockedcontrol: &windows_core::PCWSTR) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFSensorProfile {}
impl IMFSensorProfile_Vtbl {
    pub const fn new<Identity: IMFSensorProfile_Impl, const OFFSET: isize>() -> IMFSensorProfile_Vtbl {
        unsafe extern "system" fn GetProfileId<Identity: IMFSensorProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pid: *mut SENSORPROFILEID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSensorProfile_Impl::GetProfileId(this, core::mem::transmute_copy(&pid)).into()
        }
        unsafe extern "system" fn AddProfileFilter<Identity: IMFSensorProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, streamid: u32, wzfiltersetstring: windows_core::PCWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSensorProfile_Impl::AddProfileFilter(this, core::mem::transmute_copy(&streamid), core::mem::transmute(&wzfiltersetstring)).into()
        }
        unsafe extern "system" fn IsMediaTypeSupported<Identity: IMFSensorProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, streamid: u32, pmediatype: *mut core::ffi::c_void, pfsupported: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorProfile_Impl::IsMediaTypeSupported(this, core::mem::transmute_copy(&streamid), windows_core::from_raw_borrowed(&pmediatype)) {
                Ok(ok__) => {
                    pfsupported.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddBlockedControl<Identity: IMFSensorProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, wzblockedcontrol: windows_core::PCWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSensorProfile_Impl::AddBlockedControl(this, core::mem::transmute(&wzblockedcontrol)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetProfileId: GetProfileId::<Identity, OFFSET>,
            AddProfileFilter: AddProfileFilter::<Identity, OFFSET>,
            IsMediaTypeSupported: IsMediaTypeSupported::<Identity, OFFSET>,
            AddBlockedControl: AddBlockedControl::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSensorProfile as windows_core::Interface>::IID
    }
}
pub trait IMFSensorProfileCollection_Impl: Sized + windows_core::IUnknownImpl {
    fn GetProfileCount(&self) -> u32;
    fn GetProfile(&self, index: u32) -> windows_core::Result<IMFSensorProfile>;
    fn AddProfile(&self, pprofile: Option<&IMFSensorProfile>) -> windows_core::Result<()>;
    fn FindProfile(&self, profileid: *const SENSORPROFILEID) -> windows_core::Result<IMFSensorProfile>;
    fn RemoveProfileByIndex(&self, index: u32);
    fn RemoveProfile(&self, profileid: *const SENSORPROFILEID);
}
impl windows_core::RuntimeName for IMFSensorProfileCollection {}
impl IMFSensorProfileCollection_Vtbl {
    pub const fn new<Identity: IMFSensorProfileCollection_Impl, const OFFSET: isize>() -> IMFSensorProfileCollection_Vtbl {
        unsafe extern "system" fn GetProfileCount<Identity: IMFSensorProfileCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u32 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSensorProfileCollection_Impl::GetProfileCount(this)
        }
        unsafe extern "system" fn GetProfile<Identity: IMFSensorProfileCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, index: u32, ppprofile: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorProfileCollection_Impl::GetProfile(this, core::mem::transmute_copy(&index)) {
                Ok(ok__) => {
                    ppprofile.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddProfile<Identity: IMFSensorProfileCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pprofile: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSensorProfileCollection_Impl::AddProfile(this, windows_core::from_raw_borrowed(&pprofile)).into()
        }
        unsafe extern "system" fn FindProfile<Identity: IMFSensorProfileCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, profileid: *const SENSORPROFILEID, ppprofile: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorProfileCollection_Impl::FindProfile(this, core::mem::transmute_copy(&profileid)) {
                Ok(ok__) => {
                    ppprofile.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveProfileByIndex<Identity: IMFSensorProfileCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, index: u32) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSensorProfileCollection_Impl::RemoveProfileByIndex(this, core::mem::transmute_copy(&index))
        }
        unsafe extern "system" fn RemoveProfile<Identity: IMFSensorProfileCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, profileid: *const SENSORPROFILEID) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSensorProfileCollection_Impl::RemoveProfile(this, core::mem::transmute_copy(&profileid))
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetProfileCount: GetProfileCount::<Identity, OFFSET>,
            GetProfile: GetProfile::<Identity, OFFSET>,
            AddProfile: AddProfile::<Identity, OFFSET>,
            FindProfile: FindProfile::<Identity, OFFSET>,
            RemoveProfileByIndex: RemoveProfileByIndex::<Identity, OFFSET>,
            RemoveProfile: RemoveProfile::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSensorProfileCollection as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFSensorStream_Impl: Sized + IMFAttributes_Impl {
    fn GetMediaTypeCount(&self) -> windows_core::Result<u32>;
    fn GetMediaType(&self, dwindex: u32) -> windows_core::Result<IMFMediaType>;
    fn CloneSensorStream(&self) -> windows_core::Result<IMFSensorStream>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFSensorStream {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFSensorStream_Vtbl {
    pub const fn new<Identity: IMFSensorStream_Impl, const OFFSET: isize>() -> IMFSensorStream_Vtbl {
        unsafe extern "system" fn GetMediaTypeCount<Identity: IMFSensorStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwcount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorStream_Impl::GetMediaTypeCount(this) {
                Ok(ok__) => {
                    pdwcount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaType<Identity: IMFSensorStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwindex: u32, ppmediatype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorStream_Impl::GetMediaType(this, core::mem::transmute_copy(&dwindex)) {
                Ok(ok__) => {
                    ppmediatype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CloneSensorStream<Identity: IMFSensorStream_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppstream: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorStream_Impl::CloneSensorStream(this) {
                Ok(ok__) => {
                    ppstream.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IMFAttributes_Vtbl::new::<Identity, OFFSET>(),
            GetMediaTypeCount: GetMediaTypeCount::<Identity, OFFSET>,
            GetMediaType: GetMediaType::<Identity, OFFSET>,
            CloneSensorStream: CloneSensorStream::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSensorStream as windows_core::Interface>::IID || iid == &<IMFAttributes as windows_core::Interface>::IID
    }
}
pub trait IMFSensorTransformFactory_Impl: Sized + windows_core::IUnknownImpl {
    fn GetFactoryAttributes(&self) -> windows_core::Result<IMFAttributes>;
    fn InitializeFactory(&self, dwmaxtransformcount: u32, psensordevices: Option<&IMFCollection>, pattributes: Option<&IMFAttributes>) -> windows_core::Result<()>;
    fn GetTransformCount(&self) -> windows_core::Result<u32>;
    fn GetTransformInformation(&self, transformindex: u32, pguidtransformid: *mut windows_core::GUID, ppattributes: *mut Option<IMFAttributes>, ppstreaminformation: *mut Option<IMFCollection>) -> windows_core::Result<()>;
    fn CreateTransform(&self, guidsensortransformid: *const windows_core::GUID, pattributes: Option<&IMFAttributes>) -> windows_core::Result<IMFDeviceTransform>;
}
impl windows_core::RuntimeName for IMFSensorTransformFactory {}
impl IMFSensorTransformFactory_Vtbl {
    pub const fn new<Identity: IMFSensorTransformFactory_Impl, const OFFSET: isize>() -> IMFSensorTransformFactory_Vtbl {
        unsafe extern "system" fn GetFactoryAttributes<Identity: IMFSensorTransformFactory_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppattributes: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorTransformFactory_Impl::GetFactoryAttributes(this) {
                Ok(ok__) => {
                    ppattributes.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InitializeFactory<Identity: IMFSensorTransformFactory_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwmaxtransformcount: u32, psensordevices: *mut core::ffi::c_void, pattributes: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSensorTransformFactory_Impl::InitializeFactory(this, core::mem::transmute_copy(&dwmaxtransformcount), windows_core::from_raw_borrowed(&psensordevices), windows_core::from_raw_borrowed(&pattributes)).into()
        }
        unsafe extern "system" fn GetTransformCount<Identity: IMFSensorTransformFactory_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwcount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorTransformFactory_Impl::GetTransformCount(this) {
                Ok(ok__) => {
                    pdwcount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransformInformation<Identity: IMFSensorTransformFactory_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, transformindex: u32, pguidtransformid: *mut windows_core::GUID, ppattributes: *mut *mut core::ffi::c_void, ppstreaminformation: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSensorTransformFactory_Impl::GetTransformInformation(this, core::mem::transmute_copy(&transformindex), core::mem::transmute_copy(&pguidtransformid), core::mem::transmute_copy(&ppattributes), core::mem::transmute_copy(&ppstreaminformation)).into()
        }
        unsafe extern "system" fn CreateTransform<Identity: IMFSensorTransformFactory_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidsensortransformid: *const windows_core::GUID, pattributes: *mut core::ffi::c_void, ppdevicemft: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSensorTransformFactory_Impl::CreateTransform(this, core::mem::transmute_copy(&guidsensortransformid), windows_core::from_raw_borrowed(&pattributes)) {
                Ok(ok__) => {
                    ppdevicemft.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetFactoryAttributes: GetFactoryAttributes::<Identity, OFFSET>,
            InitializeFactory: InitializeFactory::<Identity, OFFSET>,
            GetTransformCount: GetTransformCount::<Identity, OFFSET>,
            GetTransformInformation: GetTransformInformation::<Identity, OFFSET>,
            CreateTransform: CreateTransform::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSensorTransformFactory as windows_core::Interface>::IID
    }
}
pub trait IMFSequencerSource_Impl: Sized + windows_core::IUnknownImpl {
    fn AppendTopology(&self, ptopology: Option<&IMFTopology>, dwflags: u32) -> windows_core::Result<u32>;
    fn DeleteTopology(&self, dwid: u32) -> windows_core::Result<()>;
    fn GetPresentationContext(&self, ppd: Option<&IMFPresentationDescriptor>, pid: *mut u32, pptopology: *mut Option<IMFTopology>) -> windows_core::Result<()>;
    fn UpdateTopology(&self, dwid: u32, ptopology: Option<&IMFTopology>) -> windows_core::Result<()>;
    fn UpdateTopologyFlags(&self, dwid: u32, dwflags: u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFSequencerSource {}
impl IMFSequencerSource_Vtbl {
    pub const fn new<Identity: IMFSequencerSource_Impl, const OFFSET: isize>() -> IMFSequencerSource_Vtbl {
        unsafe extern "system" fn AppendTopology<Identity: IMFSequencerSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptopology: *mut core::ffi::c_void, dwflags: u32, pdwid: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSequencerSource_Impl::AppendTopology(this, windows_core::from_raw_borrowed(&ptopology), core::mem::transmute_copy(&dwflags)) {
                Ok(ok__) => {
                    pdwid.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DeleteTopology<Identity: IMFSequencerSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwid: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSequencerSource_Impl::DeleteTopology(this, core::mem::transmute_copy(&dwid)).into()
        }
        unsafe extern "system" fn GetPresentationContext<Identity: IMFSequencerSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppd: *mut core::ffi::c_void, pid: *mut u32, pptopology: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSequencerSource_Impl::GetPresentationContext(this, windows_core::from_raw_borrowed(&ppd), core::mem::transmute_copy(&pid), core::mem::transmute_copy(&pptopology)).into()
        }
        unsafe extern "system" fn UpdateTopology<Identity: IMFSequencerSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwid: u32, ptopology: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSequencerSource_Impl::UpdateTopology(this, core::mem::transmute_copy(&dwid), windows_core::from_raw_borrowed(&ptopology)).into()
        }
        unsafe extern "system" fn UpdateTopologyFlags<Identity: IMFSequencerSource_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwid: u32, dwflags: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSequencerSource_Impl::UpdateTopologyFlags(this, core::mem::transmute_copy(&dwid), core::mem::transmute_copy(&dwflags)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            AppendTopology: AppendTopology::<Identity, OFFSET>,
            DeleteTopology: DeleteTopology::<Identity, OFFSET>,
            GetPresentationContext: GetPresentationContext::<Identity, OFFSET>,
            UpdateTopology: UpdateTopology::<Identity, OFFSET>,
            UpdateTopologyFlags: UpdateTopologyFlags::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSequencerSource as windows_core::Interface>::IID
    }
}
pub trait IMFSharingEngineClassFactory_Impl: Sized + windows_core::IUnknownImpl {
    fn CreateInstance(&self, dwflags: u32, pattr: Option<&IMFAttributes>) -> windows_core::Result<windows_core::IUnknown>;
}
impl windows_core::RuntimeName for IMFSharingEngineClassFactory {}
impl IMFSharingEngineClassFactory_Vtbl {
    pub const fn new<Identity: IMFSharingEngineClassFactory_Impl, const OFFSET: isize>() -> IMFSharingEngineClassFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Identity: IMFSharingEngineClassFactory_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32, pattr: *mut core::ffi::c_void, ppengine: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSharingEngineClassFactory_Impl::CreateInstance(this, core::mem::transmute_copy(&dwflags), windows_core::from_raw_borrowed(&pattr)) {
                Ok(ok__) => {
                    ppengine.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), CreateInstance: CreateInstance::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSharingEngineClassFactory as windows_core::Interface>::IID
    }
}
pub trait IMFShutdown_Impl: Sized + windows_core::IUnknownImpl {
    fn Shutdown(&self) -> windows_core::Result<()>;
    fn GetShutdownStatus(&self) -> windows_core::Result<MFSHUTDOWN_STATUS>;
}
impl windows_core::RuntimeName for IMFShutdown {}
impl IMFShutdown_Vtbl {
    pub const fn new<Identity: IMFShutdown_Impl, const OFFSET: isize>() -> IMFShutdown_Vtbl {
        unsafe extern "system" fn Shutdown<Identity: IMFShutdown_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFShutdown_Impl::Shutdown(this).into()
        }
        unsafe extern "system" fn GetShutdownStatus<Identity: IMFShutdown_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstatus: *mut MFSHUTDOWN_STATUS) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFShutdown_Impl::GetShutdownStatus(this) {
                Ok(ok__) => {
                    pstatus.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Shutdown: Shutdown::<Identity, OFFSET>,
            GetShutdownStatus: GetShutdownStatus::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFShutdown as windows_core::Interface>::IID
    }
}
pub trait IMFSignedLibrary_Impl: Sized + windows_core::IUnknownImpl {
    fn GetProcedureAddress(&self, name: &windows_core::PCSTR, address: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFSignedLibrary {}
impl IMFSignedLibrary_Vtbl {
    pub const fn new<Identity: IMFSignedLibrary_Impl, const OFFSET: isize>() -> IMFSignedLibrary_Vtbl {
        unsafe extern "system" fn GetProcedureAddress<Identity: IMFSignedLibrary_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, name: windows_core::PCSTR, address: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSignedLibrary_Impl::GetProcedureAddress(this, core::mem::transmute(&name), core::mem::transmute_copy(&address)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetProcedureAddress: GetProcedureAddress::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSignedLibrary as windows_core::Interface>::IID
    }
}
pub trait IMFSimpleAudioVolume_Impl: Sized + windows_core::IUnknownImpl {
    fn SetMasterVolume(&self, flevel: f32) -> windows_core::Result<()>;
    fn GetMasterVolume(&self) -> windows_core::Result<f32>;
    fn SetMute(&self, bmute: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn GetMute(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
}
impl windows_core::RuntimeName for IMFSimpleAudioVolume {}
impl IMFSimpleAudioVolume_Vtbl {
    pub const fn new<Identity: IMFSimpleAudioVolume_Impl, const OFFSET: isize>() -> IMFSimpleAudioVolume_Vtbl {
        unsafe extern "system" fn SetMasterVolume<Identity: IMFSimpleAudioVolume_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, flevel: f32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSimpleAudioVolume_Impl::SetMasterVolume(this, core::mem::transmute_copy(&flevel)).into()
        }
        unsafe extern "system" fn GetMasterVolume<Identity: IMFSimpleAudioVolume_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pflevel: *mut f32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSimpleAudioVolume_Impl::GetMasterVolume(this) {
                Ok(ok__) => {
                    pflevel.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMute<Identity: IMFSimpleAudioVolume_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bmute: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSimpleAudioVolume_Impl::SetMute(this, core::mem::transmute_copy(&bmute)).into()
        }
        unsafe extern "system" fn GetMute<Identity: IMFSimpleAudioVolume_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbmute: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSimpleAudioVolume_Impl::GetMute(this) {
                Ok(ok__) => {
                    pbmute.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetMasterVolume: SetMasterVolume::<Identity, OFFSET>,
            GetMasterVolume: GetMasterVolume::<Identity, OFFSET>,
            SetMute: SetMute::<Identity, OFFSET>,
            GetMute: GetMute::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSimpleAudioVolume as windows_core::Interface>::IID
    }
}
pub trait IMFSinkWriter_Impl: Sized + windows_core::IUnknownImpl {
    fn AddStream(&self, ptargetmediatype: Option<&IMFMediaType>) -> windows_core::Result<u32>;
    fn SetInputMediaType(&self, dwstreamindex: u32, pinputmediatype: Option<&IMFMediaType>, pencodingparameters: Option<&IMFAttributes>) -> windows_core::Result<()>;
    fn BeginWriting(&self) -> windows_core::Result<()>;
    fn WriteSample(&self, dwstreamindex: u32, psample: Option<&IMFSample>) -> windows_core::Result<()>;
    fn SendStreamTick(&self, dwstreamindex: u32, lltimestamp: i64) -> windows_core::Result<()>;
    fn PlaceMarker(&self, dwstreamindex: u32, pvcontext: *const core::ffi::c_void) -> windows_core::Result<()>;
    fn NotifyEndOfSegment(&self, dwstreamindex: u32) -> windows_core::Result<()>;
    fn Flush(&self, dwstreamindex: u32) -> windows_core::Result<()>;
    fn Finalize(&self) -> windows_core::Result<()>;
    fn GetServiceForStream(&self, dwstreamindex: u32, guidservice: *const windows_core::GUID, riid: *const windows_core::GUID, ppvobject: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn GetStatistics(&self, dwstreamindex: u32, pstats: *mut MF_SINK_WRITER_STATISTICS) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFSinkWriter {}
impl IMFSinkWriter_Vtbl {
    pub const fn new<Identity: IMFSinkWriter_Impl, const OFFSET: isize>() -> IMFSinkWriter_Vtbl {
        unsafe extern "system" fn AddStream<Identity: IMFSinkWriter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptargetmediatype: *mut core::ffi::c_void, pdwstreamindex: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSinkWriter_Impl::AddStream(this, windows_core::from_raw_borrowed(&ptargetmediatype)) {
                Ok(ok__) => {
                    pdwstreamindex.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputMediaType<Identity: IMFSinkWriter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, pinputmediatype: *mut core::ffi::c_void, pencodingparameters: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSinkWriter_Impl::SetInputMediaType(this, core::mem::transmute_copy(&dwstreamindex), windows_core::from_raw_borrowed(&pinputmediatype), windows_core::from_raw_borrowed(&pencodingparameters)).into()
        }
        unsafe extern "system" fn BeginWriting<Identity: IMFSinkWriter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSinkWriter_Impl::BeginWriting(this).into()
        }
        unsafe extern "system" fn WriteSample<Identity: IMFSinkWriter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, psample: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSinkWriter_Impl::WriteSample(this, core::mem::transmute_copy(&dwstreamindex), windows_core::from_raw_borrowed(&psample)).into()
        }
        unsafe extern "system" fn SendStreamTick<Identity: IMFSinkWriter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, lltimestamp: i64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSinkWriter_Impl::SendStreamTick(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&lltimestamp)).into()
        }
        unsafe extern "system" fn PlaceMarker<Identity: IMFSinkWriter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, pvcontext: *const core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSinkWriter_Impl::PlaceMarker(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&pvcontext)).into()
        }
        unsafe extern "system" fn NotifyEndOfSegment<Identity: IMFSinkWriter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSinkWriter_Impl::NotifyEndOfSegment(this, core::mem::transmute_copy(&dwstreamindex)).into()
        }
        unsafe extern "system" fn Flush<Identity: IMFSinkWriter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSinkWriter_Impl::Flush(this, core::mem::transmute_copy(&dwstreamindex)).into()
        }
        unsafe extern "system" fn Finalize<Identity: IMFSinkWriter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSinkWriter_Impl::Finalize(this).into()
        }
        unsafe extern "system" fn GetServiceForStream<Identity: IMFSinkWriter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, guidservice: *const windows_core::GUID, riid: *const windows_core::GUID, ppvobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSinkWriter_Impl::GetServiceForStream(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&guidservice), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvobject)).into()
        }
        unsafe extern "system" fn GetStatistics<Identity: IMFSinkWriter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, pstats: *mut MF_SINK_WRITER_STATISTICS) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSinkWriter_Impl::GetStatistics(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&pstats)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            AddStream: AddStream::<Identity, OFFSET>,
            SetInputMediaType: SetInputMediaType::<Identity, OFFSET>,
            BeginWriting: BeginWriting::<Identity, OFFSET>,
            WriteSample: WriteSample::<Identity, OFFSET>,
            SendStreamTick: SendStreamTick::<Identity, OFFSET>,
            PlaceMarker: PlaceMarker::<Identity, OFFSET>,
            NotifyEndOfSegment: NotifyEndOfSegment::<Identity, OFFSET>,
            Flush: Flush::<Identity, OFFSET>,
            Finalize: Finalize::<Identity, OFFSET>,
            GetServiceForStream: GetServiceForStream::<Identity, OFFSET>,
            GetStatistics: GetStatistics::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSinkWriter as windows_core::Interface>::IID
    }
}
pub trait IMFSinkWriterCallback_Impl: Sized + windows_core::IUnknownImpl {
    fn OnFinalize(&self, hrstatus: windows_core::HRESULT) -> windows_core::Result<()>;
    fn OnMarker(&self, dwstreamindex: u32, pvcontext: *const core::ffi::c_void) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFSinkWriterCallback {}
impl IMFSinkWriterCallback_Vtbl {
    pub const fn new<Identity: IMFSinkWriterCallback_Impl, const OFFSET: isize>() -> IMFSinkWriterCallback_Vtbl {
        unsafe extern "system" fn OnFinalize<Identity: IMFSinkWriterCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hrstatus: windows_core::HRESULT) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSinkWriterCallback_Impl::OnFinalize(this, core::mem::transmute_copy(&hrstatus)).into()
        }
        unsafe extern "system" fn OnMarker<Identity: IMFSinkWriterCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, pvcontext: *const core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSinkWriterCallback_Impl::OnMarker(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&pvcontext)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            OnFinalize: OnFinalize::<Identity, OFFSET>,
            OnMarker: OnMarker::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSinkWriterCallback as windows_core::Interface>::IID
    }
}
pub trait IMFSinkWriterCallback2_Impl: Sized + IMFSinkWriterCallback_Impl {
    fn OnTransformChange(&self) -> windows_core::Result<()>;
    fn OnStreamError(&self, dwstreamindex: u32, hrstatus: windows_core::HRESULT) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFSinkWriterCallback2 {}
impl IMFSinkWriterCallback2_Vtbl {
    pub const fn new<Identity: IMFSinkWriterCallback2_Impl, const OFFSET: isize>() -> IMFSinkWriterCallback2_Vtbl {
        unsafe extern "system" fn OnTransformChange<Identity: IMFSinkWriterCallback2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSinkWriterCallback2_Impl::OnTransformChange(this).into()
        }
        unsafe extern "system" fn OnStreamError<Identity: IMFSinkWriterCallback2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, hrstatus: windows_core::HRESULT) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSinkWriterCallback2_Impl::OnStreamError(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&hrstatus)).into()
        }
        Self {
            base__: IMFSinkWriterCallback_Vtbl::new::<Identity, OFFSET>(),
            OnTransformChange: OnTransformChange::<Identity, OFFSET>,
            OnStreamError: OnStreamError::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSinkWriterCallback2 as windows_core::Interface>::IID || iid == &<IMFSinkWriterCallback as windows_core::Interface>::IID
    }
}
pub trait IMFSinkWriterEncoderConfig_Impl: Sized + windows_core::IUnknownImpl {
    fn SetTargetMediaType(&self, dwstreamindex: u32, ptargetmediatype: Option<&IMFMediaType>, pencodingparameters: Option<&IMFAttributes>) -> windows_core::Result<()>;
    fn PlaceEncodingParameters(&self, dwstreamindex: u32, pencodingparameters: Option<&IMFAttributes>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFSinkWriterEncoderConfig {}
impl IMFSinkWriterEncoderConfig_Vtbl {
    pub const fn new<Identity: IMFSinkWriterEncoderConfig_Impl, const OFFSET: isize>() -> IMFSinkWriterEncoderConfig_Vtbl {
        unsafe extern "system" fn SetTargetMediaType<Identity: IMFSinkWriterEncoderConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, ptargetmediatype: *mut core::ffi::c_void, pencodingparameters: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSinkWriterEncoderConfig_Impl::SetTargetMediaType(this, core::mem::transmute_copy(&dwstreamindex), windows_core::from_raw_borrowed(&ptargetmediatype), windows_core::from_raw_borrowed(&pencodingparameters)).into()
        }
        unsafe extern "system" fn PlaceEncodingParameters<Identity: IMFSinkWriterEncoderConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, pencodingparameters: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSinkWriterEncoderConfig_Impl::PlaceEncodingParameters(this, core::mem::transmute_copy(&dwstreamindex), windows_core::from_raw_borrowed(&pencodingparameters)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetTargetMediaType: SetTargetMediaType::<Identity, OFFSET>,
            PlaceEncodingParameters: PlaceEncodingParameters::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSinkWriterEncoderConfig as windows_core::Interface>::IID
    }
}
pub trait IMFSinkWriterEx_Impl: Sized + IMFSinkWriter_Impl {
    fn GetTransformForStream(&self, dwstreamindex: u32, dwtransformindex: u32, pguidcategory: *mut windows_core::GUID, pptransform: *mut Option<IMFTransform>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFSinkWriterEx {}
impl IMFSinkWriterEx_Vtbl {
    pub const fn new<Identity: IMFSinkWriterEx_Impl, const OFFSET: isize>() -> IMFSinkWriterEx_Vtbl {
        unsafe extern "system" fn GetTransformForStream<Identity: IMFSinkWriterEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, dwtransformindex: u32, pguidcategory: *mut windows_core::GUID, pptransform: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSinkWriterEx_Impl::GetTransformForStream(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&dwtransformindex), core::mem::transmute_copy(&pguidcategory), core::mem::transmute_copy(&pptransform)).into()
        }
        Self { base__: IMFSinkWriter_Vtbl::new::<Identity, OFFSET>(), GetTransformForStream: GetTransformForStream::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSinkWriterEx as windows_core::Interface>::IID || iid == &<IMFSinkWriter as windows_core::Interface>::IID
    }
}
pub trait IMFSourceBuffer_Impl: Sized + windows_core::IUnknownImpl {
    fn GetUpdating(&self) -> super::super::Foundation::BOOL;
    fn GetBuffered(&self) -> windows_core::Result<IMFMediaTimeRange>;
    fn GetTimeStampOffset(&self) -> f64;
    fn SetTimeStampOffset(&self, offset: f64) -> windows_core::Result<()>;
    fn GetAppendWindowStart(&self) -> f64;
    fn SetAppendWindowStart(&self, time: f64) -> windows_core::Result<()>;
    fn GetAppendWindowEnd(&self) -> f64;
    fn SetAppendWindowEnd(&self, time: f64) -> windows_core::Result<()>;
    fn Append(&self, pdata: *const u8, len: u32) -> windows_core::Result<()>;
    fn AppendByteStream(&self, pstream: Option<&IMFByteStream>, pmaxlen: *const u64) -> windows_core::Result<()>;
    fn Abort(&self) -> windows_core::Result<()>;
    fn Remove(&self, start: f64, end: f64) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFSourceBuffer {}
impl IMFSourceBuffer_Vtbl {
    pub const fn new<Identity: IMFSourceBuffer_Impl, const OFFSET: isize>() -> IMFSourceBuffer_Vtbl {
        unsafe extern "system" fn GetUpdating<Identity: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceBuffer_Impl::GetUpdating(this)
        }
        unsafe extern "system" fn GetBuffered<Identity: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppbuffered: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSourceBuffer_Impl::GetBuffered(this) {
                Ok(ok__) => {
                    ppbuffered.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTimeStampOffset<Identity: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> f64 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceBuffer_Impl::GetTimeStampOffset(this)
        }
        unsafe extern "system" fn SetTimeStampOffset<Identity: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, offset: f64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceBuffer_Impl::SetTimeStampOffset(this, core::mem::transmute_copy(&offset)).into()
        }
        unsafe extern "system" fn GetAppendWindowStart<Identity: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> f64 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceBuffer_Impl::GetAppendWindowStart(this)
        }
        unsafe extern "system" fn SetAppendWindowStart<Identity: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, time: f64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceBuffer_Impl::SetAppendWindowStart(this, core::mem::transmute_copy(&time)).into()
        }
        unsafe extern "system" fn GetAppendWindowEnd<Identity: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> f64 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceBuffer_Impl::GetAppendWindowEnd(this)
        }
        unsafe extern "system" fn SetAppendWindowEnd<Identity: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, time: f64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceBuffer_Impl::SetAppendWindowEnd(this, core::mem::transmute_copy(&time)).into()
        }
        unsafe extern "system" fn Append<Identity: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdata: *const u8, len: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceBuffer_Impl::Append(this, core::mem::transmute_copy(&pdata), core::mem::transmute_copy(&len)).into()
        }
        unsafe extern "system" fn AppendByteStream<Identity: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pstream: *mut core::ffi::c_void, pmaxlen: *const u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceBuffer_Impl::AppendByteStream(this, windows_core::from_raw_borrowed(&pstream), core::mem::transmute_copy(&pmaxlen)).into()
        }
        unsafe extern "system" fn Abort<Identity: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceBuffer_Impl::Abort(this).into()
        }
        unsafe extern "system" fn Remove<Identity: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, start: f64, end: f64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceBuffer_Impl::Remove(this, core::mem::transmute_copy(&start), core::mem::transmute_copy(&end)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetUpdating: GetUpdating::<Identity, OFFSET>,
            GetBuffered: GetBuffered::<Identity, OFFSET>,
            GetTimeStampOffset: GetTimeStampOffset::<Identity, OFFSET>,
            SetTimeStampOffset: SetTimeStampOffset::<Identity, OFFSET>,
            GetAppendWindowStart: GetAppendWindowStart::<Identity, OFFSET>,
            SetAppendWindowStart: SetAppendWindowStart::<Identity, OFFSET>,
            GetAppendWindowEnd: GetAppendWindowEnd::<Identity, OFFSET>,
            SetAppendWindowEnd: SetAppendWindowEnd::<Identity, OFFSET>,
            Append: Append::<Identity, OFFSET>,
            AppendByteStream: AppendByteStream::<Identity, OFFSET>,
            Abort: Abort::<Identity, OFFSET>,
            Remove: Remove::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSourceBuffer as windows_core::Interface>::IID
    }
}
pub trait IMFSourceBufferAppendMode_Impl: Sized + windows_core::IUnknownImpl {
    fn GetAppendMode(&self) -> MF_MSE_APPEND_MODE;
    fn SetAppendMode(&self, mode: MF_MSE_APPEND_MODE) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFSourceBufferAppendMode {}
impl IMFSourceBufferAppendMode_Vtbl {
    pub const fn new<Identity: IMFSourceBufferAppendMode_Impl, const OFFSET: isize>() -> IMFSourceBufferAppendMode_Vtbl {
        unsafe extern "system" fn GetAppendMode<Identity: IMFSourceBufferAppendMode_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> MF_MSE_APPEND_MODE {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceBufferAppendMode_Impl::GetAppendMode(this)
        }
        unsafe extern "system" fn SetAppendMode<Identity: IMFSourceBufferAppendMode_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, mode: MF_MSE_APPEND_MODE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceBufferAppendMode_Impl::SetAppendMode(this, core::mem::transmute_copy(&mode)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetAppendMode: GetAppendMode::<Identity, OFFSET>,
            SetAppendMode: SetAppendMode::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSourceBufferAppendMode as windows_core::Interface>::IID
    }
}
pub trait IMFSourceBufferList_Impl: Sized + windows_core::IUnknownImpl {
    fn GetLength(&self) -> u32;
    fn GetSourceBuffer(&self, index: u32) -> Option<IMFSourceBuffer>;
}
impl windows_core::RuntimeName for IMFSourceBufferList {}
impl IMFSourceBufferList_Vtbl {
    pub const fn new<Identity: IMFSourceBufferList_Impl, const OFFSET: isize>() -> IMFSourceBufferList_Vtbl {
        unsafe extern "system" fn GetLength<Identity: IMFSourceBufferList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u32 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceBufferList_Impl::GetLength(this)
        }
        unsafe extern "system" fn GetSourceBuffer<Identity: IMFSourceBufferList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, index: u32) -> Option<IMFSourceBuffer> {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceBufferList_Impl::GetSourceBuffer(this, core::mem::transmute_copy(&index))
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetLength: GetLength::<Identity, OFFSET>,
            GetSourceBuffer: GetSourceBuffer::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSourceBufferList as windows_core::Interface>::IID
    }
}
pub trait IMFSourceBufferNotify_Impl: Sized + windows_core::IUnknownImpl {
    fn OnUpdateStart(&self);
    fn OnAbort(&self);
    fn OnError(&self, hr: windows_core::HRESULT);
    fn OnUpdate(&self);
    fn OnUpdateEnd(&self);
}
impl windows_core::RuntimeName for IMFSourceBufferNotify {}
impl IMFSourceBufferNotify_Vtbl {
    pub const fn new<Identity: IMFSourceBufferNotify_Impl, const OFFSET: isize>() -> IMFSourceBufferNotify_Vtbl {
        unsafe extern "system" fn OnUpdateStart<Identity: IMFSourceBufferNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceBufferNotify_Impl::OnUpdateStart(this)
        }
        unsafe extern "system" fn OnAbort<Identity: IMFSourceBufferNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceBufferNotify_Impl::OnAbort(this)
        }
        unsafe extern "system" fn OnError<Identity: IMFSourceBufferNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hr: windows_core::HRESULT) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceBufferNotify_Impl::OnError(this, core::mem::transmute_copy(&hr))
        }
        unsafe extern "system" fn OnUpdate<Identity: IMFSourceBufferNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceBufferNotify_Impl::OnUpdate(this)
        }
        unsafe extern "system" fn OnUpdateEnd<Identity: IMFSourceBufferNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceBufferNotify_Impl::OnUpdateEnd(this)
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            OnUpdateStart: OnUpdateStart::<Identity, OFFSET>,
            OnAbort: OnAbort::<Identity, OFFSET>,
            OnError: OnError::<Identity, OFFSET>,
            OnUpdate: OnUpdate::<Identity, OFFSET>,
            OnUpdateEnd: OnUpdateEnd::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSourceBufferNotify as windows_core::Interface>::IID
    }
}
pub trait IMFSourceOpenMonitor_Impl: Sized + windows_core::IUnknownImpl {
    fn OnSourceEvent(&self, pevent: Option<&IMFMediaEvent>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFSourceOpenMonitor {}
impl IMFSourceOpenMonitor_Vtbl {
    pub const fn new<Identity: IMFSourceOpenMonitor_Impl, const OFFSET: isize>() -> IMFSourceOpenMonitor_Vtbl {
        unsafe extern "system" fn OnSourceEvent<Identity: IMFSourceOpenMonitor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pevent: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceOpenMonitor_Impl::OnSourceEvent(this, windows_core::from_raw_borrowed(&pevent)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), OnSourceEvent: OnSourceEvent::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSourceOpenMonitor as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFSourceReader_Impl: Sized + windows_core::IUnknownImpl {
    fn GetStreamSelection(&self, dwstreamindex: u32) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn SetStreamSelection(&self, dwstreamindex: u32, fselected: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn GetNativeMediaType(&self, dwstreamindex: u32, dwmediatypeindex: u32) -> windows_core::Result<IMFMediaType>;
    fn GetCurrentMediaType(&self, dwstreamindex: u32) -> windows_core::Result<IMFMediaType>;
    fn SetCurrentMediaType(&self, dwstreamindex: u32, pdwreserved: *const u32, pmediatype: Option<&IMFMediaType>) -> windows_core::Result<()>;
    fn SetCurrentPosition(&self, guidtimeformat: *const windows_core::GUID, varposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> windows_core::Result<()>;
    fn ReadSample(&self, dwstreamindex: u32, dwcontrolflags: u32, pdwactualstreamindex: *mut u32, pdwstreamflags: *mut u32, plltimestamp: *mut i64, ppsample: *mut Option<IMFSample>) -> windows_core::Result<()>;
    fn Flush(&self, dwstreamindex: u32) -> windows_core::Result<()>;
    fn GetServiceForStream(&self, dwstreamindex: u32, guidservice: *const windows_core::GUID, riid: *const windows_core::GUID, ppvobject: *mut *mut core::ffi::c_void) -> windows_core::Result<()>;
    fn GetPresentationAttribute(&self, dwstreamindex: u32, guidattribute: *const windows_core::GUID) -> windows_core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFSourceReader {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFSourceReader_Vtbl {
    pub const fn new<Identity: IMFSourceReader_Impl, const OFFSET: isize>() -> IMFSourceReader_Vtbl {
        unsafe extern "system" fn GetStreamSelection<Identity: IMFSourceReader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, pfselected: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSourceReader_Impl::GetStreamSelection(this, core::mem::transmute_copy(&dwstreamindex)) {
                Ok(ok__) => {
                    pfselected.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamSelection<Identity: IMFSourceReader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, fselected: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceReader_Impl::SetStreamSelection(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&fselected)).into()
        }
        unsafe extern "system" fn GetNativeMediaType<Identity: IMFSourceReader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, dwmediatypeindex: u32, ppmediatype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSourceReader_Impl::GetNativeMediaType(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&dwmediatypeindex)) {
                Ok(ok__) => {
                    ppmediatype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentMediaType<Identity: IMFSourceReader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, ppmediatype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSourceReader_Impl::GetCurrentMediaType(this, core::mem::transmute_copy(&dwstreamindex)) {
                Ok(ok__) => {
                    ppmediatype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentMediaType<Identity: IMFSourceReader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, pdwreserved: *const u32, pmediatype: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceReader_Impl::SetCurrentMediaType(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&pdwreserved), windows_core::from_raw_borrowed(&pmediatype)).into()
        }
        unsafe extern "system" fn SetCurrentPosition<Identity: IMFSourceReader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidtimeformat: *const windows_core::GUID, varposition: *const core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceReader_Impl::SetCurrentPosition(this, core::mem::transmute_copy(&guidtimeformat), core::mem::transmute_copy(&varposition)).into()
        }
        unsafe extern "system" fn ReadSample<Identity: IMFSourceReader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, dwcontrolflags: u32, pdwactualstreamindex: *mut u32, pdwstreamflags: *mut u32, plltimestamp: *mut i64, ppsample: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceReader_Impl::ReadSample(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&dwcontrolflags), core::mem::transmute_copy(&pdwactualstreamindex), core::mem::transmute_copy(&pdwstreamflags), core::mem::transmute_copy(&plltimestamp), core::mem::transmute_copy(&ppsample)).into()
        }
        unsafe extern "system" fn Flush<Identity: IMFSourceReader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceReader_Impl::Flush(this, core::mem::transmute_copy(&dwstreamindex)).into()
        }
        unsafe extern "system" fn GetServiceForStream<Identity: IMFSourceReader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, guidservice: *const windows_core::GUID, riid: *const windows_core::GUID, ppvobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceReader_Impl::GetServiceForStream(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&guidservice), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvobject)).into()
        }
        unsafe extern "system" fn GetPresentationAttribute<Identity: IMFSourceReader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, guidattribute: *const windows_core::GUID, pvarattribute: *mut core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSourceReader_Impl::GetPresentationAttribute(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&guidattribute)) {
                Ok(ok__) => {
                    pvarattribute.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetStreamSelection: GetStreamSelection::<Identity, OFFSET>,
            SetStreamSelection: SetStreamSelection::<Identity, OFFSET>,
            GetNativeMediaType: GetNativeMediaType::<Identity, OFFSET>,
            GetCurrentMediaType: GetCurrentMediaType::<Identity, OFFSET>,
            SetCurrentMediaType: SetCurrentMediaType::<Identity, OFFSET>,
            SetCurrentPosition: SetCurrentPosition::<Identity, OFFSET>,
            ReadSample: ReadSample::<Identity, OFFSET>,
            Flush: Flush::<Identity, OFFSET>,
            GetServiceForStream: GetServiceForStream::<Identity, OFFSET>,
            GetPresentationAttribute: GetPresentationAttribute::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSourceReader as windows_core::Interface>::IID
    }
}
pub trait IMFSourceReaderCallback_Impl: Sized + windows_core::IUnknownImpl {
    fn OnReadSample(&self, hrstatus: windows_core::HRESULT, dwstreamindex: u32, dwstreamflags: u32, lltimestamp: i64, psample: Option<&IMFSample>) -> windows_core::Result<()>;
    fn OnFlush(&self, dwstreamindex: u32) -> windows_core::Result<()>;
    fn OnEvent(&self, dwstreamindex: u32, pevent: Option<&IMFMediaEvent>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFSourceReaderCallback {}
impl IMFSourceReaderCallback_Vtbl {
    pub const fn new<Identity: IMFSourceReaderCallback_Impl, const OFFSET: isize>() -> IMFSourceReaderCallback_Vtbl {
        unsafe extern "system" fn OnReadSample<Identity: IMFSourceReaderCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hrstatus: windows_core::HRESULT, dwstreamindex: u32, dwstreamflags: u32, lltimestamp: i64, psample: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceReaderCallback_Impl::OnReadSample(this, core::mem::transmute_copy(&hrstatus), core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&dwstreamflags), core::mem::transmute_copy(&lltimestamp), windows_core::from_raw_borrowed(&psample)).into()
        }
        unsafe extern "system" fn OnFlush<Identity: IMFSourceReaderCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceReaderCallback_Impl::OnFlush(this, core::mem::transmute_copy(&dwstreamindex)).into()
        }
        unsafe extern "system" fn OnEvent<Identity: IMFSourceReaderCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, pevent: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceReaderCallback_Impl::OnEvent(this, core::mem::transmute_copy(&dwstreamindex), windows_core::from_raw_borrowed(&pevent)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            OnReadSample: OnReadSample::<Identity, OFFSET>,
            OnFlush: OnFlush::<Identity, OFFSET>,
            OnEvent: OnEvent::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSourceReaderCallback as windows_core::Interface>::IID
    }
}
pub trait IMFSourceReaderCallback2_Impl: Sized + IMFSourceReaderCallback_Impl {
    fn OnTransformChange(&self) -> windows_core::Result<()>;
    fn OnStreamError(&self, dwstreamindex: u32, hrstatus: windows_core::HRESULT) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFSourceReaderCallback2 {}
impl IMFSourceReaderCallback2_Vtbl {
    pub const fn new<Identity: IMFSourceReaderCallback2_Impl, const OFFSET: isize>() -> IMFSourceReaderCallback2_Vtbl {
        unsafe extern "system" fn OnTransformChange<Identity: IMFSourceReaderCallback2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceReaderCallback2_Impl::OnTransformChange(this).into()
        }
        unsafe extern "system" fn OnStreamError<Identity: IMFSourceReaderCallback2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, hrstatus: windows_core::HRESULT) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceReaderCallback2_Impl::OnStreamError(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&hrstatus)).into()
        }
        Self {
            base__: IMFSourceReaderCallback_Vtbl::new::<Identity, OFFSET>(),
            OnTransformChange: OnTransformChange::<Identity, OFFSET>,
            OnStreamError: OnStreamError::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSourceReaderCallback2 as windows_core::Interface>::IID || iid == &<IMFSourceReaderCallback as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFSourceReaderEx_Impl: Sized + IMFSourceReader_Impl {
    fn SetNativeMediaType(&self, dwstreamindex: u32, pmediatype: Option<&IMFMediaType>) -> windows_core::Result<u32>;
    fn AddTransformForStream(&self, dwstreamindex: u32, ptransformoractivate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn RemoveAllTransformsForStream(&self, dwstreamindex: u32) -> windows_core::Result<()>;
    fn GetTransformForStream(&self, dwstreamindex: u32, dwtransformindex: u32, pguidcategory: *mut windows_core::GUID, pptransform: *mut Option<IMFTransform>) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFSourceReaderEx {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFSourceReaderEx_Vtbl {
    pub const fn new<Identity: IMFSourceReaderEx_Impl, const OFFSET: isize>() -> IMFSourceReaderEx_Vtbl {
        unsafe extern "system" fn SetNativeMediaType<Identity: IMFSourceReaderEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, pmediatype: *mut core::ffi::c_void, pdwstreamflags: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSourceReaderEx_Impl::SetNativeMediaType(this, core::mem::transmute_copy(&dwstreamindex), windows_core::from_raw_borrowed(&pmediatype)) {
                Ok(ok__) => {
                    pdwstreamflags.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddTransformForStream<Identity: IMFSourceReaderEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, ptransformoractivate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceReaderEx_Impl::AddTransformForStream(this, core::mem::transmute_copy(&dwstreamindex), windows_core::from_raw_borrowed(&ptransformoractivate)).into()
        }
        unsafe extern "system" fn RemoveAllTransformsForStream<Identity: IMFSourceReaderEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceReaderEx_Impl::RemoveAllTransformsForStream(this, core::mem::transmute_copy(&dwstreamindex)).into()
        }
        unsafe extern "system" fn GetTransformForStream<Identity: IMFSourceReaderEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamindex: u32, dwtransformindex: u32, pguidcategory: *mut windows_core::GUID, pptransform: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceReaderEx_Impl::GetTransformForStream(this, core::mem::transmute_copy(&dwstreamindex), core::mem::transmute_copy(&dwtransformindex), core::mem::transmute_copy(&pguidcategory), core::mem::transmute_copy(&pptransform)).into()
        }
        Self {
            base__: IMFSourceReader_Vtbl::new::<Identity, OFFSET>(),
            SetNativeMediaType: SetNativeMediaType::<Identity, OFFSET>,
            AddTransformForStream: AddTransformForStream::<Identity, OFFSET>,
            RemoveAllTransformsForStream: RemoveAllTransformsForStream::<Identity, OFFSET>,
            GetTransformForStream: GetTransformForStream::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSourceReaderEx as windows_core::Interface>::IID || iid == &<IMFSourceReader as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub trait IMFSourceResolver_Impl: Sized + windows_core::IUnknownImpl {
    fn CreateObjectFromURL(&self, pwszurl: &windows_core::PCWSTR, dwflags: u32, pprops: Option<&super::super::UI::Shell::PropertiesSystem::IPropertyStore>, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut Option<windows_core::IUnknown>) -> windows_core::Result<()>;
    fn CreateObjectFromByteStream(&self, pbytestream: Option<&IMFByteStream>, pwszurl: &windows_core::PCWSTR, dwflags: u32, pprops: Option<&super::super::UI::Shell::PropertiesSystem::IPropertyStore>, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut Option<windows_core::IUnknown>) -> windows_core::Result<()>;
    fn BeginCreateObjectFromURL(&self, pwszurl: &windows_core::PCWSTR, dwflags: u32, pprops: Option<&super::super::UI::Shell::PropertiesSystem::IPropertyStore>, ppiunknowncancelcookie: *mut Option<windows_core::IUnknown>, pcallback: Option<&IMFAsyncCallback>, punkstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndCreateObjectFromURL(&self, presult: Option<&IMFAsyncResult>, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut Option<windows_core::IUnknown>) -> windows_core::Result<()>;
    fn BeginCreateObjectFromByteStream(&self, pbytestream: Option<&IMFByteStream>, pwszurl: &windows_core::PCWSTR, dwflags: u32, pprops: Option<&super::super::UI::Shell::PropertiesSystem::IPropertyStore>, ppiunknowncancelcookie: *mut Option<windows_core::IUnknown>, pcallback: Option<&IMFAsyncCallback>, punkstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndCreateObjectFromByteStream(&self, presult: Option<&IMFAsyncResult>, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut Option<windows_core::IUnknown>) -> windows_core::Result<()>;
    fn CancelObjectCreation(&self, piunknowncancelcookie: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl windows_core::RuntimeName for IMFSourceResolver {}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl IMFSourceResolver_Vtbl {
    pub const fn new<Identity: IMFSourceResolver_Impl, const OFFSET: isize>() -> IMFSourceResolver_Vtbl {
        unsafe extern "system" fn CreateObjectFromURL<Identity: IMFSourceResolver_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwszurl: windows_core::PCWSTR, dwflags: u32, pprops: *mut core::ffi::c_void, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceResolver_Impl::CreateObjectFromURL(this, core::mem::transmute(&pwszurl), core::mem::transmute_copy(&dwflags), windows_core::from_raw_borrowed(&pprops), core::mem::transmute_copy(&pobjecttype), core::mem::transmute_copy(&ppobject)).into()
        }
        unsafe extern "system" fn CreateObjectFromByteStream<Identity: IMFSourceResolver_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbytestream: *mut core::ffi::c_void, pwszurl: windows_core::PCWSTR, dwflags: u32, pprops: *mut core::ffi::c_void, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceResolver_Impl::CreateObjectFromByteStream(this, windows_core::from_raw_borrowed(&pbytestream), core::mem::transmute(&pwszurl), core::mem::transmute_copy(&dwflags), windows_core::from_raw_borrowed(&pprops), core::mem::transmute_copy(&pobjecttype), core::mem::transmute_copy(&ppobject)).into()
        }
        unsafe extern "system" fn BeginCreateObjectFromURL<Identity: IMFSourceResolver_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwszurl: windows_core::PCWSTR, dwflags: u32, pprops: *mut core::ffi::c_void, ppiunknowncancelcookie: *mut *mut core::ffi::c_void, pcallback: *mut core::ffi::c_void, punkstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceResolver_Impl::BeginCreateObjectFromURL(this, core::mem::transmute(&pwszurl), core::mem::transmute_copy(&dwflags), windows_core::from_raw_borrowed(&pprops), core::mem::transmute_copy(&ppiunknowncancelcookie), windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&punkstate)).into()
        }
        unsafe extern "system" fn EndCreateObjectFromURL<Identity: IMFSourceResolver_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceResolver_Impl::EndCreateObjectFromURL(this, windows_core::from_raw_borrowed(&presult), core::mem::transmute_copy(&pobjecttype), core::mem::transmute_copy(&ppobject)).into()
        }
        unsafe extern "system" fn BeginCreateObjectFromByteStream<Identity: IMFSourceResolver_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbytestream: *mut core::ffi::c_void, pwszurl: windows_core::PCWSTR, dwflags: u32, pprops: *mut core::ffi::c_void, ppiunknowncancelcookie: *mut *mut core::ffi::c_void, pcallback: *mut core::ffi::c_void, punkstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceResolver_Impl::BeginCreateObjectFromByteStream(this, windows_core::from_raw_borrowed(&pbytestream), core::mem::transmute(&pwszurl), core::mem::transmute_copy(&dwflags), windows_core::from_raw_borrowed(&pprops), core::mem::transmute_copy(&ppiunknowncancelcookie), windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&punkstate)).into()
        }
        unsafe extern "system" fn EndCreateObjectFromByteStream<Identity: IMFSourceResolver_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceResolver_Impl::EndCreateObjectFromByteStream(this, windows_core::from_raw_borrowed(&presult), core::mem::transmute_copy(&pobjecttype), core::mem::transmute_copy(&ppobject)).into()
        }
        unsafe extern "system" fn CancelObjectCreation<Identity: IMFSourceResolver_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, piunknowncancelcookie: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSourceResolver_Impl::CancelObjectCreation(this, windows_core::from_raw_borrowed(&piunknowncancelcookie)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            CreateObjectFromURL: CreateObjectFromURL::<Identity, OFFSET>,
            CreateObjectFromByteStream: CreateObjectFromByteStream::<Identity, OFFSET>,
            BeginCreateObjectFromURL: BeginCreateObjectFromURL::<Identity, OFFSET>,
            EndCreateObjectFromURL: EndCreateObjectFromURL::<Identity, OFFSET>,
            BeginCreateObjectFromByteStream: BeginCreateObjectFromByteStream::<Identity, OFFSET>,
            EndCreateObjectFromByteStream: EndCreateObjectFromByteStream::<Identity, OFFSET>,
            CancelObjectCreation: CancelObjectCreation::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSourceResolver as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_Audio")]
pub trait IMFSpatialAudioObjectBuffer_Impl: Sized + IMFMediaBuffer_Impl {
    fn SetID(&self, u32id: u32) -> windows_core::Result<()>;
    fn GetID(&self) -> windows_core::Result<u32>;
    fn SetType(&self, r#type: super::Audio::AudioObjectType) -> windows_core::Result<()>;
    fn GetType(&self) -> windows_core::Result<super::Audio::AudioObjectType>;
    fn GetMetadataItems(&self) -> windows_core::Result<super::Audio::ISpatialAudioMetadataItems>;
}
#[cfg(feature = "Win32_Media_Audio")]
impl windows_core::RuntimeName for IMFSpatialAudioObjectBuffer {}
#[cfg(feature = "Win32_Media_Audio")]
impl IMFSpatialAudioObjectBuffer_Vtbl {
    pub const fn new<Identity: IMFSpatialAudioObjectBuffer_Impl, const OFFSET: isize>() -> IMFSpatialAudioObjectBuffer_Vtbl {
        unsafe extern "system" fn SetID<Identity: IMFSpatialAudioObjectBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, u32id: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSpatialAudioObjectBuffer_Impl::SetID(this, core::mem::transmute_copy(&u32id)).into()
        }
        unsafe extern "system" fn GetID<Identity: IMFSpatialAudioObjectBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pu32id: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSpatialAudioObjectBuffer_Impl::GetID(this) {
                Ok(ok__) => {
                    pu32id.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetType<Identity: IMFSpatialAudioObjectBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, r#type: super::Audio::AudioObjectType) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSpatialAudioObjectBuffer_Impl::SetType(this, core::mem::transmute_copy(&r#type)).into()
        }
        unsafe extern "system" fn GetType<Identity: IMFSpatialAudioObjectBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptype: *mut super::Audio::AudioObjectType) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSpatialAudioObjectBuffer_Impl::GetType(this) {
                Ok(ok__) => {
                    ptype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMetadataItems<Identity: IMFSpatialAudioObjectBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppmetadataitems: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSpatialAudioObjectBuffer_Impl::GetMetadataItems(this) {
                Ok(ok__) => {
                    ppmetadataitems.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IMFMediaBuffer_Vtbl::new::<Identity, OFFSET>(),
            SetID: SetID::<Identity, OFFSET>,
            GetID: GetID::<Identity, OFFSET>,
            SetType: SetType::<Identity, OFFSET>,
            GetType: GetType::<Identity, OFFSET>,
            GetMetadataItems: GetMetadataItems::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSpatialAudioObjectBuffer as windows_core::Interface>::IID || iid == &<IMFMediaBuffer as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFSpatialAudioSample_Impl: Sized + IMFSample_Impl {
    fn GetObjectCount(&self) -> windows_core::Result<u32>;
    fn AddSpatialAudioObject(&self, paudioobjbuffer: Option<&IMFSpatialAudioObjectBuffer>) -> windows_core::Result<()>;
    fn GetSpatialAudioObjectByIndex(&self, dwindex: u32) -> windows_core::Result<IMFSpatialAudioObjectBuffer>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFSpatialAudioSample {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFSpatialAudioSample_Vtbl {
    pub const fn new<Identity: IMFSpatialAudioSample_Impl, const OFFSET: isize>() -> IMFSpatialAudioSample_Vtbl {
        unsafe extern "system" fn GetObjectCount<Identity: IMFSpatialAudioSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwobjectcount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSpatialAudioSample_Impl::GetObjectCount(this) {
                Ok(ok__) => {
                    pdwobjectcount.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddSpatialAudioObject<Identity: IMFSpatialAudioSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, paudioobjbuffer: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSpatialAudioSample_Impl::AddSpatialAudioObject(this, windows_core::from_raw_borrowed(&paudioobjbuffer)).into()
        }
        unsafe extern "system" fn GetSpatialAudioObjectByIndex<Identity: IMFSpatialAudioSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwindex: u32, ppaudioobjbuffer: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFSpatialAudioSample_Impl::GetSpatialAudioObjectByIndex(this, core::mem::transmute_copy(&dwindex)) {
                Ok(ok__) => {
                    ppaudioobjbuffer.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IMFSample_Vtbl::new::<Identity, OFFSET>(),
            GetObjectCount: GetObjectCount::<Identity, OFFSET>,
            AddSpatialAudioObject: AddSpatialAudioObject::<Identity, OFFSET>,
            GetSpatialAudioObjectByIndex: GetSpatialAudioObjectByIndex::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSpatialAudioSample as windows_core::Interface>::IID || iid == &<IMFAttributes as windows_core::Interface>::IID || iid == &<IMFSample as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFStreamDescriptor_Impl: Sized + IMFAttributes_Impl {
    fn GetStreamIdentifier(&self) -> windows_core::Result<u32>;
    fn GetMediaTypeHandler(&self) -> windows_core::Result<IMFMediaTypeHandler>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFStreamDescriptor {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFStreamDescriptor_Vtbl {
    pub const fn new<Identity: IMFStreamDescriptor_Impl, const OFFSET: isize>() -> IMFStreamDescriptor_Vtbl {
        unsafe extern "system" fn GetStreamIdentifier<Identity: IMFStreamDescriptor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwstreamidentifier: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFStreamDescriptor_Impl::GetStreamIdentifier(this) {
                Ok(ok__) => {
                    pdwstreamidentifier.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaTypeHandler<Identity: IMFStreamDescriptor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppmediatypehandler: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFStreamDescriptor_Impl::GetMediaTypeHandler(this) {
                Ok(ok__) => {
                    ppmediatypehandler.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IMFAttributes_Vtbl::new::<Identity, OFFSET>(),
            GetStreamIdentifier: GetStreamIdentifier::<Identity, OFFSET>,
            GetMediaTypeHandler: GetMediaTypeHandler::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFStreamDescriptor as windows_core::Interface>::IID || iid == &<IMFAttributes as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFStreamSink_Impl: Sized + IMFMediaEventGenerator_Impl {
    fn GetMediaSink(&self) -> windows_core::Result<IMFMediaSink>;
    fn GetIdentifier(&self) -> windows_core::Result<u32>;
    fn GetMediaTypeHandler(&self) -> windows_core::Result<IMFMediaTypeHandler>;
    fn ProcessSample(&self, psample: Option<&IMFSample>) -> windows_core::Result<()>;
    fn PlaceMarker(&self, emarkertype: MFSTREAMSINK_MARKER_TYPE, pvarmarkervalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pvarcontextvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> windows_core::Result<()>;
    fn Flush(&self) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFStreamSink {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFStreamSink_Vtbl {
    pub const fn new<Identity: IMFStreamSink_Impl, const OFFSET: isize>() -> IMFStreamSink_Vtbl {
        unsafe extern "system" fn GetMediaSink<Identity: IMFStreamSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppmediasink: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFStreamSink_Impl::GetMediaSink(this) {
                Ok(ok__) => {
                    ppmediasink.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIdentifier<Identity: IMFStreamSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwidentifier: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFStreamSink_Impl::GetIdentifier(this) {
                Ok(ok__) => {
                    pdwidentifier.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaTypeHandler<Identity: IMFStreamSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pphandler: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFStreamSink_Impl::GetMediaTypeHandler(this) {
                Ok(ok__) => {
                    pphandler.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProcessSample<Identity: IMFStreamSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psample: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFStreamSink_Impl::ProcessSample(this, windows_core::from_raw_borrowed(&psample)).into()
        }
        unsafe extern "system" fn PlaceMarker<Identity: IMFStreamSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, emarkertype: MFSTREAMSINK_MARKER_TYPE, pvarmarkervalue: *const core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>, pvarcontextvalue: *const core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFStreamSink_Impl::PlaceMarker(this, core::mem::transmute_copy(&emarkertype), core::mem::transmute_copy(&pvarmarkervalue), core::mem::transmute_copy(&pvarcontextvalue)).into()
        }
        unsafe extern "system" fn Flush<Identity: IMFStreamSink_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFStreamSink_Impl::Flush(this).into()
        }
        Self {
            base__: IMFMediaEventGenerator_Vtbl::new::<Identity, OFFSET>(),
            GetMediaSink: GetMediaSink::<Identity, OFFSET>,
            GetIdentifier: GetIdentifier::<Identity, OFFSET>,
            GetMediaTypeHandler: GetMediaTypeHandler::<Identity, OFFSET>,
            ProcessSample: ProcessSample::<Identity, OFFSET>,
            PlaceMarker: PlaceMarker::<Identity, OFFSET>,
            Flush: Flush::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFStreamSink as windows_core::Interface>::IID || iid == &<IMFMediaEventGenerator as windows_core::Interface>::IID
    }
}
pub trait IMFStreamingSinkConfig_Impl: Sized + windows_core::IUnknownImpl {
    fn StartStreaming(&self, fseekoffsetisbyteoffset: super::super::Foundation::BOOL, qwseekoffset: u64) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFStreamingSinkConfig {}
impl IMFStreamingSinkConfig_Vtbl {
    pub const fn new<Identity: IMFStreamingSinkConfig_Impl, const OFFSET: isize>() -> IMFStreamingSinkConfig_Vtbl {
        unsafe extern "system" fn StartStreaming<Identity: IMFStreamingSinkConfig_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fseekoffsetisbyteoffset: super::super::Foundation::BOOL, qwseekoffset: u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFStreamingSinkConfig_Impl::StartStreaming(this, core::mem::transmute_copy(&fseekoffsetisbyteoffset), core::mem::transmute_copy(&qwseekoffset)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), StartStreaming: StartStreaming::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFStreamingSinkConfig as windows_core::Interface>::IID
    }
}
pub trait IMFSystemId_Impl: Sized + windows_core::IUnknownImpl {
    fn GetData(&self, size: *mut u32, data: *mut *mut u8) -> windows_core::Result<()>;
    fn Setup(&self, stage: u32, cbin: u32, pbin: *const u8, pcbout: *mut u32, ppbout: *mut *mut u8) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFSystemId {}
impl IMFSystemId_Vtbl {
    pub const fn new<Identity: IMFSystemId_Impl, const OFFSET: isize>() -> IMFSystemId_Vtbl {
        unsafe extern "system" fn GetData<Identity: IMFSystemId_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, size: *mut u32, data: *mut *mut u8) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSystemId_Impl::GetData(this, core::mem::transmute_copy(&size), core::mem::transmute_copy(&data)).into()
        }
        unsafe extern "system" fn Setup<Identity: IMFSystemId_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, stage: u32, cbin: u32, pbin: *const u8, pcbout: *mut u32, ppbout: *mut *mut u8) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFSystemId_Impl::Setup(this, core::mem::transmute_copy(&stage), core::mem::transmute_copy(&cbin), core::mem::transmute_copy(&pbin), core::mem::transmute_copy(&pcbout), core::mem::transmute_copy(&ppbout)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetData: GetData::<Identity, OFFSET>, Setup: Setup::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFSystemId as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFTimecodeTranslate_Impl: Sized + windows_core::IUnknownImpl {
    fn BeginConvertTimecodeToHNS(&self, ppropvartimecode: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pcallback: Option<&IMFAsyncCallback>, punkstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndConvertTimecodeToHNS(&self, presult: Option<&IMFAsyncResult>) -> windows_core::Result<i64>;
    fn BeginConvertHNSToTimecode(&self, hnstime: i64, pcallback: Option<&IMFAsyncCallback>, punkstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndConvertHNSToTimecode(&self, presult: Option<&IMFAsyncResult>) -> windows_core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFTimecodeTranslate {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFTimecodeTranslate_Vtbl {
    pub const fn new<Identity: IMFTimecodeTranslate_Impl, const OFFSET: isize>() -> IMFTimecodeTranslate_Vtbl {
        unsafe extern "system" fn BeginConvertTimecodeToHNS<Identity: IMFTimecodeTranslate_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppropvartimecode: *const core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>, pcallback: *mut core::ffi::c_void, punkstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimecodeTranslate_Impl::BeginConvertTimecodeToHNS(this, core::mem::transmute_copy(&ppropvartimecode), windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&punkstate)).into()
        }
        unsafe extern "system" fn EndConvertTimecodeToHNS<Identity: IMFTimecodeTranslate_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void, phnstime: *mut i64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimecodeTranslate_Impl::EndConvertTimecodeToHNS(this, windows_core::from_raw_borrowed(&presult)) {
                Ok(ok__) => {
                    phnstime.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginConvertHNSToTimecode<Identity: IMFTimecodeTranslate_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hnstime: i64, pcallback: *mut core::ffi::c_void, punkstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimecodeTranslate_Impl::BeginConvertHNSToTimecode(this, core::mem::transmute_copy(&hnstime), windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&punkstate)).into()
        }
        unsafe extern "system" fn EndConvertHNSToTimecode<Identity: IMFTimecodeTranslate_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void, ppropvartimecode: *mut core::mem::MaybeUninit<super::super::System::Com::StructuredStorage::PROPVARIANT>) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimecodeTranslate_Impl::EndConvertHNSToTimecode(this, windows_core::from_raw_borrowed(&presult)) {
                Ok(ok__) => {
                    ppropvartimecode.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            BeginConvertTimecodeToHNS: BeginConvertTimecodeToHNS::<Identity, OFFSET>,
            EndConvertTimecodeToHNS: EndConvertTimecodeToHNS::<Identity, OFFSET>,
            BeginConvertHNSToTimecode: BeginConvertHNSToTimecode::<Identity, OFFSET>,
            EndConvertHNSToTimecode: EndConvertHNSToTimecode::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTimecodeTranslate as windows_core::Interface>::IID
    }
}
pub trait IMFTimedText_Impl: Sized + windows_core::IUnknownImpl {
    fn RegisterNotifications(&self, notify: Option<&IMFTimedTextNotify>) -> windows_core::Result<()>;
    fn SelectTrack(&self, trackid: u32, selected: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn AddDataSource(&self, bytestream: Option<&IMFByteStream>, label: &windows_core::PCWSTR, language: &windows_core::PCWSTR, kind: MF_TIMED_TEXT_TRACK_KIND, isdefault: super::super::Foundation::BOOL) -> windows_core::Result<u32>;
    fn AddDataSourceFromUrl(&self, url: &windows_core::PCWSTR, label: &windows_core::PCWSTR, language: &windows_core::PCWSTR, kind: MF_TIMED_TEXT_TRACK_KIND, isdefault: super::super::Foundation::BOOL) -> windows_core::Result<u32>;
    fn AddTrack(&self, label: &windows_core::PCWSTR, language: &windows_core::PCWSTR, kind: MF_TIMED_TEXT_TRACK_KIND) -> windows_core::Result<IMFTimedTextTrack>;
    fn RemoveTrack(&self, track: Option<&IMFTimedTextTrack>) -> windows_core::Result<()>;
    fn GetCueTimeOffset(&self) -> windows_core::Result<f64>;
    fn SetCueTimeOffset(&self, offset: f64) -> windows_core::Result<()>;
    fn GetTracks(&self) -> windows_core::Result<IMFTimedTextTrackList>;
    fn GetActiveTracks(&self) -> windows_core::Result<IMFTimedTextTrackList>;
    fn GetTextTracks(&self) -> windows_core::Result<IMFTimedTextTrackList>;
    fn GetMetadataTracks(&self) -> windows_core::Result<IMFTimedTextTrackList>;
    fn SetInBandEnabled(&self, enabled: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn IsInBandEnabled(&self) -> super::super::Foundation::BOOL;
}
impl windows_core::RuntimeName for IMFTimedText {}
impl IMFTimedText_Vtbl {
    pub const fn new<Identity: IMFTimedText_Impl, const OFFSET: isize>() -> IMFTimedText_Vtbl {
        unsafe extern "system" fn RegisterNotifications<Identity: IMFTimedText_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, notify: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedText_Impl::RegisterNotifications(this, windows_core::from_raw_borrowed(&notify)).into()
        }
        unsafe extern "system" fn SelectTrack<Identity: IMFTimedText_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, trackid: u32, selected: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedText_Impl::SelectTrack(this, core::mem::transmute_copy(&trackid), core::mem::transmute_copy(&selected)).into()
        }
        unsafe extern "system" fn AddDataSource<Identity: IMFTimedText_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bytestream: *mut core::ffi::c_void, label: windows_core::PCWSTR, language: windows_core::PCWSTR, kind: MF_TIMED_TEXT_TRACK_KIND, isdefault: super::super::Foundation::BOOL, trackid: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedText_Impl::AddDataSource(this, windows_core::from_raw_borrowed(&bytestream), core::mem::transmute(&label), core::mem::transmute(&language), core::mem::transmute_copy(&kind), core::mem::transmute_copy(&isdefault)) {
                Ok(ok__) => {
                    trackid.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddDataSourceFromUrl<Identity: IMFTimedText_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, url: windows_core::PCWSTR, label: windows_core::PCWSTR, language: windows_core::PCWSTR, kind: MF_TIMED_TEXT_TRACK_KIND, isdefault: super::super::Foundation::BOOL, trackid: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedText_Impl::AddDataSourceFromUrl(this, core::mem::transmute(&url), core::mem::transmute(&label), core::mem::transmute(&language), core::mem::transmute_copy(&kind), core::mem::transmute_copy(&isdefault)) {
                Ok(ok__) => {
                    trackid.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddTrack<Identity: IMFTimedText_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, label: windows_core::PCWSTR, language: windows_core::PCWSTR, kind: MF_TIMED_TEXT_TRACK_KIND, track: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedText_Impl::AddTrack(this, core::mem::transmute(&label), core::mem::transmute(&language), core::mem::transmute_copy(&kind)) {
                Ok(ok__) => {
                    track.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTrack<Identity: IMFTimedText_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, track: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedText_Impl::RemoveTrack(this, windows_core::from_raw_borrowed(&track)).into()
        }
        unsafe extern "system" fn GetCueTimeOffset<Identity: IMFTimedText_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, offset: *mut f64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedText_Impl::GetCueTimeOffset(this) {
                Ok(ok__) => {
                    offset.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCueTimeOffset<Identity: IMFTimedText_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, offset: f64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedText_Impl::SetCueTimeOffset(this, core::mem::transmute_copy(&offset)).into()
        }
        unsafe extern "system" fn GetTracks<Identity: IMFTimedText_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, tracks: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedText_Impl::GetTracks(this) {
                Ok(ok__) => {
                    tracks.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetActiveTracks<Identity: IMFTimedText_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, activetracks: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedText_Impl::GetActiveTracks(this) {
                Ok(ok__) => {
                    activetracks.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTextTracks<Identity: IMFTimedText_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, texttracks: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedText_Impl::GetTextTracks(this) {
                Ok(ok__) => {
                    texttracks.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMetadataTracks<Identity: IMFTimedText_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, metadatatracks: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedText_Impl::GetMetadataTracks(this) {
                Ok(ok__) => {
                    metadatatracks.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInBandEnabled<Identity: IMFTimedText_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, enabled: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedText_Impl::SetInBandEnabled(this, core::mem::transmute_copy(&enabled)).into()
        }
        unsafe extern "system" fn IsInBandEnabled<Identity: IMFTimedText_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedText_Impl::IsInBandEnabled(this)
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            RegisterNotifications: RegisterNotifications::<Identity, OFFSET>,
            SelectTrack: SelectTrack::<Identity, OFFSET>,
            AddDataSource: AddDataSource::<Identity, OFFSET>,
            AddDataSourceFromUrl: AddDataSourceFromUrl::<Identity, OFFSET>,
            AddTrack: AddTrack::<Identity, OFFSET>,
            RemoveTrack: RemoveTrack::<Identity, OFFSET>,
            GetCueTimeOffset: GetCueTimeOffset::<Identity, OFFSET>,
            SetCueTimeOffset: SetCueTimeOffset::<Identity, OFFSET>,
            GetTracks: GetTracks::<Identity, OFFSET>,
            GetActiveTracks: GetActiveTracks::<Identity, OFFSET>,
            GetTextTracks: GetTextTracks::<Identity, OFFSET>,
            GetMetadataTracks: GetMetadataTracks::<Identity, OFFSET>,
            SetInBandEnabled: SetInBandEnabled::<Identity, OFFSET>,
            IsInBandEnabled: IsInBandEnabled::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTimedText as windows_core::Interface>::IID
    }
}
pub trait IMFTimedTextBinary_Impl: Sized + windows_core::IUnknownImpl {
    fn GetData(&self, data: *mut *mut u8, length: *mut u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFTimedTextBinary {}
impl IMFTimedTextBinary_Vtbl {
    pub const fn new<Identity: IMFTimedTextBinary_Impl, const OFFSET: isize>() -> IMFTimedTextBinary_Vtbl {
        unsafe extern "system" fn GetData<Identity: IMFTimedTextBinary_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, data: *mut *mut u8, length: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextBinary_Impl::GetData(this, core::mem::transmute_copy(&data), core::mem::transmute_copy(&length)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetData: GetData::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTimedTextBinary as windows_core::Interface>::IID
    }
}
pub trait IMFTimedTextBouten_Impl: Sized + windows_core::IUnknownImpl {
    fn GetBoutenType(&self) -> windows_core::Result<MF_TIMED_TEXT_BOUTEN_TYPE>;
    fn GetBoutenColor(&self) -> windows_core::Result<MFARGB>;
    fn GetBoutenPosition(&self) -> windows_core::Result<MF_TIMED_TEXT_BOUTEN_POSITION>;
}
impl windows_core::RuntimeName for IMFTimedTextBouten {}
impl IMFTimedTextBouten_Vtbl {
    pub const fn new<Identity: IMFTimedTextBouten_Impl, const OFFSET: isize>() -> IMFTimedTextBouten_Vtbl {
        unsafe extern "system" fn GetBoutenType<Identity: IMFTimedTextBouten_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: *mut MF_TIMED_TEXT_BOUTEN_TYPE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextBouten_Impl::GetBoutenType(this) {
                Ok(ok__) => {
                    value.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBoutenColor<Identity: IMFTimedTextBouten_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: *mut MFARGB) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextBouten_Impl::GetBoutenColor(this) {
                Ok(ok__) => {
                    value.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBoutenPosition<Identity: IMFTimedTextBouten_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: *mut MF_TIMED_TEXT_BOUTEN_POSITION) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextBouten_Impl::GetBoutenPosition(this) {
                Ok(ok__) => {
                    value.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetBoutenType: GetBoutenType::<Identity, OFFSET>,
            GetBoutenColor: GetBoutenColor::<Identity, OFFSET>,
            GetBoutenPosition: GetBoutenPosition::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTimedTextBouten as windows_core::Interface>::IID
    }
}
pub trait IMFTimedTextCue_Impl: Sized + windows_core::IUnknownImpl {
    fn GetId(&self) -> u32;
    fn GetOriginalId(&self) -> windows_core::Result<windows_core::PWSTR>;
    fn GetCueKind(&self) -> MF_TIMED_TEXT_TRACK_KIND;
    fn GetStartTime(&self) -> f64;
    fn GetDuration(&self) -> f64;
    fn GetTrackId(&self) -> u32;
    fn GetData(&self) -> windows_core::Result<IMFTimedTextBinary>;
    fn GetRegion(&self) -> windows_core::Result<IMFTimedTextRegion>;
    fn GetStyle(&self) -> windows_core::Result<IMFTimedTextStyle>;
    fn GetLineCount(&self) -> u32;
    fn GetLine(&self, index: u32) -> windows_core::Result<IMFTimedTextFormattedText>;
}
impl windows_core::RuntimeName for IMFTimedTextCue {}
impl IMFTimedTextCue_Vtbl {
    pub const fn new<Identity: IMFTimedTextCue_Impl, const OFFSET: isize>() -> IMFTimedTextCue_Vtbl {
        unsafe extern "system" fn GetId<Identity: IMFTimedTextCue_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u32 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextCue_Impl::GetId(this)
        }
        unsafe extern "system" fn GetOriginalId<Identity: IMFTimedTextCue_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, originalid: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextCue_Impl::GetOriginalId(this) {
                Ok(ok__) => {
                    originalid.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCueKind<Identity: IMFTimedTextCue_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> MF_TIMED_TEXT_TRACK_KIND {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextCue_Impl::GetCueKind(this)
        }
        unsafe extern "system" fn GetStartTime<Identity: IMFTimedTextCue_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> f64 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextCue_Impl::GetStartTime(this)
        }
        unsafe extern "system" fn GetDuration<Identity: IMFTimedTextCue_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> f64 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextCue_Impl::GetDuration(this)
        }
        unsafe extern "system" fn GetTrackId<Identity: IMFTimedTextCue_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u32 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextCue_Impl::GetTrackId(this)
        }
        unsafe extern "system" fn GetData<Identity: IMFTimedTextCue_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, data: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextCue_Impl::GetData(this) {
                Ok(ok__) => {
                    data.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRegion<Identity: IMFTimedTextCue_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, region: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextCue_Impl::GetRegion(this) {
                Ok(ok__) => {
                    region.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStyle<Identity: IMFTimedTextCue_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, style: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextCue_Impl::GetStyle(this) {
                Ok(ok__) => {
                    style.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLineCount<Identity: IMFTimedTextCue_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u32 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextCue_Impl::GetLineCount(this)
        }
        unsafe extern "system" fn GetLine<Identity: IMFTimedTextCue_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, index: u32, line: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextCue_Impl::GetLine(this, core::mem::transmute_copy(&index)) {
                Ok(ok__) => {
                    line.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetId: GetId::<Identity, OFFSET>,
            GetOriginalId: GetOriginalId::<Identity, OFFSET>,
            GetCueKind: GetCueKind::<Identity, OFFSET>,
            GetStartTime: GetStartTime::<Identity, OFFSET>,
            GetDuration: GetDuration::<Identity, OFFSET>,
            GetTrackId: GetTrackId::<Identity, OFFSET>,
            GetData: GetData::<Identity, OFFSET>,
            GetRegion: GetRegion::<Identity, OFFSET>,
            GetStyle: GetStyle::<Identity, OFFSET>,
            GetLineCount: GetLineCount::<Identity, OFFSET>,
            GetLine: GetLine::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTimedTextCue as windows_core::Interface>::IID
    }
}
pub trait IMFTimedTextCueList_Impl: Sized + windows_core::IUnknownImpl {
    fn GetLength(&self) -> u32;
    fn GetCueByIndex(&self, index: u32) -> windows_core::Result<IMFTimedTextCue>;
    fn GetCueById(&self, id: u32) -> windows_core::Result<IMFTimedTextCue>;
    fn GetCueByOriginalId(&self, originalid: &windows_core::PCWSTR) -> windows_core::Result<IMFTimedTextCue>;
    fn AddTextCue(&self, start: f64, duration: f64, text: &windows_core::PCWSTR, cue: *mut Option<IMFTimedTextCue>) -> windows_core::Result<()>;
    fn AddDataCue(&self, start: f64, duration: f64, data: *const u8, datasize: u32, cue: *mut Option<IMFTimedTextCue>) -> windows_core::Result<()>;
    fn RemoveCue(&self, cue: Option<&IMFTimedTextCue>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFTimedTextCueList {}
impl IMFTimedTextCueList_Vtbl {
    pub const fn new<Identity: IMFTimedTextCueList_Impl, const OFFSET: isize>() -> IMFTimedTextCueList_Vtbl {
        unsafe extern "system" fn GetLength<Identity: IMFTimedTextCueList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u32 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextCueList_Impl::GetLength(this)
        }
        unsafe extern "system" fn GetCueByIndex<Identity: IMFTimedTextCueList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, index: u32, cue: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextCueList_Impl::GetCueByIndex(this, core::mem::transmute_copy(&index)) {
                Ok(ok__) => {
                    cue.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCueById<Identity: IMFTimedTextCueList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, id: u32, cue: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextCueList_Impl::GetCueById(this, core::mem::transmute_copy(&id)) {
                Ok(ok__) => {
                    cue.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCueByOriginalId<Identity: IMFTimedTextCueList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, originalid: windows_core::PCWSTR, cue: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextCueList_Impl::GetCueByOriginalId(this, core::mem::transmute(&originalid)) {
                Ok(ok__) => {
                    cue.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddTextCue<Identity: IMFTimedTextCueList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, start: f64, duration: f64, text: windows_core::PCWSTR, cue: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextCueList_Impl::AddTextCue(this, core::mem::transmute_copy(&start), core::mem::transmute_copy(&duration), core::mem::transmute(&text), core::mem::transmute_copy(&cue)).into()
        }
        unsafe extern "system" fn AddDataCue<Identity: IMFTimedTextCueList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, start: f64, duration: f64, data: *const u8, datasize: u32, cue: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextCueList_Impl::AddDataCue(this, core::mem::transmute_copy(&start), core::mem::transmute_copy(&duration), core::mem::transmute_copy(&data), core::mem::transmute_copy(&datasize), core::mem::transmute_copy(&cue)).into()
        }
        unsafe extern "system" fn RemoveCue<Identity: IMFTimedTextCueList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cue: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextCueList_Impl::RemoveCue(this, windows_core::from_raw_borrowed(&cue)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetLength: GetLength::<Identity, OFFSET>,
            GetCueByIndex: GetCueByIndex::<Identity, OFFSET>,
            GetCueById: GetCueById::<Identity, OFFSET>,
            GetCueByOriginalId: GetCueByOriginalId::<Identity, OFFSET>,
            AddTextCue: AddTextCue::<Identity, OFFSET>,
            AddDataCue: AddDataCue::<Identity, OFFSET>,
            RemoveCue: RemoveCue::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTimedTextCueList as windows_core::Interface>::IID
    }
}
pub trait IMFTimedTextFormattedText_Impl: Sized + windows_core::IUnknownImpl {
    fn GetText(&self) -> windows_core::Result<windows_core::PWSTR>;
    fn GetSubformattingCount(&self) -> u32;
    fn GetSubformatting(&self, index: u32, firstchar: *mut u32, charlength: *mut u32, style: *mut Option<IMFTimedTextStyle>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFTimedTextFormattedText {}
impl IMFTimedTextFormattedText_Vtbl {
    pub const fn new<Identity: IMFTimedTextFormattedText_Impl, const OFFSET: isize>() -> IMFTimedTextFormattedText_Vtbl {
        unsafe extern "system" fn GetText<Identity: IMFTimedTextFormattedText_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, text: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextFormattedText_Impl::GetText(this) {
                Ok(ok__) => {
                    text.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSubformattingCount<Identity: IMFTimedTextFormattedText_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u32 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextFormattedText_Impl::GetSubformattingCount(this)
        }
        unsafe extern "system" fn GetSubformatting<Identity: IMFTimedTextFormattedText_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, index: u32, firstchar: *mut u32, charlength: *mut u32, style: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextFormattedText_Impl::GetSubformatting(this, core::mem::transmute_copy(&index), core::mem::transmute_copy(&firstchar), core::mem::transmute_copy(&charlength), core::mem::transmute_copy(&style)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetText: GetText::<Identity, OFFSET>,
            GetSubformattingCount: GetSubformattingCount::<Identity, OFFSET>,
            GetSubformatting: GetSubformatting::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTimedTextFormattedText as windows_core::Interface>::IID
    }
}
pub trait IMFTimedTextNotify_Impl: Sized + windows_core::IUnknownImpl {
    fn TrackAdded(&self, trackid: u32);
    fn TrackRemoved(&self, trackid: u32);
    fn TrackSelected(&self, trackid: u32, selected: super::super::Foundation::BOOL);
    fn TrackReadyStateChanged(&self, trackid: u32);
    fn Error(&self, errorcode: MF_TIMED_TEXT_ERROR_CODE, extendederrorcode: windows_core::HRESULT, sourcetrackid: u32);
    fn Cue(&self, cueevent: MF_TIMED_TEXT_CUE_EVENT, currenttime: f64, cue: Option<&IMFTimedTextCue>);
    fn Reset(&self);
}
impl windows_core::RuntimeName for IMFTimedTextNotify {}
impl IMFTimedTextNotify_Vtbl {
    pub const fn new<Identity: IMFTimedTextNotify_Impl, const OFFSET: isize>() -> IMFTimedTextNotify_Vtbl {
        unsafe extern "system" fn TrackAdded<Identity: IMFTimedTextNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, trackid: u32) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextNotify_Impl::TrackAdded(this, core::mem::transmute_copy(&trackid))
        }
        unsafe extern "system" fn TrackRemoved<Identity: IMFTimedTextNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, trackid: u32) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextNotify_Impl::TrackRemoved(this, core::mem::transmute_copy(&trackid))
        }
        unsafe extern "system" fn TrackSelected<Identity: IMFTimedTextNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, trackid: u32, selected: super::super::Foundation::BOOL) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextNotify_Impl::TrackSelected(this, core::mem::transmute_copy(&trackid), core::mem::transmute_copy(&selected))
        }
        unsafe extern "system" fn TrackReadyStateChanged<Identity: IMFTimedTextNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, trackid: u32) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextNotify_Impl::TrackReadyStateChanged(this, core::mem::transmute_copy(&trackid))
        }
        unsafe extern "system" fn Error<Identity: IMFTimedTextNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, errorcode: MF_TIMED_TEXT_ERROR_CODE, extendederrorcode: windows_core::HRESULT, sourcetrackid: u32) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextNotify_Impl::Error(this, core::mem::transmute_copy(&errorcode), core::mem::transmute_copy(&extendederrorcode), core::mem::transmute_copy(&sourcetrackid))
        }
        unsafe extern "system" fn Cue<Identity: IMFTimedTextNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cueevent: MF_TIMED_TEXT_CUE_EVENT, currenttime: f64, cue: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextNotify_Impl::Cue(this, core::mem::transmute_copy(&cueevent), core::mem::transmute_copy(&currenttime), windows_core::from_raw_borrowed(&cue))
        }
        unsafe extern "system" fn Reset<Identity: IMFTimedTextNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextNotify_Impl::Reset(this)
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            TrackAdded: TrackAdded::<Identity, OFFSET>,
            TrackRemoved: TrackRemoved::<Identity, OFFSET>,
            TrackSelected: TrackSelected::<Identity, OFFSET>,
            TrackReadyStateChanged: TrackReadyStateChanged::<Identity, OFFSET>,
            Error: Error::<Identity, OFFSET>,
            Cue: Cue::<Identity, OFFSET>,
            Reset: Reset::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTimedTextNotify as windows_core::Interface>::IID
    }
}
pub trait IMFTimedTextRegion_Impl: Sized + windows_core::IUnknownImpl {
    fn GetName(&self) -> windows_core::Result<windows_core::PWSTR>;
    fn GetPosition(&self, px: *mut f64, py: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> windows_core::Result<()>;
    fn GetExtent(&self, pwidth: *mut f64, pheight: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> windows_core::Result<()>;
    fn GetBackgroundColor(&self) -> windows_core::Result<MFARGB>;
    fn GetWritingMode(&self) -> windows_core::Result<MF_TIMED_TEXT_WRITING_MODE>;
    fn GetDisplayAlignment(&self) -> windows_core::Result<MF_TIMED_TEXT_DISPLAY_ALIGNMENT>;
    fn GetLineHeight(&self, plineheight: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> windows_core::Result<()>;
    fn GetClipOverflow(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn GetPadding(&self, before: *mut f64, start: *mut f64, after: *mut f64, end: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> windows_core::Result<()>;
    fn GetWrap(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn GetZIndex(&self) -> windows_core::Result<i32>;
    fn GetScrollMode(&self) -> windows_core::Result<MF_TIMED_TEXT_SCROLL_MODE>;
}
impl windows_core::RuntimeName for IMFTimedTextRegion {}
impl IMFTimedTextRegion_Vtbl {
    pub const fn new<Identity: IMFTimedTextRegion_Impl, const OFFSET: isize>() -> IMFTimedTextRegion_Vtbl {
        unsafe extern "system" fn GetName<Identity: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, name: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextRegion_Impl::GetName(this) {
                Ok(ok__) => {
                    name.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPosition<Identity: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, px: *mut f64, py: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextRegion_Impl::GetPosition(this, core::mem::transmute_copy(&px), core::mem::transmute_copy(&py), core::mem::transmute_copy(&unittype)).into()
        }
        unsafe extern "system" fn GetExtent<Identity: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwidth: *mut f64, pheight: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextRegion_Impl::GetExtent(this, core::mem::transmute_copy(&pwidth), core::mem::transmute_copy(&pheight), core::mem::transmute_copy(&unittype)).into()
        }
        unsafe extern "system" fn GetBackgroundColor<Identity: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bgcolor: *mut MFARGB) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextRegion_Impl::GetBackgroundColor(this) {
                Ok(ok__) => {
                    bgcolor.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetWritingMode<Identity: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, writingmode: *mut MF_TIMED_TEXT_WRITING_MODE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextRegion_Impl::GetWritingMode(this) {
                Ok(ok__) => {
                    writingmode.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDisplayAlignment<Identity: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, displayalign: *mut MF_TIMED_TEXT_DISPLAY_ALIGNMENT) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextRegion_Impl::GetDisplayAlignment(this) {
                Ok(ok__) => {
                    displayalign.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLineHeight<Identity: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plineheight: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextRegion_Impl::GetLineHeight(this, core::mem::transmute_copy(&plineheight), core::mem::transmute_copy(&unittype)).into()
        }
        unsafe extern "system" fn GetClipOverflow<Identity: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clipoverflow: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextRegion_Impl::GetClipOverflow(this) {
                Ok(ok__) => {
                    clipoverflow.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPadding<Identity: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, before: *mut f64, start: *mut f64, after: *mut f64, end: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextRegion_Impl::GetPadding(this, core::mem::transmute_copy(&before), core::mem::transmute_copy(&start), core::mem::transmute_copy(&after), core::mem::transmute_copy(&end), core::mem::transmute_copy(&unittype)).into()
        }
        unsafe extern "system" fn GetWrap<Identity: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, wrap: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextRegion_Impl::GetWrap(this) {
                Ok(ok__) => {
                    wrap.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetZIndex<Identity: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, zindex: *mut i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextRegion_Impl::GetZIndex(this) {
                Ok(ok__) => {
                    zindex.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetScrollMode<Identity: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, scrollmode: *mut MF_TIMED_TEXT_SCROLL_MODE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextRegion_Impl::GetScrollMode(this) {
                Ok(ok__) => {
                    scrollmode.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetName: GetName::<Identity, OFFSET>,
            GetPosition: GetPosition::<Identity, OFFSET>,
            GetExtent: GetExtent::<Identity, OFFSET>,
            GetBackgroundColor: GetBackgroundColor::<Identity, OFFSET>,
            GetWritingMode: GetWritingMode::<Identity, OFFSET>,
            GetDisplayAlignment: GetDisplayAlignment::<Identity, OFFSET>,
            GetLineHeight: GetLineHeight::<Identity, OFFSET>,
            GetClipOverflow: GetClipOverflow::<Identity, OFFSET>,
            GetPadding: GetPadding::<Identity, OFFSET>,
            GetWrap: GetWrap::<Identity, OFFSET>,
            GetZIndex: GetZIndex::<Identity, OFFSET>,
            GetScrollMode: GetScrollMode::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTimedTextRegion as windows_core::Interface>::IID
    }
}
pub trait IMFTimedTextRuby_Impl: Sized + windows_core::IUnknownImpl {
    fn GetRubyText(&self) -> windows_core::Result<windows_core::PWSTR>;
    fn GetRubyPosition(&self) -> windows_core::Result<MF_TIMED_TEXT_RUBY_POSITION>;
    fn GetRubyAlign(&self) -> windows_core::Result<MF_TIMED_TEXT_RUBY_ALIGN>;
    fn GetRubyReserve(&self) -> windows_core::Result<MF_TIMED_TEXT_RUBY_RESERVE>;
}
impl windows_core::RuntimeName for IMFTimedTextRuby {}
impl IMFTimedTextRuby_Vtbl {
    pub const fn new<Identity: IMFTimedTextRuby_Impl, const OFFSET: isize>() -> IMFTimedTextRuby_Vtbl {
        unsafe extern "system" fn GetRubyText<Identity: IMFTimedTextRuby_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, rubytext: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextRuby_Impl::GetRubyText(this) {
                Ok(ok__) => {
                    rubytext.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRubyPosition<Identity: IMFTimedTextRuby_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: *mut MF_TIMED_TEXT_RUBY_POSITION) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextRuby_Impl::GetRubyPosition(this) {
                Ok(ok__) => {
                    value.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRubyAlign<Identity: IMFTimedTextRuby_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: *mut MF_TIMED_TEXT_RUBY_ALIGN) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextRuby_Impl::GetRubyAlign(this) {
                Ok(ok__) => {
                    value.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRubyReserve<Identity: IMFTimedTextRuby_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: *mut MF_TIMED_TEXT_RUBY_RESERVE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextRuby_Impl::GetRubyReserve(this) {
                Ok(ok__) => {
                    value.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetRubyText: GetRubyText::<Identity, OFFSET>,
            GetRubyPosition: GetRubyPosition::<Identity, OFFSET>,
            GetRubyAlign: GetRubyAlign::<Identity, OFFSET>,
            GetRubyReserve: GetRubyReserve::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTimedTextRuby as windows_core::Interface>::IID
    }
}
pub trait IMFTimedTextStyle_Impl: Sized + windows_core::IUnknownImpl {
    fn GetName(&self) -> windows_core::Result<windows_core::PWSTR>;
    fn IsExternal(&self) -> super::super::Foundation::BOOL;
    fn GetFontFamily(&self) -> windows_core::Result<windows_core::PWSTR>;
    fn GetFontSize(&self, fontsize: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> windows_core::Result<()>;
    fn GetColor(&self) -> windows_core::Result<MFARGB>;
    fn GetBackgroundColor(&self) -> windows_core::Result<MFARGB>;
    fn GetShowBackgroundAlways(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn GetFontStyle(&self) -> windows_core::Result<MF_TIMED_TEXT_FONT_STYLE>;
    fn GetBold(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn GetRightToLeft(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn GetTextAlignment(&self) -> windows_core::Result<MF_TIMED_TEXT_ALIGNMENT>;
    fn GetTextDecoration(&self) -> windows_core::Result<u32>;
    fn GetTextOutline(&self, color: *mut MFARGB, thickness: *mut f64, blurradius: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFTimedTextStyle {}
impl IMFTimedTextStyle_Vtbl {
    pub const fn new<Identity: IMFTimedTextStyle_Impl, const OFFSET: isize>() -> IMFTimedTextStyle_Vtbl {
        unsafe extern "system" fn GetName<Identity: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, name: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextStyle_Impl::GetName(this) {
                Ok(ok__) => {
                    name.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsExternal<Identity: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextStyle_Impl::IsExternal(this)
        }
        unsafe extern "system" fn GetFontFamily<Identity: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fontfamily: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextStyle_Impl::GetFontFamily(this) {
                Ok(ok__) => {
                    fontfamily.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFontSize<Identity: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fontsize: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextStyle_Impl::GetFontSize(this, core::mem::transmute_copy(&fontsize), core::mem::transmute_copy(&unittype)).into()
        }
        unsafe extern "system" fn GetColor<Identity: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, color: *mut MFARGB) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextStyle_Impl::GetColor(this) {
                Ok(ok__) => {
                    color.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBackgroundColor<Identity: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bgcolor: *mut MFARGB) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextStyle_Impl::GetBackgroundColor(this) {
                Ok(ok__) => {
                    bgcolor.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetShowBackgroundAlways<Identity: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, showbackgroundalways: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextStyle_Impl::GetShowBackgroundAlways(this) {
                Ok(ok__) => {
                    showbackgroundalways.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFontStyle<Identity: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fontstyle: *mut MF_TIMED_TEXT_FONT_STYLE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextStyle_Impl::GetFontStyle(this) {
                Ok(ok__) => {
                    fontstyle.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBold<Identity: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bold: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextStyle_Impl::GetBold(this) {
                Ok(ok__) => {
                    bold.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRightToLeft<Identity: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, righttoleft: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextStyle_Impl::GetRightToLeft(this) {
                Ok(ok__) => {
                    righttoleft.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTextAlignment<Identity: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, textalign: *mut MF_TIMED_TEXT_ALIGNMENT) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextStyle_Impl::GetTextAlignment(this) {
                Ok(ok__) => {
                    textalign.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTextDecoration<Identity: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, textdecoration: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextStyle_Impl::GetTextDecoration(this) {
                Ok(ok__) => {
                    textdecoration.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTextOutline<Identity: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, color: *mut MFARGB, thickness: *mut f64, blurradius: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextStyle_Impl::GetTextOutline(this, core::mem::transmute_copy(&color), core::mem::transmute_copy(&thickness), core::mem::transmute_copy(&blurradius), core::mem::transmute_copy(&unittype)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetName: GetName::<Identity, OFFSET>,
            IsExternal: IsExternal::<Identity, OFFSET>,
            GetFontFamily: GetFontFamily::<Identity, OFFSET>,
            GetFontSize: GetFontSize::<Identity, OFFSET>,
            GetColor: GetColor::<Identity, OFFSET>,
            GetBackgroundColor: GetBackgroundColor::<Identity, OFFSET>,
            GetShowBackgroundAlways: GetShowBackgroundAlways::<Identity, OFFSET>,
            GetFontStyle: GetFontStyle::<Identity, OFFSET>,
            GetBold: GetBold::<Identity, OFFSET>,
            GetRightToLeft: GetRightToLeft::<Identity, OFFSET>,
            GetTextAlignment: GetTextAlignment::<Identity, OFFSET>,
            GetTextDecoration: GetTextDecoration::<Identity, OFFSET>,
            GetTextOutline: GetTextOutline::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTimedTextStyle as windows_core::Interface>::IID
    }
}
pub trait IMFTimedTextStyle2_Impl: Sized + windows_core::IUnknownImpl {
    fn GetRuby(&self) -> windows_core::Result<IMFTimedTextRuby>;
    fn GetBouten(&self) -> windows_core::Result<IMFTimedTextBouten>;
    fn IsTextCombined(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
    fn GetFontAngleInDegrees(&self) -> windows_core::Result<f64>;
}
impl windows_core::RuntimeName for IMFTimedTextStyle2 {}
impl IMFTimedTextStyle2_Vtbl {
    pub const fn new<Identity: IMFTimedTextStyle2_Impl, const OFFSET: isize>() -> IMFTimedTextStyle2_Vtbl {
        unsafe extern "system" fn GetRuby<Identity: IMFTimedTextStyle2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ruby: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextStyle2_Impl::GetRuby(this) {
                Ok(ok__) => {
                    ruby.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBouten<Identity: IMFTimedTextStyle2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bouten: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextStyle2_Impl::GetBouten(this) {
                Ok(ok__) => {
                    bouten.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextCombined<Identity: IMFTimedTextStyle2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextStyle2_Impl::IsTextCombined(this) {
                Ok(ok__) => {
                    value.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFontAngleInDegrees<Identity: IMFTimedTextStyle2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, value: *mut f64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextStyle2_Impl::GetFontAngleInDegrees(this) {
                Ok(ok__) => {
                    value.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetRuby: GetRuby::<Identity, OFFSET>,
            GetBouten: GetBouten::<Identity, OFFSET>,
            IsTextCombined: IsTextCombined::<Identity, OFFSET>,
            GetFontAngleInDegrees: GetFontAngleInDegrees::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTimedTextStyle2 as windows_core::Interface>::IID
    }
}
pub trait IMFTimedTextTrack_Impl: Sized + windows_core::IUnknownImpl {
    fn GetId(&self) -> u32;
    fn GetLabel(&self) -> windows_core::Result<windows_core::PWSTR>;
    fn SetLabel(&self, label: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn GetLanguage(&self) -> windows_core::Result<windows_core::PWSTR>;
    fn GetTrackKind(&self) -> MF_TIMED_TEXT_TRACK_KIND;
    fn IsInBand(&self) -> super::super::Foundation::BOOL;
    fn GetInBandMetadataTrackDispatchType(&self) -> windows_core::Result<windows_core::PWSTR>;
    fn IsActive(&self) -> super::super::Foundation::BOOL;
    fn GetErrorCode(&self) -> MF_TIMED_TEXT_ERROR_CODE;
    fn GetExtendedErrorCode(&self) -> windows_core::Result<()>;
    fn GetDataFormat(&self) -> windows_core::Result<windows_core::GUID>;
    fn GetReadyState(&self) -> MF_TIMED_TEXT_TRACK_READY_STATE;
    fn GetCueList(&self) -> windows_core::Result<IMFTimedTextCueList>;
}
impl windows_core::RuntimeName for IMFTimedTextTrack {}
impl IMFTimedTextTrack_Vtbl {
    pub const fn new<Identity: IMFTimedTextTrack_Impl, const OFFSET: isize>() -> IMFTimedTextTrack_Vtbl {
        unsafe extern "system" fn GetId<Identity: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u32 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextTrack_Impl::GetId(this)
        }
        unsafe extern "system" fn GetLabel<Identity: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, label: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextTrack_Impl::GetLabel(this) {
                Ok(ok__) => {
                    label.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLabel<Identity: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, label: windows_core::PCWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextTrack_Impl::SetLabel(this, core::mem::transmute(&label)).into()
        }
        unsafe extern "system" fn GetLanguage<Identity: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, language: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextTrack_Impl::GetLanguage(this) {
                Ok(ok__) => {
                    language.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTrackKind<Identity: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> MF_TIMED_TEXT_TRACK_KIND {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextTrack_Impl::GetTrackKind(this)
        }
        unsafe extern "system" fn IsInBand<Identity: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextTrack_Impl::IsInBand(this)
        }
        unsafe extern "system" fn GetInBandMetadataTrackDispatchType<Identity: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dispatchtype: *mut windows_core::PWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextTrack_Impl::GetInBandMetadataTrackDispatchType(this) {
                Ok(ok__) => {
                    dispatchtype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsActive<Identity: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextTrack_Impl::IsActive(this)
        }
        unsafe extern "system" fn GetErrorCode<Identity: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> MF_TIMED_TEXT_ERROR_CODE {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextTrack_Impl::GetErrorCode(this)
        }
        unsafe extern "system" fn GetExtendedErrorCode<Identity: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextTrack_Impl::GetExtendedErrorCode(this).into()
        }
        unsafe extern "system" fn GetDataFormat<Identity: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, format: *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextTrack_Impl::GetDataFormat(this) {
                Ok(ok__) => {
                    format.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetReadyState<Identity: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> MF_TIMED_TEXT_TRACK_READY_STATE {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextTrack_Impl::GetReadyState(this)
        }
        unsafe extern "system" fn GetCueList<Identity: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cues: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextTrack_Impl::GetCueList(this) {
                Ok(ok__) => {
                    cues.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetId: GetId::<Identity, OFFSET>,
            GetLabel: GetLabel::<Identity, OFFSET>,
            SetLabel: SetLabel::<Identity, OFFSET>,
            GetLanguage: GetLanguage::<Identity, OFFSET>,
            GetTrackKind: GetTrackKind::<Identity, OFFSET>,
            IsInBand: IsInBand::<Identity, OFFSET>,
            GetInBandMetadataTrackDispatchType: GetInBandMetadataTrackDispatchType::<Identity, OFFSET>,
            IsActive: IsActive::<Identity, OFFSET>,
            GetErrorCode: GetErrorCode::<Identity, OFFSET>,
            GetExtendedErrorCode: GetExtendedErrorCode::<Identity, OFFSET>,
            GetDataFormat: GetDataFormat::<Identity, OFFSET>,
            GetReadyState: GetReadyState::<Identity, OFFSET>,
            GetCueList: GetCueList::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTimedTextTrack as windows_core::Interface>::IID
    }
}
pub trait IMFTimedTextTrackList_Impl: Sized + windows_core::IUnknownImpl {
    fn GetLength(&self) -> u32;
    fn GetTrack(&self, index: u32) -> windows_core::Result<IMFTimedTextTrack>;
    fn GetTrackById(&self, trackid: u32) -> windows_core::Result<IMFTimedTextTrack>;
}
impl windows_core::RuntimeName for IMFTimedTextTrackList {}
impl IMFTimedTextTrackList_Vtbl {
    pub const fn new<Identity: IMFTimedTextTrackList_Impl, const OFFSET: isize>() -> IMFTimedTextTrackList_Vtbl {
        unsafe extern "system" fn GetLength<Identity: IMFTimedTextTrackList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> u32 {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimedTextTrackList_Impl::GetLength(this)
        }
        unsafe extern "system" fn GetTrack<Identity: IMFTimedTextTrackList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, index: u32, track: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextTrackList_Impl::GetTrack(this, core::mem::transmute_copy(&index)) {
                Ok(ok__) => {
                    track.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTrackById<Identity: IMFTimedTextTrackList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, trackid: u32, track: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimedTextTrackList_Impl::GetTrackById(this, core::mem::transmute_copy(&trackid)) {
                Ok(ok__) => {
                    track.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetLength: GetLength::<Identity, OFFSET>,
            GetTrack: GetTrack::<Identity, OFFSET>,
            GetTrackById: GetTrackById::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTimedTextTrackList as windows_core::Interface>::IID
    }
}
pub trait IMFTimer_Impl: Sized + windows_core::IUnknownImpl {
    fn SetTimer(&self, dwflags: u32, llclocktime: i64, pcallback: Option<&IMFAsyncCallback>, punkstate: Option<&windows_core::IUnknown>) -> windows_core::Result<windows_core::IUnknown>;
    fn CancelTimer(&self, punkkey: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFTimer {}
impl IMFTimer_Vtbl {
    pub const fn new<Identity: IMFTimer_Impl, const OFFSET: isize>() -> IMFTimer_Vtbl {
        unsafe extern "system" fn SetTimer<Identity: IMFTimer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32, llclocktime: i64, pcallback: *mut core::ffi::c_void, punkstate: *mut core::ffi::c_void, ppunkkey: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTimer_Impl::SetTimer(this, core::mem::transmute_copy(&dwflags), core::mem::transmute_copy(&llclocktime), windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&punkstate)) {
                Ok(ok__) => {
                    ppunkkey.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CancelTimer<Identity: IMFTimer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, punkkey: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTimer_Impl::CancelTimer(this, windows_core::from_raw_borrowed(&punkkey)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetTimer: SetTimer::<Identity, OFFSET>,
            CancelTimer: CancelTimer::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTimer as windows_core::Interface>::IID
    }
}
pub trait IMFTopoLoader_Impl: Sized + windows_core::IUnknownImpl {
    fn Load(&self, pinputtopo: Option<&IMFTopology>, ppoutputtopo: *mut Option<IMFTopology>, pcurrenttopo: Option<&IMFTopology>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFTopoLoader {}
impl IMFTopoLoader_Vtbl {
    pub const fn new<Identity: IMFTopoLoader_Impl, const OFFSET: isize>() -> IMFTopoLoader_Vtbl {
        unsafe extern "system" fn Load<Identity: IMFTopoLoader_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pinputtopo: *mut core::ffi::c_void, ppoutputtopo: *mut *mut core::ffi::c_void, pcurrenttopo: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTopoLoader_Impl::Load(this, windows_core::from_raw_borrowed(&pinputtopo), core::mem::transmute_copy(&ppoutputtopo), windows_core::from_raw_borrowed(&pcurrenttopo)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Load: Load::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTopoLoader as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFTopology_Impl: Sized + IMFAttributes_Impl {
    fn GetTopologyID(&self) -> windows_core::Result<u64>;
    fn AddNode(&self, pnode: Option<&IMFTopologyNode>) -> windows_core::Result<()>;
    fn RemoveNode(&self, pnode: Option<&IMFTopologyNode>) -> windows_core::Result<()>;
    fn GetNodeCount(&self) -> windows_core::Result<u16>;
    fn GetNode(&self, windex: u16) -> windows_core::Result<IMFTopologyNode>;
    fn Clear(&self) -> windows_core::Result<()>;
    fn CloneFrom(&self, ptopology: Option<&IMFTopology>) -> windows_core::Result<()>;
    fn GetNodeByID(&self, qwtoponodeid: u64) -> windows_core::Result<IMFTopologyNode>;
    fn GetSourceNodeCollection(&self) -> windows_core::Result<IMFCollection>;
    fn GetOutputNodeCollection(&self) -> windows_core::Result<IMFCollection>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFTopology {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFTopology_Vtbl {
    pub const fn new<Identity: IMFTopology_Impl, const OFFSET: isize>() -> IMFTopology_Vtbl {
        unsafe extern "system" fn GetTopologyID<Identity: IMFTopology_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pid: *mut u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTopology_Impl::GetTopologyID(this) {
                Ok(ok__) => {
                    pid.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddNode<Identity: IMFTopology_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pnode: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTopology_Impl::AddNode(this, windows_core::from_raw_borrowed(&pnode)).into()
        }
        unsafe extern "system" fn RemoveNode<Identity: IMFTopology_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pnode: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTopology_Impl::RemoveNode(this, windows_core::from_raw_borrowed(&pnode)).into()
        }
        unsafe extern "system" fn GetNodeCount<Identity: IMFTopology_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwnodes: *mut u16) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTopology_Impl::GetNodeCount(this) {
                Ok(ok__) => {
                    pwnodes.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNode<Identity: IMFTopology_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, windex: u16, ppnode: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTopology_Impl::GetNode(this, core::mem::transmute_copy(&windex)) {
                Ok(ok__) => {
                    ppnode.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clear<Identity: IMFTopology_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTopology_Impl::Clear(this).into()
        }
        unsafe extern "system" fn CloneFrom<Identity: IMFTopology_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptopology: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTopology_Impl::CloneFrom(this, windows_core::from_raw_borrowed(&ptopology)).into()
        }
        unsafe extern "system" fn GetNodeByID<Identity: IMFTopology_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, qwtoponodeid: u64, ppnode: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTopology_Impl::GetNodeByID(this, core::mem::transmute_copy(&qwtoponodeid)) {
                Ok(ok__) => {
                    ppnode.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceNodeCollection<Identity: IMFTopology_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppcollection: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTopology_Impl::GetSourceNodeCollection(this) {
                Ok(ok__) => {
                    ppcollection.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputNodeCollection<Identity: IMFTopology_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppcollection: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTopology_Impl::GetOutputNodeCollection(this) {
                Ok(ok__) => {
                    ppcollection.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IMFAttributes_Vtbl::new::<Identity, OFFSET>(),
            GetTopologyID: GetTopologyID::<Identity, OFFSET>,
            AddNode: AddNode::<Identity, OFFSET>,
            RemoveNode: RemoveNode::<Identity, OFFSET>,
            GetNodeCount: GetNodeCount::<Identity, OFFSET>,
            GetNode: GetNode::<Identity, OFFSET>,
            Clear: Clear::<Identity, OFFSET>,
            CloneFrom: CloneFrom::<Identity, OFFSET>,
            GetNodeByID: GetNodeByID::<Identity, OFFSET>,
            GetSourceNodeCollection: GetSourceNodeCollection::<Identity, OFFSET>,
            GetOutputNodeCollection: GetOutputNodeCollection::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTopology as windows_core::Interface>::IID || iid == &<IMFAttributes as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFTopologyNode_Impl: Sized + IMFAttributes_Impl {
    fn SetObject(&self, pobject: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn GetObject(&self) -> windows_core::Result<windows_core::IUnknown>;
    fn GetNodeType(&self) -> windows_core::Result<MF_TOPOLOGY_TYPE>;
    fn GetTopoNodeID(&self) -> windows_core::Result<u64>;
    fn SetTopoNodeID(&self, ulltopoid: u64) -> windows_core::Result<()>;
    fn GetInputCount(&self) -> windows_core::Result<u32>;
    fn GetOutputCount(&self) -> windows_core::Result<u32>;
    fn ConnectOutput(&self, dwoutputindex: u32, pdownstreamnode: Option<&IMFTopologyNode>, dwinputindexondownstreamnode: u32) -> windows_core::Result<()>;
    fn DisconnectOutput(&self, dwoutputindex: u32) -> windows_core::Result<()>;
    fn GetInput(&self, dwinputindex: u32, ppupstreamnode: *mut Option<IMFTopologyNode>, pdwoutputindexonupstreamnode: *mut u32) -> windows_core::Result<()>;
    fn GetOutput(&self, dwoutputindex: u32, ppdownstreamnode: *mut Option<IMFTopologyNode>, pdwinputindexondownstreamnode: *mut u32) -> windows_core::Result<()>;
    fn SetOutputPrefType(&self, dwoutputindex: u32, ptype: Option<&IMFMediaType>) -> windows_core::Result<()>;
    fn GetOutputPrefType(&self, dwoutputindex: u32) -> windows_core::Result<IMFMediaType>;
    fn SetInputPrefType(&self, dwinputindex: u32, ptype: Option<&IMFMediaType>) -> windows_core::Result<()>;
    fn GetInputPrefType(&self, dwinputindex: u32) -> windows_core::Result<IMFMediaType>;
    fn CloneFrom(&self, pnode: Option<&IMFTopologyNode>) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFTopologyNode {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFTopologyNode_Vtbl {
    pub const fn new<Identity: IMFTopologyNode_Impl, const OFFSET: isize>() -> IMFTopologyNode_Vtbl {
        unsafe extern "system" fn SetObject<Identity: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pobject: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTopologyNode_Impl::SetObject(this, windows_core::from_raw_borrowed(&pobject)).into()
        }
        unsafe extern "system" fn GetObject<Identity: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTopologyNode_Impl::GetObject(this) {
                Ok(ok__) => {
                    ppobject.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNodeType<Identity: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptype: *mut MF_TOPOLOGY_TYPE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTopologyNode_Impl::GetNodeType(this) {
                Ok(ok__) => {
                    ptype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTopoNodeID<Identity: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pid: *mut u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTopologyNode_Impl::GetTopoNodeID(this) {
                Ok(ok__) => {
                    pid.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTopoNodeID<Identity: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulltopoid: u64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTopologyNode_Impl::SetTopoNodeID(this, core::mem::transmute_copy(&ulltopoid)).into()
        }
        unsafe extern "system" fn GetInputCount<Identity: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcinputs: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTopologyNode_Impl::GetInputCount(this) {
                Ok(ok__) => {
                    pcinputs.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputCount<Identity: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcoutputs: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTopologyNode_Impl::GetOutputCount(this) {
                Ok(ok__) => {
                    pcoutputs.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConnectOutput<Identity: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwoutputindex: u32, pdownstreamnode: *mut core::ffi::c_void, dwinputindexondownstreamnode: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTopologyNode_Impl::ConnectOutput(this, core::mem::transmute_copy(&dwoutputindex), windows_core::from_raw_borrowed(&pdownstreamnode), core::mem::transmute_copy(&dwinputindexondownstreamnode)).into()
        }
        unsafe extern "system" fn DisconnectOutput<Identity: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwoutputindex: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTopologyNode_Impl::DisconnectOutput(this, core::mem::transmute_copy(&dwoutputindex)).into()
        }
        unsafe extern "system" fn GetInput<Identity: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwinputindex: u32, ppupstreamnode: *mut *mut core::ffi::c_void, pdwoutputindexonupstreamnode: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTopologyNode_Impl::GetInput(this, core::mem::transmute_copy(&dwinputindex), core::mem::transmute_copy(&ppupstreamnode), core::mem::transmute_copy(&pdwoutputindexonupstreamnode)).into()
        }
        unsafe extern "system" fn GetOutput<Identity: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwoutputindex: u32, ppdownstreamnode: *mut *mut core::ffi::c_void, pdwinputindexondownstreamnode: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTopologyNode_Impl::GetOutput(this, core::mem::transmute_copy(&dwoutputindex), core::mem::transmute_copy(&ppdownstreamnode), core::mem::transmute_copy(&pdwinputindexondownstreamnode)).into()
        }
        unsafe extern "system" fn SetOutputPrefType<Identity: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwoutputindex: u32, ptype: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTopologyNode_Impl::SetOutputPrefType(this, core::mem::transmute_copy(&dwoutputindex), windows_core::from_raw_borrowed(&ptype)).into()
        }
        unsafe extern "system" fn GetOutputPrefType<Identity: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwoutputindex: u32, pptype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTopologyNode_Impl::GetOutputPrefType(this, core::mem::transmute_copy(&dwoutputindex)) {
                Ok(ok__) => {
                    pptype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputPrefType<Identity: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwinputindex: u32, ptype: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTopologyNode_Impl::SetInputPrefType(this, core::mem::transmute_copy(&dwinputindex), windows_core::from_raw_borrowed(&ptype)).into()
        }
        unsafe extern "system" fn GetInputPrefType<Identity: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwinputindex: u32, pptype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTopologyNode_Impl::GetInputPrefType(this, core::mem::transmute_copy(&dwinputindex)) {
                Ok(ok__) => {
                    pptype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CloneFrom<Identity: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pnode: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTopologyNode_Impl::CloneFrom(this, windows_core::from_raw_borrowed(&pnode)).into()
        }
        Self {
            base__: IMFAttributes_Vtbl::new::<Identity, OFFSET>(),
            SetObject: SetObject::<Identity, OFFSET>,
            GetObject: GetObject::<Identity, OFFSET>,
            GetNodeType: GetNodeType::<Identity, OFFSET>,
            GetTopoNodeID: GetTopoNodeID::<Identity, OFFSET>,
            SetTopoNodeID: SetTopoNodeID::<Identity, OFFSET>,
            GetInputCount: GetInputCount::<Identity, OFFSET>,
            GetOutputCount: GetOutputCount::<Identity, OFFSET>,
            ConnectOutput: ConnectOutput::<Identity, OFFSET>,
            DisconnectOutput: DisconnectOutput::<Identity, OFFSET>,
            GetInput: GetInput::<Identity, OFFSET>,
            GetOutput: GetOutput::<Identity, OFFSET>,
            SetOutputPrefType: SetOutputPrefType::<Identity, OFFSET>,
            GetOutputPrefType: GetOutputPrefType::<Identity, OFFSET>,
            SetInputPrefType: SetInputPrefType::<Identity, OFFSET>,
            GetInputPrefType: GetInputPrefType::<Identity, OFFSET>,
            CloneFrom: CloneFrom::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTopologyNode as windows_core::Interface>::IID || iid == &<IMFAttributes as windows_core::Interface>::IID
    }
}
pub trait IMFTopologyNodeAttributeEditor_Impl: Sized + windows_core::IUnknownImpl {
    fn UpdateNodeAttributes(&self, topoid: u64, cupdates: u32, pupdates: *const MFTOPONODE_ATTRIBUTE_UPDATE) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFTopologyNodeAttributeEditor {}
impl IMFTopologyNodeAttributeEditor_Vtbl {
    pub const fn new<Identity: IMFTopologyNodeAttributeEditor_Impl, const OFFSET: isize>() -> IMFTopologyNodeAttributeEditor_Vtbl {
        unsafe extern "system" fn UpdateNodeAttributes<Identity: IMFTopologyNodeAttributeEditor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, topoid: u64, cupdates: u32, pupdates: *const MFTOPONODE_ATTRIBUTE_UPDATE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTopologyNodeAttributeEditor_Impl::UpdateNodeAttributes(this, core::mem::transmute_copy(&topoid), core::mem::transmute_copy(&cupdates), core::mem::transmute_copy(&pupdates)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), UpdateNodeAttributes: UpdateNodeAttributes::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTopologyNodeAttributeEditor as windows_core::Interface>::IID
    }
}
pub trait IMFTopologyServiceLookup_Impl: Sized + windows_core::IUnknownImpl {
    fn LookupService(&self, r#type: MF_SERVICE_LOOKUP_TYPE, dwindex: u32, guidservice: *const windows_core::GUID, riid: *const windows_core::GUID, ppvobjects: *mut *mut core::ffi::c_void, pnobjects: *mut u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFTopologyServiceLookup {}
impl IMFTopologyServiceLookup_Vtbl {
    pub const fn new<Identity: IMFTopologyServiceLookup_Impl, const OFFSET: isize>() -> IMFTopologyServiceLookup_Vtbl {
        unsafe extern "system" fn LookupService<Identity: IMFTopologyServiceLookup_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, r#type: MF_SERVICE_LOOKUP_TYPE, dwindex: u32, guidservice: *const windows_core::GUID, riid: *const windows_core::GUID, ppvobjects: *mut *mut core::ffi::c_void, pnobjects: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTopologyServiceLookup_Impl::LookupService(this, core::mem::transmute_copy(&r#type), core::mem::transmute_copy(&dwindex), core::mem::transmute_copy(&guidservice), core::mem::transmute_copy(&riid), core::mem::transmute_copy(&ppvobjects), core::mem::transmute_copy(&pnobjects)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), LookupService: LookupService::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTopologyServiceLookup as windows_core::Interface>::IID
    }
}
pub trait IMFTopologyServiceLookupClient_Impl: Sized + windows_core::IUnknownImpl {
    fn InitServicePointers(&self, plookup: Option<&IMFTopologyServiceLookup>) -> windows_core::Result<()>;
    fn ReleaseServicePointers(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFTopologyServiceLookupClient {}
impl IMFTopologyServiceLookupClient_Vtbl {
    pub const fn new<Identity: IMFTopologyServiceLookupClient_Impl, const OFFSET: isize>() -> IMFTopologyServiceLookupClient_Vtbl {
        unsafe extern "system" fn InitServicePointers<Identity: IMFTopologyServiceLookupClient_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plookup: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTopologyServiceLookupClient_Impl::InitServicePointers(this, windows_core::from_raw_borrowed(&plookup)).into()
        }
        unsafe extern "system" fn ReleaseServicePointers<Identity: IMFTopologyServiceLookupClient_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTopologyServiceLookupClient_Impl::ReleaseServicePointers(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            InitServicePointers: InitServicePointers::<Identity, OFFSET>,
            ReleaseServicePointers: ReleaseServicePointers::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTopologyServiceLookupClient as windows_core::Interface>::IID
    }
}
pub trait IMFTrackedSample_Impl: Sized + windows_core::IUnknownImpl {
    fn SetAllocator(&self, psampleallocator: Option<&IMFAsyncCallback>, punkstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFTrackedSample {}
impl IMFTrackedSample_Vtbl {
    pub const fn new<Identity: IMFTrackedSample_Impl, const OFFSET: isize>() -> IMFTrackedSample_Vtbl {
        unsafe extern "system" fn SetAllocator<Identity: IMFTrackedSample_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psampleallocator: *mut core::ffi::c_void, punkstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTrackedSample_Impl::SetAllocator(this, windows_core::from_raw_borrowed(&psampleallocator), windows_core::from_raw_borrowed(&punkstate)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), SetAllocator: SetAllocator::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTrackedSample as windows_core::Interface>::IID
    }
}
pub trait IMFTranscodeProfile_Impl: Sized + windows_core::IUnknownImpl {
    fn SetAudioAttributes(&self, pattrs: Option<&IMFAttributes>) -> windows_core::Result<()>;
    fn GetAudioAttributes(&self) -> windows_core::Result<IMFAttributes>;
    fn SetVideoAttributes(&self, pattrs: Option<&IMFAttributes>) -> windows_core::Result<()>;
    fn GetVideoAttributes(&self) -> windows_core::Result<IMFAttributes>;
    fn SetContainerAttributes(&self, pattrs: Option<&IMFAttributes>) -> windows_core::Result<()>;
    fn GetContainerAttributes(&self) -> windows_core::Result<IMFAttributes>;
}
impl windows_core::RuntimeName for IMFTranscodeProfile {}
impl IMFTranscodeProfile_Vtbl {
    pub const fn new<Identity: IMFTranscodeProfile_Impl, const OFFSET: isize>() -> IMFTranscodeProfile_Vtbl {
        unsafe extern "system" fn SetAudioAttributes<Identity: IMFTranscodeProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pattrs: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTranscodeProfile_Impl::SetAudioAttributes(this, windows_core::from_raw_borrowed(&pattrs)).into()
        }
        unsafe extern "system" fn GetAudioAttributes<Identity: IMFTranscodeProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppattrs: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTranscodeProfile_Impl::GetAudioAttributes(this) {
                Ok(ok__) => {
                    ppattrs.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoAttributes<Identity: IMFTranscodeProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pattrs: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTranscodeProfile_Impl::SetVideoAttributes(this, windows_core::from_raw_borrowed(&pattrs)).into()
        }
        unsafe extern "system" fn GetVideoAttributes<Identity: IMFTranscodeProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppattrs: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTranscodeProfile_Impl::GetVideoAttributes(this) {
                Ok(ok__) => {
                    ppattrs.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContainerAttributes<Identity: IMFTranscodeProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pattrs: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTranscodeProfile_Impl::SetContainerAttributes(this, windows_core::from_raw_borrowed(&pattrs)).into()
        }
        unsafe extern "system" fn GetContainerAttributes<Identity: IMFTranscodeProfile_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppattrs: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTranscodeProfile_Impl::GetContainerAttributes(this) {
                Ok(ok__) => {
                    ppattrs.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetAudioAttributes: SetAudioAttributes::<Identity, OFFSET>,
            GetAudioAttributes: GetAudioAttributes::<Identity, OFFSET>,
            SetVideoAttributes: SetVideoAttributes::<Identity, OFFSET>,
            GetVideoAttributes: GetVideoAttributes::<Identity, OFFSET>,
            SetContainerAttributes: SetContainerAttributes::<Identity, OFFSET>,
            GetContainerAttributes: GetContainerAttributes::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTranscodeProfile as windows_core::Interface>::IID
    }
}
pub trait IMFTranscodeSinkInfoProvider_Impl: Sized + windows_core::IUnknownImpl {
    fn SetOutputFile(&self, pwszfilename: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn SetOutputByteStream(&self, pbytestreamactivate: Option<&IMFActivate>) -> windows_core::Result<()>;
    fn SetProfile(&self, pprofile: Option<&IMFTranscodeProfile>) -> windows_core::Result<()>;
    fn GetSinkInfo(&self) -> windows_core::Result<MF_TRANSCODE_SINK_INFO>;
}
impl windows_core::RuntimeName for IMFTranscodeSinkInfoProvider {}
impl IMFTranscodeSinkInfoProvider_Vtbl {
    pub const fn new<Identity: IMFTranscodeSinkInfoProvider_Impl, const OFFSET: isize>() -> IMFTranscodeSinkInfoProvider_Vtbl {
        unsafe extern "system" fn SetOutputFile<Identity: IMFTranscodeSinkInfoProvider_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwszfilename: windows_core::PCWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTranscodeSinkInfoProvider_Impl::SetOutputFile(this, core::mem::transmute(&pwszfilename)).into()
        }
        unsafe extern "system" fn SetOutputByteStream<Identity: IMFTranscodeSinkInfoProvider_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbytestreamactivate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTranscodeSinkInfoProvider_Impl::SetOutputByteStream(this, windows_core::from_raw_borrowed(&pbytestreamactivate)).into()
        }
        unsafe extern "system" fn SetProfile<Identity: IMFTranscodeSinkInfoProvider_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pprofile: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTranscodeSinkInfoProvider_Impl::SetProfile(this, windows_core::from_raw_borrowed(&pprofile)).into()
        }
        unsafe extern "system" fn GetSinkInfo<Identity: IMFTranscodeSinkInfoProvider_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psinkinfo: *mut MF_TRANSCODE_SINK_INFO) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTranscodeSinkInfoProvider_Impl::GetSinkInfo(this) {
                Ok(ok__) => {
                    psinkinfo.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetOutputFile: SetOutputFile::<Identity, OFFSET>,
            SetOutputByteStream: SetOutputByteStream::<Identity, OFFSET>,
            SetProfile: SetProfile::<Identity, OFFSET>,
            GetSinkInfo: GetSinkInfo::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTranscodeSinkInfoProvider as windows_core::Interface>::IID
    }
}
pub trait IMFTransform_Impl: Sized + windows_core::IUnknownImpl {
    fn GetStreamLimits(&self, pdwinputminimum: *mut u32, pdwinputmaximum: *mut u32, pdwoutputminimum: *mut u32, pdwoutputmaximum: *mut u32) -> windows_core::Result<()>;
    fn GetStreamCount(&self, pcinputstreams: *mut u32, pcoutputstreams: *mut u32) -> windows_core::Result<()>;
    fn GetStreamIDs(&self, dwinputidarraysize: u32, pdwinputids: *mut u32, dwoutputidarraysize: u32, pdwoutputids: *mut u32) -> windows_core::Result<()>;
    fn GetInputStreamInfo(&self, dwinputstreamid: u32, pstreaminfo: *mut MFT_INPUT_STREAM_INFO) -> windows_core::Result<()>;
    fn GetOutputStreamInfo(&self, dwoutputstreamid: u32) -> windows_core::Result<MFT_OUTPUT_STREAM_INFO>;
    fn GetAttributes(&self) -> windows_core::Result<IMFAttributes>;
    fn GetInputStreamAttributes(&self, dwinputstreamid: u32) -> windows_core::Result<IMFAttributes>;
    fn GetOutputStreamAttributes(&self, dwoutputstreamid: u32) -> windows_core::Result<IMFAttributes>;
    fn DeleteInputStream(&self, dwstreamid: u32) -> windows_core::Result<()>;
    fn AddInputStreams(&self, cstreams: u32, adwstreamids: *const u32) -> windows_core::Result<()>;
    fn GetInputAvailableType(&self, dwinputstreamid: u32, dwtypeindex: u32) -> windows_core::Result<IMFMediaType>;
    fn GetOutputAvailableType(&self, dwoutputstreamid: u32, dwtypeindex: u32) -> windows_core::Result<IMFMediaType>;
    fn SetInputType(&self, dwinputstreamid: u32, ptype: Option<&IMFMediaType>, dwflags: u32) -> windows_core::Result<()>;
    fn SetOutputType(&self, dwoutputstreamid: u32, ptype: Option<&IMFMediaType>, dwflags: u32) -> windows_core::Result<()>;
    fn GetInputCurrentType(&self, dwinputstreamid: u32) -> windows_core::Result<IMFMediaType>;
    fn GetOutputCurrentType(&self, dwoutputstreamid: u32) -> windows_core::Result<IMFMediaType>;
    fn GetInputStatus(&self, dwinputstreamid: u32) -> windows_core::Result<u32>;
    fn GetOutputStatus(&self) -> windows_core::Result<u32>;
    fn SetOutputBounds(&self, hnslowerbound: i64, hnsupperbound: i64) -> windows_core::Result<()>;
    fn ProcessEvent(&self, dwinputstreamid: u32, pevent: Option<&IMFMediaEvent>) -> windows_core::Result<()>;
    fn ProcessMessage(&self, emessage: MFT_MESSAGE_TYPE, ulparam: usize) -> windows_core::Result<()>;
    fn ProcessInput(&self, dwinputstreamid: u32, psample: Option<&IMFSample>, dwflags: u32) -> windows_core::Result<()>;
    fn ProcessOutput(&self, dwflags: u32, coutputbuffercount: u32, poutputsamples: *mut MFT_OUTPUT_DATA_BUFFER, pdwstatus: *mut u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFTransform {}
impl IMFTransform_Vtbl {
    pub const fn new<Identity: IMFTransform_Impl, const OFFSET: isize>() -> IMFTransform_Vtbl {
        unsafe extern "system" fn GetStreamLimits<Identity: IMFTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwinputminimum: *mut u32, pdwinputmaximum: *mut u32, pdwoutputminimum: *mut u32, pdwoutputmaximum: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTransform_Impl::GetStreamLimits(this, core::mem::transmute_copy(&pdwinputminimum), core::mem::transmute_copy(&pdwinputmaximum), core::mem::transmute_copy(&pdwoutputminimum), core::mem::transmute_copy(&pdwoutputmaximum)).into()
        }
        unsafe extern "system" fn GetStreamCount<Identity: IMFTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcinputstreams: *mut u32, pcoutputstreams: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTransform_Impl::GetStreamCount(this, core::mem::transmute_copy(&pcinputstreams), core::mem::transmute_copy(&pcoutputstreams)).into()
        }
        unsafe extern "system" fn GetStreamIDs<Identity: IMFTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwinputidarraysize: u32, pdwinputids: *mut u32, dwoutputidarraysize: u32, pdwoutputids: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTransform_Impl::GetStreamIDs(this, core::mem::transmute_copy(&dwinputidarraysize), core::mem::transmute_copy(&pdwinputids), core::mem::transmute_copy(&dwoutputidarraysize), core::mem::transmute_copy(&pdwoutputids)).into()
        }
        unsafe extern "system" fn GetInputStreamInfo<Identity: IMFTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwinputstreamid: u32, pstreaminfo: *mut MFT_INPUT_STREAM_INFO) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTransform_Impl::GetInputStreamInfo(this, core::mem::transmute_copy(&dwinputstreamid), core::mem::transmute_copy(&pstreaminfo)).into()
        }
        unsafe extern "system" fn GetOutputStreamInfo<Identity: IMFTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwoutputstreamid: u32, pstreaminfo: *mut MFT_OUTPUT_STREAM_INFO) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTransform_Impl::GetOutputStreamInfo(this, core::mem::transmute_copy(&dwoutputstreamid)) {
                Ok(ok__) => {
                    pstreaminfo.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAttributes<Identity: IMFTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pattributes: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTransform_Impl::GetAttributes(this) {
                Ok(ok__) => {
                    pattributes.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInputStreamAttributes<Identity: IMFTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwinputstreamid: u32, pattributes: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTransform_Impl::GetInputStreamAttributes(this, core::mem::transmute_copy(&dwinputstreamid)) {
                Ok(ok__) => {
                    pattributes.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputStreamAttributes<Identity: IMFTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwoutputstreamid: u32, pattributes: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTransform_Impl::GetOutputStreamAttributes(this, core::mem::transmute_copy(&dwoutputstreamid)) {
                Ok(ok__) => {
                    pattributes.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DeleteInputStream<Identity: IMFTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTransform_Impl::DeleteInputStream(this, core::mem::transmute_copy(&dwstreamid)).into()
        }
        unsafe extern "system" fn AddInputStreams<Identity: IMFTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cstreams: u32, adwstreamids: *const u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTransform_Impl::AddInputStreams(this, core::mem::transmute_copy(&cstreams), core::mem::transmute_copy(&adwstreamids)).into()
        }
        unsafe extern "system" fn GetInputAvailableType<Identity: IMFTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwinputstreamid: u32, dwtypeindex: u32, pptype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTransform_Impl::GetInputAvailableType(this, core::mem::transmute_copy(&dwinputstreamid), core::mem::transmute_copy(&dwtypeindex)) {
                Ok(ok__) => {
                    pptype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputAvailableType<Identity: IMFTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwoutputstreamid: u32, dwtypeindex: u32, pptype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTransform_Impl::GetOutputAvailableType(this, core::mem::transmute_copy(&dwoutputstreamid), core::mem::transmute_copy(&dwtypeindex)) {
                Ok(ok__) => {
                    pptype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputType<Identity: IMFTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwinputstreamid: u32, ptype: *mut core::ffi::c_void, dwflags: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTransform_Impl::SetInputType(this, core::mem::transmute_copy(&dwinputstreamid), windows_core::from_raw_borrowed(&ptype), core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn SetOutputType<Identity: IMFTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwoutputstreamid: u32, ptype: *mut core::ffi::c_void, dwflags: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTransform_Impl::SetOutputType(this, core::mem::transmute_copy(&dwoutputstreamid), windows_core::from_raw_borrowed(&ptype), core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn GetInputCurrentType<Identity: IMFTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwinputstreamid: u32, pptype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTransform_Impl::GetInputCurrentType(this, core::mem::transmute_copy(&dwinputstreamid)) {
                Ok(ok__) => {
                    pptype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputCurrentType<Identity: IMFTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwoutputstreamid: u32, pptype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTransform_Impl::GetOutputCurrentType(this, core::mem::transmute_copy(&dwoutputstreamid)) {
                Ok(ok__) => {
                    pptype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInputStatus<Identity: IMFTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwinputstreamid: u32, pdwflags: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTransform_Impl::GetInputStatus(this, core::mem::transmute_copy(&dwinputstreamid)) {
                Ok(ok__) => {
                    pdwflags.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputStatus<Identity: IMFTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwflags: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTransform_Impl::GetOutputStatus(this) {
                Ok(ok__) => {
                    pdwflags.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputBounds<Identity: IMFTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hnslowerbound: i64, hnsupperbound: i64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTransform_Impl::SetOutputBounds(this, core::mem::transmute_copy(&hnslowerbound), core::mem::transmute_copy(&hnsupperbound)).into()
        }
        unsafe extern "system" fn ProcessEvent<Identity: IMFTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwinputstreamid: u32, pevent: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTransform_Impl::ProcessEvent(this, core::mem::transmute_copy(&dwinputstreamid), windows_core::from_raw_borrowed(&pevent)).into()
        }
        unsafe extern "system" fn ProcessMessage<Identity: IMFTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, emessage: MFT_MESSAGE_TYPE, ulparam: usize) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTransform_Impl::ProcessMessage(this, core::mem::transmute_copy(&emessage), core::mem::transmute_copy(&ulparam)).into()
        }
        unsafe extern "system" fn ProcessInput<Identity: IMFTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwinputstreamid: u32, psample: *mut core::ffi::c_void, dwflags: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTransform_Impl::ProcessInput(this, core::mem::transmute_copy(&dwinputstreamid), windows_core::from_raw_borrowed(&psample), core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn ProcessOutput<Identity: IMFTransform_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32, coutputbuffercount: u32, poutputsamples: *mut MFT_OUTPUT_DATA_BUFFER, pdwstatus: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFTransform_Impl::ProcessOutput(this, core::mem::transmute_copy(&dwflags), core::mem::transmute_copy(&coutputbuffercount), core::mem::transmute_copy(&poutputsamples), core::mem::transmute_copy(&pdwstatus)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetStreamLimits: GetStreamLimits::<Identity, OFFSET>,
            GetStreamCount: GetStreamCount::<Identity, OFFSET>,
            GetStreamIDs: GetStreamIDs::<Identity, OFFSET>,
            GetInputStreamInfo: GetInputStreamInfo::<Identity, OFFSET>,
            GetOutputStreamInfo: GetOutputStreamInfo::<Identity, OFFSET>,
            GetAttributes: GetAttributes::<Identity, OFFSET>,
            GetInputStreamAttributes: GetInputStreamAttributes::<Identity, OFFSET>,
            GetOutputStreamAttributes: GetOutputStreamAttributes::<Identity, OFFSET>,
            DeleteInputStream: DeleteInputStream::<Identity, OFFSET>,
            AddInputStreams: AddInputStreams::<Identity, OFFSET>,
            GetInputAvailableType: GetInputAvailableType::<Identity, OFFSET>,
            GetOutputAvailableType: GetOutputAvailableType::<Identity, OFFSET>,
            SetInputType: SetInputType::<Identity, OFFSET>,
            SetOutputType: SetOutputType::<Identity, OFFSET>,
            GetInputCurrentType: GetInputCurrentType::<Identity, OFFSET>,
            GetOutputCurrentType: GetOutputCurrentType::<Identity, OFFSET>,
            GetInputStatus: GetInputStatus::<Identity, OFFSET>,
            GetOutputStatus: GetOutputStatus::<Identity, OFFSET>,
            SetOutputBounds: SetOutputBounds::<Identity, OFFSET>,
            ProcessEvent: ProcessEvent::<Identity, OFFSET>,
            ProcessMessage: ProcessMessage::<Identity, OFFSET>,
            ProcessInput: ProcessInput::<Identity, OFFSET>,
            ProcessOutput: ProcessOutput::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTransform as windows_core::Interface>::IID
    }
}
pub trait IMFTrustedInput_Impl: Sized + windows_core::IUnknownImpl {
    fn GetInputTrustAuthority(&self, dwstreamid: u32, riid: *const windows_core::GUID) -> windows_core::Result<windows_core::IUnknown>;
}
impl windows_core::RuntimeName for IMFTrustedInput {}
impl IMFTrustedInput_Vtbl {
    pub const fn new<Identity: IMFTrustedInput_Impl, const OFFSET: isize>() -> IMFTrustedInput_Vtbl {
        unsafe extern "system" fn GetInputTrustAuthority<Identity: IMFTrustedInput_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, riid: *const windows_core::GUID, ppunkobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTrustedInput_Impl::GetInputTrustAuthority(this, core::mem::transmute_copy(&dwstreamid), core::mem::transmute_copy(&riid)) {
                Ok(ok__) => {
                    ppunkobject.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetInputTrustAuthority: GetInputTrustAuthority::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTrustedInput as windows_core::Interface>::IID
    }
}
pub trait IMFTrustedOutput_Impl: Sized + windows_core::IUnknownImpl {
    fn GetOutputTrustAuthorityCount(&self) -> windows_core::Result<u32>;
    fn GetOutputTrustAuthorityByIndex(&self, dwindex: u32) -> windows_core::Result<IMFOutputTrustAuthority>;
    fn IsFinal(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
}
impl windows_core::RuntimeName for IMFTrustedOutput {}
impl IMFTrustedOutput_Vtbl {
    pub const fn new<Identity: IMFTrustedOutput_Impl, const OFFSET: isize>() -> IMFTrustedOutput_Vtbl {
        unsafe extern "system" fn GetOutputTrustAuthorityCount<Identity: IMFTrustedOutput_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcoutputtrustauthorities: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTrustedOutput_Impl::GetOutputTrustAuthorityCount(this) {
                Ok(ok__) => {
                    pcoutputtrustauthorities.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputTrustAuthorityByIndex<Identity: IMFTrustedOutput_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwindex: u32, ppauthority: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTrustedOutput_Impl::GetOutputTrustAuthorityByIndex(this, core::mem::transmute_copy(&dwindex)) {
                Ok(ok__) => {
                    ppauthority.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFinal<Identity: IMFTrustedOutput_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfisfinal: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFTrustedOutput_Impl::IsFinal(this) {
                Ok(ok__) => {
                    pfisfinal.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetOutputTrustAuthorityCount: GetOutputTrustAuthorityCount::<Identity, OFFSET>,
            GetOutputTrustAuthorityByIndex: GetOutputTrustAuthorityByIndex::<Identity, OFFSET>,
            IsFinal: IsFinal::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFTrustedOutput as windows_core::Interface>::IID
    }
}
pub trait IMFVideoCaptureSampleAllocator_Impl: Sized + IMFVideoSampleAllocator_Impl {
    fn InitializeCaptureSampleAllocator(&self, cbsamplesize: u32, cbcapturemetadatasize: u32, cbalignment: u32, cminimumsamples: u32, pattributes: Option<&IMFAttributes>, pmediatype: Option<&IMFMediaType>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFVideoCaptureSampleAllocator {}
impl IMFVideoCaptureSampleAllocator_Vtbl {
    pub const fn new<Identity: IMFVideoCaptureSampleAllocator_Impl, const OFFSET: isize>() -> IMFVideoCaptureSampleAllocator_Vtbl {
        unsafe extern "system" fn InitializeCaptureSampleAllocator<Identity: IMFVideoCaptureSampleAllocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cbsamplesize: u32, cbcapturemetadatasize: u32, cbalignment: u32, cminimumsamples: u32, pattributes: *mut core::ffi::c_void, pmediatype: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoCaptureSampleAllocator_Impl::InitializeCaptureSampleAllocator(this, core::mem::transmute_copy(&cbsamplesize), core::mem::transmute_copy(&cbcapturemetadatasize), core::mem::transmute_copy(&cbalignment), core::mem::transmute_copy(&cminimumsamples), windows_core::from_raw_borrowed(&pattributes), windows_core::from_raw_borrowed(&pmediatype)).into()
        }
        Self {
            base__: IMFVideoSampleAllocator_Vtbl::new::<Identity, OFFSET>(),
            InitializeCaptureSampleAllocator: InitializeCaptureSampleAllocator::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFVideoCaptureSampleAllocator as windows_core::Interface>::IID || iid == &<IMFVideoSampleAllocator as windows_core::Interface>::IID
    }
}
pub trait IMFVideoDeviceID_Impl: Sized + windows_core::IUnknownImpl {
    fn GetDeviceID(&self) -> windows_core::Result<windows_core::GUID>;
}
impl windows_core::RuntimeName for IMFVideoDeviceID {}
impl IMFVideoDeviceID_Vtbl {
    pub const fn new<Identity: IMFVideoDeviceID_Impl, const OFFSET: isize>() -> IMFVideoDeviceID_Vtbl {
        unsafe extern "system" fn GetDeviceID<Identity: IMFVideoDeviceID_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdeviceid: *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFVideoDeviceID_Impl::GetDeviceID(this) {
                Ok(ok__) => {
                    pdeviceid.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetDeviceID: GetDeviceID::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFVideoDeviceID as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Gdi")]
pub trait IMFVideoDisplayControl_Impl: Sized + windows_core::IUnknownImpl {
    fn GetNativeVideoSize(&self, pszvideo: *mut super::super::Foundation::SIZE, pszarvideo: *mut super::super::Foundation::SIZE) -> windows_core::Result<()>;
    fn GetIdealVideoSize(&self, pszmin: *mut super::super::Foundation::SIZE, pszmax: *mut super::super::Foundation::SIZE) -> windows_core::Result<()>;
    fn SetVideoPosition(&self, pnrcsource: *const MFVideoNormalizedRect, prcdest: *const super::super::Foundation::RECT) -> windows_core::Result<()>;
    fn GetVideoPosition(&self, pnrcsource: *mut MFVideoNormalizedRect, prcdest: *mut super::super::Foundation::RECT) -> windows_core::Result<()>;
    fn SetAspectRatioMode(&self, dwaspectratiomode: u32) -> windows_core::Result<()>;
    fn GetAspectRatioMode(&self) -> windows_core::Result<u32>;
    fn SetVideoWindow(&self, hwndvideo: super::super::Foundation::HWND) -> windows_core::Result<()>;
    fn GetVideoWindow(&self) -> windows_core::Result<super::super::Foundation::HWND>;
    fn RepaintVideo(&self) -> windows_core::Result<()>;
    fn GetCurrentImage(&self, pbih: *mut super::super::Graphics::Gdi::BITMAPINFOHEADER, pdib: *mut *mut u8, pcbdib: *mut u32, ptimestamp: *mut i64) -> windows_core::Result<()>;
    fn SetBorderColor(&self, clr: super::super::Foundation::COLORREF) -> windows_core::Result<()>;
    fn GetBorderColor(&self) -> windows_core::Result<super::super::Foundation::COLORREF>;
    fn SetRenderingPrefs(&self, dwrenderflags: u32) -> windows_core::Result<()>;
    fn GetRenderingPrefs(&self) -> windows_core::Result<u32>;
    fn SetFullscreen(&self, ffullscreen: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn GetFullscreen(&self) -> windows_core::Result<super::super::Foundation::BOOL>;
}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl windows_core::RuntimeName for IMFVideoDisplayControl {}
#[cfg(feature = "Win32_Graphics_Gdi")]
impl IMFVideoDisplayControl_Vtbl {
    pub const fn new<Identity: IMFVideoDisplayControl_Impl, const OFFSET: isize>() -> IMFVideoDisplayControl_Vtbl {
        unsafe extern "system" fn GetNativeVideoSize<Identity: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszvideo: *mut super::super::Foundation::SIZE, pszarvideo: *mut super::super::Foundation::SIZE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoDisplayControl_Impl::GetNativeVideoSize(this, core::mem::transmute_copy(&pszvideo), core::mem::transmute_copy(&pszarvideo)).into()
        }
        unsafe extern "system" fn GetIdealVideoSize<Identity: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pszmin: *mut super::super::Foundation::SIZE, pszmax: *mut super::super::Foundation::SIZE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoDisplayControl_Impl::GetIdealVideoSize(this, core::mem::transmute_copy(&pszmin), core::mem::transmute_copy(&pszmax)).into()
        }
        unsafe extern "system" fn SetVideoPosition<Identity: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pnrcsource: *const MFVideoNormalizedRect, prcdest: *const super::super::Foundation::RECT) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoDisplayControl_Impl::SetVideoPosition(this, core::mem::transmute_copy(&pnrcsource), core::mem::transmute_copy(&prcdest)).into()
        }
        unsafe extern "system" fn GetVideoPosition<Identity: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pnrcsource: *mut MFVideoNormalizedRect, prcdest: *mut super::super::Foundation::RECT) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoDisplayControl_Impl::GetVideoPosition(this, core::mem::transmute_copy(&pnrcsource), core::mem::transmute_copy(&prcdest)).into()
        }
        unsafe extern "system" fn SetAspectRatioMode<Identity: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwaspectratiomode: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoDisplayControl_Impl::SetAspectRatioMode(this, core::mem::transmute_copy(&dwaspectratiomode)).into()
        }
        unsafe extern "system" fn GetAspectRatioMode<Identity: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwaspectratiomode: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFVideoDisplayControl_Impl::GetAspectRatioMode(this) {
                Ok(ok__) => {
                    pdwaspectratiomode.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoWindow<Identity: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, hwndvideo: super::super::Foundation::HWND) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoDisplayControl_Impl::SetVideoWindow(this, core::mem::transmute_copy(&hwndvideo)).into()
        }
        unsafe extern "system" fn GetVideoWindow<Identity: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, phwndvideo: *mut super::super::Foundation::HWND) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFVideoDisplayControl_Impl::GetVideoWindow(this) {
                Ok(ok__) => {
                    phwndvideo.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RepaintVideo<Identity: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoDisplayControl_Impl::RepaintVideo(this).into()
        }
        unsafe extern "system" fn GetCurrentImage<Identity: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbih: *mut super::super::Graphics::Gdi::BITMAPINFOHEADER, pdib: *mut *mut u8, pcbdib: *mut u32, ptimestamp: *mut i64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoDisplayControl_Impl::GetCurrentImage(this, core::mem::transmute_copy(&pbih), core::mem::transmute_copy(&pdib), core::mem::transmute_copy(&pcbdib), core::mem::transmute_copy(&ptimestamp)).into()
        }
        unsafe extern "system" fn SetBorderColor<Identity: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clr: super::super::Foundation::COLORREF) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoDisplayControl_Impl::SetBorderColor(this, core::mem::transmute_copy(&clr)).into()
        }
        unsafe extern "system" fn GetBorderColor<Identity: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pclr: *mut super::super::Foundation::COLORREF) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFVideoDisplayControl_Impl::GetBorderColor(this) {
                Ok(ok__) => {
                    pclr.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRenderingPrefs<Identity: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwrenderflags: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoDisplayControl_Impl::SetRenderingPrefs(this, core::mem::transmute_copy(&dwrenderflags)).into()
        }
        unsafe extern "system" fn GetRenderingPrefs<Identity: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwrenderflags: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFVideoDisplayControl_Impl::GetRenderingPrefs(this) {
                Ok(ok__) => {
                    pdwrenderflags.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFullscreen<Identity: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ffullscreen: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoDisplayControl_Impl::SetFullscreen(this, core::mem::transmute_copy(&ffullscreen)).into()
        }
        unsafe extern "system" fn GetFullscreen<Identity: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pffullscreen: *mut super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFVideoDisplayControl_Impl::GetFullscreen(this) {
                Ok(ok__) => {
                    pffullscreen.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetNativeVideoSize: GetNativeVideoSize::<Identity, OFFSET>,
            GetIdealVideoSize: GetIdealVideoSize::<Identity, OFFSET>,
            SetVideoPosition: SetVideoPosition::<Identity, OFFSET>,
            GetVideoPosition: GetVideoPosition::<Identity, OFFSET>,
            SetAspectRatioMode: SetAspectRatioMode::<Identity, OFFSET>,
            GetAspectRatioMode: GetAspectRatioMode::<Identity, OFFSET>,
            SetVideoWindow: SetVideoWindow::<Identity, OFFSET>,
            GetVideoWindow: GetVideoWindow::<Identity, OFFSET>,
            RepaintVideo: RepaintVideo::<Identity, OFFSET>,
            GetCurrentImage: GetCurrentImage::<Identity, OFFSET>,
            SetBorderColor: SetBorderColor::<Identity, OFFSET>,
            GetBorderColor: GetBorderColor::<Identity, OFFSET>,
            SetRenderingPrefs: SetRenderingPrefs::<Identity, OFFSET>,
            GetRenderingPrefs: GetRenderingPrefs::<Identity, OFFSET>,
            SetFullscreen: SetFullscreen::<Identity, OFFSET>,
            GetFullscreen: GetFullscreen::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFVideoDisplayControl as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFVideoMediaType_Impl: Sized + IMFMediaType_Impl {
    fn GetVideoFormat(&self) -> *mut MFVIDEOFORMAT;
    fn GetVideoRepresentation(&self, guidrepresentation: &windows_core::GUID, ppvrepresentation: *mut *mut core::ffi::c_void, lstride: i32) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFVideoMediaType {}
#[cfg(all(feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFVideoMediaType_Vtbl {
    pub const fn new<Identity: IMFVideoMediaType_Impl, const OFFSET: isize>() -> IMFVideoMediaType_Vtbl {
        unsafe extern "system" fn GetVideoFormat<Identity: IMFVideoMediaType_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> *mut MFVIDEOFORMAT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoMediaType_Impl::GetVideoFormat(this)
        }
        unsafe extern "system" fn GetVideoRepresentation<Identity: IMFVideoMediaType_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidrepresentation: windows_core::GUID, ppvrepresentation: *mut *mut core::ffi::c_void, lstride: i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoMediaType_Impl::GetVideoRepresentation(this, core::mem::transmute(&guidrepresentation), core::mem::transmute_copy(&ppvrepresentation), core::mem::transmute_copy(&lstride)).into()
        }
        Self {
            base__: IMFMediaType_Vtbl::new::<Identity, OFFSET>(),
            GetVideoFormat: GetVideoFormat::<Identity, OFFSET>,
            GetVideoRepresentation: GetVideoRepresentation::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFVideoMediaType as windows_core::Interface>::IID || iid == &<IMFAttributes as windows_core::Interface>::IID || iid == &<IMFMediaType as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
pub trait IMFVideoMixerBitmap_Impl: Sized + windows_core::IUnknownImpl {
    fn SetAlphaBitmap(&self, pbmpparms: *const MFVideoAlphaBitmap) -> windows_core::Result<()>;
    fn ClearAlphaBitmap(&self) -> windows_core::Result<()>;
    fn UpdateAlphaBitmapParameters(&self, pbmpparms: *const MFVideoAlphaBitmapParams) -> windows_core::Result<()>;
    fn GetAlphaBitmapParameters(&self, pbmpparms: *mut MFVideoAlphaBitmapParams) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
impl windows_core::RuntimeName for IMFVideoMixerBitmap {}
#[cfg(all(feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
impl IMFVideoMixerBitmap_Vtbl {
    pub const fn new<Identity: IMFVideoMixerBitmap_Impl, const OFFSET: isize>() -> IMFVideoMixerBitmap_Vtbl {
        unsafe extern "system" fn SetAlphaBitmap<Identity: IMFVideoMixerBitmap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbmpparms: *const MFVideoAlphaBitmap) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoMixerBitmap_Impl::SetAlphaBitmap(this, core::mem::transmute_copy(&pbmpparms)).into()
        }
        unsafe extern "system" fn ClearAlphaBitmap<Identity: IMFVideoMixerBitmap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoMixerBitmap_Impl::ClearAlphaBitmap(this).into()
        }
        unsafe extern "system" fn UpdateAlphaBitmapParameters<Identity: IMFVideoMixerBitmap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbmpparms: *const MFVideoAlphaBitmapParams) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoMixerBitmap_Impl::UpdateAlphaBitmapParameters(this, core::mem::transmute_copy(&pbmpparms)).into()
        }
        unsafe extern "system" fn GetAlphaBitmapParameters<Identity: IMFVideoMixerBitmap_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbmpparms: *mut MFVideoAlphaBitmapParams) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoMixerBitmap_Impl::GetAlphaBitmapParameters(this, core::mem::transmute_copy(&pbmpparms)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetAlphaBitmap: SetAlphaBitmap::<Identity, OFFSET>,
            ClearAlphaBitmap: ClearAlphaBitmap::<Identity, OFFSET>,
            UpdateAlphaBitmapParameters: UpdateAlphaBitmapParameters::<Identity, OFFSET>,
            GetAlphaBitmapParameters: GetAlphaBitmapParameters::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFVideoMixerBitmap as windows_core::Interface>::IID
    }
}
pub trait IMFVideoMixerControl_Impl: Sized + windows_core::IUnknownImpl {
    fn SetStreamZOrder(&self, dwstreamid: u32, dwz: u32) -> windows_core::Result<()>;
    fn GetStreamZOrder(&self, dwstreamid: u32) -> windows_core::Result<u32>;
    fn SetStreamOutputRect(&self, dwstreamid: u32, pnrcoutput: *const MFVideoNormalizedRect) -> windows_core::Result<()>;
    fn GetStreamOutputRect(&self, dwstreamid: u32) -> windows_core::Result<MFVideoNormalizedRect>;
}
impl windows_core::RuntimeName for IMFVideoMixerControl {}
impl IMFVideoMixerControl_Vtbl {
    pub const fn new<Identity: IMFVideoMixerControl_Impl, const OFFSET: isize>() -> IMFVideoMixerControl_Vtbl {
        unsafe extern "system" fn SetStreamZOrder<Identity: IMFVideoMixerControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, dwz: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoMixerControl_Impl::SetStreamZOrder(this, core::mem::transmute_copy(&dwstreamid), core::mem::transmute_copy(&dwz)).into()
        }
        unsafe extern "system" fn GetStreamZOrder<Identity: IMFVideoMixerControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, pdwz: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFVideoMixerControl_Impl::GetStreamZOrder(this, core::mem::transmute_copy(&dwstreamid)) {
                Ok(ok__) => {
                    pdwz.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamOutputRect<Identity: IMFVideoMixerControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, pnrcoutput: *const MFVideoNormalizedRect) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoMixerControl_Impl::SetStreamOutputRect(this, core::mem::transmute_copy(&dwstreamid), core::mem::transmute_copy(&pnrcoutput)).into()
        }
        unsafe extern "system" fn GetStreamOutputRect<Identity: IMFVideoMixerControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwstreamid: u32, pnrcoutput: *mut MFVideoNormalizedRect) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFVideoMixerControl_Impl::GetStreamOutputRect(this, core::mem::transmute_copy(&dwstreamid)) {
                Ok(ok__) => {
                    pnrcoutput.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetStreamZOrder: SetStreamZOrder::<Identity, OFFSET>,
            GetStreamZOrder: GetStreamZOrder::<Identity, OFFSET>,
            SetStreamOutputRect: SetStreamOutputRect::<Identity, OFFSET>,
            GetStreamOutputRect: GetStreamOutputRect::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFVideoMixerControl as windows_core::Interface>::IID
    }
}
pub trait IMFVideoMixerControl2_Impl: Sized + IMFVideoMixerControl_Impl {
    fn SetMixingPrefs(&self, dwmixflags: u32) -> windows_core::Result<()>;
    fn GetMixingPrefs(&self) -> windows_core::Result<u32>;
}
impl windows_core::RuntimeName for IMFVideoMixerControl2 {}
impl IMFVideoMixerControl2_Vtbl {
    pub const fn new<Identity: IMFVideoMixerControl2_Impl, const OFFSET: isize>() -> IMFVideoMixerControl2_Vtbl {
        unsafe extern "system" fn SetMixingPrefs<Identity: IMFVideoMixerControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwmixflags: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoMixerControl2_Impl::SetMixingPrefs(this, core::mem::transmute_copy(&dwmixflags)).into()
        }
        unsafe extern "system" fn GetMixingPrefs<Identity: IMFVideoMixerControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwmixflags: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFVideoMixerControl2_Impl::GetMixingPrefs(this) {
                Ok(ok__) => {
                    pdwmixflags.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IMFVideoMixerControl_Vtbl::new::<Identity, OFFSET>(),
            SetMixingPrefs: SetMixingPrefs::<Identity, OFFSET>,
            GetMixingPrefs: GetMixingPrefs::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFVideoMixerControl2 as windows_core::Interface>::IID || iid == &<IMFVideoMixerControl as windows_core::Interface>::IID
    }
}
pub trait IMFVideoPositionMapper_Impl: Sized + windows_core::IUnknownImpl {
    fn MapOutputCoordinateToInputStream(&self, xout: f32, yout: f32, dwoutputstreamindex: u32, dwinputstreamindex: u32, pxin: *mut f32, pyin: *mut f32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFVideoPositionMapper {}
impl IMFVideoPositionMapper_Vtbl {
    pub const fn new<Identity: IMFVideoPositionMapper_Impl, const OFFSET: isize>() -> IMFVideoPositionMapper_Vtbl {
        unsafe extern "system" fn MapOutputCoordinateToInputStream<Identity: IMFVideoPositionMapper_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, xout: f32, yout: f32, dwoutputstreamindex: u32, dwinputstreamindex: u32, pxin: *mut f32, pyin: *mut f32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoPositionMapper_Impl::MapOutputCoordinateToInputStream(this, core::mem::transmute_copy(&xout), core::mem::transmute_copy(&yout), core::mem::transmute_copy(&dwoutputstreamindex), core::mem::transmute_copy(&dwinputstreamindex), core::mem::transmute_copy(&pxin), core::mem::transmute_copy(&pyin)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            MapOutputCoordinateToInputStream: MapOutputCoordinateToInputStream::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFVideoPositionMapper as windows_core::Interface>::IID
    }
}
pub trait IMFVideoPresenter_Impl: Sized + IMFClockStateSink_Impl {
    fn ProcessMessage(&self, emessage: MFVP_MESSAGE_TYPE, ulparam: usize) -> windows_core::Result<()>;
    fn GetCurrentMediaType(&self) -> windows_core::Result<IMFVideoMediaType>;
}
impl windows_core::RuntimeName for IMFVideoPresenter {}
impl IMFVideoPresenter_Vtbl {
    pub const fn new<Identity: IMFVideoPresenter_Impl, const OFFSET: isize>() -> IMFVideoPresenter_Vtbl {
        unsafe extern "system" fn ProcessMessage<Identity: IMFVideoPresenter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, emessage: MFVP_MESSAGE_TYPE, ulparam: usize) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoPresenter_Impl::ProcessMessage(this, core::mem::transmute_copy(&emessage), core::mem::transmute_copy(&ulparam)).into()
        }
        unsafe extern "system" fn GetCurrentMediaType<Identity: IMFVideoPresenter_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppmediatype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFVideoPresenter_Impl::GetCurrentMediaType(this) {
                Ok(ok__) => {
                    ppmediatype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IMFClockStateSink_Vtbl::new::<Identity, OFFSET>(),
            ProcessMessage: ProcessMessage::<Identity, OFFSET>,
            GetCurrentMediaType: GetCurrentMediaType::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFVideoPresenter as windows_core::Interface>::IID || iid == &<IMFClockStateSink as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub trait IMFVideoProcessor_Impl: Sized + windows_core::IUnknownImpl {
    fn GetAvailableVideoProcessorModes(&self, lpdwnumprocessingmodes: *mut u32, ppvideoprocessingmodes: *mut *mut windows_core::GUID) -> windows_core::Result<()>;
    fn GetVideoProcessorCaps(&self, lpvideoprocessormode: *const windows_core::GUID, lpvideoprocessorcaps: *mut DXVA2_VideoProcessorCaps) -> windows_core::Result<()>;
    fn GetVideoProcessorMode(&self) -> windows_core::Result<windows_core::GUID>;
    fn SetVideoProcessorMode(&self, lpmode: *const windows_core::GUID) -> windows_core::Result<()>;
    fn GetProcAmpRange(&self, dwproperty: u32) -> windows_core::Result<DXVA2_ValueRange>;
    fn GetProcAmpValues(&self, dwflags: u32) -> windows_core::Result<DXVA2_ProcAmpValues>;
    fn SetProcAmpValues(&self, dwflags: u32, pvalues: *const DXVA2_ProcAmpValues) -> windows_core::Result<()>;
    fn GetFilteringRange(&self, dwproperty: u32) -> windows_core::Result<DXVA2_ValueRange>;
    fn GetFilteringValue(&self, dwproperty: u32) -> windows_core::Result<DXVA2_Fixed32>;
    fn SetFilteringValue(&self, dwproperty: u32, pvalue: *const DXVA2_Fixed32) -> windows_core::Result<()>;
    fn GetBackgroundColor(&self) -> windows_core::Result<super::super::Foundation::COLORREF>;
    fn SetBackgroundColor(&self, clrbkg: super::super::Foundation::COLORREF) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl windows_core::RuntimeName for IMFVideoProcessor {}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl IMFVideoProcessor_Vtbl {
    pub const fn new<Identity: IMFVideoProcessor_Impl, const OFFSET: isize>() -> IMFVideoProcessor_Vtbl {
        unsafe extern "system" fn GetAvailableVideoProcessorModes<Identity: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpdwnumprocessingmodes: *mut u32, ppvideoprocessingmodes: *mut *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoProcessor_Impl::GetAvailableVideoProcessorModes(this, core::mem::transmute_copy(&lpdwnumprocessingmodes), core::mem::transmute_copy(&ppvideoprocessingmodes)).into()
        }
        unsafe extern "system" fn GetVideoProcessorCaps<Identity: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpvideoprocessormode: *const windows_core::GUID, lpvideoprocessorcaps: *mut DXVA2_VideoProcessorCaps) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoProcessor_Impl::GetVideoProcessorCaps(this, core::mem::transmute_copy(&lpvideoprocessormode), core::mem::transmute_copy(&lpvideoprocessorcaps)).into()
        }
        unsafe extern "system" fn GetVideoProcessorMode<Identity: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpmode: *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFVideoProcessor_Impl::GetVideoProcessorMode(this) {
                Ok(ok__) => {
                    lpmode.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoProcessorMode<Identity: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpmode: *const windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoProcessor_Impl::SetVideoProcessorMode(this, core::mem::transmute_copy(&lpmode)).into()
        }
        unsafe extern "system" fn GetProcAmpRange<Identity: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwproperty: u32, pproprange: *mut DXVA2_ValueRange) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFVideoProcessor_Impl::GetProcAmpRange(this, core::mem::transmute_copy(&dwproperty)) {
                Ok(ok__) => {
                    pproprange.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProcAmpValues<Identity: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32, values: *mut DXVA2_ProcAmpValues) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFVideoProcessor_Impl::GetProcAmpValues(this, core::mem::transmute_copy(&dwflags)) {
                Ok(ok__) => {
                    values.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProcAmpValues<Identity: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32, pvalues: *const DXVA2_ProcAmpValues) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoProcessor_Impl::SetProcAmpValues(this, core::mem::transmute_copy(&dwflags), core::mem::transmute_copy(&pvalues)).into()
        }
        unsafe extern "system" fn GetFilteringRange<Identity: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwproperty: u32, pproprange: *mut DXVA2_ValueRange) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFVideoProcessor_Impl::GetFilteringRange(this, core::mem::transmute_copy(&dwproperty)) {
                Ok(ok__) => {
                    pproprange.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFilteringValue<Identity: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwproperty: u32, pvalue: *mut DXVA2_Fixed32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFVideoProcessor_Impl::GetFilteringValue(this, core::mem::transmute_copy(&dwproperty)) {
                Ok(ok__) => {
                    pvalue.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFilteringValue<Identity: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwproperty: u32, pvalue: *const DXVA2_Fixed32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoProcessor_Impl::SetFilteringValue(this, core::mem::transmute_copy(&dwproperty), core::mem::transmute_copy(&pvalue)).into()
        }
        unsafe extern "system" fn GetBackgroundColor<Identity: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lpclrbkg: *mut super::super::Foundation::COLORREF) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFVideoProcessor_Impl::GetBackgroundColor(this) {
                Ok(ok__) => {
                    lpclrbkg.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundColor<Identity: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, clrbkg: super::super::Foundation::COLORREF) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoProcessor_Impl::SetBackgroundColor(this, core::mem::transmute_copy(&clrbkg)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetAvailableVideoProcessorModes: GetAvailableVideoProcessorModes::<Identity, OFFSET>,
            GetVideoProcessorCaps: GetVideoProcessorCaps::<Identity, OFFSET>,
            GetVideoProcessorMode: GetVideoProcessorMode::<Identity, OFFSET>,
            SetVideoProcessorMode: SetVideoProcessorMode::<Identity, OFFSET>,
            GetProcAmpRange: GetProcAmpRange::<Identity, OFFSET>,
            GetProcAmpValues: GetProcAmpValues::<Identity, OFFSET>,
            SetProcAmpValues: SetProcAmpValues::<Identity, OFFSET>,
            GetFilteringRange: GetFilteringRange::<Identity, OFFSET>,
            GetFilteringValue: GetFilteringValue::<Identity, OFFSET>,
            SetFilteringValue: SetFilteringValue::<Identity, OFFSET>,
            GetBackgroundColor: GetBackgroundColor::<Identity, OFFSET>,
            SetBackgroundColor: SetBackgroundColor::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFVideoProcessor as windows_core::Interface>::IID
    }
}
pub trait IMFVideoProcessorControl_Impl: Sized + windows_core::IUnknownImpl {
    fn SetBorderColor(&self, pbordercolor: *const MFARGB) -> windows_core::Result<()>;
    fn SetSourceRectangle(&self, psrcrect: *const super::super::Foundation::RECT) -> windows_core::Result<()>;
    fn SetDestinationRectangle(&self, pdstrect: *const super::super::Foundation::RECT) -> windows_core::Result<()>;
    fn SetMirror(&self, emirror: MF_VIDEO_PROCESSOR_MIRROR) -> windows_core::Result<()>;
    fn SetRotation(&self, erotation: MF_VIDEO_PROCESSOR_ROTATION) -> windows_core::Result<()>;
    fn SetConstrictionSize(&self, pconstrictionsize: *const super::super::Foundation::SIZE) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFVideoProcessorControl {}
impl IMFVideoProcessorControl_Vtbl {
    pub const fn new<Identity: IMFVideoProcessorControl_Impl, const OFFSET: isize>() -> IMFVideoProcessorControl_Vtbl {
        unsafe extern "system" fn SetBorderColor<Identity: IMFVideoProcessorControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbordercolor: *const MFARGB) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoProcessorControl_Impl::SetBorderColor(this, core::mem::transmute_copy(&pbordercolor)).into()
        }
        unsafe extern "system" fn SetSourceRectangle<Identity: IMFVideoProcessorControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, psrcrect: *const super::super::Foundation::RECT) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoProcessorControl_Impl::SetSourceRectangle(this, core::mem::transmute_copy(&psrcrect)).into()
        }
        unsafe extern "system" fn SetDestinationRectangle<Identity: IMFVideoProcessorControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdstrect: *const super::super::Foundation::RECT) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoProcessorControl_Impl::SetDestinationRectangle(this, core::mem::transmute_copy(&pdstrect)).into()
        }
        unsafe extern "system" fn SetMirror<Identity: IMFVideoProcessorControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, emirror: MF_VIDEO_PROCESSOR_MIRROR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoProcessorControl_Impl::SetMirror(this, core::mem::transmute_copy(&emirror)).into()
        }
        unsafe extern "system" fn SetRotation<Identity: IMFVideoProcessorControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, erotation: MF_VIDEO_PROCESSOR_ROTATION) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoProcessorControl_Impl::SetRotation(this, core::mem::transmute_copy(&erotation)).into()
        }
        unsafe extern "system" fn SetConstrictionSize<Identity: IMFVideoProcessorControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pconstrictionsize: *const super::super::Foundation::SIZE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoProcessorControl_Impl::SetConstrictionSize(this, core::mem::transmute_copy(&pconstrictionsize)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetBorderColor: SetBorderColor::<Identity, OFFSET>,
            SetSourceRectangle: SetSourceRectangle::<Identity, OFFSET>,
            SetDestinationRectangle: SetDestinationRectangle::<Identity, OFFSET>,
            SetMirror: SetMirror::<Identity, OFFSET>,
            SetRotation: SetRotation::<Identity, OFFSET>,
            SetConstrictionSize: SetConstrictionSize::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFVideoProcessorControl as windows_core::Interface>::IID
    }
}
pub trait IMFVideoProcessorControl2_Impl: Sized + IMFVideoProcessorControl_Impl {
    fn SetRotationOverride(&self, uirotation: u32) -> windows_core::Result<()>;
    fn EnableHardwareEffects(&self, fenabled: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn GetSupportedHardwareEffects(&self) -> windows_core::Result<u32>;
}
impl windows_core::RuntimeName for IMFVideoProcessorControl2 {}
impl IMFVideoProcessorControl2_Vtbl {
    pub const fn new<Identity: IMFVideoProcessorControl2_Impl, const OFFSET: isize>() -> IMFVideoProcessorControl2_Vtbl {
        unsafe extern "system" fn SetRotationOverride<Identity: IMFVideoProcessorControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, uirotation: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoProcessorControl2_Impl::SetRotationOverride(this, core::mem::transmute_copy(&uirotation)).into()
        }
        unsafe extern "system" fn EnableHardwareEffects<Identity: IMFVideoProcessorControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fenabled: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoProcessorControl2_Impl::EnableHardwareEffects(this, core::mem::transmute_copy(&fenabled)).into()
        }
        unsafe extern "system" fn GetSupportedHardwareEffects<Identity: IMFVideoProcessorControl2_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, puisupport: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFVideoProcessorControl2_Impl::GetSupportedHardwareEffects(this) {
                Ok(ok__) => {
                    puisupport.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IMFVideoProcessorControl_Vtbl::new::<Identity, OFFSET>(),
            SetRotationOverride: SetRotationOverride::<Identity, OFFSET>,
            EnableHardwareEffects: EnableHardwareEffects::<Identity, OFFSET>,
            GetSupportedHardwareEffects: GetSupportedHardwareEffects::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFVideoProcessorControl2 as windows_core::Interface>::IID || iid == &<IMFVideoProcessorControl as windows_core::Interface>::IID
    }
}
pub trait IMFVideoProcessorControl3_Impl: Sized + IMFVideoProcessorControl2_Impl {
    fn GetNaturalOutputType(&self) -> windows_core::Result<IMFMediaType>;
    fn EnableSphericalVideoProcessing(&self, fenable: super::super::Foundation::BOOL, eformat: MFVideoSphericalFormat, eprojectionmode: MFVideoSphericalProjectionMode) -> windows_core::Result<()>;
    fn SetSphericalVideoProperties(&self, x: f32, y: f32, z: f32, w: f32, fieldofview: f32) -> windows_core::Result<()>;
    fn SetOutputDevice(&self, poutputdevice: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFVideoProcessorControl3 {}
impl IMFVideoProcessorControl3_Vtbl {
    pub const fn new<Identity: IMFVideoProcessorControl3_Impl, const OFFSET: isize>() -> IMFVideoProcessorControl3_Vtbl {
        unsafe extern "system" fn GetNaturalOutputType<Identity: IMFVideoProcessorControl3_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pptype: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFVideoProcessorControl3_Impl::GetNaturalOutputType(this) {
                Ok(ok__) => {
                    pptype.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnableSphericalVideoProcessing<Identity: IMFVideoProcessorControl3_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fenable: super::super::Foundation::BOOL, eformat: MFVideoSphericalFormat, eprojectionmode: MFVideoSphericalProjectionMode) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoProcessorControl3_Impl::EnableSphericalVideoProcessing(this, core::mem::transmute_copy(&fenable), core::mem::transmute_copy(&eformat), core::mem::transmute_copy(&eprojectionmode)).into()
        }
        unsafe extern "system" fn SetSphericalVideoProperties<Identity: IMFVideoProcessorControl3_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, x: f32, y: f32, z: f32, w: f32, fieldofview: f32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoProcessorControl3_Impl::SetSphericalVideoProperties(this, core::mem::transmute_copy(&x), core::mem::transmute_copy(&y), core::mem::transmute_copy(&z), core::mem::transmute_copy(&w), core::mem::transmute_copy(&fieldofview)).into()
        }
        unsafe extern "system" fn SetOutputDevice<Identity: IMFVideoProcessorControl3_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, poutputdevice: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoProcessorControl3_Impl::SetOutputDevice(this, windows_core::from_raw_borrowed(&poutputdevice)).into()
        }
        Self {
            base__: IMFVideoProcessorControl2_Vtbl::new::<Identity, OFFSET>(),
            GetNaturalOutputType: GetNaturalOutputType::<Identity, OFFSET>,
            EnableSphericalVideoProcessing: EnableSphericalVideoProcessing::<Identity, OFFSET>,
            SetSphericalVideoProperties: SetSphericalVideoProperties::<Identity, OFFSET>,
            SetOutputDevice: SetOutputDevice::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFVideoProcessorControl3 as windows_core::Interface>::IID || iid == &<IMFVideoProcessorControl as windows_core::Interface>::IID || iid == &<IMFVideoProcessorControl2 as windows_core::Interface>::IID
    }
}
pub trait IMFVideoRenderer_Impl: Sized + windows_core::IUnknownImpl {
    fn InitializeRenderer(&self, pvideomixer: Option<&IMFTransform>, pvideopresenter: Option<&IMFVideoPresenter>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFVideoRenderer {}
impl IMFVideoRenderer_Vtbl {
    pub const fn new<Identity: IMFVideoRenderer_Impl, const OFFSET: isize>() -> IMFVideoRenderer_Vtbl {
        unsafe extern "system" fn InitializeRenderer<Identity: IMFVideoRenderer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pvideomixer: *mut core::ffi::c_void, pvideopresenter: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoRenderer_Impl::InitializeRenderer(this, windows_core::from_raw_borrowed(&pvideomixer), windows_core::from_raw_borrowed(&pvideopresenter)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), InitializeRenderer: InitializeRenderer::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFVideoRenderer as windows_core::Interface>::IID
    }
}
pub trait IMFVideoRendererEffectControl_Impl: Sized + windows_core::IUnknownImpl {
    fn OnAppServiceConnectionEstablished(&self, pappserviceconnection: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFVideoRendererEffectControl {}
impl IMFVideoRendererEffectControl_Vtbl {
    pub const fn new<Identity: IMFVideoRendererEffectControl_Impl, const OFFSET: isize>() -> IMFVideoRendererEffectControl_Vtbl {
        unsafe extern "system" fn OnAppServiceConnectionEstablished<Identity: IMFVideoRendererEffectControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pappserviceconnection: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoRendererEffectControl_Impl::OnAppServiceConnectionEstablished(this, windows_core::from_raw_borrowed(&pappserviceconnection)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            OnAppServiceConnectionEstablished: OnAppServiceConnectionEstablished::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFVideoRendererEffectControl as windows_core::Interface>::IID
    }
}
pub trait IMFVideoSampleAllocator_Impl: Sized + windows_core::IUnknownImpl {
    fn SetDirectXManager(&self, pmanager: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn UninitializeSampleAllocator(&self) -> windows_core::Result<()>;
    fn InitializeSampleAllocator(&self, crequestedframes: u32, pmediatype: Option<&IMFMediaType>) -> windows_core::Result<()>;
    fn AllocateSample(&self) -> windows_core::Result<IMFSample>;
}
impl windows_core::RuntimeName for IMFVideoSampleAllocator {}
impl IMFVideoSampleAllocator_Vtbl {
    pub const fn new<Identity: IMFVideoSampleAllocator_Impl, const OFFSET: isize>() -> IMFVideoSampleAllocator_Vtbl {
        unsafe extern "system" fn SetDirectXManager<Identity: IMFVideoSampleAllocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmanager: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoSampleAllocator_Impl::SetDirectXManager(this, windows_core::from_raw_borrowed(&pmanager)).into()
        }
        unsafe extern "system" fn UninitializeSampleAllocator<Identity: IMFVideoSampleAllocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoSampleAllocator_Impl::UninitializeSampleAllocator(this).into()
        }
        unsafe extern "system" fn InitializeSampleAllocator<Identity: IMFVideoSampleAllocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, crequestedframes: u32, pmediatype: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoSampleAllocator_Impl::InitializeSampleAllocator(this, core::mem::transmute_copy(&crequestedframes), windows_core::from_raw_borrowed(&pmediatype)).into()
        }
        unsafe extern "system" fn AllocateSample<Identity: IMFVideoSampleAllocator_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppsample: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFVideoSampleAllocator_Impl::AllocateSample(this) {
                Ok(ok__) => {
                    ppsample.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetDirectXManager: SetDirectXManager::<Identity, OFFSET>,
            UninitializeSampleAllocator: UninitializeSampleAllocator::<Identity, OFFSET>,
            InitializeSampleAllocator: InitializeSampleAllocator::<Identity, OFFSET>,
            AllocateSample: AllocateSample::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFVideoSampleAllocator as windows_core::Interface>::IID
    }
}
pub trait IMFVideoSampleAllocatorCallback_Impl: Sized + windows_core::IUnknownImpl {
    fn SetCallback(&self, pnotify: Option<&IMFVideoSampleAllocatorNotify>) -> windows_core::Result<()>;
    fn GetFreeSampleCount(&self) -> windows_core::Result<i32>;
}
impl windows_core::RuntimeName for IMFVideoSampleAllocatorCallback {}
impl IMFVideoSampleAllocatorCallback_Vtbl {
    pub const fn new<Identity: IMFVideoSampleAllocatorCallback_Impl, const OFFSET: isize>() -> IMFVideoSampleAllocatorCallback_Vtbl {
        unsafe extern "system" fn SetCallback<Identity: IMFVideoSampleAllocatorCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pnotify: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoSampleAllocatorCallback_Impl::SetCallback(this, windows_core::from_raw_borrowed(&pnotify)).into()
        }
        unsafe extern "system" fn GetFreeSampleCount<Identity: IMFVideoSampleAllocatorCallback_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plsamples: *mut i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFVideoSampleAllocatorCallback_Impl::GetFreeSampleCount(this) {
                Ok(ok__) => {
                    plsamples.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetCallback: SetCallback::<Identity, OFFSET>,
            GetFreeSampleCount: GetFreeSampleCount::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFVideoSampleAllocatorCallback as windows_core::Interface>::IID
    }
}
pub trait IMFVideoSampleAllocatorEx_Impl: Sized + IMFVideoSampleAllocator_Impl {
    fn InitializeSampleAllocatorEx(&self, cinitialsamples: u32, cmaximumsamples: u32, pattributes: Option<&IMFAttributes>, pmediatype: Option<&IMFMediaType>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFVideoSampleAllocatorEx {}
impl IMFVideoSampleAllocatorEx_Vtbl {
    pub const fn new<Identity: IMFVideoSampleAllocatorEx_Impl, const OFFSET: isize>() -> IMFVideoSampleAllocatorEx_Vtbl {
        unsafe extern "system" fn InitializeSampleAllocatorEx<Identity: IMFVideoSampleAllocatorEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, cinitialsamples: u32, cmaximumsamples: u32, pattributes: *mut core::ffi::c_void, pmediatype: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoSampleAllocatorEx_Impl::InitializeSampleAllocatorEx(this, core::mem::transmute_copy(&cinitialsamples), core::mem::transmute_copy(&cmaximumsamples), windows_core::from_raw_borrowed(&pattributes), windows_core::from_raw_borrowed(&pmediatype)).into()
        }
        Self { base__: IMFVideoSampleAllocator_Vtbl::new::<Identity, OFFSET>(), InitializeSampleAllocatorEx: InitializeSampleAllocatorEx::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFVideoSampleAllocatorEx as windows_core::Interface>::IID || iid == &<IMFVideoSampleAllocator as windows_core::Interface>::IID
    }
}
pub trait IMFVideoSampleAllocatorNotify_Impl: Sized + windows_core::IUnknownImpl {
    fn NotifyRelease(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFVideoSampleAllocatorNotify {}
impl IMFVideoSampleAllocatorNotify_Vtbl {
    pub const fn new<Identity: IMFVideoSampleAllocatorNotify_Impl, const OFFSET: isize>() -> IMFVideoSampleAllocatorNotify_Vtbl {
        unsafe extern "system" fn NotifyRelease<Identity: IMFVideoSampleAllocatorNotify_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoSampleAllocatorNotify_Impl::NotifyRelease(this).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), NotifyRelease: NotifyRelease::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFVideoSampleAllocatorNotify as windows_core::Interface>::IID
    }
}
pub trait IMFVideoSampleAllocatorNotifyEx_Impl: Sized + IMFVideoSampleAllocatorNotify_Impl {
    fn NotifyPrune(&self, __midl__imfvideosampleallocatornotifyex0000: Option<&IMFSample>) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IMFVideoSampleAllocatorNotifyEx {}
impl IMFVideoSampleAllocatorNotifyEx_Vtbl {
    pub const fn new<Identity: IMFVideoSampleAllocatorNotifyEx_Impl, const OFFSET: isize>() -> IMFVideoSampleAllocatorNotifyEx_Vtbl {
        unsafe extern "system" fn NotifyPrune<Identity: IMFVideoSampleAllocatorNotifyEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, __midl__imfvideosampleallocatornotifyex0000: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVideoSampleAllocatorNotifyEx_Impl::NotifyPrune(this, windows_core::from_raw_borrowed(&__midl__imfvideosampleallocatornotifyex0000)).into()
        }
        Self { base__: IMFVideoSampleAllocatorNotify_Vtbl::new::<Identity, OFFSET>(), NotifyPrune: NotifyPrune::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFVideoSampleAllocatorNotifyEx as windows_core::Interface>::IID || iid == &<IMFVideoSampleAllocatorNotify as windows_core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Devices_Properties", feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
pub trait IMFVirtualCamera_Impl: Sized + IMFAttributes_Impl {
    fn AddDeviceSourceInfo(&self, devicesourceinfo: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn AddProperty(&self, pkey: *const super::super::Devices::Properties::DEVPROPKEY, r#type: super::super::Devices::Properties::DEVPROPTYPE, pbdata: *const u8, cbdata: u32) -> windows_core::Result<()>;
    fn AddRegistryEntry(&self, entryname: &windows_core::PCWSTR, subkeypath: &windows_core::PCWSTR, dwregtype: u32, pbdata: *const u8, cbdata: u32) -> windows_core::Result<()>;
    fn Start(&self, pcallback: Option<&IMFAsyncCallback>) -> windows_core::Result<()>;
    fn Stop(&self) -> windows_core::Result<()>;
    fn Remove(&self) -> windows_core::Result<()>;
    fn GetMediaSource(&self) -> windows_core::Result<IMFMediaSource>;
    fn SendCameraProperty(&self, propertyset: *const windows_core::GUID, propertyid: u32, propertyflags: u32, propertypayload: *mut core::ffi::c_void, propertypayloadlength: u32, data: *mut core::ffi::c_void, datalength: u32, datawritten: *mut u32) -> windows_core::Result<()>;
    fn CreateSyncEvent(&self, kseventset: *const windows_core::GUID, kseventid: u32, kseventflags: u32, eventhandle: super::super::Foundation::HANDLE) -> windows_core::Result<IMFCameraSyncObject>;
    fn CreateSyncSemaphore(&self, kseventset: *const windows_core::GUID, kseventid: u32, kseventflags: u32, semaphorehandle: super::super::Foundation::HANDLE, semaphoreadjustment: i32) -> windows_core::Result<IMFCameraSyncObject>;
    fn Shutdown(&self) -> windows_core::Result<()>;
}
#[cfg(all(feature = "Win32_Devices_Properties", feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl windows_core::RuntimeName for IMFVirtualCamera {}
#[cfg(all(feature = "Win32_Devices_Properties", feature = "Win32_System_Com_StructuredStorage", feature = "Win32_System_Variant"))]
impl IMFVirtualCamera_Vtbl {
    pub const fn new<Identity: IMFVirtualCamera_Impl, const OFFSET: isize>() -> IMFVirtualCamera_Vtbl {
        unsafe extern "system" fn AddDeviceSourceInfo<Identity: IMFVirtualCamera_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, devicesourceinfo: windows_core::PCWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVirtualCamera_Impl::AddDeviceSourceInfo(this, core::mem::transmute(&devicesourceinfo)).into()
        }
        unsafe extern "system" fn AddProperty<Identity: IMFVirtualCamera_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pkey: *const super::super::Devices::Properties::DEVPROPKEY, r#type: super::super::Devices::Properties::DEVPROPTYPE, pbdata: *const u8, cbdata: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVirtualCamera_Impl::AddProperty(this, core::mem::transmute_copy(&pkey), core::mem::transmute_copy(&r#type), core::mem::transmute_copy(&pbdata), core::mem::transmute_copy(&cbdata)).into()
        }
        unsafe extern "system" fn AddRegistryEntry<Identity: IMFVirtualCamera_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, entryname: windows_core::PCWSTR, subkeypath: windows_core::PCWSTR, dwregtype: u32, pbdata: *const u8, cbdata: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVirtualCamera_Impl::AddRegistryEntry(this, core::mem::transmute(&entryname), core::mem::transmute(&subkeypath), core::mem::transmute_copy(&dwregtype), core::mem::transmute_copy(&pbdata), core::mem::transmute_copy(&cbdata)).into()
        }
        unsafe extern "system" fn Start<Identity: IMFVirtualCamera_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcallback: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVirtualCamera_Impl::Start(this, windows_core::from_raw_borrowed(&pcallback)).into()
        }
        unsafe extern "system" fn Stop<Identity: IMFVirtualCamera_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVirtualCamera_Impl::Stop(this).into()
        }
        unsafe extern "system" fn Remove<Identity: IMFVirtualCamera_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVirtualCamera_Impl::Remove(this).into()
        }
        unsafe extern "system" fn GetMediaSource<Identity: IMFVirtualCamera_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ppmediasource: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFVirtualCamera_Impl::GetMediaSource(this) {
                Ok(ok__) => {
                    ppmediasource.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SendCameraProperty<Identity: IMFVirtualCamera_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, propertyset: *const windows_core::GUID, propertyid: u32, propertyflags: u32, propertypayload: *mut core::ffi::c_void, propertypayloadlength: u32, data: *mut core::ffi::c_void, datalength: u32, datawritten: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVirtualCamera_Impl::SendCameraProperty(this, core::mem::transmute_copy(&propertyset), core::mem::transmute_copy(&propertyid), core::mem::transmute_copy(&propertyflags), core::mem::transmute_copy(&propertypayload), core::mem::transmute_copy(&propertypayloadlength), core::mem::transmute_copy(&data), core::mem::transmute_copy(&datalength), core::mem::transmute_copy(&datawritten)).into()
        }
        unsafe extern "system" fn CreateSyncEvent<Identity: IMFVirtualCamera_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, kseventset: *const windows_core::GUID, kseventid: u32, kseventflags: u32, eventhandle: super::super::Foundation::HANDLE, camerasyncobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFVirtualCamera_Impl::CreateSyncEvent(this, core::mem::transmute_copy(&kseventset), core::mem::transmute_copy(&kseventid), core::mem::transmute_copy(&kseventflags), core::mem::transmute_copy(&eventhandle)) {
                Ok(ok__) => {
                    camerasyncobject.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateSyncSemaphore<Identity: IMFVirtualCamera_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, kseventset: *const windows_core::GUID, kseventid: u32, kseventflags: u32, semaphorehandle: super::super::Foundation::HANDLE, semaphoreadjustment: i32, camerasyncobject: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFVirtualCamera_Impl::CreateSyncSemaphore(this, core::mem::transmute_copy(&kseventset), core::mem::transmute_copy(&kseventid), core::mem::transmute_copy(&kseventflags), core::mem::transmute_copy(&semaphorehandle), core::mem::transmute_copy(&semaphoreadjustment)) {
                Ok(ok__) => {
                    camerasyncobject.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Shutdown<Identity: IMFVirtualCamera_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFVirtualCamera_Impl::Shutdown(this).into()
        }
        Self {
            base__: IMFAttributes_Vtbl::new::<Identity, OFFSET>(),
            AddDeviceSourceInfo: AddDeviceSourceInfo::<Identity, OFFSET>,
            AddProperty: AddProperty::<Identity, OFFSET>,
            AddRegistryEntry: AddRegistryEntry::<Identity, OFFSET>,
            Start: Start::<Identity, OFFSET>,
            Stop: Stop::<Identity, OFFSET>,
            Remove: Remove::<Identity, OFFSET>,
            GetMediaSource: GetMediaSource::<Identity, OFFSET>,
            SendCameraProperty: SendCameraProperty::<Identity, OFFSET>,
            CreateSyncEvent: CreateSyncEvent::<Identity, OFFSET>,
            CreateSyncSemaphore: CreateSyncSemaphore::<Identity, OFFSET>,
            Shutdown: Shutdown::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFVirtualCamera as windows_core::Interface>::IID || iid == &<IMFAttributes as windows_core::Interface>::IID
    }
}
pub trait IMFWorkQueueServices_Impl: Sized + windows_core::IUnknownImpl {
    fn BeginRegisterTopologyWorkQueuesWithMMCSS(&self, pcallback: Option<&IMFAsyncCallback>, pstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndRegisterTopologyWorkQueuesWithMMCSS(&self, presult: Option<&IMFAsyncResult>) -> windows_core::Result<()>;
    fn BeginUnregisterTopologyWorkQueuesWithMMCSS(&self, pcallback: Option<&IMFAsyncCallback>, pstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndUnregisterTopologyWorkQueuesWithMMCSS(&self, presult: Option<&IMFAsyncResult>) -> windows_core::Result<()>;
    fn GetTopologyWorkQueueMMCSSClass(&self, dwtopologyworkqueueid: u32, pwszclass: windows_core::PWSTR, pcchclass: *mut u32) -> windows_core::Result<()>;
    fn GetTopologyWorkQueueMMCSSTaskId(&self, dwtopologyworkqueueid: u32) -> windows_core::Result<u32>;
    fn BeginRegisterPlatformWorkQueueWithMMCSS(&self, dwplatformworkqueue: u32, wszclass: &windows_core::PCWSTR, dwtaskid: u32, pcallback: Option<&IMFAsyncCallback>, pstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndRegisterPlatformWorkQueueWithMMCSS(&self, presult: Option<&IMFAsyncResult>) -> windows_core::Result<u32>;
    fn BeginUnregisterPlatformWorkQueueWithMMCSS(&self, dwplatformworkqueue: u32, pcallback: Option<&IMFAsyncCallback>, pstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn EndUnregisterPlatformWorkQueueWithMMCSS(&self, presult: Option<&IMFAsyncResult>) -> windows_core::Result<()>;
    fn GetPlaftormWorkQueueMMCSSClass(&self, dwplatformworkqueueid: u32, pwszclass: windows_core::PWSTR, pcchclass: *mut u32) -> windows_core::Result<()>;
    fn GetPlatformWorkQueueMMCSSTaskId(&self, dwplatformworkqueueid: u32) -> windows_core::Result<u32>;
}
impl windows_core::RuntimeName for IMFWorkQueueServices {}
impl IMFWorkQueueServices_Vtbl {
    pub const fn new<Identity: IMFWorkQueueServices_Impl, const OFFSET: isize>() -> IMFWorkQueueServices_Vtbl {
        unsafe extern "system" fn BeginRegisterTopologyWorkQueuesWithMMCSS<Identity: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcallback: *mut core::ffi::c_void, pstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFWorkQueueServices_Impl::BeginRegisterTopologyWorkQueuesWithMMCSS(this, windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&pstate)).into()
        }
        unsafe extern "system" fn EndRegisterTopologyWorkQueuesWithMMCSS<Identity: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFWorkQueueServices_Impl::EndRegisterTopologyWorkQueuesWithMMCSS(this, windows_core::from_raw_borrowed(&presult)).into()
        }
        unsafe extern "system" fn BeginUnregisterTopologyWorkQueuesWithMMCSS<Identity: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcallback: *mut core::ffi::c_void, pstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFWorkQueueServices_Impl::BeginUnregisterTopologyWorkQueuesWithMMCSS(this, windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&pstate)).into()
        }
        unsafe extern "system" fn EndUnregisterTopologyWorkQueuesWithMMCSS<Identity: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFWorkQueueServices_Impl::EndUnregisterTopologyWorkQueuesWithMMCSS(this, windows_core::from_raw_borrowed(&presult)).into()
        }
        unsafe extern "system" fn GetTopologyWorkQueueMMCSSClass<Identity: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwtopologyworkqueueid: u32, pwszclass: windows_core::PWSTR, pcchclass: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFWorkQueueServices_Impl::GetTopologyWorkQueueMMCSSClass(this, core::mem::transmute_copy(&dwtopologyworkqueueid), core::mem::transmute_copy(&pwszclass), core::mem::transmute_copy(&pcchclass)).into()
        }
        unsafe extern "system" fn GetTopologyWorkQueueMMCSSTaskId<Identity: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwtopologyworkqueueid: u32, pdwtaskid: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFWorkQueueServices_Impl::GetTopologyWorkQueueMMCSSTaskId(this, core::mem::transmute_copy(&dwtopologyworkqueueid)) {
                Ok(ok__) => {
                    pdwtaskid.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginRegisterPlatformWorkQueueWithMMCSS<Identity: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwplatformworkqueue: u32, wszclass: windows_core::PCWSTR, dwtaskid: u32, pcallback: *mut core::ffi::c_void, pstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFWorkQueueServices_Impl::BeginRegisterPlatformWorkQueueWithMMCSS(this, core::mem::transmute_copy(&dwplatformworkqueue), core::mem::transmute(&wszclass), core::mem::transmute_copy(&dwtaskid), windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&pstate)).into()
        }
        unsafe extern "system" fn EndRegisterPlatformWorkQueueWithMMCSS<Identity: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void, pdwtaskid: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFWorkQueueServices_Impl::EndRegisterPlatformWorkQueueWithMMCSS(this, windows_core::from_raw_borrowed(&presult)) {
                Ok(ok__) => {
                    pdwtaskid.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginUnregisterPlatformWorkQueueWithMMCSS<Identity: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwplatformworkqueue: u32, pcallback: *mut core::ffi::c_void, pstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFWorkQueueServices_Impl::BeginUnregisterPlatformWorkQueueWithMMCSS(this, core::mem::transmute_copy(&dwplatformworkqueue), windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&pstate)).into()
        }
        unsafe extern "system" fn EndUnregisterPlatformWorkQueueWithMMCSS<Identity: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, presult: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFWorkQueueServices_Impl::EndUnregisterPlatformWorkQueueWithMMCSS(this, windows_core::from_raw_borrowed(&presult)).into()
        }
        unsafe extern "system" fn GetPlaftormWorkQueueMMCSSClass<Identity: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwplatformworkqueueid: u32, pwszclass: windows_core::PWSTR, pcchclass: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFWorkQueueServices_Impl::GetPlaftormWorkQueueMMCSSClass(this, core::mem::transmute_copy(&dwplatformworkqueueid), core::mem::transmute_copy(&pwszclass), core::mem::transmute_copy(&pcchclass)).into()
        }
        unsafe extern "system" fn GetPlatformWorkQueueMMCSSTaskId<Identity: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwplatformworkqueueid: u32, pdwtaskid: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFWorkQueueServices_Impl::GetPlatformWorkQueueMMCSSTaskId(this, core::mem::transmute_copy(&dwplatformworkqueueid)) {
                Ok(ok__) => {
                    pdwtaskid.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            BeginRegisterTopologyWorkQueuesWithMMCSS: BeginRegisterTopologyWorkQueuesWithMMCSS::<Identity, OFFSET>,
            EndRegisterTopologyWorkQueuesWithMMCSS: EndRegisterTopologyWorkQueuesWithMMCSS::<Identity, OFFSET>,
            BeginUnregisterTopologyWorkQueuesWithMMCSS: BeginUnregisterTopologyWorkQueuesWithMMCSS::<Identity, OFFSET>,
            EndUnregisterTopologyWorkQueuesWithMMCSS: EndUnregisterTopologyWorkQueuesWithMMCSS::<Identity, OFFSET>,
            GetTopologyWorkQueueMMCSSClass: GetTopologyWorkQueueMMCSSClass::<Identity, OFFSET>,
            GetTopologyWorkQueueMMCSSTaskId: GetTopologyWorkQueueMMCSSTaskId::<Identity, OFFSET>,
            BeginRegisterPlatformWorkQueueWithMMCSS: BeginRegisterPlatformWorkQueueWithMMCSS::<Identity, OFFSET>,
            EndRegisterPlatformWorkQueueWithMMCSS: EndRegisterPlatformWorkQueueWithMMCSS::<Identity, OFFSET>,
            BeginUnregisterPlatformWorkQueueWithMMCSS: BeginUnregisterPlatformWorkQueueWithMMCSS::<Identity, OFFSET>,
            EndUnregisterPlatformWorkQueueWithMMCSS: EndUnregisterPlatformWorkQueueWithMMCSS::<Identity, OFFSET>,
            GetPlaftormWorkQueueMMCSSClass: GetPlaftormWorkQueueMMCSSClass::<Identity, OFFSET>,
            GetPlatformWorkQueueMMCSSTaskId: GetPlatformWorkQueueMMCSSTaskId::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFWorkQueueServices as windows_core::Interface>::IID
    }
}
pub trait IMFWorkQueueServicesEx_Impl: Sized + IMFWorkQueueServices_Impl {
    fn GetTopologyWorkQueueMMCSSPriority(&self, dwtopologyworkqueueid: u32) -> windows_core::Result<i32>;
    fn BeginRegisterPlatformWorkQueueWithMMCSSEx(&self, dwplatformworkqueue: u32, wszclass: &windows_core::PCWSTR, dwtaskid: u32, lpriority: i32, pcallback: Option<&IMFAsyncCallback>, pstate: Option<&windows_core::IUnknown>) -> windows_core::Result<()>;
    fn GetPlatformWorkQueueMMCSSPriority(&self, dwplatformworkqueueid: u32) -> windows_core::Result<i32>;
}
impl windows_core::RuntimeName for IMFWorkQueueServicesEx {}
impl IMFWorkQueueServicesEx_Vtbl {
    pub const fn new<Identity: IMFWorkQueueServicesEx_Impl, const OFFSET: isize>() -> IMFWorkQueueServicesEx_Vtbl {
        unsafe extern "system" fn GetTopologyWorkQueueMMCSSPriority<Identity: IMFWorkQueueServicesEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwtopologyworkqueueid: u32, plpriority: *mut i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFWorkQueueServicesEx_Impl::GetTopologyWorkQueueMMCSSPriority(this, core::mem::transmute_copy(&dwtopologyworkqueueid)) {
                Ok(ok__) => {
                    plpriority.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginRegisterPlatformWorkQueueWithMMCSSEx<Identity: IMFWorkQueueServicesEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwplatformworkqueue: u32, wszclass: windows_core::PCWSTR, dwtaskid: u32, lpriority: i32, pcallback: *mut core::ffi::c_void, pstate: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IMFWorkQueueServicesEx_Impl::BeginRegisterPlatformWorkQueueWithMMCSSEx(this, core::mem::transmute_copy(&dwplatformworkqueue), core::mem::transmute(&wszclass), core::mem::transmute_copy(&dwtaskid), core::mem::transmute_copy(&lpriority), windows_core::from_raw_borrowed(&pcallback), windows_core::from_raw_borrowed(&pstate)).into()
        }
        unsafe extern "system" fn GetPlatformWorkQueueMMCSSPriority<Identity: IMFWorkQueueServicesEx_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwplatformworkqueueid: u32, plpriority: *mut i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IMFWorkQueueServicesEx_Impl::GetPlatformWorkQueueMMCSSPriority(this, core::mem::transmute_copy(&dwplatformworkqueueid)) {
                Ok(ok__) => {
                    plpriority.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self {
            base__: IMFWorkQueueServices_Vtbl::new::<Identity, OFFSET>(),
            GetTopologyWorkQueueMMCSSPriority: GetTopologyWorkQueueMMCSSPriority::<Identity, OFFSET>,
            BeginRegisterPlatformWorkQueueWithMMCSSEx: BeginRegisterPlatformWorkQueueWithMMCSSEx::<Identity, OFFSET>,
            GetPlatformWorkQueueMMCSSPriority: GetPlatformWorkQueueMMCSSPriority::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IMFWorkQueueServicesEx as windows_core::Interface>::IID || iid == &<IMFWorkQueueServices as windows_core::Interface>::IID
    }
}
pub trait IOPMVideoOutput_Impl: Sized + windows_core::IUnknownImpl {
    fn StartInitialization(&self, prnrandomnumber: *mut OPM_RANDOM_NUMBER, ppbcertificate: *mut *mut u8, pulcertificatelength: *mut u32) -> windows_core::Result<()>;
    fn FinishInitialization(&self, pparameters: *const OPM_ENCRYPTED_INITIALIZATION_PARAMETERS) -> windows_core::Result<()>;
    fn GetInformation(&self, pparameters: *const OPM_GET_INFO_PARAMETERS, prequestedinformation: *mut OPM_REQUESTED_INFORMATION) -> windows_core::Result<()>;
    fn COPPCompatibleGetInformation(&self, pparameters: *const OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS, prequestedinformation: *mut OPM_REQUESTED_INFORMATION) -> windows_core::Result<()>;
    fn Configure(&self, pparameters: *const OPM_CONFIGURE_PARAMETERS, uladditionalparameterssize: u32, pbadditionalparameters: *const u8) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IOPMVideoOutput {}
impl IOPMVideoOutput_Vtbl {
    pub const fn new<Identity: IOPMVideoOutput_Impl, const OFFSET: isize>() -> IOPMVideoOutput_Vtbl {
        unsafe extern "system" fn StartInitialization<Identity: IOPMVideoOutput_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, prnrandomnumber: *mut OPM_RANDOM_NUMBER, ppbcertificate: *mut *mut u8, pulcertificatelength: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IOPMVideoOutput_Impl::StartInitialization(this, core::mem::transmute_copy(&prnrandomnumber), core::mem::transmute_copy(&ppbcertificate), core::mem::transmute_copy(&pulcertificatelength)).into()
        }
        unsafe extern "system" fn FinishInitialization<Identity: IOPMVideoOutput_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pparameters: *const OPM_ENCRYPTED_INITIALIZATION_PARAMETERS) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IOPMVideoOutput_Impl::FinishInitialization(this, core::mem::transmute_copy(&pparameters)).into()
        }
        unsafe extern "system" fn GetInformation<Identity: IOPMVideoOutput_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pparameters: *const OPM_GET_INFO_PARAMETERS, prequestedinformation: *mut OPM_REQUESTED_INFORMATION) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IOPMVideoOutput_Impl::GetInformation(this, core::mem::transmute_copy(&pparameters), core::mem::transmute_copy(&prequestedinformation)).into()
        }
        unsafe extern "system" fn COPPCompatibleGetInformation<Identity: IOPMVideoOutput_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pparameters: *const OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS, prequestedinformation: *mut OPM_REQUESTED_INFORMATION) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IOPMVideoOutput_Impl::COPPCompatibleGetInformation(this, core::mem::transmute_copy(&pparameters), core::mem::transmute_copy(&prequestedinformation)).into()
        }
        unsafe extern "system" fn Configure<Identity: IOPMVideoOutput_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pparameters: *const OPM_CONFIGURE_PARAMETERS, uladditionalparameterssize: u32, pbadditionalparameters: *const u8) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IOPMVideoOutput_Impl::Configure(this, core::mem::transmute_copy(&pparameters), core::mem::transmute_copy(&uladditionalparameterssize), core::mem::transmute_copy(&pbadditionalparameters)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            StartInitialization: StartInitialization::<Identity, OFFSET>,
            FinishInitialization: FinishInitialization::<Identity, OFFSET>,
            GetInformation: GetInformation::<Identity, OFFSET>,
            COPPCompatibleGetInformation: COPPCompatibleGetInformation::<Identity, OFFSET>,
            Configure: Configure::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IOPMVideoOutput as windows_core::Interface>::IID
    }
}
pub trait IPlayToControl_Impl: Sized + windows_core::IUnknownImpl {
    fn Connect(&self, pfactory: Option<&IMFSharingEngineClassFactory>) -> windows_core::Result<()>;
    fn Disconnect(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IPlayToControl {}
impl IPlayToControl_Vtbl {
    pub const fn new<Identity: IPlayToControl_Impl, const OFFSET: isize>() -> IPlayToControl_Vtbl {
        unsafe extern "system" fn Connect<Identity: IPlayToControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pfactory: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IPlayToControl_Impl::Connect(this, windows_core::from_raw_borrowed(&pfactory)).into()
        }
        unsafe extern "system" fn Disconnect<Identity: IPlayToControl_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IPlayToControl_Impl::Disconnect(this).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), Connect: Connect::<Identity, OFFSET>, Disconnect: Disconnect::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IPlayToControl as windows_core::Interface>::IID
    }
}
pub trait IPlayToControlWithCapabilities_Impl: Sized + IPlayToControl_Impl {
    fn GetCapabilities(&self) -> windows_core::Result<PLAYTO_SOURCE_CREATEFLAGS>;
}
impl windows_core::RuntimeName for IPlayToControlWithCapabilities {}
impl IPlayToControlWithCapabilities_Vtbl {
    pub const fn new<Identity: IPlayToControlWithCapabilities_Impl, const OFFSET: isize>() -> IPlayToControlWithCapabilities_Vtbl {
        unsafe extern "system" fn GetCapabilities<Identity: IPlayToControlWithCapabilities_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pcapabilities: *mut PLAYTO_SOURCE_CREATEFLAGS) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IPlayToControlWithCapabilities_Impl::GetCapabilities(this) {
                Ok(ok__) => {
                    pcapabilities.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: IPlayToControl_Vtbl::new::<Identity, OFFSET>(), GetCapabilities: GetCapabilities::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IPlayToControlWithCapabilities as windows_core::Interface>::IID || iid == &<IPlayToControl as windows_core::Interface>::IID
    }
}
pub trait IPlayToSourceClassFactory_Impl: Sized + windows_core::IUnknownImpl {
    fn CreateInstance(&self, dwflags: u32, pcontrol: Option<&IPlayToControl>) -> windows_core::Result<windows_core::IInspectable>;
}
impl windows_core::RuntimeName for IPlayToSourceClassFactory {}
impl IPlayToSourceClassFactory_Vtbl {
    pub const fn new<Identity: IPlayToSourceClassFactory_Impl, const OFFSET: isize>() -> IPlayToSourceClassFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Identity: IPlayToSourceClassFactory_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwflags: u32, pcontrol: *mut core::ffi::c_void, ppsource: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IPlayToSourceClassFactory_Impl::CreateInstance(this, core::mem::transmute_copy(&dwflags), windows_core::from_raw_borrowed(&pcontrol)) {
                Ok(ok__) => {
                    ppsource.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), CreateInstance: CreateInstance::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IPlayToSourceClassFactory as windows_core::Interface>::IID
    }
}
pub trait IToc_Impl: Sized + windows_core::IUnknownImpl {
    fn SetDescriptor(&self, pdescriptor: *mut TOC_DESCRIPTOR) -> windows_core::Result<()>;
    fn GetDescriptor(&self, pdescriptor: *mut TOC_DESCRIPTOR) -> windows_core::Result<()>;
    fn SetDescription(&self, pwszdescription: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn GetDescription(&self, pwdescriptionsize: *mut u16, pwszdescription: windows_core::PWSTR) -> windows_core::Result<()>;
    fn SetContext(&self, dwcontextsize: u32, pbtcontext: *mut u8) -> windows_core::Result<()>;
    fn GetContext(&self, pdwcontextsize: *mut u32, pbtcontext: *mut u8) -> windows_core::Result<()>;
    fn GetEntryListCount(&self, pwcount: *mut u16) -> windows_core::Result<()>;
    fn GetEntryListByIndex(&self, wentrylistindex: u16) -> windows_core::Result<ITocEntryList>;
    fn AddEntryList(&self, pentrylist: Option<&ITocEntryList>, pwentrylistindex: *mut u16) -> windows_core::Result<()>;
    fn AddEntryListByIndex(&self, wentrylistindex: u16, pentrylist: Option<&ITocEntryList>) -> windows_core::Result<()>;
    fn RemoveEntryListByIndex(&self, wentrylistindex: u16) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IToc {}
impl IToc_Vtbl {
    pub const fn new<Identity: IToc_Impl, const OFFSET: isize>() -> IToc_Vtbl {
        unsafe extern "system" fn SetDescriptor<Identity: IToc_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdescriptor: *mut TOC_DESCRIPTOR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IToc_Impl::SetDescriptor(this, core::mem::transmute_copy(&pdescriptor)).into()
        }
        unsafe extern "system" fn GetDescriptor<Identity: IToc_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdescriptor: *mut TOC_DESCRIPTOR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IToc_Impl::GetDescriptor(this, core::mem::transmute_copy(&pdescriptor)).into()
        }
        unsafe extern "system" fn SetDescription<Identity: IToc_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwszdescription: windows_core::PCWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IToc_Impl::SetDescription(this, core::mem::transmute(&pwszdescription)).into()
        }
        unsafe extern "system" fn GetDescription<Identity: IToc_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwdescriptionsize: *mut u16, pwszdescription: windows_core::PWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IToc_Impl::GetDescription(this, core::mem::transmute_copy(&pwdescriptionsize), core::mem::transmute_copy(&pwszdescription)).into()
        }
        unsafe extern "system" fn SetContext<Identity: IToc_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwcontextsize: u32, pbtcontext: *mut u8) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IToc_Impl::SetContext(this, core::mem::transmute_copy(&dwcontextsize), core::mem::transmute_copy(&pbtcontext)).into()
        }
        unsafe extern "system" fn GetContext<Identity: IToc_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwcontextsize: *mut u32, pbtcontext: *mut u8) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IToc_Impl::GetContext(this, core::mem::transmute_copy(&pdwcontextsize), core::mem::transmute_copy(&pbtcontext)).into()
        }
        unsafe extern "system" fn GetEntryListCount<Identity: IToc_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwcount: *mut u16) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IToc_Impl::GetEntryListCount(this, core::mem::transmute_copy(&pwcount)).into()
        }
        unsafe extern "system" fn GetEntryListByIndex<Identity: IToc_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, wentrylistindex: u16, ppentrylist: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match IToc_Impl::GetEntryListByIndex(this, core::mem::transmute_copy(&wentrylistindex)) {
                Ok(ok__) => {
                    ppentrylist.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddEntryList<Identity: IToc_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pentrylist: *mut core::ffi::c_void, pwentrylistindex: *mut u16) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IToc_Impl::AddEntryList(this, windows_core::from_raw_borrowed(&pentrylist), core::mem::transmute_copy(&pwentrylistindex)).into()
        }
        unsafe extern "system" fn AddEntryListByIndex<Identity: IToc_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, wentrylistindex: u16, pentrylist: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IToc_Impl::AddEntryListByIndex(this, core::mem::transmute_copy(&wentrylistindex), windows_core::from_raw_borrowed(&pentrylist)).into()
        }
        unsafe extern "system" fn RemoveEntryListByIndex<Identity: IToc_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, wentrylistindex: u16) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IToc_Impl::RemoveEntryListByIndex(this, core::mem::transmute_copy(&wentrylistindex)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetDescriptor: SetDescriptor::<Identity, OFFSET>,
            GetDescriptor: GetDescriptor::<Identity, OFFSET>,
            SetDescription: SetDescription::<Identity, OFFSET>,
            GetDescription: GetDescription::<Identity, OFFSET>,
            SetContext: SetContext::<Identity, OFFSET>,
            GetContext: GetContext::<Identity, OFFSET>,
            GetEntryListCount: GetEntryListCount::<Identity, OFFSET>,
            GetEntryListByIndex: GetEntryListByIndex::<Identity, OFFSET>,
            AddEntryList: AddEntryList::<Identity, OFFSET>,
            AddEntryListByIndex: AddEntryListByIndex::<Identity, OFFSET>,
            RemoveEntryListByIndex: RemoveEntryListByIndex::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IToc as windows_core::Interface>::IID
    }
}
pub trait ITocCollection_Impl: Sized + windows_core::IUnknownImpl {
    fn GetEntryCount(&self, pdwentrycount: *mut u32) -> windows_core::Result<()>;
    fn GetEntryByIndex(&self, dwentryindex: u32) -> windows_core::Result<IToc>;
    fn AddEntry(&self, ptoc: Option<&IToc>, pdwentryindex: *mut u32) -> windows_core::Result<()>;
    fn AddEntryByIndex(&self, dwentryindex: u32, ptoc: Option<&IToc>) -> windows_core::Result<()>;
    fn RemoveEntryByIndex(&self, dwentryindex: u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for ITocCollection {}
impl ITocCollection_Vtbl {
    pub const fn new<Identity: ITocCollection_Impl, const OFFSET: isize>() -> ITocCollection_Vtbl {
        unsafe extern "system" fn GetEntryCount<Identity: ITocCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwentrycount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ITocCollection_Impl::GetEntryCount(this, core::mem::transmute_copy(&pdwentrycount)).into()
        }
        unsafe extern "system" fn GetEntryByIndex<Identity: ITocCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwentryindex: u32, pptoc: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match ITocCollection_Impl::GetEntryByIndex(this, core::mem::transmute_copy(&dwentryindex)) {
                Ok(ok__) => {
                    pptoc.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddEntry<Identity: ITocCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ptoc: *mut core::ffi::c_void, pdwentryindex: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ITocCollection_Impl::AddEntry(this, windows_core::from_raw_borrowed(&ptoc), core::mem::transmute_copy(&pdwentryindex)).into()
        }
        unsafe extern "system" fn AddEntryByIndex<Identity: ITocCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwentryindex: u32, ptoc: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ITocCollection_Impl::AddEntryByIndex(this, core::mem::transmute_copy(&dwentryindex), windows_core::from_raw_borrowed(&ptoc)).into()
        }
        unsafe extern "system" fn RemoveEntryByIndex<Identity: ITocCollection_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwentryindex: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ITocCollection_Impl::RemoveEntryByIndex(this, core::mem::transmute_copy(&dwentryindex)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetEntryCount: GetEntryCount::<Identity, OFFSET>,
            GetEntryByIndex: GetEntryByIndex::<Identity, OFFSET>,
            AddEntry: AddEntry::<Identity, OFFSET>,
            AddEntryByIndex: AddEntryByIndex::<Identity, OFFSET>,
            RemoveEntryByIndex: RemoveEntryByIndex::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ITocCollection as windows_core::Interface>::IID
    }
}
pub trait ITocEntry_Impl: Sized + windows_core::IUnknownImpl {
    fn SetTitle(&self, pwsztitle: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn GetTitle(&self, pwtitlesize: *mut u16, pwsztitle: windows_core::PWSTR) -> windows_core::Result<()>;
    fn SetDescriptor(&self, pdescriptor: *mut TOC_ENTRY_DESCRIPTOR) -> windows_core::Result<()>;
    fn GetDescriptor(&self, pdescriptor: *mut TOC_ENTRY_DESCRIPTOR) -> windows_core::Result<()>;
    fn SetSubEntries(&self, dwnumsubentries: u32, pwsubentryindices: *mut u16) -> windows_core::Result<()>;
    fn GetSubEntries(&self, pdwnumsubentries: *mut u32, pwsubentryindices: *mut u16) -> windows_core::Result<()>;
    fn SetDescriptionData(&self, dwdescriptiondatasize: u32, pbtdescriptiondata: *mut u8, pguidtype: *mut windows_core::GUID) -> windows_core::Result<()>;
    fn GetDescriptionData(&self, pdwdescriptiondatasize: *mut u32, pbtdescriptiondata: *mut u8, pguidtype: *mut windows_core::GUID) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for ITocEntry {}
impl ITocEntry_Vtbl {
    pub const fn new<Identity: ITocEntry_Impl, const OFFSET: isize>() -> ITocEntry_Vtbl {
        unsafe extern "system" fn SetTitle<Identity: ITocEntry_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwsztitle: windows_core::PCWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ITocEntry_Impl::SetTitle(this, core::mem::transmute(&pwsztitle)).into()
        }
        unsafe extern "system" fn GetTitle<Identity: ITocEntry_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwtitlesize: *mut u16, pwsztitle: windows_core::PWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ITocEntry_Impl::GetTitle(this, core::mem::transmute_copy(&pwtitlesize), core::mem::transmute_copy(&pwsztitle)).into()
        }
        unsafe extern "system" fn SetDescriptor<Identity: ITocEntry_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdescriptor: *mut TOC_ENTRY_DESCRIPTOR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ITocEntry_Impl::SetDescriptor(this, core::mem::transmute_copy(&pdescriptor)).into()
        }
        unsafe extern "system" fn GetDescriptor<Identity: ITocEntry_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdescriptor: *mut TOC_ENTRY_DESCRIPTOR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ITocEntry_Impl::GetDescriptor(this, core::mem::transmute_copy(&pdescriptor)).into()
        }
        unsafe extern "system" fn SetSubEntries<Identity: ITocEntry_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwnumsubentries: u32, pwsubentryindices: *mut u16) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ITocEntry_Impl::SetSubEntries(this, core::mem::transmute_copy(&dwnumsubentries), core::mem::transmute_copy(&pwsubentryindices)).into()
        }
        unsafe extern "system" fn GetSubEntries<Identity: ITocEntry_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwnumsubentries: *mut u32, pwsubentryindices: *mut u16) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ITocEntry_Impl::GetSubEntries(this, core::mem::transmute_copy(&pdwnumsubentries), core::mem::transmute_copy(&pwsubentryindices)).into()
        }
        unsafe extern "system" fn SetDescriptionData<Identity: ITocEntry_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwdescriptiondatasize: u32, pbtdescriptiondata: *mut u8, pguidtype: *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ITocEntry_Impl::SetDescriptionData(this, core::mem::transmute_copy(&dwdescriptiondatasize), core::mem::transmute_copy(&pbtdescriptiondata), core::mem::transmute_copy(&pguidtype)).into()
        }
        unsafe extern "system" fn GetDescriptionData<Identity: ITocEntry_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwdescriptiondatasize: *mut u32, pbtdescriptiondata: *mut u8, pguidtype: *mut windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ITocEntry_Impl::GetDescriptionData(this, core::mem::transmute_copy(&pdwdescriptiondatasize), core::mem::transmute_copy(&pbtdescriptiondata), core::mem::transmute_copy(&pguidtype)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetTitle: SetTitle::<Identity, OFFSET>,
            GetTitle: GetTitle::<Identity, OFFSET>,
            SetDescriptor: SetDescriptor::<Identity, OFFSET>,
            GetDescriptor: GetDescriptor::<Identity, OFFSET>,
            SetSubEntries: SetSubEntries::<Identity, OFFSET>,
            GetSubEntries: GetSubEntries::<Identity, OFFSET>,
            SetDescriptionData: SetDescriptionData::<Identity, OFFSET>,
            GetDescriptionData: GetDescriptionData::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ITocEntry as windows_core::Interface>::IID
    }
}
pub trait ITocEntryList_Impl: Sized + windows_core::IUnknownImpl {
    fn GetEntryCount(&self, pdwentrycount: *mut u32) -> windows_core::Result<()>;
    fn GetEntryByIndex(&self, dwentryindex: u32) -> windows_core::Result<ITocEntry>;
    fn AddEntry(&self, pentry: Option<&ITocEntry>, pdwentryindex: *mut u32) -> windows_core::Result<()>;
    fn AddEntryByIndex(&self, dwentryindex: u32, pentry: Option<&ITocEntry>) -> windows_core::Result<()>;
    fn RemoveEntryByIndex(&self, dwentryindex: u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for ITocEntryList {}
impl ITocEntryList_Vtbl {
    pub const fn new<Identity: ITocEntryList_Impl, const OFFSET: isize>() -> ITocEntryList_Vtbl {
        unsafe extern "system" fn GetEntryCount<Identity: ITocEntryList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwentrycount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ITocEntryList_Impl::GetEntryCount(this, core::mem::transmute_copy(&pdwentrycount)).into()
        }
        unsafe extern "system" fn GetEntryByIndex<Identity: ITocEntryList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwentryindex: u32, ppentry: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match ITocEntryList_Impl::GetEntryByIndex(this, core::mem::transmute_copy(&dwentryindex)) {
                Ok(ok__) => {
                    ppentry.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddEntry<Identity: ITocEntryList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pentry: *mut core::ffi::c_void, pdwentryindex: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ITocEntryList_Impl::AddEntry(this, windows_core::from_raw_borrowed(&pentry), core::mem::transmute_copy(&pdwentryindex)).into()
        }
        unsafe extern "system" fn AddEntryByIndex<Identity: ITocEntryList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwentryindex: u32, pentry: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ITocEntryList_Impl::AddEntryByIndex(this, core::mem::transmute_copy(&dwentryindex), windows_core::from_raw_borrowed(&pentry)).into()
        }
        unsafe extern "system" fn RemoveEntryByIndex<Identity: ITocEntryList_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwentryindex: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ITocEntryList_Impl::RemoveEntryByIndex(this, core::mem::transmute_copy(&dwentryindex)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetEntryCount: GetEntryCount::<Identity, OFFSET>,
            GetEntryByIndex: GetEntryByIndex::<Identity, OFFSET>,
            AddEntry: AddEntry::<Identity, OFFSET>,
            AddEntryByIndex: AddEntryByIndex::<Identity, OFFSET>,
            RemoveEntryByIndex: RemoveEntryByIndex::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ITocEntryList as windows_core::Interface>::IID
    }
}
pub trait ITocParser_Impl: Sized + windows_core::IUnknownImpl {
    fn Init(&self, pwszfilename: &windows_core::PCWSTR) -> windows_core::Result<()>;
    fn GetTocCount(&self, enumtocpostype: TOC_POS_TYPE, pdwtoccount: *mut u32) -> windows_core::Result<()>;
    fn GetTocByIndex(&self, enumtocpostype: TOC_POS_TYPE, dwtocindex: u32) -> windows_core::Result<IToc>;
    fn GetTocByType(&self, enumtocpostype: TOC_POS_TYPE, guidtoctype: &windows_core::GUID) -> windows_core::Result<ITocCollection>;
    fn AddToc(&self, enumtocpostype: TOC_POS_TYPE, ptoc: Option<&IToc>, pdwtocindex: *mut u32) -> windows_core::Result<()>;
    fn RemoveTocByIndex(&self, enumtocpostype: TOC_POS_TYPE, dwtocindex: u32) -> windows_core::Result<()>;
    fn RemoveTocByType(&self, enumtocpostype: TOC_POS_TYPE, guidtoctype: &windows_core::GUID) -> windows_core::Result<()>;
    fn Commit(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for ITocParser {}
impl ITocParser_Vtbl {
    pub const fn new<Identity: ITocParser_Impl, const OFFSET: isize>() -> ITocParser_Vtbl {
        unsafe extern "system" fn Init<Identity: ITocParser_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pwszfilename: windows_core::PCWSTR) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ITocParser_Impl::Init(this, core::mem::transmute(&pwszfilename)).into()
        }
        unsafe extern "system" fn GetTocCount<Identity: ITocParser_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, pdwtoccount: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ITocParser_Impl::GetTocCount(this, core::mem::transmute_copy(&enumtocpostype), core::mem::transmute_copy(&pdwtoccount)).into()
        }
        unsafe extern "system" fn GetTocByIndex<Identity: ITocParser_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, dwtocindex: u32, pptoc: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match ITocParser_Impl::GetTocByIndex(this, core::mem::transmute_copy(&enumtocpostype), core::mem::transmute_copy(&dwtocindex)) {
                Ok(ok__) => {
                    pptoc.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTocByType<Identity: ITocParser_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, guidtoctype: windows_core::GUID, pptocs: *mut *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            match ITocParser_Impl::GetTocByType(this, core::mem::transmute_copy(&enumtocpostype), core::mem::transmute(&guidtoctype)) {
                Ok(ok__) => {
                    pptocs.write(core::mem::transmute(ok__));
                    windows_core::HRESULT(0)
                }
                Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddToc<Identity: ITocParser_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, ptoc: *mut core::ffi::c_void, pdwtocindex: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ITocParser_Impl::AddToc(this, core::mem::transmute_copy(&enumtocpostype), windows_core::from_raw_borrowed(&ptoc), core::mem::transmute_copy(&pdwtocindex)).into()
        }
        unsafe extern "system" fn RemoveTocByIndex<Identity: ITocParser_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, dwtocindex: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ITocParser_Impl::RemoveTocByIndex(this, core::mem::transmute_copy(&enumtocpostype), core::mem::transmute_copy(&dwtocindex)).into()
        }
        unsafe extern "system" fn RemoveTocByType<Identity: ITocParser_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, guidtoctype: windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ITocParser_Impl::RemoveTocByType(this, core::mem::transmute_copy(&enumtocpostype), core::mem::transmute(&guidtoctype)).into()
        }
        unsafe extern "system" fn Commit<Identity: ITocParser_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            ITocParser_Impl::Commit(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Init: Init::<Identity, OFFSET>,
            GetTocCount: GetTocCount::<Identity, OFFSET>,
            GetTocByIndex: GetTocByIndex::<Identity, OFFSET>,
            GetTocByType: GetTocByType::<Identity, OFFSET>,
            AddToc: AddToc::<Identity, OFFSET>,
            RemoveTocByIndex: RemoveTocByIndex::<Identity, OFFSET>,
            RemoveTocByType: RemoveTocByType::<Identity, OFFSET>,
            Commit: Commit::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<ITocParser as windows_core::Interface>::IID
    }
}
pub trait IValidateBinding_Impl: Sized + windows_core::IUnknownImpl {
    fn GetIdentifier(&self, guidlicensorid: &windows_core::GUID, pbephemeron: *const u8, cbephemeron: u32, ppbblobvalidationid: *mut *mut u8, pcbblobsize: *mut u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IValidateBinding {}
impl IValidateBinding_Vtbl {
    pub const fn new<Identity: IValidateBinding_Impl, const OFFSET: isize>() -> IValidateBinding_Vtbl {
        unsafe extern "system" fn GetIdentifier<Identity: IValidateBinding_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidlicensorid: windows_core::GUID, pbephemeron: *const u8, cbephemeron: u32, ppbblobvalidationid: *mut *mut u8, pcbblobsize: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IValidateBinding_Impl::GetIdentifier(this, core::mem::transmute(&guidlicensorid), core::mem::transmute_copy(&pbephemeron), core::mem::transmute_copy(&cbephemeron), core::mem::transmute_copy(&ppbblobvalidationid), core::mem::transmute_copy(&pcbblobsize)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetIdentifier: GetIdentifier::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IValidateBinding as windows_core::Interface>::IID
    }
}
pub trait IWMCodecLeakyBucket_Impl: Sized + windows_core::IUnknownImpl {
    fn SetBufferSizeBits(&self, ulbuffersize: u32) -> windows_core::Result<()>;
    fn GetBufferSizeBits(&self, pulbuffersize: *mut u32) -> windows_core::Result<()>;
    fn SetBufferFullnessBits(&self, ulbufferfullness: u32) -> windows_core::Result<()>;
    fn GetBufferFullnessBits(&self, pulbufferfullness: *mut u32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IWMCodecLeakyBucket {}
impl IWMCodecLeakyBucket_Vtbl {
    pub const fn new<Identity: IWMCodecLeakyBucket_Impl, const OFFSET: isize>() -> IWMCodecLeakyBucket_Vtbl {
        unsafe extern "system" fn SetBufferSizeBits<Identity: IWMCodecLeakyBucket_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulbuffersize: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMCodecLeakyBucket_Impl::SetBufferSizeBits(this, core::mem::transmute_copy(&ulbuffersize)).into()
        }
        unsafe extern "system" fn GetBufferSizeBits<Identity: IWMCodecLeakyBucket_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulbuffersize: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMCodecLeakyBucket_Impl::GetBufferSizeBits(this, core::mem::transmute_copy(&pulbuffersize)).into()
        }
        unsafe extern "system" fn SetBufferFullnessBits<Identity: IWMCodecLeakyBucket_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, ulbufferfullness: u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMCodecLeakyBucket_Impl::SetBufferFullnessBits(this, core::mem::transmute_copy(&ulbufferfullness)).into()
        }
        unsafe extern "system" fn GetBufferFullnessBits<Identity: IWMCodecLeakyBucket_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pulbufferfullness: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMCodecLeakyBucket_Impl::GetBufferFullnessBits(this, core::mem::transmute_copy(&pulbufferfullness)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetBufferSizeBits: SetBufferSizeBits::<Identity, OFFSET>,
            GetBufferSizeBits: GetBufferSizeBits::<Identity, OFFSET>,
            SetBufferFullnessBits: SetBufferFullnessBits::<Identity, OFFSET>,
            GetBufferFullnessBits: GetBufferFullnessBits::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IWMCodecLeakyBucket as windows_core::Interface>::IID
    }
}
pub trait IWMCodecOutputTimestamp_Impl: Sized + windows_core::IUnknownImpl {
    fn GetNextOutputTime(&self, prttime: *mut i64) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IWMCodecOutputTimestamp {}
impl IWMCodecOutputTimestamp_Vtbl {
    pub const fn new<Identity: IWMCodecOutputTimestamp_Impl, const OFFSET: isize>() -> IWMCodecOutputTimestamp_Vtbl {
        unsafe extern "system" fn GetNextOutputTime<Identity: IWMCodecOutputTimestamp_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, prttime: *mut i64) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMCodecOutputTimestamp_Impl::GetNextOutputTime(this, core::mem::transmute_copy(&prttime)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), GetNextOutputTime: GetNextOutputTime::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IWMCodecOutputTimestamp as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_DxMediaObjects")]
pub trait IWMCodecPrivateData_Impl: Sized + windows_core::IUnknownImpl {
    fn SetPartialOutputType(&self, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE) -> windows_core::Result<()>;
    fn GetPrivateData(&self, pbdata: *mut u8, pcbdata: *mut u32) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Media_DxMediaObjects")]
impl windows_core::RuntimeName for IWMCodecPrivateData {}
#[cfg(feature = "Win32_Media_DxMediaObjects")]
impl IWMCodecPrivateData_Vtbl {
    pub const fn new<Identity: IWMCodecPrivateData_Impl, const OFFSET: isize>() -> IWMCodecPrivateData_Vtbl {
        unsafe extern "system" fn SetPartialOutputType<Identity: IWMCodecPrivateData_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMCodecPrivateData_Impl::SetPartialOutputType(this, core::mem::transmute_copy(&pmt)).into()
        }
        unsafe extern "system" fn GetPrivateData<Identity: IWMCodecPrivateData_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbdata: *mut u8, pcbdata: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMCodecPrivateData_Impl::GetPrivateData(this, core::mem::transmute_copy(&pbdata), core::mem::transmute_copy(&pcbdata)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetPartialOutputType: SetPartialOutputType::<Identity, OFFSET>,
            GetPrivateData: GetPrivateData::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IWMCodecPrivateData as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_DxMediaObjects")]
pub trait IWMCodecProps_Impl: Sized + windows_core::IUnknownImpl {
    fn GetFormatProp(&self, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE, pszname: &windows_core::PCWSTR, ptype: *mut WMT_PROP_DATATYPE, pvalue: *mut u8, pdwsize: *mut u32) -> windows_core::Result<()>;
    fn GetCodecProp(&self, dwformat: u32, pszname: &windows_core::PCWSTR, ptype: *mut WMT_PROP_DATATYPE, pvalue: *mut u8, pdwsize: *mut u32) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Media_DxMediaObjects")]
impl windows_core::RuntimeName for IWMCodecProps {}
#[cfg(feature = "Win32_Media_DxMediaObjects")]
impl IWMCodecProps_Vtbl {
    pub const fn new<Identity: IWMCodecProps_Impl, const OFFSET: isize>() -> IWMCodecProps_Vtbl {
        unsafe extern "system" fn GetFormatProp<Identity: IWMCodecProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE, pszname: windows_core::PCWSTR, ptype: *mut WMT_PROP_DATATYPE, pvalue: *mut u8, pdwsize: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMCodecProps_Impl::GetFormatProp(this, core::mem::transmute_copy(&pmt), core::mem::transmute(&pszname), core::mem::transmute_copy(&ptype), core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pdwsize)).into()
        }
        unsafe extern "system" fn GetCodecProp<Identity: IWMCodecProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, dwformat: u32, pszname: windows_core::PCWSTR, ptype: *mut WMT_PROP_DATATYPE, pvalue: *mut u8, pdwsize: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMCodecProps_Impl::GetCodecProp(this, core::mem::transmute_copy(&dwformat), core::mem::transmute(&pszname), core::mem::transmute_copy(&ptype), core::mem::transmute_copy(&pvalue), core::mem::transmute_copy(&pdwsize)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetFormatProp: GetFormatProp::<Identity, OFFSET>,
            GetCodecProp: GetCodecProp::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IWMCodecProps as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_DxMediaObjects")]
pub trait IWMCodecStrings_Impl: Sized + windows_core::IUnknownImpl {
    fn GetName(&self, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE, cchlength: u32, szname: windows_core::PWSTR, pcchlength: *mut u32) -> windows_core::Result<()>;
    fn GetDescription(&self, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE, cchlength: u32, szdescription: windows_core::PWSTR, pcchlength: *mut u32) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Media_DxMediaObjects")]
impl windows_core::RuntimeName for IWMCodecStrings {}
#[cfg(feature = "Win32_Media_DxMediaObjects")]
impl IWMCodecStrings_Vtbl {
    pub const fn new<Identity: IWMCodecStrings_Impl, const OFFSET: isize>() -> IWMCodecStrings_Vtbl {
        unsafe extern "system" fn GetName<Identity: IWMCodecStrings_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE, cchlength: u32, szname: windows_core::PWSTR, pcchlength: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMCodecStrings_Impl::GetName(this, core::mem::transmute_copy(&pmt), core::mem::transmute_copy(&cchlength), core::mem::transmute_copy(&szname), core::mem::transmute_copy(&pcchlength)).into()
        }
        unsafe extern "system" fn GetDescription<Identity: IWMCodecStrings_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE, cchlength: u32, szdescription: windows_core::PWSTR, pcchlength: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMCodecStrings_Impl::GetDescription(this, core::mem::transmute_copy(&pmt), core::mem::transmute_copy(&cchlength), core::mem::transmute_copy(&szdescription), core::mem::transmute_copy(&pcchlength)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetName: GetName::<Identity, OFFSET>,
            GetDescription: GetDescription::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IWMCodecStrings as windows_core::Interface>::IID
    }
}
pub trait IWMColorConvProps_Impl: Sized + windows_core::IUnknownImpl {
    fn SetMode(&self, lmode: i32) -> windows_core::Result<()>;
    fn SetFullCroppingParam(&self, lsrccropleft: i32, lsrccroptop: i32, ldstcropleft: i32, ldstcroptop: i32, lcropwidth: i32, lcropheight: i32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IWMColorConvProps {}
impl IWMColorConvProps_Vtbl {
    pub const fn new<Identity: IWMColorConvProps_Impl, const OFFSET: isize>() -> IWMColorConvProps_Vtbl {
        unsafe extern "system" fn SetMode<Identity: IWMColorConvProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lmode: i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMColorConvProps_Impl::SetMode(this, core::mem::transmute_copy(&lmode)).into()
        }
        unsafe extern "system" fn SetFullCroppingParam<Identity: IWMColorConvProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lsrccropleft: i32, lsrccroptop: i32, ldstcropleft: i32, ldstcroptop: i32, lcropwidth: i32, lcropheight: i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMColorConvProps_Impl::SetFullCroppingParam(this, core::mem::transmute_copy(&lsrccropleft), core::mem::transmute_copy(&lsrccroptop), core::mem::transmute_copy(&ldstcropleft), core::mem::transmute_copy(&ldstcroptop), core::mem::transmute_copy(&lcropwidth), core::mem::transmute_copy(&lcropheight)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetMode: SetMode::<Identity, OFFSET>,
            SetFullCroppingParam: SetFullCroppingParam::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IWMColorConvProps as windows_core::Interface>::IID
    }
}
pub trait IWMColorLegalizerProps_Impl: Sized + windows_core::IUnknownImpl {
    fn SetColorLegalizerQuality(&self, lquality: i32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IWMColorLegalizerProps {}
impl IWMColorLegalizerProps_Vtbl {
    pub const fn new<Identity: IWMColorLegalizerProps_Impl, const OFFSET: isize>() -> IWMColorLegalizerProps_Vtbl {
        unsafe extern "system" fn SetColorLegalizerQuality<Identity: IWMColorLegalizerProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lquality: i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMColorLegalizerProps_Impl::SetColorLegalizerQuality(this, core::mem::transmute_copy(&lquality)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), SetColorLegalizerQuality: SetColorLegalizerQuality::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IWMColorLegalizerProps as windows_core::Interface>::IID
    }
}
pub trait IWMFrameInterpProps_Impl: Sized + windows_core::IUnknownImpl {
    fn SetFrameRateIn(&self, lframerate: i32, lscale: i32) -> windows_core::Result<()>;
    fn SetFrameRateOut(&self, lframerate: i32, lscale: i32) -> windows_core::Result<()>;
    fn SetFrameInterpEnabled(&self, bfienabled: super::super::Foundation::BOOL) -> windows_core::Result<()>;
    fn SetComplexityLevel(&self, icomplexity: i32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IWMFrameInterpProps {}
impl IWMFrameInterpProps_Vtbl {
    pub const fn new<Identity: IWMFrameInterpProps_Impl, const OFFSET: isize>() -> IWMFrameInterpProps_Vtbl {
        unsafe extern "system" fn SetFrameRateIn<Identity: IWMFrameInterpProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lframerate: i32, lscale: i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMFrameInterpProps_Impl::SetFrameRateIn(this, core::mem::transmute_copy(&lframerate), core::mem::transmute_copy(&lscale)).into()
        }
        unsafe extern "system" fn SetFrameRateOut<Identity: IWMFrameInterpProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lframerate: i32, lscale: i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMFrameInterpProps_Impl::SetFrameRateOut(this, core::mem::transmute_copy(&lframerate), core::mem::transmute_copy(&lscale)).into()
        }
        unsafe extern "system" fn SetFrameInterpEnabled<Identity: IWMFrameInterpProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, bfienabled: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMFrameInterpProps_Impl::SetFrameInterpEnabled(this, core::mem::transmute_copy(&bfienabled)).into()
        }
        unsafe extern "system" fn SetComplexityLevel<Identity: IWMFrameInterpProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, icomplexity: i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMFrameInterpProps_Impl::SetComplexityLevel(this, core::mem::transmute_copy(&icomplexity)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetFrameRateIn: SetFrameRateIn::<Identity, OFFSET>,
            SetFrameRateOut: SetFrameRateOut::<Identity, OFFSET>,
            SetFrameInterpEnabled: SetFrameInterpEnabled::<Identity, OFFSET>,
            SetComplexityLevel: SetComplexityLevel::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IWMFrameInterpProps as windows_core::Interface>::IID
    }
}
pub trait IWMInterlaceProps_Impl: Sized + windows_core::IUnknownImpl {
    fn SetProcessType(&self, iprocesstype: i32) -> windows_core::Result<()>;
    fn SetInitInverseTeleCinePattern(&self, iinitpattern: i32) -> windows_core::Result<()>;
    fn SetLastFrame(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IWMInterlaceProps {}
impl IWMInterlaceProps_Vtbl {
    pub const fn new<Identity: IWMInterlaceProps_Impl, const OFFSET: isize>() -> IWMInterlaceProps_Vtbl {
        unsafe extern "system" fn SetProcessType<Identity: IWMInterlaceProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, iprocesstype: i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMInterlaceProps_Impl::SetProcessType(this, core::mem::transmute_copy(&iprocesstype)).into()
        }
        unsafe extern "system" fn SetInitInverseTeleCinePattern<Identity: IWMInterlaceProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, iinitpattern: i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMInterlaceProps_Impl::SetInitInverseTeleCinePattern(this, core::mem::transmute_copy(&iinitpattern)).into()
        }
        unsafe extern "system" fn SetLastFrame<Identity: IWMInterlaceProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMInterlaceProps_Impl::SetLastFrame(this).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetProcessType: SetProcessType::<Identity, OFFSET>,
            SetInitInverseTeleCinePattern: SetInitInverseTeleCinePattern::<Identity, OFFSET>,
            SetLastFrame: SetLastFrame::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IWMInterlaceProps as windows_core::Interface>::IID
    }
}
pub trait IWMResamplerProps_Impl: Sized + windows_core::IUnknownImpl {
    fn SetHalfFilterLength(&self, lhalffilterlen: i32) -> windows_core::Result<()>;
    fn SetUserChannelMtx(&self, userchannelmtx: *mut f32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IWMResamplerProps {}
impl IWMResamplerProps_Vtbl {
    pub const fn new<Identity: IWMResamplerProps_Impl, const OFFSET: isize>() -> IWMResamplerProps_Vtbl {
        unsafe extern "system" fn SetHalfFilterLength<Identity: IWMResamplerProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lhalffilterlen: i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMResamplerProps_Impl::SetHalfFilterLength(this, core::mem::transmute_copy(&lhalffilterlen)).into()
        }
        unsafe extern "system" fn SetUserChannelMtx<Identity: IWMResamplerProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, userchannelmtx: *mut f32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMResamplerProps_Impl::SetUserChannelMtx(this, core::mem::transmute_copy(&userchannelmtx)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetHalfFilterLength: SetHalfFilterLength::<Identity, OFFSET>,
            SetUserChannelMtx: SetUserChannelMtx::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IWMResamplerProps as windows_core::Interface>::IID
    }
}
pub trait IWMResizerProps_Impl: Sized + windows_core::IUnknownImpl {
    fn SetResizerQuality(&self, lquality: i32) -> windows_core::Result<()>;
    fn SetInterlaceMode(&self, lmode: i32) -> windows_core::Result<()>;
    fn SetClipRegion(&self, lcliporixsrc: i32, lcliporiysrc: i32, lclipwidthsrc: i32, lclipheightsrc: i32) -> windows_core::Result<()>;
    fn SetFullCropRegion(&self, lcliporixsrc: i32, lcliporiysrc: i32, lclipwidthsrc: i32, lclipheightsrc: i32, lcliporixdst: i32, lcliporiydst: i32, lclipwidthdst: i32, lclipheightdst: i32) -> windows_core::Result<()>;
    fn GetFullCropRegion(&self, lcliporixsrc: *mut i32, lcliporiysrc: *mut i32, lclipwidthsrc: *mut i32, lclipheightsrc: *mut i32, lcliporixdst: *mut i32, lcliporiydst: *mut i32, lclipwidthdst: *mut i32, lclipheightdst: *mut i32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IWMResizerProps {}
impl IWMResizerProps_Vtbl {
    pub const fn new<Identity: IWMResizerProps_Impl, const OFFSET: isize>() -> IWMResizerProps_Vtbl {
        unsafe extern "system" fn SetResizerQuality<Identity: IWMResizerProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lquality: i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMResizerProps_Impl::SetResizerQuality(this, core::mem::transmute_copy(&lquality)).into()
        }
        unsafe extern "system" fn SetInterlaceMode<Identity: IWMResizerProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lmode: i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMResizerProps_Impl::SetInterlaceMode(this, core::mem::transmute_copy(&lmode)).into()
        }
        unsafe extern "system" fn SetClipRegion<Identity: IWMResizerProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lcliporixsrc: i32, lcliporiysrc: i32, lclipwidthsrc: i32, lclipheightsrc: i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMResizerProps_Impl::SetClipRegion(this, core::mem::transmute_copy(&lcliporixsrc), core::mem::transmute_copy(&lcliporiysrc), core::mem::transmute_copy(&lclipwidthsrc), core::mem::transmute_copy(&lclipheightsrc)).into()
        }
        unsafe extern "system" fn SetFullCropRegion<Identity: IWMResizerProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lcliporixsrc: i32, lcliporiysrc: i32, lclipwidthsrc: i32, lclipheightsrc: i32, lcliporixdst: i32, lcliporiydst: i32, lclipwidthdst: i32, lclipheightdst: i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMResizerProps_Impl::SetFullCropRegion(this, core::mem::transmute_copy(&lcliporixsrc), core::mem::transmute_copy(&lcliporiysrc), core::mem::transmute_copy(&lclipwidthsrc), core::mem::transmute_copy(&lclipheightsrc), core::mem::transmute_copy(&lcliporixdst), core::mem::transmute_copy(&lcliporiydst), core::mem::transmute_copy(&lclipwidthdst), core::mem::transmute_copy(&lclipheightdst)).into()
        }
        unsafe extern "system" fn GetFullCropRegion<Identity: IWMResizerProps_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lcliporixsrc: *mut i32, lcliporiysrc: *mut i32, lclipwidthsrc: *mut i32, lclipheightsrc: *mut i32, lcliporixdst: *mut i32, lcliporiydst: *mut i32, lclipwidthdst: *mut i32, lclipheightdst: *mut i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMResizerProps_Impl::GetFullCropRegion(this, core::mem::transmute_copy(&lcliporixsrc), core::mem::transmute_copy(&lcliporiysrc), core::mem::transmute_copy(&lclipwidthsrc), core::mem::transmute_copy(&lclipheightsrc), core::mem::transmute_copy(&lcliporixdst), core::mem::transmute_copy(&lcliporiydst), core::mem::transmute_copy(&lclipwidthdst), core::mem::transmute_copy(&lclipheightdst)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetResizerQuality: SetResizerQuality::<Identity, OFFSET>,
            SetInterlaceMode: SetInterlaceMode::<Identity, OFFSET>,
            SetClipRegion: SetClipRegion::<Identity, OFFSET>,
            SetFullCropRegion: SetFullCropRegion::<Identity, OFFSET>,
            GetFullCropRegion: GetFullCropRegion::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IWMResizerProps as windows_core::Interface>::IID
    }
}
pub trait IWMSampleExtensionSupport_Impl: Sized + windows_core::IUnknownImpl {
    fn SetUseSampleExtensions(&self, fuseextensions: super::super::Foundation::BOOL) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IWMSampleExtensionSupport {}
impl IWMSampleExtensionSupport_Vtbl {
    pub const fn new<Identity: IWMSampleExtensionSupport_Impl, const OFFSET: isize>() -> IWMSampleExtensionSupport_Vtbl {
        unsafe extern "system" fn SetUseSampleExtensions<Identity: IWMSampleExtensionSupport_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, fuseextensions: super::super::Foundation::BOOL) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMSampleExtensionSupport_Impl::SetUseSampleExtensions(this, core::mem::transmute_copy(&fuseextensions)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), SetUseSampleExtensions: SetUseSampleExtensions::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IWMSampleExtensionSupport as windows_core::Interface>::IID
    }
}
pub trait IWMValidate_Impl: Sized + windows_core::IUnknownImpl {
    fn SetIdentifier(&self, guidvalidationid: &windows_core::GUID) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IWMValidate {}
impl IWMValidate_Vtbl {
    pub const fn new<Identity: IWMValidate_Impl, const OFFSET: isize>() -> IWMValidate_Vtbl {
        unsafe extern "system" fn SetIdentifier<Identity: IWMValidate_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, guidvalidationid: windows_core::GUID) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMValidate_Impl::SetIdentifier(this, core::mem::transmute(&guidvalidationid)).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), SetIdentifier: SetIdentifier::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IWMValidate as windows_core::Interface>::IID
    }
}
pub trait IWMVideoDecoderHurryup_Impl: Sized + windows_core::IUnknownImpl {
    fn SetHurryup(&self, lhurryup: i32) -> windows_core::Result<()>;
    fn GetHurryup(&self, plhurryup: *mut i32) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IWMVideoDecoderHurryup {}
impl IWMVideoDecoderHurryup_Vtbl {
    pub const fn new<Identity: IWMVideoDecoderHurryup_Impl, const OFFSET: isize>() -> IWMVideoDecoderHurryup_Vtbl {
        unsafe extern "system" fn SetHurryup<Identity: IWMVideoDecoderHurryup_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, lhurryup: i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMVideoDecoderHurryup_Impl::SetHurryup(this, core::mem::transmute_copy(&lhurryup)).into()
        }
        unsafe extern "system" fn GetHurryup<Identity: IWMVideoDecoderHurryup_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, plhurryup: *mut i32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMVideoDecoderHurryup_Impl::GetHurryup(this, core::mem::transmute_copy(&plhurryup)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetHurryup: SetHurryup::<Identity, OFFSET>,
            GetHurryup: GetHurryup::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IWMVideoDecoderHurryup as windows_core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_DxMediaObjects")]
pub trait IWMVideoDecoderReconBuffer_Impl: Sized + windows_core::IUnknownImpl {
    fn GetReconstructedVideoFrameSize(&self, pdwsize: *mut u32) -> windows_core::Result<()>;
    fn GetReconstructedVideoFrame(&self, pbuf: Option<&super::DxMediaObjects::IMediaBuffer>) -> windows_core::Result<()>;
    fn SetReconstructedVideoFrame(&self, pbuf: Option<&super::DxMediaObjects::IMediaBuffer>) -> windows_core::Result<()>;
}
#[cfg(feature = "Win32_Media_DxMediaObjects")]
impl windows_core::RuntimeName for IWMVideoDecoderReconBuffer {}
#[cfg(feature = "Win32_Media_DxMediaObjects")]
impl IWMVideoDecoderReconBuffer_Vtbl {
    pub const fn new<Identity: IWMVideoDecoderReconBuffer_Impl, const OFFSET: isize>() -> IWMVideoDecoderReconBuffer_Vtbl {
        unsafe extern "system" fn GetReconstructedVideoFrameSize<Identity: IWMVideoDecoderReconBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pdwsize: *mut u32) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMVideoDecoderReconBuffer_Impl::GetReconstructedVideoFrameSize(this, core::mem::transmute_copy(&pdwsize)).into()
        }
        unsafe extern "system" fn GetReconstructedVideoFrame<Identity: IWMVideoDecoderReconBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbuf: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMVideoDecoderReconBuffer_Impl::GetReconstructedVideoFrame(this, windows_core::from_raw_borrowed(&pbuf)).into()
        }
        unsafe extern "system" fn SetReconstructedVideoFrame<Identity: IWMVideoDecoderReconBuffer_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void, pbuf: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMVideoDecoderReconBuffer_Impl::SetReconstructedVideoFrame(this, windows_core::from_raw_borrowed(&pbuf)).into()
        }
        Self {
            base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetReconstructedVideoFrameSize: GetReconstructedVideoFrameSize::<Identity, OFFSET>,
            GetReconstructedVideoFrame: GetReconstructedVideoFrame::<Identity, OFFSET>,
            SetReconstructedVideoFrame: SetReconstructedVideoFrame::<Identity, OFFSET>,
        }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IWMVideoDecoderReconBuffer as windows_core::Interface>::IID
    }
}
pub trait IWMVideoForceKeyFrame_Impl: Sized + windows_core::IUnknownImpl {
    fn SetKeyFrame(&self) -> windows_core::Result<()>;
}
impl windows_core::RuntimeName for IWMVideoForceKeyFrame {}
impl IWMVideoForceKeyFrame_Vtbl {
    pub const fn new<Identity: IWMVideoForceKeyFrame_Impl, const OFFSET: isize>() -> IWMVideoForceKeyFrame_Vtbl {
        unsafe extern "system" fn SetKeyFrame<Identity: IWMVideoForceKeyFrame_Impl, const OFFSET: isize>(this: *mut core::ffi::c_void) -> windows_core::HRESULT {
            let this: &Identity = &*((this as *const *const ()).offset(OFFSET) as *const Identity);
            IWMVideoForceKeyFrame_Impl::SetKeyFrame(this).into()
        }
        Self { base__: windows_core::IUnknown_Vtbl::new::<Identity, OFFSET>(), SetKeyFrame: SetKeyFrame::<Identity, OFFSET> }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<IWMVideoForceKeyFrame as windows_core::Interface>::IID
    }
}
pub trait MFASYNCRESULT_Impl: Sized + IMFAsyncResult_Impl {}
impl windows_core::RuntimeName for MFASYNCRESULT {}
impl MFASYNCRESULT_Vtbl {
    pub const fn new<Identity: MFASYNCRESULT_Impl, const OFFSET: isize>() -> MFASYNCRESULT_Vtbl {
        Self { base__: IMFAsyncResult_Vtbl::new::<Identity, OFFSET>() }
    }
    pub fn matches(iid: &windows_core::GUID) -> bool {
        iid == &<MFASYNCRESULT as windows_core::Interface>::IID || iid == &<IMFAsyncResult as windows_core::Interface>::IID
    }
}
