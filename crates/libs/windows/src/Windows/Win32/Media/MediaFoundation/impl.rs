pub trait IAdvancedMediaCaptureImpl: Sized {
    fn GetAdvancedMediaCaptureSettings();
}
impl ::windows::core::RuntimeName for IAdvancedMediaCapture {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IAdvancedMediaCapture";
}
impl IAdvancedMediaCaptureVtbl {
    pub const fn new<Impl: IAdvancedMediaCaptureImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAdvancedMediaCaptureVtbl {
        unsafe extern "system" fn GetAdvancedMediaCaptureSettings<Impl: IAdvancedMediaCaptureImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAdvancedMediaCaptureSettings(::core::mem::transmute_copy(&value)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAdvancedMediaCapture>, base.5, GetAdvancedMediaCaptureSettings::<Impl, OFFSET>)
    }
}
pub trait IAdvancedMediaCaptureInitializationSettingsImpl: Sized {
    fn SetDirectxDeviceManager();
}
impl ::windows::core::RuntimeName for IAdvancedMediaCaptureInitializationSettings {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IAdvancedMediaCaptureInitializationSettings";
}
impl IAdvancedMediaCaptureInitializationSettingsVtbl {
    pub const fn new<Impl: IAdvancedMediaCaptureInitializationSettingsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAdvancedMediaCaptureInitializationSettingsVtbl {
        unsafe extern "system" fn SetDirectxDeviceManager<Impl: IAdvancedMediaCaptureInitializationSettingsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDirectxDeviceManager(&*(&value as *const <IMFDXGIDeviceManager as ::windows::core::Abi>::Abi as *const <IMFDXGIDeviceManager as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAdvancedMediaCaptureInitializationSettings>, base.5, SetDirectxDeviceManager::<Impl, OFFSET>)
    }
}
pub trait IAdvancedMediaCaptureSettingsImpl: Sized {
    fn GetDirectxDeviceManager();
}
impl ::windows::core::RuntimeName for IAdvancedMediaCaptureSettings {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IAdvancedMediaCaptureSettings";
}
impl IAdvancedMediaCaptureSettingsVtbl {
    pub const fn new<Impl: IAdvancedMediaCaptureSettingsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAdvancedMediaCaptureSettingsVtbl {
        unsafe extern "system" fn GetDirectxDeviceManager<Impl: IAdvancedMediaCaptureSettingsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDirectxDeviceManager(::core::mem::transmute_copy(&value)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAdvancedMediaCaptureSettings>, base.5, GetDirectxDeviceManager::<Impl, OFFSET>)
    }
}
pub trait IAudioSourceProviderImpl: Sized {
    fn ProvideInput();
}
impl ::windows::core::RuntimeName for IAudioSourceProvider {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IAudioSourceProvider";
}
impl IAudioSourceProviderVtbl {
    pub const fn new<Impl: IAudioSourceProviderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IAudioSourceProviderVtbl {
        unsafe extern "system" fn ProvideInput<Impl: IAudioSourceProviderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsamplecount: u32, pdwchannelcount: *mut u32, pinterleavedaudiodata: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProvideInput(dwsamplecount, pdwchannelcount, ::core::mem::transmute_copy(&pinterleavedaudiodata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IAudioSourceProvider>, base.5, ProvideInput::<Impl, OFFSET>)
    }
}
pub trait IClusterDetectorImpl: Sized {
    fn Initialize();
    fn Detect();
}
impl ::windows::core::RuntimeName for IClusterDetector {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IClusterDetector";
}
impl IClusterDetectorVtbl {
    pub const fn new<Impl: IClusterDetectorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IClusterDetectorVtbl {
        unsafe extern "system" fn Initialize<Impl: IClusterDetectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wbaseentrylevel: u16, wclusterentrylevel: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(wbaseentrylevel, wclusterentrylevel) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Detect<Impl: IClusterDetectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwmaxnumclusters: u32, fminclusterduration: f32, fmaxclusterduration: f32, psrctoc: ::windows::core::RawPtr, ppdsttoc: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Detect(dwmaxnumclusters, fminclusterduration, fmaxclusterduration, &*(&psrctoc as *const <IToc as ::windows::core::Abi>::Abi as *const <IToc as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppdsttoc)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IClusterDetector>, base.5, Initialize::<Impl, OFFSET>, Detect::<Impl, OFFSET>)
    }
}
pub trait ICodecAPIImpl: Sized {
    fn IsSupported();
    fn IsModifiable();
    fn GetParameterRange();
    fn GetParameterValues();
    fn GetDefaultValue();
    fn GetValue();
    fn SetValue();
    fn RegisterForEvent();
    fn UnregisterForEvent();
    fn SetAllDefaults();
    fn SetValueWithNotify();
    fn SetAllDefaultsWithNotify();
    fn GetAllSettings();
    fn SetAllSettings();
    fn SetAllSettingsWithNotify();
}
impl ::windows::core::RuntimeName for ICodecAPI {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ICodecAPI";
}
impl ICodecAPIVtbl {
    pub const fn new<Impl: ICodecAPIImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ICodecAPIVtbl {
        unsafe extern "system" fn IsSupported<Impl: ICodecAPIImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSupported(&*(&api as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsModifiable<Impl: ICodecAPIImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsModifiable(&*(&api as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetParameterRange<Impl: ICodecAPIImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, valuemin: *mut super::super::System::Com::VARIANT, valuemax: *mut super::super::System::Com::VARIANT, steppingdelta: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetParameterRange(&*(&api as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&valuemin), ::core::mem::transmute_copy(&valuemax), ::core::mem::transmute_copy(&steppingdelta)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetParameterValues<Impl: ICodecAPIImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, values: *mut *mut super::super::System::Com::VARIANT, valuescount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetParameterValues(&*(&api as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&values), ::core::mem::transmute_copy(&valuescount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDefaultValue<Impl: ICodecAPIImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, value: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDefaultValue(&*(&api as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&value)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetValue<Impl: ICodecAPIImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, value: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetValue(&*(&api as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&value)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetValue<Impl: ICodecAPIImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, value: *const super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetValue(&*(&api as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterForEvent<Impl: ICodecAPIImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, userdata: isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterForEvent(&*(&api as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), userdata) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnregisterForEvent<Impl: ICodecAPIImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnregisterForEvent(&*(&api as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAllDefaults<Impl: ICodecAPIImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAllDefaults() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetValueWithNotify<Impl: ICodecAPIImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, value: *mut super::super::System::Com::VARIANT, changedparam: *mut *mut ::windows::core::GUID, changedparamcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetValueWithNotify(&*(&api as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <super::super::System::Com::VARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::VARIANT as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&changedparam), ::core::mem::transmute_copy(&changedparamcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAllDefaultsWithNotify<Impl: ICodecAPIImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, changedparam: *mut *mut ::windows::core::GUID, changedparamcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAllDefaultsWithNotify(::core::mem::transmute_copy(&changedparam), ::core::mem::transmute_copy(&changedparamcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAllSettings<Impl: ICodecAPIImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, __midl__icodecapi0000: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAllSettings(&*(&__midl__icodecapi0000 as *const <super::super::System::Com::IStream as ::windows::core::Abi>::Abi as *const <super::super::System::Com::IStream as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAllSettings<Impl: ICodecAPIImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, __midl__icodecapi0001: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAllSettings(&*(&__midl__icodecapi0001 as *const <super::super::System::Com::IStream as ::windows::core::Abi>::Abi as *const <super::super::System::Com::IStream as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAllSettingsWithNotify<Impl: ICodecAPIImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, __midl__icodecapi0002: ::windows::core::RawPtr, changedparam: *mut *mut ::windows::core::GUID, changedparamcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAllSettingsWithNotify(&*(&__midl__icodecapi0002 as *const <super::super::System::Com::IStream as ::windows::core::Abi>::Abi as *const <super::super::System::Com::IStream as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&changedparam), ::core::mem::transmute_copy(&changedparamcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ICodecAPI>,
            base.5,
            IsSupported::<Impl, OFFSET>,
            IsModifiable::<Impl, OFFSET>,
            GetParameterRange::<Impl, OFFSET>,
            GetParameterValues::<Impl, OFFSET>,
            GetDefaultValue::<Impl, OFFSET>,
            GetValue::<Impl, OFFSET>,
            SetValue::<Impl, OFFSET>,
            RegisterForEvent::<Impl, OFFSET>,
            UnregisterForEvent::<Impl, OFFSET>,
            SetAllDefaults::<Impl, OFFSET>,
            SetValueWithNotify::<Impl, OFFSET>,
            SetAllDefaultsWithNotify::<Impl, OFFSET>,
            GetAllSettings::<Impl, OFFSET>,
            SetAllSettings::<Impl, OFFSET>,
            SetAllSettingsWithNotify::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoDecodeCommandListImpl: Sized + ID3D12CommandListImpl + ID3D12DeviceChildImpl + ID3D12ObjectImpl {
    fn Close();
    fn Reset();
    fn ClearState();
    fn ResourceBarrier();
    fn DiscardResource();
    fn BeginQuery();
    fn EndQuery();
    fn ResolveQueryData();
    fn SetPredication();
    fn SetMarker();
    fn BeginEvent();
    fn EndEvent();
    fn DecodeFrame();
    fn WriteBufferImmediate();
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::RuntimeName for ID3D12VideoDecodeCommandList {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoDecodeCommandList";
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoDecodeCommandListVtbl {
    pub const fn new<Impl: ID3D12VideoDecodeCommandListImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoDecodeCommandListVtbl {
        unsafe extern "system" fn Close<Impl: ID3D12VideoDecodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Close() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Reset<Impl: ID3D12VideoDecodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pallocator: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reset(&*(&pallocator as *const <super::super::Graphics::Direct3D12::ID3D12CommandAllocator as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12CommandAllocator as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ClearState<Impl: ID3D12VideoDecodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).ClearState().into()
        }
        unsafe extern "system" fn ResourceBarrier<Impl: ID3D12VideoDecodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, numbarriers: u32, pbarriers: *const super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).ResourceBarrier(numbarriers, &*(&pbarriers as *const <super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DiscardResource<Impl: ID3D12VideoDecodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presource: ::windows::core::RawPtr, pregion: *const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).DiscardResource(&*(&presource as *const <super::super::Graphics::Direct3D12::ID3D12Resource as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12Resource as ::windows::core::DefaultType>::DefaultType), &*(&pregion as *const <super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BeginQuery<Impl: ID3D12VideoDecodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pqueryheap: ::windows::core::RawPtr, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).BeginQuery(&*(&pqueryheap as *const <super::super::Graphics::Direct3D12::ID3D12QueryHeap as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12QueryHeap as ::windows::core::DefaultType>::DefaultType), r#type, index).into()
        }
        unsafe extern "system" fn EndQuery<Impl: ID3D12VideoDecodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pqueryheap: ::windows::core::RawPtr, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).EndQuery(&*(&pqueryheap as *const <super::super::Graphics::Direct3D12::ID3D12QueryHeap as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12QueryHeap as ::windows::core::DefaultType>::DefaultType), r#type, index).into()
        }
        unsafe extern "system" fn ResolveQueryData<Impl: ID3D12VideoDecodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pqueryheap: ::windows::core::RawPtr, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: ::windows::core::RawPtr, aligneddestinationbufferoffset: u64) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this)
                .ResolveQueryData(
                    &*(&pqueryheap as *const <super::super::Graphics::Direct3D12::ID3D12QueryHeap as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12QueryHeap as ::windows::core::DefaultType>::DefaultType),
                    r#type,
                    startindex,
                    numqueries,
                    &*(&pdestinationbuffer as *const <super::super::Graphics::Direct3D12::ID3D12Resource as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12Resource as ::windows::core::DefaultType>::DefaultType),
                    aligneddestinationbufferoffset,
                )
                .into()
        }
        unsafe extern "system" fn SetPredication<Impl: ID3D12VideoDecodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbuffer: ::windows::core::RawPtr, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPredication(&*(&pbuffer as *const <super::super::Graphics::Direct3D12::ID3D12Resource as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12Resource as ::windows::core::DefaultType>::DefaultType), alignedbufferoffset, operation).into()
        }
        unsafe extern "system" fn SetMarker<Impl: ID3D12VideoDecodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMarker(metadata, &*(&pdata as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType), size).into()
        }
        unsafe extern "system" fn BeginEvent<Impl: ID3D12VideoDecodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).BeginEvent(metadata, &*(&pdata as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType), size).into()
        }
        unsafe extern "system" fn EndEvent<Impl: ID3D12VideoDecodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).EndEvent().into()
        }
        unsafe extern "system" fn DecodeFrame<Impl: ID3D12VideoDecodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdecoder: ::windows::core::RawPtr, poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS, pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this)
                .DecodeFrame(
                    &*(&pdecoder as *const <ID3D12VideoDecoder as ::windows::core::Abi>::Abi as *const <ID3D12VideoDecoder as ::windows::core::DefaultType>::DefaultType),
                    &*(&poutputarguments as *const <D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS as ::windows::core::DefaultType>::DefaultType),
                    &*(&pinputarguments as *const <D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS as ::windows::core::DefaultType>::DefaultType),
                )
                .into()
        }
        unsafe extern "system" fn WriteBufferImmediate<Impl: ID3D12VideoDecodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).WriteBufferImmediate(count, &*(&pparams as *const <super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER as ::windows::core::DefaultType>::DefaultType), pmodes).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ID3D12VideoDecodeCommandList>,
            base.5,
            Close::<Impl, OFFSET>,
            Reset::<Impl, OFFSET>,
            ClearState::<Impl, OFFSET>,
            ResourceBarrier::<Impl, OFFSET>,
            DiscardResource::<Impl, OFFSET>,
            BeginQuery::<Impl, OFFSET>,
            EndQuery::<Impl, OFFSET>,
            ResolveQueryData::<Impl, OFFSET>,
            SetPredication::<Impl, OFFSET>,
            SetMarker::<Impl, OFFSET>,
            BeginEvent::<Impl, OFFSET>,
            EndEvent::<Impl, OFFSET>,
            DecodeFrame::<Impl, OFFSET>,
            WriteBufferImmediate::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoDecodeCommandList1Impl: Sized + ID3D12VideoDecodeCommandListImpl + ID3D12CommandListImpl + ID3D12DeviceChildImpl + ID3D12ObjectImpl {
    fn DecodeFrame1();
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::RuntimeName for ID3D12VideoDecodeCommandList1 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoDecodeCommandList1";
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoDecodeCommandList1Vtbl {
    pub const fn new<Impl: ID3D12VideoDecodeCommandList1Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoDecodeCommandList1Vtbl {
        unsafe extern "system" fn DecodeFrame1<Impl: ID3D12VideoDecodeCommandList1Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdecoder: ::windows::core::RawPtr, poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1, pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this)
                .DecodeFrame1(
                    &*(&pdecoder as *const <ID3D12VideoDecoder as ::windows::core::Abi>::Abi as *const <ID3D12VideoDecoder as ::windows::core::DefaultType>::DefaultType),
                    &*(&poutputarguments as *const <D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1 as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1 as ::windows::core::DefaultType>::DefaultType),
                    &*(&pinputarguments as *const <D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS as ::windows::core::DefaultType>::DefaultType),
                )
                .into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ID3D12VideoDecodeCommandList1>, base.5, DecodeFrame1::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoDecodeCommandList2Impl: Sized + ID3D12VideoDecodeCommandList1Impl + ID3D12VideoDecodeCommandListImpl + ID3D12CommandListImpl + ID3D12DeviceChildImpl + ID3D12ObjectImpl {
    fn SetProtectedResourceSession();
    fn InitializeExtensionCommand();
    fn ExecuteExtensionCommand();
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::RuntimeName for ID3D12VideoDecodeCommandList2 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoDecodeCommandList2";
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoDecodeCommandList2Vtbl {
    pub const fn new<Impl: ID3D12VideoDecodeCommandList2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoDecodeCommandList2Vtbl {
        unsafe extern "system" fn SetProtectedResourceSession<Impl: ID3D12VideoDecodeCommandList2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pprotectedresourcesession: ::windows::core::RawPtr) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetProtectedResourceSession(&*(&pprotectedresourcesession as *const <super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn InitializeExtensionCommand<Impl: ID3D12VideoDecodeCommandList2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pextensioncommand: ::windows::core::RawPtr, pinitializationparameters: *const ::core::ffi::c_void, initializationparameterssizeinbytes: usize) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).InitializeExtensionCommand(&*(&pextensioncommand as *const <ID3D12VideoExtensionCommand as ::windows::core::Abi>::Abi as *const <ID3D12VideoExtensionCommand as ::windows::core::DefaultType>::DefaultType), &*(&pinitializationparameters as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType), initializationparameterssizeinbytes).into()
        }
        unsafe extern "system" fn ExecuteExtensionCommand<Impl: ID3D12VideoDecodeCommandList2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pextensioncommand: ::windows::core::RawPtr, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).ExecuteExtensionCommand(&*(&pextensioncommand as *const <ID3D12VideoExtensionCommand as ::windows::core::Abi>::Abi as *const <ID3D12VideoExtensionCommand as ::windows::core::DefaultType>::DefaultType), &*(&pexecutionparameters as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType), executionparameterssizeinbytes).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ID3D12VideoDecodeCommandList2>, base.5, SetProtectedResourceSession::<Impl, OFFSET>, InitializeExtensionCommand::<Impl, OFFSET>, ExecuteExtensionCommand::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoDecoderImpl: Sized + ID3D12PageableImpl + ID3D12DeviceChildImpl + ID3D12ObjectImpl {
    fn GetDesc();
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::RuntimeName for ID3D12VideoDecoder {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoDecoder";
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoDecoderVtbl {
    pub const fn new<Impl: ID3D12VideoDecoderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoDecoderVtbl {
        unsafe extern "system" fn GetDesc<Impl: ID3D12VideoDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut D3D12_VIDEO_DECODER_DESC) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDesc() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ID3D12VideoDecoder>, base.5, GetDesc::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoDecoder1Impl: Sized + ID3D12VideoDecoderImpl + ID3D12PageableImpl + ID3D12DeviceChildImpl + ID3D12ObjectImpl {
    fn GetProtectedResourceSession();
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::RuntimeName for ID3D12VideoDecoder1 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoDecoder1";
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoDecoder1Vtbl {
    pub const fn new<Impl: ID3D12VideoDecoder1Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoDecoder1Vtbl {
        unsafe extern "system" fn GetProtectedResourceSession<Impl: ID3D12VideoDecoder1Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProtectedResourceSession(&*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppprotectedsession)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ID3D12VideoDecoder1>, base.5, GetProtectedResourceSession::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoDecoderHeapImpl: Sized + ID3D12PageableImpl + ID3D12DeviceChildImpl + ID3D12ObjectImpl {
    fn GetDesc();
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::RuntimeName for ID3D12VideoDecoderHeap {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoDecoderHeap";
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoDecoderHeapVtbl {
    pub const fn new<Impl: ID3D12VideoDecoderHeapImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoDecoderHeapVtbl {
        unsafe extern "system" fn GetDesc<Impl: ID3D12VideoDecoderHeapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut D3D12_VIDEO_DECODER_HEAP_DESC) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDesc() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ID3D12VideoDecoderHeap>, base.5, GetDesc::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoDecoderHeap1Impl: Sized + ID3D12VideoDecoderHeapImpl + ID3D12PageableImpl + ID3D12DeviceChildImpl + ID3D12ObjectImpl {
    fn GetProtectedResourceSession();
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::RuntimeName for ID3D12VideoDecoderHeap1 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoDecoderHeap1";
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoDecoderHeap1Vtbl {
    pub const fn new<Impl: ID3D12VideoDecoderHeap1Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoDecoderHeap1Vtbl {
        unsafe extern "system" fn GetProtectedResourceSession<Impl: ID3D12VideoDecoderHeap1Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProtectedResourceSession(&*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppprotectedsession)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ID3D12VideoDecoderHeap1>, base.5, GetProtectedResourceSession::<Impl, OFFSET>)
    }
}
pub trait ID3D12VideoDeviceImpl: Sized {
    fn CheckFeatureSupport();
    fn CreateVideoDecoder();
    fn CreateVideoDecoderHeap();
    fn CreateVideoProcessor();
}
impl ::windows::core::RuntimeName for ID3D12VideoDevice {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoDevice";
}
impl ID3D12VideoDeviceVtbl {
    pub const fn new<Impl: ID3D12VideoDeviceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoDeviceVtbl {
        unsafe extern "system" fn CheckFeatureSupport<Impl: ID3D12VideoDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, featurevideo: D3D12_FEATURE_VIDEO, pfeaturesupportdata: *mut ::core::ffi::c_void, featuresupportdatasize: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CheckFeatureSupport(featurevideo, &*(&pfeaturesupportdata as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType), featuresupportdatasize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateVideoDecoder<Impl: ID3D12VideoDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdesc: *const D3D12_VIDEO_DECODER_DESC, riid: *const ::windows::core::GUID, ppvideodecoder: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateVideoDecoder(&*(&pdesc as *const <D3D12_VIDEO_DECODER_DESC as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_DECODER_DESC as ::windows::core::DefaultType>::DefaultType), &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppvideodecoder)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateVideoDecoderHeap<Impl: ID3D12VideoDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC, riid: *const ::windows::core::GUID, ppvideodecoderheap: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateVideoDecoderHeap(&*(&pvideodecoderheapdesc as *const <D3D12_VIDEO_DECODER_HEAP_DESC as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_DECODER_HEAP_DESC as ::windows::core::DefaultType>::DefaultType), &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppvideodecoderheap)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateVideoProcessor<Impl: ID3D12VideoDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, nodemask: u32, poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC, numinputstreamdescs: u32, pinputstreamdescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC, riid: *const ::windows::core::GUID, ppvideoprocessor: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateVideoProcessor(
                nodemask,
                &*(&poutputstreamdesc as *const <D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC as ::windows::core::DefaultType>::DefaultType),
                numinputstreamdescs,
                &*(&pinputstreamdescs as *const <D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC as ::windows::core::DefaultType>::DefaultType),
                &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&ppvideoprocessor),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ID3D12VideoDevice>, base.5, CheckFeatureSupport::<Impl, OFFSET>, CreateVideoDecoder::<Impl, OFFSET>, CreateVideoDecoderHeap::<Impl, OFFSET>, CreateVideoProcessor::<Impl, OFFSET>)
    }
}
pub trait ID3D12VideoDevice1Impl: Sized + ID3D12VideoDeviceImpl {
    fn CreateVideoMotionEstimator();
    fn CreateVideoMotionVectorHeap();
}
impl ::windows::core::RuntimeName for ID3D12VideoDevice1 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoDevice1";
}
impl ID3D12VideoDevice1Vtbl {
    pub const fn new<Impl: ID3D12VideoDevice1Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoDevice1Vtbl {
        unsafe extern "system" fn CreateVideoMotionEstimator<Impl: ID3D12VideoDevice1Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdesc: *const D3D12_VIDEO_MOTION_ESTIMATOR_DESC, pprotectedresourcesession: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppvideomotionestimator: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateVideoMotionEstimator(
                &*(&pdesc as *const <D3D12_VIDEO_MOTION_ESTIMATOR_DESC as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_MOTION_ESTIMATOR_DESC as ::windows::core::DefaultType>::DefaultType),
                &*(&pprotectedresourcesession as *const <super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession as ::windows::core::DefaultType>::DefaultType),
                &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&ppvideomotionestimator),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateVideoMotionVectorHeap<Impl: ID3D12VideoDevice1Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdesc: *const D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC, pprotectedresourcesession: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppvideomotionvectorheap: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateVideoMotionVectorHeap(
                &*(&pdesc as *const <D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC as ::windows::core::DefaultType>::DefaultType),
                &*(&pprotectedresourcesession as *const <super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession as ::windows::core::DefaultType>::DefaultType),
                &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&ppvideomotionvectorheap),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ID3D12VideoDevice1>, base.5, CreateVideoMotionEstimator::<Impl, OFFSET>, CreateVideoMotionVectorHeap::<Impl, OFFSET>)
    }
}
pub trait ID3D12VideoDevice2Impl: Sized + ID3D12VideoDevice1Impl + ID3D12VideoDeviceImpl {
    fn CreateVideoDecoder1();
    fn CreateVideoDecoderHeap1();
    fn CreateVideoProcessor1();
    fn CreateVideoExtensionCommand();
    fn ExecuteExtensionCommand();
}
impl ::windows::core::RuntimeName for ID3D12VideoDevice2 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoDevice2";
}
impl ID3D12VideoDevice2Vtbl {
    pub const fn new<Impl: ID3D12VideoDevice2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoDevice2Vtbl {
        unsafe extern "system" fn CreateVideoDecoder1<Impl: ID3D12VideoDevice2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdesc: *const D3D12_VIDEO_DECODER_DESC, pprotectedresourcesession: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppvideodecoder: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateVideoDecoder1(
                &*(&pdesc as *const <D3D12_VIDEO_DECODER_DESC as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_DECODER_DESC as ::windows::core::DefaultType>::DefaultType),
                &*(&pprotectedresourcesession as *const <super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession as ::windows::core::DefaultType>::DefaultType),
                &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&ppvideodecoder),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateVideoDecoderHeap1<Impl: ID3D12VideoDevice2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC, pprotectedresourcesession: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppvideodecoderheap: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateVideoDecoderHeap1(
                &*(&pvideodecoderheapdesc as *const <D3D12_VIDEO_DECODER_HEAP_DESC as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_DECODER_HEAP_DESC as ::windows::core::DefaultType>::DefaultType),
                &*(&pprotectedresourcesession as *const <super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession as ::windows::core::DefaultType>::DefaultType),
                &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&ppvideodecoderheap),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateVideoProcessor1<Impl: ID3D12VideoDevice2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, nodemask: u32, poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC, numinputstreamdescs: u32, pinputstreamdescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC, pprotectedresourcesession: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppvideoprocessor: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateVideoProcessor1(
                nodemask,
                &*(&poutputstreamdesc as *const <D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC as ::windows::core::DefaultType>::DefaultType),
                numinputstreamdescs,
                &*(&pinputstreamdescs as *const <D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC as ::windows::core::DefaultType>::DefaultType),
                &*(&pprotectedresourcesession as *const <super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession as ::windows::core::DefaultType>::DefaultType),
                &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&ppvideoprocessor),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateVideoExtensionCommand<Impl: ID3D12VideoDevice2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdesc: *const D3D12_VIDEO_EXTENSION_COMMAND_DESC, pcreationparameters: *const ::core::ffi::c_void, creationparametersdatasizeinbytes: usize, pprotectedresourcesession: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppvideoextensioncommand: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateVideoExtensionCommand(
                &*(&pdesc as *const <D3D12_VIDEO_EXTENSION_COMMAND_DESC as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_EXTENSION_COMMAND_DESC as ::windows::core::DefaultType>::DefaultType),
                &*(&pcreationparameters as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType),
                creationparametersdatasizeinbytes,
                &*(&pprotectedresourcesession as *const <super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession as ::windows::core::DefaultType>::DefaultType),
                &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&ppvideoextensioncommand),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ExecuteExtensionCommand<Impl: ID3D12VideoDevice2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pextensioncommand: ::windows::core::RawPtr, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize, poutputdata: *mut ::core::ffi::c_void, outputdatasizeinbytes: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ExecuteExtensionCommand(&*(&pextensioncommand as *const <ID3D12VideoExtensionCommand as ::windows::core::Abi>::Abi as *const <ID3D12VideoExtensionCommand as ::windows::core::DefaultType>::DefaultType), &*(&pexecutionparameters as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType), executionparameterssizeinbytes, ::core::mem::transmute_copy(&poutputdata), outputdatasizeinbytes) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ID3D12VideoDevice2>, base.5, CreateVideoDecoder1::<Impl, OFFSET>, CreateVideoDecoderHeap1::<Impl, OFFSET>, CreateVideoProcessor1::<Impl, OFFSET>, CreateVideoExtensionCommand::<Impl, OFFSET>, ExecuteExtensionCommand::<Impl, OFFSET>)
    }
}
pub trait ID3D12VideoDevice3Impl: Sized + ID3D12VideoDevice2Impl + ID3D12VideoDevice1Impl + ID3D12VideoDeviceImpl {
    fn CreateVideoEncoder();
    fn CreateVideoEncoderHeap();
}
impl ::windows::core::RuntimeName for ID3D12VideoDevice3 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoDevice3";
}
impl ID3D12VideoDevice3Vtbl {
    pub const fn new<Impl: ID3D12VideoDevice3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoDevice3Vtbl {
        unsafe extern "system" fn CreateVideoEncoder<Impl: ID3D12VideoDevice3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdesc: *const D3D12_VIDEO_ENCODER_DESC, riid: *const ::windows::core::GUID, ppvideoencoder: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateVideoEncoder(&*(&pdesc as *const <D3D12_VIDEO_ENCODER_DESC as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_ENCODER_DESC as ::windows::core::DefaultType>::DefaultType), &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppvideoencoder)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateVideoEncoderHeap<Impl: ID3D12VideoDevice3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdesc: *const D3D12_VIDEO_ENCODER_HEAP_DESC, riid: *const ::windows::core::GUID, ppvideoencoderheap: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateVideoEncoderHeap(&*(&pdesc as *const <D3D12_VIDEO_ENCODER_HEAP_DESC as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_ENCODER_HEAP_DESC as ::windows::core::DefaultType>::DefaultType), &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppvideoencoderheap)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ID3D12VideoDevice3>, base.5, CreateVideoEncoder::<Impl, OFFSET>, CreateVideoEncoderHeap::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoEncodeCommandListImpl: Sized + ID3D12CommandListImpl + ID3D12DeviceChildImpl + ID3D12ObjectImpl {
    fn Close();
    fn Reset();
    fn ClearState();
    fn ResourceBarrier();
    fn DiscardResource();
    fn BeginQuery();
    fn EndQuery();
    fn ResolveQueryData();
    fn SetPredication();
    fn SetMarker();
    fn BeginEvent();
    fn EndEvent();
    fn EstimateMotion();
    fn ResolveMotionVectorHeap();
    fn WriteBufferImmediate();
    fn SetProtectedResourceSession();
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::RuntimeName for ID3D12VideoEncodeCommandList {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoEncodeCommandList";
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoEncodeCommandListVtbl {
    pub const fn new<Impl: ID3D12VideoEncodeCommandListImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoEncodeCommandListVtbl {
        unsafe extern "system" fn Close<Impl: ID3D12VideoEncodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Close() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Reset<Impl: ID3D12VideoEncodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pallocator: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reset(&*(&pallocator as *const <super::super::Graphics::Direct3D12::ID3D12CommandAllocator as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12CommandAllocator as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ClearState<Impl: ID3D12VideoEncodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).ClearState().into()
        }
        unsafe extern "system" fn ResourceBarrier<Impl: ID3D12VideoEncodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, numbarriers: u32, pbarriers: *const super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).ResourceBarrier(numbarriers, &*(&pbarriers as *const <super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DiscardResource<Impl: ID3D12VideoEncodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presource: ::windows::core::RawPtr, pregion: *const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).DiscardResource(&*(&presource as *const <super::super::Graphics::Direct3D12::ID3D12Resource as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12Resource as ::windows::core::DefaultType>::DefaultType), &*(&pregion as *const <super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BeginQuery<Impl: ID3D12VideoEncodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pqueryheap: ::windows::core::RawPtr, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).BeginQuery(&*(&pqueryheap as *const <super::super::Graphics::Direct3D12::ID3D12QueryHeap as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12QueryHeap as ::windows::core::DefaultType>::DefaultType), r#type, index).into()
        }
        unsafe extern "system" fn EndQuery<Impl: ID3D12VideoEncodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pqueryheap: ::windows::core::RawPtr, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).EndQuery(&*(&pqueryheap as *const <super::super::Graphics::Direct3D12::ID3D12QueryHeap as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12QueryHeap as ::windows::core::DefaultType>::DefaultType), r#type, index).into()
        }
        unsafe extern "system" fn ResolveQueryData<Impl: ID3D12VideoEncodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pqueryheap: ::windows::core::RawPtr, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: ::windows::core::RawPtr, aligneddestinationbufferoffset: u64) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this)
                .ResolveQueryData(
                    &*(&pqueryheap as *const <super::super::Graphics::Direct3D12::ID3D12QueryHeap as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12QueryHeap as ::windows::core::DefaultType>::DefaultType),
                    r#type,
                    startindex,
                    numqueries,
                    &*(&pdestinationbuffer as *const <super::super::Graphics::Direct3D12::ID3D12Resource as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12Resource as ::windows::core::DefaultType>::DefaultType),
                    aligneddestinationbufferoffset,
                )
                .into()
        }
        unsafe extern "system" fn SetPredication<Impl: ID3D12VideoEncodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbuffer: ::windows::core::RawPtr, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPredication(&*(&pbuffer as *const <super::super::Graphics::Direct3D12::ID3D12Resource as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12Resource as ::windows::core::DefaultType>::DefaultType), alignedbufferoffset, operation).into()
        }
        unsafe extern "system" fn SetMarker<Impl: ID3D12VideoEncodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMarker(metadata, &*(&pdata as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType), size).into()
        }
        unsafe extern "system" fn BeginEvent<Impl: ID3D12VideoEncodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).BeginEvent(metadata, &*(&pdata as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType), size).into()
        }
        unsafe extern "system" fn EndEvent<Impl: ID3D12VideoEncodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).EndEvent().into()
        }
        unsafe extern "system" fn EstimateMotion<Impl: ID3D12VideoEncodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmotionestimator: ::windows::core::RawPtr, poutputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT, pinputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this)
                .EstimateMotion(
                    &*(&pmotionestimator as *const <ID3D12VideoMotionEstimator as ::windows::core::Abi>::Abi as *const <ID3D12VideoMotionEstimator as ::windows::core::DefaultType>::DefaultType),
                    &*(&poutputarguments as *const <D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT as ::windows::core::DefaultType>::DefaultType),
                    &*(&pinputarguments as *const <D3D12_VIDEO_MOTION_ESTIMATOR_INPUT as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_MOTION_ESTIMATOR_INPUT as ::windows::core::DefaultType>::DefaultType),
                )
                .into()
        }
        unsafe extern "system" fn ResolveMotionVectorHeap<Impl: ID3D12VideoEncodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, poutputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT, pinputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).ResolveMotionVectorHeap(&*(&poutputarguments as *const <D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT as ::windows::core::Abi>::Abi as *const <D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT as ::windows::core::DefaultType>::DefaultType), &*(&pinputarguments as *const <D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT as ::windows::core::Abi>::Abi as *const <D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn WriteBufferImmediate<Impl: ID3D12VideoEncodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).WriteBufferImmediate(count, &*(&pparams as *const <super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER as ::windows::core::DefaultType>::DefaultType), pmodes).into()
        }
        unsafe extern "system" fn SetProtectedResourceSession<Impl: ID3D12VideoEncodeCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pprotectedresourcesession: ::windows::core::RawPtr) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetProtectedResourceSession(&*(&pprotectedresourcesession as *const <super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ID3D12VideoEncodeCommandList>,
            base.5,
            Close::<Impl, OFFSET>,
            Reset::<Impl, OFFSET>,
            ClearState::<Impl, OFFSET>,
            ResourceBarrier::<Impl, OFFSET>,
            DiscardResource::<Impl, OFFSET>,
            BeginQuery::<Impl, OFFSET>,
            EndQuery::<Impl, OFFSET>,
            ResolveQueryData::<Impl, OFFSET>,
            SetPredication::<Impl, OFFSET>,
            SetMarker::<Impl, OFFSET>,
            BeginEvent::<Impl, OFFSET>,
            EndEvent::<Impl, OFFSET>,
            EstimateMotion::<Impl, OFFSET>,
            ResolveMotionVectorHeap::<Impl, OFFSET>,
            WriteBufferImmediate::<Impl, OFFSET>,
            SetProtectedResourceSession::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoEncodeCommandList1Impl: Sized + ID3D12VideoEncodeCommandListImpl + ID3D12CommandListImpl + ID3D12DeviceChildImpl + ID3D12ObjectImpl {
    fn InitializeExtensionCommand();
    fn ExecuteExtensionCommand();
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::RuntimeName for ID3D12VideoEncodeCommandList1 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoEncodeCommandList1";
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoEncodeCommandList1Vtbl {
    pub const fn new<Impl: ID3D12VideoEncodeCommandList1Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoEncodeCommandList1Vtbl {
        unsafe extern "system" fn InitializeExtensionCommand<Impl: ID3D12VideoEncodeCommandList1Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pextensioncommand: ::windows::core::RawPtr, pinitializationparameters: *const ::core::ffi::c_void, initializationparameterssizeinbytes: usize) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).InitializeExtensionCommand(&*(&pextensioncommand as *const <ID3D12VideoExtensionCommand as ::windows::core::Abi>::Abi as *const <ID3D12VideoExtensionCommand as ::windows::core::DefaultType>::DefaultType), &*(&pinitializationparameters as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType), initializationparameterssizeinbytes).into()
        }
        unsafe extern "system" fn ExecuteExtensionCommand<Impl: ID3D12VideoEncodeCommandList1Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pextensioncommand: ::windows::core::RawPtr, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).ExecuteExtensionCommand(&*(&pextensioncommand as *const <ID3D12VideoExtensionCommand as ::windows::core::Abi>::Abi as *const <ID3D12VideoExtensionCommand as ::windows::core::DefaultType>::DefaultType), &*(&pexecutionparameters as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType), executionparameterssizeinbytes).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ID3D12VideoEncodeCommandList1>, base.5, InitializeExtensionCommand::<Impl, OFFSET>, ExecuteExtensionCommand::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoEncodeCommandList2Impl: Sized + ID3D12VideoEncodeCommandList1Impl + ID3D12VideoEncodeCommandListImpl + ID3D12CommandListImpl + ID3D12DeviceChildImpl + ID3D12ObjectImpl {
    fn EncodeFrame();
    fn ResolveEncoderOutputMetadata();
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::RuntimeName for ID3D12VideoEncodeCommandList2 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoEncodeCommandList2";
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoEncodeCommandList2Vtbl {
    pub const fn new<Impl: ID3D12VideoEncodeCommandList2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoEncodeCommandList2Vtbl {
        unsafe extern "system" fn EncodeFrame<Impl: ID3D12VideoEncodeCommandList2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pencoder: ::windows::core::RawPtr, pheap: ::windows::core::RawPtr, pinputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS, poutputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this)
                .EncodeFrame(
                    &*(&pencoder as *const <ID3D12VideoEncoder as ::windows::core::Abi>::Abi as *const <ID3D12VideoEncoder as ::windows::core::DefaultType>::DefaultType),
                    &*(&pheap as *const <ID3D12VideoEncoderHeap as ::windows::core::Abi>::Abi as *const <ID3D12VideoEncoderHeap as ::windows::core::DefaultType>::DefaultType),
                    &*(&pinputarguments as *const <D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS as ::windows::core::DefaultType>::DefaultType),
                    &*(&poutputarguments as *const <D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS as ::windows::core::DefaultType>::DefaultType),
                )
                .into()
        }
        unsafe extern "system" fn ResolveEncoderOutputMetadata<Impl: ID3D12VideoEncodeCommandList2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pinputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS, poutputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this)
                .ResolveEncoderOutputMetadata(&*(&pinputarguments as *const <D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS as ::windows::core::DefaultType>::DefaultType), &*(&poutputarguments as *const <D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS as ::windows::core::DefaultType>::DefaultType))
                .into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ID3D12VideoEncodeCommandList2>, base.5, EncodeFrame::<Impl, OFFSET>, ResolveEncoderOutputMetadata::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoEncoderImpl: Sized + ID3D12PageableImpl + ID3D12DeviceChildImpl + ID3D12ObjectImpl {
    fn GetNodeMask();
    fn GetEncoderFlags();
    fn GetCodec();
    fn GetCodecProfile();
    fn GetCodecConfiguration();
    fn GetInputFormat();
    fn GetMaxMotionEstimationPrecision();
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::RuntimeName for ID3D12VideoEncoder {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoEncoder";
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoEncoderVtbl {
    pub const fn new<Impl: ID3D12VideoEncoderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoEncoderVtbl {
        unsafe extern "system" fn GetNodeMask<Impl: ID3D12VideoEncoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNodeMask() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEncoderFlags<Impl: ID3D12VideoEncoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> D3D12_VIDEO_ENCODER_FLAGS {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEncoderFlags() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCodec<Impl: ID3D12VideoEncoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> D3D12_VIDEO_ENCODER_CODEC {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCodec() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCodecProfile<Impl: ID3D12VideoEncoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dstprofile: D3D12_VIDEO_ENCODER_PROFILE_DESC) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCodecProfile(::core::mem::transmute_copy(&dstprofile)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCodecConfiguration<Impl: ID3D12VideoEncoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dstcodecconfig: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCodecConfiguration(::core::mem::transmute_copy(&dstcodecconfig)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInputFormat<Impl: ID3D12VideoEncoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> super::super::Graphics::Dxgi::Common::DXGI_FORMAT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInputFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMaxMotionEstimationPrecision<Impl: ID3D12VideoEncoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMaxMotionEstimationPrecision() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ID3D12VideoEncoder>, base.5, GetNodeMask::<Impl, OFFSET>, GetEncoderFlags::<Impl, OFFSET>, GetCodec::<Impl, OFFSET>, GetCodecProfile::<Impl, OFFSET>, GetCodecConfiguration::<Impl, OFFSET>, GetInputFormat::<Impl, OFFSET>, GetMaxMotionEstimationPrecision::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoEncoderHeapImpl: Sized + ID3D12PageableImpl + ID3D12DeviceChildImpl + ID3D12ObjectImpl {
    fn GetNodeMask();
    fn GetEncoderHeapFlags();
    fn GetCodec();
    fn GetCodecProfile();
    fn GetCodecLevel();
    fn GetResolutionListCount();
    fn GetResolutionList();
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::RuntimeName for ID3D12VideoEncoderHeap {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoEncoderHeap";
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoEncoderHeapVtbl {
    pub const fn new<Impl: ID3D12VideoEncoderHeapImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoEncoderHeapVtbl {
        unsafe extern "system" fn GetNodeMask<Impl: ID3D12VideoEncoderHeapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNodeMask() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEncoderHeapFlags<Impl: ID3D12VideoEncoderHeapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> D3D12_VIDEO_ENCODER_HEAP_FLAGS {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEncoderHeapFlags() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCodec<Impl: ID3D12VideoEncoderHeapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> D3D12_VIDEO_ENCODER_CODEC {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCodec() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCodecProfile<Impl: ID3D12VideoEncoderHeapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dstprofile: D3D12_VIDEO_ENCODER_PROFILE_DESC) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCodecProfile(::core::mem::transmute_copy(&dstprofile)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCodecLevel<Impl: ID3D12VideoEncoderHeapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dstlevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCodecLevel(::core::mem::transmute_copy(&dstlevel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetResolutionListCount<Impl: ID3D12VideoEncoderHeapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetResolutionListCount() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetResolutionList<Impl: ID3D12VideoEncoderHeapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, resolutionslistcount: u32, presolutionlist: *mut D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetResolutionList(resolutionslistcount, ::core::mem::transmute_copy(&presolutionlist)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ID3D12VideoEncoderHeap>, base.5, GetNodeMask::<Impl, OFFSET>, GetEncoderHeapFlags::<Impl, OFFSET>, GetCodec::<Impl, OFFSET>, GetCodecProfile::<Impl, OFFSET>, GetCodecLevel::<Impl, OFFSET>, GetResolutionListCount::<Impl, OFFSET>, GetResolutionList::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoExtensionCommandImpl: Sized + ID3D12PageableImpl + ID3D12DeviceChildImpl + ID3D12ObjectImpl {
    fn GetDesc();
    fn GetProtectedResourceSession();
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::RuntimeName for ID3D12VideoExtensionCommand {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoExtensionCommand";
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoExtensionCommandVtbl {
    pub const fn new<Impl: ID3D12VideoExtensionCommandImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoExtensionCommandVtbl {
        unsafe extern "system" fn GetDesc<Impl: ID3D12VideoExtensionCommandImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut D3D12_VIDEO_EXTENSION_COMMAND_DESC) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDesc() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProtectedResourceSession<Impl: ID3D12VideoExtensionCommandImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProtectedResourceSession(&*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppprotectedsession)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ID3D12VideoExtensionCommand>, base.5, GetDesc::<Impl, OFFSET>, GetProtectedResourceSession::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoMotionEstimatorImpl: Sized + ID3D12PageableImpl + ID3D12DeviceChildImpl + ID3D12ObjectImpl {
    fn GetDesc();
    fn GetProtectedResourceSession();
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::RuntimeName for ID3D12VideoMotionEstimator {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoMotionEstimator";
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoMotionEstimatorVtbl {
    pub const fn new<Impl: ID3D12VideoMotionEstimatorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoMotionEstimatorVtbl {
        unsafe extern "system" fn GetDesc<Impl: ID3D12VideoMotionEstimatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut D3D12_VIDEO_MOTION_ESTIMATOR_DESC) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDesc() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProtectedResourceSession<Impl: ID3D12VideoMotionEstimatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProtectedResourceSession(&*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppprotectedsession)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ID3D12VideoMotionEstimator>, base.5, GetDesc::<Impl, OFFSET>, GetProtectedResourceSession::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoMotionVectorHeapImpl: Sized + ID3D12PageableImpl + ID3D12DeviceChildImpl + ID3D12ObjectImpl {
    fn GetDesc();
    fn GetProtectedResourceSession();
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::RuntimeName for ID3D12VideoMotionVectorHeap {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoMotionVectorHeap";
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoMotionVectorHeapVtbl {
    pub const fn new<Impl: ID3D12VideoMotionVectorHeapImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoMotionVectorHeapVtbl {
        unsafe extern "system" fn GetDesc<Impl: ID3D12VideoMotionVectorHeapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDesc() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProtectedResourceSession<Impl: ID3D12VideoMotionVectorHeapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProtectedResourceSession(&*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppprotectedsession)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ID3D12VideoMotionVectorHeap>, base.5, GetDesc::<Impl, OFFSET>, GetProtectedResourceSession::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoProcessCommandListImpl: Sized + ID3D12CommandListImpl + ID3D12DeviceChildImpl + ID3D12ObjectImpl {
    fn Close();
    fn Reset();
    fn ClearState();
    fn ResourceBarrier();
    fn DiscardResource();
    fn BeginQuery();
    fn EndQuery();
    fn ResolveQueryData();
    fn SetPredication();
    fn SetMarker();
    fn BeginEvent();
    fn EndEvent();
    fn ProcessFrames();
    fn WriteBufferImmediate();
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::RuntimeName for ID3D12VideoProcessCommandList {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoProcessCommandList";
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoProcessCommandListVtbl {
    pub const fn new<Impl: ID3D12VideoProcessCommandListImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoProcessCommandListVtbl {
        unsafe extern "system" fn Close<Impl: ID3D12VideoProcessCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Close() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Reset<Impl: ID3D12VideoProcessCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pallocator: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reset(&*(&pallocator as *const <super::super::Graphics::Direct3D12::ID3D12CommandAllocator as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12CommandAllocator as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ClearState<Impl: ID3D12VideoProcessCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).ClearState().into()
        }
        unsafe extern "system" fn ResourceBarrier<Impl: ID3D12VideoProcessCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, numbarriers: u32, pbarriers: *const super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).ResourceBarrier(numbarriers, &*(&pbarriers as *const <super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn DiscardResource<Impl: ID3D12VideoProcessCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presource: ::windows::core::RawPtr, pregion: *const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).DiscardResource(&*(&presource as *const <super::super::Graphics::Direct3D12::ID3D12Resource as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12Resource as ::windows::core::DefaultType>::DefaultType), &*(&pregion as *const <super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn BeginQuery<Impl: ID3D12VideoProcessCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pqueryheap: ::windows::core::RawPtr, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).BeginQuery(&*(&pqueryheap as *const <super::super::Graphics::Direct3D12::ID3D12QueryHeap as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12QueryHeap as ::windows::core::DefaultType>::DefaultType), r#type, index).into()
        }
        unsafe extern "system" fn EndQuery<Impl: ID3D12VideoProcessCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pqueryheap: ::windows::core::RawPtr, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).EndQuery(&*(&pqueryheap as *const <super::super::Graphics::Direct3D12::ID3D12QueryHeap as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12QueryHeap as ::windows::core::DefaultType>::DefaultType), r#type, index).into()
        }
        unsafe extern "system" fn ResolveQueryData<Impl: ID3D12VideoProcessCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pqueryheap: ::windows::core::RawPtr, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: ::windows::core::RawPtr, aligneddestinationbufferoffset: u64) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this)
                .ResolveQueryData(
                    &*(&pqueryheap as *const <super::super::Graphics::Direct3D12::ID3D12QueryHeap as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12QueryHeap as ::windows::core::DefaultType>::DefaultType),
                    r#type,
                    startindex,
                    numqueries,
                    &*(&pdestinationbuffer as *const <super::super::Graphics::Direct3D12::ID3D12Resource as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12Resource as ::windows::core::DefaultType>::DefaultType),
                    aligneddestinationbufferoffset,
                )
                .into()
        }
        unsafe extern "system" fn SetPredication<Impl: ID3D12VideoProcessCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbuffer: ::windows::core::RawPtr, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetPredication(&*(&pbuffer as *const <super::super::Graphics::Direct3D12::ID3D12Resource as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12Resource as ::windows::core::DefaultType>::DefaultType), alignedbufferoffset, operation).into()
        }
        unsafe extern "system" fn SetMarker<Impl: ID3D12VideoProcessCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetMarker(metadata, &*(&pdata as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType), size).into()
        }
        unsafe extern "system" fn BeginEvent<Impl: ID3D12VideoProcessCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).BeginEvent(metadata, &*(&pdata as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType), size).into()
        }
        unsafe extern "system" fn EndEvent<Impl: ID3D12VideoProcessCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).EndEvent().into()
        }
        unsafe extern "system" fn ProcessFrames<Impl: ID3D12VideoProcessCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvideoprocessor: ::windows::core::RawPtr, poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS, numinputstreams: u32, pinputarguments: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this)
                .ProcessFrames(
                    &*(&pvideoprocessor as *const <ID3D12VideoProcessor as ::windows::core::Abi>::Abi as *const <ID3D12VideoProcessor as ::windows::core::DefaultType>::DefaultType),
                    &*(&poutputarguments as *const <D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS as ::windows::core::DefaultType>::DefaultType),
                    numinputstreams,
                    &*(&pinputarguments as *const <D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS as ::windows::core::DefaultType>::DefaultType),
                )
                .into()
        }
        unsafe extern "system" fn WriteBufferImmediate<Impl: ID3D12VideoProcessCommandListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).WriteBufferImmediate(count, &*(&pparams as *const <super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER as ::windows::core::DefaultType>::DefaultType), pmodes).into()
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<ID3D12VideoProcessCommandList>,
            base.5,
            Close::<Impl, OFFSET>,
            Reset::<Impl, OFFSET>,
            ClearState::<Impl, OFFSET>,
            ResourceBarrier::<Impl, OFFSET>,
            DiscardResource::<Impl, OFFSET>,
            BeginQuery::<Impl, OFFSET>,
            EndQuery::<Impl, OFFSET>,
            ResolveQueryData::<Impl, OFFSET>,
            SetPredication::<Impl, OFFSET>,
            SetMarker::<Impl, OFFSET>,
            BeginEvent::<Impl, OFFSET>,
            EndEvent::<Impl, OFFSET>,
            ProcessFrames::<Impl, OFFSET>,
            WriteBufferImmediate::<Impl, OFFSET>,
        )
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoProcessCommandList1Impl: Sized + ID3D12VideoProcessCommandListImpl + ID3D12CommandListImpl + ID3D12DeviceChildImpl + ID3D12ObjectImpl {
    fn ProcessFrames1();
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::RuntimeName for ID3D12VideoProcessCommandList1 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoProcessCommandList1";
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoProcessCommandList1Vtbl {
    pub const fn new<Impl: ID3D12VideoProcessCommandList1Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoProcessCommandList1Vtbl {
        unsafe extern "system" fn ProcessFrames1<Impl: ID3D12VideoProcessCommandList1Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvideoprocessor: ::windows::core::RawPtr, poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS, numinputstreams: u32, pinputarguments: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this)
                .ProcessFrames1(
                    &*(&pvideoprocessor as *const <ID3D12VideoProcessor as ::windows::core::Abi>::Abi as *const <ID3D12VideoProcessor as ::windows::core::DefaultType>::DefaultType),
                    &*(&poutputarguments as *const <D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS as ::windows::core::DefaultType>::DefaultType),
                    numinputstreams,
                    &*(&pinputarguments as *const <D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1 as ::windows::core::Abi>::Abi as *const <D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1 as ::windows::core::DefaultType>::DefaultType),
                )
                .into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ID3D12VideoProcessCommandList1>, base.5, ProcessFrames1::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoProcessCommandList2Impl: Sized + ID3D12VideoProcessCommandList1Impl + ID3D12VideoProcessCommandListImpl + ID3D12CommandListImpl + ID3D12DeviceChildImpl + ID3D12ObjectImpl {
    fn SetProtectedResourceSession();
    fn InitializeExtensionCommand();
    fn ExecuteExtensionCommand();
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::RuntimeName for ID3D12VideoProcessCommandList2 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoProcessCommandList2";
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoProcessCommandList2Vtbl {
    pub const fn new<Impl: ID3D12VideoProcessCommandList2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoProcessCommandList2Vtbl {
        unsafe extern "system" fn SetProtectedResourceSession<Impl: ID3D12VideoProcessCommandList2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pprotectedresourcesession: ::windows::core::RawPtr) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetProtectedResourceSession(&*(&pprotectedresourcesession as *const <super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn InitializeExtensionCommand<Impl: ID3D12VideoProcessCommandList2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pextensioncommand: ::windows::core::RawPtr, pinitializationparameters: *const ::core::ffi::c_void, initializationparameterssizeinbytes: usize) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).InitializeExtensionCommand(&*(&pextensioncommand as *const <ID3D12VideoExtensionCommand as ::windows::core::Abi>::Abi as *const <ID3D12VideoExtensionCommand as ::windows::core::DefaultType>::DefaultType), &*(&pinitializationparameters as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType), initializationparameterssizeinbytes).into()
        }
        unsafe extern "system" fn ExecuteExtensionCommand<Impl: ID3D12VideoProcessCommandList2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pextensioncommand: ::windows::core::RawPtr, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).ExecuteExtensionCommand(&*(&pextensioncommand as *const <ID3D12VideoExtensionCommand as ::windows::core::Abi>::Abi as *const <ID3D12VideoExtensionCommand as ::windows::core::DefaultType>::DefaultType), &*(&pexecutionparameters as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType), executionparameterssizeinbytes).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ID3D12VideoProcessCommandList2>, base.5, SetProtectedResourceSession::<Impl, OFFSET>, InitializeExtensionCommand::<Impl, OFFSET>, ExecuteExtensionCommand::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoProcessorImpl: Sized + ID3D12PageableImpl + ID3D12DeviceChildImpl + ID3D12ObjectImpl {
    fn GetNodeMask();
    fn GetNumInputStreamDescs();
    fn GetInputStreamDescs();
    fn GetOutputStreamDesc();
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::RuntimeName for ID3D12VideoProcessor {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoProcessor";
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoProcessorVtbl {
    pub const fn new<Impl: ID3D12VideoProcessorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoProcessorVtbl {
        unsafe extern "system" fn GetNodeMask<Impl: ID3D12VideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNodeMask() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNumInputStreamDescs<Impl: ID3D12VideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNumInputStreamDescs() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInputStreamDescs<Impl: ID3D12VideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, numinputstreamdescs: u32, pinputstreamdescs: *mut D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInputStreamDescs(numinputstreamdescs, ::core::mem::transmute_copy(&pinputstreamdescs)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputStreamDesc<Impl: ID3D12VideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, result__: *mut D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputStreamDesc() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ID3D12VideoProcessor>, base.5, GetNodeMask::<Impl, OFFSET>, GetNumInputStreamDescs::<Impl, OFFSET>, GetInputStreamDescs::<Impl, OFFSET>, GetOutputStreamDesc::<Impl, OFFSET>)
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
pub trait ID3D12VideoProcessor1Impl: Sized + ID3D12VideoProcessorImpl + ID3D12PageableImpl + ID3D12DeviceChildImpl + ID3D12ObjectImpl {
    fn GetProtectedResourceSession();
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ::windows::core::RuntimeName for ID3D12VideoProcessor1 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ID3D12VideoProcessor1";
}
#[cfg(feature = "Win32_Graphics_Direct3D12")]
impl ID3D12VideoProcessor1Vtbl {
    pub const fn new<Impl: ID3D12VideoProcessor1Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ID3D12VideoProcessor1Vtbl {
        unsafe extern "system" fn GetProtectedResourceSession<Impl: ID3D12VideoProcessor1Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProtectedResourceSession(&*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppprotectedsession)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ID3D12VideoProcessor1>, base.5, GetProtectedResourceSession::<Impl, OFFSET>)
    }
}
pub trait IDXVAHD_DeviceImpl: Sized {
    fn CreateVideoSurface();
    fn GetVideoProcessorDeviceCaps();
    fn GetVideoProcessorOutputFormats();
    fn GetVideoProcessorInputFormats();
    fn GetVideoProcessorCaps();
    fn GetVideoProcessorCustomRates();
    fn GetVideoProcessorFilterRange();
    fn CreateVideoProcessor();
}
impl ::windows::core::RuntimeName for IDXVAHD_Device {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IDXVAHD_Device";
}
impl IDXVAHD_DeviceVtbl {
    pub const fn new<Impl: IDXVAHD_DeviceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDXVAHD_DeviceVtbl {
        unsafe extern "system" fn CreateVideoSurface<Impl: IDXVAHD_DeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, width: u32, height: u32, format: super::super::Graphics::Direct3D9::D3DFORMAT, pool: super::super::Graphics::Direct3D9::D3DPOOL, usage: u32, r#type: DXVAHD_SURFACE_TYPE, numsurfaces: u32, ppsurfaces: *mut ::windows::core::RawPtr, psharedhandle: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateVideoSurface(width, height, format, pool, usage, r#type, numsurfaces, ::core::mem::transmute_copy(&ppsurfaces), &*(&psharedhandle as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoProcessorDeviceCaps<Impl: IDXVAHD_DeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcaps: *mut DXVAHD_VPDEVCAPS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoProcessorDeviceCaps(::core::mem::transmute_copy(&pcaps)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoProcessorOutputFormats<Impl: IDXVAHD_DeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, count: u32, pformats: *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoProcessorOutputFormats(count, ::core::mem::transmute_copy(&pformats)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoProcessorInputFormats<Impl: IDXVAHD_DeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, count: u32, pformats: *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoProcessorInputFormats(count, ::core::mem::transmute_copy(&pformats)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoProcessorCaps<Impl: IDXVAHD_DeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, count: u32, pcaps: *mut DXVAHD_VPCAPS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoProcessorCaps(count, ::core::mem::transmute_copy(&pcaps)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoProcessorCustomRates<Impl: IDXVAHD_DeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvpguid: *const ::windows::core::GUID, count: u32, prates: *mut DXVAHD_CUSTOM_RATE_DATA) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoProcessorCustomRates(&*(&pvpguid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), count, ::core::mem::transmute_copy(&prates)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoProcessorFilterRange<Impl: IDXVAHD_DeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, filter: DXVAHD_FILTER, prange: *mut DXVAHD_FILTER_RANGE_DATA) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoProcessorFilterRange(filter, ::core::mem::transmute_copy(&prange)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateVideoProcessor<Impl: IDXVAHD_DeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvpguid: *const ::windows::core::GUID, ppvideoprocessor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateVideoProcessor(&*(&pvpguid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppvideoprocessor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDXVAHD_Device>, base.5, CreateVideoSurface::<Impl, OFFSET>, GetVideoProcessorDeviceCaps::<Impl, OFFSET>, GetVideoProcessorOutputFormats::<Impl, OFFSET>, GetVideoProcessorInputFormats::<Impl, OFFSET>, GetVideoProcessorCaps::<Impl, OFFSET>, GetVideoProcessorCustomRates::<Impl, OFFSET>, GetVideoProcessorFilterRange::<Impl, OFFSET>, CreateVideoProcessor::<Impl, OFFSET>)
    }
}
pub trait IDXVAHD_VideoProcessorImpl: Sized {
    fn SetVideoProcessBltState();
    fn GetVideoProcessBltState();
    fn SetVideoProcessStreamState();
    fn GetVideoProcessStreamState();
    fn VideoProcessBltHD();
}
impl ::windows::core::RuntimeName for IDXVAHD_VideoProcessor {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IDXVAHD_VideoProcessor";
}
impl IDXVAHD_VideoProcessorVtbl {
    pub const fn new<Impl: IDXVAHD_VideoProcessorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDXVAHD_VideoProcessorVtbl {
        unsafe extern "system" fn SetVideoProcessBltState<Impl: IDXVAHD_VideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, state: DXVAHD_BLT_STATE, datasize: u32, pdata: *const ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVideoProcessBltState(state, datasize, &*(&pdata as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoProcessBltState<Impl: IDXVAHD_VideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, state: DXVAHD_BLT_STATE, datasize: u32, pdata: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoProcessBltState(state, datasize, &*(&pdata as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoProcessStreamState<Impl: IDXVAHD_VideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, streamnumber: u32, state: DXVAHD_STREAM_STATE, datasize: u32, pdata: *const ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVideoProcessStreamState(streamnumber, state, datasize, &*(&pdata as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoProcessStreamState<Impl: IDXVAHD_VideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, streamnumber: u32, state: DXVAHD_STREAM_STATE, datasize: u32, pdata: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoProcessStreamState(streamnumber, state, datasize, &*(&pdata as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VideoProcessBltHD<Impl: IDXVAHD_VideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, poutputsurface: ::windows::core::RawPtr, outputframe: u32, streamcount: u32, pstreams: *const DXVAHD_STREAM_DATA) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VideoProcessBltHD(&*(&poutputsurface as *const <super::super::Graphics::Direct3D9::IDirect3DSurface9 as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D9::IDirect3DSurface9 as ::windows::core::DefaultType>::DefaultType), outputframe, streamcount, &*(&pstreams as *const <DXVAHD_STREAM_DATA as ::windows::core::Abi>::Abi as *const <DXVAHD_STREAM_DATA as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDXVAHD_VideoProcessor>, base.5, SetVideoProcessBltState::<Impl, OFFSET>, GetVideoProcessBltState::<Impl, OFFSET>, SetVideoProcessStreamState::<Impl, OFFSET>, GetVideoProcessStreamState::<Impl, OFFSET>, VideoProcessBltHD::<Impl, OFFSET>)
    }
}
pub trait IDirect3D9ExOverlayExtensionImpl: Sized {
    fn CheckDeviceOverlayType();
}
impl ::windows::core::RuntimeName for IDirect3D9ExOverlayExtension {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IDirect3D9ExOverlayExtension";
}
impl IDirect3D9ExOverlayExtensionVtbl {
    pub const fn new<Impl: IDirect3D9ExOverlayExtensionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDirect3D9ExOverlayExtensionVtbl {
        unsafe extern "system" fn CheckDeviceOverlayType<Impl: IDirect3D9ExOverlayExtensionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, adapter: u32, devtype: super::super::Graphics::Direct3D9::D3DDEVTYPE, overlaywidth: u32, overlayheight: u32, overlayformat: super::super::Graphics::Direct3D9::D3DFORMAT, pdisplaymode: *mut super::super::Graphics::Direct3D9::D3DDISPLAYMODEEX, displayrotation: super::super::Graphics::Direct3D9::D3DDISPLAYROTATION, poverlaycaps: *mut D3DOVERLAYCAPS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CheckDeviceOverlayType(adapter, devtype, overlaywidth, overlayheight, overlayformat, &*(&pdisplaymode as *const <super::super::Graphics::Direct3D9::D3DDISPLAYMODEEX as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D9::D3DDISPLAYMODEEX as ::windows::core::DefaultType>::DefaultType), displayrotation, &*(&poverlaycaps as *const <D3DOVERLAYCAPS as ::windows::core::Abi>::Abi as *const <D3DOVERLAYCAPS as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDirect3D9ExOverlayExtension>, base.5, CheckDeviceOverlayType::<Impl, OFFSET>)
    }
}
pub trait IDirect3DAuthenticatedChannel9Impl: Sized {
    fn GetCertificateSize();
    fn GetCertificate();
    fn NegotiateKeyExchange();
    fn Query();
    fn Configure();
}
impl ::windows::core::RuntimeName for IDirect3DAuthenticatedChannel9 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IDirect3DAuthenticatedChannel9";
}
impl IDirect3DAuthenticatedChannel9Vtbl {
    pub const fn new<Impl: IDirect3DAuthenticatedChannel9Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDirect3DAuthenticatedChannel9Vtbl {
        unsafe extern "system" fn GetCertificateSize<Impl: IDirect3DAuthenticatedChannel9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcertificatesize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCertificateSize(pcertificatesize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCertificate<Impl: IDirect3DAuthenticatedChannel9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, certifactesize: u32, ppcertificate: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCertificate(certifactesize, ppcertificate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NegotiateKeyExchange<Impl: IDirect3DAuthenticatedChannel9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, datasize: u32, pdata: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NegotiateKeyExchange(datasize, &*(&pdata as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Query<Impl: IDirect3DAuthenticatedChannel9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, inputsize: u32, pinput: *const ::core::ffi::c_void, outputsize: u32, poutput: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Query(inputsize, &*(&pinput as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType), outputsize, &*(&poutput as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Configure<Impl: IDirect3DAuthenticatedChannel9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, inputsize: u32, pinput: *const ::core::ffi::c_void, poutput: *mut super::super::Graphics::Direct3D9::D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Configure(inputsize, &*(&pinput as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType), &*(&poutput as *const <super::super::Graphics::Direct3D9::D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D9::D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDirect3DAuthenticatedChannel9>, base.5, GetCertificateSize::<Impl, OFFSET>, GetCertificate::<Impl, OFFSET>, NegotiateKeyExchange::<Impl, OFFSET>, Query::<Impl, OFFSET>, Configure::<Impl, OFFSET>)
    }
}
pub trait IDirect3DCryptoSession9Impl: Sized {
    fn GetCertificateSize();
    fn GetCertificate();
    fn NegotiateKeyExchange();
    fn EncryptionBlt();
    fn DecryptionBlt();
    fn GetSurfacePitch();
    fn StartSessionKeyRefresh();
    fn FinishSessionKeyRefresh();
    fn GetEncryptionBltKey();
}
impl ::windows::core::RuntimeName for IDirect3DCryptoSession9 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IDirect3DCryptoSession9";
}
impl IDirect3DCryptoSession9Vtbl {
    pub const fn new<Impl: IDirect3DCryptoSession9Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDirect3DCryptoSession9Vtbl {
        unsafe extern "system" fn GetCertificateSize<Impl: IDirect3DCryptoSession9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcertificatesize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCertificateSize(pcertificatesize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCertificate<Impl: IDirect3DCryptoSession9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, certifactesize: u32, ppcertificate: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCertificate(certifactesize, ppcertificate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NegotiateKeyExchange<Impl: IDirect3DCryptoSession9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, datasize: u32, pdata: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NegotiateKeyExchange(datasize, &*(&pdata as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EncryptionBlt<Impl: IDirect3DCryptoSession9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psrcsurface: ::windows::core::RawPtr, pdstsurface: ::windows::core::RawPtr, dstsurfacesize: u32, piv: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EncryptionBlt(
                &*(&psrcsurface as *const <super::super::Graphics::Direct3D9::IDirect3DSurface9 as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D9::IDirect3DSurface9 as ::windows::core::DefaultType>::DefaultType),
                &*(&pdstsurface as *const <super::super::Graphics::Direct3D9::IDirect3DSurface9 as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D9::IDirect3DSurface9 as ::windows::core::DefaultType>::DefaultType),
                dstsurfacesize,
                &*(&piv as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DecryptionBlt<Impl: IDirect3DCryptoSession9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psrcsurface: ::windows::core::RawPtr, pdstsurface: ::windows::core::RawPtr, srcsurfacesize: u32, pencryptedblockinfo: *mut super::super::Graphics::Direct3D9::D3DENCRYPTED_BLOCK_INFO, pcontentkey: *mut ::core::ffi::c_void, piv: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DecryptionBlt(
                &*(&psrcsurface as *const <super::super::Graphics::Direct3D9::IDirect3DSurface9 as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D9::IDirect3DSurface9 as ::windows::core::DefaultType>::DefaultType),
                &*(&pdstsurface as *const <super::super::Graphics::Direct3D9::IDirect3DSurface9 as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D9::IDirect3DSurface9 as ::windows::core::DefaultType>::DefaultType),
                srcsurfacesize,
                &*(&pencryptedblockinfo as *const <super::super::Graphics::Direct3D9::D3DENCRYPTED_BLOCK_INFO as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D9::D3DENCRYPTED_BLOCK_INFO as ::windows::core::DefaultType>::DefaultType),
                &*(&pcontentkey as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType),
                &*(&piv as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSurfacePitch<Impl: IDirect3DCryptoSession9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psrcsurface: ::windows::core::RawPtr, psurfacepitch: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSurfacePitch(&*(&psrcsurface as *const <super::super::Graphics::Direct3D9::IDirect3DSurface9 as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D9::IDirect3DSurface9 as ::windows::core::DefaultType>::DefaultType), psurfacepitch) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StartSessionKeyRefresh<Impl: IDirect3DCryptoSession9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prandomnumber: *mut ::core::ffi::c_void, randomnumbersize: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StartSessionKeyRefresh(&*(&prandomnumber as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType), randomnumbersize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FinishSessionKeyRefresh<Impl: IDirect3DCryptoSession9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FinishSessionKeyRefresh() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEncryptionBltKey<Impl: IDirect3DCryptoSession9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, preadbackkey: *mut ::core::ffi::c_void, keysize: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEncryptionBltKey(&*(&preadbackkey as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType), keysize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDirect3DCryptoSession9>, base.5, GetCertificateSize::<Impl, OFFSET>, GetCertificate::<Impl, OFFSET>, NegotiateKeyExchange::<Impl, OFFSET>, EncryptionBlt::<Impl, OFFSET>, DecryptionBlt::<Impl, OFFSET>, GetSurfacePitch::<Impl, OFFSET>, StartSessionKeyRefresh::<Impl, OFFSET>, FinishSessionKeyRefresh::<Impl, OFFSET>, GetEncryptionBltKey::<Impl, OFFSET>)
    }
}
pub trait IDirect3DDevice9VideoImpl: Sized {
    fn GetContentProtectionCaps();
    fn CreateAuthenticatedChannel();
    fn CreateCryptoSession();
}
impl ::windows::core::RuntimeName for IDirect3DDevice9Video {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IDirect3DDevice9Video";
}
impl IDirect3DDevice9VideoVtbl {
    pub const fn new<Impl: IDirect3DDevice9VideoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDirect3DDevice9VideoVtbl {
        unsafe extern "system" fn GetContentProtectionCaps<Impl: IDirect3DDevice9VideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcryptotype: *const ::windows::core::GUID, pdecodeprofile: *const ::windows::core::GUID, pcaps: *mut D3DCONTENTPROTECTIONCAPS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetContentProtectionCaps(
                &*(&pcryptotype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&pdecodeprofile as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&pcaps as *const <D3DCONTENTPROTECTIONCAPS as ::windows::core::Abi>::Abi as *const <D3DCONTENTPROTECTIONCAPS as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateAuthenticatedChannel<Impl: IDirect3DDevice9VideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, channeltype: super::super::Graphics::Direct3D9::D3DAUTHENTICATEDCHANNELTYPE, ppauthenticatedchannel: *mut ::windows::core::RawPtr, pchannelhandle: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateAuthenticatedChannel(channeltype, ::core::mem::transmute_copy(&ppauthenticatedchannel), &*(&pchannelhandle as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateCryptoSession<Impl: IDirect3DDevice9VideoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcryptotype: *const ::windows::core::GUID, pdecodeprofile: *const ::windows::core::GUID, ppcryptosession: *mut ::windows::core::RawPtr, pcryptohandle: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateCryptoSession(
                &*(&pcryptotype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&pdecodeprofile as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&ppcryptosession),
                &*(&pcryptohandle as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDirect3DDevice9Video>, base.5, GetContentProtectionCaps::<Impl, OFFSET>, CreateAuthenticatedChannel::<Impl, OFFSET>, CreateCryptoSession::<Impl, OFFSET>)
    }
}
pub trait IDirect3DDeviceManager9Impl: Sized {
    fn ResetDevice();
    fn OpenDeviceHandle();
    fn CloseDeviceHandle();
    fn TestDevice();
    fn LockDevice();
    fn UnlockDevice();
    fn GetVideoService();
}
impl ::windows::core::RuntimeName for IDirect3DDeviceManager9 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IDirect3DDeviceManager9";
}
impl IDirect3DDeviceManager9Vtbl {
    pub const fn new<Impl: IDirect3DDeviceManager9Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDirect3DDeviceManager9Vtbl {
        unsafe extern "system" fn ResetDevice<Impl: IDirect3DDeviceManager9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdevice: ::windows::core::RawPtr, resettoken: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ResetDevice(&*(&pdevice as *const <super::super::Graphics::Direct3D9::IDirect3DDevice9 as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D9::IDirect3DDevice9 as ::windows::core::DefaultType>::DefaultType), resettoken) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OpenDeviceHandle<Impl: IDirect3DDeviceManager9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phdevice: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OpenDeviceHandle(::core::mem::transmute_copy(&phdevice)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CloseDeviceHandle<Impl: IDirect3DDeviceManager9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CloseDeviceHandle(&*(&hdevice as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TestDevice<Impl: IDirect3DDeviceManager9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TestDevice(&*(&hdevice as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LockDevice<Impl: IDirect3DDeviceManager9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, ppdevice: *mut ::windows::core::RawPtr, fblock: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LockDevice(&*(&hdevice as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppdevice), &*(&fblock as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnlockDevice<Impl: IDirect3DDeviceManager9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, fsavestate: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnlockDevice(&*(&hdevice as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType), &*(&fsavestate as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoService<Impl: IDirect3DDeviceManager9Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, riid: *const ::windows::core::GUID, ppservice: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoService(&*(&hdevice as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType), &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppservice)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDirect3DDeviceManager9>, base.5, ResetDevice::<Impl, OFFSET>, OpenDeviceHandle::<Impl, OFFSET>, CloseDeviceHandle::<Impl, OFFSET>, TestDevice::<Impl, OFFSET>, LockDevice::<Impl, OFFSET>, UnlockDevice::<Impl, OFFSET>, GetVideoService::<Impl, OFFSET>)
    }
}
pub trait IDirectXVideoAccelerationServiceImpl: Sized {
    fn CreateSurface();
}
impl ::windows::core::RuntimeName for IDirectXVideoAccelerationService {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IDirectXVideoAccelerationService";
}
impl IDirectXVideoAccelerationServiceVtbl {
    pub const fn new<Impl: IDirectXVideoAccelerationServiceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDirectXVideoAccelerationServiceVtbl {
        unsafe extern "system" fn CreateSurface<Impl: IDirectXVideoAccelerationServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, width: u32, height: u32, backbuffers: u32, format: super::super::Graphics::Direct3D9::D3DFORMAT, pool: super::super::Graphics::Direct3D9::D3DPOOL, usage: u32, dxvatype: DXVA2_VideoRenderTargetType, ppsurface: *mut ::windows::core::RawPtr, psharedhandle: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateSurface(width, height, backbuffers, format, pool, usage, dxvatype, ::core::mem::transmute_copy(&ppsurface), &*(&psharedhandle as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDirectXVideoAccelerationService>, base.5, CreateSurface::<Impl, OFFSET>)
    }
}
pub trait IDirectXVideoDecoderImpl: Sized {
    fn GetVideoDecoderService();
    fn GetCreationParameters();
    fn GetBuffer();
    fn ReleaseBuffer();
    fn BeginFrame();
    fn EndFrame();
    fn Execute();
}
impl ::windows::core::RuntimeName for IDirectXVideoDecoder {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IDirectXVideoDecoder";
}
impl IDirectXVideoDecoderVtbl {
    pub const fn new<Impl: IDirectXVideoDecoderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDirectXVideoDecoderVtbl {
        unsafe extern "system" fn GetVideoDecoderService<Impl: IDirectXVideoDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppservice: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoDecoderService(::core::mem::transmute_copy(&ppservice)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCreationParameters<Impl: IDirectXVideoDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdeviceguid: *mut ::windows::core::GUID, pvideodesc: *mut DXVA2_VideoDesc, pconfig: *mut DXVA2_ConfigPictureDecode, pdecoderrendertargets: *mut *mut ::windows::core::RawPtr, pnumsurfaces: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCreationParameters(::core::mem::transmute_copy(&pdeviceguid), ::core::mem::transmute_copy(&pvideodesc), ::core::mem::transmute_copy(&pconfig), ::core::mem::transmute_copy(&pdecoderrendertargets), ::core::mem::transmute_copy(&pnumsurfaces)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBuffer<Impl: IDirectXVideoDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, buffertype: DXVA2_BufferfType, ppbuffer: *mut *mut ::core::ffi::c_void, pbuffersize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBuffer(buffertype, ::core::mem::transmute_copy(&ppbuffer), ::core::mem::transmute_copy(&pbuffersize)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReleaseBuffer<Impl: IDirectXVideoDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, buffertype: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReleaseBuffer(buffertype) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginFrame<Impl: IDirectXVideoDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prendertarget: ::windows::core::RawPtr, pvpvpdata: *const ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginFrame(&*(&prendertarget as *const <super::super::Graphics::Direct3D9::IDirect3DSurface9 as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D9::IDirect3DSurface9 as ::windows::core::DefaultType>::DefaultType), &*(&pvpvpdata as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndFrame<Impl: IDirectXVideoDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phandlecomplete: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndFrame(&*(&phandlecomplete as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Execute<Impl: IDirectXVideoDecoderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pexecuteparams: *const DXVA2_DecodeExecuteParams) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Execute(&*(&pexecuteparams as *const <DXVA2_DecodeExecuteParams as ::windows::core::Abi>::Abi as *const <DXVA2_DecodeExecuteParams as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDirectXVideoDecoder>, base.5, GetVideoDecoderService::<Impl, OFFSET>, GetCreationParameters::<Impl, OFFSET>, GetBuffer::<Impl, OFFSET>, ReleaseBuffer::<Impl, OFFSET>, BeginFrame::<Impl, OFFSET>, EndFrame::<Impl, OFFSET>, Execute::<Impl, OFFSET>)
    }
}
pub trait IDirectXVideoDecoderServiceImpl: Sized + IDirectXVideoAccelerationServiceImpl {
    fn GetDecoderDeviceGuids();
    fn GetDecoderRenderTargets();
    fn GetDecoderConfigurations();
    fn CreateVideoDecoder();
}
impl ::windows::core::RuntimeName for IDirectXVideoDecoderService {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IDirectXVideoDecoderService";
}
impl IDirectXVideoDecoderServiceVtbl {
    pub const fn new<Impl: IDirectXVideoDecoderServiceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDirectXVideoDecoderServiceVtbl {
        unsafe extern "system" fn GetDecoderDeviceGuids<Impl: IDirectXVideoDecoderServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcount: *mut u32, pguids: *mut *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDecoderDeviceGuids(::core::mem::transmute_copy(&pcount), ::core::mem::transmute_copy(&pguids)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDecoderRenderTargets<Impl: IDirectXVideoDecoderServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guid: *const ::windows::core::GUID, pcount: *mut u32, pformats: *mut *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDecoderRenderTargets(&*(&guid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pcount), ::core::mem::transmute_copy(&pformats)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDecoderConfigurations<Impl: IDirectXVideoDecoderServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, preserved: *mut ::core::ffi::c_void, pcount: *mut u32, ppconfigs: *mut *mut DXVA2_ConfigPictureDecode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDecoderConfigurations(
                &*(&guid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&pvideodesc as *const <DXVA2_VideoDesc as ::windows::core::Abi>::Abi as *const <DXVA2_VideoDesc as ::windows::core::DefaultType>::DefaultType),
                &*(&preserved as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&pcount),
                ::core::mem::transmute_copy(&ppconfigs),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateVideoDecoder<Impl: IDirectXVideoDecoderServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, pconfig: *const DXVA2_ConfigPictureDecode, ppdecoderrendertargets: *const ::windows::core::RawPtr, numrendertargets: u32, ppdecode: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateVideoDecoder(
                &*(&guid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&pvideodesc as *const <DXVA2_VideoDesc as ::windows::core::Abi>::Abi as *const <DXVA2_VideoDesc as ::windows::core::DefaultType>::DefaultType),
                &*(&pconfig as *const <DXVA2_ConfigPictureDecode as ::windows::core::Abi>::Abi as *const <DXVA2_ConfigPictureDecode as ::windows::core::DefaultType>::DefaultType),
                &*(&ppdecoderrendertargets as *const <super::super::Graphics::Direct3D9::IDirect3DSurface9 as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D9::IDirect3DSurface9 as ::windows::core::DefaultType>::DefaultType),
                numrendertargets,
                ::core::mem::transmute_copy(&ppdecode),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDirectXVideoDecoderService>, base.5, GetDecoderDeviceGuids::<Impl, OFFSET>, GetDecoderRenderTargets::<Impl, OFFSET>, GetDecoderConfigurations::<Impl, OFFSET>, CreateVideoDecoder::<Impl, OFFSET>)
    }
}
pub trait IDirectXVideoMemoryConfigurationImpl: Sized {
    fn GetAvailableSurfaceTypeByIndex();
    fn SetSurfaceType();
}
impl ::windows::core::RuntimeName for IDirectXVideoMemoryConfiguration {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IDirectXVideoMemoryConfiguration";
}
impl IDirectXVideoMemoryConfigurationVtbl {
    pub const fn new<Impl: IDirectXVideoMemoryConfigurationImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDirectXVideoMemoryConfigurationVtbl {
        unsafe extern "system" fn GetAvailableSurfaceTypeByIndex<Impl: IDirectXVideoMemoryConfigurationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwtypeindex: u32, pdwtype: *mut DXVA2_SurfaceType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAvailableSurfaceTypeByIndex(dwtypeindex, ::core::mem::transmute_copy(&pdwtype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSurfaceType<Impl: IDirectXVideoMemoryConfigurationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwtype: DXVA2_SurfaceType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSurfaceType(dwtype) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDirectXVideoMemoryConfiguration>, base.5, GetAvailableSurfaceTypeByIndex::<Impl, OFFSET>, SetSurfaceType::<Impl, OFFSET>)
    }
}
pub trait IDirectXVideoProcessorImpl: Sized {
    fn GetVideoProcessorService();
    fn GetCreationParameters();
    fn GetVideoProcessorCaps();
    fn GetProcAmpRange();
    fn GetFilterPropertyRange();
    fn VideoProcessBlt();
}
impl ::windows::core::RuntimeName for IDirectXVideoProcessor {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IDirectXVideoProcessor";
}
impl IDirectXVideoProcessorVtbl {
    pub const fn new<Impl: IDirectXVideoProcessorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDirectXVideoProcessorVtbl {
        unsafe extern "system" fn GetVideoProcessorService<Impl: IDirectXVideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppservice: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoProcessorService(::core::mem::transmute_copy(&ppservice)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCreationParameters<Impl: IDirectXVideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdeviceguid: *mut ::windows::core::GUID, pvideodesc: *mut DXVA2_VideoDesc, prendertargetformat: *mut super::super::Graphics::Direct3D9::D3DFORMAT, pmaxnumsubstreams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCreationParameters(::core::mem::transmute_copy(&pdeviceguid), ::core::mem::transmute_copy(&pvideodesc), ::core::mem::transmute_copy(&prendertargetformat), ::core::mem::transmute_copy(&pmaxnumsubstreams)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoProcessorCaps<Impl: IDirectXVideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcaps: *mut DXVA2_VideoProcessorCaps) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoProcessorCaps(::core::mem::transmute_copy(&pcaps)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProcAmpRange<Impl: IDirectXVideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, procampcap: u32, prange: *mut DXVA2_ValueRange) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProcAmpRange(procampcap, ::core::mem::transmute_copy(&prange)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFilterPropertyRange<Impl: IDirectXVideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, filtersetting: u32, prange: *mut DXVA2_ValueRange) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFilterPropertyRange(filtersetting, ::core::mem::transmute_copy(&prange)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VideoProcessBlt<Impl: IDirectXVideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prendertarget: ::windows::core::RawPtr, pbltparams: *const DXVA2_VideoProcessBltParams, psamples: *const DXVA2_VideoSample, numsamples: u32, phandlecomplete: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).VideoProcessBlt(
                &*(&prendertarget as *const <super::super::Graphics::Direct3D9::IDirect3DSurface9 as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D9::IDirect3DSurface9 as ::windows::core::DefaultType>::DefaultType),
                &*(&pbltparams as *const <DXVA2_VideoProcessBltParams as ::windows::core::Abi>::Abi as *const <DXVA2_VideoProcessBltParams as ::windows::core::DefaultType>::DefaultType),
                &*(&psamples as *const <DXVA2_VideoSample as ::windows::core::Abi>::Abi as *const <DXVA2_VideoSample as ::windows::core::DefaultType>::DefaultType),
                numsamples,
                &*(&phandlecomplete as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDirectXVideoProcessor>, base.5, GetVideoProcessorService::<Impl, OFFSET>, GetCreationParameters::<Impl, OFFSET>, GetVideoProcessorCaps::<Impl, OFFSET>, GetProcAmpRange::<Impl, OFFSET>, GetFilterPropertyRange::<Impl, OFFSET>, VideoProcessBlt::<Impl, OFFSET>)
    }
}
pub trait IDirectXVideoProcessorServiceImpl: Sized + IDirectXVideoAccelerationServiceImpl {
    fn RegisterVideoProcessorSoftwareDevice();
    fn GetVideoProcessorDeviceGuids();
    fn GetVideoProcessorRenderTargets();
    fn GetVideoProcessorSubStreamFormats();
    fn GetVideoProcessorCaps();
    fn GetProcAmpRange();
    fn GetFilterPropertyRange();
    fn CreateVideoProcessor();
}
impl ::windows::core::RuntimeName for IDirectXVideoProcessorService {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IDirectXVideoProcessorService";
}
impl IDirectXVideoProcessorServiceVtbl {
    pub const fn new<Impl: IDirectXVideoProcessorServiceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IDirectXVideoProcessorServiceVtbl {
        unsafe extern "system" fn RegisterVideoProcessorSoftwareDevice<Impl: IDirectXVideoProcessorServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcallbacks: *const ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterVideoProcessorSoftwareDevice(&*(&pcallbacks as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoProcessorDeviceGuids<Impl: IDirectXVideoProcessorServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvideodesc: *const DXVA2_VideoDesc, pcount: *mut u32, pguids: *mut *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoProcessorDeviceGuids(&*(&pvideodesc as *const <DXVA2_VideoDesc as ::windows::core::Abi>::Abi as *const <DXVA2_VideoDesc as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pcount), ::core::mem::transmute_copy(&pguids)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoProcessorRenderTargets<Impl: IDirectXVideoProcessorServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, pcount: *mut u32, pformats: *mut *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoProcessorRenderTargets(&*(&videoprocdeviceguid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&pvideodesc as *const <DXVA2_VideoDesc as ::windows::core::Abi>::Abi as *const <DXVA2_VideoDesc as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pcount), ::core::mem::transmute_copy(&pformats)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoProcessorSubStreamFormats<Impl: IDirectXVideoProcessorServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, pcount: *mut u32, pformats: *mut *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoProcessorSubStreamFormats(&*(&videoprocdeviceguid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&pvideodesc as *const <DXVA2_VideoDesc as ::windows::core::Abi>::Abi as *const <DXVA2_VideoDesc as ::windows::core::DefaultType>::DefaultType), rendertargetformat, ::core::mem::transmute_copy(&pcount), ::core::mem::transmute_copy(&pformats)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoProcessorCaps<Impl: IDirectXVideoProcessorServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, pcaps: *mut DXVA2_VideoProcessorCaps) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoProcessorCaps(&*(&videoprocdeviceguid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&pvideodesc as *const <DXVA2_VideoDesc as ::windows::core::Abi>::Abi as *const <DXVA2_VideoDesc as ::windows::core::DefaultType>::DefaultType), rendertargetformat, ::core::mem::transmute_copy(&pcaps)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProcAmpRange<Impl: IDirectXVideoProcessorServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, procampcap: u32, prange: *mut DXVA2_ValueRange) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProcAmpRange(&*(&videoprocdeviceguid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&pvideodesc as *const <DXVA2_VideoDesc as ::windows::core::Abi>::Abi as *const <DXVA2_VideoDesc as ::windows::core::DefaultType>::DefaultType), rendertargetformat, procampcap, ::core::mem::transmute_copy(&prange)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFilterPropertyRange<Impl: IDirectXVideoProcessorServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, filtersetting: u32, prange: *mut DXVA2_ValueRange) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFilterPropertyRange(&*(&videoprocdeviceguid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&pvideodesc as *const <DXVA2_VideoDesc as ::windows::core::Abi>::Abi as *const <DXVA2_VideoDesc as ::windows::core::DefaultType>::DefaultType), rendertargetformat, filtersetting, ::core::mem::transmute_copy(&prange)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateVideoProcessor<Impl: IDirectXVideoProcessorServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, maxnumsubstreams: u32, ppvidprocess: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateVideoProcessor(&*(&videoprocdeviceguid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&pvideodesc as *const <DXVA2_VideoDesc as ::windows::core::Abi>::Abi as *const <DXVA2_VideoDesc as ::windows::core::DefaultType>::DefaultType), rendertargetformat, maxnumsubstreams, ::core::mem::transmute_copy(&ppvidprocess)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IDirectXVideoProcessorService>, base.5, RegisterVideoProcessorSoftwareDevice::<Impl, OFFSET>, GetVideoProcessorDeviceGuids::<Impl, OFFSET>, GetVideoProcessorRenderTargets::<Impl, OFFSET>, GetVideoProcessorSubStreamFormats::<Impl, OFFSET>, GetVideoProcessorCaps::<Impl, OFFSET>, GetProcAmpRange::<Impl, OFFSET>, GetFilterPropertyRange::<Impl, OFFSET>, CreateVideoProcessor::<Impl, OFFSET>)
    }
}
pub trait IEVRFilterConfigImpl: Sized {
    fn SetNumberOfStreams();
    fn GetNumberOfStreams();
}
impl ::windows::core::RuntimeName for IEVRFilterConfig {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IEVRFilterConfig";
}
impl IEVRFilterConfigVtbl {
    pub const fn new<Impl: IEVRFilterConfigImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IEVRFilterConfigVtbl {
        unsafe extern "system" fn SetNumberOfStreams<Impl: IEVRFilterConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwmaxstreams: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetNumberOfStreams(dwmaxstreams) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNumberOfStreams<Impl: IEVRFilterConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwmaxstreams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNumberOfStreams(::core::mem::transmute_copy(&pdwmaxstreams)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IEVRFilterConfig>, base.5, SetNumberOfStreams::<Impl, OFFSET>, GetNumberOfStreams::<Impl, OFFSET>)
    }
}
pub trait IEVRFilterConfigExImpl: Sized + IEVRFilterConfigImpl {
    fn SetConfigPrefs();
    fn GetConfigPrefs();
}
impl ::windows::core::RuntimeName for IEVRFilterConfigEx {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IEVRFilterConfigEx";
}
impl IEVRFilterConfigExVtbl {
    pub const fn new<Impl: IEVRFilterConfigExImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IEVRFilterConfigExVtbl {
        unsafe extern "system" fn SetConfigPrefs<Impl: IEVRFilterConfigExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwconfigflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetConfigPrefs(dwconfigflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetConfigPrefs<Impl: IEVRFilterConfigExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwconfigflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetConfigPrefs(::core::mem::transmute_copy(&pdwconfigflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IEVRFilterConfigEx>, base.5, SetConfigPrefs::<Impl, OFFSET>, GetConfigPrefs::<Impl, OFFSET>)
    }
}
pub trait IEVRTrustedVideoPluginImpl: Sized {
    fn IsInTrustedVideoMode();
    fn CanConstrict();
    fn SetConstriction();
    fn DisableImageExport();
}
impl ::windows::core::RuntimeName for IEVRTrustedVideoPlugin {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IEVRTrustedVideoPlugin";
}
impl IEVRTrustedVideoPluginVtbl {
    pub const fn new<Impl: IEVRTrustedVideoPluginImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IEVRTrustedVideoPluginVtbl {
        unsafe extern "system" fn IsInTrustedVideoMode<Impl: IEVRTrustedVideoPluginImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pyes: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsInTrustedVideoMode(::core::mem::transmute_copy(&pyes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanConstrict<Impl: IEVRTrustedVideoPluginImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pyes: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanConstrict(::core::mem::transmute_copy(&pyes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetConstriction<Impl: IEVRTrustedVideoPluginImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwkpix: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetConstriction(dwkpix) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisableImageExport<Impl: IEVRTrustedVideoPluginImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bdisable: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisableImageExport(&*(&bdisable as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IEVRTrustedVideoPlugin>, base.5, IsInTrustedVideoMode::<Impl, OFFSET>, CanConstrict::<Impl, OFFSET>, SetConstriction::<Impl, OFFSET>, DisableImageExport::<Impl, OFFSET>)
    }
}
pub trait IEVRVideoStreamControlImpl: Sized {
    fn SetStreamActiveState();
    fn GetStreamActiveState();
}
impl ::windows::core::RuntimeName for IEVRVideoStreamControl {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IEVRVideoStreamControl";
}
impl IEVRVideoStreamControlVtbl {
    pub const fn new<Impl: IEVRVideoStreamControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IEVRVideoStreamControlVtbl {
        unsafe extern "system" fn SetStreamActiveState<Impl: IEVRVideoStreamControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, factive: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStreamActiveState(&*(&factive as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamActiveState<Impl: IEVRVideoStreamControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpfactive: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamActiveState(::core::mem::transmute_copy(&lpfactive)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IEVRVideoStreamControl>, base.5, SetStreamActiveState::<Impl, OFFSET>, GetStreamActiveState::<Impl, OFFSET>)
    }
}
pub trait IFileClientImpl: Sized {
    fn GetObjectDiskSize();
    fn Write();
    fn Read();
}
impl ::windows::core::RuntimeName for IFileClient {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IFileClient";
}
impl IFileClientVtbl {
    pub const fn new<Impl: IFileClientImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFileClientVtbl {
        unsafe extern "system" fn GetObjectDiskSize<Impl: IFileClientImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pqwsize: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetObjectDiskSize(pqwsize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Write<Impl: IFileClientImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfio: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Write(&*(&pfio as *const <IFileIo as ::windows::core::Abi>::Abi as *const <IFileIo as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Read<Impl: IFileClientImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfio: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Read(&*(&pfio as *const <IFileIo as ::windows::core::Abi>::Abi as *const <IFileIo as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFileClient>, base.5, GetObjectDiskSize::<Impl, OFFSET>, Write::<Impl, OFFSET>, Read::<Impl, OFFSET>)
    }
}
pub trait IFileIoImpl: Sized {
    fn Initialize();
    fn GetLength();
    fn SetLength();
    fn GetCurrentPosition();
    fn SetCurrentPosition();
    fn IsEndOfStream();
    fn Read();
    fn Write();
    fn Seek();
    fn Close();
}
impl ::windows::core::RuntimeName for IFileIo {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IFileIo";
}
impl IFileIoVtbl {
    pub const fn new<Impl: IFileIoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IFileIoVtbl {
        unsafe extern "system" fn Initialize<Impl: IFileIoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, eaccessmode: FILE_ACCESSMODE, eopenmode: FILE_OPENMODE, pwszfilename: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(eaccessmode, eopenmode, &*(&pwszfilename as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IFileIoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pqwlength: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(pqwlength) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLength<Impl: IFileIoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, qwlength: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLength(qwlength) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentPosition<Impl: IFileIoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pqwposition: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentPosition(pqwposition) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentPosition<Impl: IFileIoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, qwposition: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCurrentPosition(qwposition) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsEndOfStream<Impl: IFileIoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbendofstream: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsEndOfStream(&*(&pbendofstream as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Read<Impl: IFileIoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbt: *mut u8, ul: u32, pulread: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Read(pbt, ul, pulread) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Write<Impl: IFileIoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbt: *mut u8, ul: u32, pulwritten: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Write(pbt, ul, pulwritten) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Seek<Impl: IFileIoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, eseekorigin: SEEK_ORIGIN, qwseekoffset: u64, dwseekflags: u32, pqwcurrentposition: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Seek(eseekorigin, qwseekoffset, dwseekflags, pqwcurrentposition) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Close<Impl: IFileIoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Close() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IFileIo>, base.5, Initialize::<Impl, OFFSET>, GetLength::<Impl, OFFSET>, SetLength::<Impl, OFFSET>, GetCurrentPosition::<Impl, OFFSET>, SetCurrentPosition::<Impl, OFFSET>, IsEndOfStream::<Impl, OFFSET>, Read::<Impl, OFFSET>, Write::<Impl, OFFSET>, Seek::<Impl, OFFSET>, Close::<Impl, OFFSET>)
    }
}
pub trait IMF2DBufferImpl: Sized {
    fn Lock2D();
    fn Unlock2D();
    fn GetScanline0AndPitch();
    fn IsContiguousFormat();
    fn GetContiguousLength();
    fn ContiguousCopyTo();
    fn ContiguousCopyFrom();
}
impl ::windows::core::RuntimeName for IMF2DBuffer {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMF2DBuffer";
}
impl IMF2DBufferVtbl {
    pub const fn new<Impl: IMF2DBufferImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMF2DBufferVtbl {
        unsafe extern "system" fn Lock2D<Impl: IMF2DBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppbscanline0: *mut *mut u8, plpitch: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Lock2D(::core::mem::transmute_copy(&ppbscanline0), ::core::mem::transmute_copy(&plpitch)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Unlock2D<Impl: IMF2DBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Unlock2D() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetScanline0AndPitch<Impl: IMF2DBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbscanline0: *mut *mut u8, plpitch: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetScanline0AndPitch(::core::mem::transmute_copy(&pbscanline0), ::core::mem::transmute_copy(&plpitch)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsContiguousFormat<Impl: IMF2DBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfiscontiguous: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsContiguousFormat(::core::mem::transmute_copy(&pfiscontiguous)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetContiguousLength<Impl: IMF2DBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcblength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetContiguousLength(::core::mem::transmute_copy(&pcblength)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContiguousCopyTo<Impl: IMF2DBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbdestbuffer: *mut u8, cbdestbuffer: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContiguousCopyTo(::core::mem::transmute_copy(&pbdestbuffer), cbdestbuffer) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContiguousCopyFrom<Impl: IMF2DBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbsrcbuffer: *const u8, cbsrcbuffer: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContiguousCopyFrom(pbsrcbuffer, cbsrcbuffer) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMF2DBuffer>, base.5, Lock2D::<Impl, OFFSET>, Unlock2D::<Impl, OFFSET>, GetScanline0AndPitch::<Impl, OFFSET>, IsContiguousFormat::<Impl, OFFSET>, GetContiguousLength::<Impl, OFFSET>, ContiguousCopyTo::<Impl, OFFSET>, ContiguousCopyFrom::<Impl, OFFSET>)
    }
}
pub trait IMF2DBuffer2Impl: Sized + IMF2DBufferImpl {
    fn Lock2DSize();
    fn Copy2DTo();
}
impl ::windows::core::RuntimeName for IMF2DBuffer2 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMF2DBuffer2";
}
impl IMF2DBuffer2Vtbl {
    pub const fn new<Impl: IMF2DBuffer2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMF2DBuffer2Vtbl {
        unsafe extern "system" fn Lock2DSize<Impl: IMF2DBuffer2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lockflags: MF2DBuffer_LockFlags, ppbscanline0: *mut *mut u8, plpitch: *mut i32, ppbbufferstart: *mut *mut u8, pcbbufferlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Lock2DSize(lockflags, ::core::mem::transmute_copy(&ppbscanline0), ::core::mem::transmute_copy(&plpitch), ::core::mem::transmute_copy(&ppbbufferstart), ::core::mem::transmute_copy(&pcbbufferlength)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Copy2DTo<Impl: IMF2DBuffer2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdestbuffer: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Copy2DTo(&*(&pdestbuffer as *const <IMF2DBuffer2 as ::windows::core::Abi>::Abi as *const <IMF2DBuffer2 as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMF2DBuffer2>, base.5, Lock2DSize::<Impl, OFFSET>, Copy2DTo::<Impl, OFFSET>)
    }
}
pub trait IMFASFContentInfoImpl: Sized {
    fn GetHeaderSize();
    fn ParseHeader();
    fn GenerateHeader();
    fn GetProfile();
    fn SetProfile();
    fn GeneratePresentationDescriptor();
    fn GetEncodingConfigurationPropertyStore();
}
impl ::windows::core::RuntimeName for IMFASFContentInfo {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFASFContentInfo";
}
impl IMFASFContentInfoVtbl {
    pub const fn new<Impl: IMFASFContentInfoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFASFContentInfoVtbl {
        unsafe extern "system" fn GetHeaderSize<Impl: IMFASFContentInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pistartofcontent: ::windows::core::RawPtr, cbheadersize: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetHeaderSize(&*(&pistartofcontent as *const <IMFMediaBuffer as ::windows::core::Abi>::Abi as *const <IMFMediaBuffer as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&cbheadersize)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ParseHeader<Impl: IMFASFContentInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, piheaderbuffer: ::windows::core::RawPtr, cboffsetwithinheader: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ParseHeader(&*(&piheaderbuffer as *const <IMFMediaBuffer as ::windows::core::Abi>::Abi as *const <IMFMediaBuffer as ::windows::core::DefaultType>::DefaultType), cboffsetwithinheader) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GenerateHeader<Impl: IMFASFContentInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, piheader: ::windows::core::RawPtr, pcbheader: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GenerateHeader(&*(&piheader as *const <IMFMediaBuffer as ::windows::core::Abi>::Abi as *const <IMFMediaBuffer as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pcbheader)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProfile<Impl: IMFASFContentInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppiprofile: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProfile(::core::mem::transmute_copy(&ppiprofile)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProfile<Impl: IMFASFContentInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, piprofile: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetProfile(&*(&piprofile as *const <IMFASFProfile as ::windows::core::Abi>::Abi as *const <IMFASFProfile as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GeneratePresentationDescriptor<Impl: IMFASFContentInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppipresentationdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GeneratePresentationDescriptor(::core::mem::transmute_copy(&ppipresentationdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEncodingConfigurationPropertyStore<Impl: IMFASFContentInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wstreamnumber: u16, ppistore: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEncodingConfigurationPropertyStore(wstreamnumber, ::core::mem::transmute_copy(&ppistore)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFASFContentInfo>, base.5, GetHeaderSize::<Impl, OFFSET>, ParseHeader::<Impl, OFFSET>, GenerateHeader::<Impl, OFFSET>, GetProfile::<Impl, OFFSET>, SetProfile::<Impl, OFFSET>, GeneratePresentationDescriptor::<Impl, OFFSET>, GetEncodingConfigurationPropertyStore::<Impl, OFFSET>)
    }
}
pub trait IMFASFIndexerImpl: Sized {
    fn SetFlags();
    fn GetFlags();
    fn Initialize();
    fn GetIndexPosition();
    fn SetIndexByteStreams();
    fn GetIndexByteStreamCount();
    fn GetIndexStatus();
    fn SetIndexStatus();
    fn GetSeekPositionForValue();
    fn GenerateIndexEntries();
    fn CommitIndex();
    fn GetIndexWriteSpace();
    fn GetCompletedIndex();
}
impl ::windows::core::RuntimeName for IMFASFIndexer {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFASFIndexer";
}
impl IMFASFIndexerVtbl {
    pub const fn new<Impl: IMFASFIndexerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFASFIndexerVtbl {
        unsafe extern "system" fn SetFlags<Impl: IMFASFIndexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFlags(dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFlags<Impl: IMFASFIndexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFlags(::core::mem::transmute_copy(&pdwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Initialize<Impl: IMFASFIndexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, picontentinfo: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&picontentinfo as *const <IMFASFContentInfo as ::windows::core::Abi>::Abi as *const <IMFASFContentInfo as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIndexPosition<Impl: IMFASFIndexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, picontentinfo: ::windows::core::RawPtr, pcbindexoffset: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIndexPosition(&*(&picontentinfo as *const <IMFASFContentInfo as ::windows::core::Abi>::Abi as *const <IMFASFContentInfo as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pcbindexoffset)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIndexByteStreams<Impl: IMFASFIndexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppibytestreams: *const ::windows::core::RawPtr, cbytestreams: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetIndexByteStreams(&*(&ppibytestreams as *const <IMFByteStream as ::windows::core::Abi>::Abi as *const <IMFByteStream as ::windows::core::DefaultType>::DefaultType), cbytestreams) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIndexByteStreamCount<Impl: IMFASFIndexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcbytestreams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIndexByteStreamCount(::core::mem::transmute_copy(&pcbytestreams)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIndexStatus<Impl: IMFASFIndexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pindexidentifier: *const ASF_INDEX_IDENTIFIER, pfisindexed: *mut super::super::Foundation::BOOL, pbindexdescriptor: *mut u8, pcbindexdescriptor: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIndexStatus(&*(&pindexidentifier as *const <ASF_INDEX_IDENTIFIER as ::windows::core::Abi>::Abi as *const <ASF_INDEX_IDENTIFIER as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pfisindexed), ::core::mem::transmute_copy(&pbindexdescriptor), pcbindexdescriptor) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIndexStatus<Impl: IMFASFIndexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbindexdescriptor: *const u8, cbindexdescriptor: u32, fgenerateindex: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetIndexStatus(pbindexdescriptor, cbindexdescriptor, &*(&fgenerateindex as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSeekPositionForValue<Impl: IMFASFIndexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvarvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pindexidentifier: *const ASF_INDEX_IDENTIFIER, pcboffsetwithindata: *mut u64, phnsapproxtime: *mut i64, pdwpayloadnumberofstreamwithinpacket: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSeekPositionForValue(
                &*(&pvarvalue as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::DefaultType>::DefaultType),
                &*(&pindexidentifier as *const <ASF_INDEX_IDENTIFIER as ::windows::core::Abi>::Abi as *const <ASF_INDEX_IDENTIFIER as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&pcboffsetwithindata),
                phnsapproxtime,
                pdwpayloadnumberofstreamwithinpacket,
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GenerateIndexEntries<Impl: IMFASFIndexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, piasfpacketsample: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GenerateIndexEntries(&*(&piasfpacketsample as *const <IMFSample as ::windows::core::Abi>::Abi as *const <IMFSample as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CommitIndex<Impl: IMFASFIndexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, picontentinfo: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CommitIndex(&*(&picontentinfo as *const <IMFASFContentInfo as ::windows::core::Abi>::Abi as *const <IMFASFContentInfo as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIndexWriteSpace<Impl: IMFASFIndexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcbindexwritespace: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIndexWriteSpace(::core::mem::transmute_copy(&pcbindexwritespace)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCompletedIndex<Impl: IMFASFIndexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, piindexbuffer: ::windows::core::RawPtr, cboffsetwithinindex: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCompletedIndex(&*(&piindexbuffer as *const <IMFMediaBuffer as ::windows::core::Abi>::Abi as *const <IMFMediaBuffer as ::windows::core::DefaultType>::DefaultType), cboffsetwithinindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMFASFIndexer>,
            base.5,
            SetFlags::<Impl, OFFSET>,
            GetFlags::<Impl, OFFSET>,
            Initialize::<Impl, OFFSET>,
            GetIndexPosition::<Impl, OFFSET>,
            SetIndexByteStreams::<Impl, OFFSET>,
            GetIndexByteStreamCount::<Impl, OFFSET>,
            GetIndexStatus::<Impl, OFFSET>,
            SetIndexStatus::<Impl, OFFSET>,
            GetSeekPositionForValue::<Impl, OFFSET>,
            GenerateIndexEntries::<Impl, OFFSET>,
            CommitIndex::<Impl, OFFSET>,
            GetIndexWriteSpace::<Impl, OFFSET>,
            GetCompletedIndex::<Impl, OFFSET>,
        )
    }
}
pub trait IMFASFMultiplexerImpl: Sized {
    fn Initialize();
    fn SetFlags();
    fn GetFlags();
    fn ProcessSample();
    fn GetNextPacket();
    fn Flush();
    fn End();
    fn GetStatistics();
    fn SetSyncTolerance();
}
impl ::windows::core::RuntimeName for IMFASFMultiplexer {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFASFMultiplexer";
}
impl IMFASFMultiplexerVtbl {
    pub const fn new<Impl: IMFASFMultiplexerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFASFMultiplexerVtbl {
        unsafe extern "system" fn Initialize<Impl: IMFASFMultiplexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, picontentinfo: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&picontentinfo as *const <IMFASFContentInfo as ::windows::core::Abi>::Abi as *const <IMFASFContentInfo as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFlags<Impl: IMFASFMultiplexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFlags(dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFlags<Impl: IMFASFMultiplexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFlags(::core::mem::transmute_copy(&pdwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProcessSample<Impl: IMFASFMultiplexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wstreamnumber: u16, pisample: ::windows::core::RawPtr, hnstimestampadjust: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProcessSample(wstreamnumber, &*(&pisample as *const <IMFSample as ::windows::core::Abi>::Abi as *const <IMFSample as ::windows::core::DefaultType>::DefaultType), hnstimestampadjust) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNextPacket<Impl: IMFASFMultiplexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwstatusflags: *mut u32, ppipacket: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNextPacket(::core::mem::transmute_copy(&pdwstatusflags), ::core::mem::transmute_copy(&ppipacket)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Flush<Impl: IMFASFMultiplexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Flush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn End<Impl: IMFASFMultiplexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, picontentinfo: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).End(&*(&picontentinfo as *const <IMFASFContentInfo as ::windows::core::Abi>::Abi as *const <IMFASFContentInfo as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStatistics<Impl: IMFASFMultiplexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wstreamnumber: u16, pmuxstats: *mut ASF_MUX_STATISTICS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStatistics(wstreamnumber, ::core::mem::transmute_copy(&pmuxstats)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSyncTolerance<Impl: IMFASFMultiplexerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mssynctolerance: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSyncTolerance(mssynctolerance) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFASFMultiplexer>, base.5, Initialize::<Impl, OFFSET>, SetFlags::<Impl, OFFSET>, GetFlags::<Impl, OFFSET>, ProcessSample::<Impl, OFFSET>, GetNextPacket::<Impl, OFFSET>, Flush::<Impl, OFFSET>, End::<Impl, OFFSET>, GetStatistics::<Impl, OFFSET>, SetSyncTolerance::<Impl, OFFSET>)
    }
}
pub trait IMFASFMutualExclusionImpl: Sized {
    fn GetType();
    fn SetType();
    fn GetRecordCount();
    fn GetStreamsForRecord();
    fn AddStreamForRecord();
    fn RemoveStreamFromRecord();
    fn RemoveRecord();
    fn AddRecord();
    fn Clone();
}
impl ::windows::core::RuntimeName for IMFASFMutualExclusion {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFASFMutualExclusion";
}
impl IMFASFMutualExclusionVtbl {
    pub const fn new<Impl: IMFASFMutualExclusionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFASFMutualExclusionVtbl {
        unsafe extern "system" fn GetType<Impl: IMFASFMutualExclusionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguidtype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetType(::core::mem::transmute_copy(&pguidtype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetType<Impl: IMFASFMutualExclusionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidtype: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetType(&*(&guidtype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRecordCount<Impl: IMFASFMutualExclusionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwrecordcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRecordCount(::core::mem::transmute_copy(&pdwrecordcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamsForRecord<Impl: IMFASFMutualExclusionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordnumber: u32, pwstreamnumarray: *mut u16, pcstreams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamsForRecord(dwrecordnumber, ::core::mem::transmute_copy(&pwstreamnumarray), pcstreams) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddStreamForRecord<Impl: IMFASFMutualExclusionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordnumber: u32, wstreamnumber: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddStreamForRecord(dwrecordnumber, wstreamnumber) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveStreamFromRecord<Impl: IMFASFMutualExclusionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordnumber: u32, wstreamnumber: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveStreamFromRecord(dwrecordnumber, wstreamnumber) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveRecord<Impl: IMFASFMutualExclusionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrecordnumber: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveRecord(dwrecordnumber) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddRecord<Impl: IMFASFMutualExclusionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwrecordnumber: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddRecord(::core::mem::transmute_copy(&pdwrecordnumber)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IMFASFMutualExclusionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppimutex: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&ppimutex)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFASFMutualExclusion>, base.5, GetType::<Impl, OFFSET>, SetType::<Impl, OFFSET>, GetRecordCount::<Impl, OFFSET>, GetStreamsForRecord::<Impl, OFFSET>, AddStreamForRecord::<Impl, OFFSET>, RemoveStreamFromRecord::<Impl, OFFSET>, RemoveRecord::<Impl, OFFSET>, AddRecord::<Impl, OFFSET>, Clone::<Impl, OFFSET>)
    }
}
pub trait IMFASFProfileImpl: Sized + IMFAttributesImpl {
    fn GetStreamCount();
    fn GetStream();
    fn GetStreamByNumber();
    fn SetStream();
    fn RemoveStream();
    fn CreateStream();
    fn GetMutualExclusionCount();
    fn GetMutualExclusion();
    fn AddMutualExclusion();
    fn RemoveMutualExclusion();
    fn CreateMutualExclusion();
    fn GetStreamPrioritization();
    fn AddStreamPrioritization();
    fn RemoveStreamPrioritization();
    fn CreateStreamPrioritization();
    fn Clone();
}
impl ::windows::core::RuntimeName for IMFASFProfile {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFASFProfile";
}
impl IMFASFProfileVtbl {
    pub const fn new<Impl: IMFASFProfileImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFASFProfileVtbl {
        unsafe extern "system" fn GetStreamCount<Impl: IMFASFProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcstreams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamCount(::core::mem::transmute_copy(&pcstreams)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStream<Impl: IMFASFProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pwstreamnumber: *mut u16, ppistream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStream(dwstreamindex, ::core::mem::transmute_copy(&pwstreamnumber), ::core::mem::transmute_copy(&ppistream)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamByNumber<Impl: IMFASFProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wstreamnumber: u16, ppistream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamByNumber(wstreamnumber, ::core::mem::transmute_copy(&ppistream)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStream<Impl: IMFASFProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pistream: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStream(&*(&pistream as *const <IMFASFStreamConfig as ::windows::core::Abi>::Abi as *const <IMFASFStreamConfig as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveStream<Impl: IMFASFProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wstreamnumber: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveStream(wstreamnumber) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateStream<Impl: IMFASFProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pimediatype: ::windows::core::RawPtr, ppistream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateStream(&*(&pimediatype as *const <IMFMediaType as ::windows::core::Abi>::Abi as *const <IMFMediaType as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppistream)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMutualExclusionCount<Impl: IMFASFProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcmutexs: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMutualExclusionCount(::core::mem::transmute_copy(&pcmutexs)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMutualExclusion<Impl: IMFASFProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwmutexindex: u32, ppimutex: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMutualExclusion(dwmutexindex, ::core::mem::transmute_copy(&ppimutex)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddMutualExclusion<Impl: IMFASFProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pimutex: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddMutualExclusion(&*(&pimutex as *const <IMFASFMutualExclusion as ::windows::core::Abi>::Abi as *const <IMFASFMutualExclusion as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveMutualExclusion<Impl: IMFASFProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwmutexindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveMutualExclusion(dwmutexindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateMutualExclusion<Impl: IMFASFProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppimutex: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateMutualExclusion(::core::mem::transmute_copy(&ppimutex)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamPrioritization<Impl: IMFASFProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppistreamprioritization: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamPrioritization(::core::mem::transmute_copy(&ppistreamprioritization)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddStreamPrioritization<Impl: IMFASFProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pistreamprioritization: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddStreamPrioritization(&*(&pistreamprioritization as *const <IMFASFStreamPrioritization as ::windows::core::Abi>::Abi as *const <IMFASFStreamPrioritization as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveStreamPrioritization<Impl: IMFASFProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveStreamPrioritization() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateStreamPrioritization<Impl: IMFASFProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppistreamprioritization: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateStreamPrioritization(::core::mem::transmute_copy(&ppistreamprioritization)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IMFASFProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppiprofile: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&ppiprofile)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMFASFProfile>,
            base.5,
            GetStreamCount::<Impl, OFFSET>,
            GetStream::<Impl, OFFSET>,
            GetStreamByNumber::<Impl, OFFSET>,
            SetStream::<Impl, OFFSET>,
            RemoveStream::<Impl, OFFSET>,
            CreateStream::<Impl, OFFSET>,
            GetMutualExclusionCount::<Impl, OFFSET>,
            GetMutualExclusion::<Impl, OFFSET>,
            AddMutualExclusion::<Impl, OFFSET>,
            RemoveMutualExclusion::<Impl, OFFSET>,
            CreateMutualExclusion::<Impl, OFFSET>,
            GetStreamPrioritization::<Impl, OFFSET>,
            AddStreamPrioritization::<Impl, OFFSET>,
            RemoveStreamPrioritization::<Impl, OFFSET>,
            CreateStreamPrioritization::<Impl, OFFSET>,
            Clone::<Impl, OFFSET>,
        )
    }
}
pub trait IMFASFSplitterImpl: Sized {
    fn Initialize();
    fn SetFlags();
    fn GetFlags();
    fn SelectStreams();
    fn GetSelectedStreams();
    fn ParseData();
    fn GetNextSample();
    fn Flush();
    fn GetLastSendTime();
}
impl ::windows::core::RuntimeName for IMFASFSplitter {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFASFSplitter";
}
impl IMFASFSplitterVtbl {
    pub const fn new<Impl: IMFASFSplitterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFASFSplitterVtbl {
        unsafe extern "system" fn Initialize<Impl: IMFASFSplitterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, picontentinfo: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&picontentinfo as *const <IMFASFContentInfo as ::windows::core::Abi>::Abi as *const <IMFASFContentInfo as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFlags<Impl: IMFASFSplitterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFlags(dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFlags<Impl: IMFASFSplitterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFlags(::core::mem::transmute_copy(&pdwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectStreams<Impl: IMFASFSplitterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwstreamnumbers: *const u16, wnumstreams: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectStreams(pwstreamnumbers, wnumstreams) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSelectedStreams<Impl: IMFASFSplitterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwstreamnumbers: *mut u16, pwnumstreams: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSelectedStreams(::core::mem::transmute_copy(&pwstreamnumbers), pwnumstreams) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ParseData<Impl: IMFASFSplitterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pibuffer: ::windows::core::RawPtr, cbbufferoffset: u32, cblength: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ParseData(&*(&pibuffer as *const <IMFMediaBuffer as ::windows::core::Abi>::Abi as *const <IMFMediaBuffer as ::windows::core::DefaultType>::DefaultType), cbbufferoffset, cblength) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNextSample<Impl: IMFASFSplitterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwstatusflags: *mut ASF_STATUSFLAGS, pwstreamnumber: *mut u16, ppisample: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNextSample(::core::mem::transmute_copy(&pdwstatusflags), ::core::mem::transmute_copy(&pwstreamnumber), ::core::mem::transmute_copy(&ppisample)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Flush<Impl: IMFASFSplitterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Flush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLastSendTime<Impl: IMFASFSplitterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwlastsendtime: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLastSendTime(::core::mem::transmute_copy(&pdwlastsendtime)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFASFSplitter>, base.5, Initialize::<Impl, OFFSET>, SetFlags::<Impl, OFFSET>, GetFlags::<Impl, OFFSET>, SelectStreams::<Impl, OFFSET>, GetSelectedStreams::<Impl, OFFSET>, ParseData::<Impl, OFFSET>, GetNextSample::<Impl, OFFSET>, Flush::<Impl, OFFSET>, GetLastSendTime::<Impl, OFFSET>)
    }
}
pub trait IMFASFStreamConfigImpl: Sized + IMFAttributesImpl {
    fn GetStreamType();
    fn GetStreamNumber();
    fn SetStreamNumber();
    fn GetMediaType();
    fn SetMediaType();
    fn GetPayloadExtensionCount();
    fn GetPayloadExtension();
    fn AddPayloadExtension();
    fn RemoveAllPayloadExtensions();
    fn Clone();
}
impl ::windows::core::RuntimeName for IMFASFStreamConfig {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFASFStreamConfig";
}
impl IMFASFStreamConfigVtbl {
    pub const fn new<Impl: IMFASFStreamConfigImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFASFStreamConfigVtbl {
        unsafe extern "system" fn GetStreamType<Impl: IMFASFStreamConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguidstreamtype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamType(::core::mem::transmute_copy(&pguidstreamtype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamNumber<Impl: IMFASFStreamConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u16 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamNumber() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamNumber<Impl: IMFASFStreamConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wstreamnum: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStreamNumber(wstreamnum) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaType<Impl: IMFASFStreamConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppimediatype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMediaType(::core::mem::transmute_copy(&ppimediatype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaType<Impl: IMFASFStreamConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pimediatype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMediaType(&*(&pimediatype as *const <IMFMediaType as ::windows::core::Abi>::Abi as *const <IMFMediaType as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPayloadExtensionCount<Impl: IMFASFStreamConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcpayloadextensions: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPayloadExtensionCount(::core::mem::transmute_copy(&pcpayloadextensions)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPayloadExtension<Impl: IMFASFStreamConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wpayloadextensionnumber: u16, pguidextensionsystemid: *mut ::windows::core::GUID, pcbextensiondatasize: *mut u16, pbextensionsysteminfo: *mut u8, pcbextensionsysteminfo: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPayloadExtension(wpayloadextensionnumber, ::core::mem::transmute_copy(&pguidextensionsystemid), ::core::mem::transmute_copy(&pcbextensiondatasize), pbextensionsysteminfo, pcbextensionsysteminfo) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddPayloadExtension<Impl: IMFASFStreamConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidextensionsystemid: ::windows::core::GUID, cbextensiondatasize: u16, pbextensionsysteminfo: *const u8, cbextensionsysteminfo: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddPayloadExtension(&*(&guidextensionsystemid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), cbextensiondatasize, pbextensionsysteminfo, cbextensionsysteminfo) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveAllPayloadExtensions<Impl: IMFASFStreamConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveAllPayloadExtensions() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IMFASFStreamConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppistreamconfig: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&ppistreamconfig)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFASFStreamConfig>, base.5, GetStreamType::<Impl, OFFSET>, GetStreamNumber::<Impl, OFFSET>, SetStreamNumber::<Impl, OFFSET>, GetMediaType::<Impl, OFFSET>, SetMediaType::<Impl, OFFSET>, GetPayloadExtensionCount::<Impl, OFFSET>, GetPayloadExtension::<Impl, OFFSET>, AddPayloadExtension::<Impl, OFFSET>, RemoveAllPayloadExtensions::<Impl, OFFSET>, Clone::<Impl, OFFSET>)
    }
}
pub trait IMFASFStreamPrioritizationImpl: Sized {
    fn GetStreamCount();
    fn GetStream();
    fn AddStream();
    fn RemoveStream();
    fn Clone();
}
impl ::windows::core::RuntimeName for IMFASFStreamPrioritization {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFASFStreamPrioritization";
}
impl IMFASFStreamPrioritizationVtbl {
    pub const fn new<Impl: IMFASFStreamPrioritizationImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFASFStreamPrioritizationVtbl {
        unsafe extern "system" fn GetStreamCount<Impl: IMFASFStreamPrioritizationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwstreamcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamCount(::core::mem::transmute_copy(&pdwstreamcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStream<Impl: IMFASFStreamPrioritizationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pwstreamnumber: *mut u16, pwstreamflags: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStream(dwstreamindex, ::core::mem::transmute_copy(&pwstreamnumber), ::core::mem::transmute_copy(&pwstreamflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddStream<Impl: IMFASFStreamPrioritizationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wstreamnumber: u16, wstreamflags: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddStream(wstreamnumber, wstreamflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveStream<Impl: IMFASFStreamPrioritizationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveStream(dwstreamindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IMFASFStreamPrioritizationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppistreamprioritization: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&ppistreamprioritization)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFASFStreamPrioritization>, base.5, GetStreamCount::<Impl, OFFSET>, GetStream::<Impl, OFFSET>, AddStream::<Impl, OFFSET>, RemoveStream::<Impl, OFFSET>, Clone::<Impl, OFFSET>)
    }
}
pub trait IMFASFStreamSelectorImpl: Sized {
    fn GetStreamCount();
    fn GetOutputCount();
    fn GetOutputStreamCount();
    fn GetOutputStreamNumbers();
    fn GetOutputFromStream();
    fn GetOutputOverride();
    fn SetOutputOverride();
    fn GetOutputMutexCount();
    fn GetOutputMutex();
    fn SetOutputMutexSelection();
    fn GetBandwidthStepCount();
    fn GetBandwidthStep();
    fn BitrateToStepNumber();
    fn SetStreamSelectorFlags();
}
impl ::windows::core::RuntimeName for IMFASFStreamSelector {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFASFStreamSelector";
}
impl IMFASFStreamSelectorVtbl {
    pub const fn new<Impl: IMFASFStreamSelectorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFASFStreamSelectorVtbl {
        unsafe extern "system" fn GetStreamCount<Impl: IMFASFStreamSelectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcstreams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamCount(::core::mem::transmute_copy(&pcstreams)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputCount<Impl: IMFASFStreamSelectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcoutputs: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputCount(::core::mem::transmute_copy(&pcoutputs)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputStreamCount<Impl: IMFASFStreamSelectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwoutputnum: u32, pcstreams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputStreamCount(dwoutputnum, ::core::mem::transmute_copy(&pcstreams)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputStreamNumbers<Impl: IMFASFStreamSelectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwoutputnum: u32, rgwstreamnumbers: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputStreamNumbers(dwoutputnum, ::core::mem::transmute_copy(&rgwstreamnumbers)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputFromStream<Impl: IMFASFStreamSelectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wstreamnum: u16, pdwoutput: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputFromStream(wstreamnum, ::core::mem::transmute_copy(&pdwoutput)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputOverride<Impl: IMFASFStreamSelectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwoutputnum: u32, pselection: *mut ASF_SELECTION_STATUS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputOverride(dwoutputnum, ::core::mem::transmute_copy(&pselection)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputOverride<Impl: IMFASFStreamSelectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwoutputnum: u32, selection: ASF_SELECTION_STATUS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputOverride(dwoutputnum, selection) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputMutexCount<Impl: IMFASFStreamSelectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwoutputnum: u32, pcmutexes: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputMutexCount(dwoutputnum, ::core::mem::transmute_copy(&pcmutexes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputMutex<Impl: IMFASFStreamSelectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwoutputnum: u32, dwmutexnum: u32, ppmutex: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputMutex(dwoutputnum, dwmutexnum, ::core::mem::transmute_copy(&ppmutex)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputMutexSelection<Impl: IMFASFStreamSelectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwoutputnum: u32, dwmutexnum: u32, wselectedrecord: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputMutexSelection(dwoutputnum, dwmutexnum, wselectedrecord) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBandwidthStepCount<Impl: IMFASFStreamSelectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcstepcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBandwidthStepCount(::core::mem::transmute_copy(&pcstepcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBandwidthStep<Impl: IMFASFStreamSelectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstepnum: u32, pdwbitrate: *mut u32, rgwstreamnumbers: *mut u16, rgselections: *mut ASF_SELECTION_STATUS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBandwidthStep(dwstepnum, ::core::mem::transmute_copy(&pdwbitrate), ::core::mem::transmute_copy(&rgwstreamnumbers), ::core::mem::transmute_copy(&rgselections)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BitrateToStepNumber<Impl: IMFASFStreamSelectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwbitrate: u32, pdwstepnum: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BitrateToStepNumber(dwbitrate, ::core::mem::transmute_copy(&pdwstepnum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamSelectorFlags<Impl: IMFASFStreamSelectorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamselectorflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStreamSelectorFlags(dwstreamselectorflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMFASFStreamSelector>,
            base.5,
            GetStreamCount::<Impl, OFFSET>,
            GetOutputCount::<Impl, OFFSET>,
            GetOutputStreamCount::<Impl, OFFSET>,
            GetOutputStreamNumbers::<Impl, OFFSET>,
            GetOutputFromStream::<Impl, OFFSET>,
            GetOutputOverride::<Impl, OFFSET>,
            SetOutputOverride::<Impl, OFFSET>,
            GetOutputMutexCount::<Impl, OFFSET>,
            GetOutputMutex::<Impl, OFFSET>,
            SetOutputMutexSelection::<Impl, OFFSET>,
            GetBandwidthStepCount::<Impl, OFFSET>,
            GetBandwidthStep::<Impl, OFFSET>,
            BitrateToStepNumber::<Impl, OFFSET>,
            SetStreamSelectorFlags::<Impl, OFFSET>,
        )
    }
}
pub trait IMFActivateImpl: Sized + IMFAttributesImpl {
    fn ActivateObject();
    fn ShutdownObject();
    fn DetachObject();
}
impl ::windows::core::RuntimeName for IMFActivate {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFActivate";
}
impl IMFActivateVtbl {
    pub const fn new<Impl: IMFActivateImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFActivateVtbl {
        unsafe extern "system" fn ActivateObject<Impl: IMFActivateImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ActivateObject(&*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppv)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ShutdownObject<Impl: IMFActivateImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShutdownObject() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DetachObject<Impl: IMFActivateImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DetachObject() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFActivate>, base.5, ActivateObject::<Impl, OFFSET>, ShutdownObject::<Impl, OFFSET>, DetachObject::<Impl, OFFSET>)
    }
}
pub trait IMFAsyncCallbackImpl: Sized {
    fn GetParameters();
    fn Invoke();
}
impl ::windows::core::RuntimeName for IMFAsyncCallback {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFAsyncCallback";
}
impl IMFAsyncCallbackVtbl {
    pub const fn new<Impl: IMFAsyncCallbackImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFAsyncCallbackVtbl {
        unsafe extern "system" fn GetParameters<Impl: IMFAsyncCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwflags: *mut u32, pdwqueue: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetParameters(::core::mem::transmute_copy(&pdwflags), ::core::mem::transmute_copy(&pdwqueue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Invoke<Impl: IMFAsyncCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pasyncresult: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Invoke(&*(&pasyncresult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFAsyncCallback>, base.5, GetParameters::<Impl, OFFSET>, Invoke::<Impl, OFFSET>)
    }
}
pub trait IMFAsyncCallbackLoggingImpl: Sized + IMFAsyncCallbackImpl {
    fn GetObjectPointer();
    fn GetObjectTag();
}
impl ::windows::core::RuntimeName for IMFAsyncCallbackLogging {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFAsyncCallbackLogging";
}
impl IMFAsyncCallbackLoggingVtbl {
    pub const fn new<Impl: IMFAsyncCallbackLoggingImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFAsyncCallbackLoggingVtbl {
        unsafe extern "system" fn GetObjectPointer<Impl: IMFAsyncCallbackLoggingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetObjectPointer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetObjectTag<Impl: IMFAsyncCallbackLoggingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetObjectTag() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFAsyncCallbackLogging>, base.5, GetObjectPointer::<Impl, OFFSET>, GetObjectTag::<Impl, OFFSET>)
    }
}
pub trait IMFAsyncResultImpl: Sized {
    fn GetState();
    fn GetStatus();
    fn SetStatus();
    fn GetObject();
    fn GetStateNoAddRef();
}
impl ::windows::core::RuntimeName for IMFAsyncResult {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFAsyncResult";
}
impl IMFAsyncResultVtbl {
    pub const fn new<Impl: IMFAsyncResultImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFAsyncResultVtbl {
        unsafe extern "system" fn GetState<Impl: IMFAsyncResultImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppunkstate: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetState(::core::mem::transmute_copy(&ppunkstate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStatus<Impl: IMFAsyncResultImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStatus() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStatus<Impl: IMFAsyncResultImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hrstatus: ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStatus(hrstatus) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetObject<Impl: IMFAsyncResultImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetObject(::core::mem::transmute_copy(&ppobject)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStateNoAddRef<Impl: IMFAsyncResultImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::core::option::Option<::windows::core::IUnknown> {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStateNoAddRef() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFAsyncResult>, base.5, GetState::<Impl, OFFSET>, GetStatus::<Impl, OFFSET>, SetStatus::<Impl, OFFSET>, GetObject::<Impl, OFFSET>, GetStateNoAddRef::<Impl, OFFSET>)
    }
}
pub trait IMFAttributesImpl: Sized {
    fn GetItem();
    fn GetItemType();
    fn CompareItem();
    fn Compare();
    fn GetUINT32();
    fn GetUINT64();
    fn GetDouble();
    fn GetGUID();
    fn GetStringLength();
    fn GetString();
    fn GetAllocatedString();
    fn GetBlobSize();
    fn GetBlob();
    fn GetAllocatedBlob();
    fn GetUnknown();
    fn SetItem();
    fn DeleteItem();
    fn DeleteAllItems();
    fn SetUINT32();
    fn SetUINT64();
    fn SetDouble();
    fn SetGUID();
    fn SetString();
    fn SetBlob();
    fn SetUnknown();
    fn LockStore();
    fn UnlockStore();
    fn GetCount();
    fn GetItemByIndex();
    fn CopyAllItems();
}
impl ::windows::core::RuntimeName for IMFAttributes {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFAttributes";
}
impl IMFAttributesVtbl {
    pub const fn new<Impl: IMFAttributesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFAttributesVtbl {
        unsafe extern "system" fn GetItem<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetItem(&*(&guidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&pvalue as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetItemType<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, ptype: *mut MF_ATTRIBUTE_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetItemType(&*(&guidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ptype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompareItem<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pbresult: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CompareItem(&*(&guidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pbresult)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Compare<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptheirs: ::windows::core::RawPtr, matchtype: MF_ATTRIBUTES_MATCH_TYPE, pbresult: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Compare(&*(&ptheirs as *const <IMFAttributes as ::windows::core::Abi>::Abi as *const <IMFAttributes as ::windows::core::DefaultType>::DefaultType), matchtype, ::core::mem::transmute_copy(&pbresult)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetUINT32<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, punvalue: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetUINT32(&*(&guidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&punvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetUINT64<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, punvalue: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetUINT64(&*(&guidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&punvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDouble<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pfvalue: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDouble(&*(&guidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pfvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetGUID<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pguidvalue: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetGUID(&*(&guidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pguidvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStringLength<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pcchlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStringLength(&*(&guidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pcchlength)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetString<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pwszvalue: super::super::Foundation::PWSTR, cchbufsize: u32, pcchlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetString(&*(&guidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pwszvalue), cchbufsize, pcchlength) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAllocatedString<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, ppwszvalue: *mut super::super::Foundation::PWSTR, pcchlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAllocatedString(&*(&guidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppwszvalue), ::core::mem::transmute_copy(&pcchlength)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBlobSize<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pcbblobsize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBlobSize(&*(&guidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pcbblobsize)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBlob<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pbuf: *mut u8, cbbufsize: u32, pcbblobsize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBlob(&*(&guidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pbuf), cbbufsize, pcbblobsize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAllocatedBlob<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAllocatedBlob(&*(&guidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppbuf), ::core::mem::transmute_copy(&pcbsize)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetUnknown<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetUnknown(&*(&guidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppv)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetItem<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetItem(&*(&guidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&value as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DeleteItem<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DeleteItem(&*(&guidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DeleteAllItems<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DeleteAllItems() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUINT32<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, unvalue: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetUINT32(&*(&guidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), unvalue) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUINT64<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, unvalue: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetUINT64(&*(&guidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), unvalue) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDouble<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, fvalue: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDouble(&*(&guidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), fvalue) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGUID<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, guidvalue: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetGUID(&*(&guidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&guidvalue as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetString<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, wszvalue: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetString(&*(&guidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&wszvalue as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBlob<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pbuf: *const u8, cbbufsize: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBlob(&*(&guidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), pbuf, cbbufsize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUnknown<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, punknown: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetUnknown(&*(&guidkey as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&punknown as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LockStore<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LockStore() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnlockStore<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnlockStore() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCount<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcitems: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCount(::core::mem::transmute_copy(&pcitems)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetItemByIndex<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, unindex: u32, pguidkey: *mut ::windows::core::GUID, pvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetItemByIndex(unindex, ::core::mem::transmute_copy(&pguidkey), &*(&pvalue as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CopyAllItems<Impl: IMFAttributesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdest: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CopyAllItems(&*(&pdest as *const <IMFAttributes as ::windows::core::Abi>::Abi as *const <IMFAttributes as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMFAttributes>,
            base.5,
            GetItem::<Impl, OFFSET>,
            GetItemType::<Impl, OFFSET>,
            CompareItem::<Impl, OFFSET>,
            Compare::<Impl, OFFSET>,
            GetUINT32::<Impl, OFFSET>,
            GetUINT64::<Impl, OFFSET>,
            GetDouble::<Impl, OFFSET>,
            GetGUID::<Impl, OFFSET>,
            GetStringLength::<Impl, OFFSET>,
            GetString::<Impl, OFFSET>,
            GetAllocatedString::<Impl, OFFSET>,
            GetBlobSize::<Impl, OFFSET>,
            GetBlob::<Impl, OFFSET>,
            GetAllocatedBlob::<Impl, OFFSET>,
            GetUnknown::<Impl, OFFSET>,
            SetItem::<Impl, OFFSET>,
            DeleteItem::<Impl, OFFSET>,
            DeleteAllItems::<Impl, OFFSET>,
            SetUINT32::<Impl, OFFSET>,
            SetUINT64::<Impl, OFFSET>,
            SetDouble::<Impl, OFFSET>,
            SetGUID::<Impl, OFFSET>,
            SetString::<Impl, OFFSET>,
            SetBlob::<Impl, OFFSET>,
            SetUnknown::<Impl, OFFSET>,
            LockStore::<Impl, OFFSET>,
            UnlockStore::<Impl, OFFSET>,
            GetCount::<Impl, OFFSET>,
            GetItemByIndex::<Impl, OFFSET>,
            CopyAllItems::<Impl, OFFSET>,
        )
    }
}
pub trait IMFAudioMediaTypeImpl: Sized + IMFMediaTypeImpl + IMFAttributesImpl {
    fn GetAudioFormat();
}
impl ::windows::core::RuntimeName for IMFAudioMediaType {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFAudioMediaType";
}
impl IMFAudioMediaTypeVtbl {
    pub const fn new<Impl: IMFAudioMediaTypeImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFAudioMediaTypeVtbl {
        unsafe extern "system" fn GetAudioFormat<Impl: IMFAudioMediaTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> *mut super::Audio::WAVEFORMATEX {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAudioFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFAudioMediaType>, base.5, GetAudioFormat::<Impl, OFFSET>)
    }
}
pub trait IMFAudioPolicyImpl: Sized {
    fn SetGroupingParam();
    fn GetGroupingParam();
    fn SetDisplayName();
    fn GetDisplayName();
    fn SetIconPath();
    fn GetIconPath();
}
impl ::windows::core::RuntimeName for IMFAudioPolicy {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFAudioPolicy";
}
impl IMFAudioPolicyVtbl {
    pub const fn new<Impl: IMFAudioPolicyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFAudioPolicyVtbl {
        unsafe extern "system" fn SetGroupingParam<Impl: IMFAudioPolicyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, rguidclass: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetGroupingParam(&*(&rguidclass as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetGroupingParam<Impl: IMFAudioPolicyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguidclass: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetGroupingParam(::core::mem::transmute_copy(&pguidclass)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisplayName<Impl: IMFAudioPolicyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszname: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDisplayName(&*(&pszname as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDisplayName<Impl: IMFAudioPolicyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszname: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDisplayName(::core::mem::transmute_copy(&pszname)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIconPath<Impl: IMFAudioPolicyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszpath: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetIconPath(&*(&pszpath as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIconPath<Impl: IMFAudioPolicyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszpath: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIconPath(::core::mem::transmute_copy(&pszpath)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFAudioPolicy>, base.5, SetGroupingParam::<Impl, OFFSET>, GetGroupingParam::<Impl, OFFSET>, SetDisplayName::<Impl, OFFSET>, GetDisplayName::<Impl, OFFSET>, SetIconPath::<Impl, OFFSET>, GetIconPath::<Impl, OFFSET>)
    }
}
pub trait IMFAudioStreamVolumeImpl: Sized {
    fn GetChannelCount();
    fn SetChannelVolume();
    fn GetChannelVolume();
    fn SetAllVolumes();
    fn GetAllVolumes();
}
impl ::windows::core::RuntimeName for IMFAudioStreamVolume {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFAudioStreamVolume";
}
impl IMFAudioStreamVolumeVtbl {
    pub const fn new<Impl: IMFAudioStreamVolumeImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFAudioStreamVolumeVtbl {
        unsafe extern "system" fn GetChannelCount<Impl: IMFAudioStreamVolumeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetChannelCount(::core::mem::transmute_copy(&pdwcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChannelVolume<Impl: IMFAudioStreamVolumeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, flevel: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetChannelVolume(dwindex, flevel) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetChannelVolume<Impl: IMFAudioStreamVolumeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, pflevel: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetChannelVolume(dwindex, ::core::mem::transmute_copy(&pflevel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAllVolumes<Impl: IMFAudioStreamVolumeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwcount: u32, pfvolumes: *const f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAllVolumes(dwcount, pfvolumes) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAllVolumes<Impl: IMFAudioStreamVolumeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwcount: u32, pfvolumes: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAllVolumes(dwcount, ::core::mem::transmute_copy(&pfvolumes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFAudioStreamVolume>, base.5, GetChannelCount::<Impl, OFFSET>, SetChannelVolume::<Impl, OFFSET>, GetChannelVolume::<Impl, OFFSET>, SetAllVolumes::<Impl, OFFSET>, GetAllVolumes::<Impl, OFFSET>)
    }
}
pub trait IMFBufferListNotifyImpl: Sized {
    fn OnAddSourceBuffer();
    fn OnRemoveSourceBuffer();
}
impl ::windows::core::RuntimeName for IMFBufferListNotify {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFBufferListNotify";
}
impl IMFBufferListNotifyVtbl {
    pub const fn new<Impl: IMFBufferListNotifyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFBufferListNotifyVtbl {
        unsafe extern "system" fn OnAddSourceBuffer<Impl: IMFBufferListNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnAddSourceBuffer().into()
        }
        unsafe extern "system" fn OnRemoveSourceBuffer<Impl: IMFBufferListNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnRemoveSourceBuffer().into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFBufferListNotify>, base.5, OnAddSourceBuffer::<Impl, OFFSET>, OnRemoveSourceBuffer::<Impl, OFFSET>)
    }
}
pub trait IMFByteStreamImpl: Sized {
    fn GetCapabilities();
    fn GetLength();
    fn SetLength();
    fn GetCurrentPosition();
    fn SetCurrentPosition();
    fn IsEndOfStream();
    fn Read();
    fn BeginRead();
    fn EndRead();
    fn Write();
    fn BeginWrite();
    fn EndWrite();
    fn Seek();
    fn Flush();
    fn Close();
}
impl ::windows::core::RuntimeName for IMFByteStream {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFByteStream";
}
impl IMFByteStreamVtbl {
    pub const fn new<Impl: IMFByteStreamImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFByteStreamVtbl {
        unsafe extern "system" fn GetCapabilities<Impl: IMFByteStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwcapabilities: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCapabilities(::core::mem::transmute_copy(&pdwcapabilities)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IMFByteStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pqwlength: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength(::core::mem::transmute_copy(&pqwlength)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLength<Impl: IMFByteStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, qwlength: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLength(qwlength) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentPosition<Impl: IMFByteStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pqwposition: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentPosition(::core::mem::transmute_copy(&pqwposition)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentPosition<Impl: IMFByteStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, qwposition: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCurrentPosition(qwposition) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsEndOfStream<Impl: IMFByteStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfendofstream: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsEndOfStream(::core::mem::transmute_copy(&pfendofstream)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Read<Impl: IMFByteStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pb: *mut u8, cb: u32, pcbread: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Read(::core::mem::transmute_copy(&pb), cb, ::core::mem::transmute_copy(&pcbread)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginRead<Impl: IMFByteStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pb: *mut u8, cb: u32, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginRead(::core::mem::transmute_copy(&pb), cb, &*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType), &*(&punkstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndRead<Impl: IMFByteStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, pcbread: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndRead(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pcbread)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Write<Impl: IMFByteStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pb: *const u8, cb: u32, pcbwritten: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Write(pb, cb, ::core::mem::transmute_copy(&pcbwritten)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginWrite<Impl: IMFByteStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pb: *const u8, cb: u32, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginWrite(pb, cb, &*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType), &*(&punkstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndWrite<Impl: IMFByteStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, pcbwritten: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndWrite(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pcbwritten)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Seek<Impl: IMFByteStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, seekorigin: MFBYTESTREAM_SEEK_ORIGIN, llseekoffset: i64, dwseekflags: u32, pqwcurrentposition: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Seek(seekorigin, llseekoffset, dwseekflags, ::core::mem::transmute_copy(&pqwcurrentposition)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Flush<Impl: IMFByteStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Flush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Close<Impl: IMFByteStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Close() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMFByteStream>,
            base.5,
            GetCapabilities::<Impl, OFFSET>,
            GetLength::<Impl, OFFSET>,
            SetLength::<Impl, OFFSET>,
            GetCurrentPosition::<Impl, OFFSET>,
            SetCurrentPosition::<Impl, OFFSET>,
            IsEndOfStream::<Impl, OFFSET>,
            Read::<Impl, OFFSET>,
            BeginRead::<Impl, OFFSET>,
            EndRead::<Impl, OFFSET>,
            Write::<Impl, OFFSET>,
            BeginWrite::<Impl, OFFSET>,
            EndWrite::<Impl, OFFSET>,
            Seek::<Impl, OFFSET>,
            Flush::<Impl, OFFSET>,
            Close::<Impl, OFFSET>,
        )
    }
}
pub trait IMFByteStreamBufferingImpl: Sized {
    fn SetBufferingParams();
    fn EnableBuffering();
    fn StopBuffering();
}
impl ::windows::core::RuntimeName for IMFByteStreamBuffering {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFByteStreamBuffering";
}
impl IMFByteStreamBufferingVtbl {
    pub const fn new<Impl: IMFByteStreamBufferingImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFByteStreamBufferingVtbl {
        unsafe extern "system" fn SetBufferingParams<Impl: IMFByteStreamBufferingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pparams: *const MFBYTESTREAM_BUFFERING_PARAMS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBufferingParams(&*(&pparams as *const <MFBYTESTREAM_BUFFERING_PARAMS as ::windows::core::Abi>::Abi as *const <MFBYTESTREAM_BUFFERING_PARAMS as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnableBuffering<Impl: IMFByteStreamBufferingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fenable: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnableBuffering(&*(&fenable as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StopBuffering<Impl: IMFByteStreamBufferingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StopBuffering() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFByteStreamBuffering>, base.5, SetBufferingParams::<Impl, OFFSET>, EnableBuffering::<Impl, OFFSET>, StopBuffering::<Impl, OFFSET>)
    }
}
pub trait IMFByteStreamCacheControlImpl: Sized {
    fn StopBackgroundTransfer();
}
impl ::windows::core::RuntimeName for IMFByteStreamCacheControl {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFByteStreamCacheControl";
}
impl IMFByteStreamCacheControlVtbl {
    pub const fn new<Impl: IMFByteStreamCacheControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFByteStreamCacheControlVtbl {
        unsafe extern "system" fn StopBackgroundTransfer<Impl: IMFByteStreamCacheControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StopBackgroundTransfer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFByteStreamCacheControl>, base.5, StopBackgroundTransfer::<Impl, OFFSET>)
    }
}
pub trait IMFByteStreamCacheControl2Impl: Sized + IMFByteStreamCacheControlImpl {
    fn GetByteRanges();
    fn SetCacheLimit();
    fn IsBackgroundTransferActive();
}
impl ::windows::core::RuntimeName for IMFByteStreamCacheControl2 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFByteStreamCacheControl2";
}
impl IMFByteStreamCacheControl2Vtbl {
    pub const fn new<Impl: IMFByteStreamCacheControl2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFByteStreamCacheControl2Vtbl {
        unsafe extern "system" fn GetByteRanges<Impl: IMFByteStreamCacheControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcranges: *mut u32, ppranges: *mut *mut MF_BYTE_STREAM_CACHE_RANGE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetByteRanges(::core::mem::transmute_copy(&pcranges), ::core::mem::transmute_copy(&ppranges)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCacheLimit<Impl: IMFByteStreamCacheControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, qwbytes: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCacheLimit(qwbytes) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsBackgroundTransferActive<Impl: IMFByteStreamCacheControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfactive: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsBackgroundTransferActive(::core::mem::transmute_copy(&pfactive)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFByteStreamCacheControl2>, base.5, GetByteRanges::<Impl, OFFSET>, SetCacheLimit::<Impl, OFFSET>, IsBackgroundTransferActive::<Impl, OFFSET>)
    }
}
pub trait IMFByteStreamHandlerImpl: Sized {
    fn BeginCreateObject();
    fn EndCreateObject();
    fn CancelObjectCreation();
    fn GetMaxNumberOfBytesRequiredForResolution();
}
impl ::windows::core::RuntimeName for IMFByteStreamHandler {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFByteStreamHandler";
}
impl IMFByteStreamHandlerVtbl {
    pub const fn new<Impl: IMFByteStreamHandlerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFByteStreamHandlerVtbl {
        unsafe extern "system" fn BeginCreateObject<Impl: IMFByteStreamHandlerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbytestream: ::windows::core::RawPtr, pwszurl: super::super::Foundation::PWSTR, dwflags: u32, pprops: ::windows::core::RawPtr, ppiunknowncancelcookie: *mut *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginCreateObject(
                &*(&pbytestream as *const <IMFByteStream as ::windows::core::Abi>::Abi as *const <IMFByteStream as ::windows::core::DefaultType>::DefaultType),
                &*(&pwszurl as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                dwflags,
                &*(&pprops as *const <super::super::UI::Shell::PropertiesSystem::IPropertyStore as ::windows::core::Abi>::Abi as *const <super::super::UI::Shell::PropertiesSystem::IPropertyStore as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&ppiunknowncancelcookie),
                &*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType),
                &*(&punkstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndCreateObject<Impl: IMFByteStreamHandlerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndCreateObject(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pobjecttype), ::core::mem::transmute_copy(&ppobject)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CancelObjectCreation<Impl: IMFByteStreamHandlerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, piunknowncancelcookie: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CancelObjectCreation(&*(&piunknowncancelcookie as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMaxNumberOfBytesRequiredForResolution<Impl: IMFByteStreamHandlerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pqwbytes: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMaxNumberOfBytesRequiredForResolution(::core::mem::transmute_copy(&pqwbytes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFByteStreamHandler>, base.5, BeginCreateObject::<Impl, OFFSET>, EndCreateObject::<Impl, OFFSET>, CancelObjectCreation::<Impl, OFFSET>, GetMaxNumberOfBytesRequiredForResolution::<Impl, OFFSET>)
    }
}
pub trait IMFByteStreamProxyClassFactoryImpl: Sized {
    fn CreateByteStreamProxy();
}
impl ::windows::core::RuntimeName for IMFByteStreamProxyClassFactory {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFByteStreamProxyClassFactory";
}
impl IMFByteStreamProxyClassFactoryVtbl {
    pub const fn new<Impl: IMFByteStreamProxyClassFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFByteStreamProxyClassFactoryVtbl {
        unsafe extern "system" fn CreateByteStreamProxy<Impl: IMFByteStreamProxyClassFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbytestream: ::windows::core::RawPtr, pattributes: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateByteStreamProxy(&*(&pbytestream as *const <IMFByteStream as ::windows::core::Abi>::Abi as *const <IMFByteStream as ::windows::core::DefaultType>::DefaultType), &*(&pattributes as *const <IMFAttributes as ::windows::core::Abi>::Abi as *const <IMFAttributes as ::windows::core::DefaultType>::DefaultType), &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppvobject)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFByteStreamProxyClassFactory>, base.5, CreateByteStreamProxy::<Impl, OFFSET>)
    }
}
pub trait IMFByteStreamTimeSeekImpl: Sized {
    fn IsTimeSeekSupported();
    fn TimeSeek();
    fn GetTimeSeekResult();
}
impl ::windows::core::RuntimeName for IMFByteStreamTimeSeek {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFByteStreamTimeSeek";
}
impl IMFByteStreamTimeSeekVtbl {
    pub const fn new<Impl: IMFByteStreamTimeSeekImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFByteStreamTimeSeekVtbl {
        unsafe extern "system" fn IsTimeSeekSupported<Impl: IMFByteStreamTimeSeekImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pftimeseekissupported: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTimeSeekSupported(::core::mem::transmute_copy(&pftimeseekissupported)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TimeSeek<Impl: IMFByteStreamTimeSeekImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, qwtimeposition: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TimeSeek(qwtimeposition) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTimeSeekResult<Impl: IMFByteStreamTimeSeekImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pqwstarttime: *mut u64, pqwstoptime: *mut u64, pqwduration: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTimeSeekResult(::core::mem::transmute_copy(&pqwstarttime), ::core::mem::transmute_copy(&pqwstoptime), ::core::mem::transmute_copy(&pqwduration)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFByteStreamTimeSeek>, base.5, IsTimeSeekSupported::<Impl, OFFSET>, TimeSeek::<Impl, OFFSET>, GetTimeSeekResult::<Impl, OFFSET>)
    }
}
pub trait IMFCameraOcclusionStateMonitorImpl: Sized {
    fn Start();
    fn Stop();
    fn GetSupportedStates();
}
impl ::windows::core::RuntimeName for IMFCameraOcclusionStateMonitor {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFCameraOcclusionStateMonitor";
}
impl IMFCameraOcclusionStateMonitorVtbl {
    pub const fn new<Impl: IMFCameraOcclusionStateMonitorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFCameraOcclusionStateMonitorVtbl {
        unsafe extern "system" fn Start<Impl: IMFCameraOcclusionStateMonitorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Start() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Stop<Impl: IMFCameraOcclusionStateMonitorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSupportedStates<Impl: IMFCameraOcclusionStateMonitorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSupportedStates() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFCameraOcclusionStateMonitor>, base.5, Start::<Impl, OFFSET>, Stop::<Impl, OFFSET>, GetSupportedStates::<Impl, OFFSET>)
    }
}
pub trait IMFCameraOcclusionStateReportImpl: Sized {
    fn GetOcclusionState();
}
impl ::windows::core::RuntimeName for IMFCameraOcclusionStateReport {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFCameraOcclusionStateReport";
}
impl IMFCameraOcclusionStateReportVtbl {
    pub const fn new<Impl: IMFCameraOcclusionStateReportImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFCameraOcclusionStateReportVtbl {
        unsafe extern "system" fn GetOcclusionState<Impl: IMFCameraOcclusionStateReportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, occlusionstate: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOcclusionState(::core::mem::transmute_copy(&occlusionstate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFCameraOcclusionStateReport>, base.5, GetOcclusionState::<Impl, OFFSET>)
    }
}
pub trait IMFCameraOcclusionStateReportCallbackImpl: Sized {
    fn OnOcclusionStateReport();
}
impl ::windows::core::RuntimeName for IMFCameraOcclusionStateReportCallback {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFCameraOcclusionStateReportCallback";
}
impl IMFCameraOcclusionStateReportCallbackVtbl {
    pub const fn new<Impl: IMFCameraOcclusionStateReportCallbackImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFCameraOcclusionStateReportCallbackVtbl {
        unsafe extern "system" fn OnOcclusionStateReport<Impl: IMFCameraOcclusionStateReportCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, occlusionstatereport: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnOcclusionStateReport(&*(&occlusionstatereport as *const <IMFCameraOcclusionStateReport as ::windows::core::Abi>::Abi as *const <IMFCameraOcclusionStateReport as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFCameraOcclusionStateReportCallback>, base.5, OnOcclusionStateReport::<Impl, OFFSET>)
    }
}
pub trait IMFCameraSyncObjectImpl: Sized {
    fn WaitOnSignal();
    fn Shutdown();
}
impl ::windows::core::RuntimeName for IMFCameraSyncObject {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFCameraSyncObject";
}
impl IMFCameraSyncObjectVtbl {
    pub const fn new<Impl: IMFCameraSyncObjectImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFCameraSyncObjectVtbl {
        unsafe extern "system" fn WaitOnSignal<Impl: IMFCameraSyncObjectImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, timeoutinms: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WaitOnSignal(timeoutinms) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Shutdown<Impl: IMFCameraSyncObjectImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Shutdown().into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFCameraSyncObject>, base.5, WaitOnSignal::<Impl, OFFSET>, Shutdown::<Impl, OFFSET>)
    }
}
pub trait IMFCaptureEngineImpl: Sized {
    fn Initialize();
    fn StartPreview();
    fn StopPreview();
    fn StartRecord();
    fn StopRecord();
    fn TakePhoto();
    fn GetSink();
    fn GetSource();
}
impl ::windows::core::RuntimeName for IMFCaptureEngine {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFCaptureEngine";
}
impl IMFCaptureEngineVtbl {
    pub const fn new<Impl: IMFCaptureEngineImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFCaptureEngineVtbl {
        unsafe extern "system" fn Initialize<Impl: IMFCaptureEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, peventcallback: ::windows::core::RawPtr, pattributes: ::windows::core::RawPtr, paudiosource: *mut ::core::ffi::c_void, pvideosource: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(
                &*(&peventcallback as *const <IMFCaptureEngineOnEventCallback as ::windows::core::Abi>::Abi as *const <IMFCaptureEngineOnEventCallback as ::windows::core::DefaultType>::DefaultType),
                &*(&pattributes as *const <IMFAttributes as ::windows::core::Abi>::Abi as *const <IMFAttributes as ::windows::core::DefaultType>::DefaultType),
                &*(&paudiosource as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType),
                &*(&pvideosource as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StartPreview<Impl: IMFCaptureEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StartPreview() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StopPreview<Impl: IMFCaptureEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StopPreview() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StartRecord<Impl: IMFCaptureEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StartRecord() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn StopRecord<Impl: IMFCaptureEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bfinalize: super::super::Foundation::BOOL, bflushunprocessedsamples: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StopRecord(&*(&bfinalize as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType), &*(&bflushunprocessedsamples as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TakePhoto<Impl: IMFCaptureEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TakePhoto() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSink<Impl: IMFCaptureEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mfcaptureenginesinktype: MF_CAPTURE_ENGINE_SINK_TYPE, ppsink: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSink(mfcaptureenginesinktype, ::core::mem::transmute_copy(&ppsink)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSource<Impl: IMFCaptureEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppsource: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSource(::core::mem::transmute_copy(&ppsource)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFCaptureEngine>, base.5, Initialize::<Impl, OFFSET>, StartPreview::<Impl, OFFSET>, StopPreview::<Impl, OFFSET>, StartRecord::<Impl, OFFSET>, StopRecord::<Impl, OFFSET>, TakePhoto::<Impl, OFFSET>, GetSink::<Impl, OFFSET>, GetSource::<Impl, OFFSET>)
    }
}
pub trait IMFCaptureEngineClassFactoryImpl: Sized {
    fn CreateInstance();
}
impl ::windows::core::RuntimeName for IMFCaptureEngineClassFactory {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFCaptureEngineClassFactory";
}
impl IMFCaptureEngineClassFactoryVtbl {
    pub const fn new<Impl: IMFCaptureEngineClassFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFCaptureEngineClassFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMFCaptureEngineClassFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clsid: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(&*(&clsid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppvobject)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFCaptureEngineClassFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
pub trait IMFCaptureEngineOnEventCallbackImpl: Sized {
    fn OnEvent();
}
impl ::windows::core::RuntimeName for IMFCaptureEngineOnEventCallback {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFCaptureEngineOnEventCallback";
}
impl IMFCaptureEngineOnEventCallbackVtbl {
    pub const fn new<Impl: IMFCaptureEngineOnEventCallbackImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFCaptureEngineOnEventCallbackVtbl {
        unsafe extern "system" fn OnEvent<Impl: IMFCaptureEngineOnEventCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pevent: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnEvent(&*(&pevent as *const <IMFMediaEvent as ::windows::core::Abi>::Abi as *const <IMFMediaEvent as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFCaptureEngineOnEventCallback>, base.5, OnEvent::<Impl, OFFSET>)
    }
}
pub trait IMFCaptureEngineOnSampleCallbackImpl: Sized {
    fn OnSample();
}
impl ::windows::core::RuntimeName for IMFCaptureEngineOnSampleCallback {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFCaptureEngineOnSampleCallback";
}
impl IMFCaptureEngineOnSampleCallbackVtbl {
    pub const fn new<Impl: IMFCaptureEngineOnSampleCallbackImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFCaptureEngineOnSampleCallbackVtbl {
        unsafe extern "system" fn OnSample<Impl: IMFCaptureEngineOnSampleCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psample: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnSample(&*(&psample as *const <IMFSample as ::windows::core::Abi>::Abi as *const <IMFSample as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFCaptureEngineOnSampleCallback>, base.5, OnSample::<Impl, OFFSET>)
    }
}
pub trait IMFCaptureEngineOnSampleCallback2Impl: Sized + IMFCaptureEngineOnSampleCallbackImpl {
    fn OnSynchronizedEvent();
}
impl ::windows::core::RuntimeName for IMFCaptureEngineOnSampleCallback2 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFCaptureEngineOnSampleCallback2";
}
impl IMFCaptureEngineOnSampleCallback2Vtbl {
    pub const fn new<Impl: IMFCaptureEngineOnSampleCallback2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFCaptureEngineOnSampleCallback2Vtbl {
        unsafe extern "system" fn OnSynchronizedEvent<Impl: IMFCaptureEngineOnSampleCallback2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pevent: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnSynchronizedEvent(&*(&pevent as *const <IMFMediaEvent as ::windows::core::Abi>::Abi as *const <IMFMediaEvent as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFCaptureEngineOnSampleCallback2>, base.5, OnSynchronizedEvent::<Impl, OFFSET>)
    }
}
pub trait IMFCapturePhotoConfirmationImpl: Sized {
    fn SetPhotoConfirmationCallback();
    fn SetPixelFormat();
    fn GetPixelFormat();
}
impl ::windows::core::RuntimeName for IMFCapturePhotoConfirmation {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFCapturePhotoConfirmation";
}
impl IMFCapturePhotoConfirmationVtbl {
    pub const fn new<Impl: IMFCapturePhotoConfirmationImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFCapturePhotoConfirmationVtbl {
        unsafe extern "system" fn SetPhotoConfirmationCallback<Impl: IMFCapturePhotoConfirmationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pnotificationcallback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPhotoConfirmationCallback(&*(&pnotificationcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPixelFormat<Impl: IMFCapturePhotoConfirmationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, subtype: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPixelFormat(&*(&subtype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPixelFormat<Impl: IMFCapturePhotoConfirmationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, subtype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPixelFormat(::core::mem::transmute_copy(&subtype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFCapturePhotoConfirmation>, base.5, SetPhotoConfirmationCallback::<Impl, OFFSET>, SetPixelFormat::<Impl, OFFSET>, GetPixelFormat::<Impl, OFFSET>)
    }
}
pub trait IMFCapturePhotoSinkImpl: Sized + IMFCaptureSinkImpl {
    fn SetOutputFileName();
    fn SetSampleCallback();
    fn SetOutputByteStream();
}
impl ::windows::core::RuntimeName for IMFCapturePhotoSink {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFCapturePhotoSink";
}
impl IMFCapturePhotoSinkVtbl {
    pub const fn new<Impl: IMFCapturePhotoSinkImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFCapturePhotoSinkVtbl {
        unsafe extern "system" fn SetOutputFileName<Impl: IMFCapturePhotoSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, filename: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputFileName(&*(&filename as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSampleCallback<Impl: IMFCapturePhotoSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSampleCallback(&*(&pcallback as *const <IMFCaptureEngineOnSampleCallback as ::windows::core::Abi>::Abi as *const <IMFCaptureEngineOnSampleCallback as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputByteStream<Impl: IMFCapturePhotoSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbytestream: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputByteStream(&*(&pbytestream as *const <IMFByteStream as ::windows::core::Abi>::Abi as *const <IMFByteStream as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFCapturePhotoSink>, base.5, SetOutputFileName::<Impl, OFFSET>, SetSampleCallback::<Impl, OFFSET>, SetOutputByteStream::<Impl, OFFSET>)
    }
}
pub trait IMFCapturePreviewSinkImpl: Sized + IMFCaptureSinkImpl {
    fn SetRenderHandle();
    fn SetRenderSurface();
    fn UpdateVideo();
    fn SetSampleCallback();
    fn GetMirrorState();
    fn SetMirrorState();
    fn GetRotation();
    fn SetRotation();
    fn SetCustomSink();
}
impl ::windows::core::RuntimeName for IMFCapturePreviewSink {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFCapturePreviewSink";
}
impl IMFCapturePreviewSinkVtbl {
    pub const fn new<Impl: IMFCapturePreviewSinkImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFCapturePreviewSinkVtbl {
        unsafe extern "system" fn SetRenderHandle<Impl: IMFCapturePreviewSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, handle: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRenderHandle(&*(&handle as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRenderSurface<Impl: IMFCapturePreviewSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psurface: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRenderSurface(&*(&psurface as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UpdateVideo<Impl: IMFCapturePreviewSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UpdateVideo(&*(&psrc as *const <MFVideoNormalizedRect as ::windows::core::Abi>::Abi as *const <MFVideoNormalizedRect as ::windows::core::DefaultType>::DefaultType), &*(&pdst as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType), pborderclr) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSampleCallback<Impl: IMFCapturePreviewSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamsinkindex: u32, pcallback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSampleCallback(dwstreamsinkindex, &*(&pcallback as *const <IMFCaptureEngineOnSampleCallback as ::windows::core::Abi>::Abi as *const <IMFCaptureEngineOnSampleCallback as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMirrorState<Impl: IMFCapturePreviewSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfmirrorstate: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMirrorState(::core::mem::transmute_copy(&pfmirrorstate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMirrorState<Impl: IMFCapturePreviewSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fmirrorstate: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMirrorState(&*(&fmirrorstate as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRotation<Impl: IMFCapturePreviewSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pdwrotationvalue: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRotation(dwstreamindex, ::core::mem::transmute_copy(&pdwrotationvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRotation<Impl: IMFCapturePreviewSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, dwrotationvalue: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRotation(dwstreamindex, dwrotationvalue) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCustomSink<Impl: IMFCapturePreviewSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmediasink: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCustomSink(&*(&pmediasink as *const <IMFMediaSink as ::windows::core::Abi>::Abi as *const <IMFMediaSink as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFCapturePreviewSink>, base.5, SetRenderHandle::<Impl, OFFSET>, SetRenderSurface::<Impl, OFFSET>, UpdateVideo::<Impl, OFFSET>, SetSampleCallback::<Impl, OFFSET>, GetMirrorState::<Impl, OFFSET>, SetMirrorState::<Impl, OFFSET>, GetRotation::<Impl, OFFSET>, SetRotation::<Impl, OFFSET>, SetCustomSink::<Impl, OFFSET>)
    }
}
pub trait IMFCaptureRecordSinkImpl: Sized + IMFCaptureSinkImpl {
    fn SetOutputByteStream();
    fn SetOutputFileName();
    fn SetSampleCallback();
    fn SetCustomSink();
    fn GetRotation();
    fn SetRotation();
}
impl ::windows::core::RuntimeName for IMFCaptureRecordSink {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFCaptureRecordSink";
}
impl IMFCaptureRecordSinkVtbl {
    pub const fn new<Impl: IMFCaptureRecordSinkImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFCaptureRecordSinkVtbl {
        unsafe extern "system" fn SetOutputByteStream<Impl: IMFCaptureRecordSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbytestream: ::windows::core::RawPtr, guidcontainertype: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputByteStream(&*(&pbytestream as *const <IMFByteStream as ::windows::core::Abi>::Abi as *const <IMFByteStream as ::windows::core::DefaultType>::DefaultType), &*(&guidcontainertype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputFileName<Impl: IMFCaptureRecordSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, filename: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputFileName(&*(&filename as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSampleCallback<Impl: IMFCaptureRecordSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamsinkindex: u32, pcallback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSampleCallback(dwstreamsinkindex, &*(&pcallback as *const <IMFCaptureEngineOnSampleCallback as ::windows::core::Abi>::Abi as *const <IMFCaptureEngineOnSampleCallback as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCustomSink<Impl: IMFCaptureRecordSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmediasink: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCustomSink(&*(&pmediasink as *const <IMFMediaSink as ::windows::core::Abi>::Abi as *const <IMFMediaSink as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRotation<Impl: IMFCaptureRecordSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pdwrotationvalue: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRotation(dwstreamindex, ::core::mem::transmute_copy(&pdwrotationvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRotation<Impl: IMFCaptureRecordSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, dwrotationvalue: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRotation(dwstreamindex, dwrotationvalue) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFCaptureRecordSink>, base.5, SetOutputByteStream::<Impl, OFFSET>, SetOutputFileName::<Impl, OFFSET>, SetSampleCallback::<Impl, OFFSET>, SetCustomSink::<Impl, OFFSET>, GetRotation::<Impl, OFFSET>, SetRotation::<Impl, OFFSET>)
    }
}
pub trait IMFCaptureSinkImpl: Sized {
    fn GetOutputMediaType();
    fn GetService();
    fn AddStream();
    fn Prepare();
    fn RemoveAllStreams();
}
impl ::windows::core::RuntimeName for IMFCaptureSink {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFCaptureSink";
}
impl IMFCaptureSinkVtbl {
    pub const fn new<Impl: IMFCaptureSinkImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFCaptureSinkVtbl {
        unsafe extern "system" fn GetOutputMediaType<Impl: IMFCaptureSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsinkstreamindex: u32, ppmediatype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputMediaType(dwsinkstreamindex, ::core::mem::transmute_copy(&ppmediatype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetService<Impl: IMFCaptureSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsinkstreamindex: u32, rguidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppunknown: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetService(dwsinkstreamindex, &*(&rguidservice as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppunknown)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddStream<Impl: IMFCaptureSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32, pmediatype: ::windows::core::RawPtr, pattributes: ::windows::core::RawPtr, pdwsinkstreamindex: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddStream(dwsourcestreamindex, &*(&pmediatype as *const <IMFMediaType as ::windows::core::Abi>::Abi as *const <IMFMediaType as ::windows::core::DefaultType>::DefaultType), &*(&pattributes as *const <IMFAttributes as ::windows::core::Abi>::Abi as *const <IMFAttributes as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pdwsinkstreamindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Prepare<Impl: IMFCaptureSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Prepare() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveAllStreams<Impl: IMFCaptureSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveAllStreams() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFCaptureSink>, base.5, GetOutputMediaType::<Impl, OFFSET>, GetService::<Impl, OFFSET>, AddStream::<Impl, OFFSET>, Prepare::<Impl, OFFSET>, RemoveAllStreams::<Impl, OFFSET>)
    }
}
pub trait IMFCaptureSink2Impl: Sized + IMFCaptureSinkImpl {
    fn SetOutputMediaType();
}
impl ::windows::core::RuntimeName for IMFCaptureSink2 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFCaptureSink2";
}
impl IMFCaptureSink2Vtbl {
    pub const fn new<Impl: IMFCaptureSink2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFCaptureSink2Vtbl {
        unsafe extern "system" fn SetOutputMediaType<Impl: IMFCaptureSink2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pmediatype: ::windows::core::RawPtr, pencodingattributes: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputMediaType(dwstreamindex, &*(&pmediatype as *const <IMFMediaType as ::windows::core::Abi>::Abi as *const <IMFMediaType as ::windows::core::DefaultType>::DefaultType), &*(&pencodingattributes as *const <IMFAttributes as ::windows::core::Abi>::Abi as *const <IMFAttributes as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFCaptureSink2>, base.5, SetOutputMediaType::<Impl, OFFSET>)
    }
}
pub trait IMFCaptureSourceImpl: Sized {
    fn GetCaptureDeviceSource();
    fn GetCaptureDeviceActivate();
    fn GetService();
    fn AddEffect();
    fn RemoveEffect();
    fn RemoveAllEffects();
    fn GetAvailableDeviceMediaType();
    fn SetCurrentDeviceMediaType();
    fn GetCurrentDeviceMediaType();
    fn GetDeviceStreamCount();
    fn GetDeviceStreamCategory();
    fn GetMirrorState();
    fn SetMirrorState();
    fn GetStreamIndexFromFriendlyName();
}
impl ::windows::core::RuntimeName for IMFCaptureSource {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFCaptureSource";
}
impl IMFCaptureSourceVtbl {
    pub const fn new<Impl: IMFCaptureSourceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFCaptureSourceVtbl {
        unsafe extern "system" fn GetCaptureDeviceSource<Impl: IMFCaptureSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mfcaptureenginedevicetype: MF_CAPTURE_ENGINE_DEVICE_TYPE, ppmediasource: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCaptureDeviceSource(mfcaptureenginedevicetype, ::core::mem::transmute_copy(&ppmediasource)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCaptureDeviceActivate<Impl: IMFCaptureSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mfcaptureenginedevicetype: MF_CAPTURE_ENGINE_DEVICE_TYPE, ppactivate: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCaptureDeviceActivate(mfcaptureenginedevicetype, ::core::mem::transmute_copy(&ppactivate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetService<Impl: IMFCaptureSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, rguidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppunknown: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetService(&*(&rguidservice as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppunknown)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddEffect<Impl: IMFCaptureSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32, punknown: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddEffect(dwsourcestreamindex, &*(&punknown as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveEffect<Impl: IMFCaptureSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32, punknown: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveEffect(dwsourcestreamindex, &*(&punknown as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveAllEffects<Impl: IMFCaptureSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveAllEffects(dwsourcestreamindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAvailableDeviceMediaType<Impl: IMFCaptureSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32, dwmediatypeindex: u32, ppmediatype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAvailableDeviceMediaType(dwsourcestreamindex, dwmediatypeindex, ::core::mem::transmute_copy(&ppmediatype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentDeviceMediaType<Impl: IMFCaptureSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32, pmediatype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCurrentDeviceMediaType(dwsourcestreamindex, &*(&pmediatype as *const <IMFMediaType as ::windows::core::Abi>::Abi as *const <IMFMediaType as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentDeviceMediaType<Impl: IMFCaptureSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32, ppmediatype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentDeviceMediaType(dwsourcestreamindex, ::core::mem::transmute_copy(&ppmediatype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDeviceStreamCount<Impl: IMFCaptureSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwstreamcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDeviceStreamCount(::core::mem::transmute_copy(&pdwstreamcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDeviceStreamCategory<Impl: IMFCaptureSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32, pstreamcategory: *mut MF_CAPTURE_ENGINE_STREAM_CATEGORY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDeviceStreamCategory(dwsourcestreamindex, ::core::mem::transmute_copy(&pstreamcategory)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMirrorState<Impl: IMFCaptureSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pfmirrorstate: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMirrorState(dwstreamindex, ::core::mem::transmute_copy(&pfmirrorstate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMirrorState<Impl: IMFCaptureSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, fmirrorstate: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMirrorState(dwstreamindex, &*(&fmirrorstate as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamIndexFromFriendlyName<Impl: IMFCaptureSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, uifriendlyname: u32, pdwactualstreamindex: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamIndexFromFriendlyName(uifriendlyname, ::core::mem::transmute_copy(&pdwactualstreamindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMFCaptureSource>,
            base.5,
            GetCaptureDeviceSource::<Impl, OFFSET>,
            GetCaptureDeviceActivate::<Impl, OFFSET>,
            GetService::<Impl, OFFSET>,
            AddEffect::<Impl, OFFSET>,
            RemoveEffect::<Impl, OFFSET>,
            RemoveAllEffects::<Impl, OFFSET>,
            GetAvailableDeviceMediaType::<Impl, OFFSET>,
            SetCurrentDeviceMediaType::<Impl, OFFSET>,
            GetCurrentDeviceMediaType::<Impl, OFFSET>,
            GetDeviceStreamCount::<Impl, OFFSET>,
            GetDeviceStreamCategory::<Impl, OFFSET>,
            GetMirrorState::<Impl, OFFSET>,
            SetMirrorState::<Impl, OFFSET>,
            GetStreamIndexFromFriendlyName::<Impl, OFFSET>,
        )
    }
}
pub trait IMFCdmSuspendNotifyImpl: Sized {
    fn Begin();
    fn End();
}
impl ::windows::core::RuntimeName for IMFCdmSuspendNotify {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFCdmSuspendNotify";
}
impl IMFCdmSuspendNotifyVtbl {
    pub const fn new<Impl: IMFCdmSuspendNotifyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFCdmSuspendNotifyVtbl {
        unsafe extern "system" fn Begin<Impl: IMFCdmSuspendNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Begin() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn End<Impl: IMFCdmSuspendNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).End() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFCdmSuspendNotify>, base.5, Begin::<Impl, OFFSET>, End::<Impl, OFFSET>)
    }
}
pub trait IMFClockImpl: Sized {
    fn GetClockCharacteristics();
    fn GetCorrelatedTime();
    fn GetContinuityKey();
    fn GetState();
    fn GetProperties();
}
impl ::windows::core::RuntimeName for IMFClock {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFClock";
}
impl IMFClockVtbl {
    pub const fn new<Impl: IMFClockImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFClockVtbl {
        unsafe extern "system" fn GetClockCharacteristics<Impl: IMFClockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwcharacteristics: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetClockCharacteristics(::core::mem::transmute_copy(&pdwcharacteristics)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCorrelatedTime<Impl: IMFClockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwreserved: u32, pllclocktime: *mut i64, phnssystemtime: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCorrelatedTime(dwreserved, ::core::mem::transmute_copy(&pllclocktime), ::core::mem::transmute_copy(&phnssystemtime)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetContinuityKey<Impl: IMFClockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwcontinuitykey: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetContinuityKey(::core::mem::transmute_copy(&pdwcontinuitykey)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetState<Impl: IMFClockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwreserved: u32, peclockstate: *mut MFCLOCK_STATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetState(dwreserved, ::core::mem::transmute_copy(&peclockstate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProperties<Impl: IMFClockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pclockproperties: *mut MFCLOCK_PROPERTIES) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProperties(::core::mem::transmute_copy(&pclockproperties)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFClock>, base.5, GetClockCharacteristics::<Impl, OFFSET>, GetCorrelatedTime::<Impl, OFFSET>, GetContinuityKey::<Impl, OFFSET>, GetState::<Impl, OFFSET>, GetProperties::<Impl, OFFSET>)
    }
}
pub trait IMFClockConsumerImpl: Sized {
    fn SetPresentationClock();
    fn GetPresentationClock();
}
impl ::windows::core::RuntimeName for IMFClockConsumer {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFClockConsumer";
}
impl IMFClockConsumerVtbl {
    pub const fn new<Impl: IMFClockConsumerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFClockConsumerVtbl {
        unsafe extern "system" fn SetPresentationClock<Impl: IMFClockConsumerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppresentationclock: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPresentationClock(&*(&ppresentationclock as *const <IMFPresentationClock as ::windows::core::Abi>::Abi as *const <IMFPresentationClock as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPresentationClock<Impl: IMFClockConsumerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pppresentationclock: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPresentationClock(::core::mem::transmute_copy(&pppresentationclock)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFClockConsumer>, base.5, SetPresentationClock::<Impl, OFFSET>, GetPresentationClock::<Impl, OFFSET>)
    }
}
pub trait IMFClockStateSinkImpl: Sized {
    fn OnClockStart();
    fn OnClockStop();
    fn OnClockPause();
    fn OnClockRestart();
    fn OnClockSetRate();
}
impl ::windows::core::RuntimeName for IMFClockStateSink {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFClockStateSink";
}
impl IMFClockStateSinkVtbl {
    pub const fn new<Impl: IMFClockStateSinkImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFClockStateSinkVtbl {
        unsafe extern "system" fn OnClockStart<Impl: IMFClockStateSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnssystemtime: i64, llclockstartoffset: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnClockStart(hnssystemtime, llclockstartoffset) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnClockStop<Impl: IMFClockStateSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnssystemtime: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnClockStop(hnssystemtime) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnClockPause<Impl: IMFClockStateSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnssystemtime: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnClockPause(hnssystemtime) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnClockRestart<Impl: IMFClockStateSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnssystemtime: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnClockRestart(hnssystemtime) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnClockSetRate<Impl: IMFClockStateSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnssystemtime: i64, flrate: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnClockSetRate(hnssystemtime, flrate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFClockStateSink>, base.5, OnClockStart::<Impl, OFFSET>, OnClockStop::<Impl, OFFSET>, OnClockPause::<Impl, OFFSET>, OnClockRestart::<Impl, OFFSET>, OnClockSetRate::<Impl, OFFSET>)
    }
}
pub trait IMFCollectionImpl: Sized {
    fn GetElementCount();
    fn GetElement();
    fn AddElement();
    fn RemoveElement();
    fn InsertElementAt();
    fn RemoveAllElements();
}
impl ::windows::core::RuntimeName for IMFCollection {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFCollection";
}
impl IMFCollectionVtbl {
    pub const fn new<Impl: IMFCollectionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFCollectionVtbl {
        unsafe extern "system" fn GetElementCount<Impl: IMFCollectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcelements: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetElementCount(::core::mem::transmute_copy(&pcelements)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetElement<Impl: IMFCollectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwelementindex: u32, ppunkelement: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetElement(dwelementindex, ::core::mem::transmute_copy(&ppunkelement)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddElement<Impl: IMFCollectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, punkelement: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddElement(&*(&punkelement as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveElement<Impl: IMFCollectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwelementindex: u32, ppunkelement: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveElement(dwelementindex, ::core::mem::transmute_copy(&ppunkelement)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InsertElementAt<Impl: IMFCollectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, punknown: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InsertElementAt(dwindex, &*(&punknown as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveAllElements<Impl: IMFCollectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveAllElements() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFCollection>, base.5, GetElementCount::<Impl, OFFSET>, GetElement::<Impl, OFFSET>, AddElement::<Impl, OFFSET>, RemoveElement::<Impl, OFFSET>, InsertElementAt::<Impl, OFFSET>, RemoveAllElements::<Impl, OFFSET>)
    }
}
pub trait IMFContentDecryptionModuleImpl: Sized {
    fn SetContentEnabler();
    fn GetSuspendNotify();
    fn SetPMPHostApp();
    fn CreateSession();
    fn SetServerCertificate();
    fn CreateTrustedInput();
    fn GetProtectionSystemIds();
}
impl ::windows::core::RuntimeName for IMFContentDecryptionModule {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFContentDecryptionModule";
}
impl IMFContentDecryptionModuleVtbl {
    pub const fn new<Impl: IMFContentDecryptionModuleImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFContentDecryptionModuleVtbl {
        unsafe extern "system" fn SetContentEnabler<Impl: IMFContentDecryptionModuleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, contentenabler: ::windows::core::RawPtr, result: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetContentEnabler(&*(&contentenabler as *const <IMFContentEnabler as ::windows::core::Abi>::Abi as *const <IMFContentEnabler as ::windows::core::DefaultType>::DefaultType), &*(&result as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSuspendNotify<Impl: IMFContentDecryptionModuleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, notify: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSuspendNotify(::core::mem::transmute_copy(&notify)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPMPHostApp<Impl: IMFContentDecryptionModuleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmphostapp: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPMPHostApp(&*(&pmphostapp as *const <IMFPMPHostApp as ::windows::core::Abi>::Abi as *const <IMFPMPHostApp as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateSession<Impl: IMFContentDecryptionModuleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, sessiontype: MF_MEDIAKEYSESSION_TYPE, callbacks: ::windows::core::RawPtr, session: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateSession(sessiontype, &*(&callbacks as *const <IMFContentDecryptionModuleSessionCallbacks as ::windows::core::Abi>::Abi as *const <IMFContentDecryptionModuleSessionCallbacks as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&session)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetServerCertificate<Impl: IMFContentDecryptionModuleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, certificate: *const u8, certificatesize: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetServerCertificate(certificate, certificatesize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateTrustedInput<Impl: IMFContentDecryptionModuleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, contentinitdata: *const u8, contentinitdatasize: u32, trustedinput: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateTrustedInput(contentinitdata, contentinitdatasize, ::core::mem::transmute_copy(&trustedinput)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProtectionSystemIds<Impl: IMFContentDecryptionModuleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, systemids: *mut *mut ::windows::core::GUID, count: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProtectionSystemIds(::core::mem::transmute_copy(&systemids), ::core::mem::transmute_copy(&count)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFContentDecryptionModule>, base.5, SetContentEnabler::<Impl, OFFSET>, GetSuspendNotify::<Impl, OFFSET>, SetPMPHostApp::<Impl, OFFSET>, CreateSession::<Impl, OFFSET>, SetServerCertificate::<Impl, OFFSET>, CreateTrustedInput::<Impl, OFFSET>, GetProtectionSystemIds::<Impl, OFFSET>)
    }
}
pub trait IMFContentDecryptionModuleAccessImpl: Sized {
    fn CreateContentDecryptionModule();
    fn GetConfiguration();
    fn GetKeySystem();
}
impl ::windows::core::RuntimeName for IMFContentDecryptionModuleAccess {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFContentDecryptionModuleAccess";
}
impl IMFContentDecryptionModuleAccessVtbl {
    pub const fn new<Impl: IMFContentDecryptionModuleAccessImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFContentDecryptionModuleAccessVtbl {
        unsafe extern "system" fn CreateContentDecryptionModule<Impl: IMFContentDecryptionModuleAccessImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, contentdecryptionmoduleproperties: ::windows::core::RawPtr, contentdecryptionmodule: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateContentDecryptionModule(&*(&contentdecryptionmoduleproperties as *const <super::super::UI::Shell::PropertiesSystem::IPropertyStore as ::windows::core::Abi>::Abi as *const <super::super::UI::Shell::PropertiesSystem::IPropertyStore as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&contentdecryptionmodule)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetConfiguration<Impl: IMFContentDecryptionModuleAccessImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, configuration: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetConfiguration(::core::mem::transmute_copy(&configuration)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetKeySystem<Impl: IMFContentDecryptionModuleAccessImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, keysystem: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetKeySystem(::core::mem::transmute_copy(&keysystem)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFContentDecryptionModuleAccess>, base.5, CreateContentDecryptionModule::<Impl, OFFSET>, GetConfiguration::<Impl, OFFSET>, GetKeySystem::<Impl, OFFSET>)
    }
}
pub trait IMFContentDecryptionModuleFactoryImpl: Sized {
    fn IsTypeSupported();
    fn CreateContentDecryptionModuleAccess();
}
impl ::windows::core::RuntimeName for IMFContentDecryptionModuleFactory {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFContentDecryptionModuleFactory";
}
impl IMFContentDecryptionModuleFactoryVtbl {
    pub const fn new<Impl: IMFContentDecryptionModuleFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFContentDecryptionModuleFactoryVtbl {
        unsafe extern "system" fn IsTypeSupported<Impl: IMFContentDecryptionModuleFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, keysystem: super::super::Foundation::PWSTR, contenttype: super::super::Foundation::PWSTR) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTypeSupported(&*(&keysystem as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), &*(&contenttype as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateContentDecryptionModuleAccess<Impl: IMFContentDecryptionModuleFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, keysystem: super::super::Foundation::PWSTR, configurations: *const ::windows::core::RawPtr, numconfigurations: u32, contentdecryptionmoduleaccess: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateContentDecryptionModuleAccess(
                &*(&keysystem as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&configurations as *const <super::super::UI::Shell::PropertiesSystem::IPropertyStore as ::windows::core::Abi>::Abi as *const <super::super::UI::Shell::PropertiesSystem::IPropertyStore as ::windows::core::DefaultType>::DefaultType),
                numconfigurations,
                ::core::mem::transmute_copy(&contentdecryptionmoduleaccess),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFContentDecryptionModuleFactory>, base.5, IsTypeSupported::<Impl, OFFSET>, CreateContentDecryptionModuleAccess::<Impl, OFFSET>)
    }
}
pub trait IMFContentDecryptionModuleSessionImpl: Sized {
    fn GetSessionId();
    fn GetExpiration();
    fn GetKeyStatuses();
    fn Load();
    fn GenerateRequest();
    fn Update();
    fn Close();
    fn Remove();
}
impl ::windows::core::RuntimeName for IMFContentDecryptionModuleSession {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFContentDecryptionModuleSession";
}
impl IMFContentDecryptionModuleSessionVtbl {
    pub const fn new<Impl: IMFContentDecryptionModuleSessionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFContentDecryptionModuleSessionVtbl {
        unsafe extern "system" fn GetSessionId<Impl: IMFContentDecryptionModuleSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, sessionid: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSessionId(::core::mem::transmute_copy(&sessionid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetExpiration<Impl: IMFContentDecryptionModuleSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, expiration: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetExpiration(::core::mem::transmute_copy(&expiration)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetKeyStatuses<Impl: IMFContentDecryptionModuleSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, keystatuses: *mut *mut MFMediaKeyStatus, numkeystatuses: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetKeyStatuses(::core::mem::transmute_copy(&keystatuses), ::core::mem::transmute_copy(&numkeystatuses)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Load<Impl: IMFContentDecryptionModuleSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, sessionid: super::super::Foundation::PWSTR, loaded: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Load(&*(&sessionid as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&loaded)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GenerateRequest<Impl: IMFContentDecryptionModuleSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, initdatatype: super::super::Foundation::PWSTR, initdata: *const u8, initdatasize: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GenerateRequest(&*(&initdatatype as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), initdata, initdatasize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Update<Impl: IMFContentDecryptionModuleSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, response: *const u8, responsesize: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Update(response, responsesize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Close<Impl: IMFContentDecryptionModuleSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Close() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Remove<Impl: IMFContentDecryptionModuleSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Remove() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFContentDecryptionModuleSession>, base.5, GetSessionId::<Impl, OFFSET>, GetExpiration::<Impl, OFFSET>, GetKeyStatuses::<Impl, OFFSET>, Load::<Impl, OFFSET>, GenerateRequest::<Impl, OFFSET>, Update::<Impl, OFFSET>, Close::<Impl, OFFSET>, Remove::<Impl, OFFSET>)
    }
}
pub trait IMFContentDecryptionModuleSessionCallbacksImpl: Sized {
    fn KeyMessage();
    fn KeyStatusChanged();
}
impl ::windows::core::RuntimeName for IMFContentDecryptionModuleSessionCallbacks {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFContentDecryptionModuleSessionCallbacks";
}
impl IMFContentDecryptionModuleSessionCallbacksVtbl {
    pub const fn new<Impl: IMFContentDecryptionModuleSessionCallbacksImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFContentDecryptionModuleSessionCallbacksVtbl {
        unsafe extern "system" fn KeyMessage<Impl: IMFContentDecryptionModuleSessionCallbacksImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, messagetype: MF_MEDIAKEYSESSION_MESSAGETYPE, message: *const u8, messagesize: u32, destinationurl: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KeyMessage(messagetype, message, messagesize, &*(&destinationurl as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KeyStatusChanged<Impl: IMFContentDecryptionModuleSessionCallbacksImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KeyStatusChanged() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFContentDecryptionModuleSessionCallbacks>, base.5, KeyMessage::<Impl, OFFSET>, KeyStatusChanged::<Impl, OFFSET>)
    }
}
pub trait IMFContentDecryptorContextImpl: Sized {
    fn InitializeHardwareKey();
}
impl ::windows::core::RuntimeName for IMFContentDecryptorContext {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFContentDecryptorContext";
}
impl IMFContentDecryptorContextVtbl {
    pub const fn new<Impl: IMFContentDecryptorContextImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFContentDecryptorContextVtbl {
        unsafe extern "system" fn InitializeHardwareKey<Impl: IMFContentDecryptorContextImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, inputprivatedatabytecount: u32, inputprivatedata: *const ::core::ffi::c_void, outputprivatedata: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InitializeHardwareKey(inputprivatedatabytecount, &*(&inputprivatedata as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&outputprivatedata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFContentDecryptorContext>, base.5, InitializeHardwareKey::<Impl, OFFSET>)
    }
}
pub trait IMFContentEnablerImpl: Sized {
    fn GetEnableType();
    fn GetEnableURL();
    fn GetEnableData();
    fn IsAutomaticSupported();
    fn AutomaticEnable();
    fn MonitorEnable();
    fn Cancel();
}
impl ::windows::core::RuntimeName for IMFContentEnabler {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFContentEnabler";
}
impl IMFContentEnablerVtbl {
    pub const fn new<Impl: IMFContentEnablerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFContentEnablerVtbl {
        unsafe extern "system" fn GetEnableType<Impl: IMFContentEnablerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEnableType(::core::mem::transmute_copy(&ptype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEnableURL<Impl: IMFContentEnablerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppwszurl: *mut super::super::Foundation::PWSTR, pcchurl: *mut u32, ptruststatus: *mut MF_URL_TRUST_STATUS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEnableURL(::core::mem::transmute_copy(&ppwszurl), ::core::mem::transmute_copy(&pcchurl), ptruststatus) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEnableData<Impl: IMFContentEnablerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppbdata: *mut *mut u8, pcbdata: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEnableData(::core::mem::transmute_copy(&ppbdata), ::core::mem::transmute_copy(&pcbdata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsAutomaticSupported<Impl: IMFContentEnablerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfautomatic: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsAutomaticSupported(::core::mem::transmute_copy(&pfautomatic)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutomaticEnable<Impl: IMFContentEnablerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AutomaticEnable() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MonitorEnable<Impl: IMFContentEnablerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MonitorEnable() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Cancel<Impl: IMFContentEnablerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Cancel() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFContentEnabler>, base.5, GetEnableType::<Impl, OFFSET>, GetEnableURL::<Impl, OFFSET>, GetEnableData::<Impl, OFFSET>, IsAutomaticSupported::<Impl, OFFSET>, AutomaticEnable::<Impl, OFFSET>, MonitorEnable::<Impl, OFFSET>, Cancel::<Impl, OFFSET>)
    }
}
pub trait IMFContentProtectionDeviceImpl: Sized {
    fn InvokeFunction();
    fn GetPrivateDataByteCount();
}
impl ::windows::core::RuntimeName for IMFContentProtectionDevice {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFContentProtectionDevice";
}
impl IMFContentProtectionDeviceVtbl {
    pub const fn new<Impl: IMFContentProtectionDeviceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFContentProtectionDeviceVtbl {
        unsafe extern "system" fn InvokeFunction<Impl: IMFContentProtectionDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, functionid: u32, inputbufferbytecount: u32, inputbuffer: *const u8, outputbufferbytecount: *mut u32, outputbuffer: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InvokeFunction(functionid, inputbufferbytecount, inputbuffer, outputbufferbytecount, ::core::mem::transmute_copy(&outputbuffer)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPrivateDataByteCount<Impl: IMFContentProtectionDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, privateinputbytecount: *mut u32, privateoutputbytecount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPrivateDataByteCount(::core::mem::transmute_copy(&privateinputbytecount), ::core::mem::transmute_copy(&privateoutputbytecount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFContentProtectionDevice>, base.5, InvokeFunction::<Impl, OFFSET>, GetPrivateDataByteCount::<Impl, OFFSET>)
    }
}
pub trait IMFContentProtectionManagerImpl: Sized {
    fn BeginEnableContent();
    fn EndEnableContent();
}
impl ::windows::core::RuntimeName for IMFContentProtectionManager {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFContentProtectionManager";
}
impl IMFContentProtectionManagerVtbl {
    pub const fn new<Impl: IMFContentProtectionManagerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFContentProtectionManagerVtbl {
        unsafe extern "system" fn BeginEnableContent<Impl: IMFContentProtectionManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, penableractivate: ::windows::core::RawPtr, ptopo: ::windows::core::RawPtr, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginEnableContent(
                &*(&penableractivate as *const <IMFActivate as ::windows::core::Abi>::Abi as *const <IMFActivate as ::windows::core::DefaultType>::DefaultType),
                &*(&ptopo as *const <IMFTopology as ::windows::core::Abi>::Abi as *const <IMFTopology as ::windows::core::DefaultType>::DefaultType),
                &*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType),
                &*(&punkstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndEnableContent<Impl: IMFContentProtectionManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndEnableContent(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFContentProtectionManager>, base.5, BeginEnableContent::<Impl, OFFSET>, EndEnableContent::<Impl, OFFSET>)
    }
}
pub trait IMFD3D12SynchronizationObjectImpl: Sized {
    fn SignalEventOnFinalResourceRelease();
    fn Reset();
}
impl ::windows::core::RuntimeName for IMFD3D12SynchronizationObject {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFD3D12SynchronizationObject";
}
impl IMFD3D12SynchronizationObjectVtbl {
    pub const fn new<Impl: IMFD3D12SynchronizationObjectImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFD3D12SynchronizationObjectVtbl {
        unsafe extern "system" fn SignalEventOnFinalResourceRelease<Impl: IMFD3D12SynchronizationObjectImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hevent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SignalEventOnFinalResourceRelease(&*(&hevent as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Reset<Impl: IMFD3D12SynchronizationObjectImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFD3D12SynchronizationObject>, base.5, SignalEventOnFinalResourceRelease::<Impl, OFFSET>, Reset::<Impl, OFFSET>)
    }
}
pub trait IMFD3D12SynchronizationObjectCommandsImpl: Sized {
    fn EnqueueResourceReady();
    fn EnqueueResourceReadyWait();
    fn SignalEventOnResourceReady();
    fn EnqueueResourceRelease();
}
impl ::windows::core::RuntimeName for IMFD3D12SynchronizationObjectCommands {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFD3D12SynchronizationObjectCommands";
}
impl IMFD3D12SynchronizationObjectCommandsVtbl {
    pub const fn new<Impl: IMFD3D12SynchronizationObjectCommandsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFD3D12SynchronizationObjectCommandsVtbl {
        unsafe extern "system" fn EnqueueResourceReady<Impl: IMFD3D12SynchronizationObjectCommandsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pproducercommandqueue: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnqueueResourceReady(&*(&pproducercommandqueue as *const <super::super::Graphics::Direct3D12::ID3D12CommandQueue as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12CommandQueue as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnqueueResourceReadyWait<Impl: IMFD3D12SynchronizationObjectCommandsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pconsumercommandqueue: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnqueueResourceReadyWait(&*(&pconsumercommandqueue as *const <super::super::Graphics::Direct3D12::ID3D12CommandQueue as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12CommandQueue as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SignalEventOnResourceReady<Impl: IMFD3D12SynchronizationObjectCommandsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hevent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SignalEventOnResourceReady(&*(&hevent as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnqueueResourceRelease<Impl: IMFD3D12SynchronizationObjectCommandsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pconsumercommandqueue: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnqueueResourceRelease(&*(&pconsumercommandqueue as *const <super::super::Graphics::Direct3D12::ID3D12CommandQueue as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Direct3D12::ID3D12CommandQueue as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFD3D12SynchronizationObjectCommands>, base.5, EnqueueResourceReady::<Impl, OFFSET>, EnqueueResourceReadyWait::<Impl, OFFSET>, SignalEventOnResourceReady::<Impl, OFFSET>, EnqueueResourceRelease::<Impl, OFFSET>)
    }
}
pub trait IMFDLNASinkInitImpl: Sized {
    fn Initialize();
}
impl ::windows::core::RuntimeName for IMFDLNASinkInit {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFDLNASinkInit";
}
impl IMFDLNASinkInitVtbl {
    pub const fn new<Impl: IMFDLNASinkInitImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFDLNASinkInitVtbl {
        unsafe extern "system" fn Initialize<Impl: IMFDLNASinkInitImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbytestream: ::windows::core::RawPtr, fpal: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Initialize(&*(&pbytestream as *const <IMFByteStream as ::windows::core::Abi>::Abi as *const <IMFByteStream as ::windows::core::DefaultType>::DefaultType), &*(&fpal as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFDLNASinkInit>, base.5, Initialize::<Impl, OFFSET>)
    }
}
pub trait IMFDRMNetHelperImpl: Sized {
    fn ProcessLicenseRequest();
    fn GetChainedLicenseResponse();
}
impl ::windows::core::RuntimeName for IMFDRMNetHelper {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFDRMNetHelper";
}
impl IMFDRMNetHelperVtbl {
    pub const fn new<Impl: IMFDRMNetHelperImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFDRMNetHelperVtbl {
        unsafe extern "system" fn ProcessLicenseRequest<Impl: IMFDRMNetHelperImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plicenserequest: *const u8, cblicenserequest: u32, pplicenseresponse: *mut *mut u8, pcblicenseresponse: *mut u32, pbstrkid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProcessLicenseRequest(plicenserequest, cblicenserequest, ::core::mem::transmute_copy(&pplicenseresponse), ::core::mem::transmute_copy(&pcblicenseresponse), ::core::mem::transmute_copy(&pbstrkid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetChainedLicenseResponse<Impl: IMFDRMNetHelperImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pplicenseresponse: *mut *mut u8, pcblicenseresponse: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetChainedLicenseResponse(::core::mem::transmute_copy(&pplicenseresponse), ::core::mem::transmute_copy(&pcblicenseresponse)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFDRMNetHelper>, base.5, ProcessLicenseRequest::<Impl, OFFSET>, GetChainedLicenseResponse::<Impl, OFFSET>)
    }
}
pub trait IMFDXGIBufferImpl: Sized {
    fn GetResource();
    fn GetSubresourceIndex();
    fn GetUnknown();
    fn SetUnknown();
}
impl ::windows::core::RuntimeName for IMFDXGIBuffer {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFDXGIBuffer";
}
impl IMFDXGIBufferVtbl {
    pub const fn new<Impl: IMFDXGIBufferImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFDXGIBufferVtbl {
        unsafe extern "system" fn GetResource<Impl: IMFDXGIBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetResource(&*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppvobject)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSubresourceIndex<Impl: IMFDXGIBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pusubresource: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSubresourceIndex(::core::mem::transmute_copy(&pusubresource)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetUnknown<Impl: IMFDXGIBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guid: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetUnknown(&*(&guid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppvobject)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUnknown<Impl: IMFDXGIBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guid: *const ::windows::core::GUID, punkdata: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetUnknown(&*(&guid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&punkdata as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFDXGIBuffer>, base.5, GetResource::<Impl, OFFSET>, GetSubresourceIndex::<Impl, OFFSET>, GetUnknown::<Impl, OFFSET>, SetUnknown::<Impl, OFFSET>)
    }
}
pub trait IMFDXGIDeviceManagerImpl: Sized {
    fn CloseDeviceHandle();
    fn GetVideoService();
    fn LockDevice();
    fn OpenDeviceHandle();
    fn ResetDevice();
    fn TestDevice();
    fn UnlockDevice();
}
impl ::windows::core::RuntimeName for IMFDXGIDeviceManager {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFDXGIDeviceManager";
}
impl IMFDXGIDeviceManagerVtbl {
    pub const fn new<Impl: IMFDXGIDeviceManagerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFDXGIDeviceManagerVtbl {
        unsafe extern "system" fn CloseDeviceHandle<Impl: IMFDXGIDeviceManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CloseDeviceHandle(&*(&hdevice as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoService<Impl: IMFDXGIDeviceManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, riid: *const ::windows::core::GUID, ppservice: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoService(&*(&hdevice as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType), &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppservice)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LockDevice<Impl: IMFDXGIDeviceManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, riid: *const ::windows::core::GUID, ppunkdevice: *mut *mut ::core::ffi::c_void, fblock: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LockDevice(
                &*(&hdevice as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType),
                &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&ppunkdevice),
                &*(&fblock as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OpenDeviceHandle<Impl: IMFDXGIDeviceManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phdevice: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OpenDeviceHandle(::core::mem::transmute_copy(&phdevice)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ResetDevice<Impl: IMFDXGIDeviceManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, punkdevice: *mut ::core::ffi::c_void, resettoken: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ResetDevice(&*(&punkdevice as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType), resettoken) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TestDevice<Impl: IMFDXGIDeviceManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TestDevice(&*(&hdevice as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnlockDevice<Impl: IMFDXGIDeviceManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, fsavestate: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnlockDevice(&*(&hdevice as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType), &*(&fsavestate as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFDXGIDeviceManager>, base.5, CloseDeviceHandle::<Impl, OFFSET>, GetVideoService::<Impl, OFFSET>, LockDevice::<Impl, OFFSET>, OpenDeviceHandle::<Impl, OFFSET>, ResetDevice::<Impl, OFFSET>, TestDevice::<Impl, OFFSET>, UnlockDevice::<Impl, OFFSET>)
    }
}
pub trait IMFDXGIDeviceManagerSourceImpl: Sized {
    fn GetManager();
}
impl ::windows::core::RuntimeName for IMFDXGIDeviceManagerSource {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFDXGIDeviceManagerSource";
}
impl IMFDXGIDeviceManagerSourceVtbl {
    pub const fn new<Impl: IMFDXGIDeviceManagerSourceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFDXGIDeviceManagerSourceVtbl {
        unsafe extern "system" fn GetManager<Impl: IMFDXGIDeviceManagerSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppmanager: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetManager(::core::mem::transmute_copy(&ppmanager)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFDXGIDeviceManagerSource>, base.5, GetManager::<Impl, OFFSET>)
    }
}
pub trait IMFDesiredSampleImpl: Sized {
    fn GetDesiredSampleTimeAndDuration();
    fn SetDesiredSampleTimeAndDuration();
    fn Clear();
}
impl ::windows::core::RuntimeName for IMFDesiredSample {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFDesiredSample";
}
impl IMFDesiredSampleVtbl {
    pub const fn new<Impl: IMFDesiredSampleImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFDesiredSampleVtbl {
        unsafe extern "system" fn GetDesiredSampleTimeAndDuration<Impl: IMFDesiredSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phnssampletime: *mut i64, phnssampleduration: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDesiredSampleTimeAndDuration(::core::mem::transmute_copy(&phnssampletime), ::core::mem::transmute_copy(&phnssampleduration)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDesiredSampleTimeAndDuration<Impl: IMFDesiredSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnssampletime: i64, hnssampleduration: i64) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).SetDesiredSampleTimeAndDuration(hnssampletime, hnssampleduration).into()
        }
        unsafe extern "system" fn Clear<Impl: IMFDesiredSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Clear().into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFDesiredSample>, base.5, GetDesiredSampleTimeAndDuration::<Impl, OFFSET>, SetDesiredSampleTimeAndDuration::<Impl, OFFSET>, Clear::<Impl, OFFSET>)
    }
}
pub trait IMFExtendedCameraControlImpl: Sized {
    fn GetCapabilities();
    fn SetFlags();
    fn GetFlags();
    fn LockPayload();
    fn UnlockPayload();
    fn CommitSettings();
}
impl ::windows::core::RuntimeName for IMFExtendedCameraControl {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFExtendedCameraControl";
}
impl IMFExtendedCameraControlVtbl {
    pub const fn new<Impl: IMFExtendedCameraControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFExtendedCameraControlVtbl {
        unsafe extern "system" fn GetCapabilities<Impl: IMFExtendedCameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u64 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCapabilities() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFlags<Impl: IMFExtendedCameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulflags: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFlags(ulflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFlags<Impl: IMFExtendedCameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u64 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFlags() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LockPayload<Impl: IMFExtendedCameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pppayload: *mut *mut u8, pulpayload: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LockPayload(::core::mem::transmute_copy(&pppayload), ::core::mem::transmute_copy(&pulpayload)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnlockPayload<Impl: IMFExtendedCameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnlockPayload() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CommitSettings<Impl: IMFExtendedCameraControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CommitSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFExtendedCameraControl>, base.5, GetCapabilities::<Impl, OFFSET>, SetFlags::<Impl, OFFSET>, GetFlags::<Impl, OFFSET>, LockPayload::<Impl, OFFSET>, UnlockPayload::<Impl, OFFSET>, CommitSettings::<Impl, OFFSET>)
    }
}
pub trait IMFExtendedCameraControllerImpl: Sized {
    fn GetExtendedCameraControl();
}
impl ::windows::core::RuntimeName for IMFExtendedCameraController {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFExtendedCameraController";
}
impl IMFExtendedCameraControllerVtbl {
    pub const fn new<Impl: IMFExtendedCameraControllerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFExtendedCameraControllerVtbl {
        unsafe extern "system" fn GetExtendedCameraControl<Impl: IMFExtendedCameraControllerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, ulpropertyid: u32, ppcontrol: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetExtendedCameraControl(dwstreamindex, ulpropertyid, ::core::mem::transmute_copy(&ppcontrol)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFExtendedCameraController>, base.5, GetExtendedCameraControl::<Impl, OFFSET>)
    }
}
pub trait IMFExtendedCameraIntrinsicModelImpl: Sized {
    fn GetModel();
    fn SetModel();
    fn GetDistortionModelType();
}
impl ::windows::core::RuntimeName for IMFExtendedCameraIntrinsicModel {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFExtendedCameraIntrinsicModel";
}
impl IMFExtendedCameraIntrinsicModelVtbl {
    pub const fn new<Impl: IMFExtendedCameraIntrinsicModelImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFExtendedCameraIntrinsicModelVtbl {
        unsafe extern "system" fn GetModel<Impl: IMFExtendedCameraIntrinsicModelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pintrinsicmodel: *mut MFExtendedCameraIntrinsic_IntrinsicModel) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetModel(::core::mem::transmute_copy(&pintrinsicmodel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetModel<Impl: IMFExtendedCameraIntrinsicModelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pintrinsicmodel: *const MFExtendedCameraIntrinsic_IntrinsicModel) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetModel(&*(&pintrinsicmodel as *const <MFExtendedCameraIntrinsic_IntrinsicModel as ::windows::core::Abi>::Abi as *const <MFExtendedCameraIntrinsic_IntrinsicModel as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDistortionModelType<Impl: IMFExtendedCameraIntrinsicModelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdistortionmodeltype: *mut MFCameraIntrinsic_DistortionModelType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDistortionModelType(::core::mem::transmute_copy(&pdistortionmodeltype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFExtendedCameraIntrinsicModel>, base.5, GetModel::<Impl, OFFSET>, SetModel::<Impl, OFFSET>, GetDistortionModelType::<Impl, OFFSET>)
    }
}
pub trait IMFExtendedCameraIntrinsicsImpl: Sized {
    fn InitializeFromBuffer();
    fn GetBufferSize();
    fn SerializeToBuffer();
    fn GetIntrinsicModelCount();
    fn GetIntrinsicModelByIndex();
    fn AddIntrinsicModel();
}
impl ::windows::core::RuntimeName for IMFExtendedCameraIntrinsics {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFExtendedCameraIntrinsics";
}
impl IMFExtendedCameraIntrinsicsVtbl {
    pub const fn new<Impl: IMFExtendedCameraIntrinsicsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFExtendedCameraIntrinsicsVtbl {
        unsafe extern "system" fn InitializeFromBuffer<Impl: IMFExtendedCameraIntrinsicsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbbuffer: *const u8, dwbuffersize: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InitializeFromBuffer(pbbuffer, dwbuffersize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBufferSize<Impl: IMFExtendedCameraIntrinsicsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwbuffersize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBufferSize(::core::mem::transmute_copy(&pdwbuffersize)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SerializeToBuffer<Impl: IMFExtendedCameraIntrinsicsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbbuffer: *mut u8, pdwbuffersize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SerializeToBuffer(::core::mem::transmute_copy(&pbbuffer), pdwbuffersize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIntrinsicModelCount<Impl: IMFExtendedCameraIntrinsicsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIntrinsicModelCount(::core::mem::transmute_copy(&pdwcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIntrinsicModelByIndex<Impl: IMFExtendedCameraIntrinsicsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppintrinsicmodel: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIntrinsicModelByIndex(dwindex, ::core::mem::transmute_copy(&ppintrinsicmodel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddIntrinsicModel<Impl: IMFExtendedCameraIntrinsicsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pintrinsicmodel: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddIntrinsicModel(&*(&pintrinsicmodel as *const <IMFExtendedCameraIntrinsicModel as ::windows::core::Abi>::Abi as *const <IMFExtendedCameraIntrinsicModel as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFExtendedCameraIntrinsics>, base.5, InitializeFromBuffer::<Impl, OFFSET>, GetBufferSize::<Impl, OFFSET>, SerializeToBuffer::<Impl, OFFSET>, GetIntrinsicModelCount::<Impl, OFFSET>, GetIntrinsicModelByIndex::<Impl, OFFSET>, AddIntrinsicModel::<Impl, OFFSET>)
    }
}
pub trait IMFExtendedCameraIntrinsicsDistortionModel6KTImpl: Sized {
    fn GetDistortionModel();
    fn SetDistortionModel();
}
impl ::windows::core::RuntimeName for IMFExtendedCameraIntrinsicsDistortionModel6KT {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFExtendedCameraIntrinsicsDistortionModel6KT";
}
impl IMFExtendedCameraIntrinsicsDistortionModel6KTVtbl {
    pub const fn new<Impl: IMFExtendedCameraIntrinsicsDistortionModel6KTImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFExtendedCameraIntrinsicsDistortionModel6KTVtbl {
        unsafe extern "system" fn GetDistortionModel<Impl: IMFExtendedCameraIntrinsicsDistortionModel6KTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdistortionmodel: *mut MFCameraIntrinsic_DistortionModel6KT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDistortionModel(::core::mem::transmute_copy(&pdistortionmodel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDistortionModel<Impl: IMFExtendedCameraIntrinsicsDistortionModel6KTImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdistortionmodel: *const MFCameraIntrinsic_DistortionModel6KT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDistortionModel(&*(&pdistortionmodel as *const <MFCameraIntrinsic_DistortionModel6KT as ::windows::core::Abi>::Abi as *const <MFCameraIntrinsic_DistortionModel6KT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFExtendedCameraIntrinsicsDistortionModel6KT>, base.5, GetDistortionModel::<Impl, OFFSET>, SetDistortionModel::<Impl, OFFSET>)
    }
}
pub trait IMFExtendedCameraIntrinsicsDistortionModelArcTanImpl: Sized {
    fn GetDistortionModel();
    fn SetDistortionModel();
}
impl ::windows::core::RuntimeName for IMFExtendedCameraIntrinsicsDistortionModelArcTan {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFExtendedCameraIntrinsicsDistortionModelArcTan";
}
impl IMFExtendedCameraIntrinsicsDistortionModelArcTanVtbl {
    pub const fn new<Impl: IMFExtendedCameraIntrinsicsDistortionModelArcTanImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFExtendedCameraIntrinsicsDistortionModelArcTanVtbl {
        unsafe extern "system" fn GetDistortionModel<Impl: IMFExtendedCameraIntrinsicsDistortionModelArcTanImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdistortionmodel: *mut MFCameraIntrinsic_DistortionModelArcTan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDistortionModel(::core::mem::transmute_copy(&pdistortionmodel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDistortionModel<Impl: IMFExtendedCameraIntrinsicsDistortionModelArcTanImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdistortionmodel: *const MFCameraIntrinsic_DistortionModelArcTan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDistortionModel(&*(&pdistortionmodel as *const <MFCameraIntrinsic_DistortionModelArcTan as ::windows::core::Abi>::Abi as *const <MFCameraIntrinsic_DistortionModelArcTan as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFExtendedCameraIntrinsicsDistortionModelArcTan>, base.5, GetDistortionModel::<Impl, OFFSET>, SetDistortionModel::<Impl, OFFSET>)
    }
}
pub trait IMFExtendedDRMTypeSupportImpl: Sized {
    fn IsTypeSupportedEx();
}
impl ::windows::core::RuntimeName for IMFExtendedDRMTypeSupport {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFExtendedDRMTypeSupport";
}
impl IMFExtendedDRMTypeSupportVtbl {
    pub const fn new<Impl: IMFExtendedDRMTypeSupportImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFExtendedDRMTypeSupportVtbl {
        unsafe extern "system" fn IsTypeSupportedEx<Impl: IMFExtendedDRMTypeSupportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, r#type: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, keysystem: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, panswer: *mut MF_MEDIA_ENGINE_CANPLAY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTypeSupportedEx(&*(&r#type as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), &*(&keysystem as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&panswer)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFExtendedDRMTypeSupport>, base.5, IsTypeSupportedEx::<Impl, OFFSET>)
    }
}
pub trait IMFFieldOfUseMFTUnlockImpl: Sized {
    fn Unlock();
}
impl ::windows::core::RuntimeName for IMFFieldOfUseMFTUnlock {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFFieldOfUseMFTUnlock";
}
impl IMFFieldOfUseMFTUnlockVtbl {
    pub const fn new<Impl: IMFFieldOfUseMFTUnlockImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFFieldOfUseMFTUnlockVtbl {
        unsafe extern "system" fn Unlock<Impl: IMFFieldOfUseMFTUnlockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, punkmft: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Unlock(&*(&punkmft as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFFieldOfUseMFTUnlock>, base.5, Unlock::<Impl, OFFSET>)
    }
}
pub trait IMFFinalizableMediaSinkImpl: Sized + IMFMediaSinkImpl {
    fn BeginFinalize();
    fn EndFinalize();
}
impl ::windows::core::RuntimeName for IMFFinalizableMediaSink {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFFinalizableMediaSink";
}
impl IMFFinalizableMediaSinkVtbl {
    pub const fn new<Impl: IMFFinalizableMediaSinkImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFFinalizableMediaSinkVtbl {
        unsafe extern "system" fn BeginFinalize<Impl: IMFFinalizableMediaSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginFinalize(&*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType), &*(&punkstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndFinalize<Impl: IMFFinalizableMediaSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndFinalize(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFFinalizableMediaSink>, base.5, BeginFinalize::<Impl, OFFSET>, EndFinalize::<Impl, OFFSET>)
    }
}
pub trait IMFGetServiceImpl: Sized {
    fn GetService();
}
impl ::windows::core::RuntimeName for IMFGetService {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFGetService";
}
impl IMFGetServiceVtbl {
    pub const fn new<Impl: IMFGetServiceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFGetServiceVtbl {
        unsafe extern "system" fn GetService<Impl: IMFGetServiceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetService(&*(&guidservice as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppvobject)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFGetService>, base.5, GetService::<Impl, OFFSET>)
    }
}
pub trait IMFHDCPStatusImpl: Sized {
    fn Query();
    fn Set();
}
impl ::windows::core::RuntimeName for IMFHDCPStatus {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFHDCPStatus";
}
impl IMFHDCPStatusVtbl {
    pub const fn new<Impl: IMFHDCPStatusImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFHDCPStatusVtbl {
        unsafe extern "system" fn Query<Impl: IMFHDCPStatusImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstatus: *mut MF_HDCP_STATUS, pfstatus: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Query(pstatus, &*(&pfstatus as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Set<Impl: IMFHDCPStatusImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, status: MF_HDCP_STATUS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Set(status) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFHDCPStatus>, base.5, Query::<Impl, OFFSET>, Set::<Impl, OFFSET>)
    }
}
pub trait IMFHttpDownloadRequestImpl: Sized {
    fn AddHeader();
    fn BeginSendRequest();
    fn EndSendRequest();
    fn BeginReceiveResponse();
    fn EndReceiveResponse();
    fn BeginReadPayload();
    fn EndReadPayload();
    fn QueryHeader();
    fn GetURL();
    fn HasNullSourceOrigin();
    fn GetTimeSeekResult();
    fn GetHttpStatus();
    fn GetAtEndOfPayload();
    fn GetTotalLength();
    fn GetRangeEndOffset();
    fn Close();
}
impl ::windows::core::RuntimeName for IMFHttpDownloadRequest {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFHttpDownloadRequest";
}
impl IMFHttpDownloadRequestVtbl {
    pub const fn new<Impl: IMFHttpDownloadRequestImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFHttpDownloadRequestVtbl {
        unsafe extern "system" fn AddHeader<Impl: IMFHttpDownloadRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, szheader: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddHeader(&*(&szheader as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginSendRequest<Impl: IMFHttpDownloadRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbpayload: *const u8, cbpayload: u32, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginSendRequest(pbpayload, cbpayload, &*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType), &*(&punkstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndSendRequest<Impl: IMFHttpDownloadRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndSendRequest(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginReceiveResponse<Impl: IMFHttpDownloadRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginReceiveResponse(&*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType), &*(&punkstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndReceiveResponse<Impl: IMFHttpDownloadRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndReceiveResponse(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginReadPayload<Impl: IMFHttpDownloadRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pb: *mut u8, cb: u32, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginReadPayload(::core::mem::transmute_copy(&pb), cb, &*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType), &*(&punkstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndReadPayload<Impl: IMFHttpDownloadRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, pqwoffset: *mut u64, pcbread: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndReadPayload(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pqwoffset), ::core::mem::transmute_copy(&pcbread)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueryHeader<Impl: IMFHttpDownloadRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, szheadername: super::super::Foundation::PWSTR, dwindex: u32, ppszheadervalue: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueryHeader(&*(&szheadername as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), dwindex, ::core::mem::transmute_copy(&ppszheadervalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetURL<Impl: IMFHttpDownloadRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppszurl: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetURL(::core::mem::transmute_copy(&ppszurl)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HasNullSourceOrigin<Impl: IMFHttpDownloadRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfnullsourceorigin: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HasNullSourceOrigin(::core::mem::transmute_copy(&pfnullsourceorigin)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTimeSeekResult<Impl: IMFHttpDownloadRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pqwstarttime: *mut u64, pqwstoptime: *mut u64, pqwduration: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTimeSeekResult(::core::mem::transmute_copy(&pqwstarttime), ::core::mem::transmute_copy(&pqwstoptime), ::core::mem::transmute_copy(&pqwduration)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetHttpStatus<Impl: IMFHttpDownloadRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwhttpstatus: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetHttpStatus(::core::mem::transmute_copy(&pdwhttpstatus)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAtEndOfPayload<Impl: IMFHttpDownloadRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfatendofpayload: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAtEndOfPayload(::core::mem::transmute_copy(&pfatendofpayload)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTotalLength<Impl: IMFHttpDownloadRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pqwtotallength: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTotalLength(::core::mem::transmute_copy(&pqwtotallength)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRangeEndOffset<Impl: IMFHttpDownloadRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pqwrangeend: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRangeEndOffset(::core::mem::transmute_copy(&pqwrangeend)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Close<Impl: IMFHttpDownloadRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Close() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMFHttpDownloadRequest>,
            base.5,
            AddHeader::<Impl, OFFSET>,
            BeginSendRequest::<Impl, OFFSET>,
            EndSendRequest::<Impl, OFFSET>,
            BeginReceiveResponse::<Impl, OFFSET>,
            EndReceiveResponse::<Impl, OFFSET>,
            BeginReadPayload::<Impl, OFFSET>,
            EndReadPayload::<Impl, OFFSET>,
            QueryHeader::<Impl, OFFSET>,
            GetURL::<Impl, OFFSET>,
            HasNullSourceOrigin::<Impl, OFFSET>,
            GetTimeSeekResult::<Impl, OFFSET>,
            GetHttpStatus::<Impl, OFFSET>,
            GetAtEndOfPayload::<Impl, OFFSET>,
            GetTotalLength::<Impl, OFFSET>,
            GetRangeEndOffset::<Impl, OFFSET>,
            Close::<Impl, OFFSET>,
        )
    }
}
pub trait IMFHttpDownloadSessionImpl: Sized {
    fn SetServer();
    fn CreateRequest();
    fn Close();
}
impl ::windows::core::RuntimeName for IMFHttpDownloadSession {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFHttpDownloadSession";
}
impl IMFHttpDownloadSessionVtbl {
    pub const fn new<Impl: IMFHttpDownloadSessionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFHttpDownloadSessionVtbl {
        unsafe extern "system" fn SetServer<Impl: IMFHttpDownloadSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, szservername: super::super::Foundation::PWSTR, nport: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetServer(&*(&szservername as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), nport) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateRequest<Impl: IMFHttpDownloadSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, szobjectname: super::super::Foundation::PWSTR, fbypassproxycache: super::super::Foundation::BOOL, fsecure: super::super::Foundation::BOOL, szverb: super::super::Foundation::PWSTR, szreferrer: super::super::Foundation::PWSTR, pprequest: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateRequest(
                &*(&szobjectname as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&fbypassproxycache as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
                &*(&fsecure as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
                &*(&szverb as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&szreferrer as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&pprequest),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Close<Impl: IMFHttpDownloadSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Close() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFHttpDownloadSession>, base.5, SetServer::<Impl, OFFSET>, CreateRequest::<Impl, OFFSET>, Close::<Impl, OFFSET>)
    }
}
pub trait IMFHttpDownloadSessionProviderImpl: Sized {
    fn CreateHttpDownloadSession();
}
impl ::windows::core::RuntimeName for IMFHttpDownloadSessionProvider {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFHttpDownloadSessionProvider";
}
impl IMFHttpDownloadSessionProviderVtbl {
    pub const fn new<Impl: IMFHttpDownloadSessionProviderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFHttpDownloadSessionProviderVtbl {
        unsafe extern "system" fn CreateHttpDownloadSession<Impl: IMFHttpDownloadSessionProviderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wszscheme: super::super::Foundation::PWSTR, ppdownloadsession: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateHttpDownloadSession(&*(&wszscheme as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppdownloadsession)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFHttpDownloadSessionProvider>, base.5, CreateHttpDownloadSession::<Impl, OFFSET>)
    }
}
pub trait IMFImageSharingEngineImpl: Sized {
    fn SetSource();
    fn GetDevice();
    fn Shutdown();
}
impl ::windows::core::RuntimeName for IMFImageSharingEngine {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFImageSharingEngine";
}
impl IMFImageSharingEngineVtbl {
    pub const fn new<Impl: IMFImageSharingEngineImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFImageSharingEngineVtbl {
        unsafe extern "system" fn SetSource<Impl: IMFImageSharingEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstream: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSource(&*(&pstream as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDevice<Impl: IMFImageSharingEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdevice: *mut DEVICE_INFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDevice(::core::mem::transmute_copy(&pdevice)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Shutdown<Impl: IMFImageSharingEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Shutdown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFImageSharingEngine>, base.5, SetSource::<Impl, OFFSET>, GetDevice::<Impl, OFFSET>, Shutdown::<Impl, OFFSET>)
    }
}
pub trait IMFImageSharingEngineClassFactoryImpl: Sized {
    fn CreateInstanceFromUDN();
}
impl ::windows::core::RuntimeName for IMFImageSharingEngineClassFactory {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFImageSharingEngineClassFactory";
}
impl IMFImageSharingEngineClassFactoryVtbl {
    pub const fn new<Impl: IMFImageSharingEngineClassFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFImageSharingEngineClassFactoryVtbl {
        unsafe extern "system" fn CreateInstanceFromUDN<Impl: IMFImageSharingEngineClassFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, puniquedevicename: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, ppengine: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstanceFromUDN(&*(&puniquedevicename as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppengine)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFImageSharingEngineClassFactory>, base.5, CreateInstanceFromUDN::<Impl, OFFSET>)
    }
}
pub trait IMFInputTrustAuthorityImpl: Sized {
    fn GetDecrypter();
    fn RequestAccess();
    fn GetPolicy();
    fn BindAccess();
    fn UpdateAccess();
    fn Reset();
}
impl ::windows::core::RuntimeName for IMFInputTrustAuthority {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFInputTrustAuthority";
}
impl IMFInputTrustAuthorityVtbl {
    pub const fn new<Impl: IMFInputTrustAuthorityImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFInputTrustAuthorityVtbl {
        unsafe extern "system" fn GetDecrypter<Impl: IMFInputTrustAuthorityImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDecrypter(&*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppv)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RequestAccess<Impl: IMFInputTrustAuthorityImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, action: MFPOLICYMANAGER_ACTION, ppcontentenableractivate: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RequestAccess(action, ::core::mem::transmute_copy(&ppcontentenableractivate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPolicy<Impl: IMFInputTrustAuthorityImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, action: MFPOLICYMANAGER_ACTION, pppolicy: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPolicy(action, ::core::mem::transmute_copy(&pppolicy)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BindAccess<Impl: IMFInputTrustAuthorityImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pparam: *const MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BindAccess(&*(&pparam as *const <MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS as ::windows::core::Abi>::Abi as *const <MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UpdateAccess<Impl: IMFInputTrustAuthorityImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pparam: *const MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UpdateAccess(&*(&pparam as *const <MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS as ::windows::core::Abi>::Abi as *const <MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Reset<Impl: IMFInputTrustAuthorityImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Reset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFInputTrustAuthority>, base.5, GetDecrypter::<Impl, OFFSET>, RequestAccess::<Impl, OFFSET>, GetPolicy::<Impl, OFFSET>, BindAccess::<Impl, OFFSET>, UpdateAccess::<Impl, OFFSET>, Reset::<Impl, OFFSET>)
    }
}
pub trait IMFLocalMFTRegistrationImpl: Sized {
    fn RegisterMFTs();
}
impl ::windows::core::RuntimeName for IMFLocalMFTRegistration {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFLocalMFTRegistration";
}
impl IMFLocalMFTRegistrationVtbl {
    pub const fn new<Impl: IMFLocalMFTRegistrationImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFLocalMFTRegistrationVtbl {
        unsafe extern "system" fn RegisterMFTs<Impl: IMFLocalMFTRegistrationImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmfts: *const MFT_REGISTRATION_INFO, cmfts: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterMFTs(&*(&pmfts as *const <MFT_REGISTRATION_INFO as ::windows::core::Abi>::Abi as *const <MFT_REGISTRATION_INFO as ::windows::core::DefaultType>::DefaultType), cmfts) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFLocalMFTRegistration>, base.5, RegisterMFTs::<Impl, OFFSET>)
    }
}
pub trait IMFMediaBufferImpl: Sized {
    fn Lock();
    fn Unlock();
    fn GetCurrentLength();
    fn SetCurrentLength();
    fn GetMaxLength();
}
impl ::windows::core::RuntimeName for IMFMediaBuffer {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaBuffer";
}
impl IMFMediaBufferVtbl {
    pub const fn new<Impl: IMFMediaBufferImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaBufferVtbl {
        unsafe extern "system" fn Lock<Impl: IMFMediaBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppbbuffer: *mut *mut u8, pcbmaxlength: *mut u32, pcbcurrentlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Lock(::core::mem::transmute_copy(&ppbbuffer), ::core::mem::transmute_copy(&pcbmaxlength), ::core::mem::transmute_copy(&pcbcurrentlength)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Unlock<Impl: IMFMediaBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Unlock() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentLength<Impl: IMFMediaBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcbcurrentlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentLength(::core::mem::transmute_copy(&pcbcurrentlength)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentLength<Impl: IMFMediaBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cbcurrentlength: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCurrentLength(cbcurrentlength) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMaxLength<Impl: IMFMediaBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcbmaxlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMaxLength(::core::mem::transmute_copy(&pcbmaxlength)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaBuffer>, base.5, Lock::<Impl, OFFSET>, Unlock::<Impl, OFFSET>, GetCurrentLength::<Impl, OFFSET>, SetCurrentLength::<Impl, OFFSET>, GetMaxLength::<Impl, OFFSET>)
    }
}
pub trait IMFMediaEngineImpl: Sized {
    fn GetError();
    fn SetErrorCode();
    fn SetSourceElements();
    fn SetSource();
    fn GetCurrentSource();
    fn GetNetworkState();
    fn GetPreload();
    fn SetPreload();
    fn GetBuffered();
    fn Load();
    fn CanPlayType();
    fn GetReadyState();
    fn IsSeeking();
    fn GetCurrentTime();
    fn SetCurrentTime();
    fn GetStartTime();
    fn GetDuration();
    fn IsPaused();
    fn GetDefaultPlaybackRate();
    fn SetDefaultPlaybackRate();
    fn GetPlaybackRate();
    fn SetPlaybackRate();
    fn GetPlayed();
    fn GetSeekable();
    fn IsEnded();
    fn GetAutoPlay();
    fn SetAutoPlay();
    fn GetLoop();
    fn SetLoop();
    fn Play();
    fn Pause();
    fn GetMuted();
    fn SetMuted();
    fn GetVolume();
    fn SetVolume();
    fn HasVideo();
    fn HasAudio();
    fn GetNativeVideoSize();
    fn GetVideoAspectRatio();
    fn Shutdown();
    fn TransferVideoFrame();
    fn OnVideoStreamTick();
}
impl ::windows::core::RuntimeName for IMFMediaEngine {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaEngine";
}
impl IMFMediaEngineVtbl {
    pub const fn new<Impl: IMFMediaEngineImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaEngineVtbl {
        unsafe extern "system" fn GetError<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pperror: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetError(::core::mem::transmute_copy(&pperror)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetErrorCode<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, error: MF_MEDIA_ENGINE_ERR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetErrorCode(error) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourceElements<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psrcelements: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSourceElements(&*(&psrcelements as *const <IMFMediaEngineSrcElements as ::windows::core::Abi>::Abi as *const <IMFMediaEngineSrcElements as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSource<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, purl: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSource(&*(&purl as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentSource<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppurl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentSource(::core::mem::transmute_copy(&ppurl)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNetworkState<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u16 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNetworkState() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPreload<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> MF_MEDIA_ENGINE_PRELOAD {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPreload() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPreload<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, preload: MF_MEDIA_ENGINE_PRELOAD) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPreload(preload) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBuffered<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppbuffered: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBuffered(::core::mem::transmute_copy(&ppbuffered)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Load<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Load() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanPlayType<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, r#type: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, panswer: *mut MF_MEDIA_ENGINE_CANPLAY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanPlayType(&*(&r#type as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&panswer)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetReadyState<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u16 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetReadyState() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSeeking<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSeeking() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentTime<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentTime<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, seektime: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCurrentTime(seektime) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStartTime<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStartTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDuration<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDuration() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPaused<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsPaused() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDefaultPlaybackRate<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDefaultPlaybackRate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultPlaybackRate<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, rate: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDefaultPlaybackRate(rate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPlaybackRate<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPlaybackRate() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPlaybackRate<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, rate: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPlaybackRate(rate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPlayed<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppplayed: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPlayed(::core::mem::transmute_copy(&ppplayed)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSeekable<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppseekable: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSeekable(::core::mem::transmute_copy(&ppseekable)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsEnded<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsEnded() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAutoPlay<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAutoPlay() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAutoPlay<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, autoplay: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAutoPlay(&*(&autoplay as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLoop<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLoop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLoop<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, r#loop: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLoop(&*(&r#loop as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Play<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Play() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pause<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pause() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMuted<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMuted() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMuted<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, muted: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMuted(&*(&muted as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVolume<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVolume() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVolume<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, volume: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVolume(volume) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HasVideo<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HasVideo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HasAudio<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HasAudio() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNativeVideoSize<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cx: *mut u32, cy: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNativeVideoSize(::core::mem::transmute_copy(&cx), ::core::mem::transmute_copy(&cy)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoAspectRatio<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cx: *mut u32, cy: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoAspectRatio(::core::mem::transmute_copy(&cx), ::core::mem::transmute_copy(&cy)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Shutdown<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Shutdown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TransferVideoFrame<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdstsurf: *mut ::core::ffi::c_void, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const MFARGB) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TransferVideoFrame(
                &*(&pdstsurf as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType),
                &*(&psrc as *const <MFVideoNormalizedRect as ::windows::core::Abi>::Abi as *const <MFVideoNormalizedRect as ::windows::core::DefaultType>::DefaultType),
                &*(&pdst as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType),
                &*(&pborderclr as *const <MFARGB as ::windows::core::Abi>::Abi as *const <MFARGB as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnVideoStreamTick<Impl: IMFMediaEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppts: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnVideoStreamTick(::core::mem::transmute_copy(&ppts)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMFMediaEngine>,
            base.5,
            GetError::<Impl, OFFSET>,
            SetErrorCode::<Impl, OFFSET>,
            SetSourceElements::<Impl, OFFSET>,
            SetSource::<Impl, OFFSET>,
            GetCurrentSource::<Impl, OFFSET>,
            GetNetworkState::<Impl, OFFSET>,
            GetPreload::<Impl, OFFSET>,
            SetPreload::<Impl, OFFSET>,
            GetBuffered::<Impl, OFFSET>,
            Load::<Impl, OFFSET>,
            CanPlayType::<Impl, OFFSET>,
            GetReadyState::<Impl, OFFSET>,
            IsSeeking::<Impl, OFFSET>,
            GetCurrentTime::<Impl, OFFSET>,
            SetCurrentTime::<Impl, OFFSET>,
            GetStartTime::<Impl, OFFSET>,
            GetDuration::<Impl, OFFSET>,
            IsPaused::<Impl, OFFSET>,
            GetDefaultPlaybackRate::<Impl, OFFSET>,
            SetDefaultPlaybackRate::<Impl, OFFSET>,
            GetPlaybackRate::<Impl, OFFSET>,
            SetPlaybackRate::<Impl, OFFSET>,
            GetPlayed::<Impl, OFFSET>,
            GetSeekable::<Impl, OFFSET>,
            IsEnded::<Impl, OFFSET>,
            GetAutoPlay::<Impl, OFFSET>,
            SetAutoPlay::<Impl, OFFSET>,
            GetLoop::<Impl, OFFSET>,
            SetLoop::<Impl, OFFSET>,
            Play::<Impl, OFFSET>,
            Pause::<Impl, OFFSET>,
            GetMuted::<Impl, OFFSET>,
            SetMuted::<Impl, OFFSET>,
            GetVolume::<Impl, OFFSET>,
            SetVolume::<Impl, OFFSET>,
            HasVideo::<Impl, OFFSET>,
            HasAudio::<Impl, OFFSET>,
            GetNativeVideoSize::<Impl, OFFSET>,
            GetVideoAspectRatio::<Impl, OFFSET>,
            Shutdown::<Impl, OFFSET>,
            TransferVideoFrame::<Impl, OFFSET>,
            OnVideoStreamTick::<Impl, OFFSET>,
        )
    }
}
pub trait IMFMediaEngineAudioEndpointIdImpl: Sized {
    fn SetAudioEndpointId();
    fn GetAudioEndpointId();
}
impl ::windows::core::RuntimeName for IMFMediaEngineAudioEndpointId {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaEngineAudioEndpointId";
}
impl IMFMediaEngineAudioEndpointIdVtbl {
    pub const fn new<Impl: IMFMediaEngineAudioEndpointIdImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaEngineAudioEndpointIdVtbl {
        unsafe extern "system" fn SetAudioEndpointId<Impl: IMFMediaEngineAudioEndpointIdImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszendpointid: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAudioEndpointId(&*(&pszendpointid as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAudioEndpointId<Impl: IMFMediaEngineAudioEndpointIdImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppszendpointid: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAudioEndpointId(::core::mem::transmute_copy(&ppszendpointid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaEngineAudioEndpointId>, base.5, SetAudioEndpointId::<Impl, OFFSET>, GetAudioEndpointId::<Impl, OFFSET>)
    }
}
pub trait IMFMediaEngineClassFactoryImpl: Sized {
    fn CreateInstance();
    fn CreateTimeRange();
    fn CreateError();
}
impl ::windows::core::RuntimeName for IMFMediaEngineClassFactory {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaEngineClassFactory";
}
impl IMFMediaEngineClassFactoryVtbl {
    pub const fn new<Impl: IMFMediaEngineClassFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaEngineClassFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMFMediaEngineClassFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32, pattr: ::windows::core::RawPtr, ppplayer: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(dwflags, &*(&pattr as *const <IMFAttributes as ::windows::core::Abi>::Abi as *const <IMFAttributes as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppplayer)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateTimeRange<Impl: IMFMediaEngineClassFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pptimerange: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateTimeRange(::core::mem::transmute_copy(&pptimerange)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateError<Impl: IMFMediaEngineClassFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pperror: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateError(::core::mem::transmute_copy(&pperror)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaEngineClassFactory>, base.5, CreateInstance::<Impl, OFFSET>, CreateTimeRange::<Impl, OFFSET>, CreateError::<Impl, OFFSET>)
    }
}
pub trait IMFMediaEngineClassFactory2Impl: Sized {
    fn CreateMediaKeys2();
}
impl ::windows::core::RuntimeName for IMFMediaEngineClassFactory2 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaEngineClassFactory2";
}
impl IMFMediaEngineClassFactory2Vtbl {
    pub const fn new<Impl: IMFMediaEngineClassFactory2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaEngineClassFactory2Vtbl {
        unsafe extern "system" fn CreateMediaKeys2<Impl: IMFMediaEngineClassFactory2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, keysystem: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, defaultcdmstorepath: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, inprivatecdmstorepath: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, ppkeys: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateMediaKeys2(
                &*(&keysystem as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&defaultcdmstorepath as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&inprivatecdmstorepath as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&ppkeys),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaEngineClassFactory2>, base.5, CreateMediaKeys2::<Impl, OFFSET>)
    }
}
pub trait IMFMediaEngineClassFactory3Impl: Sized {
    fn CreateMediaKeySystemAccess();
}
impl ::windows::core::RuntimeName for IMFMediaEngineClassFactory3 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaEngineClassFactory3";
}
impl IMFMediaEngineClassFactory3Vtbl {
    pub const fn new<Impl: IMFMediaEngineClassFactory3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaEngineClassFactory3Vtbl {
        unsafe extern "system" fn CreateMediaKeySystemAccess<Impl: IMFMediaEngineClassFactory3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, keysystem: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, ppsupportedconfigurationsarray: *const ::windows::core::RawPtr, usize: u32, ppkeyaccess: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateMediaKeySystemAccess(&*(&keysystem as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), &*(&ppsupportedconfigurationsarray as *const <super::super::UI::Shell::PropertiesSystem::IPropertyStore as ::windows::core::Abi>::Abi as *const <super::super::UI::Shell::PropertiesSystem::IPropertyStore as ::windows::core::DefaultType>::DefaultType), usize, ::core::mem::transmute_copy(&ppkeyaccess)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaEngineClassFactory3>, base.5, CreateMediaKeySystemAccess::<Impl, OFFSET>)
    }
}
pub trait IMFMediaEngineClassFactory4Impl: Sized {
    fn CreateContentDecryptionModuleFactory();
}
impl ::windows::core::RuntimeName for IMFMediaEngineClassFactory4 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaEngineClassFactory4";
}
impl IMFMediaEngineClassFactory4Vtbl {
    pub const fn new<Impl: IMFMediaEngineClassFactory4Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaEngineClassFactory4Vtbl {
        unsafe extern "system" fn CreateContentDecryptionModuleFactory<Impl: IMFMediaEngineClassFactory4Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, keysystem: super::super::Foundation::PWSTR, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateContentDecryptionModuleFactory(&*(&keysystem as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppvobject)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaEngineClassFactory4>, base.5, CreateContentDecryptionModuleFactory::<Impl, OFFSET>)
    }
}
pub trait IMFMediaEngineClassFactoryExImpl: Sized + IMFMediaEngineClassFactoryImpl {
    fn CreateMediaSourceExtension();
    fn CreateMediaKeys();
    fn IsTypeSupported();
}
impl ::windows::core::RuntimeName for IMFMediaEngineClassFactoryEx {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaEngineClassFactoryEx";
}
impl IMFMediaEngineClassFactoryExVtbl {
    pub const fn new<Impl: IMFMediaEngineClassFactoryExImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaEngineClassFactoryExVtbl {
        unsafe extern "system" fn CreateMediaSourceExtension<Impl: IMFMediaEngineClassFactoryExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32, pattr: ::windows::core::RawPtr, ppmse: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateMediaSourceExtension(dwflags, &*(&pattr as *const <IMFAttributes as ::windows::core::Abi>::Abi as *const <IMFAttributes as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppmse)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateMediaKeys<Impl: IMFMediaEngineClassFactoryExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, keysystem: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, cdmstorepath: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, ppkeys: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateMediaKeys(&*(&keysystem as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), &*(&cdmstorepath as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppkeys)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTypeSupported<Impl: IMFMediaEngineClassFactoryExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, r#type: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, keysystem: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, issupported: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTypeSupported(&*(&r#type as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), &*(&keysystem as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&issupported)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaEngineClassFactoryEx>, base.5, CreateMediaSourceExtension::<Impl, OFFSET>, CreateMediaKeys::<Impl, OFFSET>, IsTypeSupported::<Impl, OFFSET>)
    }
}
pub trait IMFMediaEngineEMEImpl: Sized {
    fn Keys();
    fn SetMediaKeys();
}
impl ::windows::core::RuntimeName for IMFMediaEngineEME {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaEngineEME";
}
impl IMFMediaEngineEMEVtbl {
    pub const fn new<Impl: IMFMediaEngineEMEImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaEngineEMEVtbl {
        unsafe extern "system" fn Keys<Impl: IMFMediaEngineEMEImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, keys: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Keys(::core::mem::transmute_copy(&keys)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaKeys<Impl: IMFMediaEngineEMEImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, keys: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMediaKeys(&*(&keys as *const <IMFMediaKeys as ::windows::core::Abi>::Abi as *const <IMFMediaKeys as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaEngineEME>, base.5, Keys::<Impl, OFFSET>, SetMediaKeys::<Impl, OFFSET>)
    }
}
pub trait IMFMediaEngineEMENotifyImpl: Sized {
    fn Encrypted();
    fn WaitingForKey();
}
impl ::windows::core::RuntimeName for IMFMediaEngineEMENotify {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaEngineEMENotify";
}
impl IMFMediaEngineEMENotifyVtbl {
    pub const fn new<Impl: IMFMediaEngineEMENotifyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaEngineEMENotifyVtbl {
        unsafe extern "system" fn Encrypted<Impl: IMFMediaEngineEMENotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbinitdata: *const u8, cb: u32, bstrinitdatatype: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Encrypted(pbinitdata, cb, &*(&bstrinitdatatype as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn WaitingForKey<Impl: IMFMediaEngineEMENotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).WaitingForKey().into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaEngineEMENotify>, base.5, Encrypted::<Impl, OFFSET>, WaitingForKey::<Impl, OFFSET>)
    }
}
pub trait IMFMediaEngineExImpl: Sized + IMFMediaEngineImpl {
    fn SetSourceFromByteStream();
    fn GetStatistics();
    fn UpdateVideoStream();
    fn GetBalance();
    fn SetBalance();
    fn IsPlaybackRateSupported();
    fn FrameStep();
    fn GetResourceCharacteristics();
    fn GetPresentationAttribute();
    fn GetNumberOfStreams();
    fn GetStreamAttribute();
    fn GetStreamSelection();
    fn SetStreamSelection();
    fn ApplyStreamSelections();
    fn IsProtected();
    fn InsertVideoEffect();
    fn InsertAudioEffect();
    fn RemoveAllEffects();
    fn SetTimelineMarkerTimer();
    fn GetTimelineMarkerTimer();
    fn CancelTimelineMarkerTimer();
    fn IsStereo3D();
    fn GetStereo3DFramePackingMode();
    fn SetStereo3DFramePackingMode();
    fn GetStereo3DRenderMode();
    fn SetStereo3DRenderMode();
    fn EnableWindowlessSwapchainMode();
    fn GetVideoSwapchainHandle();
    fn EnableHorizontalMirrorMode();
    fn GetAudioStreamCategory();
    fn SetAudioStreamCategory();
    fn GetAudioEndpointRole();
    fn SetAudioEndpointRole();
    fn GetRealTimeMode();
    fn SetRealTimeMode();
    fn SetCurrentTimeEx();
    fn EnableTimeUpdateTimer();
}
impl ::windows::core::RuntimeName for IMFMediaEngineEx {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaEngineEx";
}
impl IMFMediaEngineExVtbl {
    pub const fn new<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaEngineExVtbl {
        unsafe extern "system" fn SetSourceFromByteStream<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbytestream: ::windows::core::RawPtr, purl: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSourceFromByteStream(&*(&pbytestream as *const <IMFByteStream as ::windows::core::Abi>::Abi as *const <IMFByteStream as ::windows::core::DefaultType>::DefaultType), &*(&purl as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStatistics<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, statisticid: MF_MEDIA_ENGINE_STATISTIC, pstatistic: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStatistics(statisticid, ::core::mem::transmute_copy(&pstatistic)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UpdateVideoStream<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const MFARGB) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UpdateVideoStream(&*(&psrc as *const <MFVideoNormalizedRect as ::windows::core::Abi>::Abi as *const <MFVideoNormalizedRect as ::windows::core::DefaultType>::DefaultType), &*(&pdst as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType), &*(&pborderclr as *const <MFARGB as ::windows::core::Abi>::Abi as *const <MFARGB as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBalance<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBalance() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBalance<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, balance: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBalance(balance) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsPlaybackRateSupported<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, rate: f64) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsPlaybackRateSupported(rate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FrameStep<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, forward: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FrameStep(&*(&forward as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetResourceCharacteristics<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcharacteristics: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetResourceCharacteristics(::core::mem::transmute_copy(&pcharacteristics)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPresentationAttribute<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidmfattribute: *const ::windows::core::GUID, pvvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPresentationAttribute(&*(&guidmfattribute as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pvvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNumberOfStreams<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwstreamcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNumberOfStreams(::core::mem::transmute_copy(&pdwstreamcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamAttribute<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, guidmfattribute: *const ::windows::core::GUID, pvvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamAttribute(dwstreamindex, &*(&guidmfattribute as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pvvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamSelection<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, penabled: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamSelection(dwstreamindex, ::core::mem::transmute_copy(&penabled)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamSelection<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, enabled: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStreamSelection(dwstreamindex, &*(&enabled as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ApplyStreamSelections<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ApplyStreamSelections() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsProtected<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pprotected: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsProtected(::core::mem::transmute_copy(&pprotected)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InsertVideoEffect<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, peffect: *mut ::core::ffi::c_void, foptional: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InsertVideoEffect(&*(&peffect as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType), &*(&foptional as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InsertAudioEffect<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, peffect: *mut ::core::ffi::c_void, foptional: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InsertAudioEffect(&*(&peffect as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType), &*(&foptional as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveAllEffects<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveAllEffects() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTimelineMarkerTimer<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, timetofire: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTimelineMarkerTimer(timetofire) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTimelineMarkerTimer<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptimetofire: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTimelineMarkerTimer(::core::mem::transmute_copy(&ptimetofire)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CancelTimelineMarkerTimer<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CancelTimelineMarkerTimer() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsStereo3D<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsStereo3D() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStereo3DFramePackingMode<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, packmode: *mut MF_MEDIA_ENGINE_S3D_PACKING_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStereo3DFramePackingMode(::core::mem::transmute_copy(&packmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStereo3DFramePackingMode<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, packmode: MF_MEDIA_ENGINE_S3D_PACKING_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStereo3DFramePackingMode(packmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStereo3DRenderMode<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, outputtype: *mut MF3DVideoOutputType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStereo3DRenderMode(::core::mem::transmute_copy(&outputtype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStereo3DRenderMode<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, outputtype: MF3DVideoOutputType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStereo3DRenderMode(outputtype) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnableWindowlessSwapchainMode<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fenable: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnableWindowlessSwapchainMode(&*(&fenable as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoSwapchainHandle<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phswapchain: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoSwapchainHandle(::core::mem::transmute_copy(&phswapchain)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnableHorizontalMirrorMode<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fenable: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnableHorizontalMirrorMode(&*(&fenable as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAudioStreamCategory<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcategory: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAudioStreamCategory(::core::mem::transmute_copy(&pcategory)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAudioStreamCategory<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, category: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAudioStreamCategory(category) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAudioEndpointRole<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prole: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAudioEndpointRole(::core::mem::transmute_copy(&prole)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAudioEndpointRole<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, role: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAudioEndpointRole(role) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRealTimeMode<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfenabled: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRealTimeMode(::core::mem::transmute_copy(&pfenabled)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRealTimeMode<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fenable: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRealTimeMode(&*(&fenable as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentTimeEx<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, seektime: f64, seekmode: MF_MEDIA_ENGINE_SEEK_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCurrentTimeEx(seektime, seekmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnableTimeUpdateTimer<Impl: IMFMediaEngineExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fenabletimer: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnableTimeUpdateTimer(&*(&fenabletimer as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMFMediaEngineEx>,
            base.5,
            SetSourceFromByteStream::<Impl, OFFSET>,
            GetStatistics::<Impl, OFFSET>,
            UpdateVideoStream::<Impl, OFFSET>,
            GetBalance::<Impl, OFFSET>,
            SetBalance::<Impl, OFFSET>,
            IsPlaybackRateSupported::<Impl, OFFSET>,
            FrameStep::<Impl, OFFSET>,
            GetResourceCharacteristics::<Impl, OFFSET>,
            GetPresentationAttribute::<Impl, OFFSET>,
            GetNumberOfStreams::<Impl, OFFSET>,
            GetStreamAttribute::<Impl, OFFSET>,
            GetStreamSelection::<Impl, OFFSET>,
            SetStreamSelection::<Impl, OFFSET>,
            ApplyStreamSelections::<Impl, OFFSET>,
            IsProtected::<Impl, OFFSET>,
            InsertVideoEffect::<Impl, OFFSET>,
            InsertAudioEffect::<Impl, OFFSET>,
            RemoveAllEffects::<Impl, OFFSET>,
            SetTimelineMarkerTimer::<Impl, OFFSET>,
            GetTimelineMarkerTimer::<Impl, OFFSET>,
            CancelTimelineMarkerTimer::<Impl, OFFSET>,
            IsStereo3D::<Impl, OFFSET>,
            GetStereo3DFramePackingMode::<Impl, OFFSET>,
            SetStereo3DFramePackingMode::<Impl, OFFSET>,
            GetStereo3DRenderMode::<Impl, OFFSET>,
            SetStereo3DRenderMode::<Impl, OFFSET>,
            EnableWindowlessSwapchainMode::<Impl, OFFSET>,
            GetVideoSwapchainHandle::<Impl, OFFSET>,
            EnableHorizontalMirrorMode::<Impl, OFFSET>,
            GetAudioStreamCategory::<Impl, OFFSET>,
            SetAudioStreamCategory::<Impl, OFFSET>,
            GetAudioEndpointRole::<Impl, OFFSET>,
            SetAudioEndpointRole::<Impl, OFFSET>,
            GetRealTimeMode::<Impl, OFFSET>,
            SetRealTimeMode::<Impl, OFFSET>,
            SetCurrentTimeEx::<Impl, OFFSET>,
            EnableTimeUpdateTimer::<Impl, OFFSET>,
        )
    }
}
pub trait IMFMediaEngineExtensionImpl: Sized {
    fn CanPlayType();
    fn BeginCreateObject();
    fn CancelObjectCreation();
    fn EndCreateObject();
}
impl ::windows::core::RuntimeName for IMFMediaEngineExtension {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaEngineExtension";
}
impl IMFMediaEngineExtensionVtbl {
    pub const fn new<Impl: IMFMediaEngineExtensionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaEngineExtensionVtbl {
        unsafe extern "system" fn CanPlayType<Impl: IMFMediaEngineExtensionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, audioonly: super::super::Foundation::BOOL, mimetype: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, panswer: *mut MF_MEDIA_ENGINE_CANPLAY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CanPlayType(&*(&audioonly as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType), &*(&mimetype as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&panswer)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginCreateObject<Impl: IMFMediaEngineExtensionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bstrurl: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pbytestream: ::windows::core::RawPtr, r#type: MF_OBJECT_TYPE, ppiunknowncancelcookie: *mut *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginCreateObject(
                &*(&bstrurl as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&pbytestream as *const <IMFByteStream as ::windows::core::Abi>::Abi as *const <IMFByteStream as ::windows::core::DefaultType>::DefaultType),
                r#type,
                ::core::mem::transmute_copy(&ppiunknowncancelcookie),
                &*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType),
                &*(&punkstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CancelObjectCreation<Impl: IMFMediaEngineExtensionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, piunknowncancelcookie: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CancelObjectCreation(&*(&piunknowncancelcookie as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndCreateObject<Impl: IMFMediaEngineExtensionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndCreateObject(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppobject)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaEngineExtension>, base.5, CanPlayType::<Impl, OFFSET>, BeginCreateObject::<Impl, OFFSET>, CancelObjectCreation::<Impl, OFFSET>, EndCreateObject::<Impl, OFFSET>)
    }
}
pub trait IMFMediaEngineNeedKeyNotifyImpl: Sized {
    fn NeedKey();
}
impl ::windows::core::RuntimeName for IMFMediaEngineNeedKeyNotify {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaEngineNeedKeyNotify";
}
impl IMFMediaEngineNeedKeyNotifyVtbl {
    pub const fn new<Impl: IMFMediaEngineNeedKeyNotifyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaEngineNeedKeyNotifyVtbl {
        unsafe extern "system" fn NeedKey<Impl: IMFMediaEngineNeedKeyNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, initdata: *const u8, cb: u32) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).NeedKey(initdata, cb).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaEngineNeedKeyNotify>, base.5, NeedKey::<Impl, OFFSET>)
    }
}
pub trait IMFMediaEngineNotifyImpl: Sized {
    fn EventNotify();
}
impl ::windows::core::RuntimeName for IMFMediaEngineNotify {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaEngineNotify";
}
impl IMFMediaEngineNotifyVtbl {
    pub const fn new<Impl: IMFMediaEngineNotifyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaEngineNotifyVtbl {
        unsafe extern "system" fn EventNotify<Impl: IMFMediaEngineNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, event: u32, param1: usize, param2: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EventNotify(event, param1, param2) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaEngineNotify>, base.5, EventNotify::<Impl, OFFSET>)
    }
}
pub trait IMFMediaEngineOPMInfoImpl: Sized {
    fn GetOPMInfo();
}
impl ::windows::core::RuntimeName for IMFMediaEngineOPMInfo {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaEngineOPMInfo";
}
impl IMFMediaEngineOPMInfoVtbl {
    pub const fn new<Impl: IMFMediaEngineOPMInfoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaEngineOPMInfoVtbl {
        unsafe extern "system" fn GetOPMInfo<Impl: IMFMediaEngineOPMInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstatus: *mut MF_MEDIA_ENGINE_OPM_STATUS, pconstricted: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOPMInfo(::core::mem::transmute_copy(&pstatus), ::core::mem::transmute_copy(&pconstricted)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaEngineOPMInfo>, base.5, GetOPMInfo::<Impl, OFFSET>)
    }
}
pub trait IMFMediaEngineProtectedContentImpl: Sized {
    fn ShareResources();
    fn GetRequiredProtections();
    fn SetOPMWindow();
    fn TransferVideoFrame();
    fn SetContentProtectionManager();
    fn SetApplicationCertificate();
}
impl ::windows::core::RuntimeName for IMFMediaEngineProtectedContent {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaEngineProtectedContent";
}
impl IMFMediaEngineProtectedContentVtbl {
    pub const fn new<Impl: IMFMediaEngineProtectedContentImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaEngineProtectedContentVtbl {
        unsafe extern "system" fn ShareResources<Impl: IMFMediaEngineProtectedContentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, punkdevicecontext: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShareResources(&*(&punkdevicecontext as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRequiredProtections<Impl: IMFMediaEngineProtectedContentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pframeprotectionflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRequiredProtections(::core::mem::transmute_copy(&pframeprotectionflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOPMWindow<Impl: IMFMediaEngineProtectedContentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hwnd: super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOPMWindow(&*(&hwnd as *const <super::super::Foundation::HWND as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HWND as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TransferVideoFrame<Impl: IMFMediaEngineProtectedContentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdstsurf: *mut ::core::ffi::c_void, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const MFARGB, pframeprotectionflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TransferVideoFrame(
                &*(&pdstsurf as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType),
                &*(&psrc as *const <MFVideoNormalizedRect as ::windows::core::Abi>::Abi as *const <MFVideoNormalizedRect as ::windows::core::DefaultType>::DefaultType),
                &*(&pdst as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType),
                &*(&pborderclr as *const <MFARGB as ::windows::core::Abi>::Abi as *const <MFARGB as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&pframeprotectionflags),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentProtectionManager<Impl: IMFMediaEngineProtectedContentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcpm: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetContentProtectionManager(&*(&pcpm as *const <IMFContentProtectionManager as ::windows::core::Abi>::Abi as *const <IMFContentProtectionManager as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetApplicationCertificate<Impl: IMFMediaEngineProtectedContentImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbblob: *const u8, cbblob: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetApplicationCertificate(pbblob, cbblob) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaEngineProtectedContent>, base.5, ShareResources::<Impl, OFFSET>, GetRequiredProtections::<Impl, OFFSET>, SetOPMWindow::<Impl, OFFSET>, TransferVideoFrame::<Impl, OFFSET>, SetContentProtectionManager::<Impl, OFFSET>, SetApplicationCertificate::<Impl, OFFSET>)
    }
}
pub trait IMFMediaEngineSrcElementsImpl: Sized {
    fn GetLength();
    fn GetURL();
    fn GetType();
    fn GetMedia();
    fn AddElement();
    fn RemoveAllElements();
}
impl ::windows::core::RuntimeName for IMFMediaEngineSrcElements {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaEngineSrcElements";
}
impl IMFMediaEngineSrcElementsVtbl {
    pub const fn new<Impl: IMFMediaEngineSrcElementsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaEngineSrcElementsVtbl {
        unsafe extern "system" fn GetLength<Impl: IMFMediaEngineSrcElementsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetURL<Impl: IMFMediaEngineSrcElementsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: u32, purl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetURL(index, ::core::mem::transmute_copy(&purl)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetType<Impl: IMFMediaEngineSrcElementsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: u32, ptype: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetType(index, ::core::mem::transmute_copy(&ptype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMedia<Impl: IMFMediaEngineSrcElementsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: u32, pmedia: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMedia(index, ::core::mem::transmute_copy(&pmedia)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddElement<Impl: IMFMediaEngineSrcElementsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, purl: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, ptype: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pmedia: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddElement(
                &*(&purl as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&ptype as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&pmedia as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveAllElements<Impl: IMFMediaEngineSrcElementsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveAllElements() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaEngineSrcElements>, base.5, GetLength::<Impl, OFFSET>, GetURL::<Impl, OFFSET>, GetType::<Impl, OFFSET>, GetMedia::<Impl, OFFSET>, AddElement::<Impl, OFFSET>, RemoveAllElements::<Impl, OFFSET>)
    }
}
pub trait IMFMediaEngineSrcElementsExImpl: Sized + IMFMediaEngineSrcElementsImpl {
    fn AddElementEx();
    fn GetKeySystem();
}
impl ::windows::core::RuntimeName for IMFMediaEngineSrcElementsEx {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaEngineSrcElementsEx";
}
impl IMFMediaEngineSrcElementsExVtbl {
    pub const fn new<Impl: IMFMediaEngineSrcElementsExImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaEngineSrcElementsExVtbl {
        unsafe extern "system" fn AddElementEx<Impl: IMFMediaEngineSrcElementsExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, purl: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, ptype: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pmedia: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, keysystem: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddElementEx(
                &*(&purl as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&ptype as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&pmedia as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&keysystem as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetKeySystem<Impl: IMFMediaEngineSrcElementsExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: u32, ptype: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetKeySystem(index, ::core::mem::transmute_copy(&ptype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaEngineSrcElementsEx>, base.5, AddElementEx::<Impl, OFFSET>, GetKeySystem::<Impl, OFFSET>)
    }
}
pub trait IMFMediaEngineSupportsSourceTransferImpl: Sized {
    fn ShouldTransferSource();
    fn DetachMediaSource();
    fn AttachMediaSource();
}
impl ::windows::core::RuntimeName for IMFMediaEngineSupportsSourceTransfer {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaEngineSupportsSourceTransfer";
}
impl IMFMediaEngineSupportsSourceTransferVtbl {
    pub const fn new<Impl: IMFMediaEngineSupportsSourceTransferImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaEngineSupportsSourceTransferVtbl {
        unsafe extern "system" fn ShouldTransferSource<Impl: IMFMediaEngineSupportsSourceTransferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfshouldtransfer: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShouldTransferSource(::core::mem::transmute_copy(&pfshouldtransfer)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DetachMediaSource<Impl: IMFMediaEngineSupportsSourceTransferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppbytestream: *mut ::windows::core::RawPtr, ppmediasource: *mut ::windows::core::RawPtr, ppmse: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DetachMediaSource(::core::mem::transmute_copy(&ppbytestream), ::core::mem::transmute_copy(&ppmediasource), ::core::mem::transmute_copy(&ppmse)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AttachMediaSource<Impl: IMFMediaEngineSupportsSourceTransferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbytestream: ::windows::core::RawPtr, pmediasource: ::windows::core::RawPtr, pmse: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AttachMediaSource(&*(&pbytestream as *const <IMFByteStream as ::windows::core::Abi>::Abi as *const <IMFByteStream as ::windows::core::DefaultType>::DefaultType), &*(&pmediasource as *const <IMFMediaSource as ::windows::core::Abi>::Abi as *const <IMFMediaSource as ::windows::core::DefaultType>::DefaultType), &*(&pmse as *const <IMFMediaSourceExtension as ::windows::core::Abi>::Abi as *const <IMFMediaSourceExtension as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaEngineSupportsSourceTransfer>, base.5, ShouldTransferSource::<Impl, OFFSET>, DetachMediaSource::<Impl, OFFSET>, AttachMediaSource::<Impl, OFFSET>)
    }
}
pub trait IMFMediaEngineTransferSourceImpl: Sized {
    fn TransferSourceToMediaEngine();
}
impl ::windows::core::RuntimeName for IMFMediaEngineTransferSource {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaEngineTransferSource";
}
impl IMFMediaEngineTransferSourceVtbl {
    pub const fn new<Impl: IMFMediaEngineTransferSourceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaEngineTransferSourceVtbl {
        unsafe extern "system" fn TransferSourceToMediaEngine<Impl: IMFMediaEngineTransferSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, destination: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).TransferSourceToMediaEngine(&*(&destination as *const <IMFMediaEngine as ::windows::core::Abi>::Abi as *const <IMFMediaEngine as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaEngineTransferSource>, base.5, TransferSourceToMediaEngine::<Impl, OFFSET>)
    }
}
pub trait IMFMediaEngineWebSupportImpl: Sized {
    fn ShouldDelayTheLoadEvent();
    fn ConnectWebAudio();
    fn DisconnectWebAudio();
}
impl ::windows::core::RuntimeName for IMFMediaEngineWebSupport {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaEngineWebSupport";
}
impl IMFMediaEngineWebSupportVtbl {
    pub const fn new<Impl: IMFMediaEngineWebSupportImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaEngineWebSupportVtbl {
        unsafe extern "system" fn ShouldDelayTheLoadEvent<Impl: IMFMediaEngineWebSupportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ShouldDelayTheLoadEvent() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConnectWebAudio<Impl: IMFMediaEngineWebSupportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsamplerate: u32, ppsourceprovider: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConnectWebAudio(dwsamplerate, ::core::mem::transmute_copy(&ppsourceprovider)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisconnectWebAudio<Impl: IMFMediaEngineWebSupportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisconnectWebAudio() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaEngineWebSupport>, base.5, ShouldDelayTheLoadEvent::<Impl, OFFSET>, ConnectWebAudio::<Impl, OFFSET>, DisconnectWebAudio::<Impl, OFFSET>)
    }
}
pub trait IMFMediaErrorImpl: Sized {
    fn GetErrorCode();
    fn GetExtendedErrorCode();
    fn SetErrorCode();
    fn SetExtendedErrorCode();
}
impl ::windows::core::RuntimeName for IMFMediaError {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaError";
}
impl IMFMediaErrorVtbl {
    pub const fn new<Impl: IMFMediaErrorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaErrorVtbl {
        unsafe extern "system" fn GetErrorCode<Impl: IMFMediaErrorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u16 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetErrorCode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetExtendedErrorCode<Impl: IMFMediaErrorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetExtendedErrorCode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetErrorCode<Impl: IMFMediaErrorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, error: MF_MEDIA_ENGINE_ERR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetErrorCode(error) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetExtendedErrorCode<Impl: IMFMediaErrorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, error: ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetExtendedErrorCode(error) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaError>, base.5, GetErrorCode::<Impl, OFFSET>, GetExtendedErrorCode::<Impl, OFFSET>, SetErrorCode::<Impl, OFFSET>, SetExtendedErrorCode::<Impl, OFFSET>)
    }
}
pub trait IMFMediaEventImpl: Sized + IMFAttributesImpl {
    fn GetType();
    fn GetExtendedType();
    fn GetStatus();
    fn GetValue();
}
impl ::windows::core::RuntimeName for IMFMediaEvent {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaEvent";
}
impl IMFMediaEventVtbl {
    pub const fn new<Impl: IMFMediaEventImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaEventVtbl {
        unsafe extern "system" fn GetType<Impl: IMFMediaEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmet: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetType(::core::mem::transmute_copy(&pmet)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetExtendedType<Impl: IMFMediaEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguidextendedtype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetExtendedType(::core::mem::transmute_copy(&pguidextendedtype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStatus<Impl: IMFMediaEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phrstatus: *mut ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStatus(::core::mem::transmute_copy(&phrstatus)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetValue<Impl: IMFMediaEventImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetValue(::core::mem::transmute_copy(&pvvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaEvent>, base.5, GetType::<Impl, OFFSET>, GetExtendedType::<Impl, OFFSET>, GetStatus::<Impl, OFFSET>, GetValue::<Impl, OFFSET>)
    }
}
pub trait IMFMediaEventGeneratorImpl: Sized {
    fn GetEvent();
    fn BeginGetEvent();
    fn EndGetEvent();
    fn QueueEvent();
}
impl ::windows::core::RuntimeName for IMFMediaEventGenerator {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaEventGenerator";
}
impl IMFMediaEventGeneratorVtbl {
    pub const fn new<Impl: IMFMediaEventGeneratorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaEventGeneratorVtbl {
        unsafe extern "system" fn GetEvent<Impl: IMFMediaEventGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS, ppevent: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEvent(dwflags, ::core::mem::transmute_copy(&ppevent)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginGetEvent<Impl: IMFMediaEventGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginGetEvent(&*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType), &*(&punkstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndGetEvent<Impl: IMFMediaEventGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, ppevent: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndGetEvent(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppevent)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueueEvent<Impl: IMFMediaEventGeneratorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, met: u32, guidextendedtype: *const ::windows::core::GUID, hrstatus: ::windows::core::HRESULT, pvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueueEvent(met, &*(&guidextendedtype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), hrstatus, &*(&pvvalue as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaEventGenerator>, base.5, GetEvent::<Impl, OFFSET>, BeginGetEvent::<Impl, OFFSET>, EndGetEvent::<Impl, OFFSET>, QueueEvent::<Impl, OFFSET>)
    }
}
pub trait IMFMediaEventQueueImpl: Sized {
    fn GetEvent();
    fn BeginGetEvent();
    fn EndGetEvent();
    fn QueueEvent();
    fn QueueEventParamVar();
    fn QueueEventParamUnk();
    fn Shutdown();
}
impl ::windows::core::RuntimeName for IMFMediaEventQueue {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaEventQueue";
}
impl IMFMediaEventQueueVtbl {
    pub const fn new<Impl: IMFMediaEventQueueImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaEventQueueVtbl {
        unsafe extern "system" fn GetEvent<Impl: IMFMediaEventQueueImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32, ppevent: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEvent(dwflags, ::core::mem::transmute_copy(&ppevent)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginGetEvent<Impl: IMFMediaEventQueueImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginGetEvent(&*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType), &*(&punkstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndGetEvent<Impl: IMFMediaEventQueueImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, ppevent: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndGetEvent(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppevent)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueueEvent<Impl: IMFMediaEventQueueImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pevent: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueueEvent(&*(&pevent as *const <IMFMediaEvent as ::windows::core::Abi>::Abi as *const <IMFMediaEvent as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueueEventParamVar<Impl: IMFMediaEventQueueImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, met: u32, guidextendedtype: *const ::windows::core::GUID, hrstatus: ::windows::core::HRESULT, pvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueueEventParamVar(met, &*(&guidextendedtype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), hrstatus, &*(&pvvalue as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueueEventParamUnk<Impl: IMFMediaEventQueueImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, met: u32, guidextendedtype: *const ::windows::core::GUID, hrstatus: ::windows::core::HRESULT, punk: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).QueueEventParamUnk(met, &*(&guidextendedtype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), hrstatus, &*(&punk as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Shutdown<Impl: IMFMediaEventQueueImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Shutdown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaEventQueue>, base.5, GetEvent::<Impl, OFFSET>, BeginGetEvent::<Impl, OFFSET>, EndGetEvent::<Impl, OFFSET>, QueueEvent::<Impl, OFFSET>, QueueEventParamVar::<Impl, OFFSET>, QueueEventParamUnk::<Impl, OFFSET>, Shutdown::<Impl, OFFSET>)
    }
}
pub trait IMFMediaKeySessionImpl: Sized {
    fn GetError();
    fn KeySystem();
    fn SessionId();
    fn Update();
    fn Close();
}
impl ::windows::core::RuntimeName for IMFMediaKeySession {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaKeySession";
}
impl IMFMediaKeySessionVtbl {
    pub const fn new<Impl: IMFMediaKeySessionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaKeySessionVtbl {
        unsafe extern "system" fn GetError<Impl: IMFMediaKeySessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, code: *mut u16, systemcode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetError(::core::mem::transmute_copy(&code), ::core::mem::transmute_copy(&systemcode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KeySystem<Impl: IMFMediaKeySessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, keysystem: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KeySystem(::core::mem::transmute_copy(&keysystem)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SessionId<Impl: IMFMediaKeySessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, sessionid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SessionId(::core::mem::transmute_copy(&sessionid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Update<Impl: IMFMediaKeySessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, key: *const u8, cb: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Update(key, cb) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Close<Impl: IMFMediaKeySessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Close() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaKeySession>, base.5, GetError::<Impl, OFFSET>, KeySystem::<Impl, OFFSET>, SessionId::<Impl, OFFSET>, Update::<Impl, OFFSET>, Close::<Impl, OFFSET>)
    }
}
pub trait IMFMediaKeySession2Impl: Sized + IMFMediaKeySessionImpl {
    fn KeyStatuses();
    fn Load();
    fn GenerateRequest();
    fn Expiration();
    fn Remove();
    fn Shutdown();
}
impl ::windows::core::RuntimeName for IMFMediaKeySession2 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaKeySession2";
}
impl IMFMediaKeySession2Vtbl {
    pub const fn new<Impl: IMFMediaKeySession2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaKeySession2Vtbl {
        unsafe extern "system" fn KeyStatuses<Impl: IMFMediaKeySession2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pkeystatusesarray: *mut *mut MFMediaKeyStatus, pusize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KeyStatuses(::core::mem::transmute_copy(&pkeystatusesarray), ::core::mem::transmute_copy(&pusize)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Load<Impl: IMFMediaKeySession2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bstrsessionid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pfloaded: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Load(&*(&bstrsessionid as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pfloaded)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GenerateRequest<Impl: IMFMediaKeySession2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, initdatatype: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pbinitdata: *const u8, cb: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GenerateRequest(&*(&initdatatype as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), pbinitdata, cb) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Expiration<Impl: IMFMediaKeySession2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dblexpiration: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Expiration(::core::mem::transmute_copy(&dblexpiration)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Remove<Impl: IMFMediaKeySession2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Remove() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Shutdown<Impl: IMFMediaKeySession2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Shutdown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaKeySession2>, base.5, KeyStatuses::<Impl, OFFSET>, Load::<Impl, OFFSET>, GenerateRequest::<Impl, OFFSET>, Expiration::<Impl, OFFSET>, Remove::<Impl, OFFSET>, Shutdown::<Impl, OFFSET>)
    }
}
pub trait IMFMediaKeySessionNotifyImpl: Sized {
    fn KeyMessage();
    fn KeyAdded();
    fn KeyError();
}
impl ::windows::core::RuntimeName for IMFMediaKeySessionNotify {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaKeySessionNotify";
}
impl IMFMediaKeySessionNotifyVtbl {
    pub const fn new<Impl: IMFMediaKeySessionNotifyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaKeySessionNotifyVtbl {
        unsafe extern "system" fn KeyMessage<Impl: IMFMediaKeySessionNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, destinationurl: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, message: *const u8, cb: u32) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).KeyMessage(&*(&destinationurl as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), message, cb).into()
        }
        unsafe extern "system" fn KeyAdded<Impl: IMFMediaKeySessionNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).KeyAdded().into()
        }
        unsafe extern "system" fn KeyError<Impl: IMFMediaKeySessionNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, code: u16, systemcode: u32) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).KeyError(code, systemcode).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaKeySessionNotify>, base.5, KeyMessage::<Impl, OFFSET>, KeyAdded::<Impl, OFFSET>, KeyError::<Impl, OFFSET>)
    }
}
pub trait IMFMediaKeySessionNotify2Impl: Sized + IMFMediaKeySessionNotifyImpl {
    fn KeyMessage2();
    fn KeyStatusChange();
}
impl ::windows::core::RuntimeName for IMFMediaKeySessionNotify2 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaKeySessionNotify2";
}
impl IMFMediaKeySessionNotify2Vtbl {
    pub const fn new<Impl: IMFMediaKeySessionNotify2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaKeySessionNotify2Vtbl {
        unsafe extern "system" fn KeyMessage2<Impl: IMFMediaKeySessionNotify2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, emessagetype: MF_MEDIAKEYSESSION_MESSAGETYPE, destinationurl: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pbmessage: *const u8, cbmessage: u32) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).KeyMessage2(emessagetype, &*(&destinationurl as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), pbmessage, cbmessage).into()
        }
        unsafe extern "system" fn KeyStatusChange<Impl: IMFMediaKeySessionNotify2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).KeyStatusChange().into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaKeySessionNotify2>, base.5, KeyMessage2::<Impl, OFFSET>, KeyStatusChange::<Impl, OFFSET>)
    }
}
pub trait IMFMediaKeySystemAccessImpl: Sized {
    fn CreateMediaKeys();
    fn SupportedConfiguration();
    fn KeySystem();
}
impl ::windows::core::RuntimeName for IMFMediaKeySystemAccess {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaKeySystemAccess";
}
impl IMFMediaKeySystemAccessVtbl {
    pub const fn new<Impl: IMFMediaKeySystemAccessImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaKeySystemAccessVtbl {
        unsafe extern "system" fn CreateMediaKeys<Impl: IMFMediaKeySystemAccessImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcdmcustomconfig: ::windows::core::RawPtr, ppkeys: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateMediaKeys(&*(&pcdmcustomconfig as *const <super::super::UI::Shell::PropertiesSystem::IPropertyStore as ::windows::core::Abi>::Abi as *const <super::super::UI::Shell::PropertiesSystem::IPropertyStore as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppkeys)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SupportedConfiguration<Impl: IMFMediaKeySystemAccessImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppsupportedconfiguration: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SupportedConfiguration(::core::mem::transmute_copy(&ppsupportedconfiguration)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KeySystem<Impl: IMFMediaKeySystemAccessImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pkeysystem: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KeySystem(::core::mem::transmute_copy(&pkeysystem)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaKeySystemAccess>, base.5, CreateMediaKeys::<Impl, OFFSET>, SupportedConfiguration::<Impl, OFFSET>, KeySystem::<Impl, OFFSET>)
    }
}
pub trait IMFMediaKeysImpl: Sized {
    fn CreateSession();
    fn KeySystem();
    fn Shutdown();
    fn GetSuspendNotify();
}
impl ::windows::core::RuntimeName for IMFMediaKeys {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaKeys";
}
impl IMFMediaKeysVtbl {
    pub const fn new<Impl: IMFMediaKeysImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaKeysVtbl {
        unsafe extern "system" fn CreateSession<Impl: IMFMediaKeysImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mimetype: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, initdata: *const u8, cb: u32, customdata: *const u8, cbcustomdata: u32, notify: ::windows::core::RawPtr, ppsession: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateSession(&*(&mimetype as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), initdata, cb, customdata, cbcustomdata, &*(&notify as *const <IMFMediaKeySessionNotify as ::windows::core::Abi>::Abi as *const <IMFMediaKeySessionNotify as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppsession)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KeySystem<Impl: IMFMediaKeysImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, keysystem: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).KeySystem(::core::mem::transmute_copy(&keysystem)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Shutdown<Impl: IMFMediaKeysImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Shutdown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSuspendNotify<Impl: IMFMediaKeysImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, notify: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSuspendNotify(::core::mem::transmute_copy(&notify)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaKeys>, base.5, CreateSession::<Impl, OFFSET>, KeySystem::<Impl, OFFSET>, Shutdown::<Impl, OFFSET>, GetSuspendNotify::<Impl, OFFSET>)
    }
}
pub trait IMFMediaKeys2Impl: Sized + IMFMediaKeysImpl {
    fn CreateSession2();
    fn SetServerCertificate();
    fn GetDOMException();
}
impl ::windows::core::RuntimeName for IMFMediaKeys2 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaKeys2";
}
impl IMFMediaKeys2Vtbl {
    pub const fn new<Impl: IMFMediaKeys2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaKeys2Vtbl {
        unsafe extern "system" fn CreateSession2<Impl: IMFMediaKeys2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, esessiontype: MF_MEDIAKEYSESSION_TYPE, pmfmediakeysessionnotify2: ::windows::core::RawPtr, ppsession: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateSession2(esessiontype, &*(&pmfmediakeysessionnotify2 as *const <IMFMediaKeySessionNotify2 as ::windows::core::Abi>::Abi as *const <IMFMediaKeySessionNotify2 as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppsession)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetServerCertificate<Impl: IMFMediaKeys2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbservercertificate: *const u8, cb: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetServerCertificate(pbservercertificate, cb) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDOMException<Impl: IMFMediaKeys2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, systemcode: ::windows::core::HRESULT, code: *mut ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDOMException(systemcode, ::core::mem::transmute_copy(&code)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaKeys2>, base.5, CreateSession2::<Impl, OFFSET>, SetServerCertificate::<Impl, OFFSET>, GetDOMException::<Impl, OFFSET>)
    }
}
pub trait IMFMediaSessionImpl: Sized + IMFMediaEventGeneratorImpl {
    fn SetTopology();
    fn ClearTopologies();
    fn Start();
    fn Pause();
    fn Stop();
    fn Close();
    fn Shutdown();
    fn GetClock();
    fn GetSessionCapabilities();
    fn GetFullTopology();
}
impl ::windows::core::RuntimeName for IMFMediaSession {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaSession";
}
impl IMFMediaSessionVtbl {
    pub const fn new<Impl: IMFMediaSessionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaSessionVtbl {
        unsafe extern "system" fn SetTopology<Impl: IMFMediaSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsettopologyflags: u32, ptopology: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTopology(dwsettopologyflags, &*(&ptopology as *const <IMFTopology as ::windows::core::Abi>::Abi as *const <IMFTopology as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ClearTopologies<Impl: IMFMediaSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ClearTopologies() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Start<Impl: IMFMediaSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguidtimeformat: *const ::windows::core::GUID, pvarstartposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Start(&*(&pguidtimeformat as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&pvarstartposition as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pause<Impl: IMFMediaSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pause() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Stop<Impl: IMFMediaSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Close<Impl: IMFMediaSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Close() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Shutdown<Impl: IMFMediaSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Shutdown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetClock<Impl: IMFMediaSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppclock: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetClock(::core::mem::transmute_copy(&ppclock)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSessionCapabilities<Impl: IMFMediaSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwcaps: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSessionCapabilities(::core::mem::transmute_copy(&pdwcaps)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFullTopology<Impl: IMFMediaSessionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwgetfulltopologyflags: u32, topoid: u64, ppfulltopology: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFullTopology(dwgetfulltopologyflags, topoid, ::core::mem::transmute_copy(&ppfulltopology)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaSession>, base.5, SetTopology::<Impl, OFFSET>, ClearTopologies::<Impl, OFFSET>, Start::<Impl, OFFSET>, Pause::<Impl, OFFSET>, Stop::<Impl, OFFSET>, Close::<Impl, OFFSET>, Shutdown::<Impl, OFFSET>, GetClock::<Impl, OFFSET>, GetSessionCapabilities::<Impl, OFFSET>, GetFullTopology::<Impl, OFFSET>)
    }
}
pub trait IMFMediaSharingEngineImpl: Sized + IMFMediaEngineImpl {
    fn GetDevice();
}
impl ::windows::core::RuntimeName for IMFMediaSharingEngine {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaSharingEngine";
}
impl IMFMediaSharingEngineVtbl {
    pub const fn new<Impl: IMFMediaSharingEngineImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaSharingEngineVtbl {
        unsafe extern "system" fn GetDevice<Impl: IMFMediaSharingEngineImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdevice: *mut DEVICE_INFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDevice(::core::mem::transmute_copy(&pdevice)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaSharingEngine>, base.5, GetDevice::<Impl, OFFSET>)
    }
}
pub trait IMFMediaSharingEngineClassFactoryImpl: Sized {
    fn CreateInstance();
}
impl ::windows::core::RuntimeName for IMFMediaSharingEngineClassFactory {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaSharingEngineClassFactory";
}
impl IMFMediaSharingEngineClassFactoryVtbl {
    pub const fn new<Impl: IMFMediaSharingEngineClassFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaSharingEngineClassFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMFMediaSharingEngineClassFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32, pattr: ::windows::core::RawPtr, ppengine: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(dwflags, &*(&pattr as *const <IMFAttributes as ::windows::core::Abi>::Abi as *const <IMFAttributes as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppengine)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaSharingEngineClassFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
pub trait IMFMediaSinkImpl: Sized {
    fn GetCharacteristics();
    fn AddStreamSink();
    fn RemoveStreamSink();
    fn GetStreamSinkCount();
    fn GetStreamSinkByIndex();
    fn GetStreamSinkById();
    fn SetPresentationClock();
    fn GetPresentationClock();
    fn Shutdown();
}
impl ::windows::core::RuntimeName for IMFMediaSink {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaSink";
}
impl IMFMediaSinkVtbl {
    pub const fn new<Impl: IMFMediaSinkImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaSinkVtbl {
        unsafe extern "system" fn GetCharacteristics<Impl: IMFMediaSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwcharacteristics: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCharacteristics(::core::mem::transmute_copy(&pdwcharacteristics)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddStreamSink<Impl: IMFMediaSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamsinkidentifier: u32, pmediatype: ::windows::core::RawPtr, ppstreamsink: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddStreamSink(dwstreamsinkidentifier, &*(&pmediatype as *const <IMFMediaType as ::windows::core::Abi>::Abi as *const <IMFMediaType as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppstreamsink)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveStreamSink<Impl: IMFMediaSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamsinkidentifier: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveStreamSink(dwstreamsinkidentifier) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamSinkCount<Impl: IMFMediaSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcstreamsinkcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamSinkCount(::core::mem::transmute_copy(&pcstreamsinkcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamSinkByIndex<Impl: IMFMediaSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppstreamsink: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamSinkByIndex(dwindex, ::core::mem::transmute_copy(&ppstreamsink)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamSinkById<Impl: IMFMediaSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamsinkidentifier: u32, ppstreamsink: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamSinkById(dwstreamsinkidentifier, ::core::mem::transmute_copy(&ppstreamsink)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPresentationClock<Impl: IMFMediaSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppresentationclock: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPresentationClock(&*(&ppresentationclock as *const <IMFPresentationClock as ::windows::core::Abi>::Abi as *const <IMFPresentationClock as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPresentationClock<Impl: IMFMediaSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pppresentationclock: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPresentationClock(::core::mem::transmute_copy(&pppresentationclock)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Shutdown<Impl: IMFMediaSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Shutdown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaSink>, base.5, GetCharacteristics::<Impl, OFFSET>, AddStreamSink::<Impl, OFFSET>, RemoveStreamSink::<Impl, OFFSET>, GetStreamSinkCount::<Impl, OFFSET>, GetStreamSinkByIndex::<Impl, OFFSET>, GetStreamSinkById::<Impl, OFFSET>, SetPresentationClock::<Impl, OFFSET>, GetPresentationClock::<Impl, OFFSET>, Shutdown::<Impl, OFFSET>)
    }
}
pub trait IMFMediaSinkPrerollImpl: Sized {
    fn NotifyPreroll();
}
impl ::windows::core::RuntimeName for IMFMediaSinkPreroll {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaSinkPreroll";
}
impl IMFMediaSinkPrerollVtbl {
    pub const fn new<Impl: IMFMediaSinkPrerollImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaSinkPrerollVtbl {
        unsafe extern "system" fn NotifyPreroll<Impl: IMFMediaSinkPrerollImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnsupcomingstarttime: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NotifyPreroll(hnsupcomingstarttime) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaSinkPreroll>, base.5, NotifyPreroll::<Impl, OFFSET>)
    }
}
pub trait IMFMediaSourceImpl: Sized + IMFMediaEventGeneratorImpl {
    fn GetCharacteristics();
    fn CreatePresentationDescriptor();
    fn Start();
    fn Stop();
    fn Pause();
    fn Shutdown();
}
impl ::windows::core::RuntimeName for IMFMediaSource {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaSource";
}
impl IMFMediaSourceVtbl {
    pub const fn new<Impl: IMFMediaSourceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaSourceVtbl {
        unsafe extern "system" fn GetCharacteristics<Impl: IMFMediaSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwcharacteristics: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCharacteristics(::core::mem::transmute_copy(&pdwcharacteristics)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreatePresentationDescriptor<Impl: IMFMediaSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pppresentationdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreatePresentationDescriptor(::core::mem::transmute_copy(&pppresentationdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Start<Impl: IMFMediaSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppresentationdescriptor: ::windows::core::RawPtr, pguidtimeformat: *const ::windows::core::GUID, pvarstartposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Start(
                &*(&ppresentationdescriptor as *const <IMFPresentationDescriptor as ::windows::core::Abi>::Abi as *const <IMFPresentationDescriptor as ::windows::core::DefaultType>::DefaultType),
                &*(&pguidtimeformat as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&pvarstartposition as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Stop<Impl: IMFMediaSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pause<Impl: IMFMediaSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pause() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Shutdown<Impl: IMFMediaSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Shutdown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaSource>, base.5, GetCharacteristics::<Impl, OFFSET>, CreatePresentationDescriptor::<Impl, OFFSET>, Start::<Impl, OFFSET>, Stop::<Impl, OFFSET>, Pause::<Impl, OFFSET>, Shutdown::<Impl, OFFSET>)
    }
}
pub trait IMFMediaSource2Impl: Sized + IMFMediaSourceExImpl + IMFMediaSourceImpl + IMFMediaEventGeneratorImpl {
    fn SetMediaType();
}
impl ::windows::core::RuntimeName for IMFMediaSource2 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaSource2";
}
impl IMFMediaSource2Vtbl {
    pub const fn new<Impl: IMFMediaSource2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaSource2Vtbl {
        unsafe extern "system" fn SetMediaType<Impl: IMFMediaSource2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, pmediatype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMediaType(dwstreamid, &*(&pmediatype as *const <IMFMediaType as ::windows::core::Abi>::Abi as *const <IMFMediaType as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaSource2>, base.5, SetMediaType::<Impl, OFFSET>)
    }
}
pub trait IMFMediaSourceExImpl: Sized + IMFMediaSourceImpl + IMFMediaEventGeneratorImpl {
    fn GetSourceAttributes();
    fn GetStreamAttributes();
    fn SetD3DManager();
}
impl ::windows::core::RuntimeName for IMFMediaSourceEx {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaSourceEx";
}
impl IMFMediaSourceExVtbl {
    pub const fn new<Impl: IMFMediaSourceExImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaSourceExVtbl {
        unsafe extern "system" fn GetSourceAttributes<Impl: IMFMediaSourceExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppattributes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSourceAttributes(::core::mem::transmute_copy(&ppattributes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamAttributes<Impl: IMFMediaSourceExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamidentifier: u32, ppattributes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamAttributes(dwstreamidentifier, ::core::mem::transmute_copy(&ppattributes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetD3DManager<Impl: IMFMediaSourceExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmanager: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetD3DManager(&*(&pmanager as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaSourceEx>, base.5, GetSourceAttributes::<Impl, OFFSET>, GetStreamAttributes::<Impl, OFFSET>, SetD3DManager::<Impl, OFFSET>)
    }
}
pub trait IMFMediaSourceExtensionImpl: Sized {
    fn GetSourceBuffers();
    fn GetActiveSourceBuffers();
    fn GetReadyState();
    fn GetDuration();
    fn SetDuration();
    fn AddSourceBuffer();
    fn RemoveSourceBuffer();
    fn SetEndOfStream();
    fn IsTypeSupported();
    fn GetSourceBuffer();
}
impl ::windows::core::RuntimeName for IMFMediaSourceExtension {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaSourceExtension";
}
impl IMFMediaSourceExtensionVtbl {
    pub const fn new<Impl: IMFMediaSourceExtensionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaSourceExtensionVtbl {
        unsafe extern "system" fn GetSourceBuffers<Impl: IMFMediaSourceExtensionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::core::option::Option<IMFSourceBufferList> {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSourceBuffers() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetActiveSourceBuffers<Impl: IMFMediaSourceExtensionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::core::option::Option<IMFSourceBufferList> {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetActiveSourceBuffers() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetReadyState<Impl: IMFMediaSourceExtensionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> MF_MSE_READY {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetReadyState() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDuration<Impl: IMFMediaSourceExtensionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDuration() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDuration<Impl: IMFMediaSourceExtensionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, duration: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDuration(duration) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddSourceBuffer<Impl: IMFMediaSourceExtensionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, r#type: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pnotify: ::windows::core::RawPtr, ppsourcebuffer: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddSourceBuffer(&*(&r#type as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType), &*(&pnotify as *const <IMFSourceBufferNotify as ::windows::core::Abi>::Abi as *const <IMFSourceBufferNotify as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppsourcebuffer)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSourceBuffer<Impl: IMFMediaSourceExtensionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psourcebuffer: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveSourceBuffer(&*(&psourcebuffer as *const <IMFSourceBuffer as ::windows::core::Abi>::Abi as *const <IMFSourceBuffer as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetEndOfStream<Impl: IMFMediaSourceExtensionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, error: MF_MSE_ERROR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetEndOfStream(error) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTypeSupported<Impl: IMFMediaSourceExtensionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, r#type: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTypeSupported(&*(&r#type as *const <super::super::Foundation::BSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceBuffer<Impl: IMFMediaSourceExtensionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32) -> ::core::option::Option<IMFSourceBuffer> {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSourceBuffer(dwstreamindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaSourceExtension>, base.5, GetSourceBuffers::<Impl, OFFSET>, GetActiveSourceBuffers::<Impl, OFFSET>, GetReadyState::<Impl, OFFSET>, GetDuration::<Impl, OFFSET>, SetDuration::<Impl, OFFSET>, AddSourceBuffer::<Impl, OFFSET>, RemoveSourceBuffer::<Impl, OFFSET>, SetEndOfStream::<Impl, OFFSET>, IsTypeSupported::<Impl, OFFSET>, GetSourceBuffer::<Impl, OFFSET>)
    }
}
pub trait IMFMediaSourceExtensionLiveSeekableRangeImpl: Sized {
    fn SetLiveSeekableRange();
    fn ClearLiveSeekableRange();
}
impl ::windows::core::RuntimeName for IMFMediaSourceExtensionLiveSeekableRange {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaSourceExtensionLiveSeekableRange";
}
impl IMFMediaSourceExtensionLiveSeekableRangeVtbl {
    pub const fn new<Impl: IMFMediaSourceExtensionLiveSeekableRangeImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaSourceExtensionLiveSeekableRangeVtbl {
        unsafe extern "system" fn SetLiveSeekableRange<Impl: IMFMediaSourceExtensionLiveSeekableRangeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, start: f64, end: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLiveSeekableRange(start, end) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ClearLiveSeekableRange<Impl: IMFMediaSourceExtensionLiveSeekableRangeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ClearLiveSeekableRange() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaSourceExtensionLiveSeekableRange>, base.5, SetLiveSeekableRange::<Impl, OFFSET>, ClearLiveSeekableRange::<Impl, OFFSET>)
    }
}
pub trait IMFMediaSourceExtensionNotifyImpl: Sized {
    fn OnSourceOpen();
    fn OnSourceEnded();
    fn OnSourceClose();
}
impl ::windows::core::RuntimeName for IMFMediaSourceExtensionNotify {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaSourceExtensionNotify";
}
impl IMFMediaSourceExtensionNotifyVtbl {
    pub const fn new<Impl: IMFMediaSourceExtensionNotifyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaSourceExtensionNotifyVtbl {
        unsafe extern "system" fn OnSourceOpen<Impl: IMFMediaSourceExtensionNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnSourceOpen().into()
        }
        unsafe extern "system" fn OnSourceEnded<Impl: IMFMediaSourceExtensionNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnSourceEnded().into()
        }
        unsafe extern "system" fn OnSourceClose<Impl: IMFMediaSourceExtensionNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnSourceClose().into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaSourceExtensionNotify>, base.5, OnSourceOpen::<Impl, OFFSET>, OnSourceEnded::<Impl, OFFSET>, OnSourceClose::<Impl, OFFSET>)
    }
}
pub trait IMFMediaSourcePresentationProviderImpl: Sized {
    fn ForceEndOfPresentation();
}
impl ::windows::core::RuntimeName for IMFMediaSourcePresentationProvider {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaSourcePresentationProvider";
}
impl IMFMediaSourcePresentationProviderVtbl {
    pub const fn new<Impl: IMFMediaSourcePresentationProviderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaSourcePresentationProviderVtbl {
        unsafe extern "system" fn ForceEndOfPresentation<Impl: IMFMediaSourcePresentationProviderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppresentationdescriptor: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ForceEndOfPresentation(&*(&ppresentationdescriptor as *const <IMFPresentationDescriptor as ::windows::core::Abi>::Abi as *const <IMFPresentationDescriptor as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaSourcePresentationProvider>, base.5, ForceEndOfPresentation::<Impl, OFFSET>)
    }
}
pub trait IMFMediaSourceTopologyProviderImpl: Sized {
    fn GetMediaSourceTopology();
}
impl ::windows::core::RuntimeName for IMFMediaSourceTopologyProvider {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaSourceTopologyProvider";
}
impl IMFMediaSourceTopologyProviderVtbl {
    pub const fn new<Impl: IMFMediaSourceTopologyProviderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaSourceTopologyProviderVtbl {
        unsafe extern "system" fn GetMediaSourceTopology<Impl: IMFMediaSourceTopologyProviderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppresentationdescriptor: ::windows::core::RawPtr, pptopology: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMediaSourceTopology(&*(&ppresentationdescriptor as *const <IMFPresentationDescriptor as ::windows::core::Abi>::Abi as *const <IMFPresentationDescriptor as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pptopology)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaSourceTopologyProvider>, base.5, GetMediaSourceTopology::<Impl, OFFSET>)
    }
}
pub trait IMFMediaStreamImpl: Sized + IMFMediaEventGeneratorImpl {
    fn GetMediaSource();
    fn GetStreamDescriptor();
    fn RequestSample();
}
impl ::windows::core::RuntimeName for IMFMediaStream {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaStream";
}
impl IMFMediaStreamVtbl {
    pub const fn new<Impl: IMFMediaStreamImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaStreamVtbl {
        unsafe extern "system" fn GetMediaSource<Impl: IMFMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppmediasource: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMediaSource(::core::mem::transmute_copy(&ppmediasource)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamDescriptor<Impl: IMFMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppstreamdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamDescriptor(::core::mem::transmute_copy(&ppstreamdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RequestSample<Impl: IMFMediaStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptoken: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RequestSample(&*(&ptoken as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaStream>, base.5, GetMediaSource::<Impl, OFFSET>, GetStreamDescriptor::<Impl, OFFSET>, RequestSample::<Impl, OFFSET>)
    }
}
pub trait IMFMediaStream2Impl: Sized + IMFMediaStreamImpl + IMFMediaEventGeneratorImpl {
    fn SetStreamState();
    fn GetStreamState();
}
impl ::windows::core::RuntimeName for IMFMediaStream2 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaStream2";
}
impl IMFMediaStream2Vtbl {
    pub const fn new<Impl: IMFMediaStream2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaStream2Vtbl {
        unsafe extern "system" fn SetStreamState<Impl: IMFMediaStream2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: MF_STREAM_STATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStreamState(value) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamState<Impl: IMFMediaStream2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut MF_STREAM_STATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamState(::core::mem::transmute_copy(&value)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaStream2>, base.5, SetStreamState::<Impl, OFFSET>, GetStreamState::<Impl, OFFSET>)
    }
}
pub trait IMFMediaStreamSourceSampleRequestImpl: Sized {
    fn SetSample();
}
impl ::windows::core::RuntimeName for IMFMediaStreamSourceSampleRequest {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaStreamSourceSampleRequest";
}
impl IMFMediaStreamSourceSampleRequestVtbl {
    pub const fn new<Impl: IMFMediaStreamSourceSampleRequestImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaStreamSourceSampleRequestVtbl {
        unsafe extern "system" fn SetSample<Impl: IMFMediaStreamSourceSampleRequestImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSample(&*(&value as *const <IMFSample as ::windows::core::Abi>::Abi as *const <IMFSample as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaStreamSourceSampleRequest>, base.5, SetSample::<Impl, OFFSET>)
    }
}
pub trait IMFMediaTimeRangeImpl: Sized {
    fn GetLength();
    fn GetStart();
    fn GetEnd();
    fn ContainsTime();
    fn AddRange();
    fn Clear();
}
impl ::windows::core::RuntimeName for IMFMediaTimeRange {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaTimeRange";
}
impl IMFMediaTimeRangeVtbl {
    pub const fn new<Impl: IMFMediaTimeRangeImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaTimeRangeVtbl {
        unsafe extern "system" fn GetLength<Impl: IMFMediaTimeRangeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStart<Impl: IMFMediaTimeRangeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: u32, pstart: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStart(index, ::core::mem::transmute_copy(&pstart)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEnd<Impl: IMFMediaTimeRangeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: u32, pend: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEnd(index, ::core::mem::transmute_copy(&pend)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainsTime<Impl: IMFMediaTimeRangeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, time: f64) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ContainsTime(time) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddRange<Impl: IMFMediaTimeRangeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, starttime: f64, endtime: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddRange(starttime, endtime) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clear<Impl: IMFMediaTimeRangeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clear() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaTimeRange>, base.5, GetLength::<Impl, OFFSET>, GetStart::<Impl, OFFSET>, GetEnd::<Impl, OFFSET>, ContainsTime::<Impl, OFFSET>, AddRange::<Impl, OFFSET>, Clear::<Impl, OFFSET>)
    }
}
pub trait IMFMediaTypeImpl: Sized + IMFAttributesImpl {
    fn GetMajorType();
    fn IsCompressedFormat();
    fn IsEqual();
    fn GetRepresentation();
    fn FreeRepresentation();
}
impl ::windows::core::RuntimeName for IMFMediaType {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaType";
}
impl IMFMediaTypeVtbl {
    pub const fn new<Impl: IMFMediaTypeImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaTypeVtbl {
        unsafe extern "system" fn GetMajorType<Impl: IMFMediaTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguidmajortype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMajorType(::core::mem::transmute_copy(&pguidmajortype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCompressedFormat<Impl: IMFMediaTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfcompressed: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsCompressedFormat(::core::mem::transmute_copy(&pfcompressed)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsEqual<Impl: IMFMediaTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pimediatype: ::windows::core::RawPtr, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsEqual(&*(&pimediatype as *const <IMFMediaType as ::windows::core::Abi>::Abi as *const <IMFMediaType as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pdwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRepresentation<Impl: IMFMediaTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidrepresentation: ::windows::core::GUID, ppvrepresentation: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRepresentation(&*(&guidrepresentation as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppvrepresentation)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FreeRepresentation<Impl: IMFMediaTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidrepresentation: ::windows::core::GUID, pvrepresentation: *const ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FreeRepresentation(&*(&guidrepresentation as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&pvrepresentation as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaType>, base.5, GetMajorType::<Impl, OFFSET>, IsCompressedFormat::<Impl, OFFSET>, IsEqual::<Impl, OFFSET>, GetRepresentation::<Impl, OFFSET>, FreeRepresentation::<Impl, OFFSET>)
    }
}
pub trait IMFMediaTypeHandlerImpl: Sized {
    fn IsMediaTypeSupported();
    fn GetMediaTypeCount();
    fn GetMediaTypeByIndex();
    fn SetCurrentMediaType();
    fn GetCurrentMediaType();
    fn GetMajorType();
}
impl ::windows::core::RuntimeName for IMFMediaTypeHandler {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMediaTypeHandler";
}
impl IMFMediaTypeHandlerVtbl {
    pub const fn new<Impl: IMFMediaTypeHandlerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMediaTypeHandlerVtbl {
        unsafe extern "system" fn IsMediaTypeSupported<Impl: IMFMediaTypeHandlerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmediatype: ::windows::core::RawPtr, ppmediatype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsMediaTypeSupported(&*(&pmediatype as *const <IMFMediaType as ::windows::core::Abi>::Abi as *const <IMFMediaType as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppmediatype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaTypeCount<Impl: IMFMediaTypeHandlerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwtypecount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMediaTypeCount(::core::mem::transmute_copy(&pdwtypecount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaTypeByIndex<Impl: IMFMediaTypeHandlerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, pptype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMediaTypeByIndex(dwindex, ::core::mem::transmute_copy(&pptype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentMediaType<Impl: IMFMediaTypeHandlerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmediatype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCurrentMediaType(&*(&pmediatype as *const <IMFMediaType as ::windows::core::Abi>::Abi as *const <IMFMediaType as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentMediaType<Impl: IMFMediaTypeHandlerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppmediatype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentMediaType(::core::mem::transmute_copy(&ppmediatype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMajorType<Impl: IMFMediaTypeHandlerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguidmajortype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMajorType(::core::mem::transmute_copy(&pguidmajortype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMediaTypeHandler>, base.5, IsMediaTypeSupported::<Impl, OFFSET>, GetMediaTypeCount::<Impl, OFFSET>, GetMediaTypeByIndex::<Impl, OFFSET>, SetCurrentMediaType::<Impl, OFFSET>, GetCurrentMediaType::<Impl, OFFSET>, GetMajorType::<Impl, OFFSET>)
    }
}
pub trait IMFMetadataImpl: Sized {
    fn SetLanguage();
    fn GetLanguage();
    fn GetAllLanguages();
    fn SetProperty();
    fn GetProperty();
    fn DeleteProperty();
    fn GetAllPropertyNames();
}
impl ::windows::core::RuntimeName for IMFMetadata {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMetadata";
}
impl IMFMetadataVtbl {
    pub const fn new<Impl: IMFMetadataImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMetadataVtbl {
        unsafe extern "system" fn SetLanguage<Impl: IMFMetadataImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwszrfc1766: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLanguage(&*(&pwszrfc1766 as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLanguage<Impl: IMFMetadataImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppwszrfc1766: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLanguage(::core::mem::transmute_copy(&ppwszrfc1766)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAllLanguages<Impl: IMFMetadataImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppvlanguages: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAllLanguages(::core::mem::transmute_copy(&ppvlanguages)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProperty<Impl: IMFMetadataImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwszname: super::super::Foundation::PWSTR, ppvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetProperty(&*(&pwszname as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), &*(&ppvvalue as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProperty<Impl: IMFMetadataImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwszname: super::super::Foundation::PWSTR, ppvvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProperty(&*(&pwszname as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppvvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DeleteProperty<Impl: IMFMetadataImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwszname: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DeleteProperty(&*(&pwszname as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAllPropertyNames<Impl: IMFMetadataImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppvnames: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAllPropertyNames(::core::mem::transmute_copy(&ppvnames)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMetadata>, base.5, SetLanguage::<Impl, OFFSET>, GetLanguage::<Impl, OFFSET>, GetAllLanguages::<Impl, OFFSET>, SetProperty::<Impl, OFFSET>, GetProperty::<Impl, OFFSET>, DeleteProperty::<Impl, OFFSET>, GetAllPropertyNames::<Impl, OFFSET>)
    }
}
pub trait IMFMetadataProviderImpl: Sized {
    fn GetMFMetadata();
}
impl ::windows::core::RuntimeName for IMFMetadataProvider {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMetadataProvider";
}
impl IMFMetadataProviderVtbl {
    pub const fn new<Impl: IMFMetadataProviderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMetadataProviderVtbl {
        unsafe extern "system" fn GetMFMetadata<Impl: IMFMetadataProviderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppresentationdescriptor: ::windows::core::RawPtr, dwstreamidentifier: u32, dwflags: u32, ppmfmetadata: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMFMetadata(&*(&ppresentationdescriptor as *const <IMFPresentationDescriptor as ::windows::core::Abi>::Abi as *const <IMFPresentationDescriptor as ::windows::core::DefaultType>::DefaultType), dwstreamidentifier, dwflags, ::core::mem::transmute_copy(&ppmfmetadata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMetadataProvider>, base.5, GetMFMetadata::<Impl, OFFSET>)
    }
}
pub trait IMFMuxStreamAttributesManagerImpl: Sized {
    fn GetStreamCount();
    fn GetAttributes();
}
impl ::windows::core::RuntimeName for IMFMuxStreamAttributesManager {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMuxStreamAttributesManager";
}
impl IMFMuxStreamAttributesManagerVtbl {
    pub const fn new<Impl: IMFMuxStreamAttributesManagerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMuxStreamAttributesManagerVtbl {
        unsafe extern "system" fn GetStreamCount<Impl: IMFMuxStreamAttributesManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwmuxstreamcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamCount(::core::mem::transmute_copy(&pdwmuxstreamcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAttributes<Impl: IMFMuxStreamAttributesManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwmuxstreamindex: u32, ppstreamattributes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAttributes(dwmuxstreamindex, ::core::mem::transmute_copy(&ppstreamattributes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMuxStreamAttributesManager>, base.5, GetStreamCount::<Impl, OFFSET>, GetAttributes::<Impl, OFFSET>)
    }
}
pub trait IMFMuxStreamMediaTypeManagerImpl: Sized {
    fn GetStreamCount();
    fn GetMediaType();
    fn GetStreamConfigurationCount();
    fn AddStreamConfiguration();
    fn RemoveStreamConfiguration();
    fn GetStreamConfiguration();
}
impl ::windows::core::RuntimeName for IMFMuxStreamMediaTypeManager {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMuxStreamMediaTypeManager";
}
impl IMFMuxStreamMediaTypeManagerVtbl {
    pub const fn new<Impl: IMFMuxStreamMediaTypeManagerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMuxStreamMediaTypeManagerVtbl {
        unsafe extern "system" fn GetStreamCount<Impl: IMFMuxStreamMediaTypeManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwmuxstreamcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamCount(::core::mem::transmute_copy(&pdwmuxstreamcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaType<Impl: IMFMuxStreamMediaTypeManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwmuxstreamindex: u32, ppmediatype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMediaType(dwmuxstreamindex, ::core::mem::transmute_copy(&ppmediatype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamConfigurationCount<Impl: IMFMuxStreamMediaTypeManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamConfigurationCount(::core::mem::transmute_copy(&pdwcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddStreamConfiguration<Impl: IMFMuxStreamMediaTypeManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ullstreammask: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddStreamConfiguration(ullstreammask) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveStreamConfiguration<Impl: IMFMuxStreamMediaTypeManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ullstreammask: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveStreamConfiguration(ullstreammask) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamConfiguration<Impl: IMFMuxStreamMediaTypeManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulindex: u32, pullstreammask: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamConfiguration(ulindex, ::core::mem::transmute_copy(&pullstreammask)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMuxStreamMediaTypeManager>, base.5, GetStreamCount::<Impl, OFFSET>, GetMediaType::<Impl, OFFSET>, GetStreamConfigurationCount::<Impl, OFFSET>, AddStreamConfiguration::<Impl, OFFSET>, RemoveStreamConfiguration::<Impl, OFFSET>, GetStreamConfiguration::<Impl, OFFSET>)
    }
}
pub trait IMFMuxStreamSampleManagerImpl: Sized {
    fn GetStreamCount();
    fn GetSample();
    fn GetStreamConfiguration();
}
impl ::windows::core::RuntimeName for IMFMuxStreamSampleManager {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFMuxStreamSampleManager";
}
impl IMFMuxStreamSampleManagerVtbl {
    pub const fn new<Impl: IMFMuxStreamSampleManagerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFMuxStreamSampleManagerVtbl {
        unsafe extern "system" fn GetStreamCount<Impl: IMFMuxStreamSampleManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwmuxstreamcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamCount(::core::mem::transmute_copy(&pdwmuxstreamcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSample<Impl: IMFMuxStreamSampleManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwmuxstreamindex: u32, ppsample: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSample(dwmuxstreamindex, ::core::mem::transmute_copy(&ppsample)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamConfiguration<Impl: IMFMuxStreamSampleManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u64 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamConfiguration() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFMuxStreamSampleManager>, base.5, GetStreamCount::<Impl, OFFSET>, GetSample::<Impl, OFFSET>, GetStreamConfiguration::<Impl, OFFSET>)
    }
}
pub trait IMFNetCredentialImpl: Sized {
    fn SetUser();
    fn SetPassword();
    fn GetUser();
    fn GetPassword();
    fn LoggedOnUser();
}
impl ::windows::core::RuntimeName for IMFNetCredential {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFNetCredential";
}
impl IMFNetCredentialVtbl {
    pub const fn new<Impl: IMFNetCredentialImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFNetCredentialVtbl {
        unsafe extern "system" fn SetUser<Impl: IMFNetCredentialImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbdata: *const u8, cbdata: u32, fdataisencrypted: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetUser(pbdata, cbdata, &*(&fdataisencrypted as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPassword<Impl: IMFNetCredentialImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbdata: *const u8, cbdata: u32, fdataisencrypted: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPassword(pbdata, cbdata, &*(&fdataisencrypted as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetUser<Impl: IMFNetCredentialImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbdata: *mut u8, pcbdata: *mut u32, fencryptdata: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetUser(::core::mem::transmute_copy(&pbdata), pcbdata, &*(&fencryptdata as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPassword<Impl: IMFNetCredentialImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbdata: *mut u8, pcbdata: *mut u32, fencryptdata: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPassword(::core::mem::transmute_copy(&pbdata), pcbdata, &*(&fencryptdata as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LoggedOnUser<Impl: IMFNetCredentialImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfloggedonuser: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LoggedOnUser(::core::mem::transmute_copy(&pfloggedonuser)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFNetCredential>, base.5, SetUser::<Impl, OFFSET>, SetPassword::<Impl, OFFSET>, GetUser::<Impl, OFFSET>, GetPassword::<Impl, OFFSET>, LoggedOnUser::<Impl, OFFSET>)
    }
}
pub trait IMFNetCredentialCacheImpl: Sized {
    fn GetCredential();
    fn SetGood();
    fn SetUserOptions();
}
impl ::windows::core::RuntimeName for IMFNetCredentialCache {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFNetCredentialCache";
}
impl IMFNetCredentialCacheVtbl {
    pub const fn new<Impl: IMFNetCredentialCacheImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFNetCredentialCacheVtbl {
        unsafe extern "system" fn GetCredential<Impl: IMFNetCredentialCacheImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszurl: super::super::Foundation::PWSTR, pszrealm: super::super::Foundation::PWSTR, dwauthenticationflags: u32, ppcred: *mut ::windows::core::RawPtr, pdwrequirementsflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCredential(&*(&pszurl as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), &*(&pszrealm as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), dwauthenticationflags, ::core::mem::transmute_copy(&ppcred), ::core::mem::transmute_copy(&pdwrequirementsflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGood<Impl: IMFNetCredentialCacheImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcred: ::windows::core::RawPtr, fgood: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetGood(&*(&pcred as *const <IMFNetCredential as ::windows::core::Abi>::Abi as *const <IMFNetCredential as ::windows::core::DefaultType>::DefaultType), &*(&fgood as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUserOptions<Impl: IMFNetCredentialCacheImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcred: ::windows::core::RawPtr, dwoptionsflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetUserOptions(&*(&pcred as *const <IMFNetCredential as ::windows::core::Abi>::Abi as *const <IMFNetCredential as ::windows::core::DefaultType>::DefaultType), dwoptionsflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFNetCredentialCache>, base.5, GetCredential::<Impl, OFFSET>, SetGood::<Impl, OFFSET>, SetUserOptions::<Impl, OFFSET>)
    }
}
pub trait IMFNetCredentialManagerImpl: Sized {
    fn BeginGetCredentials();
    fn EndGetCredentials();
    fn SetGood();
}
impl ::windows::core::RuntimeName for IMFNetCredentialManager {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFNetCredentialManager";
}
impl IMFNetCredentialManagerVtbl {
    pub const fn new<Impl: IMFNetCredentialManagerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFNetCredentialManagerVtbl {
        unsafe extern "system" fn BeginGetCredentials<Impl: IMFNetCredentialManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pparam: *const MFNetCredentialManagerGetParam, pcallback: ::windows::core::RawPtr, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginGetCredentials(
                &*(&pparam as *const <MFNetCredentialManagerGetParam as ::windows::core::Abi>::Abi as *const <MFNetCredentialManagerGetParam as ::windows::core::DefaultType>::DefaultType),
                &*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType),
                &*(&pstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndGetCredentials<Impl: IMFNetCredentialManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, ppcred: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndGetCredentials(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppcred)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGood<Impl: IMFNetCredentialManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcred: ::windows::core::RawPtr, fgood: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetGood(&*(&pcred as *const <IMFNetCredential as ::windows::core::Abi>::Abi as *const <IMFNetCredential as ::windows::core::DefaultType>::DefaultType), &*(&fgood as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFNetCredentialManager>, base.5, BeginGetCredentials::<Impl, OFFSET>, EndGetCredentials::<Impl, OFFSET>, SetGood::<Impl, OFFSET>)
    }
}
pub trait IMFNetCrossOriginSupportImpl: Sized {
    fn GetCrossOriginPolicy();
    fn GetSourceOrigin();
    fn IsSameOrigin();
}
impl ::windows::core::RuntimeName for IMFNetCrossOriginSupport {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFNetCrossOriginSupport";
}
impl IMFNetCrossOriginSupportVtbl {
    pub const fn new<Impl: IMFNetCrossOriginSupportImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFNetCrossOriginSupportVtbl {
        unsafe extern "system" fn GetCrossOriginPolicy<Impl: IMFNetCrossOriginSupportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppolicy: *mut MF_CROSS_ORIGIN_POLICY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCrossOriginPolicy(::core::mem::transmute_copy(&ppolicy)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceOrigin<Impl: IMFNetCrossOriginSupportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wszsourceorigin: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSourceOrigin(::core::mem::transmute_copy(&wszsourceorigin)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSameOrigin<Impl: IMFNetCrossOriginSupportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wszurl: super::super::Foundation::PWSTR, pfissameorigin: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsSameOrigin(&*(&wszurl as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pfissameorigin)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFNetCrossOriginSupport>, base.5, GetCrossOriginPolicy::<Impl, OFFSET>, GetSourceOrigin::<Impl, OFFSET>, IsSameOrigin::<Impl, OFFSET>)
    }
}
pub trait IMFNetProxyLocatorImpl: Sized {
    fn FindFirstProxy();
    fn FindNextProxy();
    fn RegisterProxyResult();
    fn GetCurrentProxy();
    fn Clone();
}
impl ::windows::core::RuntimeName for IMFNetProxyLocator {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFNetProxyLocator";
}
impl IMFNetProxyLocatorVtbl {
    pub const fn new<Impl: IMFNetProxyLocatorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFNetProxyLocatorVtbl {
        unsafe extern "system" fn FindFirstProxy<Impl: IMFNetProxyLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszhost: super::super::Foundation::PWSTR, pszurl: super::super::Foundation::PWSTR, freserved: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FindFirstProxy(
                &*(&pszhost as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&pszurl as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&freserved as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FindNextProxy<Impl: IMFNetProxyLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FindNextProxy() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RegisterProxyResult<Impl: IMFNetProxyLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hrop: ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterProxyResult(hrop) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentProxy<Impl: IMFNetProxyLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszstr: super::super::Foundation::PWSTR, pcchstr: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentProxy(::core::mem::transmute_copy(&pszstr), pcchstr) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IMFNetProxyLocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppproxylocator: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&ppproxylocator)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFNetProxyLocator>, base.5, FindFirstProxy::<Impl, OFFSET>, FindNextProxy::<Impl, OFFSET>, RegisterProxyResult::<Impl, OFFSET>, GetCurrentProxy::<Impl, OFFSET>, Clone::<Impl, OFFSET>)
    }
}
pub trait IMFNetProxyLocatorFactoryImpl: Sized {
    fn CreateProxyLocator();
}
impl ::windows::core::RuntimeName for IMFNetProxyLocatorFactory {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFNetProxyLocatorFactory";
}
impl IMFNetProxyLocatorFactoryVtbl {
    pub const fn new<Impl: IMFNetProxyLocatorFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFNetProxyLocatorFactoryVtbl {
        unsafe extern "system" fn CreateProxyLocator<Impl: IMFNetProxyLocatorFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszprotocol: super::super::Foundation::PWSTR, ppproxylocator: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateProxyLocator(&*(&pszprotocol as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppproxylocator)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFNetProxyLocatorFactory>, base.5, CreateProxyLocator::<Impl, OFFSET>)
    }
}
pub trait IMFNetResourceFilterImpl: Sized {
    fn OnRedirect();
    fn OnSendingRequest();
}
impl ::windows::core::RuntimeName for IMFNetResourceFilter {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFNetResourceFilter";
}
impl IMFNetResourceFilterVtbl {
    pub const fn new<Impl: IMFNetResourceFilterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFNetResourceFilterVtbl {
        unsafe extern "system" fn OnRedirect<Impl: IMFNetResourceFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszurl: super::super::Foundation::PWSTR, pvbcancel: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnRedirect(&*(&pszurl as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pvbcancel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnSendingRequest<Impl: IMFNetResourceFilterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszurl: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnSendingRequest(&*(&pszurl as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFNetResourceFilter>, base.5, OnRedirect::<Impl, OFFSET>, OnSendingRequest::<Impl, OFFSET>)
    }
}
pub trait IMFNetSchemeHandlerConfigImpl: Sized {
    fn GetNumberOfSupportedProtocols();
    fn GetSupportedProtocolType();
    fn ResetProtocolRolloverSettings();
}
impl ::windows::core::RuntimeName for IMFNetSchemeHandlerConfig {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFNetSchemeHandlerConfig";
}
impl IMFNetSchemeHandlerConfigVtbl {
    pub const fn new<Impl: IMFNetSchemeHandlerConfigImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFNetSchemeHandlerConfigVtbl {
        unsafe extern "system" fn GetNumberOfSupportedProtocols<Impl: IMFNetSchemeHandlerConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcprotocols: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNumberOfSupportedProtocols(::core::mem::transmute_copy(&pcprotocols)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSupportedProtocolType<Impl: IMFNetSchemeHandlerConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, nprotocolindex: u32, pnprotocoltype: *mut MFNETSOURCE_PROTOCOL_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSupportedProtocolType(nprotocolindex, ::core::mem::transmute_copy(&pnprotocoltype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ResetProtocolRolloverSettings<Impl: IMFNetSchemeHandlerConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ResetProtocolRolloverSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFNetSchemeHandlerConfig>, base.5, GetNumberOfSupportedProtocols::<Impl, OFFSET>, GetSupportedProtocolType::<Impl, OFFSET>, ResetProtocolRolloverSettings::<Impl, OFFSET>)
    }
}
pub trait IMFObjectReferenceStreamImpl: Sized {
    fn SaveReference();
    fn LoadReference();
}
impl ::windows::core::RuntimeName for IMFObjectReferenceStream {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFObjectReferenceStream";
}
impl IMFObjectReferenceStreamVtbl {
    pub const fn new<Impl: IMFObjectReferenceStreamImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFObjectReferenceStreamVtbl {
        unsafe extern "system" fn SaveReference<Impl: IMFObjectReferenceStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, punk: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SaveReference(&*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&punk as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn LoadReference<Impl: IMFObjectReferenceStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LoadReference(&*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppv)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFObjectReferenceStream>, base.5, SaveReference::<Impl, OFFSET>, LoadReference::<Impl, OFFSET>)
    }
}
pub trait IMFOutputPolicyImpl: Sized + IMFAttributesImpl {
    fn GenerateRequiredSchemas();
    fn GetOriginatorID();
    fn GetMinimumGRLVersion();
}
impl ::windows::core::RuntimeName for IMFOutputPolicy {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFOutputPolicy";
}
impl IMFOutputPolicyVtbl {
    pub const fn new<Impl: IMFOutputPolicyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFOutputPolicyVtbl {
        unsafe extern "system" fn GenerateRequiredSchemas<Impl: IMFOutputPolicyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwattributes: u32, guidoutputsubtype: ::windows::core::GUID, rgguidprotectionschemassupported: *const ::windows::core::GUID, cprotectionschemassupported: u32, pprequiredprotectionschemas: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GenerateRequiredSchemas(dwattributes, &*(&guidoutputsubtype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&rgguidprotectionschemassupported as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), cprotectionschemassupported, ::core::mem::transmute_copy(&pprequiredprotectionschemas)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginatorID<Impl: IMFOutputPolicyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguidoriginatorid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOriginatorID(::core::mem::transmute_copy(&pguidoriginatorid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMinimumGRLVersion<Impl: IMFOutputPolicyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwminimumgrlversion: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMinimumGRLVersion(::core::mem::transmute_copy(&pdwminimumgrlversion)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFOutputPolicy>, base.5, GenerateRequiredSchemas::<Impl, OFFSET>, GetOriginatorID::<Impl, OFFSET>, GetMinimumGRLVersion::<Impl, OFFSET>)
    }
}
pub trait IMFOutputSchemaImpl: Sized + IMFAttributesImpl {
    fn GetSchemaType();
    fn GetConfigurationData();
    fn GetOriginatorID();
}
impl ::windows::core::RuntimeName for IMFOutputSchema {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFOutputSchema";
}
impl IMFOutputSchemaVtbl {
    pub const fn new<Impl: IMFOutputSchemaImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFOutputSchemaVtbl {
        unsafe extern "system" fn GetSchemaType<Impl: IMFOutputSchemaImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguidschematype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSchemaType(::core::mem::transmute_copy(&pguidschematype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetConfigurationData<Impl: IMFOutputSchemaImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetConfigurationData(::core::mem::transmute_copy(&pdwval)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginatorID<Impl: IMFOutputSchemaImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguidoriginatorid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOriginatorID(::core::mem::transmute_copy(&pguidoriginatorid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFOutputSchema>, base.5, GetSchemaType::<Impl, OFFSET>, GetConfigurationData::<Impl, OFFSET>, GetOriginatorID::<Impl, OFFSET>)
    }
}
pub trait IMFOutputTrustAuthorityImpl: Sized {
    fn GetAction();
    fn SetPolicy();
}
impl ::windows::core::RuntimeName for IMFOutputTrustAuthority {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFOutputTrustAuthority";
}
impl IMFOutputTrustAuthorityVtbl {
    pub const fn new<Impl: IMFOutputTrustAuthorityImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFOutputTrustAuthorityVtbl {
        unsafe extern "system" fn GetAction<Impl: IMFOutputTrustAuthorityImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, paction: *mut MFPOLICYMANAGER_ACTION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAction(::core::mem::transmute_copy(&paction)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPolicy<Impl: IMFOutputTrustAuthorityImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pppolicy: *const ::windows::core::RawPtr, npolicy: u32, ppbticket: *mut *mut u8, pcbticket: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPolicy(&*(&pppolicy as *const <IMFOutputPolicy as ::windows::core::Abi>::Abi as *const <IMFOutputPolicy as ::windows::core::DefaultType>::DefaultType), npolicy, ::core::mem::transmute_copy(&ppbticket), ::core::mem::transmute_copy(&pcbticket)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFOutputTrustAuthority>, base.5, GetAction::<Impl, OFFSET>, SetPolicy::<Impl, OFFSET>)
    }
}
pub trait IMFPMPClientImpl: Sized {
    fn SetPMPHost();
}
impl ::windows::core::RuntimeName for IMFPMPClient {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFPMPClient";
}
impl IMFPMPClientVtbl {
    pub const fn new<Impl: IMFPMPClientImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFPMPClientVtbl {
        unsafe extern "system" fn SetPMPHost<Impl: IMFPMPClientImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppmphost: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPMPHost(&*(&ppmphost as *const <IMFPMPHost as ::windows::core::Abi>::Abi as *const <IMFPMPHost as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFPMPClient>, base.5, SetPMPHost::<Impl, OFFSET>)
    }
}
pub trait IMFPMPClientAppImpl: Sized {
    fn SetPMPHost();
}
impl ::windows::core::RuntimeName for IMFPMPClientApp {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFPMPClientApp";
}
impl IMFPMPClientAppVtbl {
    pub const fn new<Impl: IMFPMPClientAppImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFPMPClientAppVtbl {
        unsafe extern "system" fn SetPMPHost<Impl: IMFPMPClientAppImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppmphost: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPMPHost(&*(&ppmphost as *const <IMFPMPHostApp as ::windows::core::Abi>::Abi as *const <IMFPMPHostApp as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFPMPClientApp>, base.5, SetPMPHost::<Impl, OFFSET>)
    }
}
pub trait IMFPMPHostImpl: Sized {
    fn LockProcess();
    fn UnlockProcess();
    fn CreateObjectByCLSID();
}
impl ::windows::core::RuntimeName for IMFPMPHost {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFPMPHost";
}
impl IMFPMPHostVtbl {
    pub const fn new<Impl: IMFPMPHostImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFPMPHostVtbl {
        unsafe extern "system" fn LockProcess<Impl: IMFPMPHostImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LockProcess() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnlockProcess<Impl: IMFPMPHostImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnlockProcess() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateObjectByCLSID<Impl: IMFPMPHostImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clsid: *const ::windows::core::GUID, pstream: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateObjectByCLSID(
                &*(&clsid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&pstream as *const <super::super::System::Com::IStream as ::windows::core::Abi>::Abi as *const <super::super::System::Com::IStream as ::windows::core::DefaultType>::DefaultType),
                &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&ppv),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFPMPHost>, base.5, LockProcess::<Impl, OFFSET>, UnlockProcess::<Impl, OFFSET>, CreateObjectByCLSID::<Impl, OFFSET>)
    }
}
pub trait IMFPMPHostAppImpl: Sized {
    fn LockProcess();
    fn UnlockProcess();
    fn ActivateClassById();
}
impl ::windows::core::RuntimeName for IMFPMPHostApp {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFPMPHostApp";
}
impl IMFPMPHostAppVtbl {
    pub const fn new<Impl: IMFPMPHostAppImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFPMPHostAppVtbl {
        unsafe extern "system" fn LockProcess<Impl: IMFPMPHostAppImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LockProcess() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnlockProcess<Impl: IMFPMPHostAppImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnlockProcess() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ActivateClassById<Impl: IMFPMPHostAppImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, id: super::super::Foundation::PWSTR, pstream: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ActivateClassById(
                &*(&id as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&pstream as *const <super::super::System::Com::IStream as ::windows::core::Abi>::Abi as *const <super::super::System::Com::IStream as ::windows::core::DefaultType>::DefaultType),
                &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&ppv),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFPMPHostApp>, base.5, LockProcess::<Impl, OFFSET>, UnlockProcess::<Impl, OFFSET>, ActivateClassById::<Impl, OFFSET>)
    }
}
pub trait IMFPMPServerImpl: Sized {
    fn LockProcess();
    fn UnlockProcess();
    fn CreateObjectByCLSID();
}
impl ::windows::core::RuntimeName for IMFPMPServer {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFPMPServer";
}
impl IMFPMPServerVtbl {
    pub const fn new<Impl: IMFPMPServerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFPMPServerVtbl {
        unsafe extern "system" fn LockProcess<Impl: IMFPMPServerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LockProcess() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnlockProcess<Impl: IMFPMPServerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnlockProcess() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateObjectByCLSID<Impl: IMFPMPServerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clsid: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateObjectByCLSID(&*(&clsid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppobject)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFPMPServer>, base.5, LockProcess::<Impl, OFFSET>, UnlockProcess::<Impl, OFFSET>, CreateObjectByCLSID::<Impl, OFFSET>)
    }
}
pub trait IMFPMediaItemImpl: Sized {
    fn GetMediaPlayer();
    fn GetURL();
    fn GetObject();
    fn GetUserData();
    fn SetUserData();
    fn GetStartStopPosition();
    fn SetStartStopPosition();
    fn HasVideo();
    fn HasAudio();
    fn IsProtected();
    fn GetDuration();
    fn GetNumberOfStreams();
    fn GetStreamSelection();
    fn SetStreamSelection();
    fn GetStreamAttribute();
    fn GetPresentationAttribute();
    fn GetCharacteristics();
    fn SetStreamSink();
    fn GetMetadata();
}
impl ::windows::core::RuntimeName for IMFPMediaItem {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFPMediaItem";
}
impl IMFPMediaItemVtbl {
    pub const fn new<Impl: IMFPMediaItemImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFPMediaItemVtbl {
        unsafe extern "system" fn GetMediaPlayer<Impl: IMFPMediaItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppmediaplayer: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMediaPlayer(::core::mem::transmute_copy(&ppmediaplayer)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetURL<Impl: IMFPMediaItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppwszurl: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetURL(::core::mem::transmute_copy(&ppwszurl)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetObject<Impl: IMFPMediaItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppiunknown: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetObject(::core::mem::transmute_copy(&ppiunknown)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetUserData<Impl: IMFPMediaItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwuserdata: *mut usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetUserData(::core::mem::transmute_copy(&pdwuserdata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUserData<Impl: IMFPMediaItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwuserdata: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetUserData(dwuserdata) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStartStopPosition<Impl: IMFPMediaItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguidstartpositiontype: *mut ::windows::core::GUID, pvstartvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT, pguidstoppositiontype: *mut ::windows::core::GUID, pvstopvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStartStopPosition(::core::mem::transmute_copy(&pguidstartpositiontype), ::core::mem::transmute_copy(&pvstartvalue), ::core::mem::transmute_copy(&pguidstoppositiontype), ::core::mem::transmute_copy(&pvstopvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStartStopPosition<Impl: IMFPMediaItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguidstartpositiontype: *const ::windows::core::GUID, pvstartvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pguidstoppositiontype: *const ::windows::core::GUID, pvstopvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStartStopPosition(
                &*(&pguidstartpositiontype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&pvstartvalue as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::DefaultType>::DefaultType),
                &*(&pguidstoppositiontype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&pvstopvalue as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HasVideo<Impl: IMFPMediaItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfhasvideo: *mut super::super::Foundation::BOOL, pfselected: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HasVideo(::core::mem::transmute_copy(&pfhasvideo), ::core::mem::transmute_copy(&pfselected)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HasAudio<Impl: IMFPMediaItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfhasaudio: *mut super::super::Foundation::BOOL, pfselected: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).HasAudio(::core::mem::transmute_copy(&pfhasaudio), ::core::mem::transmute_copy(&pfselected)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsProtected<Impl: IMFPMediaItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfprotected: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsProtected(::core::mem::transmute_copy(&pfprotected)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDuration<Impl: IMFPMediaItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidpositiontype: *const ::windows::core::GUID, pvdurationvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDuration(&*(&guidpositiontype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pvdurationvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNumberOfStreams<Impl: IMFPMediaItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwstreamcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNumberOfStreams(::core::mem::transmute_copy(&pdwstreamcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamSelection<Impl: IMFPMediaItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pfenabled: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamSelection(dwstreamindex, ::core::mem::transmute_copy(&pfenabled)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamSelection<Impl: IMFPMediaItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, fenabled: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStreamSelection(dwstreamindex, &*(&fenabled as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamAttribute<Impl: IMFPMediaItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, guidmfattribute: *const ::windows::core::GUID, pvvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamAttribute(dwstreamindex, &*(&guidmfattribute as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pvvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPresentationAttribute<Impl: IMFPMediaItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidmfattribute: *const ::windows::core::GUID, pvvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPresentationAttribute(&*(&guidmfattribute as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pvvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCharacteristics<Impl: IMFPMediaItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcharacteristics: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCharacteristics(::core::mem::transmute_copy(&pcharacteristics)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamSink<Impl: IMFPMediaItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pmediasink: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStreamSink(dwstreamindex, &*(&pmediasink as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMetadata<Impl: IMFPMediaItemImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppmetadatastore: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMetadata(::core::mem::transmute_copy(&ppmetadatastore)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMFPMediaItem>,
            base.5,
            GetMediaPlayer::<Impl, OFFSET>,
            GetURL::<Impl, OFFSET>,
            GetObject::<Impl, OFFSET>,
            GetUserData::<Impl, OFFSET>,
            SetUserData::<Impl, OFFSET>,
            GetStartStopPosition::<Impl, OFFSET>,
            SetStartStopPosition::<Impl, OFFSET>,
            HasVideo::<Impl, OFFSET>,
            HasAudio::<Impl, OFFSET>,
            IsProtected::<Impl, OFFSET>,
            GetDuration::<Impl, OFFSET>,
            GetNumberOfStreams::<Impl, OFFSET>,
            GetStreamSelection::<Impl, OFFSET>,
            SetStreamSelection::<Impl, OFFSET>,
            GetStreamAttribute::<Impl, OFFSET>,
            GetPresentationAttribute::<Impl, OFFSET>,
            GetCharacteristics::<Impl, OFFSET>,
            SetStreamSink::<Impl, OFFSET>,
            GetMetadata::<Impl, OFFSET>,
        )
    }
}
pub trait IMFPMediaPlayerImpl: Sized {
    fn Play();
    fn Pause();
    fn Stop();
    fn FrameStep();
    fn SetPosition();
    fn GetPosition();
    fn GetDuration();
    fn SetRate();
    fn GetRate();
    fn GetSupportedRates();
    fn GetState();
    fn CreateMediaItemFromURL();
    fn CreateMediaItemFromObject();
    fn SetMediaItem();
    fn ClearMediaItem();
    fn GetMediaItem();
    fn GetVolume();
    fn SetVolume();
    fn GetBalance();
    fn SetBalance();
    fn GetMute();
    fn SetMute();
    fn GetNativeVideoSize();
    fn GetIdealVideoSize();
    fn SetVideoSourceRect();
    fn GetVideoSourceRect();
    fn SetAspectRatioMode();
    fn GetAspectRatioMode();
    fn GetVideoWindow();
    fn UpdateVideo();
    fn SetBorderColor();
    fn GetBorderColor();
    fn InsertEffect();
    fn RemoveEffect();
    fn RemoveAllEffects();
    fn Shutdown();
}
impl ::windows::core::RuntimeName for IMFPMediaPlayer {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFPMediaPlayer";
}
impl IMFPMediaPlayerVtbl {
    pub const fn new<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFPMediaPlayerVtbl {
        unsafe extern "system" fn Play<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Play() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pause<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pause() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Stop<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FrameStep<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FrameStep() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPosition<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidpositiontype: *const ::windows::core::GUID, pvpositionvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPosition(&*(&guidpositiontype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&pvpositionvalue as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPosition<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidpositiontype: *const ::windows::core::GUID, pvpositionvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPosition(&*(&guidpositiontype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pvpositionvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDuration<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidpositiontype: *const ::windows::core::GUID, pvdurationvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDuration(&*(&guidpositiontype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pvdurationvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRate<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, flrate: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRate(flrate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRate<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pflrate: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRate(::core::mem::transmute_copy(&pflrate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSupportedRates<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fforwarddirection: super::super::Foundation::BOOL, pflslowestrate: *mut f32, pflfastestrate: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSupportedRates(&*(&fforwarddirection as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pflslowestrate), ::core::mem::transmute_copy(&pflfastestrate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetState<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pestate: *mut MFP_MEDIAPLAYER_STATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetState(::core::mem::transmute_copy(&pestate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateMediaItemFromURL<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwszurl: super::super::Foundation::PWSTR, fsync: super::super::Foundation::BOOL, dwuserdata: usize, ppmediaitem: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateMediaItemFromURL(&*(&pwszurl as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), &*(&fsync as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType), dwuserdata, ::core::mem::transmute_copy(&ppmediaitem)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateMediaItemFromObject<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, piunknownobj: *mut ::core::ffi::c_void, fsync: super::super::Foundation::BOOL, dwuserdata: usize, ppmediaitem: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateMediaItemFromObject(&*(&piunknownobj as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType), &*(&fsync as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType), dwuserdata, ::core::mem::transmute_copy(&ppmediaitem)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaItem<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pimfpmediaitem: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMediaItem(&*(&pimfpmediaitem as *const <IMFPMediaItem as ::windows::core::Abi>::Abi as *const <IMFPMediaItem as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ClearMediaItem<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ClearMediaItem() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaItem<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppimfpmediaitem: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMediaItem(::core::mem::transmute_copy(&ppimfpmediaitem)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVolume<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pflvolume: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVolume(::core::mem::transmute_copy(&pflvolume)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVolume<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, flvolume: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVolume(flvolume) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBalance<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pflbalance: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBalance(::core::mem::transmute_copy(&pflbalance)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBalance<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, flbalance: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBalance(flbalance) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMute<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfmute: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMute(::core::mem::transmute_copy(&pfmute)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMute<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fmute: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMute(&*(&fmute as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNativeVideoSize<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszvideo: *mut super::super::Foundation::SIZE, pszarvideo: *mut super::super::Foundation::SIZE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNativeVideoSize(::core::mem::transmute_copy(&pszvideo), ::core::mem::transmute_copy(&pszarvideo)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIdealVideoSize<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszmin: *mut super::super::Foundation::SIZE, pszmax: *mut super::super::Foundation::SIZE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIdealVideoSize(::core::mem::transmute_copy(&pszmin), ::core::mem::transmute_copy(&pszmax)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoSourceRect<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pnrcsource: *const MFVideoNormalizedRect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVideoSourceRect(&*(&pnrcsource as *const <MFVideoNormalizedRect as ::windows::core::Abi>::Abi as *const <MFVideoNormalizedRect as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoSourceRect<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pnrcsource: *mut MFVideoNormalizedRect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoSourceRect(::core::mem::transmute_copy(&pnrcsource)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAspectRatioMode<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwaspectratiomode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAspectRatioMode(dwaspectratiomode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAspectRatioMode<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwaspectratiomode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAspectRatioMode(::core::mem::transmute_copy(&pdwaspectratiomode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoWindow<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phwndvideo: *mut super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoWindow(::core::mem::transmute_copy(&phwndvideo)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UpdateVideo<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UpdateVideo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderColor<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clr: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBorderColor(clr) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBorderColor<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pclr: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBorderColor(::core::mem::transmute_copy(&pclr)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InsertEffect<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, peffect: *mut ::core::ffi::c_void, foptional: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InsertEffect(&*(&peffect as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType), &*(&foptional as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveEffect<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, peffect: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveEffect(&*(&peffect as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveAllEffects<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveAllEffects() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Shutdown<Impl: IMFPMediaPlayerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Shutdown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMFPMediaPlayer>,
            base.5,
            Play::<Impl, OFFSET>,
            Pause::<Impl, OFFSET>,
            Stop::<Impl, OFFSET>,
            FrameStep::<Impl, OFFSET>,
            SetPosition::<Impl, OFFSET>,
            GetPosition::<Impl, OFFSET>,
            GetDuration::<Impl, OFFSET>,
            SetRate::<Impl, OFFSET>,
            GetRate::<Impl, OFFSET>,
            GetSupportedRates::<Impl, OFFSET>,
            GetState::<Impl, OFFSET>,
            CreateMediaItemFromURL::<Impl, OFFSET>,
            CreateMediaItemFromObject::<Impl, OFFSET>,
            SetMediaItem::<Impl, OFFSET>,
            ClearMediaItem::<Impl, OFFSET>,
            GetMediaItem::<Impl, OFFSET>,
            GetVolume::<Impl, OFFSET>,
            SetVolume::<Impl, OFFSET>,
            GetBalance::<Impl, OFFSET>,
            SetBalance::<Impl, OFFSET>,
            GetMute::<Impl, OFFSET>,
            SetMute::<Impl, OFFSET>,
            GetNativeVideoSize::<Impl, OFFSET>,
            GetIdealVideoSize::<Impl, OFFSET>,
            SetVideoSourceRect::<Impl, OFFSET>,
            GetVideoSourceRect::<Impl, OFFSET>,
            SetAspectRatioMode::<Impl, OFFSET>,
            GetAspectRatioMode::<Impl, OFFSET>,
            GetVideoWindow::<Impl, OFFSET>,
            UpdateVideo::<Impl, OFFSET>,
            SetBorderColor::<Impl, OFFSET>,
            GetBorderColor::<Impl, OFFSET>,
            InsertEffect::<Impl, OFFSET>,
            RemoveEffect::<Impl, OFFSET>,
            RemoveAllEffects::<Impl, OFFSET>,
            Shutdown::<Impl, OFFSET>,
        )
    }
}
pub trait IMFPMediaPlayerCallbackImpl: Sized {
    fn OnMediaPlayerEvent();
}
impl ::windows::core::RuntimeName for IMFPMediaPlayerCallback {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFPMediaPlayerCallback";
}
impl IMFPMediaPlayerCallbackVtbl {
    pub const fn new<Impl: IMFPMediaPlayerCallbackImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFPMediaPlayerCallbackVtbl {
        unsafe extern "system" fn OnMediaPlayerEvent<Impl: IMFPMediaPlayerCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, peventheader: *const MFP_EVENT_HEADER) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnMediaPlayerEvent(&*(&peventheader as *const <MFP_EVENT_HEADER as ::windows::core::Abi>::Abi as *const <MFP_EVENT_HEADER as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFPMediaPlayerCallback>, base.5, OnMediaPlayerEvent::<Impl, OFFSET>)
    }
}
pub trait IMFPluginControlImpl: Sized {
    fn GetPreferredClsid();
    fn GetPreferredClsidByIndex();
    fn SetPreferredClsid();
    fn IsDisabled();
    fn GetDisabledByIndex();
    fn SetDisabled();
}
impl ::windows::core::RuntimeName for IMFPluginControl {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFPluginControl";
}
impl IMFPluginControlVtbl {
    pub const fn new<Impl: IMFPluginControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFPluginControlVtbl {
        unsafe extern "system" fn GetPreferredClsid<Impl: IMFPluginControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plugintype: u32, selector: super::super::Foundation::PWSTR, clsid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPreferredClsid(plugintype, &*(&selector as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&clsid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPreferredClsidByIndex<Impl: IMFPluginControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plugintype: u32, index: u32, selector: *mut super::super::Foundation::PWSTR, clsid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPreferredClsidByIndex(plugintype, index, ::core::mem::transmute_copy(&selector), ::core::mem::transmute_copy(&clsid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPreferredClsid<Impl: IMFPluginControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plugintype: u32, selector: super::super::Foundation::PWSTR, clsid: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPreferredClsid(plugintype, &*(&selector as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), &*(&clsid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsDisabled<Impl: IMFPluginControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plugintype: u32, clsid: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsDisabled(plugintype, &*(&clsid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDisabledByIndex<Impl: IMFPluginControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plugintype: u32, index: u32, clsid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDisabledByIndex(plugintype, index, ::core::mem::transmute_copy(&clsid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisabled<Impl: IMFPluginControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plugintype: u32, clsid: *const ::windows::core::GUID, disabled: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDisabled(plugintype, &*(&clsid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&disabled as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFPluginControl>, base.5, GetPreferredClsid::<Impl, OFFSET>, GetPreferredClsidByIndex::<Impl, OFFSET>, SetPreferredClsid::<Impl, OFFSET>, IsDisabled::<Impl, OFFSET>, GetDisabledByIndex::<Impl, OFFSET>, SetDisabled::<Impl, OFFSET>)
    }
}
pub trait IMFPluginControl2Impl: Sized + IMFPluginControlImpl {
    fn SetPolicy();
}
impl ::windows::core::RuntimeName for IMFPluginControl2 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFPluginControl2";
}
impl IMFPluginControl2Vtbl {
    pub const fn new<Impl: IMFPluginControl2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFPluginControl2Vtbl {
        unsafe extern "system" fn SetPolicy<Impl: IMFPluginControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, policy: MF_PLUGIN_CONTROL_POLICY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPolicy(policy) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFPluginControl2>, base.5, SetPolicy::<Impl, OFFSET>)
    }
}
pub trait IMFPresentationClockImpl: Sized + IMFClockImpl {
    fn SetTimeSource();
    fn GetTimeSource();
    fn GetTime();
    fn AddClockStateSink();
    fn RemoveClockStateSink();
    fn Start();
    fn Stop();
    fn Pause();
}
impl ::windows::core::RuntimeName for IMFPresentationClock {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFPresentationClock";
}
impl IMFPresentationClockVtbl {
    pub const fn new<Impl: IMFPresentationClockImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFPresentationClockVtbl {
        unsafe extern "system" fn SetTimeSource<Impl: IMFPresentationClockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptimesource: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTimeSource(&*(&ptimesource as *const <IMFPresentationTimeSource as ::windows::core::Abi>::Abi as *const <IMFPresentationTimeSource as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTimeSource<Impl: IMFPresentationClockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pptimesource: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTimeSource(::core::mem::transmute_copy(&pptimesource)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTime<Impl: IMFPresentationClockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phnsclocktime: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTime(::core::mem::transmute_copy(&phnsclocktime)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddClockStateSink<Impl: IMFPresentationClockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstatesink: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddClockStateSink(&*(&pstatesink as *const <IMFClockStateSink as ::windows::core::Abi>::Abi as *const <IMFClockStateSink as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveClockStateSink<Impl: IMFPresentationClockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstatesink: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveClockStateSink(&*(&pstatesink as *const <IMFClockStateSink as ::windows::core::Abi>::Abi as *const <IMFClockStateSink as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Start<Impl: IMFPresentationClockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, llclockstartoffset: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Start(llclockstartoffset) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Stop<Impl: IMFPresentationClockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Pause<Impl: IMFPresentationClockImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Pause() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFPresentationClock>, base.5, SetTimeSource::<Impl, OFFSET>, GetTimeSource::<Impl, OFFSET>, GetTime::<Impl, OFFSET>, AddClockStateSink::<Impl, OFFSET>, RemoveClockStateSink::<Impl, OFFSET>, Start::<Impl, OFFSET>, Stop::<Impl, OFFSET>, Pause::<Impl, OFFSET>)
    }
}
pub trait IMFPresentationDescriptorImpl: Sized + IMFAttributesImpl {
    fn GetStreamDescriptorCount();
    fn GetStreamDescriptorByIndex();
    fn SelectStream();
    fn DeselectStream();
    fn Clone();
}
impl ::windows::core::RuntimeName for IMFPresentationDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFPresentationDescriptor";
}
impl IMFPresentationDescriptorVtbl {
    pub const fn new<Impl: IMFPresentationDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFPresentationDescriptorVtbl {
        unsafe extern "system" fn GetStreamDescriptorCount<Impl: IMFPresentationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwdescriptorcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamDescriptorCount(::core::mem::transmute_copy(&pdwdescriptorcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamDescriptorByIndex<Impl: IMFPresentationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, pfselected: *mut super::super::Foundation::BOOL, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamDescriptorByIndex(dwindex, ::core::mem::transmute_copy(&pfselected), ::core::mem::transmute_copy(&ppdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectStream<Impl: IMFPresentationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwdescriptorindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectStream(dwdescriptorindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DeselectStream<Impl: IMFPresentationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwdescriptorindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DeselectStream(dwdescriptorindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IMFPresentationDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pppresentationdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clone(::core::mem::transmute_copy(&pppresentationdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFPresentationDescriptor>, base.5, GetStreamDescriptorCount::<Impl, OFFSET>, GetStreamDescriptorByIndex::<Impl, OFFSET>, SelectStream::<Impl, OFFSET>, DeselectStream::<Impl, OFFSET>, Clone::<Impl, OFFSET>)
    }
}
pub trait IMFPresentationTimeSourceImpl: Sized + IMFClockImpl {
    fn GetUnderlyingClock();
}
impl ::windows::core::RuntimeName for IMFPresentationTimeSource {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFPresentationTimeSource";
}
impl IMFPresentationTimeSourceVtbl {
    pub const fn new<Impl: IMFPresentationTimeSourceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFPresentationTimeSourceVtbl {
        unsafe extern "system" fn GetUnderlyingClock<Impl: IMFPresentationTimeSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppclock: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetUnderlyingClock(::core::mem::transmute_copy(&ppclock)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFPresentationTimeSource>, base.5, GetUnderlyingClock::<Impl, OFFSET>)
    }
}
pub trait IMFProtectedEnvironmentAccessImpl: Sized {
    fn Call();
    fn ReadGRL();
}
impl ::windows::core::RuntimeName for IMFProtectedEnvironmentAccess {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFProtectedEnvironmentAccess";
}
impl IMFProtectedEnvironmentAccessVtbl {
    pub const fn new<Impl: IMFProtectedEnvironmentAccessImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFProtectedEnvironmentAccessVtbl {
        unsafe extern "system" fn Call<Impl: IMFProtectedEnvironmentAccessImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, inputlength: u32, input: *const u8, outputlength: u32, output: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Call(inputlength, input, outputlength, ::core::mem::transmute_copy(&output)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReadGRL<Impl: IMFProtectedEnvironmentAccessImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, outputlength: *mut u32, output: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReadGRL(::core::mem::transmute_copy(&outputlength), ::core::mem::transmute_copy(&output)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFProtectedEnvironmentAccess>, base.5, Call::<Impl, OFFSET>, ReadGRL::<Impl, OFFSET>)
    }
}
pub trait IMFQualityAdviseImpl: Sized {
    fn SetDropMode();
    fn SetQualityLevel();
    fn GetDropMode();
    fn GetQualityLevel();
    fn DropTime();
}
impl ::windows::core::RuntimeName for IMFQualityAdvise {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFQualityAdvise";
}
impl IMFQualityAdviseVtbl {
    pub const fn new<Impl: IMFQualityAdviseImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFQualityAdviseVtbl {
        unsafe extern "system" fn SetDropMode<Impl: IMFQualityAdviseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, edropmode: MF_QUALITY_DROP_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDropMode(edropmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetQualityLevel<Impl: IMFQualityAdviseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, equalitylevel: MF_QUALITY_LEVEL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetQualityLevel(equalitylevel) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDropMode<Impl: IMFQualityAdviseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pedropmode: *mut MF_QUALITY_DROP_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDropMode(::core::mem::transmute_copy(&pedropmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetQualityLevel<Impl: IMFQualityAdviseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pequalitylevel: *mut MF_QUALITY_LEVEL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetQualityLevel(::core::mem::transmute_copy(&pequalitylevel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DropTime<Impl: IMFQualityAdviseImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnsamounttodrop: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DropTime(hnsamounttodrop) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFQualityAdvise>, base.5, SetDropMode::<Impl, OFFSET>, SetQualityLevel::<Impl, OFFSET>, GetDropMode::<Impl, OFFSET>, GetQualityLevel::<Impl, OFFSET>, DropTime::<Impl, OFFSET>)
    }
}
pub trait IMFQualityAdvise2Impl: Sized + IMFQualityAdviseImpl {
    fn NotifyQualityEvent();
}
impl ::windows::core::RuntimeName for IMFQualityAdvise2 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFQualityAdvise2";
}
impl IMFQualityAdvise2Vtbl {
    pub const fn new<Impl: IMFQualityAdvise2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFQualityAdvise2Vtbl {
        unsafe extern "system" fn NotifyQualityEvent<Impl: IMFQualityAdvise2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pevent: ::windows::core::RawPtr, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NotifyQualityEvent(&*(&pevent as *const <IMFMediaEvent as ::windows::core::Abi>::Abi as *const <IMFMediaEvent as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pdwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFQualityAdvise2>, base.5, NotifyQualityEvent::<Impl, OFFSET>)
    }
}
pub trait IMFQualityAdviseLimitsImpl: Sized {
    fn GetMaximumDropMode();
    fn GetMinimumQualityLevel();
}
impl ::windows::core::RuntimeName for IMFQualityAdviseLimits {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFQualityAdviseLimits";
}
impl IMFQualityAdviseLimitsVtbl {
    pub const fn new<Impl: IMFQualityAdviseLimitsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFQualityAdviseLimitsVtbl {
        unsafe extern "system" fn GetMaximumDropMode<Impl: IMFQualityAdviseLimitsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pedropmode: *mut MF_QUALITY_DROP_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMaximumDropMode(::core::mem::transmute_copy(&pedropmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMinimumQualityLevel<Impl: IMFQualityAdviseLimitsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pequalitylevel: *mut MF_QUALITY_LEVEL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMinimumQualityLevel(::core::mem::transmute_copy(&pequalitylevel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFQualityAdviseLimits>, base.5, GetMaximumDropMode::<Impl, OFFSET>, GetMinimumQualityLevel::<Impl, OFFSET>)
    }
}
pub trait IMFQualityManagerImpl: Sized {
    fn NotifyTopology();
    fn NotifyPresentationClock();
    fn NotifyProcessInput();
    fn NotifyProcessOutput();
    fn NotifyQualityEvent();
    fn Shutdown();
}
impl ::windows::core::RuntimeName for IMFQualityManager {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFQualityManager";
}
impl IMFQualityManagerVtbl {
    pub const fn new<Impl: IMFQualityManagerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFQualityManagerVtbl {
        unsafe extern "system" fn NotifyTopology<Impl: IMFQualityManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptopology: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NotifyTopology(&*(&ptopology as *const <IMFTopology as ::windows::core::Abi>::Abi as *const <IMFTopology as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NotifyPresentationClock<Impl: IMFQualityManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pclock: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NotifyPresentationClock(&*(&pclock as *const <IMFPresentationClock as ::windows::core::Abi>::Abi as *const <IMFPresentationClock as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NotifyProcessInput<Impl: IMFQualityManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pnode: ::windows::core::RawPtr, linputindex: i32, psample: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NotifyProcessInput(&*(&pnode as *const <IMFTopologyNode as ::windows::core::Abi>::Abi as *const <IMFTopologyNode as ::windows::core::DefaultType>::DefaultType), linputindex, &*(&psample as *const <IMFSample as ::windows::core::Abi>::Abi as *const <IMFSample as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NotifyProcessOutput<Impl: IMFQualityManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pnode: ::windows::core::RawPtr, loutputindex: i32, psample: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NotifyProcessOutput(&*(&pnode as *const <IMFTopologyNode as ::windows::core::Abi>::Abi as *const <IMFTopologyNode as ::windows::core::DefaultType>::DefaultType), loutputindex, &*(&psample as *const <IMFSample as ::windows::core::Abi>::Abi as *const <IMFSample as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NotifyQualityEvent<Impl: IMFQualityManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pobject: *mut ::core::ffi::c_void, pevent: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NotifyQualityEvent(&*(&pobject as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType), &*(&pevent as *const <IMFMediaEvent as ::windows::core::Abi>::Abi as *const <IMFMediaEvent as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Shutdown<Impl: IMFQualityManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Shutdown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFQualityManager>, base.5, NotifyTopology::<Impl, OFFSET>, NotifyPresentationClock::<Impl, OFFSET>, NotifyProcessInput::<Impl, OFFSET>, NotifyProcessOutput::<Impl, OFFSET>, NotifyQualityEvent::<Impl, OFFSET>, Shutdown::<Impl, OFFSET>)
    }
}
pub trait IMFRateControlImpl: Sized {
    fn SetRate();
    fn GetRate();
}
impl ::windows::core::RuntimeName for IMFRateControl {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFRateControl";
}
impl IMFRateControlVtbl {
    pub const fn new<Impl: IMFRateControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFRateControlVtbl {
        unsafe extern "system" fn SetRate<Impl: IMFRateControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fthin: super::super::Foundation::BOOL, flrate: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRate(&*(&fthin as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType), flrate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRate<Impl: IMFRateControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfthin: *mut super::super::Foundation::BOOL, pflrate: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRate(&*(&pfthin as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType), pflrate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFRateControl>, base.5, SetRate::<Impl, OFFSET>, GetRate::<Impl, OFFSET>)
    }
}
pub trait IMFRateSupportImpl: Sized {
    fn GetSlowestRate();
    fn GetFastestRate();
    fn IsRateSupported();
}
impl ::windows::core::RuntimeName for IMFRateSupport {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFRateSupport";
}
impl IMFRateSupportVtbl {
    pub const fn new<Impl: IMFRateSupportImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFRateSupportVtbl {
        unsafe extern "system" fn GetSlowestRate<Impl: IMFRateSupportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, edirection: MFRATE_DIRECTION, fthin: super::super::Foundation::BOOL, pflrate: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSlowestRate(edirection, &*(&fthin as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pflrate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFastestRate<Impl: IMFRateSupportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, edirection: MFRATE_DIRECTION, fthin: super::super::Foundation::BOOL, pflrate: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFastestRate(edirection, &*(&fthin as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pflrate)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsRateSupported<Impl: IMFRateSupportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fthin: super::super::Foundation::BOOL, flrate: f32, pflnearestsupportedrate: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsRateSupported(&*(&fthin as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType), flrate, pflnearestsupportedrate) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFRateSupport>, base.5, GetSlowestRate::<Impl, OFFSET>, GetFastestRate::<Impl, OFFSET>, IsRateSupported::<Impl, OFFSET>)
    }
}
pub trait IMFReadWriteClassFactoryImpl: Sized {
    fn CreateInstanceFromURL();
    fn CreateInstanceFromObject();
}
impl ::windows::core::RuntimeName for IMFReadWriteClassFactory {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFReadWriteClassFactory";
}
impl IMFReadWriteClassFactoryVtbl {
    pub const fn new<Impl: IMFReadWriteClassFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFReadWriteClassFactoryVtbl {
        unsafe extern "system" fn CreateInstanceFromURL<Impl: IMFReadWriteClassFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clsid: *const ::windows::core::GUID, pwszurl: super::super::Foundation::PWSTR, pattributes: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstanceFromURL(
                &*(&clsid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&pwszurl as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&pattributes as *const <IMFAttributes as ::windows::core::Abi>::Abi as *const <IMFAttributes as ::windows::core::DefaultType>::DefaultType),
                &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&ppvobject),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateInstanceFromObject<Impl: IMFReadWriteClassFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clsid: *const ::windows::core::GUID, punkobject: *mut ::core::ffi::c_void, pattributes: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstanceFromObject(
                &*(&clsid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&punkobject as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType),
                &*(&pattributes as *const <IMFAttributes as ::windows::core::Abi>::Abi as *const <IMFAttributes as ::windows::core::DefaultType>::DefaultType),
                &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&ppvobject),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFReadWriteClassFactory>, base.5, CreateInstanceFromURL::<Impl, OFFSET>, CreateInstanceFromObject::<Impl, OFFSET>)
    }
}
pub trait IMFRealTimeClientImpl: Sized {
    fn RegisterThreads();
    fn UnregisterThreads();
    fn SetWorkQueue();
}
impl ::windows::core::RuntimeName for IMFRealTimeClient {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFRealTimeClient";
}
impl IMFRealTimeClientVtbl {
    pub const fn new<Impl: IMFRealTimeClientImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFRealTimeClientVtbl {
        unsafe extern "system" fn RegisterThreads<Impl: IMFRealTimeClientImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwtaskindex: u32, wszclass: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterThreads(dwtaskindex, &*(&wszclass as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnregisterThreads<Impl: IMFRealTimeClientImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnregisterThreads() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWorkQueue<Impl: IMFRealTimeClientImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwworkqueueid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetWorkQueue(dwworkqueueid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFRealTimeClient>, base.5, RegisterThreads::<Impl, OFFSET>, UnregisterThreads::<Impl, OFFSET>, SetWorkQueue::<Impl, OFFSET>)
    }
}
pub trait IMFRealTimeClientExImpl: Sized {
    fn RegisterThreadsEx();
    fn UnregisterThreads();
    fn SetWorkQueueEx();
}
impl ::windows::core::RuntimeName for IMFRealTimeClientEx {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFRealTimeClientEx";
}
impl IMFRealTimeClientExVtbl {
    pub const fn new<Impl: IMFRealTimeClientExImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFRealTimeClientExVtbl {
        unsafe extern "system" fn RegisterThreadsEx<Impl: IMFRealTimeClientExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwtaskindex: *mut u32, wszclassname: super::super::Foundation::PWSTR, lbasepriority: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterThreadsEx(pdwtaskindex, &*(&wszclassname as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), lbasepriority) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnregisterThreads<Impl: IMFRealTimeClientExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UnregisterThreads() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetWorkQueueEx<Impl: IMFRealTimeClientExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwmultithreadedworkqueueid: u32, lworkitembasepriority: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetWorkQueueEx(dwmultithreadedworkqueueid, lworkitembasepriority) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFRealTimeClientEx>, base.5, RegisterThreadsEx::<Impl, OFFSET>, UnregisterThreads::<Impl, OFFSET>, SetWorkQueueEx::<Impl, OFFSET>)
    }
}
pub trait IMFRelativePanelReportImpl: Sized {
    fn GetRelativePanel();
}
impl ::windows::core::RuntimeName for IMFRelativePanelReport {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFRelativePanelReport";
}
impl IMFRelativePanelReportVtbl {
    pub const fn new<Impl: IMFRelativePanelReportImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFRelativePanelReportVtbl {
        unsafe extern "system" fn GetRelativePanel<Impl: IMFRelativePanelReportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, panel: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRelativePanel(::core::mem::transmute_copy(&panel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFRelativePanelReport>, base.5, GetRelativePanel::<Impl, OFFSET>)
    }
}
pub trait IMFRelativePanelWatcherImpl: Sized + IMFShutdownImpl {
    fn BeginGetReport();
    fn EndGetReport();
    fn GetReport();
}
impl ::windows::core::RuntimeName for IMFRelativePanelWatcher {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFRelativePanelWatcher";
}
impl IMFRelativePanelWatcherVtbl {
    pub const fn new<Impl: IMFRelativePanelWatcherImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFRelativePanelWatcherVtbl {
        unsafe extern "system" fn BeginGetReport<Impl: IMFRelativePanelWatcherImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginGetReport(&*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType), &*(&pstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndGetReport<Impl: IMFRelativePanelWatcherImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, pprelativepanelreport: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndGetReport(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pprelativepanelreport)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetReport<Impl: IMFRelativePanelWatcherImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pprelativepanelreport: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetReport(::core::mem::transmute_copy(&pprelativepanelreport)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFRelativePanelWatcher>, base.5, BeginGetReport::<Impl, OFFSET>, EndGetReport::<Impl, OFFSET>, GetReport::<Impl, OFFSET>)
    }
}
pub trait IMFRemoteAsyncCallbackImpl: Sized {
    fn Invoke();
}
impl ::windows::core::RuntimeName for IMFRemoteAsyncCallback {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFRemoteAsyncCallback";
}
impl IMFRemoteAsyncCallbackVtbl {
    pub const fn new<Impl: IMFRemoteAsyncCallbackImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFRemoteAsyncCallbackVtbl {
        unsafe extern "system" fn Invoke<Impl: IMFRemoteAsyncCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hr: ::windows::core::HRESULT, premoteresult: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Invoke(hr, &*(&premoteresult as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFRemoteAsyncCallback>, base.5, Invoke::<Impl, OFFSET>)
    }
}
pub trait IMFRemoteDesktopPluginImpl: Sized {
    fn UpdateTopology();
}
impl ::windows::core::RuntimeName for IMFRemoteDesktopPlugin {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFRemoteDesktopPlugin";
}
impl IMFRemoteDesktopPluginVtbl {
    pub const fn new<Impl: IMFRemoteDesktopPluginImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFRemoteDesktopPluginVtbl {
        unsafe extern "system" fn UpdateTopology<Impl: IMFRemoteDesktopPluginImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptopology: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UpdateTopology(&*(&ptopology as *const <IMFTopology as ::windows::core::Abi>::Abi as *const <IMFTopology as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFRemoteDesktopPlugin>, base.5, UpdateTopology::<Impl, OFFSET>)
    }
}
pub trait IMFRemoteProxyImpl: Sized {
    fn GetRemoteObject();
    fn GetRemoteHost();
}
impl ::windows::core::RuntimeName for IMFRemoteProxy {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFRemoteProxy";
}
impl IMFRemoteProxyVtbl {
    pub const fn new<Impl: IMFRemoteProxyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFRemoteProxyVtbl {
        unsafe extern "system" fn GetRemoteObject<Impl: IMFRemoteProxyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRemoteObject(&*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppv)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRemoteHost<Impl: IMFRemoteProxyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRemoteHost(&*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppv)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFRemoteProxy>, base.5, GetRemoteObject::<Impl, OFFSET>, GetRemoteHost::<Impl, OFFSET>)
    }
}
pub trait IMFSAMIStyleImpl: Sized {
    fn GetStyleCount();
    fn GetStyles();
    fn SetSelectedStyle();
    fn GetSelectedStyle();
}
impl ::windows::core::RuntimeName for IMFSAMIStyle {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSAMIStyle";
}
impl IMFSAMIStyleVtbl {
    pub const fn new<Impl: IMFSAMIStyleImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSAMIStyleVtbl {
        unsafe extern "system" fn GetStyleCount<Impl: IMFSAMIStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStyleCount(::core::mem::transmute_copy(&pdwcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStyles<Impl: IMFSAMIStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppropvarstylearray: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStyles(::core::mem::transmute_copy(&ppropvarstylearray)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedStyle<Impl: IMFSAMIStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwszstyle: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSelectedStyle(&*(&pwszstyle as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSelectedStyle<Impl: IMFSAMIStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppwszstyle: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSelectedStyle(::core::mem::transmute_copy(&ppwszstyle)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSAMIStyle>, base.5, GetStyleCount::<Impl, OFFSET>, GetStyles::<Impl, OFFSET>, SetSelectedStyle::<Impl, OFFSET>, GetSelectedStyle::<Impl, OFFSET>)
    }
}
pub trait IMFSSLCertificateManagerImpl: Sized {
    fn GetClientCertificate();
    fn BeginGetClientCertificate();
    fn EndGetClientCertificate();
    fn GetCertificatePolicy();
    fn OnServerCertificate();
}
impl ::windows::core::RuntimeName for IMFSSLCertificateManager {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSSLCertificateManager";
}
impl IMFSSLCertificateManagerVtbl {
    pub const fn new<Impl: IMFSSLCertificateManagerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSSLCertificateManagerVtbl {
        unsafe extern "system" fn GetClientCertificate<Impl: IMFSSLCertificateManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszurl: super::super::Foundation::PWSTR, ppbdata: *mut *mut u8, pcbdata: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetClientCertificate(&*(&pszurl as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppbdata), ::core::mem::transmute_copy(&pcbdata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginGetClientCertificate<Impl: IMFSSLCertificateManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszurl: super::super::Foundation::PWSTR, pcallback: ::windows::core::RawPtr, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginGetClientCertificate(
                &*(&pszurl as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType),
                &*(&pstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndGetClientCertificate<Impl: IMFSSLCertificateManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, ppbdata: *mut *mut u8, pcbdata: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndGetClientCertificate(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppbdata), ::core::mem::transmute_copy(&pcbdata)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCertificatePolicy<Impl: IMFSSLCertificateManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszurl: super::super::Foundation::PWSTR, pfoverrideautomaticcheck: *mut super::super::Foundation::BOOL, pfclientcertificateavailable: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCertificatePolicy(&*(&pszurl as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pfoverrideautomaticcheck), ::core::mem::transmute_copy(&pfclientcertificateavailable)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnServerCertificate<Impl: IMFSSLCertificateManagerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszurl: super::super::Foundation::PWSTR, pbdata: *const u8, cbdata: u32, pfisgood: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnServerCertificate(&*(&pszurl as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), pbdata, cbdata, ::core::mem::transmute_copy(&pfisgood)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSSLCertificateManager>, base.5, GetClientCertificate::<Impl, OFFSET>, BeginGetClientCertificate::<Impl, OFFSET>, EndGetClientCertificate::<Impl, OFFSET>, GetCertificatePolicy::<Impl, OFFSET>, OnServerCertificate::<Impl, OFFSET>)
    }
}
pub trait IMFSampleImpl: Sized + IMFAttributesImpl {
    fn GetSampleFlags();
    fn SetSampleFlags();
    fn GetSampleTime();
    fn SetSampleTime();
    fn GetSampleDuration();
    fn SetSampleDuration();
    fn GetBufferCount();
    fn GetBufferByIndex();
    fn ConvertToContiguousBuffer();
    fn AddBuffer();
    fn RemoveBufferByIndex();
    fn RemoveAllBuffers();
    fn GetTotalLength();
    fn CopyToBuffer();
}
impl ::windows::core::RuntimeName for IMFSample {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSample";
}
impl IMFSampleVtbl {
    pub const fn new<Impl: IMFSampleImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSampleVtbl {
        unsafe extern "system" fn GetSampleFlags<Impl: IMFSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwsampleflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSampleFlags(::core::mem::transmute_copy(&pdwsampleflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSampleFlags<Impl: IMFSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwsampleflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSampleFlags(dwsampleflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSampleTime<Impl: IMFSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phnssampletime: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSampleTime(::core::mem::transmute_copy(&phnssampletime)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSampleTime<Impl: IMFSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnssampletime: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSampleTime(hnssampletime) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSampleDuration<Impl: IMFSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phnssampleduration: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSampleDuration(::core::mem::transmute_copy(&phnssampleduration)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSampleDuration<Impl: IMFSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnssampleduration: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSampleDuration(hnssampleduration) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBufferCount<Impl: IMFSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwbuffercount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBufferCount(::core::mem::transmute_copy(&pdwbuffercount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBufferByIndex<Impl: IMFSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppbuffer: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBufferByIndex(dwindex, ::core::mem::transmute_copy(&ppbuffer)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConvertToContiguousBuffer<Impl: IMFSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppbuffer: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConvertToContiguousBuffer(::core::mem::transmute_copy(&ppbuffer)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddBuffer<Impl: IMFSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbuffer: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddBuffer(&*(&pbuffer as *const <IMFMediaBuffer as ::windows::core::Abi>::Abi as *const <IMFMediaBuffer as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveBufferByIndex<Impl: IMFSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveBufferByIndex(dwindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveAllBuffers<Impl: IMFSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveAllBuffers() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTotalLength<Impl: IMFSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcbtotallength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTotalLength(::core::mem::transmute_copy(&pcbtotallength)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CopyToBuffer<Impl: IMFSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbuffer: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CopyToBuffer(&*(&pbuffer as *const <IMFMediaBuffer as ::windows::core::Abi>::Abi as *const <IMFMediaBuffer as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMFSample>,
            base.5,
            GetSampleFlags::<Impl, OFFSET>,
            SetSampleFlags::<Impl, OFFSET>,
            GetSampleTime::<Impl, OFFSET>,
            SetSampleTime::<Impl, OFFSET>,
            GetSampleDuration::<Impl, OFFSET>,
            SetSampleDuration::<Impl, OFFSET>,
            GetBufferCount::<Impl, OFFSET>,
            GetBufferByIndex::<Impl, OFFSET>,
            ConvertToContiguousBuffer::<Impl, OFFSET>,
            AddBuffer::<Impl, OFFSET>,
            RemoveBufferByIndex::<Impl, OFFSET>,
            RemoveAllBuffers::<Impl, OFFSET>,
            GetTotalLength::<Impl, OFFSET>,
            CopyToBuffer::<Impl, OFFSET>,
        )
    }
}
pub trait IMFSampleAllocatorControlImpl: Sized {
    fn SetDefaultAllocator();
    fn GetAllocatorUsage();
}
impl ::windows::core::RuntimeName for IMFSampleAllocatorControl {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSampleAllocatorControl";
}
impl IMFSampleAllocatorControlVtbl {
    pub const fn new<Impl: IMFSampleAllocatorControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSampleAllocatorControlVtbl {
        unsafe extern "system" fn SetDefaultAllocator<Impl: IMFSampleAllocatorControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, pallocator: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDefaultAllocator(dwoutputstreamid, &*(&pallocator as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAllocatorUsage<Impl: IMFSampleAllocatorControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, pdwinputstreamid: *mut u32, peusage: *mut MFSampleAllocatorUsage) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAllocatorUsage(dwoutputstreamid, ::core::mem::transmute_copy(&pdwinputstreamid), ::core::mem::transmute_copy(&peusage)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSampleAllocatorControl>, base.5, SetDefaultAllocator::<Impl, OFFSET>, GetAllocatorUsage::<Impl, OFFSET>)
    }
}
pub trait IMFSampleGrabberSinkCallbackImpl: Sized + IMFClockStateSinkImpl {
    fn OnSetPresentationClock();
    fn OnProcessSample();
    fn OnShutdown();
}
impl ::windows::core::RuntimeName for IMFSampleGrabberSinkCallback {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSampleGrabberSinkCallback";
}
impl IMFSampleGrabberSinkCallbackVtbl {
    pub const fn new<Impl: IMFSampleGrabberSinkCallbackImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSampleGrabberSinkCallbackVtbl {
        unsafe extern "system" fn OnSetPresentationClock<Impl: IMFSampleGrabberSinkCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppresentationclock: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnSetPresentationClock(&*(&ppresentationclock as *const <IMFPresentationClock as ::windows::core::Abi>::Abi as *const <IMFPresentationClock as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnProcessSample<Impl: IMFSampleGrabberSinkCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidmajormediatype: *const ::windows::core::GUID, dwsampleflags: u32, llsampletime: i64, llsampleduration: i64, psamplebuffer: *const u8, dwsamplesize: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnProcessSample(&*(&guidmajormediatype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), dwsampleflags, llsampletime, llsampleduration, psamplebuffer, dwsamplesize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnShutdown<Impl: IMFSampleGrabberSinkCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnShutdown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSampleGrabberSinkCallback>, base.5, OnSetPresentationClock::<Impl, OFFSET>, OnProcessSample::<Impl, OFFSET>, OnShutdown::<Impl, OFFSET>)
    }
}
pub trait IMFSampleGrabberSinkCallback2Impl: Sized + IMFSampleGrabberSinkCallbackImpl + IMFClockStateSinkImpl {
    fn OnProcessSampleEx();
}
impl ::windows::core::RuntimeName for IMFSampleGrabberSinkCallback2 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSampleGrabberSinkCallback2";
}
impl IMFSampleGrabberSinkCallback2Vtbl {
    pub const fn new<Impl: IMFSampleGrabberSinkCallback2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSampleGrabberSinkCallback2Vtbl {
        unsafe extern "system" fn OnProcessSampleEx<Impl: IMFSampleGrabberSinkCallback2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidmajormediatype: *const ::windows::core::GUID, dwsampleflags: u32, llsampletime: i64, llsampleduration: i64, psamplebuffer: *const u8, dwsamplesize: u32, pattributes: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnProcessSampleEx(&*(&guidmajormediatype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), dwsampleflags, llsampletime, llsampleduration, psamplebuffer, dwsamplesize, &*(&pattributes as *const <IMFAttributes as ::windows::core::Abi>::Abi as *const <IMFAttributes as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSampleGrabberSinkCallback2>, base.5, OnProcessSampleEx::<Impl, OFFSET>)
    }
}
pub trait IMFSampleOutputStreamImpl: Sized {
    fn BeginWriteSample();
    fn EndWriteSample();
    fn Close();
}
impl ::windows::core::RuntimeName for IMFSampleOutputStream {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSampleOutputStream";
}
impl IMFSampleOutputStreamVtbl {
    pub const fn new<Impl: IMFSampleOutputStreamImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSampleOutputStreamVtbl {
        unsafe extern "system" fn BeginWriteSample<Impl: IMFSampleOutputStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psample: ::windows::core::RawPtr, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginWriteSample(&*(&psample as *const <IMFSample as ::windows::core::Abi>::Abi as *const <IMFSample as ::windows::core::DefaultType>::DefaultType), &*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType), &*(&punkstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndWriteSample<Impl: IMFSampleOutputStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndWriteSample(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Close<Impl: IMFSampleOutputStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Close() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSampleOutputStream>, base.5, BeginWriteSample::<Impl, OFFSET>, EndWriteSample::<Impl, OFFSET>, Close::<Impl, OFFSET>)
    }
}
pub trait IMFSampleProtectionImpl: Sized {
    fn GetInputProtectionVersion();
    fn GetOutputProtectionVersion();
    fn GetProtectionCertificate();
    fn InitOutputProtection();
    fn InitInputProtection();
}
impl ::windows::core::RuntimeName for IMFSampleProtection {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSampleProtection";
}
impl IMFSampleProtectionVtbl {
    pub const fn new<Impl: IMFSampleProtectionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSampleProtectionVtbl {
        unsafe extern "system" fn GetInputProtectionVersion<Impl: IMFSampleProtectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwversion: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInputProtectionVersion(::core::mem::transmute_copy(&pdwversion)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputProtectionVersion<Impl: IMFSampleProtectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwversion: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputProtectionVersion(::core::mem::transmute_copy(&pdwversion)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProtectionCertificate<Impl: IMFSampleProtectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwversion: u32, ppcert: *mut *mut u8, pcbcert: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProtectionCertificate(dwversion, ::core::mem::transmute_copy(&ppcert), ::core::mem::transmute_copy(&pcbcert)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InitOutputProtection<Impl: IMFSampleProtectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwversion: u32, dwoutputid: u32, pbcert: *const u8, cbcert: u32, ppbseed: *mut *mut u8, pcbseed: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InitOutputProtection(dwversion, dwoutputid, pbcert, cbcert, ::core::mem::transmute_copy(&ppbseed), ::core::mem::transmute_copy(&pcbseed)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InitInputProtection<Impl: IMFSampleProtectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwversion: u32, dwinputid: u32, pbseed: *const u8, cbseed: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InitInputProtection(dwversion, dwinputid, pbseed, cbseed) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSampleProtection>, base.5, GetInputProtectionVersion::<Impl, OFFSET>, GetOutputProtectionVersion::<Impl, OFFSET>, GetProtectionCertificate::<Impl, OFFSET>, InitOutputProtection::<Impl, OFFSET>, InitInputProtection::<Impl, OFFSET>)
    }
}
pub trait IMFSaveJobImpl: Sized {
    fn BeginSave();
    fn EndSave();
    fn CancelSave();
    fn GetProgress();
}
impl ::windows::core::RuntimeName for IMFSaveJob {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSaveJob";
}
impl IMFSaveJobVtbl {
    pub const fn new<Impl: IMFSaveJobImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSaveJobVtbl {
        unsafe extern "system" fn BeginSave<Impl: IMFSaveJobImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstream: ::windows::core::RawPtr, pcallback: ::windows::core::RawPtr, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginSave(&*(&pstream as *const <IMFByteStream as ::windows::core::Abi>::Abi as *const <IMFByteStream as ::windows::core::DefaultType>::DefaultType), &*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType), &*(&pstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndSave<Impl: IMFSaveJobImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndSave(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CancelSave<Impl: IMFSaveJobImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CancelSave() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProgress<Impl: IMFSaveJobImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwpercentcomplete: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProgress(::core::mem::transmute_copy(&pdwpercentcomplete)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSaveJob>, base.5, BeginSave::<Impl, OFFSET>, EndSave::<Impl, OFFSET>, CancelSave::<Impl, OFFSET>, GetProgress::<Impl, OFFSET>)
    }
}
pub trait IMFSchemeHandlerImpl: Sized {
    fn BeginCreateObject();
    fn EndCreateObject();
    fn CancelObjectCreation();
}
impl ::windows::core::RuntimeName for IMFSchemeHandler {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSchemeHandler";
}
impl IMFSchemeHandlerVtbl {
    pub const fn new<Impl: IMFSchemeHandlerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSchemeHandlerVtbl {
        unsafe extern "system" fn BeginCreateObject<Impl: IMFSchemeHandlerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwszurl: super::super::Foundation::PWSTR, dwflags: u32, pprops: ::windows::core::RawPtr, ppiunknowncancelcookie: *mut *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginCreateObject(
                &*(&pwszurl as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                dwflags,
                &*(&pprops as *const <super::super::UI::Shell::PropertiesSystem::IPropertyStore as ::windows::core::Abi>::Abi as *const <super::super::UI::Shell::PropertiesSystem::IPropertyStore as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&ppiunknowncancelcookie),
                &*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType),
                &*(&punkstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndCreateObject<Impl: IMFSchemeHandlerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndCreateObject(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pobjecttype), ::core::mem::transmute_copy(&ppobject)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CancelObjectCreation<Impl: IMFSchemeHandlerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, piunknowncancelcookie: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CancelObjectCreation(&*(&piunknowncancelcookie as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSchemeHandler>, base.5, BeginCreateObject::<Impl, OFFSET>, EndCreateObject::<Impl, OFFSET>, CancelObjectCreation::<Impl, OFFSET>)
    }
}
pub trait IMFSecureBufferImpl: Sized {
    fn GetIdentifier();
}
impl ::windows::core::RuntimeName for IMFSecureBuffer {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSecureBuffer";
}
impl IMFSecureBufferVtbl {
    pub const fn new<Impl: IMFSecureBufferImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSecureBufferVtbl {
        unsafe extern "system" fn GetIdentifier<Impl: IMFSecureBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguididentifier: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIdentifier(::core::mem::transmute_copy(&pguididentifier)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSecureBuffer>, base.5, GetIdentifier::<Impl, OFFSET>)
    }
}
pub trait IMFSecureChannelImpl: Sized {
    fn GetCertificate();
    fn SetupSession();
}
impl ::windows::core::RuntimeName for IMFSecureChannel {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSecureChannel";
}
impl IMFSecureChannelVtbl {
    pub const fn new<Impl: IMFSecureChannelImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSecureChannelVtbl {
        unsafe extern "system" fn GetCertificate<Impl: IMFSecureChannelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppcert: *mut *mut u8, pcbcert: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCertificate(::core::mem::transmute_copy(&ppcert), ::core::mem::transmute_copy(&pcbcert)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetupSession<Impl: IMFSecureChannelImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbencryptedsessionkey: *const u8, cbsessionkey: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetupSession(pbencryptedsessionkey, cbsessionkey) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSecureChannel>, base.5, GetCertificate::<Impl, OFFSET>, SetupSession::<Impl, OFFSET>)
    }
}
pub trait IMFSeekInfoImpl: Sized {
    fn GetNearestKeyFrames();
}
impl ::windows::core::RuntimeName for IMFSeekInfo {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSeekInfo";
}
impl IMFSeekInfoVtbl {
    pub const fn new<Impl: IMFSeekInfoImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSeekInfoVtbl {
        unsafe extern "system" fn GetNearestKeyFrames<Impl: IMFSeekInfoImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pguidtimeformat: *const ::windows::core::GUID, pvarstartposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pvarpreviouskeyframe: *mut super::super::System::Com::StructuredStorage::PROPVARIANT, pvarnextkeyframe: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNearestKeyFrames(
                &*(&pguidtimeformat as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType),
                &*(&pvarstartposition as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&pvarpreviouskeyframe),
                ::core::mem::transmute_copy(&pvarnextkeyframe),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSeekInfo>, base.5, GetNearestKeyFrames::<Impl, OFFSET>)
    }
}
pub trait IMFSensorActivitiesReportImpl: Sized {
    fn GetCount();
    fn GetActivityReport();
    fn GetActivityReportByDeviceName();
}
impl ::windows::core::RuntimeName for IMFSensorActivitiesReport {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSensorActivitiesReport";
}
impl IMFSensorActivitiesReportVtbl {
    pub const fn new<Impl: IMFSensorActivitiesReportImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSensorActivitiesReportVtbl {
        unsafe extern "system" fn GetCount<Impl: IMFSensorActivitiesReportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pccount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCount(::core::mem::transmute_copy(&pccount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetActivityReport<Impl: IMFSensorActivitiesReportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: u32, sensoractivityreport: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetActivityReport(index, ::core::mem::transmute_copy(&sensoractivityreport)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetActivityReportByDeviceName<Impl: IMFSensorActivitiesReportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, symbolicname: super::super::Foundation::PWSTR, sensoractivityreport: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetActivityReportByDeviceName(&*(&symbolicname as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&sensoractivityreport)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSensorActivitiesReport>, base.5, GetCount::<Impl, OFFSET>, GetActivityReport::<Impl, OFFSET>, GetActivityReportByDeviceName::<Impl, OFFSET>)
    }
}
pub trait IMFSensorActivitiesReportCallbackImpl: Sized {
    fn OnActivitiesReport();
}
impl ::windows::core::RuntimeName for IMFSensorActivitiesReportCallback {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSensorActivitiesReportCallback";
}
impl IMFSensorActivitiesReportCallbackVtbl {
    pub const fn new<Impl: IMFSensorActivitiesReportCallbackImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSensorActivitiesReportCallbackVtbl {
        unsafe extern "system" fn OnActivitiesReport<Impl: IMFSensorActivitiesReportCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, sensoractivitiesreport: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnActivitiesReport(&*(&sensoractivitiesreport as *const <IMFSensorActivitiesReport as ::windows::core::Abi>::Abi as *const <IMFSensorActivitiesReport as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSensorActivitiesReportCallback>, base.5, OnActivitiesReport::<Impl, OFFSET>)
    }
}
pub trait IMFSensorActivityMonitorImpl: Sized {
    fn Start();
    fn Stop();
}
impl ::windows::core::RuntimeName for IMFSensorActivityMonitor {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSensorActivityMonitor";
}
impl IMFSensorActivityMonitorVtbl {
    pub const fn new<Impl: IMFSensorActivityMonitorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSensorActivityMonitorVtbl {
        unsafe extern "system" fn Start<Impl: IMFSensorActivityMonitorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Start() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Stop<Impl: IMFSensorActivityMonitorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSensorActivityMonitor>, base.5, Start::<Impl, OFFSET>, Stop::<Impl, OFFSET>)
    }
}
pub trait IMFSensorActivityReportImpl: Sized {
    fn GetFriendlyName();
    fn GetSymbolicLink();
    fn GetProcessCount();
    fn GetProcessActivity();
}
impl ::windows::core::RuntimeName for IMFSensorActivityReport {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSensorActivityReport";
}
impl IMFSensorActivityReportVtbl {
    pub const fn new<Impl: IMFSensorActivityReportImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSensorActivityReportVtbl {
        unsafe extern "system" fn GetFriendlyName<Impl: IMFSensorActivityReportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, friendlyname: super::super::Foundation::PWSTR, cchfriendlyname: u32, pcchwritten: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFriendlyName(::core::mem::transmute_copy(&friendlyname), cchfriendlyname, ::core::mem::transmute_copy(&pcchwritten)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSymbolicLink<Impl: IMFSensorActivityReportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, symboliclink: super::super::Foundation::PWSTR, cchsymboliclink: u32, pcchwritten: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSymbolicLink(::core::mem::transmute_copy(&symboliclink), cchsymboliclink, ::core::mem::transmute_copy(&pcchwritten)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProcessCount<Impl: IMFSensorActivityReportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pccount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProcessCount(::core::mem::transmute_copy(&pccount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProcessActivity<Impl: IMFSensorActivityReportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: u32, ppprocessactivity: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProcessActivity(index, ::core::mem::transmute_copy(&ppprocessactivity)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSensorActivityReport>, base.5, GetFriendlyName::<Impl, OFFSET>, GetSymbolicLink::<Impl, OFFSET>, GetProcessCount::<Impl, OFFSET>, GetProcessActivity::<Impl, OFFSET>)
    }
}
pub trait IMFSensorDeviceImpl: Sized {
    fn GetDeviceId();
    fn GetDeviceType();
    fn GetFlags();
    fn GetSymbolicLink();
    fn GetDeviceAttributes();
    fn GetStreamAttributesCount();
    fn GetStreamAttributes();
    fn SetSensorDeviceMode();
    fn GetSensorDeviceMode();
}
impl ::windows::core::RuntimeName for IMFSensorDevice {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSensorDevice";
}
impl IMFSensorDeviceVtbl {
    pub const fn new<Impl: IMFSensorDeviceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSensorDeviceVtbl {
        unsafe extern "system" fn GetDeviceId<Impl: IMFSensorDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdeviceid: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDeviceId(::core::mem::transmute_copy(&pdeviceid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDeviceType<Impl: IMFSensorDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptype: *mut MFSensorDeviceType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDeviceType(::core::mem::transmute_copy(&ptype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFlags<Impl: IMFSensorDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pflags: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFlags(::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSymbolicLink<Impl: IMFSensorDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, symboliclink: super::super::Foundation::PWSTR, cchsymboliclink: i32, pcchwritten: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSymbolicLink(::core::mem::transmute_copy(&symboliclink), cchsymboliclink, ::core::mem::transmute_copy(&pcchwritten)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDeviceAttributes<Impl: IMFSensorDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppattributes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDeviceAttributes(::core::mem::transmute_copy(&ppattributes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamAttributesCount<Impl: IMFSensorDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, etype: MFSensorStreamType, pdwcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamAttributesCount(etype, ::core::mem::transmute_copy(&pdwcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamAttributes<Impl: IMFSensorDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, etype: MFSensorStreamType, dwindex: u32, ppattributes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamAttributes(etype, dwindex, ::core::mem::transmute_copy(&ppattributes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSensorDeviceMode<Impl: IMFSensorDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, emode: MFSensorDeviceMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSensorDeviceMode(emode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSensorDeviceMode<Impl: IMFSensorDeviceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pemode: *mut MFSensorDeviceMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSensorDeviceMode(::core::mem::transmute_copy(&pemode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSensorDevice>, base.5, GetDeviceId::<Impl, OFFSET>, GetDeviceType::<Impl, OFFSET>, GetFlags::<Impl, OFFSET>, GetSymbolicLink::<Impl, OFFSET>, GetDeviceAttributes::<Impl, OFFSET>, GetStreamAttributesCount::<Impl, OFFSET>, GetStreamAttributes::<Impl, OFFSET>, SetSensorDeviceMode::<Impl, OFFSET>, GetSensorDeviceMode::<Impl, OFFSET>)
    }
}
pub trait IMFSensorGroupImpl: Sized {
    fn GetSymbolicLink();
    fn GetFlags();
    fn GetSensorGroupAttributes();
    fn GetSensorDeviceCount();
    fn GetSensorDevice();
    fn SetDefaultSensorDeviceIndex();
    fn GetDefaultSensorDeviceIndex();
    fn CreateMediaSource();
}
impl ::windows::core::RuntimeName for IMFSensorGroup {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSensorGroup";
}
impl IMFSensorGroupVtbl {
    pub const fn new<Impl: IMFSensorGroupImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSensorGroupVtbl {
        unsafe extern "system" fn GetSymbolicLink<Impl: IMFSensorGroupImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, symboliclink: super::super::Foundation::PWSTR, cchsymboliclink: i32, pcchwritten: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSymbolicLink(::core::mem::transmute_copy(&symboliclink), cchsymboliclink, ::core::mem::transmute_copy(&pcchwritten)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFlags<Impl: IMFSensorGroupImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pflags: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFlags(::core::mem::transmute_copy(&pflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSensorGroupAttributes<Impl: IMFSensorGroupImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppattributes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSensorGroupAttributes(::core::mem::transmute_copy(&ppattributes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSensorDeviceCount<Impl: IMFSensorGroupImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSensorDeviceCount(::core::mem::transmute_copy(&pdwcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSensorDevice<Impl: IMFSensorGroupImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdevice: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSensorDevice(dwindex, ::core::mem::transmute_copy(&ppdevice)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultSensorDeviceIndex<Impl: IMFSensorGroupImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDefaultSensorDeviceIndex(dwindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDefaultSensorDeviceIndex<Impl: IMFSensorGroupImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwindex: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDefaultSensorDeviceIndex(::core::mem::transmute_copy(&pdwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateMediaSource<Impl: IMFSensorGroupImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppsource: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateMediaSource(::core::mem::transmute_copy(&ppsource)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSensorGroup>, base.5, GetSymbolicLink::<Impl, OFFSET>, GetFlags::<Impl, OFFSET>, GetSensorGroupAttributes::<Impl, OFFSET>, GetSensorDeviceCount::<Impl, OFFSET>, GetSensorDevice::<Impl, OFFSET>, SetDefaultSensorDeviceIndex::<Impl, OFFSET>, GetDefaultSensorDeviceIndex::<Impl, OFFSET>, CreateMediaSource::<Impl, OFFSET>)
    }
}
pub trait IMFSensorProcessActivityImpl: Sized {
    fn GetProcessId();
    fn GetStreamingState();
    fn GetStreamingMode();
    fn GetReportTime();
}
impl ::windows::core::RuntimeName for IMFSensorProcessActivity {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSensorProcessActivity";
}
impl IMFSensorProcessActivityVtbl {
    pub const fn new<Impl: IMFSensorProcessActivityImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSensorProcessActivityVtbl {
        unsafe extern "system" fn GetProcessId<Impl: IMFSensorProcessActivityImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProcessId(::core::mem::transmute_copy(&ppid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamingState<Impl: IMFSensorProcessActivityImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfstreaming: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamingState(::core::mem::transmute_copy(&pfstreaming)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamingMode<Impl: IMFSensorProcessActivityImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmode: *mut MFSensorDeviceMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamingMode(::core::mem::transmute_copy(&pmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetReportTime<Impl: IMFSensorProcessActivityImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pft: *mut super::super::Foundation::FILETIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetReportTime(::core::mem::transmute_copy(&pft)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSensorProcessActivity>, base.5, GetProcessId::<Impl, OFFSET>, GetStreamingState::<Impl, OFFSET>, GetStreamingMode::<Impl, OFFSET>, GetReportTime::<Impl, OFFSET>)
    }
}
pub trait IMFSensorProfileImpl: Sized {
    fn GetProfileId();
    fn AddProfileFilter();
    fn IsMediaTypeSupported();
    fn AddBlockedControl();
}
impl ::windows::core::RuntimeName for IMFSensorProfile {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSensorProfile";
}
impl IMFSensorProfileVtbl {
    pub const fn new<Impl: IMFSensorProfileImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSensorProfileVtbl {
        unsafe extern "system" fn GetProfileId<Impl: IMFSensorProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pid: *mut SENSORPROFILEID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProfileId(::core::mem::transmute_copy(&pid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddProfileFilter<Impl: IMFSensorProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, streamid: u32, wzfiltersetstring: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddProfileFilter(streamid, &*(&wzfiltersetstring as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsMediaTypeSupported<Impl: IMFSensorProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, streamid: u32, pmediatype: ::windows::core::RawPtr, pfsupported: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsMediaTypeSupported(streamid, &*(&pmediatype as *const <IMFMediaType as ::windows::core::Abi>::Abi as *const <IMFMediaType as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pfsupported)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddBlockedControl<Impl: IMFSensorProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wzblockedcontrol: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddBlockedControl(&*(&wzblockedcontrol as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSensorProfile>, base.5, GetProfileId::<Impl, OFFSET>, AddProfileFilter::<Impl, OFFSET>, IsMediaTypeSupported::<Impl, OFFSET>, AddBlockedControl::<Impl, OFFSET>)
    }
}
pub trait IMFSensorProfileCollectionImpl: Sized {
    fn GetProfileCount();
    fn GetProfile();
    fn AddProfile();
    fn FindProfile();
    fn RemoveProfileByIndex();
    fn RemoveProfile();
}
impl ::windows::core::RuntimeName for IMFSensorProfileCollection {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSensorProfileCollection";
}
impl IMFSensorProfileCollectionVtbl {
    pub const fn new<Impl: IMFSensorProfileCollectionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSensorProfileCollectionVtbl {
        unsafe extern "system" fn GetProfileCount<Impl: IMFSensorProfileCollectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProfileCount() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProfile<Impl: IMFSensorProfileCollectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: u32, ppprofile: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProfile(index, ::core::mem::transmute_copy(&ppprofile)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddProfile<Impl: IMFSensorProfileCollectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pprofile: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddProfile(&*(&pprofile as *const <IMFSensorProfile as ::windows::core::Abi>::Abi as *const <IMFSensorProfile as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FindProfile<Impl: IMFSensorProfileCollectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, profileid: *const SENSORPROFILEID, ppprofile: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FindProfile(&*(&profileid as *const <SENSORPROFILEID as ::windows::core::Abi>::Abi as *const <SENSORPROFILEID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppprofile)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveProfileByIndex<Impl: IMFSensorProfileCollectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: u32) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveProfileByIndex(index).into()
        }
        unsafe extern "system" fn RemoveProfile<Impl: IMFSensorProfileCollectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, profileid: *const SENSORPROFILEID) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).RemoveProfile(&*(&profileid as *const <SENSORPROFILEID as ::windows::core::Abi>::Abi as *const <SENSORPROFILEID as ::windows::core::DefaultType>::DefaultType)).into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSensorProfileCollection>, base.5, GetProfileCount::<Impl, OFFSET>, GetProfile::<Impl, OFFSET>, AddProfile::<Impl, OFFSET>, FindProfile::<Impl, OFFSET>, RemoveProfileByIndex::<Impl, OFFSET>, RemoveProfile::<Impl, OFFSET>)
    }
}
pub trait IMFSensorStreamImpl: Sized + IMFAttributesImpl {
    fn GetMediaTypeCount();
    fn GetMediaType();
    fn CloneSensorStream();
}
impl ::windows::core::RuntimeName for IMFSensorStream {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSensorStream";
}
impl IMFSensorStreamVtbl {
    pub const fn new<Impl: IMFSensorStreamImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSensorStreamVtbl {
        unsafe extern "system" fn GetMediaTypeCount<Impl: IMFSensorStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMediaTypeCount(::core::mem::transmute_copy(&pdwcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaType<Impl: IMFSensorStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppmediatype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMediaType(dwindex, ::core::mem::transmute_copy(&ppmediatype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CloneSensorStream<Impl: IMFSensorStreamImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppstream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CloneSensorStream(::core::mem::transmute_copy(&ppstream)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSensorStream>, base.5, GetMediaTypeCount::<Impl, OFFSET>, GetMediaType::<Impl, OFFSET>, CloneSensorStream::<Impl, OFFSET>)
    }
}
pub trait IMFSensorTransformFactoryImpl: Sized {
    fn GetFactoryAttributes();
    fn InitializeFactory();
    fn GetTransformCount();
    fn GetTransformInformation();
    fn CreateTransform();
}
impl ::windows::core::RuntimeName for IMFSensorTransformFactory {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSensorTransformFactory";
}
impl IMFSensorTransformFactoryVtbl {
    pub const fn new<Impl: IMFSensorTransformFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSensorTransformFactoryVtbl {
        unsafe extern "system" fn GetFactoryAttributes<Impl: IMFSensorTransformFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppattributes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFactoryAttributes(::core::mem::transmute_copy(&ppattributes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InitializeFactory<Impl: IMFSensorTransformFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwmaxtransformcount: u32, psensordevices: ::windows::core::RawPtr, pattributes: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InitializeFactory(dwmaxtransformcount, &*(&psensordevices as *const <IMFCollection as ::windows::core::Abi>::Abi as *const <IMFCollection as ::windows::core::DefaultType>::DefaultType), &*(&pattributes as *const <IMFAttributes as ::windows::core::Abi>::Abi as *const <IMFAttributes as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransformCount<Impl: IMFSensorTransformFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTransformCount(::core::mem::transmute_copy(&pdwcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransformInformation<Impl: IMFSensorTransformFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, transformindex: u32, pguidtransformid: *mut ::windows::core::GUID, ppattributes: *mut ::windows::core::RawPtr, ppstreaminformation: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTransformInformation(transformindex, ::core::mem::transmute_copy(&pguidtransformid), ::core::mem::transmute_copy(&ppattributes), ::core::mem::transmute_copy(&ppstreaminformation)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateTransform<Impl: IMFSensorTransformFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidsensortransformid: *const ::windows::core::GUID, pattributes: ::windows::core::RawPtr, ppdevicemft: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateTransform(&*(&guidsensortransformid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&pattributes as *const <IMFAttributes as ::windows::core::Abi>::Abi as *const <IMFAttributes as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppdevicemft)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSensorTransformFactory>, base.5, GetFactoryAttributes::<Impl, OFFSET>, InitializeFactory::<Impl, OFFSET>, GetTransformCount::<Impl, OFFSET>, GetTransformInformation::<Impl, OFFSET>, CreateTransform::<Impl, OFFSET>)
    }
}
pub trait IMFSequencerSourceImpl: Sized {
    fn AppendTopology();
    fn DeleteTopology();
    fn GetPresentationContext();
    fn UpdateTopology();
    fn UpdateTopologyFlags();
}
impl ::windows::core::RuntimeName for IMFSequencerSource {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSequencerSource";
}
impl IMFSequencerSourceVtbl {
    pub const fn new<Impl: IMFSequencerSourceImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSequencerSourceVtbl {
        unsafe extern "system" fn AppendTopology<Impl: IMFSequencerSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptopology: ::windows::core::RawPtr, dwflags: u32, pdwid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AppendTopology(&*(&ptopology as *const <IMFTopology as ::windows::core::Abi>::Abi as *const <IMFTopology as ::windows::core::DefaultType>::DefaultType), dwflags, ::core::mem::transmute_copy(&pdwid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DeleteTopology<Impl: IMFSequencerSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DeleteTopology(dwid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPresentationContext<Impl: IMFSequencerSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppd: ::windows::core::RawPtr, pid: *mut u32, pptopology: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPresentationContext(&*(&ppd as *const <IMFPresentationDescriptor as ::windows::core::Abi>::Abi as *const <IMFPresentationDescriptor as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pid), ::core::mem::transmute_copy(&pptopology)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UpdateTopology<Impl: IMFSequencerSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwid: u32, ptopology: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UpdateTopology(dwid, &*(&ptopology as *const <IMFTopology as ::windows::core::Abi>::Abi as *const <IMFTopology as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UpdateTopologyFlags<Impl: IMFSequencerSourceImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwid: u32, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UpdateTopologyFlags(dwid, dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSequencerSource>, base.5, AppendTopology::<Impl, OFFSET>, DeleteTopology::<Impl, OFFSET>, GetPresentationContext::<Impl, OFFSET>, UpdateTopology::<Impl, OFFSET>, UpdateTopologyFlags::<Impl, OFFSET>)
    }
}
pub trait IMFSharingEngineClassFactoryImpl: Sized {
    fn CreateInstance();
}
impl ::windows::core::RuntimeName for IMFSharingEngineClassFactory {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSharingEngineClassFactory";
}
impl IMFSharingEngineClassFactoryVtbl {
    pub const fn new<Impl: IMFSharingEngineClassFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSharingEngineClassFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMFSharingEngineClassFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32, pattr: ::windows::core::RawPtr, ppengine: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(dwflags, &*(&pattr as *const <IMFAttributes as ::windows::core::Abi>::Abi as *const <IMFAttributes as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppengine)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSharingEngineClassFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
pub trait IMFShutdownImpl: Sized {
    fn Shutdown();
    fn GetShutdownStatus();
}
impl ::windows::core::RuntimeName for IMFShutdown {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFShutdown";
}
impl IMFShutdownVtbl {
    pub const fn new<Impl: IMFShutdownImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFShutdownVtbl {
        unsafe extern "system" fn Shutdown<Impl: IMFShutdownImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Shutdown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetShutdownStatus<Impl: IMFShutdownImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstatus: *mut MFSHUTDOWN_STATUS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetShutdownStatus(::core::mem::transmute_copy(&pstatus)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFShutdown>, base.5, Shutdown::<Impl, OFFSET>, GetShutdownStatus::<Impl, OFFSET>)
    }
}
pub trait IMFSignedLibraryImpl: Sized {
    fn GetProcedureAddress();
}
impl ::windows::core::RuntimeName for IMFSignedLibrary {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSignedLibrary";
}
impl IMFSignedLibraryVtbl {
    pub const fn new<Impl: IMFSignedLibraryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSignedLibraryVtbl {
        unsafe extern "system" fn GetProcedureAddress<Impl: IMFSignedLibraryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, name: super::super::Foundation::PSTR, address: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProcedureAddress(&*(&name as *const <super::super::Foundation::PSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&address)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSignedLibrary>, base.5, GetProcedureAddress::<Impl, OFFSET>)
    }
}
pub trait IMFSimpleAudioVolumeImpl: Sized {
    fn SetMasterVolume();
    fn GetMasterVolume();
    fn SetMute();
    fn GetMute();
}
impl ::windows::core::RuntimeName for IMFSimpleAudioVolume {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSimpleAudioVolume";
}
impl IMFSimpleAudioVolumeVtbl {
    pub const fn new<Impl: IMFSimpleAudioVolumeImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSimpleAudioVolumeVtbl {
        unsafe extern "system" fn SetMasterVolume<Impl: IMFSimpleAudioVolumeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, flevel: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMasterVolume(flevel) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMasterVolume<Impl: IMFSimpleAudioVolumeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pflevel: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMasterVolume(::core::mem::transmute_copy(&pflevel)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMute<Impl: IMFSimpleAudioVolumeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bmute: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMute(&*(&bmute as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMute<Impl: IMFSimpleAudioVolumeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbmute: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMute(::core::mem::transmute_copy(&pbmute)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSimpleAudioVolume>, base.5, SetMasterVolume::<Impl, OFFSET>, GetMasterVolume::<Impl, OFFSET>, SetMute::<Impl, OFFSET>, GetMute::<Impl, OFFSET>)
    }
}
pub trait IMFSinkWriterImpl: Sized {
    fn AddStream();
    fn SetInputMediaType();
    fn BeginWriting();
    fn WriteSample();
    fn SendStreamTick();
    fn PlaceMarker();
    fn NotifyEndOfSegment();
    fn Flush();
    fn Finalize();
    fn GetServiceForStream();
    fn GetStatistics();
}
impl ::windows::core::RuntimeName for IMFSinkWriter {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSinkWriter";
}
impl IMFSinkWriterVtbl {
    pub const fn new<Impl: IMFSinkWriterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSinkWriterVtbl {
        unsafe extern "system" fn AddStream<Impl: IMFSinkWriterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptargetmediatype: ::windows::core::RawPtr, pdwstreamindex: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddStream(&*(&ptargetmediatype as *const <IMFMediaType as ::windows::core::Abi>::Abi as *const <IMFMediaType as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pdwstreamindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputMediaType<Impl: IMFSinkWriterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pinputmediatype: ::windows::core::RawPtr, pencodingparameters: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetInputMediaType(dwstreamindex, &*(&pinputmediatype as *const <IMFMediaType as ::windows::core::Abi>::Abi as *const <IMFMediaType as ::windows::core::DefaultType>::DefaultType), &*(&pencodingparameters as *const <IMFAttributes as ::windows::core::Abi>::Abi as *const <IMFAttributes as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginWriting<Impl: IMFSinkWriterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginWriting() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn WriteSample<Impl: IMFSinkWriterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, psample: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).WriteSample(dwstreamindex, &*(&psample as *const <IMFSample as ::windows::core::Abi>::Abi as *const <IMFSample as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SendStreamTick<Impl: IMFSinkWriterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, lltimestamp: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SendStreamTick(dwstreamindex, lltimestamp) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceMarker<Impl: IMFSinkWriterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pvcontext: *const ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceMarker(dwstreamindex, &*(&pvcontext as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn NotifyEndOfSegment<Impl: IMFSinkWriterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NotifyEndOfSegment(dwstreamindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Flush<Impl: IMFSinkWriterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Flush(dwstreamindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Finalize<Impl: IMFSinkWriterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Finalize() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceForStream<Impl: IMFSinkWriterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, guidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetServiceForStream(dwstreamindex, &*(&guidservice as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppvobject)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStatistics<Impl: IMFSinkWriterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pstats: *mut MF_SINK_WRITER_STATISTICS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStatistics(dwstreamindex, ::core::mem::transmute_copy(&pstats)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSinkWriter>, base.5, AddStream::<Impl, OFFSET>, SetInputMediaType::<Impl, OFFSET>, BeginWriting::<Impl, OFFSET>, WriteSample::<Impl, OFFSET>, SendStreamTick::<Impl, OFFSET>, PlaceMarker::<Impl, OFFSET>, NotifyEndOfSegment::<Impl, OFFSET>, Flush::<Impl, OFFSET>, Finalize::<Impl, OFFSET>, GetServiceForStream::<Impl, OFFSET>, GetStatistics::<Impl, OFFSET>)
    }
}
pub trait IMFSinkWriterCallbackImpl: Sized {
    fn OnFinalize();
    fn OnMarker();
}
impl ::windows::core::RuntimeName for IMFSinkWriterCallback {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSinkWriterCallback";
}
impl IMFSinkWriterCallbackVtbl {
    pub const fn new<Impl: IMFSinkWriterCallbackImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSinkWriterCallbackVtbl {
        unsafe extern "system" fn OnFinalize<Impl: IMFSinkWriterCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hrstatus: ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnFinalize(hrstatus) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnMarker<Impl: IMFSinkWriterCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pvcontext: *const ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnMarker(dwstreamindex, &*(&pvcontext as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSinkWriterCallback>, base.5, OnFinalize::<Impl, OFFSET>, OnMarker::<Impl, OFFSET>)
    }
}
pub trait IMFSinkWriterCallback2Impl: Sized + IMFSinkWriterCallbackImpl {
    fn OnTransformChange();
    fn OnStreamError();
}
impl ::windows::core::RuntimeName for IMFSinkWriterCallback2 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSinkWriterCallback2";
}
impl IMFSinkWriterCallback2Vtbl {
    pub const fn new<Impl: IMFSinkWriterCallback2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSinkWriterCallback2Vtbl {
        unsafe extern "system" fn OnTransformChange<Impl: IMFSinkWriterCallback2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnTransformChange() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnStreamError<Impl: IMFSinkWriterCallback2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, hrstatus: ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnStreamError(dwstreamindex, hrstatus) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSinkWriterCallback2>, base.5, OnTransformChange::<Impl, OFFSET>, OnStreamError::<Impl, OFFSET>)
    }
}
pub trait IMFSinkWriterEncoderConfigImpl: Sized {
    fn SetTargetMediaType();
    fn PlaceEncodingParameters();
}
impl ::windows::core::RuntimeName for IMFSinkWriterEncoderConfig {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSinkWriterEncoderConfig";
}
impl IMFSinkWriterEncoderConfigVtbl {
    pub const fn new<Impl: IMFSinkWriterEncoderConfigImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSinkWriterEncoderConfigVtbl {
        unsafe extern "system" fn SetTargetMediaType<Impl: IMFSinkWriterEncoderConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, ptargetmediatype: ::windows::core::RawPtr, pencodingparameters: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTargetMediaType(dwstreamindex, &*(&ptargetmediatype as *const <IMFMediaType as ::windows::core::Abi>::Abi as *const <IMFMediaType as ::windows::core::DefaultType>::DefaultType), &*(&pencodingparameters as *const <IMFAttributes as ::windows::core::Abi>::Abi as *const <IMFAttributes as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceEncodingParameters<Impl: IMFSinkWriterEncoderConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pencodingparameters: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceEncodingParameters(dwstreamindex, &*(&pencodingparameters as *const <IMFAttributes as ::windows::core::Abi>::Abi as *const <IMFAttributes as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSinkWriterEncoderConfig>, base.5, SetTargetMediaType::<Impl, OFFSET>, PlaceEncodingParameters::<Impl, OFFSET>)
    }
}
pub trait IMFSinkWriterExImpl: Sized + IMFSinkWriterImpl {
    fn GetTransformForStream();
}
impl ::windows::core::RuntimeName for IMFSinkWriterEx {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSinkWriterEx";
}
impl IMFSinkWriterExVtbl {
    pub const fn new<Impl: IMFSinkWriterExImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSinkWriterExVtbl {
        unsafe extern "system" fn GetTransformForStream<Impl: IMFSinkWriterExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, dwtransformindex: u32, pguidcategory: *mut ::windows::core::GUID, pptransform: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTransformForStream(dwstreamindex, dwtransformindex, ::core::mem::transmute_copy(&pguidcategory), ::core::mem::transmute_copy(&pptransform)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSinkWriterEx>, base.5, GetTransformForStream::<Impl, OFFSET>)
    }
}
pub trait IMFSourceBufferImpl: Sized {
    fn GetUpdating();
    fn GetBuffered();
    fn GetTimeStampOffset();
    fn SetTimeStampOffset();
    fn GetAppendWindowStart();
    fn SetAppendWindowStart();
    fn GetAppendWindowEnd();
    fn SetAppendWindowEnd();
    fn Append();
    fn AppendByteStream();
    fn Abort();
    fn Remove();
}
impl ::windows::core::RuntimeName for IMFSourceBuffer {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSourceBuffer";
}
impl IMFSourceBufferVtbl {
    pub const fn new<Impl: IMFSourceBufferImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSourceBufferVtbl {
        unsafe extern "system" fn GetUpdating<Impl: IMFSourceBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetUpdating() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBuffered<Impl: IMFSourceBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppbuffered: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBuffered(::core::mem::transmute_copy(&ppbuffered)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTimeStampOffset<Impl: IMFSourceBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTimeStampOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTimeStampOffset<Impl: IMFSourceBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, offset: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTimeStampOffset(offset) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAppendWindowStart<Impl: IMFSourceBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAppendWindowStart() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAppendWindowStart<Impl: IMFSourceBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, time: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAppendWindowStart(time) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAppendWindowEnd<Impl: IMFSourceBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAppendWindowEnd() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAppendWindowEnd<Impl: IMFSourceBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, time: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAppendWindowEnd(time) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Append<Impl: IMFSourceBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdata: *const u8, len: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Append(pdata, len) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AppendByteStream<Impl: IMFSourceBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pstream: ::windows::core::RawPtr, pmaxlen: *const u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AppendByteStream(&*(&pstream as *const <IMFByteStream as ::windows::core::Abi>::Abi as *const <IMFByteStream as ::windows::core::DefaultType>::DefaultType), pmaxlen) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Abort<Impl: IMFSourceBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Abort() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Remove<Impl: IMFSourceBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, start: f64, end: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Remove(start, end) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSourceBuffer>, base.5, GetUpdating::<Impl, OFFSET>, GetBuffered::<Impl, OFFSET>, GetTimeStampOffset::<Impl, OFFSET>, SetTimeStampOffset::<Impl, OFFSET>, GetAppendWindowStart::<Impl, OFFSET>, SetAppendWindowStart::<Impl, OFFSET>, GetAppendWindowEnd::<Impl, OFFSET>, SetAppendWindowEnd::<Impl, OFFSET>, Append::<Impl, OFFSET>, AppendByteStream::<Impl, OFFSET>, Abort::<Impl, OFFSET>, Remove::<Impl, OFFSET>)
    }
}
pub trait IMFSourceBufferAppendModeImpl: Sized {
    fn GetAppendMode();
    fn SetAppendMode();
}
impl ::windows::core::RuntimeName for IMFSourceBufferAppendMode {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSourceBufferAppendMode";
}
impl IMFSourceBufferAppendModeVtbl {
    pub const fn new<Impl: IMFSourceBufferAppendModeImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSourceBufferAppendModeVtbl {
        unsafe extern "system" fn GetAppendMode<Impl: IMFSourceBufferAppendModeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> MF_MSE_APPEND_MODE {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAppendMode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAppendMode<Impl: IMFSourceBufferAppendModeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, mode: MF_MSE_APPEND_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAppendMode(mode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSourceBufferAppendMode>, base.5, GetAppendMode::<Impl, OFFSET>, SetAppendMode::<Impl, OFFSET>)
    }
}
pub trait IMFSourceBufferListImpl: Sized {
    fn GetLength();
    fn GetSourceBuffer();
}
impl ::windows::core::RuntimeName for IMFSourceBufferList {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSourceBufferList";
}
impl IMFSourceBufferListVtbl {
    pub const fn new<Impl: IMFSourceBufferListImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSourceBufferListVtbl {
        unsafe extern "system" fn GetLength<Impl: IMFSourceBufferListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceBuffer<Impl: IMFSourceBufferListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: u32) -> ::core::option::Option<IMFSourceBuffer> {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSourceBuffer(index) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSourceBufferList>, base.5, GetLength::<Impl, OFFSET>, GetSourceBuffer::<Impl, OFFSET>)
    }
}
pub trait IMFSourceBufferNotifyImpl: Sized {
    fn OnUpdateStart();
    fn OnAbort();
    fn OnError();
    fn OnUpdate();
    fn OnUpdateEnd();
}
impl ::windows::core::RuntimeName for IMFSourceBufferNotify {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSourceBufferNotify";
}
impl IMFSourceBufferNotifyVtbl {
    pub const fn new<Impl: IMFSourceBufferNotifyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSourceBufferNotifyVtbl {
        unsafe extern "system" fn OnUpdateStart<Impl: IMFSourceBufferNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnUpdateStart().into()
        }
        unsafe extern "system" fn OnAbort<Impl: IMFSourceBufferNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnAbort().into()
        }
        unsafe extern "system" fn OnError<Impl: IMFSourceBufferNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hr: ::windows::core::HRESULT) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnError(hr).into()
        }
        unsafe extern "system" fn OnUpdate<Impl: IMFSourceBufferNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnUpdate().into()
        }
        unsafe extern "system" fn OnUpdateEnd<Impl: IMFSourceBufferNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).OnUpdateEnd().into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSourceBufferNotify>, base.5, OnUpdateStart::<Impl, OFFSET>, OnAbort::<Impl, OFFSET>, OnError::<Impl, OFFSET>, OnUpdate::<Impl, OFFSET>, OnUpdateEnd::<Impl, OFFSET>)
    }
}
pub trait IMFSourceOpenMonitorImpl: Sized {
    fn OnSourceEvent();
}
impl ::windows::core::RuntimeName for IMFSourceOpenMonitor {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSourceOpenMonitor";
}
impl IMFSourceOpenMonitorVtbl {
    pub const fn new<Impl: IMFSourceOpenMonitorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSourceOpenMonitorVtbl {
        unsafe extern "system" fn OnSourceEvent<Impl: IMFSourceOpenMonitorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pevent: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnSourceEvent(&*(&pevent as *const <IMFMediaEvent as ::windows::core::Abi>::Abi as *const <IMFMediaEvent as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSourceOpenMonitor>, base.5, OnSourceEvent::<Impl, OFFSET>)
    }
}
pub trait IMFSourceReaderImpl: Sized {
    fn GetStreamSelection();
    fn SetStreamSelection();
    fn GetNativeMediaType();
    fn GetCurrentMediaType();
    fn SetCurrentMediaType();
    fn SetCurrentPosition();
    fn ReadSample();
    fn Flush();
    fn GetServiceForStream();
    fn GetPresentationAttribute();
}
impl ::windows::core::RuntimeName for IMFSourceReader {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSourceReader";
}
impl IMFSourceReaderVtbl {
    pub const fn new<Impl: IMFSourceReaderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSourceReaderVtbl {
        unsafe extern "system" fn GetStreamSelection<Impl: IMFSourceReaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pfselected: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamSelection(dwstreamindex, ::core::mem::transmute_copy(&pfselected)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamSelection<Impl: IMFSourceReaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, fselected: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStreamSelection(dwstreamindex, &*(&fselected as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNativeMediaType<Impl: IMFSourceReaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, dwmediatypeindex: u32, ppmediatype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNativeMediaType(dwstreamindex, dwmediatypeindex, ::core::mem::transmute_copy(&ppmediatype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentMediaType<Impl: IMFSourceReaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, ppmediatype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentMediaType(dwstreamindex, ::core::mem::transmute_copy(&ppmediatype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentMediaType<Impl: IMFSourceReaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pdwreserved: *mut u32, pmediatype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCurrentMediaType(dwstreamindex, pdwreserved, &*(&pmediatype as *const <IMFMediaType as ::windows::core::Abi>::Abi as *const <IMFMediaType as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentPosition<Impl: IMFSourceReaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidtimeformat: *const ::windows::core::GUID, varposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCurrentPosition(&*(&guidtimeformat as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&varposition as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReadSample<Impl: IMFSourceReaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, dwcontrolflags: u32, pdwactualstreamindex: *mut u32, pdwstreamflags: *mut u32, plltimestamp: *mut i64, ppsample: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReadSample(dwstreamindex, dwcontrolflags, ::core::mem::transmute_copy(&pdwactualstreamindex), ::core::mem::transmute_copy(&pdwstreamflags), ::core::mem::transmute_copy(&plltimestamp), ::core::mem::transmute_copy(&ppsample)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Flush<Impl: IMFSourceReaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Flush(dwstreamindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetServiceForStream<Impl: IMFSourceReaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, guidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetServiceForStream(dwstreamindex, &*(&guidservice as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppvobject)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPresentationAttribute<Impl: IMFSourceReaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, guidattribute: *const ::windows::core::GUID, pvarattribute: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPresentationAttribute(dwstreamindex, &*(&guidattribute as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pvarattribute)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSourceReader>, base.5, GetStreamSelection::<Impl, OFFSET>, SetStreamSelection::<Impl, OFFSET>, GetNativeMediaType::<Impl, OFFSET>, GetCurrentMediaType::<Impl, OFFSET>, SetCurrentMediaType::<Impl, OFFSET>, SetCurrentPosition::<Impl, OFFSET>, ReadSample::<Impl, OFFSET>, Flush::<Impl, OFFSET>, GetServiceForStream::<Impl, OFFSET>, GetPresentationAttribute::<Impl, OFFSET>)
    }
}
pub trait IMFSourceReaderCallbackImpl: Sized {
    fn OnReadSample();
    fn OnFlush();
    fn OnEvent();
}
impl ::windows::core::RuntimeName for IMFSourceReaderCallback {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSourceReaderCallback";
}
impl IMFSourceReaderCallbackVtbl {
    pub const fn new<Impl: IMFSourceReaderCallbackImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSourceReaderCallbackVtbl {
        unsafe extern "system" fn OnReadSample<Impl: IMFSourceReaderCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hrstatus: ::windows::core::HRESULT, dwstreamindex: u32, dwstreamflags: u32, lltimestamp: i64, psample: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnReadSample(hrstatus, dwstreamindex, dwstreamflags, lltimestamp, &*(&psample as *const <IMFSample as ::windows::core::Abi>::Abi as *const <IMFSample as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnFlush<Impl: IMFSourceReaderCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnFlush(dwstreamindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnEvent<Impl: IMFSourceReaderCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pevent: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnEvent(dwstreamindex, &*(&pevent as *const <IMFMediaEvent as ::windows::core::Abi>::Abi as *const <IMFMediaEvent as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSourceReaderCallback>, base.5, OnReadSample::<Impl, OFFSET>, OnFlush::<Impl, OFFSET>, OnEvent::<Impl, OFFSET>)
    }
}
pub trait IMFSourceReaderCallback2Impl: Sized + IMFSourceReaderCallbackImpl {
    fn OnTransformChange();
    fn OnStreamError();
}
impl ::windows::core::RuntimeName for IMFSourceReaderCallback2 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSourceReaderCallback2";
}
impl IMFSourceReaderCallback2Vtbl {
    pub const fn new<Impl: IMFSourceReaderCallback2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSourceReaderCallback2Vtbl {
        unsafe extern "system" fn OnTransformChange<Impl: IMFSourceReaderCallback2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnTransformChange() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnStreamError<Impl: IMFSourceReaderCallback2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, hrstatus: ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnStreamError(dwstreamindex, hrstatus) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSourceReaderCallback2>, base.5, OnTransformChange::<Impl, OFFSET>, OnStreamError::<Impl, OFFSET>)
    }
}
pub trait IMFSourceReaderExImpl: Sized + IMFSourceReaderImpl {
    fn SetNativeMediaType();
    fn AddTransformForStream();
    fn RemoveAllTransformsForStream();
    fn GetTransformForStream();
}
impl ::windows::core::RuntimeName for IMFSourceReaderEx {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSourceReaderEx";
}
impl IMFSourceReaderExVtbl {
    pub const fn new<Impl: IMFSourceReaderExImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSourceReaderExVtbl {
        unsafe extern "system" fn SetNativeMediaType<Impl: IMFSourceReaderExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pmediatype: ::windows::core::RawPtr, pdwstreamflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetNativeMediaType(dwstreamindex, &*(&pmediatype as *const <IMFMediaType as ::windows::core::Abi>::Abi as *const <IMFMediaType as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pdwstreamflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddTransformForStream<Impl: IMFSourceReaderExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, ptransformoractivate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddTransformForStream(dwstreamindex, &*(&ptransformoractivate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveAllTransformsForStream<Impl: IMFSourceReaderExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveAllTransformsForStream(dwstreamindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransformForStream<Impl: IMFSourceReaderExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, dwtransformindex: u32, pguidcategory: *mut ::windows::core::GUID, pptransform: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTransformForStream(dwstreamindex, dwtransformindex, ::core::mem::transmute_copy(&pguidcategory), ::core::mem::transmute_copy(&pptransform)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSourceReaderEx>, base.5, SetNativeMediaType::<Impl, OFFSET>, AddTransformForStream::<Impl, OFFSET>, RemoveAllTransformsForStream::<Impl, OFFSET>, GetTransformForStream::<Impl, OFFSET>)
    }
}
pub trait IMFSourceResolverImpl: Sized {
    fn CreateObjectFromURL();
    fn CreateObjectFromByteStream();
    fn BeginCreateObjectFromURL();
    fn EndCreateObjectFromURL();
    fn BeginCreateObjectFromByteStream();
    fn EndCreateObjectFromByteStream();
    fn CancelObjectCreation();
}
impl ::windows::core::RuntimeName for IMFSourceResolver {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSourceResolver";
}
impl IMFSourceResolverVtbl {
    pub const fn new<Impl: IMFSourceResolverImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSourceResolverVtbl {
        unsafe extern "system" fn CreateObjectFromURL<Impl: IMFSourceResolverImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwszurl: super::super::Foundation::PWSTR, dwflags: u32, pprops: ::windows::core::RawPtr, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateObjectFromURL(
                &*(&pwszurl as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                dwflags,
                &*(&pprops as *const <super::super::UI::Shell::PropertiesSystem::IPropertyStore as ::windows::core::Abi>::Abi as *const <super::super::UI::Shell::PropertiesSystem::IPropertyStore as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&pobjecttype),
                ::core::mem::transmute_copy(&ppobject),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateObjectFromByteStream<Impl: IMFSourceResolverImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbytestream: ::windows::core::RawPtr, pwszurl: super::super::Foundation::PWSTR, dwflags: u32, pprops: ::windows::core::RawPtr, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateObjectFromByteStream(
                &*(&pbytestream as *const <IMFByteStream as ::windows::core::Abi>::Abi as *const <IMFByteStream as ::windows::core::DefaultType>::DefaultType),
                &*(&pwszurl as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                dwflags,
                &*(&pprops as *const <super::super::UI::Shell::PropertiesSystem::IPropertyStore as ::windows::core::Abi>::Abi as *const <super::super::UI::Shell::PropertiesSystem::IPropertyStore as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&pobjecttype),
                ::core::mem::transmute_copy(&ppobject),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginCreateObjectFromURL<Impl: IMFSourceResolverImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwszurl: super::super::Foundation::PWSTR, dwflags: u32, pprops: ::windows::core::RawPtr, ppiunknowncancelcookie: *mut *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginCreateObjectFromURL(
                &*(&pwszurl as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                dwflags,
                &*(&pprops as *const <super::super::UI::Shell::PropertiesSystem::IPropertyStore as ::windows::core::Abi>::Abi as *const <super::super::UI::Shell::PropertiesSystem::IPropertyStore as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&ppiunknowncancelcookie),
                &*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType),
                &*(&punkstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndCreateObjectFromURL<Impl: IMFSourceResolverImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndCreateObjectFromURL(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pobjecttype), ::core::mem::transmute_copy(&ppobject)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginCreateObjectFromByteStream<Impl: IMFSourceResolverImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbytestream: ::windows::core::RawPtr, pwszurl: super::super::Foundation::PWSTR, dwflags: u32, pprops: ::windows::core::RawPtr, ppiunknowncancelcookie: *mut *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginCreateObjectFromByteStream(
                &*(&pbytestream as *const <IMFByteStream as ::windows::core::Abi>::Abi as *const <IMFByteStream as ::windows::core::DefaultType>::DefaultType),
                &*(&pwszurl as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                dwflags,
                &*(&pprops as *const <super::super::UI::Shell::PropertiesSystem::IPropertyStore as ::windows::core::Abi>::Abi as *const <super::super::UI::Shell::PropertiesSystem::IPropertyStore as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&ppiunknowncancelcookie),
                &*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType),
                &*(&punkstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndCreateObjectFromByteStream<Impl: IMFSourceResolverImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndCreateObjectFromByteStream(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pobjecttype), ::core::mem::transmute_copy(&ppobject)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CancelObjectCreation<Impl: IMFSourceResolverImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, piunknowncancelcookie: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CancelObjectCreation(&*(&piunknowncancelcookie as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSourceResolver>, base.5, CreateObjectFromURL::<Impl, OFFSET>, CreateObjectFromByteStream::<Impl, OFFSET>, BeginCreateObjectFromURL::<Impl, OFFSET>, EndCreateObjectFromURL::<Impl, OFFSET>, BeginCreateObjectFromByteStream::<Impl, OFFSET>, EndCreateObjectFromByteStream::<Impl, OFFSET>, CancelObjectCreation::<Impl, OFFSET>)
    }
}
pub trait IMFSpatialAudioObjectBufferImpl: Sized + IMFMediaBufferImpl {
    fn SetID();
    fn GetID();
    fn SetType();
    fn GetType();
    fn GetMetadataItems();
}
impl ::windows::core::RuntimeName for IMFSpatialAudioObjectBuffer {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSpatialAudioObjectBuffer";
}
impl IMFSpatialAudioObjectBufferVtbl {
    pub const fn new<Impl: IMFSpatialAudioObjectBufferImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSpatialAudioObjectBufferVtbl {
        unsafe extern "system" fn SetID<Impl: IMFSpatialAudioObjectBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, u32id: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetID(u32id) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetID<Impl: IMFSpatialAudioObjectBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pu32id: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetID(::core::mem::transmute_copy(&pu32id)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetType<Impl: IMFSpatialAudioObjectBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, r#type: super::Audio::AudioObjectType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetType(r#type) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetType<Impl: IMFSpatialAudioObjectBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptype: *mut super::Audio::AudioObjectType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetType(::core::mem::transmute_copy(&ptype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMetadataItems<Impl: IMFSpatialAudioObjectBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppmetadataitems: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMetadataItems(::core::mem::transmute_copy(&ppmetadataitems)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSpatialAudioObjectBuffer>, base.5, SetID::<Impl, OFFSET>, GetID::<Impl, OFFSET>, SetType::<Impl, OFFSET>, GetType::<Impl, OFFSET>, GetMetadataItems::<Impl, OFFSET>)
    }
}
pub trait IMFSpatialAudioSampleImpl: Sized + IMFSampleImpl + IMFAttributesImpl {
    fn GetObjectCount();
    fn AddSpatialAudioObject();
    fn GetSpatialAudioObjectByIndex();
}
impl ::windows::core::RuntimeName for IMFSpatialAudioSample {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSpatialAudioSample";
}
impl IMFSpatialAudioSampleVtbl {
    pub const fn new<Impl: IMFSpatialAudioSampleImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSpatialAudioSampleVtbl {
        unsafe extern "system" fn GetObjectCount<Impl: IMFSpatialAudioSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwobjectcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetObjectCount(::core::mem::transmute_copy(&pdwobjectcount)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddSpatialAudioObject<Impl: IMFSpatialAudioSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, paudioobjbuffer: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddSpatialAudioObject(&*(&paudioobjbuffer as *const <IMFSpatialAudioObjectBuffer as ::windows::core::Abi>::Abi as *const <IMFSpatialAudioObjectBuffer as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSpatialAudioObjectByIndex<Impl: IMFSpatialAudioSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppaudioobjbuffer: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSpatialAudioObjectByIndex(dwindex, ::core::mem::transmute_copy(&ppaudioobjbuffer)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSpatialAudioSample>, base.5, GetObjectCount::<Impl, OFFSET>, AddSpatialAudioObject::<Impl, OFFSET>, GetSpatialAudioObjectByIndex::<Impl, OFFSET>)
    }
}
pub trait IMFStreamDescriptorImpl: Sized + IMFAttributesImpl {
    fn GetStreamIdentifier();
    fn GetMediaTypeHandler();
}
impl ::windows::core::RuntimeName for IMFStreamDescriptor {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFStreamDescriptor";
}
impl IMFStreamDescriptorVtbl {
    pub const fn new<Impl: IMFStreamDescriptorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFStreamDescriptorVtbl {
        unsafe extern "system" fn GetStreamIdentifier<Impl: IMFStreamDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwstreamidentifier: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamIdentifier(::core::mem::transmute_copy(&pdwstreamidentifier)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaTypeHandler<Impl: IMFStreamDescriptorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppmediatypehandler: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMediaTypeHandler(::core::mem::transmute_copy(&ppmediatypehandler)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFStreamDescriptor>, base.5, GetStreamIdentifier::<Impl, OFFSET>, GetMediaTypeHandler::<Impl, OFFSET>)
    }
}
pub trait IMFStreamSinkImpl: Sized + IMFMediaEventGeneratorImpl {
    fn GetMediaSink();
    fn GetIdentifier();
    fn GetMediaTypeHandler();
    fn ProcessSample();
    fn PlaceMarker();
    fn Flush();
}
impl ::windows::core::RuntimeName for IMFStreamSink {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFStreamSink";
}
impl IMFStreamSinkVtbl {
    pub const fn new<Impl: IMFStreamSinkImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFStreamSinkVtbl {
        unsafe extern "system" fn GetMediaSink<Impl: IMFStreamSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppmediasink: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMediaSink(::core::mem::transmute_copy(&ppmediasink)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIdentifier<Impl: IMFStreamSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwidentifier: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIdentifier(::core::mem::transmute_copy(&pdwidentifier)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaTypeHandler<Impl: IMFStreamSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pphandler: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMediaTypeHandler(::core::mem::transmute_copy(&pphandler)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProcessSample<Impl: IMFStreamSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psample: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProcessSample(&*(&psample as *const <IMFSample as ::windows::core::Abi>::Abi as *const <IMFSample as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn PlaceMarker<Impl: IMFStreamSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, emarkertype: MFSTREAMSINK_MARKER_TYPE, pvarmarkervalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pvarcontextvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).PlaceMarker(
                emarkertype,
                &*(&pvarmarkervalue as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::DefaultType>::DefaultType),
                &*(&pvarcontextvalue as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Flush<Impl: IMFStreamSinkImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Flush() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFStreamSink>, base.5, GetMediaSink::<Impl, OFFSET>, GetIdentifier::<Impl, OFFSET>, GetMediaTypeHandler::<Impl, OFFSET>, ProcessSample::<Impl, OFFSET>, PlaceMarker::<Impl, OFFSET>, Flush::<Impl, OFFSET>)
    }
}
pub trait IMFStreamingSinkConfigImpl: Sized {
    fn StartStreaming();
}
impl ::windows::core::RuntimeName for IMFStreamingSinkConfig {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFStreamingSinkConfig";
}
impl IMFStreamingSinkConfigVtbl {
    pub const fn new<Impl: IMFStreamingSinkConfigImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFStreamingSinkConfigVtbl {
        unsafe extern "system" fn StartStreaming<Impl: IMFStreamingSinkConfigImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fseekoffsetisbyteoffset: super::super::Foundation::BOOL, qwseekoffset: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StartStreaming(&*(&fseekoffsetisbyteoffset as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType), qwseekoffset) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFStreamingSinkConfig>, base.5, StartStreaming::<Impl, OFFSET>)
    }
}
pub trait IMFSystemIdImpl: Sized {
    fn GetData();
    fn Setup();
}
impl ::windows::core::RuntimeName for IMFSystemId {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFSystemId";
}
impl IMFSystemIdVtbl {
    pub const fn new<Impl: IMFSystemIdImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFSystemIdVtbl {
        unsafe extern "system" fn GetData<Impl: IMFSystemIdImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, size: *mut u32, data: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetData(::core::mem::transmute_copy(&size), ::core::mem::transmute_copy(&data)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Setup<Impl: IMFSystemIdImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, stage: u32, cbin: u32, pbin: *const u8, pcbout: *mut u32, ppbout: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Setup(stage, cbin, pbin, ::core::mem::transmute_copy(&pcbout), ::core::mem::transmute_copy(&ppbout)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFSystemId>, base.5, GetData::<Impl, OFFSET>, Setup::<Impl, OFFSET>)
    }
}
pub trait IMFTimecodeTranslateImpl: Sized {
    fn BeginConvertTimecodeToHNS();
    fn EndConvertTimecodeToHNS();
    fn BeginConvertHNSToTimecode();
    fn EndConvertHNSToTimecode();
}
impl ::windows::core::RuntimeName for IMFTimecodeTranslate {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTimecodeTranslate";
}
impl IMFTimecodeTranslateVtbl {
    pub const fn new<Impl: IMFTimecodeTranslateImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTimecodeTranslateVtbl {
        unsafe extern "system" fn BeginConvertTimecodeToHNS<Impl: IMFTimecodeTranslateImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppropvartimecode: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginConvertTimecodeToHNS(
                &*(&ppropvartimecode as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::Abi>::Abi as *const <super::super::System::Com::StructuredStorage::PROPVARIANT as ::windows::core::DefaultType>::DefaultType),
                &*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType),
                &*(&punkstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndConvertTimecodeToHNS<Impl: IMFTimecodeTranslateImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, phnstime: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndConvertTimecodeToHNS(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&phnstime)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginConvertHNSToTimecode<Impl: IMFTimecodeTranslateImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnstime: i64, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginConvertHNSToTimecode(hnstime, &*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType), &*(&punkstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndConvertHNSToTimecode<Impl: IMFTimecodeTranslateImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, ppropvartimecode: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndConvertHNSToTimecode(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppropvartimecode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFTimecodeTranslate>, base.5, BeginConvertTimecodeToHNS::<Impl, OFFSET>, EndConvertTimecodeToHNS::<Impl, OFFSET>, BeginConvertHNSToTimecode::<Impl, OFFSET>, EndConvertHNSToTimecode::<Impl, OFFSET>)
    }
}
pub trait IMFTimedTextImpl: Sized {
    fn RegisterNotifications();
    fn SelectTrack();
    fn AddDataSource();
    fn AddDataSourceFromUrl();
    fn AddTrack();
    fn RemoveTrack();
    fn GetCueTimeOffset();
    fn SetCueTimeOffset();
    fn GetTracks();
    fn GetActiveTracks();
    fn GetTextTracks();
    fn GetMetadataTracks();
    fn SetInBandEnabled();
    fn IsInBandEnabled();
}
impl ::windows::core::RuntimeName for IMFTimedText {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTimedText";
}
impl IMFTimedTextVtbl {
    pub const fn new<Impl: IMFTimedTextImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTimedTextVtbl {
        unsafe extern "system" fn RegisterNotifications<Impl: IMFTimedTextImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, notify: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RegisterNotifications(&*(&notify as *const <IMFTimedTextNotify as ::windows::core::Abi>::Abi as *const <IMFTimedTextNotify as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectTrack<Impl: IMFTimedTextImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, trackid: u32, selected: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SelectTrack(trackid, &*(&selected as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddDataSource<Impl: IMFTimedTextImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bytestream: ::windows::core::RawPtr, label: super::super::Foundation::PWSTR, language: super::super::Foundation::PWSTR, kind: MF_TIMED_TEXT_TRACK_KIND, isdefault: super::super::Foundation::BOOL, trackid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddDataSource(
                &*(&bytestream as *const <IMFByteStream as ::windows::core::Abi>::Abi as *const <IMFByteStream as ::windows::core::DefaultType>::DefaultType),
                &*(&label as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&language as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                kind,
                &*(&isdefault as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&trackid),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddDataSourceFromUrl<Impl: IMFTimedTextImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, url: super::super::Foundation::PWSTR, label: super::super::Foundation::PWSTR, language: super::super::Foundation::PWSTR, kind: MF_TIMED_TEXT_TRACK_KIND, isdefault: super::super::Foundation::BOOL, trackid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddDataSourceFromUrl(
                &*(&url as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&label as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                &*(&language as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                kind,
                &*(&isdefault as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType),
                ::core::mem::transmute_copy(&trackid),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddTrack<Impl: IMFTimedTextImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, label: super::super::Foundation::PWSTR, language: super::super::Foundation::PWSTR, kind: MF_TIMED_TEXT_TRACK_KIND, track: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddTrack(&*(&label as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), &*(&language as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), kind, ::core::mem::transmute_copy(&track)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTrack<Impl: IMFTimedTextImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, track: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveTrack(&*(&track as *const <IMFTimedTextTrack as ::windows::core::Abi>::Abi as *const <IMFTimedTextTrack as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCueTimeOffset<Impl: IMFTimedTextImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, offset: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCueTimeOffset(::core::mem::transmute_copy(&offset)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCueTimeOffset<Impl: IMFTimedTextImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, offset: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCueTimeOffset(offset) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTracks<Impl: IMFTimedTextImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, tracks: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTracks(::core::mem::transmute_copy(&tracks)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetActiveTracks<Impl: IMFTimedTextImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, activetracks: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetActiveTracks(::core::mem::transmute_copy(&activetracks)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTextTracks<Impl: IMFTimedTextImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, texttracks: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTextTracks(::core::mem::transmute_copy(&texttracks)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMetadataTracks<Impl: IMFTimedTextImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, metadatatracks: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMetadataTracks(::core::mem::transmute_copy(&metadatatracks)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInBandEnabled<Impl: IMFTimedTextImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, enabled: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetInBandEnabled(&*(&enabled as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsInBandEnabled<Impl: IMFTimedTextImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsInBandEnabled() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMFTimedText>,
            base.5,
            RegisterNotifications::<Impl, OFFSET>,
            SelectTrack::<Impl, OFFSET>,
            AddDataSource::<Impl, OFFSET>,
            AddDataSourceFromUrl::<Impl, OFFSET>,
            AddTrack::<Impl, OFFSET>,
            RemoveTrack::<Impl, OFFSET>,
            GetCueTimeOffset::<Impl, OFFSET>,
            SetCueTimeOffset::<Impl, OFFSET>,
            GetTracks::<Impl, OFFSET>,
            GetActiveTracks::<Impl, OFFSET>,
            GetTextTracks::<Impl, OFFSET>,
            GetMetadataTracks::<Impl, OFFSET>,
            SetInBandEnabled::<Impl, OFFSET>,
            IsInBandEnabled::<Impl, OFFSET>,
        )
    }
}
pub trait IMFTimedTextBinaryImpl: Sized {
    fn GetData();
}
impl ::windows::core::RuntimeName for IMFTimedTextBinary {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTimedTextBinary";
}
impl IMFTimedTextBinaryVtbl {
    pub const fn new<Impl: IMFTimedTextBinaryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTimedTextBinaryVtbl {
        unsafe extern "system" fn GetData<Impl: IMFTimedTextBinaryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, data: *mut *mut u8, length: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetData(::core::mem::transmute_copy(&data), ::core::mem::transmute_copy(&length)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFTimedTextBinary>, base.5, GetData::<Impl, OFFSET>)
    }
}
pub trait IMFTimedTextBoutenImpl: Sized {
    fn GetBoutenType();
    fn GetBoutenColor();
    fn GetBoutenPosition();
}
impl ::windows::core::RuntimeName for IMFTimedTextBouten {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTimedTextBouten";
}
impl IMFTimedTextBoutenVtbl {
    pub const fn new<Impl: IMFTimedTextBoutenImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTimedTextBoutenVtbl {
        unsafe extern "system" fn GetBoutenType<Impl: IMFTimedTextBoutenImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut MF_TIMED_TEXT_BOUTEN_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBoutenType(::core::mem::transmute_copy(&value)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBoutenColor<Impl: IMFTimedTextBoutenImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut MFARGB) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBoutenColor(::core::mem::transmute_copy(&value)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBoutenPosition<Impl: IMFTimedTextBoutenImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut MF_TIMED_TEXT_BOUTEN_POSITION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBoutenPosition(::core::mem::transmute_copy(&value)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFTimedTextBouten>, base.5, GetBoutenType::<Impl, OFFSET>, GetBoutenColor::<Impl, OFFSET>, GetBoutenPosition::<Impl, OFFSET>)
    }
}
pub trait IMFTimedTextCueImpl: Sized {
    fn GetId();
    fn GetOriginalId();
    fn GetCueKind();
    fn GetStartTime();
    fn GetDuration();
    fn GetTrackId();
    fn GetData();
    fn GetRegion();
    fn GetStyle();
    fn GetLineCount();
    fn GetLine();
}
impl ::windows::core::RuntimeName for IMFTimedTextCue {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTimedTextCue";
}
impl IMFTimedTextCueVtbl {
    pub const fn new<Impl: IMFTimedTextCueImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTimedTextCueVtbl {
        unsafe extern "system" fn GetId<Impl: IMFTimedTextCueImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetId() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginalId<Impl: IMFTimedTextCueImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, originalid: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOriginalId(::core::mem::transmute_copy(&originalid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCueKind<Impl: IMFTimedTextCueImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> MF_TIMED_TEXT_TRACK_KIND {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCueKind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStartTime<Impl: IMFTimedTextCueImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStartTime() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDuration<Impl: IMFTimedTextCueImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDuration() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTrackId<Impl: IMFTimedTextCueImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTrackId() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetData<Impl: IMFTimedTextCueImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, data: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetData(::core::mem::transmute_copy(&data)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRegion<Impl: IMFTimedTextCueImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, region: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRegion(::core::mem::transmute_copy(&region)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStyle<Impl: IMFTimedTextCueImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, style: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStyle(::core::mem::transmute_copy(&style)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLineCount<Impl: IMFTimedTextCueImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLineCount() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLine<Impl: IMFTimedTextCueImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: u32, line: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLine(index, ::core::mem::transmute_copy(&line)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFTimedTextCue>, base.5, GetId::<Impl, OFFSET>, GetOriginalId::<Impl, OFFSET>, GetCueKind::<Impl, OFFSET>, GetStartTime::<Impl, OFFSET>, GetDuration::<Impl, OFFSET>, GetTrackId::<Impl, OFFSET>, GetData::<Impl, OFFSET>, GetRegion::<Impl, OFFSET>, GetStyle::<Impl, OFFSET>, GetLineCount::<Impl, OFFSET>, GetLine::<Impl, OFFSET>)
    }
}
pub trait IMFTimedTextCueListImpl: Sized {
    fn GetLength();
    fn GetCueByIndex();
    fn GetCueById();
    fn GetCueByOriginalId();
    fn AddTextCue();
    fn AddDataCue();
    fn RemoveCue();
}
impl ::windows::core::RuntimeName for IMFTimedTextCueList {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTimedTextCueList";
}
impl IMFTimedTextCueListVtbl {
    pub const fn new<Impl: IMFTimedTextCueListImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTimedTextCueListVtbl {
        unsafe extern "system" fn GetLength<Impl: IMFTimedTextCueListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCueByIndex<Impl: IMFTimedTextCueListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: u32, cue: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCueByIndex(index, ::core::mem::transmute_copy(&cue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCueById<Impl: IMFTimedTextCueListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, id: u32, cue: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCueById(id, ::core::mem::transmute_copy(&cue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCueByOriginalId<Impl: IMFTimedTextCueListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, originalid: super::super::Foundation::PWSTR, cue: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCueByOriginalId(&*(&originalid as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&cue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddTextCue<Impl: IMFTimedTextCueListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, start: f64, duration: f64, text: super::super::Foundation::PWSTR, cue: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddTextCue(start, duration, &*(&text as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&cue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddDataCue<Impl: IMFTimedTextCueListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, start: f64, duration: f64, data: *const u8, datasize: u32, cue: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddDataCue(start, duration, data, datasize, ::core::mem::transmute_copy(&cue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCue<Impl: IMFTimedTextCueListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cue: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveCue(&*(&cue as *const <IMFTimedTextCue as ::windows::core::Abi>::Abi as *const <IMFTimedTextCue as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFTimedTextCueList>, base.5, GetLength::<Impl, OFFSET>, GetCueByIndex::<Impl, OFFSET>, GetCueById::<Impl, OFFSET>, GetCueByOriginalId::<Impl, OFFSET>, AddTextCue::<Impl, OFFSET>, AddDataCue::<Impl, OFFSET>, RemoveCue::<Impl, OFFSET>)
    }
}
pub trait IMFTimedTextFormattedTextImpl: Sized {
    fn GetText();
    fn GetSubformattingCount();
    fn GetSubformatting();
}
impl ::windows::core::RuntimeName for IMFTimedTextFormattedText {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTimedTextFormattedText";
}
impl IMFTimedTextFormattedTextVtbl {
    pub const fn new<Impl: IMFTimedTextFormattedTextImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTimedTextFormattedTextVtbl {
        unsafe extern "system" fn GetText<Impl: IMFTimedTextFormattedTextImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, text: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetText(::core::mem::transmute_copy(&text)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSubformattingCount<Impl: IMFTimedTextFormattedTextImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSubformattingCount() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSubformatting<Impl: IMFTimedTextFormattedTextImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: u32, firstchar: *mut u32, charlength: *mut u32, style: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSubformatting(index, ::core::mem::transmute_copy(&firstchar), ::core::mem::transmute_copy(&charlength), ::core::mem::transmute_copy(&style)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFTimedTextFormattedText>, base.5, GetText::<Impl, OFFSET>, GetSubformattingCount::<Impl, OFFSET>, GetSubformatting::<Impl, OFFSET>)
    }
}
pub trait IMFTimedTextNotifyImpl: Sized {
    fn TrackAdded();
    fn TrackRemoved();
    fn TrackSelected();
    fn TrackReadyStateChanged();
    fn Error();
    fn Cue();
    fn Reset();
}
impl ::windows::core::RuntimeName for IMFTimedTextNotify {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTimedTextNotify";
}
impl IMFTimedTextNotifyVtbl {
    pub const fn new<Impl: IMFTimedTextNotifyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTimedTextNotifyVtbl {
        unsafe extern "system" fn TrackAdded<Impl: IMFTimedTextNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, trackid: u32) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).TrackAdded(trackid).into()
        }
        unsafe extern "system" fn TrackRemoved<Impl: IMFTimedTextNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, trackid: u32) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).TrackRemoved(trackid).into()
        }
        unsafe extern "system" fn TrackSelected<Impl: IMFTimedTextNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, trackid: u32, selected: super::super::Foundation::BOOL) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).TrackSelected(trackid, &*(&selected as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn TrackReadyStateChanged<Impl: IMFTimedTextNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, trackid: u32) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).TrackReadyStateChanged(trackid).into()
        }
        unsafe extern "system" fn Error<Impl: IMFTimedTextNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, errorcode: MF_TIMED_TEXT_ERROR_CODE, extendederrorcode: ::windows::core::HRESULT, sourcetrackid: u32) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Error(errorcode, extendederrorcode, sourcetrackid).into()
        }
        unsafe extern "system" fn Cue<Impl: IMFTimedTextNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cueevent: MF_TIMED_TEXT_CUE_EVENT, currenttime: f64, cue: ::windows::core::RawPtr) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Cue(cueevent, currenttime, &*(&cue as *const <IMFTimedTextCue as ::windows::core::Abi>::Abi as *const <IMFTimedTextCue as ::windows::core::DefaultType>::DefaultType)).into()
        }
        unsafe extern "system" fn Reset<Impl: IMFTimedTextNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            (*this).Reset().into()
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFTimedTextNotify>, base.5, TrackAdded::<Impl, OFFSET>, TrackRemoved::<Impl, OFFSET>, TrackSelected::<Impl, OFFSET>, TrackReadyStateChanged::<Impl, OFFSET>, Error::<Impl, OFFSET>, Cue::<Impl, OFFSET>, Reset::<Impl, OFFSET>)
    }
}
pub trait IMFTimedTextRegionImpl: Sized {
    fn GetName();
    fn GetPosition();
    fn GetExtent();
    fn GetBackgroundColor();
    fn GetWritingMode();
    fn GetDisplayAlignment();
    fn GetLineHeight();
    fn GetClipOverflow();
    fn GetPadding();
    fn GetWrap();
    fn GetZIndex();
    fn GetScrollMode();
}
impl ::windows::core::RuntimeName for IMFTimedTextRegion {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTimedTextRegion";
}
impl IMFTimedTextRegionVtbl {
    pub const fn new<Impl: IMFTimedTextRegionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTimedTextRegionVtbl {
        unsafe extern "system" fn GetName<Impl: IMFTimedTextRegionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, name: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetName(::core::mem::transmute_copy(&name)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPosition<Impl: IMFTimedTextRegionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, px: *mut f64, py: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPosition(::core::mem::transmute_copy(&px), ::core::mem::transmute_copy(&py), ::core::mem::transmute_copy(&unittype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetExtent<Impl: IMFTimedTextRegionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwidth: *mut f64, pheight: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetExtent(::core::mem::transmute_copy(&pwidth), ::core::mem::transmute_copy(&pheight), ::core::mem::transmute_copy(&unittype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBackgroundColor<Impl: IMFTimedTextRegionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bgcolor: *mut MFARGB) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBackgroundColor(::core::mem::transmute_copy(&bgcolor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetWritingMode<Impl: IMFTimedTextRegionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, writingmode: *mut MF_TIMED_TEXT_WRITING_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetWritingMode(::core::mem::transmute_copy(&writingmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDisplayAlignment<Impl: IMFTimedTextRegionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, displayalign: *mut MF_TIMED_TEXT_DISPLAY_ALIGNMENT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDisplayAlignment(::core::mem::transmute_copy(&displayalign)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLineHeight<Impl: IMFTimedTextRegionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plineheight: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLineHeight(::core::mem::transmute_copy(&plineheight), ::core::mem::transmute_copy(&unittype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetClipOverflow<Impl: IMFTimedTextRegionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clipoverflow: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetClipOverflow(::core::mem::transmute_copy(&clipoverflow)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPadding<Impl: IMFTimedTextRegionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, before: *mut f64, start: *mut f64, after: *mut f64, end: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPadding(::core::mem::transmute_copy(&before), ::core::mem::transmute_copy(&start), ::core::mem::transmute_copy(&after), ::core::mem::transmute_copy(&end), ::core::mem::transmute_copy(&unittype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetWrap<Impl: IMFTimedTextRegionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wrap: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetWrap(::core::mem::transmute_copy(&wrap)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetZIndex<Impl: IMFTimedTextRegionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, zindex: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetZIndex(::core::mem::transmute_copy(&zindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetScrollMode<Impl: IMFTimedTextRegionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, scrollmode: *mut MF_TIMED_TEXT_SCROLL_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetScrollMode(::core::mem::transmute_copy(&scrollmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFTimedTextRegion>, base.5, GetName::<Impl, OFFSET>, GetPosition::<Impl, OFFSET>, GetExtent::<Impl, OFFSET>, GetBackgroundColor::<Impl, OFFSET>, GetWritingMode::<Impl, OFFSET>, GetDisplayAlignment::<Impl, OFFSET>, GetLineHeight::<Impl, OFFSET>, GetClipOverflow::<Impl, OFFSET>, GetPadding::<Impl, OFFSET>, GetWrap::<Impl, OFFSET>, GetZIndex::<Impl, OFFSET>, GetScrollMode::<Impl, OFFSET>)
    }
}
pub trait IMFTimedTextRubyImpl: Sized {
    fn GetRubyText();
    fn GetRubyPosition();
    fn GetRubyAlign();
    fn GetRubyReserve();
}
impl ::windows::core::RuntimeName for IMFTimedTextRuby {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTimedTextRuby";
}
impl IMFTimedTextRubyVtbl {
    pub const fn new<Impl: IMFTimedTextRubyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTimedTextRubyVtbl {
        unsafe extern "system" fn GetRubyText<Impl: IMFTimedTextRubyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, rubytext: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRubyText(::core::mem::transmute_copy(&rubytext)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRubyPosition<Impl: IMFTimedTextRubyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut MF_TIMED_TEXT_RUBY_POSITION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRubyPosition(::core::mem::transmute_copy(&value)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRubyAlign<Impl: IMFTimedTextRubyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut MF_TIMED_TEXT_RUBY_ALIGN) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRubyAlign(::core::mem::transmute_copy(&value)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRubyReserve<Impl: IMFTimedTextRubyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut MF_TIMED_TEXT_RUBY_RESERVE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRubyReserve(::core::mem::transmute_copy(&value)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFTimedTextRuby>, base.5, GetRubyText::<Impl, OFFSET>, GetRubyPosition::<Impl, OFFSET>, GetRubyAlign::<Impl, OFFSET>, GetRubyReserve::<Impl, OFFSET>)
    }
}
pub trait IMFTimedTextStyleImpl: Sized {
    fn GetName();
    fn IsExternal();
    fn GetFontFamily();
    fn GetFontSize();
    fn GetColor();
    fn GetBackgroundColor();
    fn GetShowBackgroundAlways();
    fn GetFontStyle();
    fn GetBold();
    fn GetRightToLeft();
    fn GetTextAlignment();
    fn GetTextDecoration();
    fn GetTextOutline();
}
impl ::windows::core::RuntimeName for IMFTimedTextStyle {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTimedTextStyle";
}
impl IMFTimedTextStyleVtbl {
    pub const fn new<Impl: IMFTimedTextStyleImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTimedTextStyleVtbl {
        unsafe extern "system" fn GetName<Impl: IMFTimedTextStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, name: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetName(::core::mem::transmute_copy(&name)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsExternal<Impl: IMFTimedTextStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsExternal() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFontFamily<Impl: IMFTimedTextStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fontfamily: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFontFamily(::core::mem::transmute_copy(&fontfamily)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFontSize<Impl: IMFTimedTextStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fontsize: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFontSize(::core::mem::transmute_copy(&fontsize), ::core::mem::transmute_copy(&unittype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetColor<Impl: IMFTimedTextStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, color: *mut MFARGB) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetColor(::core::mem::transmute_copy(&color)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBackgroundColor<Impl: IMFTimedTextStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bgcolor: *mut MFARGB) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBackgroundColor(::core::mem::transmute_copy(&bgcolor)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetShowBackgroundAlways<Impl: IMFTimedTextStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, showbackgroundalways: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetShowBackgroundAlways(::core::mem::transmute_copy(&showbackgroundalways)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFontStyle<Impl: IMFTimedTextStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fontstyle: *mut MF_TIMED_TEXT_FONT_STYLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFontStyle(::core::mem::transmute_copy(&fontstyle)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBold<Impl: IMFTimedTextStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bold: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBold(::core::mem::transmute_copy(&bold)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRightToLeft<Impl: IMFTimedTextStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, righttoleft: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRightToLeft(::core::mem::transmute_copy(&righttoleft)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTextAlignment<Impl: IMFTimedTextStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, textalign: *mut MF_TIMED_TEXT_ALIGNMENT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTextAlignment(::core::mem::transmute_copy(&textalign)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTextDecoration<Impl: IMFTimedTextStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, textdecoration: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTextDecoration(::core::mem::transmute_copy(&textdecoration)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTextOutline<Impl: IMFTimedTextStyleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, color: *mut MFARGB, thickness: *mut f64, blurradius: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTextOutline(::core::mem::transmute_copy(&color), ::core::mem::transmute_copy(&thickness), ::core::mem::transmute_copy(&blurradius), ::core::mem::transmute_copy(&unittype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMFTimedTextStyle>,
            base.5,
            GetName::<Impl, OFFSET>,
            IsExternal::<Impl, OFFSET>,
            GetFontFamily::<Impl, OFFSET>,
            GetFontSize::<Impl, OFFSET>,
            GetColor::<Impl, OFFSET>,
            GetBackgroundColor::<Impl, OFFSET>,
            GetShowBackgroundAlways::<Impl, OFFSET>,
            GetFontStyle::<Impl, OFFSET>,
            GetBold::<Impl, OFFSET>,
            GetRightToLeft::<Impl, OFFSET>,
            GetTextAlignment::<Impl, OFFSET>,
            GetTextDecoration::<Impl, OFFSET>,
            GetTextOutline::<Impl, OFFSET>,
        )
    }
}
pub trait IMFTimedTextStyle2Impl: Sized {
    fn GetRuby();
    fn GetBouten();
    fn IsTextCombined();
    fn GetFontAngleInDegrees();
}
impl ::windows::core::RuntimeName for IMFTimedTextStyle2 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTimedTextStyle2";
}
impl IMFTimedTextStyle2Vtbl {
    pub const fn new<Impl: IMFTimedTextStyle2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTimedTextStyle2Vtbl {
        unsafe extern "system" fn GetRuby<Impl: IMFTimedTextStyle2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ruby: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRuby(::core::mem::transmute_copy(&ruby)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBouten<Impl: IMFTimedTextStyle2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bouten: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBouten(::core::mem::transmute_copy(&bouten)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextCombined<Impl: IMFTimedTextStyle2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsTextCombined(::core::mem::transmute_copy(&value)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFontAngleInDegrees<Impl: IMFTimedTextStyle2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, value: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFontAngleInDegrees(::core::mem::transmute_copy(&value)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFTimedTextStyle2>, base.5, GetRuby::<Impl, OFFSET>, GetBouten::<Impl, OFFSET>, IsTextCombined::<Impl, OFFSET>, GetFontAngleInDegrees::<Impl, OFFSET>)
    }
}
pub trait IMFTimedTextTrackImpl: Sized {
    fn GetId();
    fn GetLabel();
    fn SetLabel();
    fn GetLanguage();
    fn GetTrackKind();
    fn IsInBand();
    fn GetInBandMetadataTrackDispatchType();
    fn IsActive();
    fn GetErrorCode();
    fn GetExtendedErrorCode();
    fn GetDataFormat();
    fn GetReadyState();
    fn GetCueList();
}
impl ::windows::core::RuntimeName for IMFTimedTextTrack {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTimedTextTrack";
}
impl IMFTimedTextTrackVtbl {
    pub const fn new<Impl: IMFTimedTextTrackImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTimedTextTrackVtbl {
        unsafe extern "system" fn GetId<Impl: IMFTimedTextTrackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetId() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLabel<Impl: IMFTimedTextTrackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, label: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLabel(::core::mem::transmute_copy(&label)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLabel<Impl: IMFTimedTextTrackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, label: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLabel(&*(&label as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLanguage<Impl: IMFTimedTextTrackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, language: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLanguage(::core::mem::transmute_copy(&language)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTrackKind<Impl: IMFTimedTextTrackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> MF_TIMED_TEXT_TRACK_KIND {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTrackKind() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsInBand<Impl: IMFTimedTextTrackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsInBand() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInBandMetadataTrackDispatchType<Impl: IMFTimedTextTrackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dispatchtype: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInBandMetadataTrackDispatchType(::core::mem::transmute_copy(&dispatchtype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsActive<Impl: IMFTimedTextTrackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsActive() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetErrorCode<Impl: IMFTimedTextTrackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> MF_TIMED_TEXT_ERROR_CODE {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetErrorCode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetExtendedErrorCode<Impl: IMFTimedTextTrackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetExtendedErrorCode() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDataFormat<Impl: IMFTimedTextTrackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, format: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDataFormat(::core::mem::transmute_copy(&format)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetReadyState<Impl: IMFTimedTextTrackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> MF_TIMED_TEXT_TRACK_READY_STATE {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetReadyState() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCueList<Impl: IMFTimedTextTrackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cues: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCueList(::core::mem::transmute_copy(&cues)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMFTimedTextTrack>,
            base.5,
            GetId::<Impl, OFFSET>,
            GetLabel::<Impl, OFFSET>,
            SetLabel::<Impl, OFFSET>,
            GetLanguage::<Impl, OFFSET>,
            GetTrackKind::<Impl, OFFSET>,
            IsInBand::<Impl, OFFSET>,
            GetInBandMetadataTrackDispatchType::<Impl, OFFSET>,
            IsActive::<Impl, OFFSET>,
            GetErrorCode::<Impl, OFFSET>,
            GetExtendedErrorCode::<Impl, OFFSET>,
            GetDataFormat::<Impl, OFFSET>,
            GetReadyState::<Impl, OFFSET>,
            GetCueList::<Impl, OFFSET>,
        )
    }
}
pub trait IMFTimedTextTrackListImpl: Sized {
    fn GetLength();
    fn GetTrack();
    fn GetTrackById();
}
impl ::windows::core::RuntimeName for IMFTimedTextTrackList {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTimedTextTrackList";
}
impl IMFTimedTextTrackListVtbl {
    pub const fn new<Impl: IMFTimedTextTrackListImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTimedTextTrackListVtbl {
        unsafe extern "system" fn GetLength<Impl: IMFTimedTextTrackListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTrack<Impl: IMFTimedTextTrackListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, index: u32, track: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTrack(index, ::core::mem::transmute_copy(&track)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTrackById<Impl: IMFTimedTextTrackListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, trackid: u32, track: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTrackById(trackid, ::core::mem::transmute_copy(&track)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFTimedTextTrackList>, base.5, GetLength::<Impl, OFFSET>, GetTrack::<Impl, OFFSET>, GetTrackById::<Impl, OFFSET>)
    }
}
pub trait IMFTimerImpl: Sized {
    fn SetTimer();
    fn CancelTimer();
}
impl ::windows::core::RuntimeName for IMFTimer {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTimer";
}
impl IMFTimerVtbl {
    pub const fn new<Impl: IMFTimerImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTimerVtbl {
        unsafe extern "system" fn SetTimer<Impl: IMFTimerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32, llclocktime: i64, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void, ppunkkey: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTimer(dwflags, llclocktime, &*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType), &*(&punkstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppunkkey)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CancelTimer<Impl: IMFTimerImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, punkkey: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CancelTimer(&*(&punkkey as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFTimer>, base.5, SetTimer::<Impl, OFFSET>, CancelTimer::<Impl, OFFSET>)
    }
}
pub trait IMFTopoLoaderImpl: Sized {
    fn Load();
}
impl ::windows::core::RuntimeName for IMFTopoLoader {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTopoLoader";
}
impl IMFTopoLoaderVtbl {
    pub const fn new<Impl: IMFTopoLoaderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTopoLoaderVtbl {
        unsafe extern "system" fn Load<Impl: IMFTopoLoaderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pinputtopo: ::windows::core::RawPtr, ppoutputtopo: *mut ::windows::core::RawPtr, pcurrenttopo: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Load(&*(&pinputtopo as *const <IMFTopology as ::windows::core::Abi>::Abi as *const <IMFTopology as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppoutputtopo), &*(&pcurrenttopo as *const <IMFTopology as ::windows::core::Abi>::Abi as *const <IMFTopology as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFTopoLoader>, base.5, Load::<Impl, OFFSET>)
    }
}
pub trait IMFTopologyImpl: Sized + IMFAttributesImpl {
    fn GetTopologyID();
    fn AddNode();
    fn RemoveNode();
    fn GetNodeCount();
    fn GetNode();
    fn Clear();
    fn CloneFrom();
    fn GetNodeByID();
    fn GetSourceNodeCollection();
    fn GetOutputNodeCollection();
}
impl ::windows::core::RuntimeName for IMFTopology {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTopology";
}
impl IMFTopologyVtbl {
    pub const fn new<Impl: IMFTopologyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTopologyVtbl {
        unsafe extern "system" fn GetTopologyID<Impl: IMFTopologyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pid: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTopologyID(::core::mem::transmute_copy(&pid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddNode<Impl: IMFTopologyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pnode: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddNode(&*(&pnode as *const <IMFTopologyNode as ::windows::core::Abi>::Abi as *const <IMFTopologyNode as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveNode<Impl: IMFTopologyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pnode: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveNode(&*(&pnode as *const <IMFTopologyNode as ::windows::core::Abi>::Abi as *const <IMFTopologyNode as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNodeCount<Impl: IMFTopologyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwnodes: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNodeCount(::core::mem::transmute_copy(&pwnodes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNode<Impl: IMFTopologyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, windex: u16, ppnode: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNode(windex, ::core::mem::transmute_copy(&ppnode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clear<Impl: IMFTopologyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Clear() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CloneFrom<Impl: IMFTopologyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptopology: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CloneFrom(&*(&ptopology as *const <IMFTopology as ::windows::core::Abi>::Abi as *const <IMFTopology as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNodeByID<Impl: IMFTopologyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, qwtoponodeid: u64, ppnode: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNodeByID(qwtoponodeid, ::core::mem::transmute_copy(&ppnode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceNodeCollection<Impl: IMFTopologyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppcollection: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSourceNodeCollection(::core::mem::transmute_copy(&ppcollection)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputNodeCollection<Impl: IMFTopologyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppcollection: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputNodeCollection(::core::mem::transmute_copy(&ppcollection)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFTopology>, base.5, GetTopologyID::<Impl, OFFSET>, AddNode::<Impl, OFFSET>, RemoveNode::<Impl, OFFSET>, GetNodeCount::<Impl, OFFSET>, GetNode::<Impl, OFFSET>, Clear::<Impl, OFFSET>, CloneFrom::<Impl, OFFSET>, GetNodeByID::<Impl, OFFSET>, GetSourceNodeCollection::<Impl, OFFSET>, GetOutputNodeCollection::<Impl, OFFSET>)
    }
}
pub trait IMFTopologyNodeImpl: Sized + IMFAttributesImpl {
    fn SetObject();
    fn GetObject();
    fn GetNodeType();
    fn GetTopoNodeID();
    fn SetTopoNodeID();
    fn GetInputCount();
    fn GetOutputCount();
    fn ConnectOutput();
    fn DisconnectOutput();
    fn GetInput();
    fn GetOutput();
    fn SetOutputPrefType();
    fn GetOutputPrefType();
    fn SetInputPrefType();
    fn GetInputPrefType();
    fn CloneFrom();
}
impl ::windows::core::RuntimeName for IMFTopologyNode {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTopologyNode";
}
impl IMFTopologyNodeVtbl {
    pub const fn new<Impl: IMFTopologyNodeImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTopologyNodeVtbl {
        unsafe extern "system" fn SetObject<Impl: IMFTopologyNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pobject: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetObject(&*(&pobject as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetObject<Impl: IMFTopologyNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetObject(::core::mem::transmute_copy(&ppobject)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNodeType<Impl: IMFTopologyNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptype: *mut MF_TOPOLOGY_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNodeType(::core::mem::transmute_copy(&ptype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTopoNodeID<Impl: IMFTopologyNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pid: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTopoNodeID(::core::mem::transmute_copy(&pid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTopoNodeID<Impl: IMFTopologyNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulltopoid: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTopoNodeID(ulltopoid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInputCount<Impl: IMFTopologyNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcinputs: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInputCount(::core::mem::transmute_copy(&pcinputs)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputCount<Impl: IMFTopologyNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcoutputs: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputCount(::core::mem::transmute_copy(&pcoutputs)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConnectOutput<Impl: IMFTopologyNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwoutputindex: u32, pdownstreamnode: ::windows::core::RawPtr, dwinputindexondownstreamnode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ConnectOutput(dwoutputindex, &*(&pdownstreamnode as *const <IMFTopologyNode as ::windows::core::Abi>::Abi as *const <IMFTopologyNode as ::windows::core::DefaultType>::DefaultType), dwinputindexondownstreamnode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisconnectOutput<Impl: IMFTopologyNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwoutputindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DisconnectOutput(dwoutputindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInput<Impl: IMFTopologyNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwinputindex: u32, ppupstreamnode: *mut ::windows::core::RawPtr, pdwoutputindexonupstreamnode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInput(dwinputindex, ::core::mem::transmute_copy(&ppupstreamnode), ::core::mem::transmute_copy(&pdwoutputindexonupstreamnode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutput<Impl: IMFTopologyNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwoutputindex: u32, ppdownstreamnode: *mut ::windows::core::RawPtr, pdwinputindexondownstreamnode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutput(dwoutputindex, ::core::mem::transmute_copy(&ppdownstreamnode), ::core::mem::transmute_copy(&pdwinputindexondownstreamnode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputPrefType<Impl: IMFTopologyNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwoutputindex: u32, ptype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputPrefType(dwoutputindex, &*(&ptype as *const <IMFMediaType as ::windows::core::Abi>::Abi as *const <IMFMediaType as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputPrefType<Impl: IMFTopologyNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwoutputindex: u32, pptype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputPrefType(dwoutputindex, ::core::mem::transmute_copy(&pptype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputPrefType<Impl: IMFTopologyNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwinputindex: u32, ptype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetInputPrefType(dwinputindex, &*(&ptype as *const <IMFMediaType as ::windows::core::Abi>::Abi as *const <IMFMediaType as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInputPrefType<Impl: IMFTopologyNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwinputindex: u32, pptype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInputPrefType(dwinputindex, ::core::mem::transmute_copy(&pptype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CloneFrom<Impl: IMFTopologyNodeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pnode: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CloneFrom(&*(&pnode as *const <IMFTopologyNode as ::windows::core::Abi>::Abi as *const <IMFTopologyNode as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMFTopologyNode>,
            base.5,
            SetObject::<Impl, OFFSET>,
            GetObject::<Impl, OFFSET>,
            GetNodeType::<Impl, OFFSET>,
            GetTopoNodeID::<Impl, OFFSET>,
            SetTopoNodeID::<Impl, OFFSET>,
            GetInputCount::<Impl, OFFSET>,
            GetOutputCount::<Impl, OFFSET>,
            ConnectOutput::<Impl, OFFSET>,
            DisconnectOutput::<Impl, OFFSET>,
            GetInput::<Impl, OFFSET>,
            GetOutput::<Impl, OFFSET>,
            SetOutputPrefType::<Impl, OFFSET>,
            GetOutputPrefType::<Impl, OFFSET>,
            SetInputPrefType::<Impl, OFFSET>,
            GetInputPrefType::<Impl, OFFSET>,
            CloneFrom::<Impl, OFFSET>,
        )
    }
}
pub trait IMFTopologyNodeAttributeEditorImpl: Sized {
    fn UpdateNodeAttributes();
}
impl ::windows::core::RuntimeName for IMFTopologyNodeAttributeEditor {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTopologyNodeAttributeEditor";
}
impl IMFTopologyNodeAttributeEditorVtbl {
    pub const fn new<Impl: IMFTopologyNodeAttributeEditorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTopologyNodeAttributeEditorVtbl {
        unsafe extern "system" fn UpdateNodeAttributes<Impl: IMFTopologyNodeAttributeEditorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, topoid: u64, cupdates: u32, pupdates: *const MFTOPONODE_ATTRIBUTE_UPDATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UpdateNodeAttributes(topoid, cupdates, &*(&pupdates as *const <MFTOPONODE_ATTRIBUTE_UPDATE as ::windows::core::Abi>::Abi as *const <MFTOPONODE_ATTRIBUTE_UPDATE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFTopologyNodeAttributeEditor>, base.5, UpdateNodeAttributes::<Impl, OFFSET>)
    }
}
pub trait IMFTopologyServiceLookupImpl: Sized {
    fn LookupService();
}
impl ::windows::core::RuntimeName for IMFTopologyServiceLookup {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTopologyServiceLookup";
}
impl IMFTopologyServiceLookupVtbl {
    pub const fn new<Impl: IMFTopologyServiceLookupImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTopologyServiceLookupVtbl {
        unsafe extern "system" fn LookupService<Impl: IMFTopologyServiceLookupImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, r#type: MF_SERVICE_LOOKUP_TYPE, dwindex: u32, guidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobjects: *mut *mut ::core::ffi::c_void, pnobjects: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).LookupService(r#type, dwindex, &*(&guidservice as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppvobjects), pnobjects) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFTopologyServiceLookup>, base.5, LookupService::<Impl, OFFSET>)
    }
}
pub trait IMFTopologyServiceLookupClientImpl: Sized {
    fn InitServicePointers();
    fn ReleaseServicePointers();
}
impl ::windows::core::RuntimeName for IMFTopologyServiceLookupClient {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTopologyServiceLookupClient";
}
impl IMFTopologyServiceLookupClientVtbl {
    pub const fn new<Impl: IMFTopologyServiceLookupClientImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTopologyServiceLookupClientVtbl {
        unsafe extern "system" fn InitServicePointers<Impl: IMFTopologyServiceLookupClientImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plookup: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InitServicePointers(&*(&plookup as *const <IMFTopologyServiceLookup as ::windows::core::Abi>::Abi as *const <IMFTopologyServiceLookup as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReleaseServicePointers<Impl: IMFTopologyServiceLookupClientImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ReleaseServicePointers() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFTopologyServiceLookupClient>, base.5, InitServicePointers::<Impl, OFFSET>, ReleaseServicePointers::<Impl, OFFSET>)
    }
}
pub trait IMFTrackedSampleImpl: Sized {
    fn SetAllocator();
}
impl ::windows::core::RuntimeName for IMFTrackedSample {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTrackedSample";
}
impl IMFTrackedSampleVtbl {
    pub const fn new<Impl: IMFTrackedSampleImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTrackedSampleVtbl {
        unsafe extern "system" fn SetAllocator<Impl: IMFTrackedSampleImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psampleallocator: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAllocator(&*(&psampleallocator as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType), &*(&punkstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFTrackedSample>, base.5, SetAllocator::<Impl, OFFSET>)
    }
}
pub trait IMFTranscodeProfileImpl: Sized {
    fn SetAudioAttributes();
    fn GetAudioAttributes();
    fn SetVideoAttributes();
    fn GetVideoAttributes();
    fn SetContainerAttributes();
    fn GetContainerAttributes();
}
impl ::windows::core::RuntimeName for IMFTranscodeProfile {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTranscodeProfile";
}
impl IMFTranscodeProfileVtbl {
    pub const fn new<Impl: IMFTranscodeProfileImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTranscodeProfileVtbl {
        unsafe extern "system" fn SetAudioAttributes<Impl: IMFTranscodeProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pattrs: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAudioAttributes(&*(&pattrs as *const <IMFAttributes as ::windows::core::Abi>::Abi as *const <IMFAttributes as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAudioAttributes<Impl: IMFTranscodeProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppattrs: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAudioAttributes(::core::mem::transmute_copy(&ppattrs)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoAttributes<Impl: IMFTranscodeProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pattrs: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVideoAttributes(&*(&pattrs as *const <IMFAttributes as ::windows::core::Abi>::Abi as *const <IMFAttributes as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoAttributes<Impl: IMFTranscodeProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppattrs: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoAttributes(::core::mem::transmute_copy(&ppattrs)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContainerAttributes<Impl: IMFTranscodeProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pattrs: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetContainerAttributes(&*(&pattrs as *const <IMFAttributes as ::windows::core::Abi>::Abi as *const <IMFAttributes as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetContainerAttributes<Impl: IMFTranscodeProfileImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppattrs: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetContainerAttributes(::core::mem::transmute_copy(&ppattrs)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFTranscodeProfile>, base.5, SetAudioAttributes::<Impl, OFFSET>, GetAudioAttributes::<Impl, OFFSET>, SetVideoAttributes::<Impl, OFFSET>, GetVideoAttributes::<Impl, OFFSET>, SetContainerAttributes::<Impl, OFFSET>, GetContainerAttributes::<Impl, OFFSET>)
    }
}
pub trait IMFTranscodeSinkInfoProviderImpl: Sized {
    fn SetOutputFile();
    fn SetOutputByteStream();
    fn SetProfile();
    fn GetSinkInfo();
}
impl ::windows::core::RuntimeName for IMFTranscodeSinkInfoProvider {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTranscodeSinkInfoProvider";
}
impl IMFTranscodeSinkInfoProviderVtbl {
    pub const fn new<Impl: IMFTranscodeSinkInfoProviderImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTranscodeSinkInfoProviderVtbl {
        unsafe extern "system" fn SetOutputFile<Impl: IMFTranscodeSinkInfoProviderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwszfilename: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputFile(&*(&pwszfilename as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputByteStream<Impl: IMFTranscodeSinkInfoProviderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbytestreamactivate: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputByteStream(&*(&pbytestreamactivate as *const <IMFActivate as ::windows::core::Abi>::Abi as *const <IMFActivate as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProfile<Impl: IMFTranscodeSinkInfoProviderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pprofile: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetProfile(&*(&pprofile as *const <IMFTranscodeProfile as ::windows::core::Abi>::Abi as *const <IMFTranscodeProfile as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSinkInfo<Impl: IMFTranscodeSinkInfoProviderImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psinkinfo: *mut MF_TRANSCODE_SINK_INFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSinkInfo(::core::mem::transmute_copy(&psinkinfo)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFTranscodeSinkInfoProvider>, base.5, SetOutputFile::<Impl, OFFSET>, SetOutputByteStream::<Impl, OFFSET>, SetProfile::<Impl, OFFSET>, GetSinkInfo::<Impl, OFFSET>)
    }
}
pub trait IMFTransformImpl: Sized {
    fn GetStreamLimits();
    fn GetStreamCount();
    fn GetStreamIDs();
    fn GetInputStreamInfo();
    fn GetOutputStreamInfo();
    fn GetAttributes();
    fn GetInputStreamAttributes();
    fn GetOutputStreamAttributes();
    fn DeleteInputStream();
    fn AddInputStreams();
    fn GetInputAvailableType();
    fn GetOutputAvailableType();
    fn SetInputType();
    fn SetOutputType();
    fn GetInputCurrentType();
    fn GetOutputCurrentType();
    fn GetInputStatus();
    fn GetOutputStatus();
    fn SetOutputBounds();
    fn ProcessEvent();
    fn ProcessMessage();
    fn ProcessInput();
    fn ProcessOutput();
}
impl ::windows::core::RuntimeName for IMFTransform {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTransform";
}
impl IMFTransformVtbl {
    pub const fn new<Impl: IMFTransformImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTransformVtbl {
        unsafe extern "system" fn GetStreamLimits<Impl: IMFTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwinputminimum: *mut u32, pdwinputmaximum: *mut u32, pdwoutputminimum: *mut u32, pdwoutputmaximum: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamLimits(::core::mem::transmute_copy(&pdwinputminimum), ::core::mem::transmute_copy(&pdwinputmaximum), ::core::mem::transmute_copy(&pdwoutputminimum), ::core::mem::transmute_copy(&pdwoutputmaximum)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamCount<Impl: IMFTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcinputstreams: *mut u32, pcoutputstreams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamCount(::core::mem::transmute_copy(&pcinputstreams), ::core::mem::transmute_copy(&pcoutputstreams)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamIDs<Impl: IMFTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwinputidarraysize: u32, pdwinputids: *mut u32, dwoutputidarraysize: u32, pdwoutputids: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamIDs(dwinputidarraysize, ::core::mem::transmute_copy(&pdwinputids), dwoutputidarraysize, ::core::mem::transmute_copy(&pdwoutputids)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInputStreamInfo<Impl: IMFTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, pstreaminfo: *mut MFT_INPUT_STREAM_INFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInputStreamInfo(dwinputstreamid, ::core::mem::transmute_copy(&pstreaminfo)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputStreamInfo<Impl: IMFTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, pstreaminfo: *mut MFT_OUTPUT_STREAM_INFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputStreamInfo(dwoutputstreamid, ::core::mem::transmute_copy(&pstreaminfo)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAttributes<Impl: IMFTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pattributes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAttributes(::core::mem::transmute_copy(&pattributes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInputStreamAttributes<Impl: IMFTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, pattributes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInputStreamAttributes(dwinputstreamid, ::core::mem::transmute_copy(&pattributes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputStreamAttributes<Impl: IMFTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, pattributes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputStreamAttributes(dwoutputstreamid, ::core::mem::transmute_copy(&pattributes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DeleteInputStream<Impl: IMFTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).DeleteInputStream(dwstreamid) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddInputStreams<Impl: IMFTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cstreams: u32, adwstreamids: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddInputStreams(cstreams, adwstreamids) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInputAvailableType<Impl: IMFTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, dwtypeindex: u32, pptype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInputAvailableType(dwinputstreamid, dwtypeindex, ::core::mem::transmute_copy(&pptype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputAvailableType<Impl: IMFTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, dwtypeindex: u32, pptype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputAvailableType(dwoutputstreamid, dwtypeindex, ::core::mem::transmute_copy(&pptype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputType<Impl: IMFTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, ptype: ::windows::core::RawPtr, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetInputType(dwinputstreamid, &*(&ptype as *const <IMFMediaType as ::windows::core::Abi>::Abi as *const <IMFMediaType as ::windows::core::DefaultType>::DefaultType), dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputType<Impl: IMFTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, ptype: ::windows::core::RawPtr, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputType(dwoutputstreamid, &*(&ptype as *const <IMFMediaType as ::windows::core::Abi>::Abi as *const <IMFMediaType as ::windows::core::DefaultType>::DefaultType), dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInputCurrentType<Impl: IMFTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, pptype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInputCurrentType(dwinputstreamid, ::core::mem::transmute_copy(&pptype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputCurrentType<Impl: IMFTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, pptype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputCurrentType(dwoutputstreamid, ::core::mem::transmute_copy(&pptype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInputStatus<Impl: IMFTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInputStatus(dwinputstreamid, ::core::mem::transmute_copy(&pdwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputStatus<Impl: IMFTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputStatus(::core::mem::transmute_copy(&pdwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputBounds<Impl: IMFTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hnslowerbound: i64, hnsupperbound: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputBounds(hnslowerbound, hnsupperbound) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProcessEvent<Impl: IMFTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, pevent: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProcessEvent(dwinputstreamid, &*(&pevent as *const <IMFMediaEvent as ::windows::core::Abi>::Abi as *const <IMFMediaEvent as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProcessMessage<Impl: IMFTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, emessage: MFT_MESSAGE_TYPE, ulparam: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProcessMessage(emessage, ulparam) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProcessInput<Impl: IMFTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, psample: ::windows::core::RawPtr, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProcessInput(dwinputstreamid, &*(&psample as *const <IMFSample as ::windows::core::Abi>::Abi as *const <IMFSample as ::windows::core::DefaultType>::DefaultType), dwflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProcessOutput<Impl: IMFTransformImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32, coutputbuffercount: u32, poutputsamples: *mut MFT_OUTPUT_DATA_BUFFER, pdwstatus: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProcessOutput(dwflags, coutputbuffercount, &*(&poutputsamples as *const <MFT_OUTPUT_DATA_BUFFER as ::windows::core::Abi>::Abi as *const <MFT_OUTPUT_DATA_BUFFER as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pdwstatus)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMFTransform>,
            base.5,
            GetStreamLimits::<Impl, OFFSET>,
            GetStreamCount::<Impl, OFFSET>,
            GetStreamIDs::<Impl, OFFSET>,
            GetInputStreamInfo::<Impl, OFFSET>,
            GetOutputStreamInfo::<Impl, OFFSET>,
            GetAttributes::<Impl, OFFSET>,
            GetInputStreamAttributes::<Impl, OFFSET>,
            GetOutputStreamAttributes::<Impl, OFFSET>,
            DeleteInputStream::<Impl, OFFSET>,
            AddInputStreams::<Impl, OFFSET>,
            GetInputAvailableType::<Impl, OFFSET>,
            GetOutputAvailableType::<Impl, OFFSET>,
            SetInputType::<Impl, OFFSET>,
            SetOutputType::<Impl, OFFSET>,
            GetInputCurrentType::<Impl, OFFSET>,
            GetOutputCurrentType::<Impl, OFFSET>,
            GetInputStatus::<Impl, OFFSET>,
            GetOutputStatus::<Impl, OFFSET>,
            SetOutputBounds::<Impl, OFFSET>,
            ProcessEvent::<Impl, OFFSET>,
            ProcessMessage::<Impl, OFFSET>,
            ProcessInput::<Impl, OFFSET>,
            ProcessOutput::<Impl, OFFSET>,
        )
    }
}
pub trait IMFTrustedInputImpl: Sized {
    fn GetInputTrustAuthority();
}
impl ::windows::core::RuntimeName for IMFTrustedInput {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTrustedInput";
}
impl IMFTrustedInputVtbl {
    pub const fn new<Impl: IMFTrustedInputImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTrustedInputVtbl {
        unsafe extern "system" fn GetInputTrustAuthority<Impl: IMFTrustedInputImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, riid: *const ::windows::core::GUID, ppunkobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInputTrustAuthority(dwstreamid, &*(&riid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppunkobject)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFTrustedInput>, base.5, GetInputTrustAuthority::<Impl, OFFSET>)
    }
}
pub trait IMFTrustedOutputImpl: Sized {
    fn GetOutputTrustAuthorityCount();
    fn GetOutputTrustAuthorityByIndex();
    fn IsFinal();
}
impl ::windows::core::RuntimeName for IMFTrustedOutput {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFTrustedOutput";
}
impl IMFTrustedOutputVtbl {
    pub const fn new<Impl: IMFTrustedOutputImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFTrustedOutputVtbl {
        unsafe extern "system" fn GetOutputTrustAuthorityCount<Impl: IMFTrustedOutputImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcoutputtrustauthorities: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputTrustAuthorityCount(::core::mem::transmute_copy(&pcoutputtrustauthorities)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputTrustAuthorityByIndex<Impl: IMFTrustedOutputImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppauthority: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetOutputTrustAuthorityByIndex(dwindex, ::core::mem::transmute_copy(&ppauthority)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFinal<Impl: IMFTrustedOutputImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfisfinal: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).IsFinal(::core::mem::transmute_copy(&pfisfinal)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFTrustedOutput>, base.5, GetOutputTrustAuthorityCount::<Impl, OFFSET>, GetOutputTrustAuthorityByIndex::<Impl, OFFSET>, IsFinal::<Impl, OFFSET>)
    }
}
pub trait IMFVideoCaptureSampleAllocatorImpl: Sized + IMFVideoSampleAllocatorImpl {
    fn InitializeCaptureSampleAllocator();
}
impl ::windows::core::RuntimeName for IMFVideoCaptureSampleAllocator {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFVideoCaptureSampleAllocator";
}
impl IMFVideoCaptureSampleAllocatorVtbl {
    pub const fn new<Impl: IMFVideoCaptureSampleAllocatorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFVideoCaptureSampleAllocatorVtbl {
        unsafe extern "system" fn InitializeCaptureSampleAllocator<Impl: IMFVideoCaptureSampleAllocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cbsamplesize: u32, cbcapturemetadatasize: u32, cbalignment: u32, cminimumsamples: u32, pattributes: ::windows::core::RawPtr, pmediatype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InitializeCaptureSampleAllocator(cbsamplesize, cbcapturemetadatasize, cbalignment, cminimumsamples, &*(&pattributes as *const <IMFAttributes as ::windows::core::Abi>::Abi as *const <IMFAttributes as ::windows::core::DefaultType>::DefaultType), &*(&pmediatype as *const <IMFMediaType as ::windows::core::Abi>::Abi as *const <IMFMediaType as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFVideoCaptureSampleAllocator>, base.5, InitializeCaptureSampleAllocator::<Impl, OFFSET>)
    }
}
pub trait IMFVideoDeviceIDImpl: Sized {
    fn GetDeviceID();
}
impl ::windows::core::RuntimeName for IMFVideoDeviceID {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFVideoDeviceID";
}
impl IMFVideoDeviceIDVtbl {
    pub const fn new<Impl: IMFVideoDeviceIDImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFVideoDeviceIDVtbl {
        unsafe extern "system" fn GetDeviceID<Impl: IMFVideoDeviceIDImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdeviceid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDeviceID(::core::mem::transmute_copy(&pdeviceid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFVideoDeviceID>, base.5, GetDeviceID::<Impl, OFFSET>)
    }
}
pub trait IMFVideoDisplayControlImpl: Sized {
    fn GetNativeVideoSize();
    fn GetIdealVideoSize();
    fn SetVideoPosition();
    fn GetVideoPosition();
    fn SetAspectRatioMode();
    fn GetAspectRatioMode();
    fn SetVideoWindow();
    fn GetVideoWindow();
    fn RepaintVideo();
    fn GetCurrentImage();
    fn SetBorderColor();
    fn GetBorderColor();
    fn SetRenderingPrefs();
    fn GetRenderingPrefs();
    fn SetFullscreen();
    fn GetFullscreen();
}
impl ::windows::core::RuntimeName for IMFVideoDisplayControl {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFVideoDisplayControl";
}
impl IMFVideoDisplayControlVtbl {
    pub const fn new<Impl: IMFVideoDisplayControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFVideoDisplayControlVtbl {
        unsafe extern "system" fn GetNativeVideoSize<Impl: IMFVideoDisplayControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszvideo: *mut super::super::Foundation::SIZE, pszarvideo: *mut super::super::Foundation::SIZE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNativeVideoSize(&*(&pszvideo as *const <super::super::Foundation::SIZE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::SIZE as ::windows::core::DefaultType>::DefaultType), &*(&pszarvideo as *const <super::super::Foundation::SIZE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::SIZE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIdealVideoSize<Impl: IMFVideoDisplayControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pszmin: *mut super::super::Foundation::SIZE, pszmax: *mut super::super::Foundation::SIZE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIdealVideoSize(&*(&pszmin as *const <super::super::Foundation::SIZE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::SIZE as ::windows::core::DefaultType>::DefaultType), &*(&pszmax as *const <super::super::Foundation::SIZE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::SIZE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoPosition<Impl: IMFVideoDisplayControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pnrcsource: *const MFVideoNormalizedRect, prcdest: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVideoPosition(&*(&pnrcsource as *const <MFVideoNormalizedRect as ::windows::core::Abi>::Abi as *const <MFVideoNormalizedRect as ::windows::core::DefaultType>::DefaultType), &*(&prcdest as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoPosition<Impl: IMFVideoDisplayControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pnrcsource: *mut MFVideoNormalizedRect, prcdest: *mut super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoPosition(::core::mem::transmute_copy(&pnrcsource), ::core::mem::transmute_copy(&prcdest)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAspectRatioMode<Impl: IMFVideoDisplayControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwaspectratiomode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAspectRatioMode(dwaspectratiomode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAspectRatioMode<Impl: IMFVideoDisplayControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwaspectratiomode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAspectRatioMode(::core::mem::transmute_copy(&pdwaspectratiomode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoWindow<Impl: IMFVideoDisplayControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, hwndvideo: super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVideoWindow(&*(&hwndvideo as *const <super::super::Foundation::HWND as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HWND as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoWindow<Impl: IMFVideoDisplayControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, phwndvideo: *mut super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoWindow(::core::mem::transmute_copy(&phwndvideo)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RepaintVideo<Impl: IMFVideoDisplayControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RepaintVideo() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentImage<Impl: IMFVideoDisplayControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbih: *mut super::super::Graphics::Gdi::BITMAPINFOHEADER, pdib: *mut *mut u8, pcbdib: *mut u32, ptimestamp: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentImage(&*(&pbih as *const <super::super::Graphics::Gdi::BITMAPINFOHEADER as ::windows::core::Abi>::Abi as *const <super::super::Graphics::Gdi::BITMAPINFOHEADER as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pdib), ::core::mem::transmute_copy(&pcbdib), ptimestamp) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBorderColor<Impl: IMFVideoDisplayControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clr: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBorderColor(clr) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBorderColor<Impl: IMFVideoDisplayControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pclr: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBorderColor(::core::mem::transmute_copy(&pclr)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRenderingPrefs<Impl: IMFVideoDisplayControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwrenderflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRenderingPrefs(dwrenderflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRenderingPrefs<Impl: IMFVideoDisplayControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwrenderflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetRenderingPrefs(::core::mem::transmute_copy(&pdwrenderflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFullscreen<Impl: IMFVideoDisplayControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ffullscreen: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFullscreen(&*(&ffullscreen as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFullscreen<Impl: IMFVideoDisplayControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pffullscreen: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFullscreen(::core::mem::transmute_copy(&pffullscreen)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMFVideoDisplayControl>,
            base.5,
            GetNativeVideoSize::<Impl, OFFSET>,
            GetIdealVideoSize::<Impl, OFFSET>,
            SetVideoPosition::<Impl, OFFSET>,
            GetVideoPosition::<Impl, OFFSET>,
            SetAspectRatioMode::<Impl, OFFSET>,
            GetAspectRatioMode::<Impl, OFFSET>,
            SetVideoWindow::<Impl, OFFSET>,
            GetVideoWindow::<Impl, OFFSET>,
            RepaintVideo::<Impl, OFFSET>,
            GetCurrentImage::<Impl, OFFSET>,
            SetBorderColor::<Impl, OFFSET>,
            GetBorderColor::<Impl, OFFSET>,
            SetRenderingPrefs::<Impl, OFFSET>,
            GetRenderingPrefs::<Impl, OFFSET>,
            SetFullscreen::<Impl, OFFSET>,
            GetFullscreen::<Impl, OFFSET>,
        )
    }
}
pub trait IMFVideoMediaTypeImpl: Sized + IMFMediaTypeImpl + IMFAttributesImpl {
    fn GetVideoFormat();
    fn GetVideoRepresentation();
}
impl ::windows::core::RuntimeName for IMFVideoMediaType {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFVideoMediaType";
}
impl IMFVideoMediaTypeVtbl {
    pub const fn new<Impl: IMFVideoMediaTypeImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFVideoMediaTypeVtbl {
        unsafe extern "system" fn GetVideoFormat<Impl: IMFVideoMediaTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> *mut MFVIDEOFORMAT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoRepresentation<Impl: IMFVideoMediaTypeImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidrepresentation: ::windows::core::GUID, ppvrepresentation: *mut *mut ::core::ffi::c_void, lstride: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoRepresentation(&*(&guidrepresentation as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppvrepresentation), lstride) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFVideoMediaType>, base.5, GetVideoFormat::<Impl, OFFSET>, GetVideoRepresentation::<Impl, OFFSET>)
    }
}
pub trait IMFVideoMixerBitmapImpl: Sized {
    fn SetAlphaBitmap();
    fn ClearAlphaBitmap();
    fn UpdateAlphaBitmapParameters();
    fn GetAlphaBitmapParameters();
}
impl ::windows::core::RuntimeName for IMFVideoMixerBitmap {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFVideoMixerBitmap";
}
impl IMFVideoMixerBitmapVtbl {
    pub const fn new<Impl: IMFVideoMixerBitmapImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFVideoMixerBitmapVtbl {
        unsafe extern "system" fn SetAlphaBitmap<Impl: IMFVideoMixerBitmapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbmpparms: *const MFVideoAlphaBitmap) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetAlphaBitmap(&*(&pbmpparms as *const <MFVideoAlphaBitmap as ::windows::core::Abi>::Abi as *const <MFVideoAlphaBitmap as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ClearAlphaBitmap<Impl: IMFVideoMixerBitmapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ClearAlphaBitmap() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UpdateAlphaBitmapParameters<Impl: IMFVideoMixerBitmapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbmpparms: *const MFVideoAlphaBitmapParams) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UpdateAlphaBitmapParameters(&*(&pbmpparms as *const <MFVideoAlphaBitmapParams as ::windows::core::Abi>::Abi as *const <MFVideoAlphaBitmapParams as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAlphaBitmapParameters<Impl: IMFVideoMixerBitmapImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbmpparms: *mut MFVideoAlphaBitmapParams) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAlphaBitmapParameters(::core::mem::transmute_copy(&pbmpparms)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFVideoMixerBitmap>, base.5, SetAlphaBitmap::<Impl, OFFSET>, ClearAlphaBitmap::<Impl, OFFSET>, UpdateAlphaBitmapParameters::<Impl, OFFSET>, GetAlphaBitmapParameters::<Impl, OFFSET>)
    }
}
pub trait IMFVideoMixerControlImpl: Sized {
    fn SetStreamZOrder();
    fn GetStreamZOrder();
    fn SetStreamOutputRect();
    fn GetStreamOutputRect();
}
impl ::windows::core::RuntimeName for IMFVideoMixerControl {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFVideoMixerControl";
}
impl IMFVideoMixerControlVtbl {
    pub const fn new<Impl: IMFVideoMixerControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFVideoMixerControlVtbl {
        unsafe extern "system" fn SetStreamZOrder<Impl: IMFVideoMixerControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, dwz: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStreamZOrder(dwstreamid, dwz) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamZOrder<Impl: IMFVideoMixerControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, pdwz: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamZOrder(dwstreamid, ::core::mem::transmute_copy(&pdwz)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamOutputRect<Impl: IMFVideoMixerControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, pnrcoutput: *const MFVideoNormalizedRect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetStreamOutputRect(dwstreamid, &*(&pnrcoutput as *const <MFVideoNormalizedRect as ::windows::core::Abi>::Abi as *const <MFVideoNormalizedRect as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamOutputRect<Impl: IMFVideoMixerControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, pnrcoutput: *mut MFVideoNormalizedRect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetStreamOutputRect(dwstreamid, ::core::mem::transmute_copy(&pnrcoutput)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFVideoMixerControl>, base.5, SetStreamZOrder::<Impl, OFFSET>, GetStreamZOrder::<Impl, OFFSET>, SetStreamOutputRect::<Impl, OFFSET>, GetStreamOutputRect::<Impl, OFFSET>)
    }
}
pub trait IMFVideoMixerControl2Impl: Sized + IMFVideoMixerControlImpl {
    fn SetMixingPrefs();
    fn GetMixingPrefs();
}
impl ::windows::core::RuntimeName for IMFVideoMixerControl2 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFVideoMixerControl2";
}
impl IMFVideoMixerControl2Vtbl {
    pub const fn new<Impl: IMFVideoMixerControl2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFVideoMixerControl2Vtbl {
        unsafe extern "system" fn SetMixingPrefs<Impl: IMFVideoMixerControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwmixflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMixingPrefs(dwmixflags) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMixingPrefs<Impl: IMFVideoMixerControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwmixflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMixingPrefs(::core::mem::transmute_copy(&pdwmixflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFVideoMixerControl2>, base.5, SetMixingPrefs::<Impl, OFFSET>, GetMixingPrefs::<Impl, OFFSET>)
    }
}
pub trait IMFVideoPositionMapperImpl: Sized {
    fn MapOutputCoordinateToInputStream();
}
impl ::windows::core::RuntimeName for IMFVideoPositionMapper {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFVideoPositionMapper";
}
impl IMFVideoPositionMapperVtbl {
    pub const fn new<Impl: IMFVideoPositionMapperImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFVideoPositionMapperVtbl {
        unsafe extern "system" fn MapOutputCoordinateToInputStream<Impl: IMFVideoPositionMapperImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, xout: f32, yout: f32, dwoutputstreamindex: u32, dwinputstreamindex: u32, pxin: *mut f32, pyin: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).MapOutputCoordinateToInputStream(xout, yout, dwoutputstreamindex, dwinputstreamindex, ::core::mem::transmute_copy(&pxin), ::core::mem::transmute_copy(&pyin)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFVideoPositionMapper>, base.5, MapOutputCoordinateToInputStream::<Impl, OFFSET>)
    }
}
pub trait IMFVideoPresenterImpl: Sized + IMFClockStateSinkImpl {
    fn ProcessMessage();
    fn GetCurrentMediaType();
}
impl ::windows::core::RuntimeName for IMFVideoPresenter {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFVideoPresenter";
}
impl IMFVideoPresenterVtbl {
    pub const fn new<Impl: IMFVideoPresenterImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFVideoPresenterVtbl {
        unsafe extern "system" fn ProcessMessage<Impl: IMFVideoPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, emessage: MFVP_MESSAGE_TYPE, ulparam: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).ProcessMessage(emessage, ulparam) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentMediaType<Impl: IMFVideoPresenterImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppmediatype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCurrentMediaType(::core::mem::transmute_copy(&ppmediatype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFVideoPresenter>, base.5, ProcessMessage::<Impl, OFFSET>, GetCurrentMediaType::<Impl, OFFSET>)
    }
}
pub trait IMFVideoProcessorImpl: Sized {
    fn GetAvailableVideoProcessorModes();
    fn GetVideoProcessorCaps();
    fn GetVideoProcessorMode();
    fn SetVideoProcessorMode();
    fn GetProcAmpRange();
    fn GetProcAmpValues();
    fn SetProcAmpValues();
    fn GetFilteringRange();
    fn GetFilteringValue();
    fn SetFilteringValue();
    fn GetBackgroundColor();
    fn SetBackgroundColor();
}
impl ::windows::core::RuntimeName for IMFVideoProcessor {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFVideoProcessor";
}
impl IMFVideoProcessorVtbl {
    pub const fn new<Impl: IMFVideoProcessorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFVideoProcessorVtbl {
        unsafe extern "system" fn GetAvailableVideoProcessorModes<Impl: IMFVideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpdwnumprocessingmodes: *mut u32, ppvideoprocessingmodes: *mut *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetAvailableVideoProcessorModes(lpdwnumprocessingmodes, ::core::mem::transmute_copy(&ppvideoprocessingmodes)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoProcessorCaps<Impl: IMFVideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpvideoprocessormode: *const ::windows::core::GUID, lpvideoprocessorcaps: *mut DXVA2_VideoProcessorCaps) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoProcessorCaps(&*(&lpvideoprocessormode as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&lpvideoprocessorcaps)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoProcessorMode<Impl: IMFVideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpmode: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetVideoProcessorMode(::core::mem::transmute_copy(&lpmode)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoProcessorMode<Impl: IMFVideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpmode: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetVideoProcessorMode(&*(&lpmode as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProcAmpRange<Impl: IMFVideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwproperty: u32, pproprange: *mut DXVA2_ValueRange) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProcAmpRange(dwproperty, ::core::mem::transmute_copy(&pproprange)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProcAmpValues<Impl: IMFVideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32, values: *mut DXVA2_ProcAmpValues) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetProcAmpValues(dwflags, ::core::mem::transmute_copy(&values)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProcAmpValues<Impl: IMFVideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32, pvalues: *const DXVA2_ProcAmpValues) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetProcAmpValues(dwflags, &*(&pvalues as *const <DXVA2_ProcAmpValues as ::windows::core::Abi>::Abi as *const <DXVA2_ProcAmpValues as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFilteringRange<Impl: IMFVideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwproperty: u32, pproprange: *mut DXVA2_ValueRange) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFilteringRange(dwproperty, ::core::mem::transmute_copy(&pproprange)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFilteringValue<Impl: IMFVideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwproperty: u32, pvalue: *mut DXVA2_Fixed32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFilteringValue(dwproperty, ::core::mem::transmute_copy(&pvalue)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFilteringValue<Impl: IMFVideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwproperty: u32, pvalue: *const DXVA2_Fixed32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFilteringValue(dwproperty, &*(&pvalue as *const <DXVA2_Fixed32 as ::windows::core::Abi>::Abi as *const <DXVA2_Fixed32 as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBackgroundColor<Impl: IMFVideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lpclrbkg: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBackgroundColor(::core::mem::transmute_copy(&lpclrbkg)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundColor<Impl: IMFVideoProcessorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, clrbkg: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBackgroundColor(clrbkg) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMFVideoProcessor>,
            base.5,
            GetAvailableVideoProcessorModes::<Impl, OFFSET>,
            GetVideoProcessorCaps::<Impl, OFFSET>,
            GetVideoProcessorMode::<Impl, OFFSET>,
            SetVideoProcessorMode::<Impl, OFFSET>,
            GetProcAmpRange::<Impl, OFFSET>,
            GetProcAmpValues::<Impl, OFFSET>,
            SetProcAmpValues::<Impl, OFFSET>,
            GetFilteringRange::<Impl, OFFSET>,
            GetFilteringValue::<Impl, OFFSET>,
            SetFilteringValue::<Impl, OFFSET>,
            GetBackgroundColor::<Impl, OFFSET>,
            SetBackgroundColor::<Impl, OFFSET>,
        )
    }
}
pub trait IMFVideoProcessorControlImpl: Sized {
    fn SetBorderColor();
    fn SetSourceRectangle();
    fn SetDestinationRectangle();
    fn SetMirror();
    fn SetRotation();
    fn SetConstrictionSize();
}
impl ::windows::core::RuntimeName for IMFVideoProcessorControl {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFVideoProcessorControl";
}
impl IMFVideoProcessorControlVtbl {
    pub const fn new<Impl: IMFVideoProcessorControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFVideoProcessorControlVtbl {
        unsafe extern "system" fn SetBorderColor<Impl: IMFVideoProcessorControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbordercolor: *const MFARGB) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBorderColor(&*(&pbordercolor as *const <MFARGB as ::windows::core::Abi>::Abi as *const <MFARGB as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSourceRectangle<Impl: IMFVideoProcessorControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, psrcrect: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSourceRectangle(&*(&psrcrect as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDestinationRectangle<Impl: IMFVideoProcessorControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdstrect: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDestinationRectangle(&*(&pdstrect as *const <super::super::Foundation::RECT as ::windows::core::Abi>::Abi as *const <super::super::Foundation::RECT as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMirror<Impl: IMFVideoProcessorControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, emirror: MF_VIDEO_PROCESSOR_MIRROR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMirror(emirror) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRotation<Impl: IMFVideoProcessorControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, erotation: MF_VIDEO_PROCESSOR_ROTATION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRotation(erotation) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetConstrictionSize<Impl: IMFVideoProcessorControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pconstrictionsize: *const super::super::Foundation::SIZE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetConstrictionSize(&*(&pconstrictionsize as *const <super::super::Foundation::SIZE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::SIZE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFVideoProcessorControl>, base.5, SetBorderColor::<Impl, OFFSET>, SetSourceRectangle::<Impl, OFFSET>, SetDestinationRectangle::<Impl, OFFSET>, SetMirror::<Impl, OFFSET>, SetRotation::<Impl, OFFSET>, SetConstrictionSize::<Impl, OFFSET>)
    }
}
pub trait IMFVideoProcessorControl2Impl: Sized + IMFVideoProcessorControlImpl {
    fn SetRotationOverride();
    fn EnableHardwareEffects();
    fn GetSupportedHardwareEffects();
}
impl ::windows::core::RuntimeName for IMFVideoProcessorControl2 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFVideoProcessorControl2";
}
impl IMFVideoProcessorControl2Vtbl {
    pub const fn new<Impl: IMFVideoProcessorControl2Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFVideoProcessorControl2Vtbl {
        unsafe extern "system" fn SetRotationOverride<Impl: IMFVideoProcessorControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, uirotation: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetRotationOverride(uirotation) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnableHardwareEffects<Impl: IMFVideoProcessorControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fenabled: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnableHardwareEffects(&*(&fenabled as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSupportedHardwareEffects<Impl: IMFVideoProcessorControl2Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, puisupport: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSupportedHardwareEffects(::core::mem::transmute_copy(&puisupport)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFVideoProcessorControl2>, base.5, SetRotationOverride::<Impl, OFFSET>, EnableHardwareEffects::<Impl, OFFSET>, GetSupportedHardwareEffects::<Impl, OFFSET>)
    }
}
pub trait IMFVideoProcessorControl3Impl: Sized + IMFVideoProcessorControl2Impl + IMFVideoProcessorControlImpl {
    fn GetNaturalOutputType();
    fn EnableSphericalVideoProcessing();
    fn SetSphericalVideoProperties();
    fn SetOutputDevice();
}
impl ::windows::core::RuntimeName for IMFVideoProcessorControl3 {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFVideoProcessorControl3";
}
impl IMFVideoProcessorControl3Vtbl {
    pub const fn new<Impl: IMFVideoProcessorControl3Impl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFVideoProcessorControl3Vtbl {
        unsafe extern "system" fn GetNaturalOutputType<Impl: IMFVideoProcessorControl3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pptype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNaturalOutputType(::core::mem::transmute_copy(&pptype)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnableSphericalVideoProcessing<Impl: IMFVideoProcessorControl3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fenable: super::super::Foundation::BOOL, eformat: MFVideoSphericalFormat, eprojectionmode: MFVideoSphericalProjectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EnableSphericalVideoProcessing(&*(&fenable as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType), eformat, eprojectionmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSphericalVideoProperties<Impl: IMFVideoProcessorControl3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, x: f32, y: f32, z: f32, w: f32, fieldofview: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSphericalVideoProperties(x, y, z, w, fieldofview) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputDevice<Impl: IMFVideoProcessorControl3Impl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, poutputdevice: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetOutputDevice(&*(&poutputdevice as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFVideoProcessorControl3>, base.5, GetNaturalOutputType::<Impl, OFFSET>, EnableSphericalVideoProcessing::<Impl, OFFSET>, SetSphericalVideoProperties::<Impl, OFFSET>, SetOutputDevice::<Impl, OFFSET>)
    }
}
pub trait IMFVideoRendererImpl: Sized {
    fn InitializeRenderer();
}
impl ::windows::core::RuntimeName for IMFVideoRenderer {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFVideoRenderer";
}
impl IMFVideoRendererVtbl {
    pub const fn new<Impl: IMFVideoRendererImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFVideoRendererVtbl {
        unsafe extern "system" fn InitializeRenderer<Impl: IMFVideoRendererImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pvideomixer: ::windows::core::RawPtr, pvideopresenter: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InitializeRenderer(&*(&pvideomixer as *const <IMFTransform as ::windows::core::Abi>::Abi as *const <IMFTransform as ::windows::core::DefaultType>::DefaultType), &*(&pvideopresenter as *const <IMFVideoPresenter as ::windows::core::Abi>::Abi as *const <IMFVideoPresenter as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFVideoRenderer>, base.5, InitializeRenderer::<Impl, OFFSET>)
    }
}
pub trait IMFVideoRendererEffectControlImpl: Sized {
    fn OnAppServiceConnectionEstablished();
}
impl ::windows::core::RuntimeName for IMFVideoRendererEffectControl {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFVideoRendererEffectControl";
}
impl IMFVideoRendererEffectControlVtbl {
    pub const fn new<Impl: IMFVideoRendererEffectControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFVideoRendererEffectControlVtbl {
        unsafe extern "system" fn OnAppServiceConnectionEstablished<Impl: IMFVideoRendererEffectControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pappserviceconnection: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).OnAppServiceConnectionEstablished(&*(&pappserviceconnection as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFVideoRendererEffectControl>, base.5, OnAppServiceConnectionEstablished::<Impl, OFFSET>)
    }
}
pub trait IMFVideoSampleAllocatorImpl: Sized {
    fn SetDirectXManager();
    fn UninitializeSampleAllocator();
    fn InitializeSampleAllocator();
    fn AllocateSample();
}
impl ::windows::core::RuntimeName for IMFVideoSampleAllocator {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFVideoSampleAllocator";
}
impl IMFVideoSampleAllocatorVtbl {
    pub const fn new<Impl: IMFVideoSampleAllocatorImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFVideoSampleAllocatorVtbl {
        unsafe extern "system" fn SetDirectXManager<Impl: IMFVideoSampleAllocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmanager: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDirectXManager(&*(&pmanager as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UninitializeSampleAllocator<Impl: IMFVideoSampleAllocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).UninitializeSampleAllocator() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InitializeSampleAllocator<Impl: IMFVideoSampleAllocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, crequestedframes: u32, pmediatype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InitializeSampleAllocator(crequestedframes, &*(&pmediatype as *const <IMFMediaType as ::windows::core::Abi>::Abi as *const <IMFMediaType as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AllocateSample<Impl: IMFVideoSampleAllocatorImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppsample: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AllocateSample(::core::mem::transmute_copy(&ppsample)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFVideoSampleAllocator>, base.5, SetDirectXManager::<Impl, OFFSET>, UninitializeSampleAllocator::<Impl, OFFSET>, InitializeSampleAllocator::<Impl, OFFSET>, AllocateSample::<Impl, OFFSET>)
    }
}
pub trait IMFVideoSampleAllocatorCallbackImpl: Sized {
    fn SetCallback();
    fn GetFreeSampleCount();
}
impl ::windows::core::RuntimeName for IMFVideoSampleAllocatorCallback {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFVideoSampleAllocatorCallback";
}
impl IMFVideoSampleAllocatorCallbackVtbl {
    pub const fn new<Impl: IMFVideoSampleAllocatorCallbackImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFVideoSampleAllocatorCallbackVtbl {
        unsafe extern "system" fn SetCallback<Impl: IMFVideoSampleAllocatorCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pnotify: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetCallback(&*(&pnotify as *const <IMFVideoSampleAllocatorNotify as ::windows::core::Abi>::Abi as *const <IMFVideoSampleAllocatorNotify as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFreeSampleCount<Impl: IMFVideoSampleAllocatorCallbackImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plsamples: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFreeSampleCount(::core::mem::transmute_copy(&plsamples)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFVideoSampleAllocatorCallback>, base.5, SetCallback::<Impl, OFFSET>, GetFreeSampleCount::<Impl, OFFSET>)
    }
}
pub trait IMFVideoSampleAllocatorExImpl: Sized + IMFVideoSampleAllocatorImpl {
    fn InitializeSampleAllocatorEx();
}
impl ::windows::core::RuntimeName for IMFVideoSampleAllocatorEx {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFVideoSampleAllocatorEx";
}
impl IMFVideoSampleAllocatorExVtbl {
    pub const fn new<Impl: IMFVideoSampleAllocatorExImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFVideoSampleAllocatorExVtbl {
        unsafe extern "system" fn InitializeSampleAllocatorEx<Impl: IMFVideoSampleAllocatorExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, cinitialsamples: u32, cmaximumsamples: u32, pattributes: ::windows::core::RawPtr, pmediatype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).InitializeSampleAllocatorEx(cinitialsamples, cmaximumsamples, &*(&pattributes as *const <IMFAttributes as ::windows::core::Abi>::Abi as *const <IMFAttributes as ::windows::core::DefaultType>::DefaultType), &*(&pmediatype as *const <IMFMediaType as ::windows::core::Abi>::Abi as *const <IMFMediaType as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFVideoSampleAllocatorEx>, base.5, InitializeSampleAllocatorEx::<Impl, OFFSET>)
    }
}
pub trait IMFVideoSampleAllocatorNotifyImpl: Sized {
    fn NotifyRelease();
}
impl ::windows::core::RuntimeName for IMFVideoSampleAllocatorNotify {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFVideoSampleAllocatorNotify";
}
impl IMFVideoSampleAllocatorNotifyVtbl {
    pub const fn new<Impl: IMFVideoSampleAllocatorNotifyImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFVideoSampleAllocatorNotifyVtbl {
        unsafe extern "system" fn NotifyRelease<Impl: IMFVideoSampleAllocatorNotifyImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NotifyRelease() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFVideoSampleAllocatorNotify>, base.5, NotifyRelease::<Impl, OFFSET>)
    }
}
pub trait IMFVideoSampleAllocatorNotifyExImpl: Sized + IMFVideoSampleAllocatorNotifyImpl {
    fn NotifyPrune();
}
impl ::windows::core::RuntimeName for IMFVideoSampleAllocatorNotifyEx {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFVideoSampleAllocatorNotifyEx";
}
impl IMFVideoSampleAllocatorNotifyExVtbl {
    pub const fn new<Impl: IMFVideoSampleAllocatorNotifyExImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFVideoSampleAllocatorNotifyExVtbl {
        unsafe extern "system" fn NotifyPrune<Impl: IMFVideoSampleAllocatorNotifyExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, __midl__imfvideosampleallocatornotifyex0000: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).NotifyPrune(&*(&__midl__imfvideosampleallocatornotifyex0000 as *const <IMFSample as ::windows::core::Abi>::Abi as *const <IMFSample as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFVideoSampleAllocatorNotifyEx>, base.5, NotifyPrune::<Impl, OFFSET>)
    }
}
pub trait IMFVirtualCameraImpl: Sized + IMFAttributesImpl {
    fn AddDeviceSourceInfo();
    fn AddProperty();
    fn AddRegistryEntry();
    fn Start();
    fn Stop();
    fn Remove();
    fn GetMediaSource();
    fn SendCameraProperty();
    fn CreateSyncEvent();
    fn CreateSyncSemaphore();
    fn Shutdown();
}
impl ::windows::core::RuntimeName for IMFVirtualCamera {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFVirtualCamera";
}
impl IMFVirtualCameraVtbl {
    pub const fn new<Impl: IMFVirtualCameraImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFVirtualCameraVtbl {
        unsafe extern "system" fn AddDeviceSourceInfo<Impl: IMFVirtualCameraImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, devicesourceinfo: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddDeviceSourceInfo(&*(&devicesourceinfo as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddProperty<Impl: IMFVirtualCameraImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pkey: *const super::super::Devices::Properties::DEVPROPKEY, r#type: u32, pbdata: *const u8, cbdata: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddProperty(&*(&pkey as *const <super::super::Devices::Properties::DEVPROPKEY as ::windows::core::Abi>::Abi as *const <super::super::Devices::Properties::DEVPROPKEY as ::windows::core::DefaultType>::DefaultType), r#type, pbdata, cbdata) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddRegistryEntry<Impl: IMFVirtualCameraImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, entryname: super::super::Foundation::PWSTR, subkeypath: super::super::Foundation::PWSTR, dwregtype: u32, pbdata: *const u8, cbdata: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddRegistryEntry(&*(&entryname as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), &*(&subkeypath as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), dwregtype, pbdata, cbdata) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Start<Impl: IMFVirtualCameraImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Start(&*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Stop<Impl: IMFVirtualCameraImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Stop() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Remove<Impl: IMFVirtualCameraImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Remove() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaSource<Impl: IMFVirtualCameraImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ppmediasource: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetMediaSource(::core::mem::transmute_copy(&ppmediasource)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SendCameraProperty<Impl: IMFVirtualCameraImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, propertyset: *const ::windows::core::GUID, propertyid: u32, propertyflags: u32, propertypayload: *mut ::core::ffi::c_void, propertypayloadlength: u32, data: *mut ::core::ffi::c_void, datalength: u32, datawritten: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SendCameraProperty(&*(&propertyset as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), propertyid, propertyflags, &*(&propertypayload as *const <::core::ffi::c_void as ::windows::core::Abi>::Abi as *const <::core::ffi::c_void as ::windows::core::DefaultType>::DefaultType), propertypayloadlength, ::core::mem::transmute_copy(&data), datalength, ::core::mem::transmute_copy(&datawritten)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateSyncEvent<Impl: IMFVirtualCameraImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, kseventset: *const ::windows::core::GUID, kseventid: u32, kseventflags: u32, eventhandle: super::super::Foundation::HANDLE, camerasyncobject: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateSyncEvent(&*(&kseventset as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), kseventid, kseventflags, &*(&eventhandle as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&camerasyncobject)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateSyncSemaphore<Impl: IMFVirtualCameraImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, kseventset: *const ::windows::core::GUID, kseventid: u32, kseventflags: u32, semaphorehandle: super::super::Foundation::HANDLE, semaphoreadjustment: i32, camerasyncobject: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateSyncSemaphore(&*(&kseventset as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), kseventid, kseventflags, &*(&semaphorehandle as *const <super::super::Foundation::HANDLE as ::windows::core::Abi>::Abi as *const <super::super::Foundation::HANDLE as ::windows::core::DefaultType>::DefaultType), semaphoreadjustment, ::core::mem::transmute_copy(&camerasyncobject)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Shutdown<Impl: IMFVirtualCameraImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Shutdown() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFVirtualCamera>, base.5, AddDeviceSourceInfo::<Impl, OFFSET>, AddProperty::<Impl, OFFSET>, AddRegistryEntry::<Impl, OFFSET>, Start::<Impl, OFFSET>, Stop::<Impl, OFFSET>, Remove::<Impl, OFFSET>, GetMediaSource::<Impl, OFFSET>, SendCameraProperty::<Impl, OFFSET>, CreateSyncEvent::<Impl, OFFSET>, CreateSyncSemaphore::<Impl, OFFSET>, Shutdown::<Impl, OFFSET>)
    }
}
pub trait IMFWorkQueueServicesImpl: Sized {
    fn BeginRegisterTopologyWorkQueuesWithMMCSS();
    fn EndRegisterTopologyWorkQueuesWithMMCSS();
    fn BeginUnregisterTopologyWorkQueuesWithMMCSS();
    fn EndUnregisterTopologyWorkQueuesWithMMCSS();
    fn GetTopologyWorkQueueMMCSSClass();
    fn GetTopologyWorkQueueMMCSSTaskId();
    fn BeginRegisterPlatformWorkQueueWithMMCSS();
    fn EndRegisterPlatformWorkQueueWithMMCSS();
    fn BeginUnregisterPlatformWorkQueueWithMMCSS();
    fn EndUnregisterPlatformWorkQueueWithMMCSS();
    fn GetPlaftormWorkQueueMMCSSClass();
    fn GetPlatformWorkQueueMMCSSTaskId();
}
impl ::windows::core::RuntimeName for IMFWorkQueueServices {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFWorkQueueServices";
}
impl IMFWorkQueueServicesVtbl {
    pub const fn new<Impl: IMFWorkQueueServicesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFWorkQueueServicesVtbl {
        unsafe extern "system" fn BeginRegisterTopologyWorkQueuesWithMMCSS<Impl: IMFWorkQueueServicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginRegisterTopologyWorkQueuesWithMMCSS(&*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType), &*(&pstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndRegisterTopologyWorkQueuesWithMMCSS<Impl: IMFWorkQueueServicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndRegisterTopologyWorkQueuesWithMMCSS(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginUnregisterTopologyWorkQueuesWithMMCSS<Impl: IMFWorkQueueServicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginUnregisterTopologyWorkQueuesWithMMCSS(&*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType), &*(&pstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndUnregisterTopologyWorkQueuesWithMMCSS<Impl: IMFWorkQueueServicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndUnregisterTopologyWorkQueuesWithMMCSS(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTopologyWorkQueueMMCSSClass<Impl: IMFWorkQueueServicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwtopologyworkqueueid: u32, pwszclass: super::super::Foundation::PWSTR, pcchclass: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTopologyWorkQueueMMCSSClass(dwtopologyworkqueueid, ::core::mem::transmute_copy(&pwszclass), pcchclass) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTopologyWorkQueueMMCSSTaskId<Impl: IMFWorkQueueServicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwtopologyworkqueueid: u32, pdwtaskid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTopologyWorkQueueMMCSSTaskId(dwtopologyworkqueueid, ::core::mem::transmute_copy(&pdwtaskid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginRegisterPlatformWorkQueueWithMMCSS<Impl: IMFWorkQueueServicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwplatformworkqueue: u32, wszclass: super::super::Foundation::PWSTR, dwtaskid: u32, pcallback: ::windows::core::RawPtr, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginRegisterPlatformWorkQueueWithMMCSS(
                dwplatformworkqueue,
                &*(&wszclass as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                dwtaskid,
                &*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType),
                &*(&pstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndRegisterPlatformWorkQueueWithMMCSS<Impl: IMFWorkQueueServicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, pdwtaskid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndRegisterPlatformWorkQueueWithMMCSS(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pdwtaskid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginUnregisterPlatformWorkQueueWithMMCSS<Impl: IMFWorkQueueServicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwplatformworkqueue: u32, pcallback: ::windows::core::RawPtr, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginUnregisterPlatformWorkQueueWithMMCSS(dwplatformworkqueue, &*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType), &*(&pstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EndUnregisterPlatformWorkQueueWithMMCSS<Impl: IMFWorkQueueServicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).EndUnregisterPlatformWorkQueueWithMMCSS(&*(&presult as *const <IMFAsyncResult as ::windows::core::Abi>::Abi as *const <IMFAsyncResult as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPlaftormWorkQueueMMCSSClass<Impl: IMFWorkQueueServicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwplatformworkqueueid: u32, pwszclass: super::super::Foundation::PWSTR, pcchclass: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPlaftormWorkQueueMMCSSClass(dwplatformworkqueueid, ::core::mem::transmute_copy(&pwszclass), pcchclass) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPlatformWorkQueueMMCSSTaskId<Impl: IMFWorkQueueServicesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwplatformworkqueueid: u32, pdwtaskid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPlatformWorkQueueMMCSSTaskId(dwplatformworkqueueid, ::core::mem::transmute_copy(&pdwtaskid)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(
            base.0,
            base.1,
            base.2,
            base.3,
            ::windows::core::GetRuntimeClassName::<IMFWorkQueueServices>,
            base.5,
            BeginRegisterTopologyWorkQueuesWithMMCSS::<Impl, OFFSET>,
            EndRegisterTopologyWorkQueuesWithMMCSS::<Impl, OFFSET>,
            BeginUnregisterTopologyWorkQueuesWithMMCSS::<Impl, OFFSET>,
            EndUnregisterTopologyWorkQueuesWithMMCSS::<Impl, OFFSET>,
            GetTopologyWorkQueueMMCSSClass::<Impl, OFFSET>,
            GetTopologyWorkQueueMMCSSTaskId::<Impl, OFFSET>,
            BeginRegisterPlatformWorkQueueWithMMCSS::<Impl, OFFSET>,
            EndRegisterPlatformWorkQueueWithMMCSS::<Impl, OFFSET>,
            BeginUnregisterPlatformWorkQueueWithMMCSS::<Impl, OFFSET>,
            EndUnregisterPlatformWorkQueueWithMMCSS::<Impl, OFFSET>,
            GetPlaftormWorkQueueMMCSSClass::<Impl, OFFSET>,
            GetPlatformWorkQueueMMCSSTaskId::<Impl, OFFSET>,
        )
    }
}
pub trait IMFWorkQueueServicesExImpl: Sized + IMFWorkQueueServicesImpl {
    fn GetTopologyWorkQueueMMCSSPriority();
    fn BeginRegisterPlatformWorkQueueWithMMCSSEx();
    fn GetPlatformWorkQueueMMCSSPriority();
}
impl ::windows::core::RuntimeName for IMFWorkQueueServicesEx {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IMFWorkQueueServicesEx";
}
impl IMFWorkQueueServicesExVtbl {
    pub const fn new<Impl: IMFWorkQueueServicesExImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IMFWorkQueueServicesExVtbl {
        unsafe extern "system" fn GetTopologyWorkQueueMMCSSPriority<Impl: IMFWorkQueueServicesExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwtopologyworkqueueid: u32, plpriority: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTopologyWorkQueueMMCSSPriority(dwtopologyworkqueueid, ::core::mem::transmute_copy(&plpriority)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginRegisterPlatformWorkQueueWithMMCSSEx<Impl: IMFWorkQueueServicesExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwplatformworkqueue: u32, wszclass: super::super::Foundation::PWSTR, dwtaskid: u32, lpriority: i32, pcallback: ::windows::core::RawPtr, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).BeginRegisterPlatformWorkQueueWithMMCSSEx(
                dwplatformworkqueue,
                &*(&wszclass as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType),
                dwtaskid,
                lpriority,
                &*(&pcallback as *const <IMFAsyncCallback as ::windows::core::Abi>::Abi as *const <IMFAsyncCallback as ::windows::core::DefaultType>::DefaultType),
                &*(&pstate as *const <::windows::core::IUnknown as ::windows::core::Abi>::Abi as *const <::windows::core::IUnknown as ::windows::core::DefaultType>::DefaultType),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPlatformWorkQueueMMCSSPriority<Impl: IMFWorkQueueServicesExImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwplatformworkqueueid: u32, plpriority: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPlatformWorkQueueMMCSSPriority(dwplatformworkqueueid, ::core::mem::transmute_copy(&plpriority)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IMFWorkQueueServicesEx>, base.5, GetTopologyWorkQueueMMCSSPriority::<Impl, OFFSET>, BeginRegisterPlatformWorkQueueWithMMCSSEx::<Impl, OFFSET>, GetPlatformWorkQueueMMCSSPriority::<Impl, OFFSET>)
    }
}
pub trait IOPMVideoOutputImpl: Sized {
    fn StartInitialization();
    fn FinishInitialization();
    fn GetInformation();
    fn COPPCompatibleGetInformation();
    fn Configure();
}
impl ::windows::core::RuntimeName for IOPMVideoOutput {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IOPMVideoOutput";
}
impl IOPMVideoOutputVtbl {
    pub const fn new<Impl: IOPMVideoOutputImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IOPMVideoOutputVtbl {
        unsafe extern "system" fn StartInitialization<Impl: IOPMVideoOutputImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prnrandomnumber: *mut OPM_RANDOM_NUMBER, ppbcertificate: *mut *mut u8, pulcertificatelength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).StartInitialization(::core::mem::transmute_copy(&prnrandomnumber), ::core::mem::transmute_copy(&ppbcertificate), ::core::mem::transmute_copy(&pulcertificatelength)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn FinishInitialization<Impl: IOPMVideoOutputImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pparameters: *const OPM_ENCRYPTED_INITIALIZATION_PARAMETERS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).FinishInitialization(&*(&pparameters as *const <OPM_ENCRYPTED_INITIALIZATION_PARAMETERS as ::windows::core::Abi>::Abi as *const <OPM_ENCRYPTED_INITIALIZATION_PARAMETERS as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInformation<Impl: IOPMVideoOutputImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pparameters: *const OPM_GET_INFO_PARAMETERS, prequestedinformation: *mut OPM_REQUESTED_INFORMATION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetInformation(&*(&pparameters as *const <OPM_GET_INFO_PARAMETERS as ::windows::core::Abi>::Abi as *const <OPM_GET_INFO_PARAMETERS as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&prequestedinformation)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn COPPCompatibleGetInformation<Impl: IOPMVideoOutputImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pparameters: *const OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS, prequestedinformation: *mut OPM_REQUESTED_INFORMATION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).COPPCompatibleGetInformation(&*(&pparameters as *const <OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS as ::windows::core::Abi>::Abi as *const <OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&prequestedinformation)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Configure<Impl: IOPMVideoOutputImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pparameters: *const OPM_CONFIGURE_PARAMETERS, uladditionalparameterssize: u32, pbadditionalparameters: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Configure(&*(&pparameters as *const <OPM_CONFIGURE_PARAMETERS as ::windows::core::Abi>::Abi as *const <OPM_CONFIGURE_PARAMETERS as ::windows::core::DefaultType>::DefaultType), uladditionalparameterssize, pbadditionalparameters) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IOPMVideoOutput>, base.5, StartInitialization::<Impl, OFFSET>, FinishInitialization::<Impl, OFFSET>, GetInformation::<Impl, OFFSET>, COPPCompatibleGetInformation::<Impl, OFFSET>, Configure::<Impl, OFFSET>)
    }
}
pub trait IPlayToControlImpl: Sized {
    fn Connect();
    fn Disconnect();
}
impl ::windows::core::RuntimeName for IPlayToControl {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IPlayToControl";
}
impl IPlayToControlVtbl {
    pub const fn new<Impl: IPlayToControlImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPlayToControlVtbl {
        unsafe extern "system" fn Connect<Impl: IPlayToControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pfactory: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Connect(&*(&pfactory as *const <IMFSharingEngineClassFactory as ::windows::core::Abi>::Abi as *const <IMFSharingEngineClassFactory as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Disconnect<Impl: IPlayToControlImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Disconnect() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPlayToControl>, base.5, Connect::<Impl, OFFSET>, Disconnect::<Impl, OFFSET>)
    }
}
pub trait IPlayToControlWithCapabilitiesImpl: Sized + IPlayToControlImpl {
    fn GetCapabilities();
}
impl ::windows::core::RuntimeName for IPlayToControlWithCapabilities {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IPlayToControlWithCapabilities";
}
impl IPlayToControlWithCapabilitiesVtbl {
    pub const fn new<Impl: IPlayToControlWithCapabilitiesImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPlayToControlWithCapabilitiesVtbl {
        unsafe extern "system" fn GetCapabilities<Impl: IPlayToControlWithCapabilitiesImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pcapabilities: *mut PLAYTO_SOURCE_CREATEFLAGS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCapabilities(::core::mem::transmute_copy(&pcapabilities)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPlayToControlWithCapabilities>, base.5, GetCapabilities::<Impl, OFFSET>)
    }
}
pub trait IPlayToSourceClassFactoryImpl: Sized {
    fn CreateInstance();
}
impl ::windows::core::RuntimeName for IPlayToSourceClassFactory {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IPlayToSourceClassFactory";
}
impl IPlayToSourceClassFactoryVtbl {
    pub const fn new<Impl: IPlayToSourceClassFactoryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IPlayToSourceClassFactoryVtbl {
        unsafe extern "system" fn CreateInstance<Impl: IPlayToSourceClassFactoryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwflags: u32, pcontrol: ::windows::core::RawPtr, ppsource: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).CreateInstance(dwflags, &*(&pcontrol as *const <IPlayToControl as ::windows::core::Abi>::Abi as *const <IPlayToControl as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&ppsource)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IPlayToSourceClassFactory>, base.5, CreateInstance::<Impl, OFFSET>)
    }
}
pub trait ITocImpl: Sized {
    fn SetDescriptor();
    fn GetDescriptor();
    fn SetDescription();
    fn GetDescription();
    fn SetContext();
    fn GetContext();
    fn GetEntryListCount();
    fn GetEntryListByIndex();
    fn AddEntryList();
    fn AddEntryListByIndex();
    fn RemoveEntryListByIndex();
}
impl ::windows::core::RuntimeName for IToc {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IToc";
}
impl ITocVtbl {
    pub const fn new<Impl: ITocImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITocVtbl {
        unsafe extern "system" fn SetDescriptor<Impl: ITocImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdescriptor: *mut TOC_DESCRIPTOR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDescriptor(&*(&pdescriptor as *const <TOC_DESCRIPTOR as ::windows::core::Abi>::Abi as *const <TOC_DESCRIPTOR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDescriptor<Impl: ITocImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdescriptor: *mut TOC_DESCRIPTOR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDescriptor(&*(&pdescriptor as *const <TOC_DESCRIPTOR as ::windows::core::Abi>::Abi as *const <TOC_DESCRIPTOR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescription<Impl: ITocImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwszdescription: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDescription(&*(&pwszdescription as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDescription<Impl: ITocImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwdescriptionsize: *mut u16, pwszdescription: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDescription(pwdescriptionsize, ::core::mem::transmute_copy(&pwszdescription)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContext<Impl: ITocImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwcontextsize: u32, pbtcontext: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetContext(dwcontextsize, pbtcontext) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetContext<Impl: ITocImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwcontextsize: *mut u32, pbtcontext: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetContext(pdwcontextsize, pbtcontext) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEntryListCount<Impl: ITocImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwcount: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEntryListCount(pwcount) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEntryListByIndex<Impl: ITocImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wentrylistindex: u16, ppentrylist: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEntryListByIndex(wentrylistindex, ::core::mem::transmute_copy(&ppentrylist)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddEntryList<Impl: ITocImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pentrylist: ::windows::core::RawPtr, pwentrylistindex: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddEntryList(&*(&pentrylist as *const <ITocEntryList as ::windows::core::Abi>::Abi as *const <ITocEntryList as ::windows::core::DefaultType>::DefaultType), pwentrylistindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddEntryListByIndex<Impl: ITocImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wentrylistindex: u16, pentrylist: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddEntryListByIndex(wentrylistindex, &*(&pentrylist as *const <ITocEntryList as ::windows::core::Abi>::Abi as *const <ITocEntryList as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveEntryListByIndex<Impl: ITocImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, wentrylistindex: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveEntryListByIndex(wentrylistindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IToc>, base.5, SetDescriptor::<Impl, OFFSET>, GetDescriptor::<Impl, OFFSET>, SetDescription::<Impl, OFFSET>, GetDescription::<Impl, OFFSET>, SetContext::<Impl, OFFSET>, GetContext::<Impl, OFFSET>, GetEntryListCount::<Impl, OFFSET>, GetEntryListByIndex::<Impl, OFFSET>, AddEntryList::<Impl, OFFSET>, AddEntryListByIndex::<Impl, OFFSET>, RemoveEntryListByIndex::<Impl, OFFSET>)
    }
}
pub trait ITocCollectionImpl: Sized {
    fn GetEntryCount();
    fn GetEntryByIndex();
    fn AddEntry();
    fn AddEntryByIndex();
    fn RemoveEntryByIndex();
}
impl ::windows::core::RuntimeName for ITocCollection {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ITocCollection";
}
impl ITocCollectionVtbl {
    pub const fn new<Impl: ITocCollectionImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITocCollectionVtbl {
        unsafe extern "system" fn GetEntryCount<Impl: ITocCollectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwentrycount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEntryCount(pdwentrycount) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEntryByIndex<Impl: ITocCollectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwentryindex: u32, pptoc: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEntryByIndex(dwentryindex, ::core::mem::transmute_copy(&pptoc)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddEntry<Impl: ITocCollectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ptoc: ::windows::core::RawPtr, pdwentryindex: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddEntry(&*(&ptoc as *const <IToc as ::windows::core::Abi>::Abi as *const <IToc as ::windows::core::DefaultType>::DefaultType), pdwentryindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddEntryByIndex<Impl: ITocCollectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwentryindex: u32, ptoc: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddEntryByIndex(dwentryindex, &*(&ptoc as *const <IToc as ::windows::core::Abi>::Abi as *const <IToc as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveEntryByIndex<Impl: ITocCollectionImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwentryindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveEntryByIndex(dwentryindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITocCollection>, base.5, GetEntryCount::<Impl, OFFSET>, GetEntryByIndex::<Impl, OFFSET>, AddEntry::<Impl, OFFSET>, AddEntryByIndex::<Impl, OFFSET>, RemoveEntryByIndex::<Impl, OFFSET>)
    }
}
pub trait ITocEntryImpl: Sized {
    fn SetTitle();
    fn GetTitle();
    fn SetDescriptor();
    fn GetDescriptor();
    fn SetSubEntries();
    fn GetSubEntries();
    fn SetDescriptionData();
    fn GetDescriptionData();
}
impl ::windows::core::RuntimeName for ITocEntry {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ITocEntry";
}
impl ITocEntryVtbl {
    pub const fn new<Impl: ITocEntryImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITocEntryVtbl {
        unsafe extern "system" fn SetTitle<Impl: ITocEntryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwsztitle: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetTitle(&*(&pwsztitle as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTitle<Impl: ITocEntryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwtitlesize: *mut u16, pwsztitle: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTitle(pwtitlesize, ::core::mem::transmute_copy(&pwsztitle)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescriptor<Impl: ITocEntryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdescriptor: *mut TOC_ENTRY_DESCRIPTOR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDescriptor(&*(&pdescriptor as *const <TOC_ENTRY_DESCRIPTOR as ::windows::core::Abi>::Abi as *const <TOC_ENTRY_DESCRIPTOR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDescriptor<Impl: ITocEntryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdescriptor: *mut TOC_ENTRY_DESCRIPTOR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDescriptor(&*(&pdescriptor as *const <TOC_ENTRY_DESCRIPTOR as ::windows::core::Abi>::Abi as *const <TOC_ENTRY_DESCRIPTOR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSubEntries<Impl: ITocEntryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwnumsubentries: u32, pwsubentryindices: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetSubEntries(dwnumsubentries, pwsubentryindices) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSubEntries<Impl: ITocEntryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwnumsubentries: *mut u32, pwsubentryindices: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetSubEntries(pdwnumsubentries, pwsubentryindices) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDescriptionData<Impl: ITocEntryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwdescriptiondatasize: u32, pbtdescriptiondata: *mut u8, pguidtype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetDescriptionData(dwdescriptiondatasize, pbtdescriptiondata, &*(&pguidtype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDescriptionData<Impl: ITocEntryImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwdescriptiondatasize: *mut u32, pbtdescriptiondata: *mut u8, pguidtype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDescriptionData(pdwdescriptiondatasize, pbtdescriptiondata, &*(&pguidtype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITocEntry>, base.5, SetTitle::<Impl, OFFSET>, GetTitle::<Impl, OFFSET>, SetDescriptor::<Impl, OFFSET>, GetDescriptor::<Impl, OFFSET>, SetSubEntries::<Impl, OFFSET>, GetSubEntries::<Impl, OFFSET>, SetDescriptionData::<Impl, OFFSET>, GetDescriptionData::<Impl, OFFSET>)
    }
}
pub trait ITocEntryListImpl: Sized {
    fn GetEntryCount();
    fn GetEntryByIndex();
    fn AddEntry();
    fn AddEntryByIndex();
    fn RemoveEntryByIndex();
}
impl ::windows::core::RuntimeName for ITocEntryList {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ITocEntryList";
}
impl ITocEntryListVtbl {
    pub const fn new<Impl: ITocEntryListImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITocEntryListVtbl {
        unsafe extern "system" fn GetEntryCount<Impl: ITocEntryListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwentrycount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEntryCount(pdwentrycount) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEntryByIndex<Impl: ITocEntryListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwentryindex: u32, ppentry: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetEntryByIndex(dwentryindex, ::core::mem::transmute_copy(&ppentry)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddEntry<Impl: ITocEntryListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pentry: ::windows::core::RawPtr, pdwentryindex: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddEntry(&*(&pentry as *const <ITocEntry as ::windows::core::Abi>::Abi as *const <ITocEntry as ::windows::core::DefaultType>::DefaultType), pdwentryindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddEntryByIndex<Impl: ITocEntryListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwentryindex: u32, pentry: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddEntryByIndex(dwentryindex, &*(&pentry as *const <ITocEntry as ::windows::core::Abi>::Abi as *const <ITocEntry as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveEntryByIndex<Impl: ITocEntryListImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwentryindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveEntryByIndex(dwentryindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITocEntryList>, base.5, GetEntryCount::<Impl, OFFSET>, GetEntryByIndex::<Impl, OFFSET>, AddEntry::<Impl, OFFSET>, AddEntryByIndex::<Impl, OFFSET>, RemoveEntryByIndex::<Impl, OFFSET>)
    }
}
pub trait ITocParserImpl: Sized {
    fn Init();
    fn GetTocCount();
    fn GetTocByIndex();
    fn GetTocByType();
    fn AddToc();
    fn RemoveTocByIndex();
    fn RemoveTocByType();
    fn Commit();
}
impl ::windows::core::RuntimeName for ITocParser {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.ITocParser";
}
impl ITocParserVtbl {
    pub const fn new<Impl: ITocParserImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> ITocParserVtbl {
        unsafe extern "system" fn Init<Impl: ITocParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pwszfilename: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Init(&*(&pwszfilename as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTocCount<Impl: ITocParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, pdwtoccount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTocCount(enumtocpostype, pdwtoccount) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTocByIndex<Impl: ITocParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, dwtocindex: u32, pptoc: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTocByIndex(enumtocpostype, dwtocindex, ::core::mem::transmute_copy(&pptoc)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTocByType<Impl: ITocParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, guidtoctype: ::windows::core::GUID, pptocs: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetTocByType(enumtocpostype, &*(&guidtoctype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), ::core::mem::transmute_copy(&pptocs)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddToc<Impl: ITocParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, ptoc: ::windows::core::RawPtr, pdwtocindex: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).AddToc(enumtocpostype, &*(&ptoc as *const <IToc as ::windows::core::Abi>::Abi as *const <IToc as ::windows::core::DefaultType>::DefaultType), pdwtocindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTocByIndex<Impl: ITocParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, dwtocindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveTocByIndex(enumtocpostype, dwtocindex) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTocByType<Impl: ITocParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, guidtoctype: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).RemoveTocByType(enumtocpostype, &*(&guidtoctype as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Commit<Impl: ITocParserImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).Commit() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<ITocParser>, base.5, Init::<Impl, OFFSET>, GetTocCount::<Impl, OFFSET>, GetTocByIndex::<Impl, OFFSET>, GetTocByType::<Impl, OFFSET>, AddToc::<Impl, OFFSET>, RemoveTocByIndex::<Impl, OFFSET>, RemoveTocByType::<Impl, OFFSET>, Commit::<Impl, OFFSET>)
    }
}
pub trait IValidateBindingImpl: Sized {
    fn GetIdentifier();
}
impl ::windows::core::RuntimeName for IValidateBinding {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IValidateBinding";
}
impl IValidateBindingVtbl {
    pub const fn new<Impl: IValidateBindingImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IValidateBindingVtbl {
        unsafe extern "system" fn GetIdentifier<Impl: IValidateBindingImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidlicensorid: ::windows::core::GUID, pbephemeron: *const u8, cbephemeron: u32, ppbblobvalidationid: *mut *mut u8, pcbblobsize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetIdentifier(&*(&guidlicensorid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType), pbephemeron, cbephemeron, ::core::mem::transmute_copy(&ppbblobvalidationid), ::core::mem::transmute_copy(&pcbblobsize)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IValidateBinding>, base.5, GetIdentifier::<Impl, OFFSET>)
    }
}
pub trait IWMCodecLeakyBucketImpl: Sized {
    fn SetBufferSizeBits();
    fn GetBufferSizeBits();
    fn SetBufferFullnessBits();
    fn GetBufferFullnessBits();
}
impl ::windows::core::RuntimeName for IWMCodecLeakyBucket {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IWMCodecLeakyBucket";
}
impl IWMCodecLeakyBucketVtbl {
    pub const fn new<Impl: IWMCodecLeakyBucketImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWMCodecLeakyBucketVtbl {
        unsafe extern "system" fn SetBufferSizeBits<Impl: IWMCodecLeakyBucketImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulbuffersize: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBufferSizeBits(ulbuffersize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBufferSizeBits<Impl: IWMCodecLeakyBucketImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulbuffersize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBufferSizeBits(pulbuffersize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBufferFullnessBits<Impl: IWMCodecLeakyBucketImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, ulbufferfullness: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetBufferFullnessBits(ulbufferfullness) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBufferFullnessBits<Impl: IWMCodecLeakyBucketImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pulbufferfullness: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetBufferFullnessBits(pulbufferfullness) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWMCodecLeakyBucket>, base.5, SetBufferSizeBits::<Impl, OFFSET>, GetBufferSizeBits::<Impl, OFFSET>, SetBufferFullnessBits::<Impl, OFFSET>, GetBufferFullnessBits::<Impl, OFFSET>)
    }
}
pub trait IWMCodecOutputTimestampImpl: Sized {
    fn GetNextOutputTime();
}
impl ::windows::core::RuntimeName for IWMCodecOutputTimestamp {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IWMCodecOutputTimestamp";
}
impl IWMCodecOutputTimestampVtbl {
    pub const fn new<Impl: IWMCodecOutputTimestampImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWMCodecOutputTimestampVtbl {
        unsafe extern "system" fn GetNextOutputTime<Impl: IWMCodecOutputTimestampImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, prttime: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetNextOutputTime(prttime) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWMCodecOutputTimestamp>, base.5, GetNextOutputTime::<Impl, OFFSET>)
    }
}
pub trait IWMCodecPrivateDataImpl: Sized {
    fn SetPartialOutputType();
    fn GetPrivateData();
}
impl ::windows::core::RuntimeName for IWMCodecPrivateData {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IWMCodecPrivateData";
}
impl IWMCodecPrivateDataVtbl {
    pub const fn new<Impl: IWMCodecPrivateDataImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWMCodecPrivateDataVtbl {
        unsafe extern "system" fn SetPartialOutputType<Impl: IWMCodecPrivateDataImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetPartialOutputType(&*(&pmt as *const <super::DxMediaObjects::DMO_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <super::DxMediaObjects::DMO_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPrivateData<Impl: IWMCodecPrivateDataImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbdata: *mut u8, pcbdata: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetPrivateData(pbdata, pcbdata) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWMCodecPrivateData>, base.5, SetPartialOutputType::<Impl, OFFSET>, GetPrivateData::<Impl, OFFSET>)
    }
}
pub trait IWMCodecPropsImpl: Sized {
    fn GetFormatProp();
    fn GetCodecProp();
}
impl ::windows::core::RuntimeName for IWMCodecProps {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IWMCodecProps";
}
impl IWMCodecPropsVtbl {
    pub const fn new<Impl: IWMCodecPropsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWMCodecPropsVtbl {
        unsafe extern "system" fn GetFormatProp<Impl: IWMCodecPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE, pszname: super::super::Foundation::PWSTR, ptype: *mut WMT_PROP_DATATYPE, pvalue: *mut u8, pdwsize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFormatProp(&*(&pmt as *const <super::DxMediaObjects::DMO_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <super::DxMediaObjects::DMO_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType), &*(&pszname as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), ptype, pvalue, pdwsize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCodecProp<Impl: IWMCodecPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, dwformat: u32, pszname: super::super::Foundation::PWSTR, ptype: *mut WMT_PROP_DATATYPE, pvalue: *mut u8, pdwsize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetCodecProp(dwformat, &*(&pszname as *const <super::super::Foundation::PWSTR as ::windows::core::Abi>::Abi as *const <super::super::Foundation::PWSTR as ::windows::core::DefaultType>::DefaultType), ptype, pvalue, pdwsize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWMCodecProps>, base.5, GetFormatProp::<Impl, OFFSET>, GetCodecProp::<Impl, OFFSET>)
    }
}
pub trait IWMCodecStringsImpl: Sized {
    fn GetName();
    fn GetDescription();
}
impl ::windows::core::RuntimeName for IWMCodecStrings {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IWMCodecStrings";
}
impl IWMCodecStringsVtbl {
    pub const fn new<Impl: IWMCodecStringsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWMCodecStringsVtbl {
        unsafe extern "system" fn GetName<Impl: IWMCodecStringsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE, cchlength: u32, szname: super::super::Foundation::PWSTR, pcchlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetName(&*(&pmt as *const <super::DxMediaObjects::DMO_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <super::DxMediaObjects::DMO_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType), cchlength, ::core::mem::transmute_copy(&szname), pcchlength) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDescription<Impl: IWMCodecStringsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE, cchlength: u32, szdescription: super::super::Foundation::PWSTR, pcchlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetDescription(&*(&pmt as *const <super::DxMediaObjects::DMO_MEDIA_TYPE as ::windows::core::Abi>::Abi as *const <super::DxMediaObjects::DMO_MEDIA_TYPE as ::windows::core::DefaultType>::DefaultType), cchlength, ::core::mem::transmute_copy(&szdescription), pcchlength) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWMCodecStrings>, base.5, GetName::<Impl, OFFSET>, GetDescription::<Impl, OFFSET>)
    }
}
pub trait IWMColorConvPropsImpl: Sized {
    fn SetMode();
    fn SetFullCroppingParam();
}
impl ::windows::core::RuntimeName for IWMColorConvProps {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IWMColorConvProps";
}
impl IWMColorConvPropsVtbl {
    pub const fn new<Impl: IWMColorConvPropsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWMColorConvPropsVtbl {
        unsafe extern "system" fn SetMode<Impl: IWMColorConvPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lmode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetMode(lmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFullCroppingParam<Impl: IWMColorConvPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lsrccropleft: i32, lsrccroptop: i32, ldstcropleft: i32, ldstcroptop: i32, lcropwidth: i32, lcropheight: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFullCroppingParam(lsrccropleft, lsrccroptop, ldstcropleft, ldstcroptop, lcropwidth, lcropheight) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWMColorConvProps>, base.5, SetMode::<Impl, OFFSET>, SetFullCroppingParam::<Impl, OFFSET>)
    }
}
pub trait IWMColorLegalizerPropsImpl: Sized {
    fn SetColorLegalizerQuality();
}
impl ::windows::core::RuntimeName for IWMColorLegalizerProps {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IWMColorLegalizerProps";
}
impl IWMColorLegalizerPropsVtbl {
    pub const fn new<Impl: IWMColorLegalizerPropsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWMColorLegalizerPropsVtbl {
        unsafe extern "system" fn SetColorLegalizerQuality<Impl: IWMColorLegalizerPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lquality: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetColorLegalizerQuality(lquality) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWMColorLegalizerProps>, base.5, SetColorLegalizerQuality::<Impl, OFFSET>)
    }
}
pub trait IWMFrameInterpPropsImpl: Sized {
    fn SetFrameRateIn();
    fn SetFrameRateOut();
    fn SetFrameInterpEnabled();
    fn SetComplexityLevel();
}
impl ::windows::core::RuntimeName for IWMFrameInterpProps {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IWMFrameInterpProps";
}
impl IWMFrameInterpPropsVtbl {
    pub const fn new<Impl: IWMFrameInterpPropsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWMFrameInterpPropsVtbl {
        unsafe extern "system" fn SetFrameRateIn<Impl: IWMFrameInterpPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lframerate: i32, lscale: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFrameRateIn(lframerate, lscale) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFrameRateOut<Impl: IWMFrameInterpPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lframerate: i32, lscale: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFrameRateOut(lframerate, lscale) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFrameInterpEnabled<Impl: IWMFrameInterpPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, bfienabled: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFrameInterpEnabled(&*(&bfienabled as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetComplexityLevel<Impl: IWMFrameInterpPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, icomplexity: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetComplexityLevel(icomplexity) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWMFrameInterpProps>, base.5, SetFrameRateIn::<Impl, OFFSET>, SetFrameRateOut::<Impl, OFFSET>, SetFrameInterpEnabled::<Impl, OFFSET>, SetComplexityLevel::<Impl, OFFSET>)
    }
}
pub trait IWMInterlacePropsImpl: Sized {
    fn SetProcessType();
    fn SetInitInverseTeleCinePattern();
    fn SetLastFrame();
}
impl ::windows::core::RuntimeName for IWMInterlaceProps {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IWMInterlaceProps";
}
impl IWMInterlacePropsVtbl {
    pub const fn new<Impl: IWMInterlacePropsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWMInterlacePropsVtbl {
        unsafe extern "system" fn SetProcessType<Impl: IWMInterlacePropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, iprocesstype: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetProcessType(iprocesstype) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInitInverseTeleCinePattern<Impl: IWMInterlacePropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, iinitpattern: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetInitInverseTeleCinePattern(iinitpattern) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLastFrame<Impl: IWMInterlacePropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetLastFrame() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWMInterlaceProps>, base.5, SetProcessType::<Impl, OFFSET>, SetInitInverseTeleCinePattern::<Impl, OFFSET>, SetLastFrame::<Impl, OFFSET>)
    }
}
pub trait IWMResamplerPropsImpl: Sized {
    fn SetHalfFilterLength();
    fn SetUserChannelMtx();
}
impl ::windows::core::RuntimeName for IWMResamplerProps {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IWMResamplerProps";
}
impl IWMResamplerPropsVtbl {
    pub const fn new<Impl: IWMResamplerPropsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWMResamplerPropsVtbl {
        unsafe extern "system" fn SetHalfFilterLength<Impl: IWMResamplerPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lhalffilterlen: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetHalfFilterLength(lhalffilterlen) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUserChannelMtx<Impl: IWMResamplerPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, userchannelmtx: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetUserChannelMtx(userchannelmtx) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWMResamplerProps>, base.5, SetHalfFilterLength::<Impl, OFFSET>, SetUserChannelMtx::<Impl, OFFSET>)
    }
}
pub trait IWMResizerPropsImpl: Sized {
    fn SetResizerQuality();
    fn SetInterlaceMode();
    fn SetClipRegion();
    fn SetFullCropRegion();
    fn GetFullCropRegion();
}
impl ::windows::core::RuntimeName for IWMResizerProps {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IWMResizerProps";
}
impl IWMResizerPropsVtbl {
    pub const fn new<Impl: IWMResizerPropsImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWMResizerPropsVtbl {
        unsafe extern "system" fn SetResizerQuality<Impl: IWMResizerPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lquality: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetResizerQuality(lquality) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInterlaceMode<Impl: IWMResizerPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lmode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetInterlaceMode(lmode) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetClipRegion<Impl: IWMResizerPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lcliporixsrc: i32, lcliporiysrc: i32, lclipwidthsrc: i32, lclipheightsrc: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetClipRegion(lcliporixsrc, lcliporiysrc, lclipwidthsrc, lclipheightsrc) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFullCropRegion<Impl: IWMResizerPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lcliporixsrc: i32, lcliporiysrc: i32, lclipwidthsrc: i32, lclipheightsrc: i32, lcliporixdst: i32, lcliporiydst: i32, lclipwidthdst: i32, lclipheightdst: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetFullCropRegion(lcliporixsrc, lcliporiysrc, lclipwidthsrc, lclipheightsrc, lcliporixdst, lcliporiydst, lclipwidthdst, lclipheightdst) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFullCropRegion<Impl: IWMResizerPropsImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lcliporixsrc: *mut i32, lcliporiysrc: *mut i32, lclipwidthsrc: *mut i32, lclipheightsrc: *mut i32, lcliporixdst: *mut i32, lcliporiydst: *mut i32, lclipwidthdst: *mut i32, lclipheightdst: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetFullCropRegion(lcliporixsrc, lcliporiysrc, lclipwidthsrc, lclipheightsrc, lcliporixdst, lcliporiydst, lclipwidthdst, lclipheightdst) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWMResizerProps>, base.5, SetResizerQuality::<Impl, OFFSET>, SetInterlaceMode::<Impl, OFFSET>, SetClipRegion::<Impl, OFFSET>, SetFullCropRegion::<Impl, OFFSET>, GetFullCropRegion::<Impl, OFFSET>)
    }
}
pub trait IWMSampleExtensionSupportImpl: Sized {
    fn SetUseSampleExtensions();
}
impl ::windows::core::RuntimeName for IWMSampleExtensionSupport {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IWMSampleExtensionSupport";
}
impl IWMSampleExtensionSupportVtbl {
    pub const fn new<Impl: IWMSampleExtensionSupportImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWMSampleExtensionSupportVtbl {
        unsafe extern "system" fn SetUseSampleExtensions<Impl: IWMSampleExtensionSupportImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, fuseextensions: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetUseSampleExtensions(&*(&fuseextensions as *const <super::super::Foundation::BOOL as ::windows::core::Abi>::Abi as *const <super::super::Foundation::BOOL as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWMSampleExtensionSupport>, base.5, SetUseSampleExtensions::<Impl, OFFSET>)
    }
}
pub trait IWMValidateImpl: Sized {
    fn SetIdentifier();
}
impl ::windows::core::RuntimeName for IWMValidate {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IWMValidate";
}
impl IWMValidateVtbl {
    pub const fn new<Impl: IWMValidateImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWMValidateVtbl {
        unsafe extern "system" fn SetIdentifier<Impl: IWMValidateImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, guidvalidationid: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetIdentifier(&*(&guidvalidationid as *const <::windows::core::GUID as ::windows::core::Abi>::Abi as *const <::windows::core::GUID as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWMValidate>, base.5, SetIdentifier::<Impl, OFFSET>)
    }
}
pub trait IWMVideoDecoderHurryupImpl: Sized {
    fn SetHurryup();
    fn GetHurryup();
}
impl ::windows::core::RuntimeName for IWMVideoDecoderHurryup {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IWMVideoDecoderHurryup";
}
impl IWMVideoDecoderHurryupVtbl {
    pub const fn new<Impl: IWMVideoDecoderHurryupImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWMVideoDecoderHurryupVtbl {
        unsafe extern "system" fn SetHurryup<Impl: IWMVideoDecoderHurryupImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, lhurryup: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetHurryup(lhurryup) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetHurryup<Impl: IWMVideoDecoderHurryupImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, plhurryup: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetHurryup(plhurryup) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWMVideoDecoderHurryup>, base.5, SetHurryup::<Impl, OFFSET>, GetHurryup::<Impl, OFFSET>)
    }
}
pub trait IWMVideoDecoderReconBufferImpl: Sized {
    fn GetReconstructedVideoFrameSize();
    fn GetReconstructedVideoFrame();
    fn SetReconstructedVideoFrame();
}
impl ::windows::core::RuntimeName for IWMVideoDecoderReconBuffer {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IWMVideoDecoderReconBuffer";
}
impl IWMVideoDecoderReconBufferVtbl {
    pub const fn new<Impl: IWMVideoDecoderReconBufferImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWMVideoDecoderReconBufferVtbl {
        unsafe extern "system" fn GetReconstructedVideoFrameSize<Impl: IWMVideoDecoderReconBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pdwsize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetReconstructedVideoFrameSize(pdwsize) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetReconstructedVideoFrame<Impl: IWMVideoDecoderReconBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbuf: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).GetReconstructedVideoFrame(&*(&pbuf as *const <super::DxMediaObjects::IMediaBuffer as ::windows::core::Abi>::Abi as *const <super::DxMediaObjects::IMediaBuffer as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetReconstructedVideoFrame<Impl: IWMVideoDecoderReconBufferImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void, pbuf: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetReconstructedVideoFrame(&*(&pbuf as *const <super::DxMediaObjects::IMediaBuffer as ::windows::core::Abi>::Abi as *const <super::DxMediaObjects::IMediaBuffer as ::windows::core::DefaultType>::DefaultType)) {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWMVideoDecoderReconBuffer>, base.5, GetReconstructedVideoFrameSize::<Impl, OFFSET>, GetReconstructedVideoFrame::<Impl, OFFSET>, SetReconstructedVideoFrame::<Impl, OFFSET>)
    }
}
pub trait IWMVideoForceKeyFrameImpl: Sized {
    fn SetKeyFrame();
}
impl ::windows::core::RuntimeName for IWMVideoForceKeyFrame {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.IWMVideoForceKeyFrame";
}
impl IWMVideoForceKeyFrameVtbl {
    pub const fn new<Impl: IWMVideoForceKeyFrameImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> IWMVideoForceKeyFrameVtbl {
        unsafe extern "system" fn SetKeyFrame<Impl: IWMVideoForceKeyFrameImpl, const OFFSET: usize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).add(OFFSET) as *mut Impl;
            match (*this).SetKeyFrame() {
                ::core::result::Result::Ok(ok__) => {
                    *result__ = ::core::mem::transmute_copy(&ok__);
                    ::core::mem::forget(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<IWMVideoForceKeyFrame>, base.5, SetKeyFrame::<Impl, OFFSET>)
    }
}
pub trait MFASYNCRESULTImpl: Sized + IMFAsyncResultImpl {}
impl ::windows::core::RuntimeName for MFASYNCRESULT {
    const NAME: &'static str = "Windows.Win32.Media.MediaFoundation.MFASYNCRESULT";
}
impl MFASYNCRESULTVtbl {
    pub const fn new<Impl: MFASYNCRESULTImpl, const OFFSET: usize>(base: &::windows::core::IInspectableVtbl) -> MFASYNCRESULTVtbl {
        Self(base.0, base.1, base.2, base.3, ::windows::core::GetRuntimeClassName::<MFASYNCRESULT>, base.5)
    }
}
