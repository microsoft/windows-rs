pub trait IAdvancedMediaCapture_Impl: Sized {
    fn GetAdvancedMediaCaptureSettings(&mut self) -> ::windows::core::Result<IAdvancedMediaCaptureSettings>;
}
impl IAdvancedMediaCapture_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAdvancedMediaCapture_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAdvancedMediaCapture_Vtbl {
        unsafe extern "system" fn GetAdvancedMediaCaptureSettings<Impl: IAdvancedMediaCapture_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAdvancedMediaCaptureSettings() {
                ::core::result::Result::Ok(ok__) => {
                    *value = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetAdvancedMediaCaptureSettings: GetAdvancedMediaCaptureSettings::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAdvancedMediaCapture as ::windows::core::Interface>::IID
    }
}
pub trait IAdvancedMediaCaptureInitializationSettings_Impl: Sized {
    fn SetDirectxDeviceManager(&mut self, value: ::core::option::Option<IMFDXGIDeviceManager>) -> ::windows::core::Result<()>;
}
impl IAdvancedMediaCaptureInitializationSettings_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAdvancedMediaCaptureInitializationSettings_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAdvancedMediaCaptureInitializationSettings_Vtbl {
        unsafe extern "system" fn SetDirectxDeviceManager<Impl: IAdvancedMediaCaptureInitializationSettings_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDirectxDeviceManager(::core::mem::transmute(&value)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), SetDirectxDeviceManager: SetDirectxDeviceManager::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAdvancedMediaCaptureInitializationSettings as ::windows::core::Interface>::IID
    }
}
pub trait IAdvancedMediaCaptureSettings_Impl: Sized {
    fn GetDirectxDeviceManager(&mut self) -> ::windows::core::Result<IMFDXGIDeviceManager>;
}
impl IAdvancedMediaCaptureSettings_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAdvancedMediaCaptureSettings_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAdvancedMediaCaptureSettings_Vtbl {
        unsafe extern "system" fn GetDirectxDeviceManager<Impl: IAdvancedMediaCaptureSettings_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDirectxDeviceManager() {
                ::core::result::Result::Ok(ok__) => {
                    *value = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetDirectxDeviceManager: GetDirectxDeviceManager::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAdvancedMediaCaptureSettings as ::windows::core::Interface>::IID
    }
}
pub trait IAudioSourceProvider_Impl: Sized {
    fn ProvideInput(&mut self, dwsamplecount: u32, pdwchannelcount: *mut u32, pinterleavedaudiodata: *mut f32) -> ::windows::core::Result<()>;
}
impl IAudioSourceProvider_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IAudioSourceProvider_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IAudioSourceProvider_Vtbl {
        unsafe extern "system" fn ProvideInput<Impl: IAudioSourceProvider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsamplecount: u32, pdwchannelcount: *mut u32, pinterleavedaudiodata: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ProvideInput(::core::mem::transmute_copy(&dwsamplecount), ::core::mem::transmute_copy(&pdwchannelcount), ::core::mem::transmute_copy(&pinterleavedaudiodata)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), ProvideInput: ProvideInput::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IAudioSourceProvider as ::windows::core::Interface>::IID
    }
}
pub trait IClusterDetector_Impl: Sized {
    fn Initialize(&mut self, wbaseentrylevel: u16, wclusterentrylevel: u16) -> ::windows::core::Result<()>;
    fn Detect(&mut self, dwmaxnumclusters: u32, fminclusterduration: f32, fmaxclusterduration: f32, psrctoc: ::core::option::Option<IToc>) -> ::windows::core::Result<IToc>;
}
impl IClusterDetector_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IClusterDetector_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IClusterDetector_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IClusterDetector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wbaseentrylevel: u16, wclusterentrylevel: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute_copy(&wbaseentrylevel), ::core::mem::transmute_copy(&wclusterentrylevel)).into()
        }
        unsafe extern "system" fn Detect<Impl: IClusterDetector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwmaxnumclusters: u32, fminclusterduration: f32, fmaxclusterduration: f32, psrctoc: ::windows::core::RawPtr, ppdsttoc: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Detect(::core::mem::transmute_copy(&dwmaxnumclusters), ::core::mem::transmute_copy(&fminclusterduration), ::core::mem::transmute_copy(&fmaxclusterduration), ::core::mem::transmute(&psrctoc)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdsttoc = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            Detect: Detect::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IClusterDetector as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
pub trait ICodecAPI_Impl: Sized {
    fn IsSupported(&mut self, api: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn IsModifiable(&mut self, api: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetParameterRange(&mut self, api: *const ::windows::core::GUID, valuemin: *mut super::super::System::Com::VARIANT, valuemax: *mut super::super::System::Com::VARIANT, steppingdelta: *mut super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
    fn GetParameterValues(&mut self, api: *const ::windows::core::GUID, values: *mut *mut super::super::System::Com::VARIANT, valuescount: *mut u32) -> ::windows::core::Result<()>;
    fn GetDefaultValue(&mut self, api: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::VARIANT>;
    fn GetValue(&mut self, api: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::VARIANT>;
    fn SetValue(&mut self, api: *const ::windows::core::GUID, value: *const super::super::System::Com::VARIANT) -> ::windows::core::Result<()>;
    fn RegisterForEvent(&mut self, api: *const ::windows::core::GUID, userdata: isize) -> ::windows::core::Result<()>;
    fn UnregisterForEvent(&mut self, api: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn SetAllDefaults(&mut self) -> ::windows::core::Result<()>;
    fn SetValueWithNotify(&mut self, api: *const ::windows::core::GUID, value: *mut super::super::System::Com::VARIANT, changedparam: *mut *mut ::windows::core::GUID, changedparamcount: *mut u32) -> ::windows::core::Result<()>;
    fn SetAllDefaultsWithNotify(&mut self, changedparam: *mut *mut ::windows::core::GUID, changedparamcount: *mut u32) -> ::windows::core::Result<()>;
    fn GetAllSettings(&mut self, __midl__icodecapi0000: ::core::option::Option<super::super::System::Com::IStream>) -> ::windows::core::Result<()>;
    fn SetAllSettings(&mut self, __midl__icodecapi0001: ::core::option::Option<super::super::System::Com::IStream>) -> ::windows::core::Result<()>;
    fn SetAllSettingsWithNotify(&mut self, __midl__icodecapi0002: ::core::option::Option<super::super::System::Com::IStream>, changedparam: *mut *mut ::windows::core::GUID, changedparamcount: *mut u32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Ole"))]
impl ICodecAPI_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ICodecAPI_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ICodecAPI_Vtbl {
        unsafe extern "system" fn IsSupported<Impl: ICodecAPI_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsSupported(::core::mem::transmute_copy(&api)).into()
        }
        unsafe extern "system" fn IsModifiable<Impl: ICodecAPI_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsModifiable(::core::mem::transmute_copy(&api)).into()
        }
        unsafe extern "system" fn GetParameterRange<Impl: ICodecAPI_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, valuemin: *mut super::super::System::Com::VARIANT, valuemax: *mut super::super::System::Com::VARIANT, steppingdelta: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetParameterRange(::core::mem::transmute_copy(&api), ::core::mem::transmute_copy(&valuemin), ::core::mem::transmute_copy(&valuemax), ::core::mem::transmute_copy(&steppingdelta)).into()
        }
        unsafe extern "system" fn GetParameterValues<Impl: ICodecAPI_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, values: *mut *mut super::super::System::Com::VARIANT, valuescount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetParameterValues(::core::mem::transmute_copy(&api), ::core::mem::transmute_copy(&values), ::core::mem::transmute_copy(&valuescount)).into()
        }
        unsafe extern "system" fn GetDefaultValue<Impl: ICodecAPI_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, value: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDefaultValue(::core::mem::transmute_copy(&api)) {
                ::core::result::Result::Ok(ok__) => {
                    *value = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetValue<Impl: ICodecAPI_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, value: *mut super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetValue(::core::mem::transmute_copy(&api)) {
                ::core::result::Result::Ok(ok__) => {
                    *value = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetValue<Impl: ICodecAPI_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, value: *const super::super::System::Com::VARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetValue(::core::mem::transmute_copy(&api), ::core::mem::transmute_copy(&value)).into()
        }
        unsafe extern "system" fn RegisterForEvent<Impl: ICodecAPI_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, userdata: isize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterForEvent(::core::mem::transmute_copy(&api), ::core::mem::transmute_copy(&userdata)).into()
        }
        unsafe extern "system" fn UnregisterForEvent<Impl: ICodecAPI_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnregisterForEvent(::core::mem::transmute_copy(&api)).into()
        }
        unsafe extern "system" fn SetAllDefaults<Impl: ICodecAPI_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAllDefaults().into()
        }
        unsafe extern "system" fn SetValueWithNotify<Impl: ICodecAPI_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, api: *const ::windows::core::GUID, value: *mut super::super::System::Com::VARIANT, changedparam: *mut *mut ::windows::core::GUID, changedparamcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetValueWithNotify(::core::mem::transmute_copy(&api), ::core::mem::transmute_copy(&value), ::core::mem::transmute_copy(&changedparam), ::core::mem::transmute_copy(&changedparamcount)).into()
        }
        unsafe extern "system" fn SetAllDefaultsWithNotify<Impl: ICodecAPI_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, changedparam: *mut *mut ::windows::core::GUID, changedparamcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAllDefaultsWithNotify(::core::mem::transmute_copy(&changedparam), ::core::mem::transmute_copy(&changedparamcount)).into()
        }
        unsafe extern "system" fn GetAllSettings<Impl: ICodecAPI_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, __midl__icodecapi0000: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAllSettings(::core::mem::transmute(&__midl__icodecapi0000)).into()
        }
        unsafe extern "system" fn SetAllSettings<Impl: ICodecAPI_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, __midl__icodecapi0001: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAllSettings(::core::mem::transmute(&__midl__icodecapi0001)).into()
        }
        unsafe extern "system" fn SetAllSettingsWithNotify<Impl: ICodecAPI_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, __midl__icodecapi0002: ::windows::core::RawPtr, changedparam: *mut *mut ::windows::core::GUID, changedparamcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAllSettingsWithNotify(::core::mem::transmute(&__midl__icodecapi0002), ::core::mem::transmute_copy(&changedparam), ::core::mem::transmute_copy(&changedparamcount)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            IsSupported: IsSupported::<Impl, IMPL_OFFSET>,
            IsModifiable: IsModifiable::<Impl, IMPL_OFFSET>,
            GetParameterRange: GetParameterRange::<Impl, IMPL_OFFSET>,
            GetParameterValues: GetParameterValues::<Impl, IMPL_OFFSET>,
            GetDefaultValue: GetDefaultValue::<Impl, IMPL_OFFSET>,
            GetValue: GetValue::<Impl, IMPL_OFFSET>,
            SetValue: SetValue::<Impl, IMPL_OFFSET>,
            RegisterForEvent: RegisterForEvent::<Impl, IMPL_OFFSET>,
            UnregisterForEvent: UnregisterForEvent::<Impl, IMPL_OFFSET>,
            SetAllDefaults: SetAllDefaults::<Impl, IMPL_OFFSET>,
            SetValueWithNotify: SetValueWithNotify::<Impl, IMPL_OFFSET>,
            SetAllDefaultsWithNotify: SetAllDefaultsWithNotify::<Impl, IMPL_OFFSET>,
            GetAllSettings: GetAllSettings::<Impl, IMPL_OFFSET>,
            SetAllSettings: SetAllSettings::<Impl, IMPL_OFFSET>,
            SetAllSettingsWithNotify: SetAllSettingsWithNotify::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ICodecAPI as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoDecodeCommandList_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Object_Impl + super::super::Graphics::Direct3D12::ID3D12DeviceChild_Impl + super::super::Graphics::Direct3D12::ID3D12CommandList_Impl {
    fn Close(&mut self) -> ::windows::core::Result<()>;
    fn Reset(&mut self, pallocator: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12CommandAllocator>) -> ::windows::core::Result<()>;
    fn ClearState(&mut self);
    fn ResourceBarrier(&mut self, numbarriers: u32, pbarriers: *const super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER);
    fn DiscardResource(&mut self, presource: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>, pregion: *const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION);
    fn BeginQuery(&mut self, pqueryheap: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12QueryHeap>, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32);
    fn EndQuery(&mut self, pqueryheap: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12QueryHeap>, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32);
    fn ResolveQueryData(&mut self, pqueryheap: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12QueryHeap>, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>, aligneddestinationbufferoffset: u64);
    fn SetPredication(&mut self, pbuffer: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP);
    fn SetMarker(&mut self, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32);
    fn BeginEvent(&mut self, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32);
    fn EndEvent(&mut self);
    fn DecodeFrame(&mut self, pdecoder: ::core::option::Option<ID3D12VideoDecoder>, poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS, pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS);
    fn WriteBufferImmediate(&mut self, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE);
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoDecodeCommandList_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoDecodeCommandList_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoDecodeCommandList_Vtbl {
        unsafe extern "system" fn Close<Impl: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Close().into()
        }
        unsafe extern "system" fn Reset<Impl: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pallocator: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reset(::core::mem::transmute(&pallocator)).into()
        }
        unsafe extern "system" fn ClearState<Impl: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ClearState()
        }
        unsafe extern "system" fn ResourceBarrier<Impl: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, numbarriers: u32, pbarriers: *const super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ResourceBarrier(::core::mem::transmute_copy(&numbarriers), ::core::mem::transmute_copy(&pbarriers))
        }
        unsafe extern "system" fn DiscardResource<Impl: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presource: ::windows::core::RawPtr, pregion: *const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DiscardResource(::core::mem::transmute(&presource), ::core::mem::transmute_copy(&pregion))
        }
        unsafe extern "system" fn BeginQuery<Impl: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pqueryheap: ::windows::core::RawPtr, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginQuery(::core::mem::transmute(&pqueryheap), ::core::mem::transmute_copy(&r#type), ::core::mem::transmute_copy(&index))
        }
        unsafe extern "system" fn EndQuery<Impl: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pqueryheap: ::windows::core::RawPtr, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndQuery(::core::mem::transmute(&pqueryheap), ::core::mem::transmute_copy(&r#type), ::core::mem::transmute_copy(&index))
        }
        unsafe extern "system" fn ResolveQueryData<Impl: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pqueryheap: ::windows::core::RawPtr, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: ::windows::core::RawPtr, aligneddestinationbufferoffset: u64) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ResolveQueryData(::core::mem::transmute(&pqueryheap), ::core::mem::transmute_copy(&r#type), ::core::mem::transmute_copy(&startindex), ::core::mem::transmute_copy(&numqueries), ::core::mem::transmute(&pdestinationbuffer), ::core::mem::transmute_copy(&aligneddestinationbufferoffset))
        }
        unsafe extern "system" fn SetPredication<Impl: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbuffer: ::windows::core::RawPtr, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPredication(::core::mem::transmute(&pbuffer), ::core::mem::transmute_copy(&alignedbufferoffset), ::core::mem::transmute_copy(&operation))
        }
        unsafe extern "system" fn SetMarker<Impl: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMarker(::core::mem::transmute_copy(&metadata), ::core::mem::transmute_copy(&pdata), ::core::mem::transmute_copy(&size))
        }
        unsafe extern "system" fn BeginEvent<Impl: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginEvent(::core::mem::transmute_copy(&metadata), ::core::mem::transmute_copy(&pdata), ::core::mem::transmute_copy(&size))
        }
        unsafe extern "system" fn EndEvent<Impl: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndEvent()
        }
        unsafe extern "system" fn DecodeFrame<Impl: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdecoder: ::windows::core::RawPtr, poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS, pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DecodeFrame(::core::mem::transmute(&pdecoder), ::core::mem::transmute_copy(&poutputarguments), ::core::mem::transmute_copy(&pinputarguments))
        }
        unsafe extern "system" fn WriteBufferImmediate<Impl: ID3D12VideoDecodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).WriteBufferImmediate(::core::mem::transmute_copy(&count), ::core::mem::transmute_copy(&pparams), ::core::mem::transmute_copy(&pmodes))
        }
        Self {
            base: super::super::Graphics::Direct3D12::ID3D12CommandList_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Close: Close::<Impl, IMPL_OFFSET>,
            Reset: Reset::<Impl, IMPL_OFFSET>,
            ClearState: ClearState::<Impl, IMPL_OFFSET>,
            ResourceBarrier: ResourceBarrier::<Impl, IMPL_OFFSET>,
            DiscardResource: DiscardResource::<Impl, IMPL_OFFSET>,
            BeginQuery: BeginQuery::<Impl, IMPL_OFFSET>,
            EndQuery: EndQuery::<Impl, IMPL_OFFSET>,
            ResolveQueryData: ResolveQueryData::<Impl, IMPL_OFFSET>,
            SetPredication: SetPredication::<Impl, IMPL_OFFSET>,
            SetMarker: SetMarker::<Impl, IMPL_OFFSET>,
            BeginEvent: BeginEvent::<Impl, IMPL_OFFSET>,
            EndEvent: EndEvent::<Impl, IMPL_OFFSET>,
            DecodeFrame: DecodeFrame::<Impl, IMPL_OFFSET>,
            WriteBufferImmediate: WriteBufferImmediate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoDecodeCommandList as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoDecodeCommandList1_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Object_Impl + super::super::Graphics::Direct3D12::ID3D12DeviceChild_Impl + super::super::Graphics::Direct3D12::ID3D12CommandList_Impl + ID3D12VideoDecodeCommandList_Impl {
    fn DecodeFrame1(&mut self, pdecoder: ::core::option::Option<ID3D12VideoDecoder>, poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1, pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS);
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoDecodeCommandList1_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoDecodeCommandList1_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoDecodeCommandList1_Vtbl {
        unsafe extern "system" fn DecodeFrame1<Impl: ID3D12VideoDecodeCommandList1_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdecoder: ::windows::core::RawPtr, poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1, pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DecodeFrame1(::core::mem::transmute(&pdecoder), ::core::mem::transmute_copy(&poutputarguments), ::core::mem::transmute_copy(&pinputarguments))
        }
        Self { base: ID3D12VideoDecodeCommandList_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), DecodeFrame1: DecodeFrame1::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoDecodeCommandList1 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoDecodeCommandList2_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Object_Impl + super::super::Graphics::Direct3D12::ID3D12DeviceChild_Impl + super::super::Graphics::Direct3D12::ID3D12CommandList_Impl + ID3D12VideoDecodeCommandList_Impl + ID3D12VideoDecodeCommandList1_Impl {
    fn SetProtectedResourceSession(&mut self, pprotectedresourcesession: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>);
    fn InitializeExtensionCommand(&mut self, pextensioncommand: ::core::option::Option<ID3D12VideoExtensionCommand>, pinitializationparameters: *const ::core::ffi::c_void, initializationparameterssizeinbytes: usize);
    fn ExecuteExtensionCommand(&mut self, pextensioncommand: ::core::option::Option<ID3D12VideoExtensionCommand>, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize);
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoDecodeCommandList2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoDecodeCommandList2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoDecodeCommandList2_Vtbl {
        unsafe extern "system" fn SetProtectedResourceSession<Impl: ID3D12VideoDecodeCommandList2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pprotectedresourcesession: ::windows::core::RawPtr) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetProtectedResourceSession(::core::mem::transmute(&pprotectedresourcesession))
        }
        unsafe extern "system" fn InitializeExtensionCommand<Impl: ID3D12VideoDecodeCommandList2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pextensioncommand: ::windows::core::RawPtr, pinitializationparameters: *const ::core::ffi::c_void, initializationparameterssizeinbytes: usize) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InitializeExtensionCommand(::core::mem::transmute(&pextensioncommand), ::core::mem::transmute_copy(&pinitializationparameters), ::core::mem::transmute_copy(&initializationparameterssizeinbytes))
        }
        unsafe extern "system" fn ExecuteExtensionCommand<Impl: ID3D12VideoDecodeCommandList2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pextensioncommand: ::windows::core::RawPtr, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ExecuteExtensionCommand(::core::mem::transmute(&pextensioncommand), ::core::mem::transmute_copy(&pexecutionparameters), ::core::mem::transmute_copy(&executionparameterssizeinbytes))
        }
        Self {
            base: ID3D12VideoDecodeCommandList1_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetProtectedResourceSession: SetProtectedResourceSession::<Impl, IMPL_OFFSET>,
            InitializeExtensionCommand: InitializeExtensionCommand::<Impl, IMPL_OFFSET>,
            ExecuteExtensionCommand: ExecuteExtensionCommand::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoDecodeCommandList2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
pub trait ID3D12VideoDecoder_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Object_Impl + super::super::Graphics::Direct3D12::ID3D12DeviceChild_Impl + super::super::Graphics::Direct3D12::ID3D12Pageable_Impl {
    fn GetDesc(&mut self) -> D3D12_VIDEO_DECODER_DESC;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ID3D12VideoDecoder_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoDecoder_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoDecoder_Vtbl {
        unsafe extern "system" fn GetDesc<Impl: ID3D12VideoDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut D3D12_VIDEO_DECODER_DESC) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            *result__ = (*this).GetDesc()
        }
        Self {
            base: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetDesc: GetDesc::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoDecoder as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
pub trait ID3D12VideoDecoder1_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Object_Impl + super::super::Graphics::Direct3D12::ID3D12DeviceChild_Impl + super::super::Graphics::Direct3D12::ID3D12Pageable_Impl + ID3D12VideoDecoder_Impl {
    fn GetProtectedResourceSession(&mut self, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ID3D12VideoDecoder1_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoDecoder1_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoDecoder1_Vtbl {
        unsafe extern "system" fn GetProtectedResourceSession<Impl: ID3D12VideoDecoder1_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetProtectedResourceSession(::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppprotectedsession)).into()
        }
        Self {
            base: ID3D12VideoDecoder_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetProtectedResourceSession: GetProtectedResourceSession::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoDecoder1 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoDecoderHeap_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Object_Impl + super::super::Graphics::Direct3D12::ID3D12DeviceChild_Impl + super::super::Graphics::Direct3D12::ID3D12Pageable_Impl {
    fn GetDesc(&mut self) -> D3D12_VIDEO_DECODER_HEAP_DESC;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoDecoderHeap_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoDecoderHeap_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoDecoderHeap_Vtbl {
        unsafe extern "system" fn GetDesc<Impl: ID3D12VideoDecoderHeap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut D3D12_VIDEO_DECODER_HEAP_DESC) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            *result__ = (*this).GetDesc()
        }
        Self {
            base: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetDesc: GetDesc::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoDecoderHeap as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoDecoderHeap1_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Object_Impl + super::super::Graphics::Direct3D12::ID3D12DeviceChild_Impl + super::super::Graphics::Direct3D12::ID3D12Pageable_Impl + ID3D12VideoDecoderHeap_Impl {
    fn GetProtectedResourceSession(&mut self, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoDecoderHeap1_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoDecoderHeap1_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoDecoderHeap1_Vtbl {
        unsafe extern "system" fn GetProtectedResourceSession<Impl: ID3D12VideoDecoderHeap1_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetProtectedResourceSession(::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppprotectedsession)).into()
        }
        Self {
            base: ID3D12VideoDecoderHeap_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetProtectedResourceSession: GetProtectedResourceSession::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoDecoderHeap1 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoDevice_Impl: Sized {
    fn CheckFeatureSupport(&mut self, featurevideo: D3D12_FEATURE_VIDEO, pfeaturesupportdata: *mut ::core::ffi::c_void, featuresupportdatasize: u32) -> ::windows::core::Result<()>;
    fn CreateVideoDecoder(&mut self, pdesc: *const D3D12_VIDEO_DECODER_DESC, riid: *const ::windows::core::GUID, ppvideodecoder: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn CreateVideoDecoderHeap(&mut self, pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC, riid: *const ::windows::core::GUID, ppvideodecoderheap: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn CreateVideoProcessor(&mut self, nodemask: u32, poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC, numinputstreamdescs: u32, pinputstreamdescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC, riid: *const ::windows::core::GUID, ppvideoprocessor: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoDevice_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoDevice_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoDevice_Vtbl {
        unsafe extern "system" fn CheckFeatureSupport<Impl: ID3D12VideoDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, featurevideo: D3D12_FEATURE_VIDEO, pfeaturesupportdata: *mut ::core::ffi::c_void, featuresupportdatasize: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CheckFeatureSupport(::core::mem::transmute_copy(&featurevideo), ::core::mem::transmute_copy(&pfeaturesupportdata), ::core::mem::transmute_copy(&featuresupportdatasize)).into()
        }
        unsafe extern "system" fn CreateVideoDecoder<Impl: ID3D12VideoDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdesc: *const D3D12_VIDEO_DECODER_DESC, riid: *const ::windows::core::GUID, ppvideodecoder: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateVideoDecoder(::core::mem::transmute_copy(&pdesc), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvideodecoder)).into()
        }
        unsafe extern "system" fn CreateVideoDecoderHeap<Impl: ID3D12VideoDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC, riid: *const ::windows::core::GUID, ppvideodecoderheap: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateVideoDecoderHeap(::core::mem::transmute_copy(&pvideodecoderheapdesc), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvideodecoderheap)).into()
        }
        unsafe extern "system" fn CreateVideoProcessor<Impl: ID3D12VideoDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, nodemask: u32, poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC, numinputstreamdescs: u32, pinputstreamdescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC, riid: *const ::windows::core::GUID, ppvideoprocessor: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateVideoProcessor(::core::mem::transmute_copy(&nodemask), ::core::mem::transmute_copy(&poutputstreamdesc), ::core::mem::transmute_copy(&numinputstreamdescs), ::core::mem::transmute_copy(&pinputstreamdescs), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvideoprocessor)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            CheckFeatureSupport: CheckFeatureSupport::<Impl, IMPL_OFFSET>,
            CreateVideoDecoder: CreateVideoDecoder::<Impl, IMPL_OFFSET>,
            CreateVideoDecoderHeap: CreateVideoDecoderHeap::<Impl, IMPL_OFFSET>,
            CreateVideoProcessor: CreateVideoProcessor::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoDevice as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoDevice1_Impl: Sized + ID3D12VideoDevice_Impl {
    fn CreateVideoMotionEstimator(&mut self, pdesc: *const D3D12_VIDEO_MOTION_ESTIMATOR_DESC, pprotectedresourcesession: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>, riid: *const ::windows::core::GUID, ppvideomotionestimator: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn CreateVideoMotionVectorHeap(&mut self, pdesc: *const D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC, pprotectedresourcesession: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>, riid: *const ::windows::core::GUID, ppvideomotionvectorheap: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoDevice1_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoDevice1_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoDevice1_Vtbl {
        unsafe extern "system" fn CreateVideoMotionEstimator<Impl: ID3D12VideoDevice1_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdesc: *const D3D12_VIDEO_MOTION_ESTIMATOR_DESC, pprotectedresourcesession: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppvideomotionestimator: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateVideoMotionEstimator(::core::mem::transmute_copy(&pdesc), ::core::mem::transmute(&pprotectedresourcesession), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvideomotionestimator)).into()
        }
        unsafe extern "system" fn CreateVideoMotionVectorHeap<Impl: ID3D12VideoDevice1_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdesc: *const D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC, pprotectedresourcesession: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppvideomotionvectorheap: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateVideoMotionVectorHeap(::core::mem::transmute_copy(&pdesc), ::core::mem::transmute(&pprotectedresourcesession), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvideomotionvectorheap)).into()
        }
        Self {
            base: ID3D12VideoDevice_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            CreateVideoMotionEstimator: CreateVideoMotionEstimator::<Impl, IMPL_OFFSET>,
            CreateVideoMotionVectorHeap: CreateVideoMotionVectorHeap::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoDevice1 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoDevice2_Impl: Sized + ID3D12VideoDevice_Impl + ID3D12VideoDevice1_Impl {
    fn CreateVideoDecoder1(&mut self, pdesc: *const D3D12_VIDEO_DECODER_DESC, pprotectedresourcesession: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>, riid: *const ::windows::core::GUID, ppvideodecoder: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn CreateVideoDecoderHeap1(&mut self, pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC, pprotectedresourcesession: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>, riid: *const ::windows::core::GUID, ppvideodecoderheap: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn CreateVideoProcessor1(&mut self, nodemask: u32, poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC, numinputstreamdescs: u32, pinputstreamdescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC, pprotectedresourcesession: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>, riid: *const ::windows::core::GUID, ppvideoprocessor: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn CreateVideoExtensionCommand(&mut self, pdesc: *const D3D12_VIDEO_EXTENSION_COMMAND_DESC, pcreationparameters: *const ::core::ffi::c_void, creationparametersdatasizeinbytes: usize, pprotectedresourcesession: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>, riid: *const ::windows::core::GUID, ppvideoextensioncommand: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn ExecuteExtensionCommand(&mut self, pextensioncommand: ::core::option::Option<ID3D12VideoExtensionCommand>, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize, poutputdata: *mut ::core::ffi::c_void, outputdatasizeinbytes: usize) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoDevice2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoDevice2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoDevice2_Vtbl {
        unsafe extern "system" fn CreateVideoDecoder1<Impl: ID3D12VideoDevice2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdesc: *const D3D12_VIDEO_DECODER_DESC, pprotectedresourcesession: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppvideodecoder: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateVideoDecoder1(::core::mem::transmute_copy(&pdesc), ::core::mem::transmute(&pprotectedresourcesession), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvideodecoder)).into()
        }
        unsafe extern "system" fn CreateVideoDecoderHeap1<Impl: ID3D12VideoDevice2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC, pprotectedresourcesession: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppvideodecoderheap: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateVideoDecoderHeap1(::core::mem::transmute_copy(&pvideodecoderheapdesc), ::core::mem::transmute(&pprotectedresourcesession), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvideodecoderheap)).into()
        }
        unsafe extern "system" fn CreateVideoProcessor1<Impl: ID3D12VideoDevice2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, nodemask: u32, poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC, numinputstreamdescs: u32, pinputstreamdescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC, pprotectedresourcesession: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppvideoprocessor: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateVideoProcessor1(::core::mem::transmute_copy(&nodemask), ::core::mem::transmute_copy(&poutputstreamdesc), ::core::mem::transmute_copy(&numinputstreamdescs), ::core::mem::transmute_copy(&pinputstreamdescs), ::core::mem::transmute(&pprotectedresourcesession), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvideoprocessor)).into()
        }
        unsafe extern "system" fn CreateVideoExtensionCommand<Impl: ID3D12VideoDevice2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdesc: *const D3D12_VIDEO_EXTENSION_COMMAND_DESC, pcreationparameters: *const ::core::ffi::c_void, creationparametersdatasizeinbytes: usize, pprotectedresourcesession: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppvideoextensioncommand: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateVideoExtensionCommand(::core::mem::transmute_copy(&pdesc), ::core::mem::transmute_copy(&pcreationparameters), ::core::mem::transmute_copy(&creationparametersdatasizeinbytes), ::core::mem::transmute(&pprotectedresourcesession), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvideoextensioncommand)).into()
        }
        unsafe extern "system" fn ExecuteExtensionCommand<Impl: ID3D12VideoDevice2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pextensioncommand: ::windows::core::RawPtr, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize, poutputdata: *mut ::core::ffi::c_void, outputdatasizeinbytes: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ExecuteExtensionCommand(::core::mem::transmute(&pextensioncommand), ::core::mem::transmute_copy(&pexecutionparameters), ::core::mem::transmute_copy(&executionparameterssizeinbytes), ::core::mem::transmute_copy(&poutputdata), ::core::mem::transmute_copy(&outputdatasizeinbytes)).into()
        }
        Self {
            base: ID3D12VideoDevice1_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            CreateVideoDecoder1: CreateVideoDecoder1::<Impl, IMPL_OFFSET>,
            CreateVideoDecoderHeap1: CreateVideoDecoderHeap1::<Impl, IMPL_OFFSET>,
            CreateVideoProcessor1: CreateVideoProcessor1::<Impl, IMPL_OFFSET>,
            CreateVideoExtensionCommand: CreateVideoExtensionCommand::<Impl, IMPL_OFFSET>,
            ExecuteExtensionCommand: ExecuteExtensionCommand::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoDevice2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoDevice3_Impl: Sized + ID3D12VideoDevice_Impl + ID3D12VideoDevice1_Impl + ID3D12VideoDevice2_Impl {
    fn CreateVideoEncoder(&mut self, pdesc: *const D3D12_VIDEO_ENCODER_DESC, riid: *const ::windows::core::GUID, ppvideoencoder: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn CreateVideoEncoderHeap(&mut self, pdesc: *const D3D12_VIDEO_ENCODER_HEAP_DESC, riid: *const ::windows::core::GUID, ppvideoencoderheap: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoDevice3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoDevice3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoDevice3_Vtbl {
        unsafe extern "system" fn CreateVideoEncoder<Impl: ID3D12VideoDevice3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdesc: *const D3D12_VIDEO_ENCODER_DESC, riid: *const ::windows::core::GUID, ppvideoencoder: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateVideoEncoder(::core::mem::transmute_copy(&pdesc), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvideoencoder)).into()
        }
        unsafe extern "system" fn CreateVideoEncoderHeap<Impl: ID3D12VideoDevice3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdesc: *const D3D12_VIDEO_ENCODER_HEAP_DESC, riid: *const ::windows::core::GUID, ppvideoencoderheap: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateVideoEncoderHeap(::core::mem::transmute_copy(&pdesc), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvideoencoderheap)).into()
        }
        Self {
            base: ID3D12VideoDevice2_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            CreateVideoEncoder: CreateVideoEncoder::<Impl, IMPL_OFFSET>,
            CreateVideoEncoderHeap: CreateVideoEncoderHeap::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoDevice3 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
pub trait ID3D12VideoEncodeCommandList_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Object_Impl + super::super::Graphics::Direct3D12::ID3D12DeviceChild_Impl + super::super::Graphics::Direct3D12::ID3D12CommandList_Impl {
    fn Close(&mut self) -> ::windows::core::Result<()>;
    fn Reset(&mut self, pallocator: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12CommandAllocator>) -> ::windows::core::Result<()>;
    fn ClearState(&mut self);
    fn ResourceBarrier(&mut self, numbarriers: u32, pbarriers: *const super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER);
    fn DiscardResource(&mut self, presource: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>, pregion: *const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION);
    fn BeginQuery(&mut self, pqueryheap: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12QueryHeap>, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32);
    fn EndQuery(&mut self, pqueryheap: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12QueryHeap>, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32);
    fn ResolveQueryData(&mut self, pqueryheap: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12QueryHeap>, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>, aligneddestinationbufferoffset: u64);
    fn SetPredication(&mut self, pbuffer: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP);
    fn SetMarker(&mut self, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32);
    fn BeginEvent(&mut self, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32);
    fn EndEvent(&mut self);
    fn EstimateMotion(&mut self, pmotionestimator: ::core::option::Option<ID3D12VideoMotionEstimator>, poutputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT, pinputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT);
    fn ResolveMotionVectorHeap(&mut self, poutputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT, pinputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT);
    fn WriteBufferImmediate(&mut self, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE);
    fn SetProtectedResourceSession(&mut self, pprotectedresourcesession: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>);
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ID3D12VideoEncodeCommandList_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoEncodeCommandList_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoEncodeCommandList_Vtbl {
        unsafe extern "system" fn Close<Impl: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Close().into()
        }
        unsafe extern "system" fn Reset<Impl: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pallocator: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reset(::core::mem::transmute(&pallocator)).into()
        }
        unsafe extern "system" fn ClearState<Impl: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ClearState()
        }
        unsafe extern "system" fn ResourceBarrier<Impl: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, numbarriers: u32, pbarriers: *const super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ResourceBarrier(::core::mem::transmute_copy(&numbarriers), ::core::mem::transmute_copy(&pbarriers))
        }
        unsafe extern "system" fn DiscardResource<Impl: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presource: ::windows::core::RawPtr, pregion: *const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DiscardResource(::core::mem::transmute(&presource), ::core::mem::transmute_copy(&pregion))
        }
        unsafe extern "system" fn BeginQuery<Impl: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pqueryheap: ::windows::core::RawPtr, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginQuery(::core::mem::transmute(&pqueryheap), ::core::mem::transmute_copy(&r#type), ::core::mem::transmute_copy(&index))
        }
        unsafe extern "system" fn EndQuery<Impl: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pqueryheap: ::windows::core::RawPtr, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndQuery(::core::mem::transmute(&pqueryheap), ::core::mem::transmute_copy(&r#type), ::core::mem::transmute_copy(&index))
        }
        unsafe extern "system" fn ResolveQueryData<Impl: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pqueryheap: ::windows::core::RawPtr, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: ::windows::core::RawPtr, aligneddestinationbufferoffset: u64) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ResolveQueryData(::core::mem::transmute(&pqueryheap), ::core::mem::transmute_copy(&r#type), ::core::mem::transmute_copy(&startindex), ::core::mem::transmute_copy(&numqueries), ::core::mem::transmute(&pdestinationbuffer), ::core::mem::transmute_copy(&aligneddestinationbufferoffset))
        }
        unsafe extern "system" fn SetPredication<Impl: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbuffer: ::windows::core::RawPtr, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPredication(::core::mem::transmute(&pbuffer), ::core::mem::transmute_copy(&alignedbufferoffset), ::core::mem::transmute_copy(&operation))
        }
        unsafe extern "system" fn SetMarker<Impl: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMarker(::core::mem::transmute_copy(&metadata), ::core::mem::transmute_copy(&pdata), ::core::mem::transmute_copy(&size))
        }
        unsafe extern "system" fn BeginEvent<Impl: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginEvent(::core::mem::transmute_copy(&metadata), ::core::mem::transmute_copy(&pdata), ::core::mem::transmute_copy(&size))
        }
        unsafe extern "system" fn EndEvent<Impl: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndEvent()
        }
        unsafe extern "system" fn EstimateMotion<Impl: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmotionestimator: ::windows::core::RawPtr, poutputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT, pinputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EstimateMotion(::core::mem::transmute(&pmotionestimator), ::core::mem::transmute_copy(&poutputarguments), ::core::mem::transmute_copy(&pinputarguments))
        }
        unsafe extern "system" fn ResolveMotionVectorHeap<Impl: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, poutputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT, pinputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ResolveMotionVectorHeap(::core::mem::transmute_copy(&poutputarguments), ::core::mem::transmute_copy(&pinputarguments))
        }
        unsafe extern "system" fn WriteBufferImmediate<Impl: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).WriteBufferImmediate(::core::mem::transmute_copy(&count), ::core::mem::transmute_copy(&pparams), ::core::mem::transmute_copy(&pmodes))
        }
        unsafe extern "system" fn SetProtectedResourceSession<Impl: ID3D12VideoEncodeCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pprotectedresourcesession: ::windows::core::RawPtr) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetProtectedResourceSession(::core::mem::transmute(&pprotectedresourcesession))
        }
        Self {
            base: super::super::Graphics::Direct3D12::ID3D12CommandList_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Close: Close::<Impl, IMPL_OFFSET>,
            Reset: Reset::<Impl, IMPL_OFFSET>,
            ClearState: ClearState::<Impl, IMPL_OFFSET>,
            ResourceBarrier: ResourceBarrier::<Impl, IMPL_OFFSET>,
            DiscardResource: DiscardResource::<Impl, IMPL_OFFSET>,
            BeginQuery: BeginQuery::<Impl, IMPL_OFFSET>,
            EndQuery: EndQuery::<Impl, IMPL_OFFSET>,
            ResolveQueryData: ResolveQueryData::<Impl, IMPL_OFFSET>,
            SetPredication: SetPredication::<Impl, IMPL_OFFSET>,
            SetMarker: SetMarker::<Impl, IMPL_OFFSET>,
            BeginEvent: BeginEvent::<Impl, IMPL_OFFSET>,
            EndEvent: EndEvent::<Impl, IMPL_OFFSET>,
            EstimateMotion: EstimateMotion::<Impl, IMPL_OFFSET>,
            ResolveMotionVectorHeap: ResolveMotionVectorHeap::<Impl, IMPL_OFFSET>,
            WriteBufferImmediate: WriteBufferImmediate::<Impl, IMPL_OFFSET>,
            SetProtectedResourceSession: SetProtectedResourceSession::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoEncodeCommandList as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
pub trait ID3D12VideoEncodeCommandList1_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Object_Impl + super::super::Graphics::Direct3D12::ID3D12DeviceChild_Impl + super::super::Graphics::Direct3D12::ID3D12CommandList_Impl + ID3D12VideoEncodeCommandList_Impl {
    fn InitializeExtensionCommand(&mut self, pextensioncommand: ::core::option::Option<ID3D12VideoExtensionCommand>, pinitializationparameters: *const ::core::ffi::c_void, initializationparameterssizeinbytes: usize);
    fn ExecuteExtensionCommand(&mut self, pextensioncommand: ::core::option::Option<ID3D12VideoExtensionCommand>, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize);
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ID3D12VideoEncodeCommandList1_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoEncodeCommandList1_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoEncodeCommandList1_Vtbl {
        unsafe extern "system" fn InitializeExtensionCommand<Impl: ID3D12VideoEncodeCommandList1_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pextensioncommand: ::windows::core::RawPtr, pinitializationparameters: *const ::core::ffi::c_void, initializationparameterssizeinbytes: usize) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InitializeExtensionCommand(::core::mem::transmute(&pextensioncommand), ::core::mem::transmute_copy(&pinitializationparameters), ::core::mem::transmute_copy(&initializationparameterssizeinbytes))
        }
        unsafe extern "system" fn ExecuteExtensionCommand<Impl: ID3D12VideoEncodeCommandList1_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pextensioncommand: ::windows::core::RawPtr, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ExecuteExtensionCommand(::core::mem::transmute(&pextensioncommand), ::core::mem::transmute_copy(&pexecutionparameters), ::core::mem::transmute_copy(&executionparameterssizeinbytes))
        }
        Self {
            base: ID3D12VideoEncodeCommandList_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            InitializeExtensionCommand: InitializeExtensionCommand::<Impl, IMPL_OFFSET>,
            ExecuteExtensionCommand: ExecuteExtensionCommand::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoEncodeCommandList1 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoEncodeCommandList2_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Object_Impl + super::super::Graphics::Direct3D12::ID3D12DeviceChild_Impl + super::super::Graphics::Direct3D12::ID3D12CommandList_Impl + ID3D12VideoEncodeCommandList_Impl + ID3D12VideoEncodeCommandList1_Impl {
    fn EncodeFrame(&mut self, pencoder: ::core::option::Option<ID3D12VideoEncoder>, pheap: ::core::option::Option<ID3D12VideoEncoderHeap>, pinputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS, poutputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS);
    fn ResolveEncoderOutputMetadata(&mut self, pinputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS, poutputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS);
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoEncodeCommandList2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoEncodeCommandList2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoEncodeCommandList2_Vtbl {
        unsafe extern "system" fn EncodeFrame<Impl: ID3D12VideoEncodeCommandList2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pencoder: ::windows::core::RawPtr, pheap: ::windows::core::RawPtr, pinputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS, poutputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EncodeFrame(::core::mem::transmute(&pencoder), ::core::mem::transmute(&pheap), ::core::mem::transmute_copy(&pinputarguments), ::core::mem::transmute_copy(&poutputarguments))
        }
        unsafe extern "system" fn ResolveEncoderOutputMetadata<Impl: ID3D12VideoEncodeCommandList2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pinputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS, poutputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ResolveEncoderOutputMetadata(::core::mem::transmute_copy(&pinputarguments), ::core::mem::transmute_copy(&poutputarguments))
        }
        Self {
            base: ID3D12VideoEncodeCommandList1_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            EncodeFrame: EncodeFrame::<Impl, IMPL_OFFSET>,
            ResolveEncoderOutputMetadata: ResolveEncoderOutputMetadata::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoEncodeCommandList2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoEncoder_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Object_Impl + super::super::Graphics::Direct3D12::ID3D12DeviceChild_Impl + super::super::Graphics::Direct3D12::ID3D12Pageable_Impl {
    fn GetNodeMask(&mut self) -> u32;
    fn GetEncoderFlags(&mut self) -> D3D12_VIDEO_ENCODER_FLAGS;
    fn GetCodec(&mut self) -> D3D12_VIDEO_ENCODER_CODEC;
    fn GetCodecProfile(&mut self, dstprofile: D3D12_VIDEO_ENCODER_PROFILE_DESC) -> ::windows::core::Result<()>;
    fn GetCodecConfiguration(&mut self, dstcodecconfig: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION) -> ::windows::core::Result<()>;
    fn GetInputFormat(&mut self) -> super::super::Graphics::Dxgi::Common::DXGI_FORMAT;
    fn GetMaxMotionEstimationPrecision(&mut self) -> D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoEncoder_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoEncoder_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoEncoder_Vtbl {
        unsafe extern "system" fn GetNodeMask<Impl: ID3D12VideoEncoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNodeMask()
        }
        unsafe extern "system" fn GetEncoderFlags<Impl: ID3D12VideoEncoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> D3D12_VIDEO_ENCODER_FLAGS {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetEncoderFlags()
        }
        unsafe extern "system" fn GetCodec<Impl: ID3D12VideoEncoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> D3D12_VIDEO_ENCODER_CODEC {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCodec()
        }
        unsafe extern "system" fn GetCodecProfile<Impl: ID3D12VideoEncoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dstprofile: D3D12_VIDEO_ENCODER_PROFILE_DESC) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCodecProfile(::core::mem::transmute_copy(&dstprofile)).into()
        }
        unsafe extern "system" fn GetCodecConfiguration<Impl: ID3D12VideoEncoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dstcodecconfig: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCodecConfiguration(::core::mem::transmute_copy(&dstcodecconfig)).into()
        }
        unsafe extern "system" fn GetInputFormat<Impl: ID3D12VideoEncoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> super::super::Graphics::Dxgi::Common::DXGI_FORMAT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetInputFormat()
        }
        unsafe extern "system" fn GetMaxMotionEstimationPrecision<Impl: ID3D12VideoEncoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMaxMotionEstimationPrecision()
        }
        Self {
            base: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetNodeMask: GetNodeMask::<Impl, IMPL_OFFSET>,
            GetEncoderFlags: GetEncoderFlags::<Impl, IMPL_OFFSET>,
            GetCodec: GetCodec::<Impl, IMPL_OFFSET>,
            GetCodecProfile: GetCodecProfile::<Impl, IMPL_OFFSET>,
            GetCodecConfiguration: GetCodecConfiguration::<Impl, IMPL_OFFSET>,
            GetInputFormat: GetInputFormat::<Impl, IMPL_OFFSET>,
            GetMaxMotionEstimationPrecision: GetMaxMotionEstimationPrecision::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoEncoder as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
pub trait ID3D12VideoEncoderHeap_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Object_Impl + super::super::Graphics::Direct3D12::ID3D12DeviceChild_Impl + super::super::Graphics::Direct3D12::ID3D12Pageable_Impl {
    fn GetNodeMask(&mut self) -> u32;
    fn GetEncoderHeapFlags(&mut self) -> D3D12_VIDEO_ENCODER_HEAP_FLAGS;
    fn GetCodec(&mut self) -> D3D12_VIDEO_ENCODER_CODEC;
    fn GetCodecProfile(&mut self, dstprofile: D3D12_VIDEO_ENCODER_PROFILE_DESC) -> ::windows::core::Result<()>;
    fn GetCodecLevel(&mut self, dstlevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING) -> ::windows::core::Result<()>;
    fn GetResolutionListCount(&mut self) -> u32;
    fn GetResolutionList(&mut self, resolutionslistcount: u32, presolutionlist: *mut D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ID3D12VideoEncoderHeap_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoEncoderHeap_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoEncoderHeap_Vtbl {
        unsafe extern "system" fn GetNodeMask<Impl: ID3D12VideoEncoderHeap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNodeMask()
        }
        unsafe extern "system" fn GetEncoderHeapFlags<Impl: ID3D12VideoEncoderHeap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> D3D12_VIDEO_ENCODER_HEAP_FLAGS {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetEncoderHeapFlags()
        }
        unsafe extern "system" fn GetCodec<Impl: ID3D12VideoEncoderHeap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> D3D12_VIDEO_ENCODER_CODEC {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCodec()
        }
        unsafe extern "system" fn GetCodecProfile<Impl: ID3D12VideoEncoderHeap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dstprofile: D3D12_VIDEO_ENCODER_PROFILE_DESC) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCodecProfile(::core::mem::transmute_copy(&dstprofile)).into()
        }
        unsafe extern "system" fn GetCodecLevel<Impl: ID3D12VideoEncoderHeap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dstlevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCodecLevel(::core::mem::transmute_copy(&dstlevel)).into()
        }
        unsafe extern "system" fn GetResolutionListCount<Impl: ID3D12VideoEncoderHeap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetResolutionListCount()
        }
        unsafe extern "system" fn GetResolutionList<Impl: ID3D12VideoEncoderHeap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, resolutionslistcount: u32, presolutionlist: *mut D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetResolutionList(::core::mem::transmute_copy(&resolutionslistcount), ::core::mem::transmute_copy(&presolutionlist)).into()
        }
        Self {
            base: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetNodeMask: GetNodeMask::<Impl, IMPL_OFFSET>,
            GetEncoderHeapFlags: GetEncoderHeapFlags::<Impl, IMPL_OFFSET>,
            GetCodec: GetCodec::<Impl, IMPL_OFFSET>,
            GetCodecProfile: GetCodecProfile::<Impl, IMPL_OFFSET>,
            GetCodecLevel: GetCodecLevel::<Impl, IMPL_OFFSET>,
            GetResolutionListCount: GetResolutionListCount::<Impl, IMPL_OFFSET>,
            GetResolutionList: GetResolutionList::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoEncoderHeap as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
pub trait ID3D12VideoExtensionCommand_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Object_Impl + super::super::Graphics::Direct3D12::ID3D12DeviceChild_Impl + super::super::Graphics::Direct3D12::ID3D12Pageable_Impl {
    fn GetDesc(&mut self) -> D3D12_VIDEO_EXTENSION_COMMAND_DESC;
    fn GetProtectedResourceSession(&mut self, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ID3D12VideoExtensionCommand_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoExtensionCommand_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoExtensionCommand_Vtbl {
        unsafe extern "system" fn GetDesc<Impl: ID3D12VideoExtensionCommand_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut D3D12_VIDEO_EXTENSION_COMMAND_DESC) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            *result__ = (*this).GetDesc()
        }
        unsafe extern "system" fn GetProtectedResourceSession<Impl: ID3D12VideoExtensionCommand_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetProtectedResourceSession(::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppprotectedsession)).into()
        }
        Self {
            base: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetDesc: GetDesc::<Impl, IMPL_OFFSET>,
            GetProtectedResourceSession: GetProtectedResourceSession::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoExtensionCommand as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoMotionEstimator_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Object_Impl + super::super::Graphics::Direct3D12::ID3D12DeviceChild_Impl + super::super::Graphics::Direct3D12::ID3D12Pageable_Impl {
    fn GetDesc(&mut self) -> D3D12_VIDEO_MOTION_ESTIMATOR_DESC;
    fn GetProtectedResourceSession(&mut self, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoMotionEstimator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoMotionEstimator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoMotionEstimator_Vtbl {
        unsafe extern "system" fn GetDesc<Impl: ID3D12VideoMotionEstimator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut D3D12_VIDEO_MOTION_ESTIMATOR_DESC) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            *result__ = (*this).GetDesc()
        }
        unsafe extern "system" fn GetProtectedResourceSession<Impl: ID3D12VideoMotionEstimator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetProtectedResourceSession(::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppprotectedsession)).into()
        }
        Self {
            base: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetDesc: GetDesc::<Impl, IMPL_OFFSET>,
            GetProtectedResourceSession: GetProtectedResourceSession::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoMotionEstimator as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoMotionVectorHeap_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Object_Impl + super::super::Graphics::Direct3D12::ID3D12DeviceChild_Impl + super::super::Graphics::Direct3D12::ID3D12Pageable_Impl {
    fn GetDesc(&mut self) -> D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC;
    fn GetProtectedResourceSession(&mut self, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoMotionVectorHeap_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoMotionVectorHeap_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoMotionVectorHeap_Vtbl {
        unsafe extern "system" fn GetDesc<Impl: ID3D12VideoMotionVectorHeap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            *result__ = (*this).GetDesc()
        }
        unsafe extern "system" fn GetProtectedResourceSession<Impl: ID3D12VideoMotionVectorHeap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetProtectedResourceSession(::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppprotectedsession)).into()
        }
        Self {
            base: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetDesc: GetDesc::<Impl, IMPL_OFFSET>,
            GetProtectedResourceSession: GetProtectedResourceSession::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoMotionVectorHeap as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
pub trait ID3D12VideoProcessCommandList_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Object_Impl + super::super::Graphics::Direct3D12::ID3D12DeviceChild_Impl + super::super::Graphics::Direct3D12::ID3D12CommandList_Impl {
    fn Close(&mut self) -> ::windows::core::Result<()>;
    fn Reset(&mut self, pallocator: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12CommandAllocator>) -> ::windows::core::Result<()>;
    fn ClearState(&mut self);
    fn ResourceBarrier(&mut self, numbarriers: u32, pbarriers: *const super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER);
    fn DiscardResource(&mut self, presource: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>, pregion: *const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION);
    fn BeginQuery(&mut self, pqueryheap: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12QueryHeap>, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32);
    fn EndQuery(&mut self, pqueryheap: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12QueryHeap>, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32);
    fn ResolveQueryData(&mut self, pqueryheap: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12QueryHeap>, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>, aligneddestinationbufferoffset: u64);
    fn SetPredication(&mut self, pbuffer: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12Resource>, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP);
    fn SetMarker(&mut self, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32);
    fn BeginEvent(&mut self, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32);
    fn EndEvent(&mut self);
    fn ProcessFrames(&mut self, pvideoprocessor: ::core::option::Option<ID3D12VideoProcessor>, poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS, numinputstreams: u32, pinputarguments: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS);
    fn WriteBufferImmediate(&mut self, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE);
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ID3D12VideoProcessCommandList_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoProcessCommandList_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoProcessCommandList_Vtbl {
        unsafe extern "system" fn Close<Impl: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Close().into()
        }
        unsafe extern "system" fn Reset<Impl: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pallocator: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reset(::core::mem::transmute(&pallocator)).into()
        }
        unsafe extern "system" fn ClearState<Impl: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ClearState()
        }
        unsafe extern "system" fn ResourceBarrier<Impl: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, numbarriers: u32, pbarriers: *const super::super::Graphics::Direct3D12::D3D12_RESOURCE_BARRIER) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ResourceBarrier(::core::mem::transmute_copy(&numbarriers), ::core::mem::transmute_copy(&pbarriers))
        }
        unsafe extern "system" fn DiscardResource<Impl: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presource: ::windows::core::RawPtr, pregion: *const super::super::Graphics::Direct3D12::D3D12_DISCARD_REGION) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DiscardResource(::core::mem::transmute(&presource), ::core::mem::transmute_copy(&pregion))
        }
        unsafe extern "system" fn BeginQuery<Impl: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pqueryheap: ::windows::core::RawPtr, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginQuery(::core::mem::transmute(&pqueryheap), ::core::mem::transmute_copy(&r#type), ::core::mem::transmute_copy(&index))
        }
        unsafe extern "system" fn EndQuery<Impl: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pqueryheap: ::windows::core::RawPtr, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, index: u32) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndQuery(::core::mem::transmute(&pqueryheap), ::core::mem::transmute_copy(&r#type), ::core::mem::transmute_copy(&index))
        }
        unsafe extern "system" fn ResolveQueryData<Impl: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pqueryheap: ::windows::core::RawPtr, r#type: super::super::Graphics::Direct3D12::D3D12_QUERY_TYPE, startindex: u32, numqueries: u32, pdestinationbuffer: ::windows::core::RawPtr, aligneddestinationbufferoffset: u64) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ResolveQueryData(::core::mem::transmute(&pqueryheap), ::core::mem::transmute_copy(&r#type), ::core::mem::transmute_copy(&startindex), ::core::mem::transmute_copy(&numqueries), ::core::mem::transmute(&pdestinationbuffer), ::core::mem::transmute_copy(&aligneddestinationbufferoffset))
        }
        unsafe extern "system" fn SetPredication<Impl: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbuffer: ::windows::core::RawPtr, alignedbufferoffset: u64, operation: super::super::Graphics::Direct3D12::D3D12_PREDICATION_OP) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPredication(::core::mem::transmute(&pbuffer), ::core::mem::transmute_copy(&alignedbufferoffset), ::core::mem::transmute_copy(&operation))
        }
        unsafe extern "system" fn SetMarker<Impl: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMarker(::core::mem::transmute_copy(&metadata), ::core::mem::transmute_copy(&pdata), ::core::mem::transmute_copy(&size))
        }
        unsafe extern "system" fn BeginEvent<Impl: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginEvent(::core::mem::transmute_copy(&metadata), ::core::mem::transmute_copy(&pdata), ::core::mem::transmute_copy(&size))
        }
        unsafe extern "system" fn EndEvent<Impl: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndEvent()
        }
        unsafe extern "system" fn ProcessFrames<Impl: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvideoprocessor: ::windows::core::RawPtr, poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS, numinputstreams: u32, pinputarguments: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ProcessFrames(::core::mem::transmute(&pvideoprocessor), ::core::mem::transmute_copy(&poutputarguments), ::core::mem::transmute_copy(&numinputstreams), ::core::mem::transmute_copy(&pinputarguments))
        }
        unsafe extern "system" fn WriteBufferImmediate<Impl: ID3D12VideoProcessCommandList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, count: u32, pparams: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pmodes: *const super::super::Graphics::Direct3D12::D3D12_WRITEBUFFERIMMEDIATE_MODE) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).WriteBufferImmediate(::core::mem::transmute_copy(&count), ::core::mem::transmute_copy(&pparams), ::core::mem::transmute_copy(&pmodes))
        }
        Self {
            base: super::super::Graphics::Direct3D12::ID3D12CommandList_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Close: Close::<Impl, IMPL_OFFSET>,
            Reset: Reset::<Impl, IMPL_OFFSET>,
            ClearState: ClearState::<Impl, IMPL_OFFSET>,
            ResourceBarrier: ResourceBarrier::<Impl, IMPL_OFFSET>,
            DiscardResource: DiscardResource::<Impl, IMPL_OFFSET>,
            BeginQuery: BeginQuery::<Impl, IMPL_OFFSET>,
            EndQuery: EndQuery::<Impl, IMPL_OFFSET>,
            ResolveQueryData: ResolveQueryData::<Impl, IMPL_OFFSET>,
            SetPredication: SetPredication::<Impl, IMPL_OFFSET>,
            SetMarker: SetMarker::<Impl, IMPL_OFFSET>,
            BeginEvent: BeginEvent::<Impl, IMPL_OFFSET>,
            EndEvent: EndEvent::<Impl, IMPL_OFFSET>,
            ProcessFrames: ProcessFrames::<Impl, IMPL_OFFSET>,
            WriteBufferImmediate: WriteBufferImmediate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoProcessCommandList as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
pub trait ID3D12VideoProcessCommandList1_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Object_Impl + super::super::Graphics::Direct3D12::ID3D12DeviceChild_Impl + super::super::Graphics::Direct3D12::ID3D12CommandList_Impl + ID3D12VideoProcessCommandList_Impl {
    fn ProcessFrames1(&mut self, pvideoprocessor: ::core::option::Option<ID3D12VideoProcessor>, poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS, numinputstreams: u32, pinputarguments: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1);
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ID3D12VideoProcessCommandList1_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoProcessCommandList1_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoProcessCommandList1_Vtbl {
        unsafe extern "system" fn ProcessFrames1<Impl: ID3D12VideoProcessCommandList1_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvideoprocessor: ::windows::core::RawPtr, poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS, numinputstreams: u32, pinputarguments: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ProcessFrames1(::core::mem::transmute(&pvideoprocessor), ::core::mem::transmute_copy(&poutputarguments), ::core::mem::transmute_copy(&numinputstreams), ::core::mem::transmute_copy(&pinputarguments))
        }
        Self { base: ID3D12VideoProcessCommandList_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), ProcessFrames1: ProcessFrames1::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoProcessCommandList1 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
pub trait ID3D12VideoProcessCommandList2_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Object_Impl + super::super::Graphics::Direct3D12::ID3D12DeviceChild_Impl + super::super::Graphics::Direct3D12::ID3D12CommandList_Impl + ID3D12VideoProcessCommandList_Impl + ID3D12VideoProcessCommandList1_Impl {
    fn SetProtectedResourceSession(&mut self, pprotectedresourcesession: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12ProtectedResourceSession>);
    fn InitializeExtensionCommand(&mut self, pextensioncommand: ::core::option::Option<ID3D12VideoExtensionCommand>, pinitializationparameters: *const ::core::ffi::c_void, initializationparameterssizeinbytes: usize);
    fn ExecuteExtensionCommand(&mut self, pextensioncommand: ::core::option::Option<ID3D12VideoExtensionCommand>, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize);
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl ID3D12VideoProcessCommandList2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoProcessCommandList2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoProcessCommandList2_Vtbl {
        unsafe extern "system" fn SetProtectedResourceSession<Impl: ID3D12VideoProcessCommandList2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pprotectedresourcesession: ::windows::core::RawPtr) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetProtectedResourceSession(::core::mem::transmute(&pprotectedresourcesession))
        }
        unsafe extern "system" fn InitializeExtensionCommand<Impl: ID3D12VideoProcessCommandList2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pextensioncommand: ::windows::core::RawPtr, pinitializationparameters: *const ::core::ffi::c_void, initializationparameterssizeinbytes: usize) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InitializeExtensionCommand(::core::mem::transmute(&pextensioncommand), ::core::mem::transmute_copy(&pinitializationparameters), ::core::mem::transmute_copy(&initializationparameterssizeinbytes))
        }
        unsafe extern "system" fn ExecuteExtensionCommand<Impl: ID3D12VideoProcessCommandList2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pextensioncommand: ::windows::core::RawPtr, pexecutionparameters: *const ::core::ffi::c_void, executionparameterssizeinbytes: usize) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ExecuteExtensionCommand(::core::mem::transmute(&pextensioncommand), ::core::mem::transmute_copy(&pexecutionparameters), ::core::mem::transmute_copy(&executionparameterssizeinbytes))
        }
        Self {
            base: ID3D12VideoProcessCommandList1_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetProtectedResourceSession: SetProtectedResourceSession::<Impl, IMPL_OFFSET>,
            InitializeExtensionCommand: InitializeExtensionCommand::<Impl, IMPL_OFFSET>,
            ExecuteExtensionCommand: ExecuteExtensionCommand::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoProcessCommandList2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoProcessor_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Object_Impl + super::super::Graphics::Direct3D12::ID3D12DeviceChild_Impl + super::super::Graphics::Direct3D12::ID3D12Pageable_Impl {
    fn GetNodeMask(&mut self) -> u32;
    fn GetNumInputStreamDescs(&mut self) -> u32;
    fn GetInputStreamDescs(&mut self, numinputstreamdescs: u32, pinputstreamdescs: *mut D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC) -> ::windows::core::Result<()>;
    fn GetOutputStreamDesc(&mut self) -> D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoProcessor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoProcessor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoProcessor_Vtbl {
        unsafe extern "system" fn GetNodeMask<Impl: ID3D12VideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNodeMask()
        }
        unsafe extern "system" fn GetNumInputStreamDescs<Impl: ID3D12VideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNumInputStreamDescs()
        }
        unsafe extern "system" fn GetInputStreamDescs<Impl: ID3D12VideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, numinputstreamdescs: u32, pinputstreamdescs: *mut D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetInputStreamDescs(::core::mem::transmute_copy(&numinputstreamdescs), ::core::mem::transmute_copy(&pinputstreamdescs)).into()
        }
        unsafe extern "system" fn GetOutputStreamDesc<Impl: ID3D12VideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, result__: *mut D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            *result__ = (*this).GetOutputStreamDesc()
        }
        Self {
            base: super::super::Graphics::Direct3D12::ID3D12Pageable_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetNodeMask: GetNodeMask::<Impl, IMPL_OFFSET>,
            GetNumInputStreamDescs: GetNumInputStreamDescs::<Impl, IMPL_OFFSET>,
            GetInputStreamDescs: GetInputStreamDescs::<Impl, IMPL_OFFSET>,
            GetOutputStreamDesc: GetOutputStreamDesc::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoProcessor as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
pub trait ID3D12VideoProcessor1_Impl: Sized + super::super::Graphics::Direct3D12::ID3D12Object_Impl + super::super::Graphics::Direct3D12::ID3D12DeviceChild_Impl + super::super::Graphics::Direct3D12::ID3D12Pageable_Impl + ID3D12VideoProcessor_Impl {
    fn GetProtectedResourceSession(&mut self, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12", feature = "Win32_Graphics_Dxgi_Common"))]
impl ID3D12VideoProcessor1_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ID3D12VideoProcessor1_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ID3D12VideoProcessor1_Vtbl {
        unsafe extern "system" fn GetProtectedResourceSession<Impl: ID3D12VideoProcessor1_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppprotectedsession: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetProtectedResourceSession(::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppprotectedsession)).into()
        }
        Self {
            base: ID3D12VideoProcessor_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetProtectedResourceSession: GetProtectedResourceSession::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoProcessor1 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub trait IDXVAHD_Device_Impl: Sized {
    fn CreateVideoSurface(&mut self, width: u32, height: u32, format: super::super::Graphics::Direct3D9::D3DFORMAT, pool: super::super::Graphics::Direct3D9::D3DPOOL, usage: u32, r#type: DXVAHD_SURFACE_TYPE, numsurfaces: u32, ppsurfaces: *mut ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, psharedhandle: *mut super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn GetVideoProcessorDeviceCaps(&mut self) -> ::windows::core::Result<DXVAHD_VPDEVCAPS>;
    fn GetVideoProcessorOutputFormats(&mut self, count: u32, pformats: *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::Result<()>;
    fn GetVideoProcessorInputFormats(&mut self, count: u32, pformats: *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::Result<()>;
    fn GetVideoProcessorCaps(&mut self, count: u32, pcaps: *mut DXVAHD_VPCAPS) -> ::windows::core::Result<()>;
    fn GetVideoProcessorCustomRates(&mut self, pvpguid: *const ::windows::core::GUID, count: u32, prates: *mut DXVAHD_CUSTOM_RATE_DATA) -> ::windows::core::Result<()>;
    fn GetVideoProcessorFilterRange(&mut self, filter: DXVAHD_FILTER) -> ::windows::core::Result<DXVAHD_FILTER_RANGE_DATA>;
    fn CreateVideoProcessor(&mut self, pvpguid: *const ::windows::core::GUID) -> ::windows::core::Result<IDXVAHD_VideoProcessor>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl IDXVAHD_Device_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDXVAHD_Device_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDXVAHD_Device_Vtbl {
        unsafe extern "system" fn CreateVideoSurface<Impl: IDXVAHD_Device_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, width: u32, height: u32, format: super::super::Graphics::Direct3D9::D3DFORMAT, pool: super::super::Graphics::Direct3D9::D3DPOOL, usage: u32, r#type: DXVAHD_SURFACE_TYPE, numsurfaces: u32, ppsurfaces: *mut ::windows::core::RawPtr, psharedhandle: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateVideoSurface(::core::mem::transmute_copy(&width), ::core::mem::transmute_copy(&height), ::core::mem::transmute_copy(&format), ::core::mem::transmute_copy(&pool), ::core::mem::transmute_copy(&usage), ::core::mem::transmute_copy(&r#type), ::core::mem::transmute_copy(&numsurfaces), ::core::mem::transmute_copy(&ppsurfaces), ::core::mem::transmute_copy(&psharedhandle)).into()
        }
        unsafe extern "system" fn GetVideoProcessorDeviceCaps<Impl: IDXVAHD_Device_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcaps: *mut DXVAHD_VPDEVCAPS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVideoProcessorDeviceCaps() {
                ::core::result::Result::Ok(ok__) => {
                    *pcaps = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoProcessorOutputFormats<Impl: IDXVAHD_Device_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, count: u32, pformats: *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoProcessorOutputFormats(::core::mem::transmute_copy(&count), ::core::mem::transmute_copy(&pformats)).into()
        }
        unsafe extern "system" fn GetVideoProcessorInputFormats<Impl: IDXVAHD_Device_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, count: u32, pformats: *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoProcessorInputFormats(::core::mem::transmute_copy(&count), ::core::mem::transmute_copy(&pformats)).into()
        }
        unsafe extern "system" fn GetVideoProcessorCaps<Impl: IDXVAHD_Device_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, count: u32, pcaps: *mut DXVAHD_VPCAPS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoProcessorCaps(::core::mem::transmute_copy(&count), ::core::mem::transmute_copy(&pcaps)).into()
        }
        unsafe extern "system" fn GetVideoProcessorCustomRates<Impl: IDXVAHD_Device_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvpguid: *const ::windows::core::GUID, count: u32, prates: *mut DXVAHD_CUSTOM_RATE_DATA) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoProcessorCustomRates(::core::mem::transmute_copy(&pvpguid), ::core::mem::transmute_copy(&count), ::core::mem::transmute_copy(&prates)).into()
        }
        unsafe extern "system" fn GetVideoProcessorFilterRange<Impl: IDXVAHD_Device_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, filter: DXVAHD_FILTER, prange: *mut DXVAHD_FILTER_RANGE_DATA) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVideoProcessorFilterRange(::core::mem::transmute_copy(&filter)) {
                ::core::result::Result::Ok(ok__) => {
                    *prange = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateVideoProcessor<Impl: IDXVAHD_Device_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvpguid: *const ::windows::core::GUID, ppvideoprocessor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateVideoProcessor(::core::mem::transmute_copy(&pvpguid)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppvideoprocessor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            CreateVideoSurface: CreateVideoSurface::<Impl, IMPL_OFFSET>,
            GetVideoProcessorDeviceCaps: GetVideoProcessorDeviceCaps::<Impl, IMPL_OFFSET>,
            GetVideoProcessorOutputFormats: GetVideoProcessorOutputFormats::<Impl, IMPL_OFFSET>,
            GetVideoProcessorInputFormats: GetVideoProcessorInputFormats::<Impl, IMPL_OFFSET>,
            GetVideoProcessorCaps: GetVideoProcessorCaps::<Impl, IMPL_OFFSET>,
            GetVideoProcessorCustomRates: GetVideoProcessorCustomRates::<Impl, IMPL_OFFSET>,
            GetVideoProcessorFilterRange: GetVideoProcessorFilterRange::<Impl, IMPL_OFFSET>,
            CreateVideoProcessor: CreateVideoProcessor::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDXVAHD_Device as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub trait IDXVAHD_VideoProcessor_Impl: Sized {
    fn SetVideoProcessBltState(&mut self, state: DXVAHD_BLT_STATE, datasize: u32, pdata: *const ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn GetVideoProcessBltState(&mut self, state: DXVAHD_BLT_STATE, datasize: u32, pdata: *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn SetVideoProcessStreamState(&mut self, streamnumber: u32, state: DXVAHD_STREAM_STATE, datasize: u32, pdata: *const ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn GetVideoProcessStreamState(&mut self, streamnumber: u32, state: DXVAHD_STREAM_STATE, datasize: u32, pdata: *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn VideoProcessBltHD(&mut self, poutputsurface: ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, outputframe: u32, streamcount: u32, pstreams: *const DXVAHD_STREAM_DATA) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl IDXVAHD_VideoProcessor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDXVAHD_VideoProcessor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDXVAHD_VideoProcessor_Vtbl {
        unsafe extern "system" fn SetVideoProcessBltState<Impl: IDXVAHD_VideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, state: DXVAHD_BLT_STATE, datasize: u32, pdata: *const ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVideoProcessBltState(::core::mem::transmute_copy(&state), ::core::mem::transmute_copy(&datasize), ::core::mem::transmute_copy(&pdata)).into()
        }
        unsafe extern "system" fn GetVideoProcessBltState<Impl: IDXVAHD_VideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, state: DXVAHD_BLT_STATE, datasize: u32, pdata: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoProcessBltState(::core::mem::transmute_copy(&state), ::core::mem::transmute_copy(&datasize), ::core::mem::transmute_copy(&pdata)).into()
        }
        unsafe extern "system" fn SetVideoProcessStreamState<Impl: IDXVAHD_VideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, streamnumber: u32, state: DXVAHD_STREAM_STATE, datasize: u32, pdata: *const ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVideoProcessStreamState(::core::mem::transmute_copy(&streamnumber), ::core::mem::transmute_copy(&state), ::core::mem::transmute_copy(&datasize), ::core::mem::transmute_copy(&pdata)).into()
        }
        unsafe extern "system" fn GetVideoProcessStreamState<Impl: IDXVAHD_VideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, streamnumber: u32, state: DXVAHD_STREAM_STATE, datasize: u32, pdata: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoProcessStreamState(::core::mem::transmute_copy(&streamnumber), ::core::mem::transmute_copy(&state), ::core::mem::transmute_copy(&datasize), ::core::mem::transmute_copy(&pdata)).into()
        }
        unsafe extern "system" fn VideoProcessBltHD<Impl: IDXVAHD_VideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, poutputsurface: ::windows::core::RawPtr, outputframe: u32, streamcount: u32, pstreams: *const DXVAHD_STREAM_DATA) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).VideoProcessBltHD(::core::mem::transmute(&poutputsurface), ::core::mem::transmute_copy(&outputframe), ::core::mem::transmute_copy(&streamcount), ::core::mem::transmute_copy(&pstreams)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetVideoProcessBltState: SetVideoProcessBltState::<Impl, IMPL_OFFSET>,
            GetVideoProcessBltState: GetVideoProcessBltState::<Impl, IMPL_OFFSET>,
            SetVideoProcessStreamState: SetVideoProcessStreamState::<Impl, IMPL_OFFSET>,
            GetVideoProcessStreamState: GetVideoProcessStreamState::<Impl, IMPL_OFFSET>,
            VideoProcessBltHD: VideoProcessBltHD::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDXVAHD_VideoProcessor as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub trait IDirect3D9ExOverlayExtension_Impl: Sized {
    fn CheckDeviceOverlayType(&mut self, adapter: u32, devtype: super::super::Graphics::Direct3D9::D3DDEVTYPE, overlaywidth: u32, overlayheight: u32, overlayformat: super::super::Graphics::Direct3D9::D3DFORMAT, pdisplaymode: *mut super::super::Graphics::Direct3D9::D3DDISPLAYMODEEX, displayrotation: super::super::Graphics::Direct3D9::D3DDISPLAYROTATION, poverlaycaps: *mut D3DOVERLAYCAPS) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl IDirect3D9ExOverlayExtension_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDirect3D9ExOverlayExtension_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDirect3D9ExOverlayExtension_Vtbl {
        unsafe extern "system" fn CheckDeviceOverlayType<Impl: IDirect3D9ExOverlayExtension_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, adapter: u32, devtype: super::super::Graphics::Direct3D9::D3DDEVTYPE, overlaywidth: u32, overlayheight: u32, overlayformat: super::super::Graphics::Direct3D9::D3DFORMAT, pdisplaymode: *mut super::super::Graphics::Direct3D9::D3DDISPLAYMODEEX, displayrotation: super::super::Graphics::Direct3D9::D3DDISPLAYROTATION, poverlaycaps: *mut D3DOVERLAYCAPS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CheckDeviceOverlayType(::core::mem::transmute_copy(&adapter), ::core::mem::transmute_copy(&devtype), ::core::mem::transmute_copy(&overlaywidth), ::core::mem::transmute_copy(&overlayheight), ::core::mem::transmute_copy(&overlayformat), ::core::mem::transmute_copy(&pdisplaymode), ::core::mem::transmute_copy(&displayrotation), ::core::mem::transmute_copy(&poverlaycaps)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), CheckDeviceOverlayType: CheckDeviceOverlayType::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDirect3D9ExOverlayExtension as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub trait IDirect3DAuthenticatedChannel9_Impl: Sized {
    fn GetCertificateSize(&mut self, pcertificatesize: *mut u32) -> ::windows::core::Result<()>;
    fn GetCertificate(&mut self, certifactesize: u32, ppcertificate: *mut u8) -> ::windows::core::Result<()>;
    fn NegotiateKeyExchange(&mut self, datasize: u32, pdata: *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn Query(&mut self, inputsize: u32, pinput: *const ::core::ffi::c_void, outputsize: u32, poutput: *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn Configure(&mut self, inputsize: u32, pinput: *const ::core::ffi::c_void, poutput: *mut super::super::Graphics::Direct3D9::D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl IDirect3DAuthenticatedChannel9_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDirect3DAuthenticatedChannel9_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDirect3DAuthenticatedChannel9_Vtbl {
        unsafe extern "system" fn GetCertificateSize<Impl: IDirect3DAuthenticatedChannel9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcertificatesize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCertificateSize(::core::mem::transmute_copy(&pcertificatesize)).into()
        }
        unsafe extern "system" fn GetCertificate<Impl: IDirect3DAuthenticatedChannel9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, certifactesize: u32, ppcertificate: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCertificate(::core::mem::transmute_copy(&certifactesize), ::core::mem::transmute_copy(&ppcertificate)).into()
        }
        unsafe extern "system" fn NegotiateKeyExchange<Impl: IDirect3DAuthenticatedChannel9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, datasize: u32, pdata: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NegotiateKeyExchange(::core::mem::transmute_copy(&datasize), ::core::mem::transmute_copy(&pdata)).into()
        }
        unsafe extern "system" fn Query<Impl: IDirect3DAuthenticatedChannel9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, inputsize: u32, pinput: *const ::core::ffi::c_void, outputsize: u32, poutput: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Query(::core::mem::transmute_copy(&inputsize), ::core::mem::transmute_copy(&pinput), ::core::mem::transmute_copy(&outputsize), ::core::mem::transmute_copy(&poutput)).into()
        }
        unsafe extern "system" fn Configure<Impl: IDirect3DAuthenticatedChannel9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, inputsize: u32, pinput: *const ::core::ffi::c_void, poutput: *mut super::super::Graphics::Direct3D9::D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Configure(::core::mem::transmute_copy(&inputsize), ::core::mem::transmute_copy(&pinput), ::core::mem::transmute_copy(&poutput)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetCertificateSize: GetCertificateSize::<Impl, IMPL_OFFSET>,
            GetCertificate: GetCertificate::<Impl, IMPL_OFFSET>,
            NegotiateKeyExchange: NegotiateKeyExchange::<Impl, IMPL_OFFSET>,
            Query: Query::<Impl, IMPL_OFFSET>,
            Configure: Configure::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDirect3DAuthenticatedChannel9 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub trait IDirect3DCryptoSession9_Impl: Sized {
    fn GetCertificateSize(&mut self, pcertificatesize: *mut u32) -> ::windows::core::Result<()>;
    fn GetCertificate(&mut self, certifactesize: u32, ppcertificate: *mut u8) -> ::windows::core::Result<()>;
    fn NegotiateKeyExchange(&mut self, datasize: u32, pdata: *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn EncryptionBlt(&mut self, psrcsurface: ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, pdstsurface: ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, dstsurfacesize: u32, piv: *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn DecryptionBlt(&mut self, psrcsurface: ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, pdstsurface: ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, srcsurfacesize: u32, pencryptedblockinfo: *mut super::super::Graphics::Direct3D9::D3DENCRYPTED_BLOCK_INFO, pcontentkey: *mut ::core::ffi::c_void, piv: *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn GetSurfacePitch(&mut self, psrcsurface: ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, psurfacepitch: *mut u32) -> ::windows::core::Result<()>;
    fn StartSessionKeyRefresh(&mut self, prandomnumber: *mut ::core::ffi::c_void, randomnumbersize: u32) -> ::windows::core::Result<()>;
    fn FinishSessionKeyRefresh(&mut self) -> ::windows::core::Result<()>;
    fn GetEncryptionBltKey(&mut self, preadbackkey: *mut ::core::ffi::c_void, keysize: u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl IDirect3DCryptoSession9_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDirect3DCryptoSession9_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDirect3DCryptoSession9_Vtbl {
        unsafe extern "system" fn GetCertificateSize<Impl: IDirect3DCryptoSession9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcertificatesize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCertificateSize(::core::mem::transmute_copy(&pcertificatesize)).into()
        }
        unsafe extern "system" fn GetCertificate<Impl: IDirect3DCryptoSession9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, certifactesize: u32, ppcertificate: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCertificate(::core::mem::transmute_copy(&certifactesize), ::core::mem::transmute_copy(&ppcertificate)).into()
        }
        unsafe extern "system" fn NegotiateKeyExchange<Impl: IDirect3DCryptoSession9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, datasize: u32, pdata: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NegotiateKeyExchange(::core::mem::transmute_copy(&datasize), ::core::mem::transmute_copy(&pdata)).into()
        }
        unsafe extern "system" fn EncryptionBlt<Impl: IDirect3DCryptoSession9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psrcsurface: ::windows::core::RawPtr, pdstsurface: ::windows::core::RawPtr, dstsurfacesize: u32, piv: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EncryptionBlt(::core::mem::transmute(&psrcsurface), ::core::mem::transmute(&pdstsurface), ::core::mem::transmute_copy(&dstsurfacesize), ::core::mem::transmute_copy(&piv)).into()
        }
        unsafe extern "system" fn DecryptionBlt<Impl: IDirect3DCryptoSession9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psrcsurface: ::windows::core::RawPtr, pdstsurface: ::windows::core::RawPtr, srcsurfacesize: u32, pencryptedblockinfo: *mut super::super::Graphics::Direct3D9::D3DENCRYPTED_BLOCK_INFO, pcontentkey: *mut ::core::ffi::c_void, piv: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DecryptionBlt(::core::mem::transmute(&psrcsurface), ::core::mem::transmute(&pdstsurface), ::core::mem::transmute_copy(&srcsurfacesize), ::core::mem::transmute_copy(&pencryptedblockinfo), ::core::mem::transmute_copy(&pcontentkey), ::core::mem::transmute_copy(&piv)).into()
        }
        unsafe extern "system" fn GetSurfacePitch<Impl: IDirect3DCryptoSession9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psrcsurface: ::windows::core::RawPtr, psurfacepitch: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSurfacePitch(::core::mem::transmute(&psrcsurface), ::core::mem::transmute_copy(&psurfacepitch)).into()
        }
        unsafe extern "system" fn StartSessionKeyRefresh<Impl: IDirect3DCryptoSession9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prandomnumber: *mut ::core::ffi::c_void, randomnumbersize: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StartSessionKeyRefresh(::core::mem::transmute_copy(&prandomnumber), ::core::mem::transmute_copy(&randomnumbersize)).into()
        }
        unsafe extern "system" fn FinishSessionKeyRefresh<Impl: IDirect3DCryptoSession9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).FinishSessionKeyRefresh().into()
        }
        unsafe extern "system" fn GetEncryptionBltKey<Impl: IDirect3DCryptoSession9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, preadbackkey: *mut ::core::ffi::c_void, keysize: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetEncryptionBltKey(::core::mem::transmute_copy(&preadbackkey), ::core::mem::transmute_copy(&keysize)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetCertificateSize: GetCertificateSize::<Impl, IMPL_OFFSET>,
            GetCertificate: GetCertificate::<Impl, IMPL_OFFSET>,
            NegotiateKeyExchange: NegotiateKeyExchange::<Impl, IMPL_OFFSET>,
            EncryptionBlt: EncryptionBlt::<Impl, IMPL_OFFSET>,
            DecryptionBlt: DecryptionBlt::<Impl, IMPL_OFFSET>,
            GetSurfacePitch: GetSurfacePitch::<Impl, IMPL_OFFSET>,
            StartSessionKeyRefresh: StartSessionKeyRefresh::<Impl, IMPL_OFFSET>,
            FinishSessionKeyRefresh: FinishSessionKeyRefresh::<Impl, IMPL_OFFSET>,
            GetEncryptionBltKey: GetEncryptionBltKey::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDirect3DCryptoSession9 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub trait IDirect3DDevice9Video_Impl: Sized {
    fn GetContentProtectionCaps(&mut self, pcryptotype: *const ::windows::core::GUID, pdecodeprofile: *const ::windows::core::GUID, pcaps: *mut D3DCONTENTPROTECTIONCAPS) -> ::windows::core::Result<()>;
    fn CreateAuthenticatedChannel(&mut self, channeltype: super::super::Graphics::Direct3D9::D3DAUTHENTICATEDCHANNELTYPE, ppauthenticatedchannel: *mut ::core::option::Option<IDirect3DAuthenticatedChannel9>, pchannelhandle: *mut super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn CreateCryptoSession(&mut self, pcryptotype: *const ::windows::core::GUID, pdecodeprofile: *const ::windows::core::GUID, ppcryptosession: *mut ::core::option::Option<IDirect3DCryptoSession9>, pcryptohandle: *mut super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl IDirect3DDevice9Video_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDirect3DDevice9Video_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDirect3DDevice9Video_Vtbl {
        unsafe extern "system" fn GetContentProtectionCaps<Impl: IDirect3DDevice9Video_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcryptotype: *const ::windows::core::GUID, pdecodeprofile: *const ::windows::core::GUID, pcaps: *mut D3DCONTENTPROTECTIONCAPS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetContentProtectionCaps(::core::mem::transmute_copy(&pcryptotype), ::core::mem::transmute_copy(&pdecodeprofile), ::core::mem::transmute_copy(&pcaps)).into()
        }
        unsafe extern "system" fn CreateAuthenticatedChannel<Impl: IDirect3DDevice9Video_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, channeltype: super::super::Graphics::Direct3D9::D3DAUTHENTICATEDCHANNELTYPE, ppauthenticatedchannel: *mut ::windows::core::RawPtr, pchannelhandle: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateAuthenticatedChannel(::core::mem::transmute_copy(&channeltype), ::core::mem::transmute_copy(&ppauthenticatedchannel), ::core::mem::transmute_copy(&pchannelhandle)).into()
        }
        unsafe extern "system" fn CreateCryptoSession<Impl: IDirect3DDevice9Video_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcryptotype: *const ::windows::core::GUID, pdecodeprofile: *const ::windows::core::GUID, ppcryptosession: *mut ::windows::core::RawPtr, pcryptohandle: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateCryptoSession(::core::mem::transmute_copy(&pcryptotype), ::core::mem::transmute_copy(&pdecodeprofile), ::core::mem::transmute_copy(&ppcryptosession), ::core::mem::transmute_copy(&pcryptohandle)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetContentProtectionCaps: GetContentProtectionCaps::<Impl, IMPL_OFFSET>,
            CreateAuthenticatedChannel: CreateAuthenticatedChannel::<Impl, IMPL_OFFSET>,
            CreateCryptoSession: CreateCryptoSession::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDirect3DDevice9Video as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub trait IDirect3DDeviceManager9_Impl: Sized {
    fn ResetDevice(&mut self, pdevice: ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DDevice9>, resettoken: u32) -> ::windows::core::Result<()>;
    fn OpenDeviceHandle(&mut self) -> ::windows::core::Result<super::super::Foundation::HANDLE>;
    fn CloseDeviceHandle(&mut self, hdevice: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn TestDevice(&mut self, hdevice: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn LockDevice(&mut self, hdevice: super::super::Foundation::HANDLE, ppdevice: *mut ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DDevice9>, fblock: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn UnlockDevice(&mut self, hdevice: super::super::Foundation::HANDLE, fsavestate: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetVideoService(&mut self, hdevice: super::super::Foundation::HANDLE, riid: *const ::windows::core::GUID, ppservice: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl IDirect3DDeviceManager9_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDirect3DDeviceManager9_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDirect3DDeviceManager9_Vtbl {
        unsafe extern "system" fn ResetDevice<Impl: IDirect3DDeviceManager9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdevice: ::windows::core::RawPtr, resettoken: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ResetDevice(::core::mem::transmute(&pdevice), ::core::mem::transmute_copy(&resettoken)).into()
        }
        unsafe extern "system" fn OpenDeviceHandle<Impl: IDirect3DDeviceManager9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phdevice: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OpenDeviceHandle() {
                ::core::result::Result::Ok(ok__) => {
                    *phdevice = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CloseDeviceHandle<Impl: IDirect3DDeviceManager9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CloseDeviceHandle(::core::mem::transmute_copy(&hdevice)).into()
        }
        unsafe extern "system" fn TestDevice<Impl: IDirect3DDeviceManager9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TestDevice(::core::mem::transmute_copy(&hdevice)).into()
        }
        unsafe extern "system" fn LockDevice<Impl: IDirect3DDeviceManager9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, ppdevice: *mut ::windows::core::RawPtr, fblock: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LockDevice(::core::mem::transmute_copy(&hdevice), ::core::mem::transmute_copy(&ppdevice), ::core::mem::transmute_copy(&fblock)).into()
        }
        unsafe extern "system" fn UnlockDevice<Impl: IDirect3DDeviceManager9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, fsavestate: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnlockDevice(::core::mem::transmute_copy(&hdevice), ::core::mem::transmute_copy(&fsavestate)).into()
        }
        unsafe extern "system" fn GetVideoService<Impl: IDirect3DDeviceManager9_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, riid: *const ::windows::core::GUID, ppservice: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoService(::core::mem::transmute_copy(&hdevice), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppservice)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            ResetDevice: ResetDevice::<Impl, IMPL_OFFSET>,
            OpenDeviceHandle: OpenDeviceHandle::<Impl, IMPL_OFFSET>,
            CloseDeviceHandle: CloseDeviceHandle::<Impl, IMPL_OFFSET>,
            TestDevice: TestDevice::<Impl, IMPL_OFFSET>,
            LockDevice: LockDevice::<Impl, IMPL_OFFSET>,
            UnlockDevice: UnlockDevice::<Impl, IMPL_OFFSET>,
            GetVideoService: GetVideoService::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDirect3DDeviceManager9 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub trait IDirectXVideoAccelerationService_Impl: Sized {
    fn CreateSurface(&mut self, width: u32, height: u32, backbuffers: u32, format: super::super::Graphics::Direct3D9::D3DFORMAT, pool: super::super::Graphics::Direct3D9::D3DPOOL, usage: u32, dxvatype: DXVA2_VideoRenderTargetType, ppsurface: *mut ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, psharedhandle: *mut super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl IDirectXVideoAccelerationService_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDirectXVideoAccelerationService_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDirectXVideoAccelerationService_Vtbl {
        unsafe extern "system" fn CreateSurface<Impl: IDirectXVideoAccelerationService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, width: u32, height: u32, backbuffers: u32, format: super::super::Graphics::Direct3D9::D3DFORMAT, pool: super::super::Graphics::Direct3D9::D3DPOOL, usage: u32, dxvatype: DXVA2_VideoRenderTargetType, ppsurface: *mut ::windows::core::RawPtr, psharedhandle: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateSurface(::core::mem::transmute_copy(&width), ::core::mem::transmute_copy(&height), ::core::mem::transmute_copy(&backbuffers), ::core::mem::transmute_copy(&format), ::core::mem::transmute_copy(&pool), ::core::mem::transmute_copy(&usage), ::core::mem::transmute_copy(&dxvatype), ::core::mem::transmute_copy(&ppsurface), ::core::mem::transmute_copy(&psharedhandle)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), CreateSurface: CreateSurface::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDirectXVideoAccelerationService as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub trait IDirectXVideoDecoder_Impl: Sized {
    fn GetVideoDecoderService(&mut self) -> ::windows::core::Result<IDirectXVideoDecoderService>;
    fn GetCreationParameters(&mut self, pdeviceguid: *mut ::windows::core::GUID, pvideodesc: *mut DXVA2_VideoDesc, pconfig: *mut DXVA2_ConfigPictureDecode, pdecoderrendertargets: *mut *mut ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, pnumsurfaces: *mut u32) -> ::windows::core::Result<()>;
    fn GetBuffer(&mut self, buffertype: DXVA2_BufferfType, ppbuffer: *mut *mut ::core::ffi::c_void, pbuffersize: *mut u32) -> ::windows::core::Result<()>;
    fn ReleaseBuffer(&mut self, buffertype: u32) -> ::windows::core::Result<()>;
    fn BeginFrame(&mut self, prendertarget: ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, pvpvpdata: *const ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn EndFrame(&mut self, phandlecomplete: *mut super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn Execute(&mut self, pexecuteparams: *const DXVA2_DecodeExecuteParams) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl IDirectXVideoDecoder_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDirectXVideoDecoder_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDirectXVideoDecoder_Vtbl {
        unsafe extern "system" fn GetVideoDecoderService<Impl: IDirectXVideoDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppservice: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVideoDecoderService() {
                ::core::result::Result::Ok(ok__) => {
                    *ppservice = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCreationParameters<Impl: IDirectXVideoDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdeviceguid: *mut ::windows::core::GUID, pvideodesc: *mut DXVA2_VideoDesc, pconfig: *mut DXVA2_ConfigPictureDecode, pdecoderrendertargets: *mut *mut ::windows::core::RawPtr, pnumsurfaces: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCreationParameters(::core::mem::transmute_copy(&pdeviceguid), ::core::mem::transmute_copy(&pvideodesc), ::core::mem::transmute_copy(&pconfig), ::core::mem::transmute_copy(&pdecoderrendertargets), ::core::mem::transmute_copy(&pnumsurfaces)).into()
        }
        unsafe extern "system" fn GetBuffer<Impl: IDirectXVideoDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, buffertype: DXVA2_BufferfType, ppbuffer: *mut *mut ::core::ffi::c_void, pbuffersize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetBuffer(::core::mem::transmute_copy(&buffertype), ::core::mem::transmute_copy(&ppbuffer), ::core::mem::transmute_copy(&pbuffersize)).into()
        }
        unsafe extern "system" fn ReleaseBuffer<Impl: IDirectXVideoDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, buffertype: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ReleaseBuffer(::core::mem::transmute_copy(&buffertype)).into()
        }
        unsafe extern "system" fn BeginFrame<Impl: IDirectXVideoDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prendertarget: ::windows::core::RawPtr, pvpvpdata: *const ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginFrame(::core::mem::transmute(&prendertarget), ::core::mem::transmute_copy(&pvpvpdata)).into()
        }
        unsafe extern "system" fn EndFrame<Impl: IDirectXVideoDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phandlecomplete: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndFrame(::core::mem::transmute_copy(&phandlecomplete)).into()
        }
        unsafe extern "system" fn Execute<Impl: IDirectXVideoDecoder_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pexecuteparams: *const DXVA2_DecodeExecuteParams) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Execute(::core::mem::transmute_copy(&pexecuteparams)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetVideoDecoderService: GetVideoDecoderService::<Impl, IMPL_OFFSET>,
            GetCreationParameters: GetCreationParameters::<Impl, IMPL_OFFSET>,
            GetBuffer: GetBuffer::<Impl, IMPL_OFFSET>,
            ReleaseBuffer: ReleaseBuffer::<Impl, IMPL_OFFSET>,
            BeginFrame: BeginFrame::<Impl, IMPL_OFFSET>,
            EndFrame: EndFrame::<Impl, IMPL_OFFSET>,
            Execute: Execute::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDirectXVideoDecoder as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub trait IDirectXVideoDecoderService_Impl: Sized + IDirectXVideoAccelerationService_Impl {
    fn GetDecoderDeviceGuids(&mut self, pcount: *mut u32, pguids: *mut *mut ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetDecoderRenderTargets(&mut self, guid: *const ::windows::core::GUID, pcount: *mut u32, pformats: *mut *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::Result<()>;
    fn GetDecoderConfigurations(&mut self, guid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, preserved: *mut ::core::ffi::c_void, pcount: *mut u32, ppconfigs: *mut *mut DXVA2_ConfigPictureDecode) -> ::windows::core::Result<()>;
    fn CreateVideoDecoder(&mut self, guid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, pconfig: *const DXVA2_ConfigPictureDecode, ppdecoderrendertargets: *const ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, numrendertargets: u32) -> ::windows::core::Result<IDirectXVideoDecoder>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl IDirectXVideoDecoderService_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDirectXVideoDecoderService_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDirectXVideoDecoderService_Vtbl {
        unsafe extern "system" fn GetDecoderDeviceGuids<Impl: IDirectXVideoDecoderService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcount: *mut u32, pguids: *mut *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDecoderDeviceGuids(::core::mem::transmute_copy(&pcount), ::core::mem::transmute_copy(&pguids)).into()
        }
        unsafe extern "system" fn GetDecoderRenderTargets<Impl: IDirectXVideoDecoderService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guid: *const ::windows::core::GUID, pcount: *mut u32, pformats: *mut *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDecoderRenderTargets(::core::mem::transmute_copy(&guid), ::core::mem::transmute_copy(&pcount), ::core::mem::transmute_copy(&pformats)).into()
        }
        unsafe extern "system" fn GetDecoderConfigurations<Impl: IDirectXVideoDecoderService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, preserved: *mut ::core::ffi::c_void, pcount: *mut u32, ppconfigs: *mut *mut DXVA2_ConfigPictureDecode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDecoderConfigurations(::core::mem::transmute_copy(&guid), ::core::mem::transmute_copy(&pvideodesc), ::core::mem::transmute_copy(&preserved), ::core::mem::transmute_copy(&pcount), ::core::mem::transmute_copy(&ppconfigs)).into()
        }
        unsafe extern "system" fn CreateVideoDecoder<Impl: IDirectXVideoDecoderService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, pconfig: *const DXVA2_ConfigPictureDecode, ppdecoderrendertargets: *const ::windows::core::RawPtr, numrendertargets: u32, ppdecode: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateVideoDecoder(::core::mem::transmute_copy(&guid), ::core::mem::transmute_copy(&pvideodesc), ::core::mem::transmute_copy(&pconfig), ::core::mem::transmute_copy(&ppdecoderrendertargets), ::core::mem::transmute_copy(&numrendertargets)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdecode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IDirectXVideoAccelerationService_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetDecoderDeviceGuids: GetDecoderDeviceGuids::<Impl, IMPL_OFFSET>,
            GetDecoderRenderTargets: GetDecoderRenderTargets::<Impl, IMPL_OFFSET>,
            GetDecoderConfigurations: GetDecoderConfigurations::<Impl, IMPL_OFFSET>,
            CreateVideoDecoder: CreateVideoDecoder::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDirectXVideoDecoderService as ::windows::core::Interface>::IID
    }
}
pub trait IDirectXVideoMemoryConfiguration_Impl: Sized {
    fn GetAvailableSurfaceTypeByIndex(&mut self, dwtypeindex: u32) -> ::windows::core::Result<DXVA2_SurfaceType>;
    fn SetSurfaceType(&mut self, dwtype: DXVA2_SurfaceType) -> ::windows::core::Result<()>;
}
impl IDirectXVideoMemoryConfiguration_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDirectXVideoMemoryConfiguration_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDirectXVideoMemoryConfiguration_Vtbl {
        unsafe extern "system" fn GetAvailableSurfaceTypeByIndex<Impl: IDirectXVideoMemoryConfiguration_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwtypeindex: u32, pdwtype: *mut DXVA2_SurfaceType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAvailableSurfaceTypeByIndex(::core::mem::transmute_copy(&dwtypeindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwtype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSurfaceType<Impl: IDirectXVideoMemoryConfiguration_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwtype: DXVA2_SurfaceType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSurfaceType(::core::mem::transmute_copy(&dwtype)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetAvailableSurfaceTypeByIndex: GetAvailableSurfaceTypeByIndex::<Impl, IMPL_OFFSET>,
            SetSurfaceType: SetSurfaceType::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDirectXVideoMemoryConfiguration as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub trait IDirectXVideoProcessor_Impl: Sized {
    fn GetVideoProcessorService(&mut self) -> ::windows::core::Result<IDirectXVideoProcessorService>;
    fn GetCreationParameters(&mut self, pdeviceguid: *mut ::windows::core::GUID, pvideodesc: *mut DXVA2_VideoDesc, prendertargetformat: *mut super::super::Graphics::Direct3D9::D3DFORMAT, pmaxnumsubstreams: *mut u32) -> ::windows::core::Result<()>;
    fn GetVideoProcessorCaps(&mut self) -> ::windows::core::Result<DXVA2_VideoProcessorCaps>;
    fn GetProcAmpRange(&mut self, procampcap: u32) -> ::windows::core::Result<DXVA2_ValueRange>;
    fn GetFilterPropertyRange(&mut self, filtersetting: u32) -> ::windows::core::Result<DXVA2_ValueRange>;
    fn VideoProcessBlt(&mut self, prendertarget: ::core::option::Option<super::super::Graphics::Direct3D9::IDirect3DSurface9>, pbltparams: *const DXVA2_VideoProcessBltParams, psamples: *const DXVA2_VideoSample, numsamples: u32, phandlecomplete: *mut super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl IDirectXVideoProcessor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDirectXVideoProcessor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDirectXVideoProcessor_Vtbl {
        unsafe extern "system" fn GetVideoProcessorService<Impl: IDirectXVideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppservice: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVideoProcessorService() {
                ::core::result::Result::Ok(ok__) => {
                    *ppservice = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCreationParameters<Impl: IDirectXVideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdeviceguid: *mut ::windows::core::GUID, pvideodesc: *mut DXVA2_VideoDesc, prendertargetformat: *mut super::super::Graphics::Direct3D9::D3DFORMAT, pmaxnumsubstreams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCreationParameters(::core::mem::transmute_copy(&pdeviceguid), ::core::mem::transmute_copy(&pvideodesc), ::core::mem::transmute_copy(&prendertargetformat), ::core::mem::transmute_copy(&pmaxnumsubstreams)).into()
        }
        unsafe extern "system" fn GetVideoProcessorCaps<Impl: IDirectXVideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcaps: *mut DXVA2_VideoProcessorCaps) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVideoProcessorCaps() {
                ::core::result::Result::Ok(ok__) => {
                    *pcaps = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProcAmpRange<Impl: IDirectXVideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, procampcap: u32, prange: *mut DXVA2_ValueRange) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProcAmpRange(::core::mem::transmute_copy(&procampcap)) {
                ::core::result::Result::Ok(ok__) => {
                    *prange = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFilterPropertyRange<Impl: IDirectXVideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, filtersetting: u32, prange: *mut DXVA2_ValueRange) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFilterPropertyRange(::core::mem::transmute_copy(&filtersetting)) {
                ::core::result::Result::Ok(ok__) => {
                    *prange = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn VideoProcessBlt<Impl: IDirectXVideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prendertarget: ::windows::core::RawPtr, pbltparams: *const DXVA2_VideoProcessBltParams, psamples: *const DXVA2_VideoSample, numsamples: u32, phandlecomplete: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).VideoProcessBlt(::core::mem::transmute(&prendertarget), ::core::mem::transmute_copy(&pbltparams), ::core::mem::transmute_copy(&psamples), ::core::mem::transmute_copy(&numsamples), ::core::mem::transmute_copy(&phandlecomplete)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetVideoProcessorService: GetVideoProcessorService::<Impl, IMPL_OFFSET>,
            GetCreationParameters: GetCreationParameters::<Impl, IMPL_OFFSET>,
            GetVideoProcessorCaps: GetVideoProcessorCaps::<Impl, IMPL_OFFSET>,
            GetProcAmpRange: GetProcAmpRange::<Impl, IMPL_OFFSET>,
            GetFilterPropertyRange: GetFilterPropertyRange::<Impl, IMPL_OFFSET>,
            VideoProcessBlt: VideoProcessBlt::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDirectXVideoProcessor as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
pub trait IDirectXVideoProcessorService_Impl: Sized + IDirectXVideoAccelerationService_Impl {
    fn RegisterVideoProcessorSoftwareDevice(&mut self, pcallbacks: *const ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn GetVideoProcessorDeviceGuids(&mut self, pvideodesc: *const DXVA2_VideoDesc, pcount: *mut u32, pguids: *mut *mut ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetVideoProcessorRenderTargets(&mut self, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, pcount: *mut u32, pformats: *mut *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::Result<()>;
    fn GetVideoProcessorSubStreamFormats(&mut self, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, pcount: *mut u32, pformats: *mut *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::Result<()>;
    fn GetVideoProcessorCaps(&mut self, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::Result<DXVA2_VideoProcessorCaps>;
    fn GetProcAmpRange(&mut self, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, procampcap: u32) -> ::windows::core::Result<DXVA2_ValueRange>;
    fn GetFilterPropertyRange(&mut self, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, filtersetting: u32) -> ::windows::core::Result<DXVA2_ValueRange>;
    fn CreateVideoProcessor(&mut self, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, maxnumsubstreams: u32) -> ::windows::core::Result<IDirectXVideoProcessor>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9"))]
impl IDirectXVideoProcessorService_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IDirectXVideoProcessorService_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IDirectXVideoProcessorService_Vtbl {
        unsafe extern "system" fn RegisterVideoProcessorSoftwareDevice<Impl: IDirectXVideoProcessorService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcallbacks: *const ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterVideoProcessorSoftwareDevice(::core::mem::transmute_copy(&pcallbacks)).into()
        }
        unsafe extern "system" fn GetVideoProcessorDeviceGuids<Impl: IDirectXVideoProcessorService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvideodesc: *const DXVA2_VideoDesc, pcount: *mut u32, pguids: *mut *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoProcessorDeviceGuids(::core::mem::transmute_copy(&pvideodesc), ::core::mem::transmute_copy(&pcount), ::core::mem::transmute_copy(&pguids)).into()
        }
        unsafe extern "system" fn GetVideoProcessorRenderTargets<Impl: IDirectXVideoProcessorService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, pcount: *mut u32, pformats: *mut *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoProcessorRenderTargets(::core::mem::transmute_copy(&videoprocdeviceguid), ::core::mem::transmute_copy(&pvideodesc), ::core::mem::transmute_copy(&pcount), ::core::mem::transmute_copy(&pformats)).into()
        }
        unsafe extern "system" fn GetVideoProcessorSubStreamFormats<Impl: IDirectXVideoProcessorService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, pcount: *mut u32, pformats: *mut *mut super::super::Graphics::Direct3D9::D3DFORMAT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoProcessorSubStreamFormats(::core::mem::transmute_copy(&videoprocdeviceguid), ::core::mem::transmute_copy(&pvideodesc), ::core::mem::transmute_copy(&rendertargetformat), ::core::mem::transmute_copy(&pcount), ::core::mem::transmute_copy(&pformats)).into()
        }
        unsafe extern "system" fn GetVideoProcessorCaps<Impl: IDirectXVideoProcessorService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, pcaps: *mut DXVA2_VideoProcessorCaps) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVideoProcessorCaps(::core::mem::transmute_copy(&videoprocdeviceguid), ::core::mem::transmute_copy(&pvideodesc), ::core::mem::transmute_copy(&rendertargetformat)) {
                ::core::result::Result::Ok(ok__) => {
                    *pcaps = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProcAmpRange<Impl: IDirectXVideoProcessorService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, procampcap: u32, prange: *mut DXVA2_ValueRange) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProcAmpRange(::core::mem::transmute_copy(&videoprocdeviceguid), ::core::mem::transmute_copy(&pvideodesc), ::core::mem::transmute_copy(&rendertargetformat), ::core::mem::transmute_copy(&procampcap)) {
                ::core::result::Result::Ok(ok__) => {
                    *prange = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFilterPropertyRange<Impl: IDirectXVideoProcessorService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, filtersetting: u32, prange: *mut DXVA2_ValueRange) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFilterPropertyRange(::core::mem::transmute_copy(&videoprocdeviceguid), ::core::mem::transmute_copy(&pvideodesc), ::core::mem::transmute_copy(&rendertargetformat), ::core::mem::transmute_copy(&filtersetting)) {
                ::core::result::Result::Ok(ok__) => {
                    *prange = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateVideoProcessor<Impl: IDirectXVideoProcessorService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, videoprocdeviceguid: *const ::windows::core::GUID, pvideodesc: *const DXVA2_VideoDesc, rendertargetformat: super::super::Graphics::Direct3D9::D3DFORMAT, maxnumsubstreams: u32, ppvidprocess: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateVideoProcessor(::core::mem::transmute_copy(&videoprocdeviceguid), ::core::mem::transmute_copy(&pvideodesc), ::core::mem::transmute_copy(&rendertargetformat), ::core::mem::transmute_copy(&maxnumsubstreams)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppvidprocess = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IDirectXVideoAccelerationService_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            RegisterVideoProcessorSoftwareDevice: RegisterVideoProcessorSoftwareDevice::<Impl, IMPL_OFFSET>,
            GetVideoProcessorDeviceGuids: GetVideoProcessorDeviceGuids::<Impl, IMPL_OFFSET>,
            GetVideoProcessorRenderTargets: GetVideoProcessorRenderTargets::<Impl, IMPL_OFFSET>,
            GetVideoProcessorSubStreamFormats: GetVideoProcessorSubStreamFormats::<Impl, IMPL_OFFSET>,
            GetVideoProcessorCaps: GetVideoProcessorCaps::<Impl, IMPL_OFFSET>,
            GetProcAmpRange: GetProcAmpRange::<Impl, IMPL_OFFSET>,
            GetFilterPropertyRange: GetFilterPropertyRange::<Impl, IMPL_OFFSET>,
            CreateVideoProcessor: CreateVideoProcessor::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IDirectXVideoProcessorService as ::windows::core::Interface>::IID
    }
}
pub trait IEVRFilterConfig_Impl: Sized {
    fn SetNumberOfStreams(&mut self, dwmaxstreams: u32) -> ::windows::core::Result<()>;
    fn GetNumberOfStreams(&mut self) -> ::windows::core::Result<u32>;
}
impl IEVRFilterConfig_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IEVRFilterConfig_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IEVRFilterConfig_Vtbl {
        unsafe extern "system" fn SetNumberOfStreams<Impl: IEVRFilterConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwmaxstreams: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetNumberOfStreams(::core::mem::transmute_copy(&dwmaxstreams)).into()
        }
        unsafe extern "system" fn GetNumberOfStreams<Impl: IEVRFilterConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwmaxstreams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNumberOfStreams() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwmaxstreams = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetNumberOfStreams: SetNumberOfStreams::<Impl, IMPL_OFFSET>,
            GetNumberOfStreams: GetNumberOfStreams::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IEVRFilterConfig as ::windows::core::Interface>::IID
    }
}
pub trait IEVRFilterConfigEx_Impl: Sized + IEVRFilterConfig_Impl {
    fn SetConfigPrefs(&mut self, dwconfigflags: u32) -> ::windows::core::Result<()>;
    fn GetConfigPrefs(&mut self) -> ::windows::core::Result<u32>;
}
impl IEVRFilterConfigEx_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IEVRFilterConfigEx_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IEVRFilterConfigEx_Vtbl {
        unsafe extern "system" fn SetConfigPrefs<Impl: IEVRFilterConfigEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwconfigflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetConfigPrefs(::core::mem::transmute_copy(&dwconfigflags)).into()
        }
        unsafe extern "system" fn GetConfigPrefs<Impl: IEVRFilterConfigEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwconfigflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetConfigPrefs() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwconfigflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IEVRFilterConfig_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetConfigPrefs: SetConfigPrefs::<Impl, IMPL_OFFSET>,
            GetConfigPrefs: GetConfigPrefs::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IEVRFilterConfigEx as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IEVRTrustedVideoPlugin_Impl: Sized {
    fn IsInTrustedVideoMode(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn CanConstrict(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn SetConstriction(&mut self, dwkpix: u32) -> ::windows::core::Result<()>;
    fn DisableImageExport(&mut self, bdisable: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IEVRTrustedVideoPlugin_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IEVRTrustedVideoPlugin_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IEVRTrustedVideoPlugin_Vtbl {
        unsafe extern "system" fn IsInTrustedVideoMode<Impl: IEVRTrustedVideoPlugin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pyes: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsInTrustedVideoMode() {
                ::core::result::Result::Ok(ok__) => {
                    *pyes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CanConstrict<Impl: IEVRTrustedVideoPlugin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pyes: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanConstrict() {
                ::core::result::Result::Ok(ok__) => {
                    *pyes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetConstriction<Impl: IEVRTrustedVideoPlugin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwkpix: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetConstriction(::core::mem::transmute_copy(&dwkpix)).into()
        }
        unsafe extern "system" fn DisableImageExport<Impl: IEVRTrustedVideoPlugin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bdisable: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DisableImageExport(::core::mem::transmute_copy(&bdisable)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            IsInTrustedVideoMode: IsInTrustedVideoMode::<Impl, IMPL_OFFSET>,
            CanConstrict: CanConstrict::<Impl, IMPL_OFFSET>,
            SetConstriction: SetConstriction::<Impl, IMPL_OFFSET>,
            DisableImageExport: DisableImageExport::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IEVRTrustedVideoPlugin as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IEVRVideoStreamControl_Impl: Sized {
    fn SetStreamActiveState(&mut self, factive: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetStreamActiveState(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
}
#[cfg(feature = "Win32_Foundation")]
impl IEVRVideoStreamControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IEVRVideoStreamControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IEVRVideoStreamControl_Vtbl {
        unsafe extern "system" fn SetStreamActiveState<Impl: IEVRVideoStreamControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, factive: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStreamActiveState(::core::mem::transmute_copy(&factive)).into()
        }
        unsafe extern "system" fn GetStreamActiveState<Impl: IEVRVideoStreamControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpfactive: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamActiveState() {
                ::core::result::Result::Ok(ok__) => {
                    *lpfactive = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetStreamActiveState: SetStreamActiveState::<Impl, IMPL_OFFSET>,
            GetStreamActiveState: GetStreamActiveState::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IEVRVideoStreamControl as ::windows::core::Interface>::IID
    }
}
pub trait IFileClient_Impl: Sized {
    fn GetObjectDiskSize(&mut self, pqwsize: *mut u64) -> ::windows::core::Result<()>;
    fn Write(&mut self, pfio: ::core::option::Option<IFileIo>) -> ::windows::core::Result<()>;
    fn Read(&mut self, pfio: ::core::option::Option<IFileIo>) -> ::windows::core::Result<()>;
}
impl IFileClient_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFileClient_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFileClient_Vtbl {
        unsafe extern "system" fn GetObjectDiskSize<Impl: IFileClient_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pqwsize: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetObjectDiskSize(::core::mem::transmute_copy(&pqwsize)).into()
        }
        unsafe extern "system" fn Write<Impl: IFileClient_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfio: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Write(::core::mem::transmute(&pfio)).into()
        }
        unsafe extern "system" fn Read<Impl: IFileClient_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfio: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Read(::core::mem::transmute(&pfio)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetObjectDiskSize: GetObjectDiskSize::<Impl, IMPL_OFFSET>,
            Write: Write::<Impl, IMPL_OFFSET>,
            Read: Read::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFileClient as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IFileIo_Impl: Sized {
    fn Initialize(&mut self, eaccessmode: FILE_ACCESSMODE, eopenmode: FILE_OPENMODE, pwszfilename: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn GetLength(&mut self, pqwlength: *mut u64) -> ::windows::core::Result<()>;
    fn SetLength(&mut self, qwlength: u64) -> ::windows::core::Result<()>;
    fn GetCurrentPosition(&mut self, pqwposition: *mut u64) -> ::windows::core::Result<()>;
    fn SetCurrentPosition(&mut self, qwposition: u64) -> ::windows::core::Result<()>;
    fn IsEndOfStream(&mut self, pbendofstream: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn Read(&mut self, pbt: *mut u8, ul: u32, pulread: *mut u32) -> ::windows::core::Result<()>;
    fn Write(&mut self, pbt: *mut u8, ul: u32, pulwritten: *mut u32) -> ::windows::core::Result<()>;
    fn Seek(&mut self, eseekorigin: SEEK_ORIGIN, qwseekoffset: u64, dwseekflags: u32, pqwcurrentposition: *mut u64) -> ::windows::core::Result<()>;
    fn Close(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IFileIo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IFileIo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IFileIo_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IFileIo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, eaccessmode: FILE_ACCESSMODE, eopenmode: FILE_OPENMODE, pwszfilename: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute_copy(&eaccessmode), ::core::mem::transmute_copy(&eopenmode), ::core::mem::transmute_copy(&pwszfilename)).into()
        }
        unsafe extern "system" fn GetLength<Impl: IFileIo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pqwlength: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLength(::core::mem::transmute_copy(&pqwlength)).into()
        }
        unsafe extern "system" fn SetLength<Impl: IFileIo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, qwlength: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLength(::core::mem::transmute_copy(&qwlength)).into()
        }
        unsafe extern "system" fn GetCurrentPosition<Impl: IFileIo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pqwposition: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrentPosition(::core::mem::transmute_copy(&pqwposition)).into()
        }
        unsafe extern "system" fn SetCurrentPosition<Impl: IFileIo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, qwposition: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCurrentPosition(::core::mem::transmute_copy(&qwposition)).into()
        }
        unsafe extern "system" fn IsEndOfStream<Impl: IFileIo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbendofstream: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsEndOfStream(::core::mem::transmute_copy(&pbendofstream)).into()
        }
        unsafe extern "system" fn Read<Impl: IFileIo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbt: *mut u8, ul: u32, pulread: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Read(::core::mem::transmute_copy(&pbt), ::core::mem::transmute_copy(&ul), ::core::mem::transmute_copy(&pulread)).into()
        }
        unsafe extern "system" fn Write<Impl: IFileIo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbt: *mut u8, ul: u32, pulwritten: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Write(::core::mem::transmute_copy(&pbt), ::core::mem::transmute_copy(&ul), ::core::mem::transmute_copy(&pulwritten)).into()
        }
        unsafe extern "system" fn Seek<Impl: IFileIo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, eseekorigin: SEEK_ORIGIN, qwseekoffset: u64, dwseekflags: u32, pqwcurrentposition: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Seek(::core::mem::transmute_copy(&eseekorigin), ::core::mem::transmute_copy(&qwseekoffset), ::core::mem::transmute_copy(&dwseekflags), ::core::mem::transmute_copy(&pqwcurrentposition)).into()
        }
        unsafe extern "system" fn Close<Impl: IFileIo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Close().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            SetLength: SetLength::<Impl, IMPL_OFFSET>,
            GetCurrentPosition: GetCurrentPosition::<Impl, IMPL_OFFSET>,
            SetCurrentPosition: SetCurrentPosition::<Impl, IMPL_OFFSET>,
            IsEndOfStream: IsEndOfStream::<Impl, IMPL_OFFSET>,
            Read: Read::<Impl, IMPL_OFFSET>,
            Write: Write::<Impl, IMPL_OFFSET>,
            Seek: Seek::<Impl, IMPL_OFFSET>,
            Close: Close::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IFileIo as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMF2DBuffer_Impl: Sized {
    fn Lock2D(&mut self, ppbscanline0: *mut *mut u8, plpitch: *mut i32) -> ::windows::core::Result<()>;
    fn Unlock2D(&mut self) -> ::windows::core::Result<()>;
    fn GetScanline0AndPitch(&mut self, pbscanline0: *mut *mut u8, plpitch: *mut i32) -> ::windows::core::Result<()>;
    fn IsContiguousFormat(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetContiguousLength(&mut self) -> ::windows::core::Result<u32>;
    fn ContiguousCopyTo(&mut self, pbdestbuffer: *mut u8, cbdestbuffer: u32) -> ::windows::core::Result<()>;
    fn ContiguousCopyFrom(&mut self, pbsrcbuffer: *const u8, cbsrcbuffer: u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMF2DBuffer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMF2DBuffer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMF2DBuffer_Vtbl {
        unsafe extern "system" fn Lock2D<Impl: IMF2DBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppbscanline0: *mut *mut u8, plpitch: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Lock2D(::core::mem::transmute_copy(&ppbscanline0), ::core::mem::transmute_copy(&plpitch)).into()
        }
        unsafe extern "system" fn Unlock2D<Impl: IMF2DBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Unlock2D().into()
        }
        unsafe extern "system" fn GetScanline0AndPitch<Impl: IMF2DBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbscanline0: *mut *mut u8, plpitch: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetScanline0AndPitch(::core::mem::transmute_copy(&pbscanline0), ::core::mem::transmute_copy(&plpitch)).into()
        }
        unsafe extern "system" fn IsContiguousFormat<Impl: IMF2DBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfiscontiguous: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsContiguousFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *pfiscontiguous = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetContiguousLength<Impl: IMF2DBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcblength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetContiguousLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pcblength = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContiguousCopyTo<Impl: IMF2DBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbdestbuffer: *mut u8, cbdestbuffer: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ContiguousCopyTo(::core::mem::transmute_copy(&pbdestbuffer), ::core::mem::transmute_copy(&cbdestbuffer)).into()
        }
        unsafe extern "system" fn ContiguousCopyFrom<Impl: IMF2DBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbsrcbuffer: *const u8, cbsrcbuffer: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ContiguousCopyFrom(::core::mem::transmute_copy(&pbsrcbuffer), ::core::mem::transmute_copy(&cbsrcbuffer)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Lock2D: Lock2D::<Impl, IMPL_OFFSET>,
            Unlock2D: Unlock2D::<Impl, IMPL_OFFSET>,
            GetScanline0AndPitch: GetScanline0AndPitch::<Impl, IMPL_OFFSET>,
            IsContiguousFormat: IsContiguousFormat::<Impl, IMPL_OFFSET>,
            GetContiguousLength: GetContiguousLength::<Impl, IMPL_OFFSET>,
            ContiguousCopyTo: ContiguousCopyTo::<Impl, IMPL_OFFSET>,
            ContiguousCopyFrom: ContiguousCopyFrom::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMF2DBuffer as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMF2DBuffer2_Impl: Sized + IMF2DBuffer_Impl {
    fn Lock2DSize(&mut self, lockflags: MF2DBuffer_LockFlags, ppbscanline0: *mut *mut u8, plpitch: *mut i32, ppbbufferstart: *mut *mut u8, pcbbufferlength: *mut u32) -> ::windows::core::Result<()>;
    fn Copy2DTo(&mut self, pdestbuffer: ::core::option::Option<IMF2DBuffer2>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMF2DBuffer2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMF2DBuffer2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMF2DBuffer2_Vtbl {
        unsafe extern "system" fn Lock2DSize<Impl: IMF2DBuffer2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lockflags: MF2DBuffer_LockFlags, ppbscanline0: *mut *mut u8, plpitch: *mut i32, ppbbufferstart: *mut *mut u8, pcbbufferlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Lock2DSize(::core::mem::transmute_copy(&lockflags), ::core::mem::transmute_copy(&ppbscanline0), ::core::mem::transmute_copy(&plpitch), ::core::mem::transmute_copy(&ppbbufferstart), ::core::mem::transmute_copy(&pcbbufferlength)).into()
        }
        unsafe extern "system" fn Copy2DTo<Impl: IMF2DBuffer2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdestbuffer: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Copy2DTo(::core::mem::transmute(&pdestbuffer)).into()
        }
        Self {
            base: IMF2DBuffer_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            Lock2DSize: Lock2DSize::<Impl, IMPL_OFFSET>,
            Copy2DTo: Copy2DTo::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMF2DBuffer2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub trait IMFASFContentInfo_Impl: Sized {
    fn GetHeaderSize(&mut self, pistartofcontent: ::core::option::Option<IMFMediaBuffer>) -> ::windows::core::Result<u64>;
    fn ParseHeader(&mut self, piheaderbuffer: ::core::option::Option<IMFMediaBuffer>, cboffsetwithinheader: u64) -> ::windows::core::Result<()>;
    fn GenerateHeader(&mut self, piheader: ::core::option::Option<IMFMediaBuffer>, pcbheader: *mut u32) -> ::windows::core::Result<()>;
    fn GetProfile(&mut self) -> ::windows::core::Result<IMFASFProfile>;
    fn SetProfile(&mut self, piprofile: ::core::option::Option<IMFASFProfile>) -> ::windows::core::Result<()>;
    fn GeneratePresentationDescriptor(&mut self) -> ::windows::core::Result<IMFPresentationDescriptor>;
    fn GetEncodingConfigurationPropertyStore(&mut self, wstreamnumber: u16) -> ::windows::core::Result<super::super::UI::Shell::PropertiesSystem::IPropertyStore>;
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl IMFASFContentInfo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFASFContentInfo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFASFContentInfo_Vtbl {
        unsafe extern "system" fn GetHeaderSize<Impl: IMFASFContentInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pistartofcontent: ::windows::core::RawPtr, cbheadersize: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetHeaderSize(::core::mem::transmute(&pistartofcontent)) {
                ::core::result::Result::Ok(ok__) => {
                    *cbheadersize = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ParseHeader<Impl: IMFASFContentInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, piheaderbuffer: ::windows::core::RawPtr, cboffsetwithinheader: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ParseHeader(::core::mem::transmute(&piheaderbuffer), ::core::mem::transmute_copy(&cboffsetwithinheader)).into()
        }
        unsafe extern "system" fn GenerateHeader<Impl: IMFASFContentInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, piheader: ::windows::core::RawPtr, pcbheader: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GenerateHeader(::core::mem::transmute(&piheader), ::core::mem::transmute_copy(&pcbheader)).into()
        }
        unsafe extern "system" fn GetProfile<Impl: IMFASFContentInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppiprofile: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProfile() {
                ::core::result::Result::Ok(ok__) => {
                    *ppiprofile = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProfile<Impl: IMFASFContentInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, piprofile: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetProfile(::core::mem::transmute(&piprofile)).into()
        }
        unsafe extern "system" fn GeneratePresentationDescriptor<Impl: IMFASFContentInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppipresentationdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GeneratePresentationDescriptor() {
                ::core::result::Result::Ok(ok__) => {
                    *ppipresentationdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEncodingConfigurationPropertyStore<Impl: IMFASFContentInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wstreamnumber: u16, ppistore: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEncodingConfigurationPropertyStore(::core::mem::transmute_copy(&wstreamnumber)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppistore = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetHeaderSize: GetHeaderSize::<Impl, IMPL_OFFSET>,
            ParseHeader: ParseHeader::<Impl, IMPL_OFFSET>,
            GenerateHeader: GenerateHeader::<Impl, IMPL_OFFSET>,
            GetProfile: GetProfile::<Impl, IMPL_OFFSET>,
            SetProfile: SetProfile::<Impl, IMPL_OFFSET>,
            GeneratePresentationDescriptor: GeneratePresentationDescriptor::<Impl, IMPL_OFFSET>,
            GetEncodingConfigurationPropertyStore: GetEncodingConfigurationPropertyStore::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFASFContentInfo as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFASFIndexer_Impl: Sized {
    fn SetFlags(&mut self, dwflags: u32) -> ::windows::core::Result<()>;
    fn GetFlags(&mut self) -> ::windows::core::Result<u32>;
    fn Initialize(&mut self, picontentinfo: ::core::option::Option<IMFASFContentInfo>) -> ::windows::core::Result<()>;
    fn GetIndexPosition(&mut self, picontentinfo: ::core::option::Option<IMFASFContentInfo>) -> ::windows::core::Result<u64>;
    fn SetIndexByteStreams(&mut self, ppibytestreams: *const ::core::option::Option<IMFByteStream>, cbytestreams: u32) -> ::windows::core::Result<()>;
    fn GetIndexByteStreamCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetIndexStatus(&mut self, pindexidentifier: *const ASF_INDEX_IDENTIFIER, pfisindexed: *mut super::super::Foundation::BOOL, pbindexdescriptor: *mut u8, pcbindexdescriptor: *mut u32) -> ::windows::core::Result<()>;
    fn SetIndexStatus(&mut self, pbindexdescriptor: *const u8, cbindexdescriptor: u32, fgenerateindex: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetSeekPositionForValue(&mut self, pvarvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pindexidentifier: *const ASF_INDEX_IDENTIFIER, pcboffsetwithindata: *mut u64, phnsapproxtime: *mut i64, pdwpayloadnumberofstreamwithinpacket: *mut u32) -> ::windows::core::Result<()>;
    fn GenerateIndexEntries(&mut self, piasfpacketsample: ::core::option::Option<IMFSample>) -> ::windows::core::Result<()>;
    fn CommitIndex(&mut self, picontentinfo: ::core::option::Option<IMFASFContentInfo>) -> ::windows::core::Result<()>;
    fn GetIndexWriteSpace(&mut self) -> ::windows::core::Result<u64>;
    fn GetCompletedIndex(&mut self, piindexbuffer: ::core::option::Option<IMFMediaBuffer>, cboffsetwithinindex: u64) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFASFIndexer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFASFIndexer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFASFIndexer_Vtbl {
        unsafe extern "system" fn SetFlags<Impl: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFlags(::core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn GetFlags<Impl: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFlags() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Initialize<Impl: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, picontentinfo: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&picontentinfo)).into()
        }
        unsafe extern "system" fn GetIndexPosition<Impl: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, picontentinfo: ::windows::core::RawPtr, pcbindexoffset: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIndexPosition(::core::mem::transmute(&picontentinfo)) {
                ::core::result::Result::Ok(ok__) => {
                    *pcbindexoffset = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIndexByteStreams<Impl: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppibytestreams: *const ::windows::core::RawPtr, cbytestreams: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIndexByteStreams(::core::mem::transmute_copy(&ppibytestreams), ::core::mem::transmute_copy(&cbytestreams)).into()
        }
        unsafe extern "system" fn GetIndexByteStreamCount<Impl: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcbytestreams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIndexByteStreamCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pcbytestreams = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIndexStatus<Impl: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pindexidentifier: *const ASF_INDEX_IDENTIFIER, pfisindexed: *mut super::super::Foundation::BOOL, pbindexdescriptor: *mut u8, pcbindexdescriptor: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetIndexStatus(::core::mem::transmute_copy(&pindexidentifier), ::core::mem::transmute_copy(&pfisindexed), ::core::mem::transmute_copy(&pbindexdescriptor), ::core::mem::transmute_copy(&pcbindexdescriptor)).into()
        }
        unsafe extern "system" fn SetIndexStatus<Impl: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbindexdescriptor: *const u8, cbindexdescriptor: u32, fgenerateindex: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIndexStatus(::core::mem::transmute_copy(&pbindexdescriptor), ::core::mem::transmute_copy(&cbindexdescriptor), ::core::mem::transmute_copy(&fgenerateindex)).into()
        }
        unsafe extern "system" fn GetSeekPositionForValue<Impl: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvarvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pindexidentifier: *const ASF_INDEX_IDENTIFIER, pcboffsetwithindata: *mut u64, phnsapproxtime: *mut i64, pdwpayloadnumberofstreamwithinpacket: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSeekPositionForValue(::core::mem::transmute_copy(&pvarvalue), ::core::mem::transmute_copy(&pindexidentifier), ::core::mem::transmute_copy(&pcboffsetwithindata), ::core::mem::transmute_copy(&phnsapproxtime), ::core::mem::transmute_copy(&pdwpayloadnumberofstreamwithinpacket)).into()
        }
        unsafe extern "system" fn GenerateIndexEntries<Impl: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, piasfpacketsample: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GenerateIndexEntries(::core::mem::transmute(&piasfpacketsample)).into()
        }
        unsafe extern "system" fn CommitIndex<Impl: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, picontentinfo: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CommitIndex(::core::mem::transmute(&picontentinfo)).into()
        }
        unsafe extern "system" fn GetIndexWriteSpace<Impl: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcbindexwritespace: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIndexWriteSpace() {
                ::core::result::Result::Ok(ok__) => {
                    *pcbindexwritespace = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCompletedIndex<Impl: IMFASFIndexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, piindexbuffer: ::windows::core::RawPtr, cboffsetwithinindex: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCompletedIndex(::core::mem::transmute(&piindexbuffer), ::core::mem::transmute_copy(&cboffsetwithinindex)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetFlags: SetFlags::<Impl, IMPL_OFFSET>,
            GetFlags: GetFlags::<Impl, IMPL_OFFSET>,
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            GetIndexPosition: GetIndexPosition::<Impl, IMPL_OFFSET>,
            SetIndexByteStreams: SetIndexByteStreams::<Impl, IMPL_OFFSET>,
            GetIndexByteStreamCount: GetIndexByteStreamCount::<Impl, IMPL_OFFSET>,
            GetIndexStatus: GetIndexStatus::<Impl, IMPL_OFFSET>,
            SetIndexStatus: SetIndexStatus::<Impl, IMPL_OFFSET>,
            GetSeekPositionForValue: GetSeekPositionForValue::<Impl, IMPL_OFFSET>,
            GenerateIndexEntries: GenerateIndexEntries::<Impl, IMPL_OFFSET>,
            CommitIndex: CommitIndex::<Impl, IMPL_OFFSET>,
            GetIndexWriteSpace: GetIndexWriteSpace::<Impl, IMPL_OFFSET>,
            GetCompletedIndex: GetCompletedIndex::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFASFIndexer as ::windows::core::Interface>::IID
    }
}
pub trait IMFASFMultiplexer_Impl: Sized {
    fn Initialize(&mut self, picontentinfo: ::core::option::Option<IMFASFContentInfo>) -> ::windows::core::Result<()>;
    fn SetFlags(&mut self, dwflags: u32) -> ::windows::core::Result<()>;
    fn GetFlags(&mut self) -> ::windows::core::Result<u32>;
    fn ProcessSample(&mut self, wstreamnumber: u16, pisample: ::core::option::Option<IMFSample>, hnstimestampadjust: i64) -> ::windows::core::Result<()>;
    fn GetNextPacket(&mut self, pdwstatusflags: *mut u32, ppipacket: *mut ::core::option::Option<IMFSample>) -> ::windows::core::Result<()>;
    fn Flush(&mut self) -> ::windows::core::Result<()>;
    fn End(&mut self, picontentinfo: ::core::option::Option<IMFASFContentInfo>) -> ::windows::core::Result<()>;
    fn GetStatistics(&mut self, wstreamnumber: u16) -> ::windows::core::Result<ASF_MUX_STATISTICS>;
    fn SetSyncTolerance(&mut self, mssynctolerance: u32) -> ::windows::core::Result<()>;
}
impl IMFASFMultiplexer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFASFMultiplexer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFASFMultiplexer_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IMFASFMultiplexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, picontentinfo: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&picontentinfo)).into()
        }
        unsafe extern "system" fn SetFlags<Impl: IMFASFMultiplexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFlags(::core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn GetFlags<Impl: IMFASFMultiplexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFlags() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProcessSample<Impl: IMFASFMultiplexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wstreamnumber: u16, pisample: ::windows::core::RawPtr, hnstimestampadjust: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ProcessSample(::core::mem::transmute_copy(&wstreamnumber), ::core::mem::transmute(&pisample), ::core::mem::transmute_copy(&hnstimestampadjust)).into()
        }
        unsafe extern "system" fn GetNextPacket<Impl: IMFASFMultiplexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwstatusflags: *mut u32, ppipacket: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNextPacket(::core::mem::transmute_copy(&pdwstatusflags), ::core::mem::transmute_copy(&ppipacket)).into()
        }
        unsafe extern "system" fn Flush<Impl: IMFASFMultiplexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Flush().into()
        }
        unsafe extern "system" fn End<Impl: IMFASFMultiplexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, picontentinfo: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).End(::core::mem::transmute(&picontentinfo)).into()
        }
        unsafe extern "system" fn GetStatistics<Impl: IMFASFMultiplexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wstreamnumber: u16, pmuxstats: *mut ASF_MUX_STATISTICS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStatistics(::core::mem::transmute_copy(&wstreamnumber)) {
                ::core::result::Result::Ok(ok__) => {
                    *pmuxstats = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSyncTolerance<Impl: IMFASFMultiplexer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mssynctolerance: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSyncTolerance(::core::mem::transmute_copy(&mssynctolerance)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            SetFlags: SetFlags::<Impl, IMPL_OFFSET>,
            GetFlags: GetFlags::<Impl, IMPL_OFFSET>,
            ProcessSample: ProcessSample::<Impl, IMPL_OFFSET>,
            GetNextPacket: GetNextPacket::<Impl, IMPL_OFFSET>,
            Flush: Flush::<Impl, IMPL_OFFSET>,
            End: End::<Impl, IMPL_OFFSET>,
            GetStatistics: GetStatistics::<Impl, IMPL_OFFSET>,
            SetSyncTolerance: SetSyncTolerance::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFASFMultiplexer as ::windows::core::Interface>::IID
    }
}
pub trait IMFASFMutualExclusion_Impl: Sized {
    fn GetType(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn SetType(&mut self, guidtype: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetRecordCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetStreamsForRecord(&mut self, dwrecordnumber: u32, pwstreamnumarray: *mut u16, pcstreams: *mut u32) -> ::windows::core::Result<()>;
    fn AddStreamForRecord(&mut self, dwrecordnumber: u32, wstreamnumber: u16) -> ::windows::core::Result<()>;
    fn RemoveStreamFromRecord(&mut self, dwrecordnumber: u32, wstreamnumber: u16) -> ::windows::core::Result<()>;
    fn RemoveRecord(&mut self, dwrecordnumber: u32) -> ::windows::core::Result<()>;
    fn AddRecord(&mut self) -> ::windows::core::Result<u32>;
    fn Clone(&mut self) -> ::windows::core::Result<IMFASFMutualExclusion>;
}
impl IMFASFMutualExclusion_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFASFMutualExclusion_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFASFMutualExclusion_Vtbl {
        unsafe extern "system" fn GetType<Impl: IMFASFMutualExclusion_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguidtype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetType() {
                ::core::result::Result::Ok(ok__) => {
                    *pguidtype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetType<Impl: IMFASFMutualExclusion_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidtype: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetType(::core::mem::transmute_copy(&guidtype)).into()
        }
        unsafe extern "system" fn GetRecordCount<Impl: IMFASFMutualExclusion_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwrecordcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRecordCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwrecordcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamsForRecord<Impl: IMFASFMutualExclusion_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordnumber: u32, pwstreamnumarray: *mut u16, pcstreams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetStreamsForRecord(::core::mem::transmute_copy(&dwrecordnumber), ::core::mem::transmute_copy(&pwstreamnumarray), ::core::mem::transmute_copy(&pcstreams)).into()
        }
        unsafe extern "system" fn AddStreamForRecord<Impl: IMFASFMutualExclusion_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordnumber: u32, wstreamnumber: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddStreamForRecord(::core::mem::transmute_copy(&dwrecordnumber), ::core::mem::transmute_copy(&wstreamnumber)).into()
        }
        unsafe extern "system" fn RemoveStreamFromRecord<Impl: IMFASFMutualExclusion_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordnumber: u32, wstreamnumber: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveStreamFromRecord(::core::mem::transmute_copy(&dwrecordnumber), ::core::mem::transmute_copy(&wstreamnumber)).into()
        }
        unsafe extern "system" fn RemoveRecord<Impl: IMFASFMutualExclusion_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrecordnumber: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveRecord(::core::mem::transmute_copy(&dwrecordnumber)).into()
        }
        unsafe extern "system" fn AddRecord<Impl: IMFASFMutualExclusion_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwrecordnumber: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddRecord() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwrecordnumber = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IMFASFMutualExclusion_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppimutex: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *ppimutex = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetType: GetType::<Impl, IMPL_OFFSET>,
            SetType: SetType::<Impl, IMPL_OFFSET>,
            GetRecordCount: GetRecordCount::<Impl, IMPL_OFFSET>,
            GetStreamsForRecord: GetStreamsForRecord::<Impl, IMPL_OFFSET>,
            AddStreamForRecord: AddStreamForRecord::<Impl, IMPL_OFFSET>,
            RemoveStreamFromRecord: RemoveStreamFromRecord::<Impl, IMPL_OFFSET>,
            RemoveRecord: RemoveRecord::<Impl, IMPL_OFFSET>,
            AddRecord: AddRecord::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFASFMutualExclusion as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFASFProfile_Impl: Sized + IMFAttributes_Impl {
    fn GetStreamCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetStream(&mut self, dwstreamindex: u32, pwstreamnumber: *mut u16, ppistream: *mut ::core::option::Option<IMFASFStreamConfig>) -> ::windows::core::Result<()>;
    fn GetStreamByNumber(&mut self, wstreamnumber: u16) -> ::windows::core::Result<IMFASFStreamConfig>;
    fn SetStream(&mut self, pistream: ::core::option::Option<IMFASFStreamConfig>) -> ::windows::core::Result<()>;
    fn RemoveStream(&mut self, wstreamnumber: u16) -> ::windows::core::Result<()>;
    fn CreateStream(&mut self, pimediatype: ::core::option::Option<IMFMediaType>) -> ::windows::core::Result<IMFASFStreamConfig>;
    fn GetMutualExclusionCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetMutualExclusion(&mut self, dwmutexindex: u32) -> ::windows::core::Result<IMFASFMutualExclusion>;
    fn AddMutualExclusion(&mut self, pimutex: ::core::option::Option<IMFASFMutualExclusion>) -> ::windows::core::Result<()>;
    fn RemoveMutualExclusion(&mut self, dwmutexindex: u32) -> ::windows::core::Result<()>;
    fn CreateMutualExclusion(&mut self) -> ::windows::core::Result<IMFASFMutualExclusion>;
    fn GetStreamPrioritization(&mut self) -> ::windows::core::Result<IMFASFStreamPrioritization>;
    fn AddStreamPrioritization(&mut self, pistreamprioritization: ::core::option::Option<IMFASFStreamPrioritization>) -> ::windows::core::Result<()>;
    fn RemoveStreamPrioritization(&mut self) -> ::windows::core::Result<()>;
    fn CreateStreamPrioritization(&mut self) -> ::windows::core::Result<IMFASFStreamPrioritization>;
    fn Clone(&mut self) -> ::windows::core::Result<IMFASFProfile>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFASFProfile_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFASFProfile_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFASFProfile_Vtbl {
        unsafe extern "system" fn GetStreamCount<Impl: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcstreams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pcstreams = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStream<Impl: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pwstreamnumber: *mut u16, ppistream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetStream(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&pwstreamnumber), ::core::mem::transmute_copy(&ppistream)).into()
        }
        unsafe extern "system" fn GetStreamByNumber<Impl: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wstreamnumber: u16, ppistream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamByNumber(::core::mem::transmute_copy(&wstreamnumber)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppistream = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStream<Impl: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pistream: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStream(::core::mem::transmute(&pistream)).into()
        }
        unsafe extern "system" fn RemoveStream<Impl: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wstreamnumber: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveStream(::core::mem::transmute_copy(&wstreamnumber)).into()
        }
        unsafe extern "system" fn CreateStream<Impl: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pimediatype: ::windows::core::RawPtr, ppistream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateStream(::core::mem::transmute(&pimediatype)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppistream = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMutualExclusionCount<Impl: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcmutexs: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMutualExclusionCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pcmutexs = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMutualExclusion<Impl: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwmutexindex: u32, ppimutex: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMutualExclusion(::core::mem::transmute_copy(&dwmutexindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppimutex = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddMutualExclusion<Impl: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pimutex: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddMutualExclusion(::core::mem::transmute(&pimutex)).into()
        }
        unsafe extern "system" fn RemoveMutualExclusion<Impl: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwmutexindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveMutualExclusion(::core::mem::transmute_copy(&dwmutexindex)).into()
        }
        unsafe extern "system" fn CreateMutualExclusion<Impl: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppimutex: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateMutualExclusion() {
                ::core::result::Result::Ok(ok__) => {
                    *ppimutex = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamPrioritization<Impl: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppistreamprioritization: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamPrioritization() {
                ::core::result::Result::Ok(ok__) => {
                    *ppistreamprioritization = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddStreamPrioritization<Impl: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pistreamprioritization: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddStreamPrioritization(::core::mem::transmute(&pistreamprioritization)).into()
        }
        unsafe extern "system" fn RemoveStreamPrioritization<Impl: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveStreamPrioritization().into()
        }
        unsafe extern "system" fn CreateStreamPrioritization<Impl: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppistreamprioritization: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateStreamPrioritization() {
                ::core::result::Result::Ok(ok__) => {
                    *ppistreamprioritization = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clone<Impl: IMFASFProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppiprofile: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *ppiprofile = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMFAttributes_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetStreamCount: GetStreamCount::<Impl, IMPL_OFFSET>,
            GetStream: GetStream::<Impl, IMPL_OFFSET>,
            GetStreamByNumber: GetStreamByNumber::<Impl, IMPL_OFFSET>,
            SetStream: SetStream::<Impl, IMPL_OFFSET>,
            RemoveStream: RemoveStream::<Impl, IMPL_OFFSET>,
            CreateStream: CreateStream::<Impl, IMPL_OFFSET>,
            GetMutualExclusionCount: GetMutualExclusionCount::<Impl, IMPL_OFFSET>,
            GetMutualExclusion: GetMutualExclusion::<Impl, IMPL_OFFSET>,
            AddMutualExclusion: AddMutualExclusion::<Impl, IMPL_OFFSET>,
            RemoveMutualExclusion: RemoveMutualExclusion::<Impl, IMPL_OFFSET>,
            CreateMutualExclusion: CreateMutualExclusion::<Impl, IMPL_OFFSET>,
            GetStreamPrioritization: GetStreamPrioritization::<Impl, IMPL_OFFSET>,
            AddStreamPrioritization: AddStreamPrioritization::<Impl, IMPL_OFFSET>,
            RemoveStreamPrioritization: RemoveStreamPrioritization::<Impl, IMPL_OFFSET>,
            CreateStreamPrioritization: CreateStreamPrioritization::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFASFProfile as ::windows::core::Interface>::IID
    }
}
pub trait IMFASFSplitter_Impl: Sized {
    fn Initialize(&mut self, picontentinfo: ::core::option::Option<IMFASFContentInfo>) -> ::windows::core::Result<()>;
    fn SetFlags(&mut self, dwflags: u32) -> ::windows::core::Result<()>;
    fn GetFlags(&mut self) -> ::windows::core::Result<u32>;
    fn SelectStreams(&mut self, pwstreamnumbers: *const u16, wnumstreams: u16) -> ::windows::core::Result<()>;
    fn GetSelectedStreams(&mut self, pwstreamnumbers: *mut u16, pwnumstreams: *mut u16) -> ::windows::core::Result<()>;
    fn ParseData(&mut self, pibuffer: ::core::option::Option<IMFMediaBuffer>, cbbufferoffset: u32, cblength: u32) -> ::windows::core::Result<()>;
    fn GetNextSample(&mut self, pdwstatusflags: *mut ASF_STATUSFLAGS, pwstreamnumber: *mut u16, ppisample: *mut ::core::option::Option<IMFSample>) -> ::windows::core::Result<()>;
    fn Flush(&mut self) -> ::windows::core::Result<()>;
    fn GetLastSendTime(&mut self) -> ::windows::core::Result<u32>;
}
impl IMFASFSplitter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFASFSplitter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFASFSplitter_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IMFASFSplitter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, picontentinfo: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&picontentinfo)).into()
        }
        unsafe extern "system" fn SetFlags<Impl: IMFASFSplitter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFlags(::core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn GetFlags<Impl: IMFASFSplitter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFlags() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SelectStreams<Impl: IMFASFSplitter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwstreamnumbers: *const u16, wnumstreams: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectStreams(::core::mem::transmute_copy(&pwstreamnumbers), ::core::mem::transmute_copy(&wnumstreams)).into()
        }
        unsafe extern "system" fn GetSelectedStreams<Impl: IMFASFSplitter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwstreamnumbers: *mut u16, pwnumstreams: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSelectedStreams(::core::mem::transmute_copy(&pwstreamnumbers), ::core::mem::transmute_copy(&pwnumstreams)).into()
        }
        unsafe extern "system" fn ParseData<Impl: IMFASFSplitter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pibuffer: ::windows::core::RawPtr, cbbufferoffset: u32, cblength: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ParseData(::core::mem::transmute(&pibuffer), ::core::mem::transmute_copy(&cbbufferoffset), ::core::mem::transmute_copy(&cblength)).into()
        }
        unsafe extern "system" fn GetNextSample<Impl: IMFASFSplitter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwstatusflags: *mut ASF_STATUSFLAGS, pwstreamnumber: *mut u16, ppisample: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNextSample(::core::mem::transmute_copy(&pdwstatusflags), ::core::mem::transmute_copy(&pwstreamnumber), ::core::mem::transmute_copy(&ppisample)).into()
        }
        unsafe extern "system" fn Flush<Impl: IMFASFSplitter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Flush().into()
        }
        unsafe extern "system" fn GetLastSendTime<Impl: IMFASFSplitter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwlastsendtime: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLastSendTime() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwlastsendtime = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            SetFlags: SetFlags::<Impl, IMPL_OFFSET>,
            GetFlags: GetFlags::<Impl, IMPL_OFFSET>,
            SelectStreams: SelectStreams::<Impl, IMPL_OFFSET>,
            GetSelectedStreams: GetSelectedStreams::<Impl, IMPL_OFFSET>,
            ParseData: ParseData::<Impl, IMPL_OFFSET>,
            GetNextSample: GetNextSample::<Impl, IMPL_OFFSET>,
            Flush: Flush::<Impl, IMPL_OFFSET>,
            GetLastSendTime: GetLastSendTime::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFASFSplitter as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFASFStreamConfig_Impl: Sized + IMFAttributes_Impl {
    fn GetStreamType(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn GetStreamNumber(&mut self) -> u16;
    fn SetStreamNumber(&mut self, wstreamnum: u16) -> ::windows::core::Result<()>;
    fn GetMediaType(&mut self) -> ::windows::core::Result<IMFMediaType>;
    fn SetMediaType(&mut self, pimediatype: ::core::option::Option<IMFMediaType>) -> ::windows::core::Result<()>;
    fn GetPayloadExtensionCount(&mut self) -> ::windows::core::Result<u16>;
    fn GetPayloadExtension(&mut self, wpayloadextensionnumber: u16, pguidextensionsystemid: *mut ::windows::core::GUID, pcbextensiondatasize: *mut u16, pbextensionsysteminfo: *mut u8, pcbextensionsysteminfo: *mut u32) -> ::windows::core::Result<()>;
    fn AddPayloadExtension(&mut self, guidextensionsystemid: ::windows::core::GUID, cbextensiondatasize: u16, pbextensionsysteminfo: *const u8, cbextensionsysteminfo: u32) -> ::windows::core::Result<()>;
    fn RemoveAllPayloadExtensions(&mut self) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<IMFASFStreamConfig>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFASFStreamConfig_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFASFStreamConfig_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFASFStreamConfig_Vtbl {
        unsafe extern "system" fn GetStreamType<Impl: IMFASFStreamConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguidstreamtype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamType() {
                ::core::result::Result::Ok(ok__) => {
                    *pguidstreamtype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamNumber<Impl: IMFASFStreamConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u16 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetStreamNumber()
        }
        unsafe extern "system" fn SetStreamNumber<Impl: IMFASFStreamConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wstreamnum: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStreamNumber(::core::mem::transmute_copy(&wstreamnum)).into()
        }
        unsafe extern "system" fn GetMediaType<Impl: IMFASFStreamConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppimediatype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMediaType() {
                ::core::result::Result::Ok(ok__) => {
                    *ppimediatype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaType<Impl: IMFASFStreamConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pimediatype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMediaType(::core::mem::transmute(&pimediatype)).into()
        }
        unsafe extern "system" fn GetPayloadExtensionCount<Impl: IMFASFStreamConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcpayloadextensions: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPayloadExtensionCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pcpayloadextensions = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPayloadExtension<Impl: IMFASFStreamConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wpayloadextensionnumber: u16, pguidextensionsystemid: *mut ::windows::core::GUID, pcbextensiondatasize: *mut u16, pbextensionsysteminfo: *mut u8, pcbextensionsysteminfo: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPayloadExtension(::core::mem::transmute_copy(&wpayloadextensionnumber), ::core::mem::transmute_copy(&pguidextensionsystemid), ::core::mem::transmute_copy(&pcbextensiondatasize), ::core::mem::transmute_copy(&pbextensionsysteminfo), ::core::mem::transmute_copy(&pcbextensionsysteminfo)).into()
        }
        unsafe extern "system" fn AddPayloadExtension<Impl: IMFASFStreamConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidextensionsystemid: ::windows::core::GUID, cbextensiondatasize: u16, pbextensionsysteminfo: *const u8, cbextensionsysteminfo: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddPayloadExtension(::core::mem::transmute_copy(&guidextensionsystemid), ::core::mem::transmute_copy(&cbextensiondatasize), ::core::mem::transmute_copy(&pbextensionsysteminfo), ::core::mem::transmute_copy(&cbextensionsysteminfo)).into()
        }
        unsafe extern "system" fn RemoveAllPayloadExtensions<Impl: IMFASFStreamConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveAllPayloadExtensions().into()
        }
        unsafe extern "system" fn Clone<Impl: IMFASFStreamConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppistreamconfig: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *ppistreamconfig = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMFAttributes_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetStreamType: GetStreamType::<Impl, IMPL_OFFSET>,
            GetStreamNumber: GetStreamNumber::<Impl, IMPL_OFFSET>,
            SetStreamNumber: SetStreamNumber::<Impl, IMPL_OFFSET>,
            GetMediaType: GetMediaType::<Impl, IMPL_OFFSET>,
            SetMediaType: SetMediaType::<Impl, IMPL_OFFSET>,
            GetPayloadExtensionCount: GetPayloadExtensionCount::<Impl, IMPL_OFFSET>,
            GetPayloadExtension: GetPayloadExtension::<Impl, IMPL_OFFSET>,
            AddPayloadExtension: AddPayloadExtension::<Impl, IMPL_OFFSET>,
            RemoveAllPayloadExtensions: RemoveAllPayloadExtensions::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFASFStreamConfig as ::windows::core::Interface>::IID
    }
}
pub trait IMFASFStreamPrioritization_Impl: Sized {
    fn GetStreamCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetStream(&mut self, dwstreamindex: u32, pwstreamnumber: *mut u16, pwstreamflags: *mut u16) -> ::windows::core::Result<()>;
    fn AddStream(&mut self, wstreamnumber: u16, wstreamflags: u16) -> ::windows::core::Result<()>;
    fn RemoveStream(&mut self, dwstreamindex: u32) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<IMFASFStreamPrioritization>;
}
impl IMFASFStreamPrioritization_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFASFStreamPrioritization_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFASFStreamPrioritization_Vtbl {
        unsafe extern "system" fn GetStreamCount<Impl: IMFASFStreamPrioritization_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwstreamcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwstreamcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStream<Impl: IMFASFStreamPrioritization_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pwstreamnumber: *mut u16, pwstreamflags: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetStream(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&pwstreamnumber), ::core::mem::transmute_copy(&pwstreamflags)).into()
        }
        unsafe extern "system" fn AddStream<Impl: IMFASFStreamPrioritization_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wstreamnumber: u16, wstreamflags: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddStream(::core::mem::transmute_copy(&wstreamnumber), ::core::mem::transmute_copy(&wstreamflags)).into()
        }
        unsafe extern "system" fn RemoveStream<Impl: IMFASFStreamPrioritization_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveStream(::core::mem::transmute_copy(&dwstreamindex)).into()
        }
        unsafe extern "system" fn Clone<Impl: IMFASFStreamPrioritization_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppistreamprioritization: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *ppistreamprioritization = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetStreamCount: GetStreamCount::<Impl, IMPL_OFFSET>,
            GetStream: GetStream::<Impl, IMPL_OFFSET>,
            AddStream: AddStream::<Impl, IMPL_OFFSET>,
            RemoveStream: RemoveStream::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFASFStreamPrioritization as ::windows::core::Interface>::IID
    }
}
pub trait IMFASFStreamSelector_Impl: Sized {
    fn GetStreamCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetOutputCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetOutputStreamCount(&mut self, dwoutputnum: u32) -> ::windows::core::Result<u32>;
    fn GetOutputStreamNumbers(&mut self, dwoutputnum: u32) -> ::windows::core::Result<u16>;
    fn GetOutputFromStream(&mut self, wstreamnum: u16) -> ::windows::core::Result<u32>;
    fn GetOutputOverride(&mut self, dwoutputnum: u32) -> ::windows::core::Result<ASF_SELECTION_STATUS>;
    fn SetOutputOverride(&mut self, dwoutputnum: u32, selection: ASF_SELECTION_STATUS) -> ::windows::core::Result<()>;
    fn GetOutputMutexCount(&mut self, dwoutputnum: u32) -> ::windows::core::Result<u32>;
    fn GetOutputMutex(&mut self, dwoutputnum: u32, dwmutexnum: u32) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn SetOutputMutexSelection(&mut self, dwoutputnum: u32, dwmutexnum: u32, wselectedrecord: u16) -> ::windows::core::Result<()>;
    fn GetBandwidthStepCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetBandwidthStep(&mut self, dwstepnum: u32, pdwbitrate: *mut u32, rgwstreamnumbers: *mut u16, rgselections: *mut ASF_SELECTION_STATUS) -> ::windows::core::Result<()>;
    fn BitrateToStepNumber(&mut self, dwbitrate: u32) -> ::windows::core::Result<u32>;
    fn SetStreamSelectorFlags(&mut self, dwstreamselectorflags: u32) -> ::windows::core::Result<()>;
}
impl IMFASFStreamSelector_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFASFStreamSelector_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFASFStreamSelector_Vtbl {
        unsafe extern "system" fn GetStreamCount<Impl: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcstreams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pcstreams = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputCount<Impl: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcoutputs: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOutputCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pcoutputs = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputStreamCount<Impl: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwoutputnum: u32, pcstreams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOutputStreamCount(::core::mem::transmute_copy(&dwoutputnum)) {
                ::core::result::Result::Ok(ok__) => {
                    *pcstreams = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputStreamNumbers<Impl: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwoutputnum: u32, rgwstreamnumbers: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOutputStreamNumbers(::core::mem::transmute_copy(&dwoutputnum)) {
                ::core::result::Result::Ok(ok__) => {
                    *rgwstreamnumbers = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputFromStream<Impl: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wstreamnum: u16, pdwoutput: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOutputFromStream(::core::mem::transmute_copy(&wstreamnum)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwoutput = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputOverride<Impl: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwoutputnum: u32, pselection: *mut ASF_SELECTION_STATUS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOutputOverride(::core::mem::transmute_copy(&dwoutputnum)) {
                ::core::result::Result::Ok(ok__) => {
                    *pselection = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputOverride<Impl: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwoutputnum: u32, selection: ASF_SELECTION_STATUS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputOverride(::core::mem::transmute_copy(&dwoutputnum), ::core::mem::transmute_copy(&selection)).into()
        }
        unsafe extern "system" fn GetOutputMutexCount<Impl: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwoutputnum: u32, pcmutexes: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOutputMutexCount(::core::mem::transmute_copy(&dwoutputnum)) {
                ::core::result::Result::Ok(ok__) => {
                    *pcmutexes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputMutex<Impl: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwoutputnum: u32, dwmutexnum: u32, ppmutex: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOutputMutex(::core::mem::transmute_copy(&dwoutputnum), ::core::mem::transmute_copy(&dwmutexnum)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppmutex = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputMutexSelection<Impl: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwoutputnum: u32, dwmutexnum: u32, wselectedrecord: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputMutexSelection(::core::mem::transmute_copy(&dwoutputnum), ::core::mem::transmute_copy(&dwmutexnum), ::core::mem::transmute_copy(&wselectedrecord)).into()
        }
        unsafe extern "system" fn GetBandwidthStepCount<Impl: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcstepcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBandwidthStepCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pcstepcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBandwidthStep<Impl: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstepnum: u32, pdwbitrate: *mut u32, rgwstreamnumbers: *mut u16, rgselections: *mut ASF_SELECTION_STATUS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetBandwidthStep(::core::mem::transmute_copy(&dwstepnum), ::core::mem::transmute_copy(&pdwbitrate), ::core::mem::transmute_copy(&rgwstreamnumbers), ::core::mem::transmute_copy(&rgselections)).into()
        }
        unsafe extern "system" fn BitrateToStepNumber<Impl: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwbitrate: u32, pdwstepnum: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).BitrateToStepNumber(::core::mem::transmute_copy(&dwbitrate)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwstepnum = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamSelectorFlags<Impl: IMFASFStreamSelector_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamselectorflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStreamSelectorFlags(::core::mem::transmute_copy(&dwstreamselectorflags)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetStreamCount: GetStreamCount::<Impl, IMPL_OFFSET>,
            GetOutputCount: GetOutputCount::<Impl, IMPL_OFFSET>,
            GetOutputStreamCount: GetOutputStreamCount::<Impl, IMPL_OFFSET>,
            GetOutputStreamNumbers: GetOutputStreamNumbers::<Impl, IMPL_OFFSET>,
            GetOutputFromStream: GetOutputFromStream::<Impl, IMPL_OFFSET>,
            GetOutputOverride: GetOutputOverride::<Impl, IMPL_OFFSET>,
            SetOutputOverride: SetOutputOverride::<Impl, IMPL_OFFSET>,
            GetOutputMutexCount: GetOutputMutexCount::<Impl, IMPL_OFFSET>,
            GetOutputMutex: GetOutputMutex::<Impl, IMPL_OFFSET>,
            SetOutputMutexSelection: SetOutputMutexSelection::<Impl, IMPL_OFFSET>,
            GetBandwidthStepCount: GetBandwidthStepCount::<Impl, IMPL_OFFSET>,
            GetBandwidthStep: GetBandwidthStep::<Impl, IMPL_OFFSET>,
            BitrateToStepNumber: BitrateToStepNumber::<Impl, IMPL_OFFSET>,
            SetStreamSelectorFlags: SetStreamSelectorFlags::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFASFStreamSelector as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFActivate_Impl: Sized + IMFAttributes_Impl {
    fn ActivateObject(&mut self, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn ShutdownObject(&mut self) -> ::windows::core::Result<()>;
    fn DetachObject(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFActivate_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFActivate_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFActivate_Vtbl {
        unsafe extern "system" fn ActivateObject<Impl: IMFActivate_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ActivateObject(::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppv)).into()
        }
        unsafe extern "system" fn ShutdownObject<Impl: IMFActivate_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ShutdownObject().into()
        }
        unsafe extern "system" fn DetachObject<Impl: IMFActivate_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DetachObject().into()
        }
        Self {
            base: IMFAttributes_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            ActivateObject: ActivateObject::<Impl, IMPL_OFFSET>,
            ShutdownObject: ShutdownObject::<Impl, IMPL_OFFSET>,
            DetachObject: DetachObject::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFActivate as ::windows::core::Interface>::IID
    }
}
pub trait IMFAsyncCallback_Impl: Sized {
    fn GetParameters(&mut self, pdwflags: *mut u32, pdwqueue: *mut u32) -> ::windows::core::Result<()>;
    fn Invoke(&mut self, pasyncresult: ::core::option::Option<IMFAsyncResult>) -> ::windows::core::Result<()>;
}
impl IMFAsyncCallback_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFAsyncCallback_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFAsyncCallback_Vtbl {
        unsafe extern "system" fn GetParameters<Impl: IMFAsyncCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwflags: *mut u32, pdwqueue: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetParameters(::core::mem::transmute_copy(&pdwflags), ::core::mem::transmute_copy(&pdwqueue)).into()
        }
        unsafe extern "system" fn Invoke<Impl: IMFAsyncCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pasyncresult: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Invoke(::core::mem::transmute(&pasyncresult)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetParameters: GetParameters::<Impl, IMPL_OFFSET>,
            Invoke: Invoke::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFAsyncCallback as ::windows::core::Interface>::IID
    }
}
pub trait IMFAsyncCallbackLogging_Impl: Sized + IMFAsyncCallback_Impl {
    fn GetObjectPointer(&mut self) -> *mut ::core::ffi::c_void;
    fn GetObjectTag(&mut self) -> u32;
}
impl IMFAsyncCallbackLogging_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFAsyncCallbackLogging_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFAsyncCallbackLogging_Vtbl {
        unsafe extern "system" fn GetObjectPointer<Impl: IMFAsyncCallbackLogging_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetObjectPointer()
        }
        unsafe extern "system" fn GetObjectTag<Impl: IMFAsyncCallbackLogging_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetObjectTag()
        }
        Self {
            base: IMFAsyncCallback_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetObjectPointer: GetObjectPointer::<Impl, IMPL_OFFSET>,
            GetObjectTag: GetObjectTag::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFAsyncCallbackLogging as ::windows::core::Interface>::IID
    }
}
pub trait IMFAsyncResult_Impl: Sized {
    fn GetState(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn GetStatus(&mut self) -> ::windows::core::Result<()>;
    fn SetStatus(&mut self, hrstatus: ::windows::core::HRESULT) -> ::windows::core::Result<()>;
    fn GetObject(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn GetStateNoAddRef(&mut self) -> ::core::option::Option<::windows::core::IUnknown>;
}
impl IMFAsyncResult_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFAsyncResult_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFAsyncResult_Vtbl {
        unsafe extern "system" fn GetState<Impl: IMFAsyncResult_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppunkstate: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetState() {
                ::core::result::Result::Ok(ok__) => {
                    *ppunkstate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStatus<Impl: IMFAsyncResult_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetStatus().into()
        }
        unsafe extern "system" fn SetStatus<Impl: IMFAsyncResult_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hrstatus: ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStatus(::core::mem::transmute_copy(&hrstatus)).into()
        }
        unsafe extern "system" fn GetObject<Impl: IMFAsyncResult_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetObject() {
                ::core::result::Result::Ok(ok__) => {
                    *ppobject = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStateNoAddRef<Impl: IMFAsyncResult_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::core::option::Option<::windows::core::IUnknown> {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetStateNoAddRef()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetState: GetState::<Impl, IMPL_OFFSET>,
            GetStatus: GetStatus::<Impl, IMPL_OFFSET>,
            SetStatus: SetStatus::<Impl, IMPL_OFFSET>,
            GetObject: GetObject::<Impl, IMPL_OFFSET>,
            GetStateNoAddRef: GetStateNoAddRef::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFAsyncResult as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFAttributes_Impl: Sized {
    fn GetItem(&mut self, guidkey: *const ::windows::core::GUID, pvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()>;
    fn GetItemType(&mut self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<MF_ATTRIBUTE_TYPE>;
    fn CompareItem(&mut self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn Compare(&mut self, ptheirs: ::core::option::Option<IMFAttributes>, matchtype: MF_ATTRIBUTES_MATCH_TYPE) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetUINT32(&mut self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32>;
    fn GetUINT64(&mut self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u64>;
    fn GetDouble(&mut self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<f64>;
    fn GetGUID(&mut self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::GUID>;
    fn GetStringLength(&mut self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32>;
    fn GetString(&mut self, guidkey: *const ::windows::core::GUID, pwszvalue: super::super::Foundation::PWSTR, cchbufsize: u32, pcchlength: *mut u32) -> ::windows::core::Result<()>;
    fn GetAllocatedString(&mut self, guidkey: *const ::windows::core::GUID, ppwszvalue: *mut super::super::Foundation::PWSTR, pcchlength: *mut u32) -> ::windows::core::Result<()>;
    fn GetBlobSize(&mut self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<u32>;
    fn GetBlob(&mut self, guidkey: *const ::windows::core::GUID, pbuf: *mut u8, cbbufsize: u32, pcbblobsize: *mut u32) -> ::windows::core::Result<()>;
    fn GetAllocatedBlob(&mut self, guidkey: *const ::windows::core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> ::windows::core::Result<()>;
    fn GetUnknown(&mut self, guidkey: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn SetItem(&mut self, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()>;
    fn DeleteItem(&mut self, guidkey: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn DeleteAllItems(&mut self) -> ::windows::core::Result<()>;
    fn SetUINT32(&mut self, guidkey: *const ::windows::core::GUID, unvalue: u32) -> ::windows::core::Result<()>;
    fn SetUINT64(&mut self, guidkey: *const ::windows::core::GUID, unvalue: u64) -> ::windows::core::Result<()>;
    fn SetDouble(&mut self, guidkey: *const ::windows::core::GUID, fvalue: f64) -> ::windows::core::Result<()>;
    fn SetGUID(&mut self, guidkey: *const ::windows::core::GUID, guidvalue: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn SetString(&mut self, guidkey: *const ::windows::core::GUID, wszvalue: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn SetBlob(&mut self, guidkey: *const ::windows::core::GUID, pbuf: *const u8, cbbufsize: u32) -> ::windows::core::Result<()>;
    fn SetUnknown(&mut self, guidkey: *const ::windows::core::GUID, punknown: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn LockStore(&mut self) -> ::windows::core::Result<()>;
    fn UnlockStore(&mut self) -> ::windows::core::Result<()>;
    fn GetCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetItemByIndex(&mut self, unindex: u32, pguidkey: *mut ::windows::core::GUID, pvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()>;
    fn CopyAllItems(&mut self, pdest: ::core::option::Option<IMFAttributes>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFAttributes_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFAttributes_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFAttributes_Vtbl {
        unsafe extern "system" fn GetItem<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetItem(::core::mem::transmute_copy(&guidkey), ::core::mem::transmute_copy(&pvalue)).into()
        }
        unsafe extern "system" fn GetItemType<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, ptype: *mut MF_ATTRIBUTE_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetItemType(::core::mem::transmute_copy(&guidkey)) {
                ::core::result::Result::Ok(ok__) => {
                    *ptype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CompareItem<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pbresult: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CompareItem(::core::mem::transmute_copy(&guidkey), ::core::mem::transmute_copy(&value)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbresult = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Compare<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptheirs: ::windows::core::RawPtr, matchtype: MF_ATTRIBUTES_MATCH_TYPE, pbresult: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Compare(::core::mem::transmute(&ptheirs), ::core::mem::transmute_copy(&matchtype)) {
                ::core::result::Result::Ok(ok__) => {
                    *pbresult = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetUINT32<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, punvalue: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetUINT32(::core::mem::transmute_copy(&guidkey)) {
                ::core::result::Result::Ok(ok__) => {
                    *punvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetUINT64<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, punvalue: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetUINT64(::core::mem::transmute_copy(&guidkey)) {
                ::core::result::Result::Ok(ok__) => {
                    *punvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDouble<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pfvalue: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDouble(::core::mem::transmute_copy(&guidkey)) {
                ::core::result::Result::Ok(ok__) => {
                    *pfvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetGUID<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pguidvalue: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetGUID(::core::mem::transmute_copy(&guidkey)) {
                ::core::result::Result::Ok(ok__) => {
                    *pguidvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStringLength<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pcchlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStringLength(::core::mem::transmute_copy(&guidkey)) {
                ::core::result::Result::Ok(ok__) => {
                    *pcchlength = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetString<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pwszvalue: super::super::Foundation::PWSTR, cchbufsize: u32, pcchlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetString(::core::mem::transmute_copy(&guidkey), ::core::mem::transmute_copy(&pwszvalue), ::core::mem::transmute_copy(&cchbufsize), ::core::mem::transmute_copy(&pcchlength)).into()
        }
        unsafe extern "system" fn GetAllocatedString<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, ppwszvalue: *mut super::super::Foundation::PWSTR, pcchlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAllocatedString(::core::mem::transmute_copy(&guidkey), ::core::mem::transmute_copy(&ppwszvalue), ::core::mem::transmute_copy(&pcchlength)).into()
        }
        unsafe extern "system" fn GetBlobSize<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pcbblobsize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBlobSize(::core::mem::transmute_copy(&guidkey)) {
                ::core::result::Result::Ok(ok__) => {
                    *pcbblobsize = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBlob<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pbuf: *mut u8, cbbufsize: u32, pcbblobsize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetBlob(::core::mem::transmute_copy(&guidkey), ::core::mem::transmute_copy(&pbuf), ::core::mem::transmute_copy(&cbbufsize), ::core::mem::transmute_copy(&pcbblobsize)).into()
        }
        unsafe extern "system" fn GetAllocatedBlob<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, ppbuf: *mut *mut u8, pcbsize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAllocatedBlob(::core::mem::transmute_copy(&guidkey), ::core::mem::transmute_copy(&ppbuf), ::core::mem::transmute_copy(&pcbsize)).into()
        }
        unsafe extern "system" fn GetUnknown<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetUnknown(::core::mem::transmute_copy(&guidkey), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppv)).into()
        }
        unsafe extern "system" fn SetItem<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, value: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetItem(::core::mem::transmute_copy(&guidkey), ::core::mem::transmute_copy(&value)).into()
        }
        unsafe extern "system" fn DeleteItem<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DeleteItem(::core::mem::transmute_copy(&guidkey)).into()
        }
        unsafe extern "system" fn DeleteAllItems<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DeleteAllItems().into()
        }
        unsafe extern "system" fn SetUINT32<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, unvalue: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUINT32(::core::mem::transmute_copy(&guidkey), ::core::mem::transmute_copy(&unvalue)).into()
        }
        unsafe extern "system" fn SetUINT64<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, unvalue: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUINT64(::core::mem::transmute_copy(&guidkey), ::core::mem::transmute_copy(&unvalue)).into()
        }
        unsafe extern "system" fn SetDouble<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, fvalue: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDouble(::core::mem::transmute_copy(&guidkey), ::core::mem::transmute_copy(&fvalue)).into()
        }
        unsafe extern "system" fn SetGUID<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, guidvalue: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGUID(::core::mem::transmute_copy(&guidkey), ::core::mem::transmute_copy(&guidvalue)).into()
        }
        unsafe extern "system" fn SetString<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, wszvalue: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetString(::core::mem::transmute_copy(&guidkey), ::core::mem::transmute_copy(&wszvalue)).into()
        }
        unsafe extern "system" fn SetBlob<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, pbuf: *const u8, cbbufsize: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBlob(::core::mem::transmute_copy(&guidkey), ::core::mem::transmute_copy(&pbuf), ::core::mem::transmute_copy(&cbbufsize)).into()
        }
        unsafe extern "system" fn SetUnknown<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidkey: *const ::windows::core::GUID, punknown: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUnknown(::core::mem::transmute_copy(&guidkey), ::core::mem::transmute(&punknown)).into()
        }
        unsafe extern "system" fn LockStore<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LockStore().into()
        }
        unsafe extern "system" fn UnlockStore<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnlockStore().into()
        }
        unsafe extern "system" fn GetCount<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcitems: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pcitems = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetItemByIndex<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, unindex: u32, pguidkey: *mut ::windows::core::GUID, pvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetItemByIndex(::core::mem::transmute_copy(&unindex), ::core::mem::transmute_copy(&pguidkey), ::core::mem::transmute_copy(&pvalue)).into()
        }
        unsafe extern "system" fn CopyAllItems<Impl: IMFAttributes_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdest: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CopyAllItems(::core::mem::transmute(&pdest)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetItem: GetItem::<Impl, IMPL_OFFSET>,
            GetItemType: GetItemType::<Impl, IMPL_OFFSET>,
            CompareItem: CompareItem::<Impl, IMPL_OFFSET>,
            Compare: Compare::<Impl, IMPL_OFFSET>,
            GetUINT32: GetUINT32::<Impl, IMPL_OFFSET>,
            GetUINT64: GetUINT64::<Impl, IMPL_OFFSET>,
            GetDouble: GetDouble::<Impl, IMPL_OFFSET>,
            GetGUID: GetGUID::<Impl, IMPL_OFFSET>,
            GetStringLength: GetStringLength::<Impl, IMPL_OFFSET>,
            GetString: GetString::<Impl, IMPL_OFFSET>,
            GetAllocatedString: GetAllocatedString::<Impl, IMPL_OFFSET>,
            GetBlobSize: GetBlobSize::<Impl, IMPL_OFFSET>,
            GetBlob: GetBlob::<Impl, IMPL_OFFSET>,
            GetAllocatedBlob: GetAllocatedBlob::<Impl, IMPL_OFFSET>,
            GetUnknown: GetUnknown::<Impl, IMPL_OFFSET>,
            SetItem: SetItem::<Impl, IMPL_OFFSET>,
            DeleteItem: DeleteItem::<Impl, IMPL_OFFSET>,
            DeleteAllItems: DeleteAllItems::<Impl, IMPL_OFFSET>,
            SetUINT32: SetUINT32::<Impl, IMPL_OFFSET>,
            SetUINT64: SetUINT64::<Impl, IMPL_OFFSET>,
            SetDouble: SetDouble::<Impl, IMPL_OFFSET>,
            SetGUID: SetGUID::<Impl, IMPL_OFFSET>,
            SetString: SetString::<Impl, IMPL_OFFSET>,
            SetBlob: SetBlob::<Impl, IMPL_OFFSET>,
            SetUnknown: SetUnknown::<Impl, IMPL_OFFSET>,
            LockStore: LockStore::<Impl, IMPL_OFFSET>,
            UnlockStore: UnlockStore::<Impl, IMPL_OFFSET>,
            GetCount: GetCount::<Impl, IMPL_OFFSET>,
            GetItemByIndex: GetItemByIndex::<Impl, IMPL_OFFSET>,
            CopyAllItems: CopyAllItems::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFAttributes as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_Audio", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFAudioMediaType_Impl: Sized + IMFAttributes_Impl + IMFMediaType_Impl {
    fn GetAudioFormat(&mut self) -> *mut super::Audio::WAVEFORMATEX;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_Audio", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFAudioMediaType_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFAudioMediaType_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFAudioMediaType_Vtbl {
        unsafe extern "system" fn GetAudioFormat<Impl: IMFAudioMediaType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> *mut super::Audio::WAVEFORMATEX {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAudioFormat()
        }
        Self { base: IMFMediaType_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), GetAudioFormat: GetAudioFormat::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFAudioMediaType as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFAudioPolicy_Impl: Sized {
    fn SetGroupingParam(&mut self, rguidclass: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetGroupingParam(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn SetDisplayName(&mut self, pszname: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn GetDisplayName(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
    fn SetIconPath(&mut self, pszpath: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn GetIconPath(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFAudioPolicy_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFAudioPolicy_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFAudioPolicy_Vtbl {
        unsafe extern "system" fn SetGroupingParam<Impl: IMFAudioPolicy_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rguidclass: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGroupingParam(::core::mem::transmute_copy(&rguidclass)).into()
        }
        unsafe extern "system" fn GetGroupingParam<Impl: IMFAudioPolicy_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguidclass: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetGroupingParam() {
                ::core::result::Result::Ok(ok__) => {
                    *pguidclass = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisplayName<Impl: IMFAudioPolicy_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszname: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisplayName(::core::mem::transmute_copy(&pszname)).into()
        }
        unsafe extern "system" fn GetDisplayName<Impl: IMFAudioPolicy_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszname: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDisplayName() {
                ::core::result::Result::Ok(ok__) => {
                    *pszname = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetIconPath<Impl: IMFAudioPolicy_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszpath: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIconPath(::core::mem::transmute_copy(&pszpath)).into()
        }
        unsafe extern "system" fn GetIconPath<Impl: IMFAudioPolicy_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszpath: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIconPath() {
                ::core::result::Result::Ok(ok__) => {
                    *pszpath = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetGroupingParam: SetGroupingParam::<Impl, IMPL_OFFSET>,
            GetGroupingParam: GetGroupingParam::<Impl, IMPL_OFFSET>,
            SetDisplayName: SetDisplayName::<Impl, IMPL_OFFSET>,
            GetDisplayName: GetDisplayName::<Impl, IMPL_OFFSET>,
            SetIconPath: SetIconPath::<Impl, IMPL_OFFSET>,
            GetIconPath: GetIconPath::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFAudioPolicy as ::windows::core::Interface>::IID
    }
}
pub trait IMFAudioStreamVolume_Impl: Sized {
    fn GetChannelCount(&mut self) -> ::windows::core::Result<u32>;
    fn SetChannelVolume(&mut self, dwindex: u32, flevel: f32) -> ::windows::core::Result<()>;
    fn GetChannelVolume(&mut self, dwindex: u32) -> ::windows::core::Result<f32>;
    fn SetAllVolumes(&mut self, dwcount: u32, pfvolumes: *const f32) -> ::windows::core::Result<()>;
    fn GetAllVolumes(&mut self, dwcount: u32, pfvolumes: *mut f32) -> ::windows::core::Result<()>;
}
impl IMFAudioStreamVolume_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFAudioStreamVolume_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFAudioStreamVolume_Vtbl {
        unsafe extern "system" fn GetChannelCount<Impl: IMFAudioStreamVolume_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetChannelCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetChannelVolume<Impl: IMFAudioStreamVolume_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, flevel: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetChannelVolume(::core::mem::transmute_copy(&dwindex), ::core::mem::transmute_copy(&flevel)).into()
        }
        unsafe extern "system" fn GetChannelVolume<Impl: IMFAudioStreamVolume_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, pflevel: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetChannelVolume(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pflevel = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAllVolumes<Impl: IMFAudioStreamVolume_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwcount: u32, pfvolumes: *const f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAllVolumes(::core::mem::transmute_copy(&dwcount), ::core::mem::transmute_copy(&pfvolumes)).into()
        }
        unsafe extern "system" fn GetAllVolumes<Impl: IMFAudioStreamVolume_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwcount: u32, pfvolumes: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAllVolumes(::core::mem::transmute_copy(&dwcount), ::core::mem::transmute_copy(&pfvolumes)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetChannelCount: GetChannelCount::<Impl, IMPL_OFFSET>,
            SetChannelVolume: SetChannelVolume::<Impl, IMPL_OFFSET>,
            GetChannelVolume: GetChannelVolume::<Impl, IMPL_OFFSET>,
            SetAllVolumes: SetAllVolumes::<Impl, IMPL_OFFSET>,
            GetAllVolumes: GetAllVolumes::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFAudioStreamVolume as ::windows::core::Interface>::IID
    }
}
pub trait IMFBufferListNotify_Impl: Sized {
    fn OnAddSourceBuffer(&mut self);
    fn OnRemoveSourceBuffer(&mut self);
}
impl IMFBufferListNotify_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFBufferListNotify_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFBufferListNotify_Vtbl {
        unsafe extern "system" fn OnAddSourceBuffer<Impl: IMFBufferListNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnAddSourceBuffer()
        }
        unsafe extern "system" fn OnRemoveSourceBuffer<Impl: IMFBufferListNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnRemoveSourceBuffer()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            OnAddSourceBuffer: OnAddSourceBuffer::<Impl, IMPL_OFFSET>,
            OnRemoveSourceBuffer: OnRemoveSourceBuffer::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFBufferListNotify as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFByteStream_Impl: Sized {
    fn GetCapabilities(&mut self) -> ::windows::core::Result<u32>;
    fn GetLength(&mut self) -> ::windows::core::Result<u64>;
    fn SetLength(&mut self, qwlength: u64) -> ::windows::core::Result<()>;
    fn GetCurrentPosition(&mut self) -> ::windows::core::Result<u64>;
    fn SetCurrentPosition(&mut self, qwposition: u64) -> ::windows::core::Result<()>;
    fn IsEndOfStream(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn Read(&mut self, pb: *mut u8, cb: u32, pcbread: *mut u32) -> ::windows::core::Result<()>;
    fn BeginRead(&mut self, pb: *mut u8, cb: u32, pcallback: ::core::option::Option<IMFAsyncCallback>, punkstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndRead(&mut self, presult: ::core::option::Option<IMFAsyncResult>) -> ::windows::core::Result<u32>;
    fn Write(&mut self, pb: *const u8, cb: u32) -> ::windows::core::Result<u32>;
    fn BeginWrite(&mut self, pb: *const u8, cb: u32, pcallback: ::core::option::Option<IMFAsyncCallback>, punkstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndWrite(&mut self, presult: ::core::option::Option<IMFAsyncResult>) -> ::windows::core::Result<u32>;
    fn Seek(&mut self, seekorigin: MFBYTESTREAM_SEEK_ORIGIN, llseekoffset: i64, dwseekflags: u32) -> ::windows::core::Result<u64>;
    fn Flush(&mut self) -> ::windows::core::Result<()>;
    fn Close(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFByteStream_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFByteStream_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFByteStream_Vtbl {
        unsafe extern "system" fn GetCapabilities<Impl: IMFByteStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwcapabilities: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCapabilities() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwcapabilities = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLength<Impl: IMFByteStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pqwlength: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pqwlength = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLength<Impl: IMFByteStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, qwlength: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLength(::core::mem::transmute_copy(&qwlength)).into()
        }
        unsafe extern "system" fn GetCurrentPosition<Impl: IMFByteStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pqwposition: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentPosition() {
                ::core::result::Result::Ok(ok__) => {
                    *pqwposition = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentPosition<Impl: IMFByteStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, qwposition: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCurrentPosition(::core::mem::transmute_copy(&qwposition)).into()
        }
        unsafe extern "system" fn IsEndOfStream<Impl: IMFByteStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfendofstream: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsEndOfStream() {
                ::core::result::Result::Ok(ok__) => {
                    *pfendofstream = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Read<Impl: IMFByteStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pb: *mut u8, cb: u32, pcbread: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Read(::core::mem::transmute_copy(&pb), ::core::mem::transmute_copy(&cb), ::core::mem::transmute_copy(&pcbread)).into()
        }
        unsafe extern "system" fn BeginRead<Impl: IMFByteStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pb: *mut u8, cb: u32, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginRead(::core::mem::transmute_copy(&pb), ::core::mem::transmute_copy(&cb), ::core::mem::transmute(&pcallback), ::core::mem::transmute(&punkstate)).into()
        }
        unsafe extern "system" fn EndRead<Impl: IMFByteStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, pcbread: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EndRead(::core::mem::transmute(&presult)) {
                ::core::result::Result::Ok(ok__) => {
                    *pcbread = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Write<Impl: IMFByteStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pb: *const u8, cb: u32, pcbwritten: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Write(::core::mem::transmute_copy(&pb), ::core::mem::transmute_copy(&cb)) {
                ::core::result::Result::Ok(ok__) => {
                    *pcbwritten = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginWrite<Impl: IMFByteStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pb: *const u8, cb: u32, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginWrite(::core::mem::transmute_copy(&pb), ::core::mem::transmute_copy(&cb), ::core::mem::transmute(&pcallback), ::core::mem::transmute(&punkstate)).into()
        }
        unsafe extern "system" fn EndWrite<Impl: IMFByteStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, pcbwritten: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EndWrite(::core::mem::transmute(&presult)) {
                ::core::result::Result::Ok(ok__) => {
                    *pcbwritten = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Seek<Impl: IMFByteStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, seekorigin: MFBYTESTREAM_SEEK_ORIGIN, llseekoffset: i64, dwseekflags: u32, pqwcurrentposition: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Seek(::core::mem::transmute_copy(&seekorigin), ::core::mem::transmute_copy(&llseekoffset), ::core::mem::transmute_copy(&dwseekflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *pqwcurrentposition = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Flush<Impl: IMFByteStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Flush().into()
        }
        unsafe extern "system" fn Close<Impl: IMFByteStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Close().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetCapabilities: GetCapabilities::<Impl, IMPL_OFFSET>,
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            SetLength: SetLength::<Impl, IMPL_OFFSET>,
            GetCurrentPosition: GetCurrentPosition::<Impl, IMPL_OFFSET>,
            SetCurrentPosition: SetCurrentPosition::<Impl, IMPL_OFFSET>,
            IsEndOfStream: IsEndOfStream::<Impl, IMPL_OFFSET>,
            Read: Read::<Impl, IMPL_OFFSET>,
            BeginRead: BeginRead::<Impl, IMPL_OFFSET>,
            EndRead: EndRead::<Impl, IMPL_OFFSET>,
            Write: Write::<Impl, IMPL_OFFSET>,
            BeginWrite: BeginWrite::<Impl, IMPL_OFFSET>,
            EndWrite: EndWrite::<Impl, IMPL_OFFSET>,
            Seek: Seek::<Impl, IMPL_OFFSET>,
            Flush: Flush::<Impl, IMPL_OFFSET>,
            Close: Close::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFByteStream as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFByteStreamBuffering_Impl: Sized {
    fn SetBufferingParams(&mut self, pparams: *const MFBYTESTREAM_BUFFERING_PARAMS) -> ::windows::core::Result<()>;
    fn EnableBuffering(&mut self, fenable: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn StopBuffering(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFByteStreamBuffering_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFByteStreamBuffering_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFByteStreamBuffering_Vtbl {
        unsafe extern "system" fn SetBufferingParams<Impl: IMFByteStreamBuffering_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pparams: *const MFBYTESTREAM_BUFFERING_PARAMS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBufferingParams(::core::mem::transmute_copy(&pparams)).into()
        }
        unsafe extern "system" fn EnableBuffering<Impl: IMFByteStreamBuffering_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fenable: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EnableBuffering(::core::mem::transmute_copy(&fenable)).into()
        }
        unsafe extern "system" fn StopBuffering<Impl: IMFByteStreamBuffering_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StopBuffering().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetBufferingParams: SetBufferingParams::<Impl, IMPL_OFFSET>,
            EnableBuffering: EnableBuffering::<Impl, IMPL_OFFSET>,
            StopBuffering: StopBuffering::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFByteStreamBuffering as ::windows::core::Interface>::IID
    }
}
pub trait IMFByteStreamCacheControl_Impl: Sized {
    fn StopBackgroundTransfer(&mut self) -> ::windows::core::Result<()>;
}
impl IMFByteStreamCacheControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFByteStreamCacheControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFByteStreamCacheControl_Vtbl {
        unsafe extern "system" fn StopBackgroundTransfer<Impl: IMFByteStreamCacheControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StopBackgroundTransfer().into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), StopBackgroundTransfer: StopBackgroundTransfer::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFByteStreamCacheControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFByteStreamCacheControl2_Impl: Sized + IMFByteStreamCacheControl_Impl {
    fn GetByteRanges(&mut self, pcranges: *mut u32, ppranges: *mut *mut MF_BYTE_STREAM_CACHE_RANGE) -> ::windows::core::Result<()>;
    fn SetCacheLimit(&mut self, qwbytes: u64) -> ::windows::core::Result<()>;
    fn IsBackgroundTransferActive(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFByteStreamCacheControl2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFByteStreamCacheControl2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFByteStreamCacheControl2_Vtbl {
        unsafe extern "system" fn GetByteRanges<Impl: IMFByteStreamCacheControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcranges: *mut u32, ppranges: *mut *mut MF_BYTE_STREAM_CACHE_RANGE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetByteRanges(::core::mem::transmute_copy(&pcranges), ::core::mem::transmute_copy(&ppranges)).into()
        }
        unsafe extern "system" fn SetCacheLimit<Impl: IMFByteStreamCacheControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, qwbytes: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCacheLimit(::core::mem::transmute_copy(&qwbytes)).into()
        }
        unsafe extern "system" fn IsBackgroundTransferActive<Impl: IMFByteStreamCacheControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfactive: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsBackgroundTransferActive() {
                ::core::result::Result::Ok(ok__) => {
                    *pfactive = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMFByteStreamCacheControl_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetByteRanges: GetByteRanges::<Impl, IMPL_OFFSET>,
            SetCacheLimit: SetCacheLimit::<Impl, IMPL_OFFSET>,
            IsBackgroundTransferActive: IsBackgroundTransferActive::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFByteStreamCacheControl2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_Shell_PropertiesSystem"))]
pub trait IMFByteStreamHandler_Impl: Sized {
    fn BeginCreateObject(&mut self, pbytestream: ::core::option::Option<IMFByteStream>, pwszurl: super::super::Foundation::PWSTR, dwflags: u32, pprops: ::core::option::Option<super::super::UI::Shell::PropertiesSystem::IPropertyStore>, ppiunknowncancelcookie: *mut ::core::option::Option<::windows::core::IUnknown>, pcallback: ::core::option::Option<IMFAsyncCallback>, punkstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndCreateObject(&mut self, presult: ::core::option::Option<IMFAsyncResult>, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn CancelObjectCreation(&mut self, piunknowncancelcookie: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn GetMaxNumberOfBytesRequiredForResolution(&mut self) -> ::windows::core::Result<u64>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_Shell_PropertiesSystem"))]
impl IMFByteStreamHandler_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFByteStreamHandler_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFByteStreamHandler_Vtbl {
        unsafe extern "system" fn BeginCreateObject<Impl: IMFByteStreamHandler_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbytestream: ::windows::core::RawPtr, pwszurl: super::super::Foundation::PWSTR, dwflags: u32, pprops: ::windows::core::RawPtr, ppiunknowncancelcookie: *mut *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginCreateObject(::core::mem::transmute(&pbytestream), ::core::mem::transmute_copy(&pwszurl), ::core::mem::transmute_copy(&dwflags), ::core::mem::transmute(&pprops), ::core::mem::transmute_copy(&ppiunknowncancelcookie), ::core::mem::transmute(&pcallback), ::core::mem::transmute(&punkstate)).into()
        }
        unsafe extern "system" fn EndCreateObject<Impl: IMFByteStreamHandler_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndCreateObject(::core::mem::transmute(&presult), ::core::mem::transmute_copy(&pobjecttype), ::core::mem::transmute_copy(&ppobject)).into()
        }
        unsafe extern "system" fn CancelObjectCreation<Impl: IMFByteStreamHandler_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, piunknowncancelcookie: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CancelObjectCreation(::core::mem::transmute(&piunknowncancelcookie)).into()
        }
        unsafe extern "system" fn GetMaxNumberOfBytesRequiredForResolution<Impl: IMFByteStreamHandler_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pqwbytes: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMaxNumberOfBytesRequiredForResolution() {
                ::core::result::Result::Ok(ok__) => {
                    *pqwbytes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            BeginCreateObject: BeginCreateObject::<Impl, IMPL_OFFSET>,
            EndCreateObject: EndCreateObject::<Impl, IMPL_OFFSET>,
            CancelObjectCreation: CancelObjectCreation::<Impl, IMPL_OFFSET>,
            GetMaxNumberOfBytesRequiredForResolution: GetMaxNumberOfBytesRequiredForResolution::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFByteStreamHandler as ::windows::core::Interface>::IID
    }
}
pub trait IMFByteStreamProxyClassFactory_Impl: Sized {
    fn CreateByteStreamProxy(&mut self, pbytestream: ::core::option::Option<IMFByteStream>, pattributes: ::core::option::Option<IMFAttributes>, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
impl IMFByteStreamProxyClassFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFByteStreamProxyClassFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFByteStreamProxyClassFactory_Vtbl {
        unsafe extern "system" fn CreateByteStreamProxy<Impl: IMFByteStreamProxyClassFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbytestream: ::windows::core::RawPtr, pattributes: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateByteStreamProxy(::core::mem::transmute(&pbytestream), ::core::mem::transmute(&pattributes), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvobject)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), CreateByteStreamProxy: CreateByteStreamProxy::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFByteStreamProxyClassFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFByteStreamTimeSeek_Impl: Sized {
    fn IsTimeSeekSupported(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn TimeSeek(&mut self, qwtimeposition: u64) -> ::windows::core::Result<()>;
    fn GetTimeSeekResult(&mut self, pqwstarttime: *mut u64, pqwstoptime: *mut u64, pqwduration: *mut u64) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFByteStreamTimeSeek_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFByteStreamTimeSeek_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFByteStreamTimeSeek_Vtbl {
        unsafe extern "system" fn IsTimeSeekSupported<Impl: IMFByteStreamTimeSeek_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pftimeseekissupported: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTimeSeekSupported() {
                ::core::result::Result::Ok(ok__) => {
                    *pftimeseekissupported = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn TimeSeek<Impl: IMFByteStreamTimeSeek_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, qwtimeposition: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TimeSeek(::core::mem::transmute_copy(&qwtimeposition)).into()
        }
        unsafe extern "system" fn GetTimeSeekResult<Impl: IMFByteStreamTimeSeek_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pqwstarttime: *mut u64, pqwstoptime: *mut u64, pqwduration: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTimeSeekResult(::core::mem::transmute_copy(&pqwstarttime), ::core::mem::transmute_copy(&pqwstoptime), ::core::mem::transmute_copy(&pqwduration)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            IsTimeSeekSupported: IsTimeSeekSupported::<Impl, IMPL_OFFSET>,
            TimeSeek: TimeSeek::<Impl, IMPL_OFFSET>,
            GetTimeSeekResult: GetTimeSeekResult::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFByteStreamTimeSeek as ::windows::core::Interface>::IID
    }
}
pub trait IMFCameraOcclusionStateMonitor_Impl: Sized {
    fn Start(&mut self) -> ::windows::core::Result<()>;
    fn Stop(&mut self) -> ::windows::core::Result<()>;
    fn GetSupportedStates(&mut self) -> u32;
}
impl IMFCameraOcclusionStateMonitor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFCameraOcclusionStateMonitor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFCameraOcclusionStateMonitor_Vtbl {
        unsafe extern "system" fn Start<Impl: IMFCameraOcclusionStateMonitor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Start().into()
        }
        unsafe extern "system" fn Stop<Impl: IMFCameraOcclusionStateMonitor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        unsafe extern "system" fn GetSupportedStates<Impl: IMFCameraOcclusionStateMonitor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSupportedStates()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Start: Start::<Impl, IMPL_OFFSET>,
            Stop: Stop::<Impl, IMPL_OFFSET>,
            GetSupportedStates: GetSupportedStates::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFCameraOcclusionStateMonitor as ::windows::core::Interface>::IID
    }
}
pub trait IMFCameraOcclusionStateReport_Impl: Sized {
    fn GetOcclusionState(&mut self) -> ::windows::core::Result<u32>;
}
impl IMFCameraOcclusionStateReport_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFCameraOcclusionStateReport_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFCameraOcclusionStateReport_Vtbl {
        unsafe extern "system" fn GetOcclusionState<Impl: IMFCameraOcclusionStateReport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, occlusionstate: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOcclusionState() {
                ::core::result::Result::Ok(ok__) => {
                    *occlusionstate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetOcclusionState: GetOcclusionState::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFCameraOcclusionStateReport as ::windows::core::Interface>::IID
    }
}
pub trait IMFCameraOcclusionStateReportCallback_Impl: Sized {
    fn OnOcclusionStateReport(&mut self, occlusionstatereport: ::core::option::Option<IMFCameraOcclusionStateReport>) -> ::windows::core::Result<()>;
}
impl IMFCameraOcclusionStateReportCallback_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFCameraOcclusionStateReportCallback_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFCameraOcclusionStateReportCallback_Vtbl {
        unsafe extern "system" fn OnOcclusionStateReport<Impl: IMFCameraOcclusionStateReportCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, occlusionstatereport: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnOcclusionStateReport(::core::mem::transmute(&occlusionstatereport)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), OnOcclusionStateReport: OnOcclusionStateReport::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFCameraOcclusionStateReportCallback as ::windows::core::Interface>::IID
    }
}
pub trait IMFCameraSyncObject_Impl: Sized {
    fn WaitOnSignal(&mut self, timeoutinms: u32) -> ::windows::core::Result<()>;
    fn Shutdown(&mut self);
}
impl IMFCameraSyncObject_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFCameraSyncObject_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFCameraSyncObject_Vtbl {
        unsafe extern "system" fn WaitOnSignal<Impl: IMFCameraSyncObject_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, timeoutinms: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).WaitOnSignal(::core::mem::transmute_copy(&timeoutinms)).into()
        }
        unsafe extern "system" fn Shutdown<Impl: IMFCameraSyncObject_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Shutdown()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            WaitOnSignal: WaitOnSignal::<Impl, IMPL_OFFSET>,
            Shutdown: Shutdown::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFCameraSyncObject as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFCaptureEngine_Impl: Sized {
    fn Initialize(&mut self, peventcallback: ::core::option::Option<IMFCaptureEngineOnEventCallback>, pattributes: ::core::option::Option<IMFAttributes>, paudiosource: ::core::option::Option<::windows::core::IUnknown>, pvideosource: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn StartPreview(&mut self) -> ::windows::core::Result<()>;
    fn StopPreview(&mut self) -> ::windows::core::Result<()>;
    fn StartRecord(&mut self) -> ::windows::core::Result<()>;
    fn StopRecord(&mut self, bfinalize: super::super::Foundation::BOOL, bflushunprocessedsamples: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn TakePhoto(&mut self) -> ::windows::core::Result<()>;
    fn GetSink(&mut self, mfcaptureenginesinktype: MF_CAPTURE_ENGINE_SINK_TYPE) -> ::windows::core::Result<IMFCaptureSink>;
    fn GetSource(&mut self) -> ::windows::core::Result<IMFCaptureSource>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFCaptureEngine_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFCaptureEngine_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFCaptureEngine_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IMFCaptureEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, peventcallback: ::windows::core::RawPtr, pattributes: ::windows::core::RawPtr, paudiosource: *mut ::core::ffi::c_void, pvideosource: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&peventcallback), ::core::mem::transmute(&pattributes), ::core::mem::transmute(&paudiosource), ::core::mem::transmute(&pvideosource)).into()
        }
        unsafe extern "system" fn StartPreview<Impl: IMFCaptureEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StartPreview().into()
        }
        unsafe extern "system" fn StopPreview<Impl: IMFCaptureEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StopPreview().into()
        }
        unsafe extern "system" fn StartRecord<Impl: IMFCaptureEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StartRecord().into()
        }
        unsafe extern "system" fn StopRecord<Impl: IMFCaptureEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bfinalize: super::super::Foundation::BOOL, bflushunprocessedsamples: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StopRecord(::core::mem::transmute_copy(&bfinalize), ::core::mem::transmute_copy(&bflushunprocessedsamples)).into()
        }
        unsafe extern "system" fn TakePhoto<Impl: IMFCaptureEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TakePhoto().into()
        }
        unsafe extern "system" fn GetSink<Impl: IMFCaptureEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mfcaptureenginesinktype: MF_CAPTURE_ENGINE_SINK_TYPE, ppsink: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSink(::core::mem::transmute_copy(&mfcaptureenginesinktype)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppsink = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSource<Impl: IMFCaptureEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppsource: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSource() {
                ::core::result::Result::Ok(ok__) => {
                    *ppsource = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Initialize: Initialize::<Impl, IMPL_OFFSET>,
            StartPreview: StartPreview::<Impl, IMPL_OFFSET>,
            StopPreview: StopPreview::<Impl, IMPL_OFFSET>,
            StartRecord: StartRecord::<Impl, IMPL_OFFSET>,
            StopRecord: StopRecord::<Impl, IMPL_OFFSET>,
            TakePhoto: TakePhoto::<Impl, IMPL_OFFSET>,
            GetSink: GetSink::<Impl, IMPL_OFFSET>,
            GetSource: GetSource::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFCaptureEngine as ::windows::core::Interface>::IID
    }
}
pub trait IMFCaptureEngineClassFactory_Impl: Sized {
    fn CreateInstance(&mut self, clsid: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
impl IMFCaptureEngineClassFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFCaptureEngineClassFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFCaptureEngineClassFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMFCaptureEngineClassFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clsid: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateInstance(::core::mem::transmute_copy(&clsid), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvobject)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFCaptureEngineClassFactory as ::windows::core::Interface>::IID
    }
}
pub trait IMFCaptureEngineOnEventCallback_Impl: Sized {
    fn OnEvent(&mut self, pevent: ::core::option::Option<IMFMediaEvent>) -> ::windows::core::Result<()>;
}
impl IMFCaptureEngineOnEventCallback_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFCaptureEngineOnEventCallback_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFCaptureEngineOnEventCallback_Vtbl {
        unsafe extern "system" fn OnEvent<Impl: IMFCaptureEngineOnEventCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pevent: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnEvent(::core::mem::transmute(&pevent)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), OnEvent: OnEvent::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFCaptureEngineOnEventCallback as ::windows::core::Interface>::IID
    }
}
pub trait IMFCaptureEngineOnSampleCallback_Impl: Sized {
    fn OnSample(&mut self, psample: ::core::option::Option<IMFSample>) -> ::windows::core::Result<()>;
}
impl IMFCaptureEngineOnSampleCallback_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFCaptureEngineOnSampleCallback_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFCaptureEngineOnSampleCallback_Vtbl {
        unsafe extern "system" fn OnSample<Impl: IMFCaptureEngineOnSampleCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psample: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnSample(::core::mem::transmute(&psample)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), OnSample: OnSample::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFCaptureEngineOnSampleCallback as ::windows::core::Interface>::IID
    }
}
pub trait IMFCaptureEngineOnSampleCallback2_Impl: Sized + IMFCaptureEngineOnSampleCallback_Impl {
    fn OnSynchronizedEvent(&mut self, pevent: ::core::option::Option<IMFMediaEvent>) -> ::windows::core::Result<()>;
}
impl IMFCaptureEngineOnSampleCallback2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFCaptureEngineOnSampleCallback2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFCaptureEngineOnSampleCallback2_Vtbl {
        unsafe extern "system" fn OnSynchronizedEvent<Impl: IMFCaptureEngineOnSampleCallback2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pevent: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnSynchronizedEvent(::core::mem::transmute(&pevent)).into()
        }
        Self {
            base: IMFCaptureEngineOnSampleCallback_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            OnSynchronizedEvent: OnSynchronizedEvent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFCaptureEngineOnSampleCallback2 as ::windows::core::Interface>::IID
    }
}
pub trait IMFCapturePhotoConfirmation_Impl: Sized {
    fn SetPhotoConfirmationCallback(&mut self, pnotificationcallback: ::core::option::Option<IMFAsyncCallback>) -> ::windows::core::Result<()>;
    fn SetPixelFormat(&mut self, subtype: ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetPixelFormat(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
}
impl IMFCapturePhotoConfirmation_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFCapturePhotoConfirmation_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFCapturePhotoConfirmation_Vtbl {
        unsafe extern "system" fn SetPhotoConfirmationCallback<Impl: IMFCapturePhotoConfirmation_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pnotificationcallback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPhotoConfirmationCallback(::core::mem::transmute(&pnotificationcallback)).into()
        }
        unsafe extern "system" fn SetPixelFormat<Impl: IMFCapturePhotoConfirmation_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, subtype: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPixelFormat(::core::mem::transmute_copy(&subtype)).into()
        }
        unsafe extern "system" fn GetPixelFormat<Impl: IMFCapturePhotoConfirmation_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, subtype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPixelFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *subtype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetPhotoConfirmationCallback: SetPhotoConfirmationCallback::<Impl, IMPL_OFFSET>,
            SetPixelFormat: SetPixelFormat::<Impl, IMPL_OFFSET>,
            GetPixelFormat: GetPixelFormat::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFCapturePhotoConfirmation as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFCapturePhotoSink_Impl: Sized + IMFCaptureSink_Impl {
    fn SetOutputFileName(&mut self, filename: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn SetSampleCallback(&mut self, pcallback: ::core::option::Option<IMFCaptureEngineOnSampleCallback>) -> ::windows::core::Result<()>;
    fn SetOutputByteStream(&mut self, pbytestream: ::core::option::Option<IMFByteStream>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFCapturePhotoSink_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFCapturePhotoSink_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFCapturePhotoSink_Vtbl {
        unsafe extern "system" fn SetOutputFileName<Impl: IMFCapturePhotoSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, filename: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputFileName(::core::mem::transmute_copy(&filename)).into()
        }
        unsafe extern "system" fn SetSampleCallback<Impl: IMFCapturePhotoSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSampleCallback(::core::mem::transmute(&pcallback)).into()
        }
        unsafe extern "system" fn SetOutputByteStream<Impl: IMFCapturePhotoSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbytestream: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputByteStream(::core::mem::transmute(&pbytestream)).into()
        }
        Self {
            base: IMFCaptureSink_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetOutputFileName: SetOutputFileName::<Impl, IMPL_OFFSET>,
            SetSampleCallback: SetSampleCallback::<Impl, IMPL_OFFSET>,
            SetOutputByteStream: SetOutputByteStream::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFCapturePhotoSink as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFCapturePreviewSink_Impl: Sized + IMFCaptureSink_Impl {
    fn SetRenderHandle(&mut self, handle: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn SetRenderSurface(&mut self, psurface: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn UpdateVideo(&mut self, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const u32) -> ::windows::core::Result<()>;
    fn SetSampleCallback(&mut self, dwstreamsinkindex: u32, pcallback: ::core::option::Option<IMFCaptureEngineOnSampleCallback>) -> ::windows::core::Result<()>;
    fn GetMirrorState(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn SetMirrorState(&mut self, fmirrorstate: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetRotation(&mut self, dwstreamindex: u32) -> ::windows::core::Result<u32>;
    fn SetRotation(&mut self, dwstreamindex: u32, dwrotationvalue: u32) -> ::windows::core::Result<()>;
    fn SetCustomSink(&mut self, pmediasink: ::core::option::Option<IMFMediaSink>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFCapturePreviewSink_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFCapturePreviewSink_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFCapturePreviewSink_Vtbl {
        unsafe extern "system" fn SetRenderHandle<Impl: IMFCapturePreviewSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, handle: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRenderHandle(::core::mem::transmute_copy(&handle)).into()
        }
        unsafe extern "system" fn SetRenderSurface<Impl: IMFCapturePreviewSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psurface: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRenderSurface(::core::mem::transmute(&psurface)).into()
        }
        unsafe extern "system" fn UpdateVideo<Impl: IMFCapturePreviewSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UpdateVideo(::core::mem::transmute_copy(&psrc), ::core::mem::transmute_copy(&pdst), ::core::mem::transmute_copy(&pborderclr)).into()
        }
        unsafe extern "system" fn SetSampleCallback<Impl: IMFCapturePreviewSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamsinkindex: u32, pcallback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSampleCallback(::core::mem::transmute_copy(&dwstreamsinkindex), ::core::mem::transmute(&pcallback)).into()
        }
        unsafe extern "system" fn GetMirrorState<Impl: IMFCapturePreviewSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfmirrorstate: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMirrorState() {
                ::core::result::Result::Ok(ok__) => {
                    *pfmirrorstate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMirrorState<Impl: IMFCapturePreviewSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fmirrorstate: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMirrorState(::core::mem::transmute_copy(&fmirrorstate)).into()
        }
        unsafe extern "system" fn GetRotation<Impl: IMFCapturePreviewSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pdwrotationvalue: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRotation(::core::mem::transmute_copy(&dwstreamindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwrotationvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRotation<Impl: IMFCapturePreviewSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, dwrotationvalue: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRotation(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&dwrotationvalue)).into()
        }
        unsafe extern "system" fn SetCustomSink<Impl: IMFCapturePreviewSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmediasink: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCustomSink(::core::mem::transmute(&pmediasink)).into()
        }
        Self {
            base: IMFCaptureSink_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetRenderHandle: SetRenderHandle::<Impl, IMPL_OFFSET>,
            SetRenderSurface: SetRenderSurface::<Impl, IMPL_OFFSET>,
            UpdateVideo: UpdateVideo::<Impl, IMPL_OFFSET>,
            SetSampleCallback: SetSampleCallback::<Impl, IMPL_OFFSET>,
            GetMirrorState: GetMirrorState::<Impl, IMPL_OFFSET>,
            SetMirrorState: SetMirrorState::<Impl, IMPL_OFFSET>,
            GetRotation: GetRotation::<Impl, IMPL_OFFSET>,
            SetRotation: SetRotation::<Impl, IMPL_OFFSET>,
            SetCustomSink: SetCustomSink::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFCapturePreviewSink as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFCaptureRecordSink_Impl: Sized + IMFCaptureSink_Impl {
    fn SetOutputByteStream(&mut self, pbytestream: ::core::option::Option<IMFByteStream>, guidcontainertype: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn SetOutputFileName(&mut self, filename: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn SetSampleCallback(&mut self, dwstreamsinkindex: u32, pcallback: ::core::option::Option<IMFCaptureEngineOnSampleCallback>) -> ::windows::core::Result<()>;
    fn SetCustomSink(&mut self, pmediasink: ::core::option::Option<IMFMediaSink>) -> ::windows::core::Result<()>;
    fn GetRotation(&mut self, dwstreamindex: u32) -> ::windows::core::Result<u32>;
    fn SetRotation(&mut self, dwstreamindex: u32, dwrotationvalue: u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFCaptureRecordSink_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFCaptureRecordSink_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFCaptureRecordSink_Vtbl {
        unsafe extern "system" fn SetOutputByteStream<Impl: IMFCaptureRecordSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbytestream: ::windows::core::RawPtr, guidcontainertype: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputByteStream(::core::mem::transmute(&pbytestream), ::core::mem::transmute_copy(&guidcontainertype)).into()
        }
        unsafe extern "system" fn SetOutputFileName<Impl: IMFCaptureRecordSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, filename: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputFileName(::core::mem::transmute_copy(&filename)).into()
        }
        unsafe extern "system" fn SetSampleCallback<Impl: IMFCaptureRecordSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamsinkindex: u32, pcallback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSampleCallback(::core::mem::transmute_copy(&dwstreamsinkindex), ::core::mem::transmute(&pcallback)).into()
        }
        unsafe extern "system" fn SetCustomSink<Impl: IMFCaptureRecordSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmediasink: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCustomSink(::core::mem::transmute(&pmediasink)).into()
        }
        unsafe extern "system" fn GetRotation<Impl: IMFCaptureRecordSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pdwrotationvalue: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRotation(::core::mem::transmute_copy(&dwstreamindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwrotationvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRotation<Impl: IMFCaptureRecordSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, dwrotationvalue: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRotation(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&dwrotationvalue)).into()
        }
        Self {
            base: IMFCaptureSink_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetOutputByteStream: SetOutputByteStream::<Impl, IMPL_OFFSET>,
            SetOutputFileName: SetOutputFileName::<Impl, IMPL_OFFSET>,
            SetSampleCallback: SetSampleCallback::<Impl, IMPL_OFFSET>,
            SetCustomSink: SetCustomSink::<Impl, IMPL_OFFSET>,
            GetRotation: GetRotation::<Impl, IMPL_OFFSET>,
            SetRotation: SetRotation::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFCaptureRecordSink as ::windows::core::Interface>::IID
    }
}
pub trait IMFCaptureSink_Impl: Sized {
    fn GetOutputMediaType(&mut self, dwsinkstreamindex: u32) -> ::windows::core::Result<IMFMediaType>;
    fn GetService(&mut self, dwsinkstreamindex: u32, rguidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn AddStream(&mut self, dwsourcestreamindex: u32, pmediatype: ::core::option::Option<IMFMediaType>, pattributes: ::core::option::Option<IMFAttributes>) -> ::windows::core::Result<u32>;
    fn Prepare(&mut self) -> ::windows::core::Result<()>;
    fn RemoveAllStreams(&mut self) -> ::windows::core::Result<()>;
}
impl IMFCaptureSink_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFCaptureSink_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFCaptureSink_Vtbl {
        unsafe extern "system" fn GetOutputMediaType<Impl: IMFCaptureSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsinkstreamindex: u32, ppmediatype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOutputMediaType(::core::mem::transmute_copy(&dwsinkstreamindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediatype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetService<Impl: IMFCaptureSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsinkstreamindex: u32, rguidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppunknown: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetService(::core::mem::transmute_copy(&dwsinkstreamindex), ::core::mem::transmute_copy(&rguidservice), ::core::mem::transmute_copy(&riid)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppunknown = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddStream<Impl: IMFCaptureSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32, pmediatype: ::windows::core::RawPtr, pattributes: ::windows::core::RawPtr, pdwsinkstreamindex: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddStream(::core::mem::transmute_copy(&dwsourcestreamindex), ::core::mem::transmute(&pmediatype), ::core::mem::transmute(&pattributes)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwsinkstreamindex = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Prepare<Impl: IMFCaptureSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Prepare().into()
        }
        unsafe extern "system" fn RemoveAllStreams<Impl: IMFCaptureSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveAllStreams().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetOutputMediaType: GetOutputMediaType::<Impl, IMPL_OFFSET>,
            GetService: GetService::<Impl, IMPL_OFFSET>,
            AddStream: AddStream::<Impl, IMPL_OFFSET>,
            Prepare: Prepare::<Impl, IMPL_OFFSET>,
            RemoveAllStreams: RemoveAllStreams::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFCaptureSink as ::windows::core::Interface>::IID
    }
}
pub trait IMFCaptureSink2_Impl: Sized + IMFCaptureSink_Impl {
    fn SetOutputMediaType(&mut self, dwstreamindex: u32, pmediatype: ::core::option::Option<IMFMediaType>, pencodingattributes: ::core::option::Option<IMFAttributes>) -> ::windows::core::Result<()>;
}
impl IMFCaptureSink2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFCaptureSink2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFCaptureSink2_Vtbl {
        unsafe extern "system" fn SetOutputMediaType<Impl: IMFCaptureSink2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pmediatype: ::windows::core::RawPtr, pencodingattributes: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputMediaType(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute(&pmediatype), ::core::mem::transmute(&pencodingattributes)).into()
        }
        Self { base: IMFCaptureSink_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), SetOutputMediaType: SetOutputMediaType::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFCaptureSink2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFCaptureSource_Impl: Sized {
    fn GetCaptureDeviceSource(&mut self, mfcaptureenginedevicetype: MF_CAPTURE_ENGINE_DEVICE_TYPE) -> ::windows::core::Result<IMFMediaSource>;
    fn GetCaptureDeviceActivate(&mut self, mfcaptureenginedevicetype: MF_CAPTURE_ENGINE_DEVICE_TYPE) -> ::windows::core::Result<IMFActivate>;
    fn GetService(&mut self, rguidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn AddEffect(&mut self, dwsourcestreamindex: u32, punknown: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn RemoveEffect(&mut self, dwsourcestreamindex: u32, punknown: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn RemoveAllEffects(&mut self, dwsourcestreamindex: u32) -> ::windows::core::Result<()>;
    fn GetAvailableDeviceMediaType(&mut self, dwsourcestreamindex: u32, dwmediatypeindex: u32) -> ::windows::core::Result<IMFMediaType>;
    fn SetCurrentDeviceMediaType(&mut self, dwsourcestreamindex: u32, pmediatype: ::core::option::Option<IMFMediaType>) -> ::windows::core::Result<()>;
    fn GetCurrentDeviceMediaType(&mut self, dwsourcestreamindex: u32) -> ::windows::core::Result<IMFMediaType>;
    fn GetDeviceStreamCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetDeviceStreamCategory(&mut self, dwsourcestreamindex: u32) -> ::windows::core::Result<MF_CAPTURE_ENGINE_STREAM_CATEGORY>;
    fn GetMirrorState(&mut self, dwstreamindex: u32) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn SetMirrorState(&mut self, dwstreamindex: u32, fmirrorstate: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetStreamIndexFromFriendlyName(&mut self, uifriendlyname: u32) -> ::windows::core::Result<u32>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFCaptureSource_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFCaptureSource_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFCaptureSource_Vtbl {
        unsafe extern "system" fn GetCaptureDeviceSource<Impl: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mfcaptureenginedevicetype: MF_CAPTURE_ENGINE_DEVICE_TYPE, ppmediasource: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCaptureDeviceSource(::core::mem::transmute_copy(&mfcaptureenginedevicetype)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediasource = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCaptureDeviceActivate<Impl: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mfcaptureenginedevicetype: MF_CAPTURE_ENGINE_DEVICE_TYPE, ppactivate: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCaptureDeviceActivate(::core::mem::transmute_copy(&mfcaptureenginedevicetype)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppactivate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetService<Impl: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rguidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppunknown: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetService(::core::mem::transmute_copy(&rguidservice), ::core::mem::transmute_copy(&riid)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppunknown = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddEffect<Impl: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32, punknown: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddEffect(::core::mem::transmute_copy(&dwsourcestreamindex), ::core::mem::transmute(&punknown)).into()
        }
        unsafe extern "system" fn RemoveEffect<Impl: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32, punknown: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveEffect(::core::mem::transmute_copy(&dwsourcestreamindex), ::core::mem::transmute(&punknown)).into()
        }
        unsafe extern "system" fn RemoveAllEffects<Impl: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveAllEffects(::core::mem::transmute_copy(&dwsourcestreamindex)).into()
        }
        unsafe extern "system" fn GetAvailableDeviceMediaType<Impl: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32, dwmediatypeindex: u32, ppmediatype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAvailableDeviceMediaType(::core::mem::transmute_copy(&dwsourcestreamindex), ::core::mem::transmute_copy(&dwmediatypeindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediatype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentDeviceMediaType<Impl: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32, pmediatype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCurrentDeviceMediaType(::core::mem::transmute_copy(&dwsourcestreamindex), ::core::mem::transmute(&pmediatype)).into()
        }
        unsafe extern "system" fn GetCurrentDeviceMediaType<Impl: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32, ppmediatype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentDeviceMediaType(::core::mem::transmute_copy(&dwsourcestreamindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediatype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDeviceStreamCount<Impl: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwstreamcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDeviceStreamCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwstreamcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDeviceStreamCategory<Impl: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsourcestreamindex: u32, pstreamcategory: *mut MF_CAPTURE_ENGINE_STREAM_CATEGORY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDeviceStreamCategory(::core::mem::transmute_copy(&dwsourcestreamindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pstreamcategory = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMirrorState<Impl: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pfmirrorstate: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMirrorState(::core::mem::transmute_copy(&dwstreamindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pfmirrorstate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMirrorState<Impl: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, fmirrorstate: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMirrorState(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&fmirrorstate)).into()
        }
        unsafe extern "system" fn GetStreamIndexFromFriendlyName<Impl: IMFCaptureSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, uifriendlyname: u32, pdwactualstreamindex: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamIndexFromFriendlyName(::core::mem::transmute_copy(&uifriendlyname)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwactualstreamindex = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetCaptureDeviceSource: GetCaptureDeviceSource::<Impl, IMPL_OFFSET>,
            GetCaptureDeviceActivate: GetCaptureDeviceActivate::<Impl, IMPL_OFFSET>,
            GetService: GetService::<Impl, IMPL_OFFSET>,
            AddEffect: AddEffect::<Impl, IMPL_OFFSET>,
            RemoveEffect: RemoveEffect::<Impl, IMPL_OFFSET>,
            RemoveAllEffects: RemoveAllEffects::<Impl, IMPL_OFFSET>,
            GetAvailableDeviceMediaType: GetAvailableDeviceMediaType::<Impl, IMPL_OFFSET>,
            SetCurrentDeviceMediaType: SetCurrentDeviceMediaType::<Impl, IMPL_OFFSET>,
            GetCurrentDeviceMediaType: GetCurrentDeviceMediaType::<Impl, IMPL_OFFSET>,
            GetDeviceStreamCount: GetDeviceStreamCount::<Impl, IMPL_OFFSET>,
            GetDeviceStreamCategory: GetDeviceStreamCategory::<Impl, IMPL_OFFSET>,
            GetMirrorState: GetMirrorState::<Impl, IMPL_OFFSET>,
            SetMirrorState: SetMirrorState::<Impl, IMPL_OFFSET>,
            GetStreamIndexFromFriendlyName: GetStreamIndexFromFriendlyName::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFCaptureSource as ::windows::core::Interface>::IID
    }
}
pub trait IMFCdmSuspendNotify_Impl: Sized {
    fn Begin(&mut self) -> ::windows::core::Result<()>;
    fn End(&mut self) -> ::windows::core::Result<()>;
}
impl IMFCdmSuspendNotify_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFCdmSuspendNotify_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFCdmSuspendNotify_Vtbl {
        unsafe extern "system" fn Begin<Impl: IMFCdmSuspendNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Begin().into()
        }
        unsafe extern "system" fn End<Impl: IMFCdmSuspendNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).End().into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Begin: Begin::<Impl, IMPL_OFFSET>, End: End::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFCdmSuspendNotify as ::windows::core::Interface>::IID
    }
}
pub trait IMFClock_Impl: Sized {
    fn GetClockCharacteristics(&mut self) -> ::windows::core::Result<u32>;
    fn GetCorrelatedTime(&mut self, dwreserved: u32, pllclocktime: *mut i64, phnssystemtime: *mut i64) -> ::windows::core::Result<()>;
    fn GetContinuityKey(&mut self) -> ::windows::core::Result<u32>;
    fn GetState(&mut self, dwreserved: u32) -> ::windows::core::Result<MFCLOCK_STATE>;
    fn GetProperties(&mut self) -> ::windows::core::Result<MFCLOCK_PROPERTIES>;
}
impl IMFClock_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFClock_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFClock_Vtbl {
        unsafe extern "system" fn GetClockCharacteristics<Impl: IMFClock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwcharacteristics: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetClockCharacteristics() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwcharacteristics = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCorrelatedTime<Impl: IMFClock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwreserved: u32, pllclocktime: *mut i64, phnssystemtime: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCorrelatedTime(::core::mem::transmute_copy(&dwreserved), ::core::mem::transmute_copy(&pllclocktime), ::core::mem::transmute_copy(&phnssystemtime)).into()
        }
        unsafe extern "system" fn GetContinuityKey<Impl: IMFClock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwcontinuitykey: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetContinuityKey() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwcontinuitykey = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetState<Impl: IMFClock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwreserved: u32, peclockstate: *mut MFCLOCK_STATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetState(::core::mem::transmute_copy(&dwreserved)) {
                ::core::result::Result::Ok(ok__) => {
                    *peclockstate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProperties<Impl: IMFClock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pclockproperties: *mut MFCLOCK_PROPERTIES) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProperties() {
                ::core::result::Result::Ok(ok__) => {
                    *pclockproperties = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetClockCharacteristics: GetClockCharacteristics::<Impl, IMPL_OFFSET>,
            GetCorrelatedTime: GetCorrelatedTime::<Impl, IMPL_OFFSET>,
            GetContinuityKey: GetContinuityKey::<Impl, IMPL_OFFSET>,
            GetState: GetState::<Impl, IMPL_OFFSET>,
            GetProperties: GetProperties::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFClock as ::windows::core::Interface>::IID
    }
}
pub trait IMFClockConsumer_Impl: Sized {
    fn SetPresentationClock(&mut self, ppresentationclock: ::core::option::Option<IMFPresentationClock>) -> ::windows::core::Result<()>;
    fn GetPresentationClock(&mut self) -> ::windows::core::Result<IMFPresentationClock>;
}
impl IMFClockConsumer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFClockConsumer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFClockConsumer_Vtbl {
        unsafe extern "system" fn SetPresentationClock<Impl: IMFClockConsumer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppresentationclock: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPresentationClock(::core::mem::transmute(&ppresentationclock)).into()
        }
        unsafe extern "system" fn GetPresentationClock<Impl: IMFClockConsumer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pppresentationclock: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPresentationClock() {
                ::core::result::Result::Ok(ok__) => {
                    *pppresentationclock = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetPresentationClock: SetPresentationClock::<Impl, IMPL_OFFSET>,
            GetPresentationClock: GetPresentationClock::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFClockConsumer as ::windows::core::Interface>::IID
    }
}
pub trait IMFClockStateSink_Impl: Sized {
    fn OnClockStart(&mut self, hnssystemtime: i64, llclockstartoffset: i64) -> ::windows::core::Result<()>;
    fn OnClockStop(&mut self, hnssystemtime: i64) -> ::windows::core::Result<()>;
    fn OnClockPause(&mut self, hnssystemtime: i64) -> ::windows::core::Result<()>;
    fn OnClockRestart(&mut self, hnssystemtime: i64) -> ::windows::core::Result<()>;
    fn OnClockSetRate(&mut self, hnssystemtime: i64, flrate: f32) -> ::windows::core::Result<()>;
}
impl IMFClockStateSink_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFClockStateSink_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFClockStateSink_Vtbl {
        unsafe extern "system" fn OnClockStart<Impl: IMFClockStateSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnssystemtime: i64, llclockstartoffset: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnClockStart(::core::mem::transmute_copy(&hnssystemtime), ::core::mem::transmute_copy(&llclockstartoffset)).into()
        }
        unsafe extern "system" fn OnClockStop<Impl: IMFClockStateSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnssystemtime: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnClockStop(::core::mem::transmute_copy(&hnssystemtime)).into()
        }
        unsafe extern "system" fn OnClockPause<Impl: IMFClockStateSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnssystemtime: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnClockPause(::core::mem::transmute_copy(&hnssystemtime)).into()
        }
        unsafe extern "system" fn OnClockRestart<Impl: IMFClockStateSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnssystemtime: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnClockRestart(::core::mem::transmute_copy(&hnssystemtime)).into()
        }
        unsafe extern "system" fn OnClockSetRate<Impl: IMFClockStateSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnssystemtime: i64, flrate: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnClockSetRate(::core::mem::transmute_copy(&hnssystemtime), ::core::mem::transmute_copy(&flrate)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            OnClockStart: OnClockStart::<Impl, IMPL_OFFSET>,
            OnClockStop: OnClockStop::<Impl, IMPL_OFFSET>,
            OnClockPause: OnClockPause::<Impl, IMPL_OFFSET>,
            OnClockRestart: OnClockRestart::<Impl, IMPL_OFFSET>,
            OnClockSetRate: OnClockSetRate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFClockStateSink as ::windows::core::Interface>::IID
    }
}
pub trait IMFCollection_Impl: Sized {
    fn GetElementCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetElement(&mut self, dwelementindex: u32) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn AddElement(&mut self, punkelement: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn RemoveElement(&mut self, dwelementindex: u32) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn InsertElementAt(&mut self, dwindex: u32, punknown: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn RemoveAllElements(&mut self) -> ::windows::core::Result<()>;
}
impl IMFCollection_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFCollection_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFCollection_Vtbl {
        unsafe extern "system" fn GetElementCount<Impl: IMFCollection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcelements: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetElementCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pcelements = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetElement<Impl: IMFCollection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwelementindex: u32, ppunkelement: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetElement(::core::mem::transmute_copy(&dwelementindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppunkelement = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddElement<Impl: IMFCollection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, punkelement: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddElement(::core::mem::transmute(&punkelement)).into()
        }
        unsafe extern "system" fn RemoveElement<Impl: IMFCollection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwelementindex: u32, ppunkelement: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RemoveElement(::core::mem::transmute_copy(&dwelementindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppunkelement = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InsertElementAt<Impl: IMFCollection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, punknown: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InsertElementAt(::core::mem::transmute_copy(&dwindex), ::core::mem::transmute(&punknown)).into()
        }
        unsafe extern "system" fn RemoveAllElements<Impl: IMFCollection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveAllElements().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetElementCount: GetElementCount::<Impl, IMPL_OFFSET>,
            GetElement: GetElement::<Impl, IMPL_OFFSET>,
            AddElement: AddElement::<Impl, IMPL_OFFSET>,
            RemoveElement: RemoveElement::<Impl, IMPL_OFFSET>,
            InsertElementAt: InsertElementAt::<Impl, IMPL_OFFSET>,
            RemoveAllElements: RemoveAllElements::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFCollection as ::windows::core::Interface>::IID
    }
}
pub trait IMFContentDecryptionModule_Impl: Sized {
    fn SetContentEnabler(&mut self, contentenabler: ::core::option::Option<IMFContentEnabler>, result: ::core::option::Option<IMFAsyncResult>) -> ::windows::core::Result<()>;
    fn GetSuspendNotify(&mut self) -> ::windows::core::Result<IMFCdmSuspendNotify>;
    fn SetPMPHostApp(&mut self, pmphostapp: ::core::option::Option<IMFPMPHostApp>) -> ::windows::core::Result<()>;
    fn CreateSession(&mut self, sessiontype: MF_MEDIAKEYSESSION_TYPE, callbacks: ::core::option::Option<IMFContentDecryptionModuleSessionCallbacks>) -> ::windows::core::Result<IMFContentDecryptionModuleSession>;
    fn SetServerCertificate(&mut self, certificate: *const u8, certificatesize: u32) -> ::windows::core::Result<()>;
    fn CreateTrustedInput(&mut self, contentinitdata: *const u8, contentinitdatasize: u32) -> ::windows::core::Result<IMFTrustedInput>;
    fn GetProtectionSystemIds(&mut self, systemids: *mut *mut ::windows::core::GUID, count: *mut u32) -> ::windows::core::Result<()>;
}
impl IMFContentDecryptionModule_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFContentDecryptionModule_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFContentDecryptionModule_Vtbl {
        unsafe extern "system" fn SetContentEnabler<Impl: IMFContentDecryptionModule_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, contentenabler: ::windows::core::RawPtr, result: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentEnabler(::core::mem::transmute(&contentenabler), ::core::mem::transmute(&result)).into()
        }
        unsafe extern "system" fn GetSuspendNotify<Impl: IMFContentDecryptionModule_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, notify: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSuspendNotify() {
                ::core::result::Result::Ok(ok__) => {
                    *notify = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPMPHostApp<Impl: IMFContentDecryptionModule_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmphostapp: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPMPHostApp(::core::mem::transmute(&pmphostapp)).into()
        }
        unsafe extern "system" fn CreateSession<Impl: IMFContentDecryptionModule_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sessiontype: MF_MEDIAKEYSESSION_TYPE, callbacks: ::windows::core::RawPtr, session: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateSession(::core::mem::transmute_copy(&sessiontype), ::core::mem::transmute(&callbacks)) {
                ::core::result::Result::Ok(ok__) => {
                    *session = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetServerCertificate<Impl: IMFContentDecryptionModule_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, certificate: *const u8, certificatesize: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetServerCertificate(::core::mem::transmute_copy(&certificate), ::core::mem::transmute_copy(&certificatesize)).into()
        }
        unsafe extern "system" fn CreateTrustedInput<Impl: IMFContentDecryptionModule_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, contentinitdata: *const u8, contentinitdatasize: u32, trustedinput: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateTrustedInput(::core::mem::transmute_copy(&contentinitdata), ::core::mem::transmute_copy(&contentinitdatasize)) {
                ::core::result::Result::Ok(ok__) => {
                    *trustedinput = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProtectionSystemIds<Impl: IMFContentDecryptionModule_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, systemids: *mut *mut ::windows::core::GUID, count: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetProtectionSystemIds(::core::mem::transmute_copy(&systemids), ::core::mem::transmute_copy(&count)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetContentEnabler: SetContentEnabler::<Impl, IMPL_OFFSET>,
            GetSuspendNotify: GetSuspendNotify::<Impl, IMPL_OFFSET>,
            SetPMPHostApp: SetPMPHostApp::<Impl, IMPL_OFFSET>,
            CreateSession: CreateSession::<Impl, IMPL_OFFSET>,
            SetServerCertificate: SetServerCertificate::<Impl, IMPL_OFFSET>,
            CreateTrustedInput: CreateTrustedInput::<Impl, IMPL_OFFSET>,
            GetProtectionSystemIds: GetProtectionSystemIds::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFContentDecryptionModule as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_Shell_PropertiesSystem"))]
pub trait IMFContentDecryptionModuleAccess_Impl: Sized {
    fn CreateContentDecryptionModule(&mut self, contentdecryptionmoduleproperties: ::core::option::Option<super::super::UI::Shell::PropertiesSystem::IPropertyStore>) -> ::windows::core::Result<IMFContentDecryptionModule>;
    fn GetConfiguration(&mut self) -> ::windows::core::Result<super::super::UI::Shell::PropertiesSystem::IPropertyStore>;
    fn GetKeySystem(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_Shell_PropertiesSystem"))]
impl IMFContentDecryptionModuleAccess_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFContentDecryptionModuleAccess_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFContentDecryptionModuleAccess_Vtbl {
        unsafe extern "system" fn CreateContentDecryptionModule<Impl: IMFContentDecryptionModuleAccess_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, contentdecryptionmoduleproperties: ::windows::core::RawPtr, contentdecryptionmodule: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateContentDecryptionModule(::core::mem::transmute(&contentdecryptionmoduleproperties)) {
                ::core::result::Result::Ok(ok__) => {
                    *contentdecryptionmodule = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetConfiguration<Impl: IMFContentDecryptionModuleAccess_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, configuration: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetConfiguration() {
                ::core::result::Result::Ok(ok__) => {
                    *configuration = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetKeySystem<Impl: IMFContentDecryptionModuleAccess_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, keysystem: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetKeySystem() {
                ::core::result::Result::Ok(ok__) => {
                    *keysystem = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            CreateContentDecryptionModule: CreateContentDecryptionModule::<Impl, IMPL_OFFSET>,
            GetConfiguration: GetConfiguration::<Impl, IMPL_OFFSET>,
            GetKeySystem: GetKeySystem::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFContentDecryptionModuleAccess as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_Shell_PropertiesSystem"))]
pub trait IMFContentDecryptionModuleFactory_Impl: Sized {
    fn IsTypeSupported(&mut self, keysystem: super::super::Foundation::PWSTR, contenttype: super::super::Foundation::PWSTR) -> super::super::Foundation::BOOL;
    fn CreateContentDecryptionModuleAccess(&mut self, keysystem: super::super::Foundation::PWSTR, configurations: *const ::core::option::Option<super::super::UI::Shell::PropertiesSystem::IPropertyStore>, numconfigurations: u32) -> ::windows::core::Result<IMFContentDecryptionModuleAccess>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_Shell_PropertiesSystem"))]
impl IMFContentDecryptionModuleFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFContentDecryptionModuleFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFContentDecryptionModuleFactory_Vtbl {
        unsafe extern "system" fn IsTypeSupported<Impl: IMFContentDecryptionModuleFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, keysystem: super::super::Foundation::PWSTR, contenttype: super::super::Foundation::PWSTR) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsTypeSupported(::core::mem::transmute_copy(&keysystem), ::core::mem::transmute_copy(&contenttype))
        }
        unsafe extern "system" fn CreateContentDecryptionModuleAccess<Impl: IMFContentDecryptionModuleFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, keysystem: super::super::Foundation::PWSTR, configurations: *const ::windows::core::RawPtr, numconfigurations: u32, contentdecryptionmoduleaccess: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateContentDecryptionModuleAccess(::core::mem::transmute_copy(&keysystem), ::core::mem::transmute_copy(&configurations), ::core::mem::transmute_copy(&numconfigurations)) {
                ::core::result::Result::Ok(ok__) => {
                    *contentdecryptionmoduleaccess = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            IsTypeSupported: IsTypeSupported::<Impl, IMPL_OFFSET>,
            CreateContentDecryptionModuleAccess: CreateContentDecryptionModuleAccess::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFContentDecryptionModuleFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFContentDecryptionModuleSession_Impl: Sized {
    fn GetSessionId(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
    fn GetExpiration(&mut self) -> ::windows::core::Result<f64>;
    fn GetKeyStatuses(&mut self, keystatuses: *mut *mut MFMediaKeyStatus, numkeystatuses: *mut u32) -> ::windows::core::Result<()>;
    fn Load(&mut self, sessionid: super::super::Foundation::PWSTR) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GenerateRequest(&mut self, initdatatype: super::super::Foundation::PWSTR, initdata: *const u8, initdatasize: u32) -> ::windows::core::Result<()>;
    fn Update(&mut self, response: *const u8, responsesize: u32) -> ::windows::core::Result<()>;
    fn Close(&mut self) -> ::windows::core::Result<()>;
    fn Remove(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFContentDecryptionModuleSession_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFContentDecryptionModuleSession_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFContentDecryptionModuleSession_Vtbl {
        unsafe extern "system" fn GetSessionId<Impl: IMFContentDecryptionModuleSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sessionid: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSessionId() {
                ::core::result::Result::Ok(ok__) => {
                    *sessionid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetExpiration<Impl: IMFContentDecryptionModuleSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, expiration: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetExpiration() {
                ::core::result::Result::Ok(ok__) => {
                    *expiration = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetKeyStatuses<Impl: IMFContentDecryptionModuleSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, keystatuses: *mut *mut MFMediaKeyStatus, numkeystatuses: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetKeyStatuses(::core::mem::transmute_copy(&keystatuses), ::core::mem::transmute_copy(&numkeystatuses)).into()
        }
        unsafe extern "system" fn Load<Impl: IMFContentDecryptionModuleSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sessionid: super::super::Foundation::PWSTR, loaded: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Load(::core::mem::transmute_copy(&sessionid)) {
                ::core::result::Result::Ok(ok__) => {
                    *loaded = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GenerateRequest<Impl: IMFContentDecryptionModuleSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, initdatatype: super::super::Foundation::PWSTR, initdata: *const u8, initdatasize: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GenerateRequest(::core::mem::transmute_copy(&initdatatype), ::core::mem::transmute_copy(&initdata), ::core::mem::transmute_copy(&initdatasize)).into()
        }
        unsafe extern "system" fn Update<Impl: IMFContentDecryptionModuleSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, response: *const u8, responsesize: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Update(::core::mem::transmute_copy(&response), ::core::mem::transmute_copy(&responsesize)).into()
        }
        unsafe extern "system" fn Close<Impl: IMFContentDecryptionModuleSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Close().into()
        }
        unsafe extern "system" fn Remove<Impl: IMFContentDecryptionModuleSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Remove().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetSessionId: GetSessionId::<Impl, IMPL_OFFSET>,
            GetExpiration: GetExpiration::<Impl, IMPL_OFFSET>,
            GetKeyStatuses: GetKeyStatuses::<Impl, IMPL_OFFSET>,
            Load: Load::<Impl, IMPL_OFFSET>,
            GenerateRequest: GenerateRequest::<Impl, IMPL_OFFSET>,
            Update: Update::<Impl, IMPL_OFFSET>,
            Close: Close::<Impl, IMPL_OFFSET>,
            Remove: Remove::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFContentDecryptionModuleSession as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFContentDecryptionModuleSessionCallbacks_Impl: Sized {
    fn KeyMessage(&mut self, messagetype: MF_MEDIAKEYSESSION_MESSAGETYPE, message: *const u8, messagesize: u32, destinationurl: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn KeyStatusChanged(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFContentDecryptionModuleSessionCallbacks_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFContentDecryptionModuleSessionCallbacks_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFContentDecryptionModuleSessionCallbacks_Vtbl {
        unsafe extern "system" fn KeyMessage<Impl: IMFContentDecryptionModuleSessionCallbacks_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, messagetype: MF_MEDIAKEYSESSION_MESSAGETYPE, message: *const u8, messagesize: u32, destinationurl: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).KeyMessage(::core::mem::transmute_copy(&messagetype), ::core::mem::transmute_copy(&message), ::core::mem::transmute_copy(&messagesize), ::core::mem::transmute_copy(&destinationurl)).into()
        }
        unsafe extern "system" fn KeyStatusChanged<Impl: IMFContentDecryptionModuleSessionCallbacks_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).KeyStatusChanged().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            KeyMessage: KeyMessage::<Impl, IMPL_OFFSET>,
            KeyStatusChanged: KeyStatusChanged::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFContentDecryptionModuleSessionCallbacks as ::windows::core::Interface>::IID
    }
}
pub trait IMFContentDecryptorContext_Impl: Sized {
    fn InitializeHardwareKey(&mut self, inputprivatedatabytecount: u32, inputprivatedata: *const ::core::ffi::c_void) -> ::windows::core::Result<u64>;
}
impl IMFContentDecryptorContext_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFContentDecryptorContext_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFContentDecryptorContext_Vtbl {
        unsafe extern "system" fn InitializeHardwareKey<Impl: IMFContentDecryptorContext_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, inputprivatedatabytecount: u32, inputprivatedata: *const ::core::ffi::c_void, outputprivatedata: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).InitializeHardwareKey(::core::mem::transmute_copy(&inputprivatedatabytecount), ::core::mem::transmute_copy(&inputprivatedata)) {
                ::core::result::Result::Ok(ok__) => {
                    *outputprivatedata = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), InitializeHardwareKey: InitializeHardwareKey::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFContentDecryptorContext as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFContentEnabler_Impl: Sized {
    fn GetEnableType(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn GetEnableURL(&mut self, ppwszurl: *mut super::super::Foundation::PWSTR, pcchurl: *mut u32, ptruststatus: *mut MF_URL_TRUST_STATUS) -> ::windows::core::Result<()>;
    fn GetEnableData(&mut self, ppbdata: *mut *mut u8, pcbdata: *mut u32) -> ::windows::core::Result<()>;
    fn IsAutomaticSupported(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn AutomaticEnable(&mut self) -> ::windows::core::Result<()>;
    fn MonitorEnable(&mut self) -> ::windows::core::Result<()>;
    fn Cancel(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFContentEnabler_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFContentEnabler_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFContentEnabler_Vtbl {
        unsafe extern "system" fn GetEnableType<Impl: IMFContentEnabler_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEnableType() {
                ::core::result::Result::Ok(ok__) => {
                    *ptype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEnableURL<Impl: IMFContentEnabler_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppwszurl: *mut super::super::Foundation::PWSTR, pcchurl: *mut u32, ptruststatus: *mut MF_URL_TRUST_STATUS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetEnableURL(::core::mem::transmute_copy(&ppwszurl), ::core::mem::transmute_copy(&pcchurl), ::core::mem::transmute_copy(&ptruststatus)).into()
        }
        unsafe extern "system" fn GetEnableData<Impl: IMFContentEnabler_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppbdata: *mut *mut u8, pcbdata: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetEnableData(::core::mem::transmute_copy(&ppbdata), ::core::mem::transmute_copy(&pcbdata)).into()
        }
        unsafe extern "system" fn IsAutomaticSupported<Impl: IMFContentEnabler_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfautomatic: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsAutomaticSupported() {
                ::core::result::Result::Ok(ok__) => {
                    *pfautomatic = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AutomaticEnable<Impl: IMFContentEnabler_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AutomaticEnable().into()
        }
        unsafe extern "system" fn MonitorEnable<Impl: IMFContentEnabler_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MonitorEnable().into()
        }
        unsafe extern "system" fn Cancel<Impl: IMFContentEnabler_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Cancel().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetEnableType: GetEnableType::<Impl, IMPL_OFFSET>,
            GetEnableURL: GetEnableURL::<Impl, IMPL_OFFSET>,
            GetEnableData: GetEnableData::<Impl, IMPL_OFFSET>,
            IsAutomaticSupported: IsAutomaticSupported::<Impl, IMPL_OFFSET>,
            AutomaticEnable: AutomaticEnable::<Impl, IMPL_OFFSET>,
            MonitorEnable: MonitorEnable::<Impl, IMPL_OFFSET>,
            Cancel: Cancel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFContentEnabler as ::windows::core::Interface>::IID
    }
}
pub trait IMFContentProtectionDevice_Impl: Sized {
    fn InvokeFunction(&mut self, functionid: u32, inputbufferbytecount: u32, inputbuffer: *const u8, outputbufferbytecount: *mut u32, outputbuffer: *mut u8) -> ::windows::core::Result<()>;
    fn GetPrivateDataByteCount(&mut self, privateinputbytecount: *mut u32, privateoutputbytecount: *mut u32) -> ::windows::core::Result<()>;
}
impl IMFContentProtectionDevice_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFContentProtectionDevice_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFContentProtectionDevice_Vtbl {
        unsafe extern "system" fn InvokeFunction<Impl: IMFContentProtectionDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, functionid: u32, inputbufferbytecount: u32, inputbuffer: *const u8, outputbufferbytecount: *mut u32, outputbuffer: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InvokeFunction(::core::mem::transmute_copy(&functionid), ::core::mem::transmute_copy(&inputbufferbytecount), ::core::mem::transmute_copy(&inputbuffer), ::core::mem::transmute_copy(&outputbufferbytecount), ::core::mem::transmute_copy(&outputbuffer)).into()
        }
        unsafe extern "system" fn GetPrivateDataByteCount<Impl: IMFContentProtectionDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, privateinputbytecount: *mut u32, privateoutputbytecount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPrivateDataByteCount(::core::mem::transmute_copy(&privateinputbytecount), ::core::mem::transmute_copy(&privateoutputbytecount)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            InvokeFunction: InvokeFunction::<Impl, IMPL_OFFSET>,
            GetPrivateDataByteCount: GetPrivateDataByteCount::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFContentProtectionDevice as ::windows::core::Interface>::IID
    }
}
pub trait IMFContentProtectionManager_Impl: Sized {
    fn BeginEnableContent(&mut self, penableractivate: ::core::option::Option<IMFActivate>, ptopo: ::core::option::Option<IMFTopology>, pcallback: ::core::option::Option<IMFAsyncCallback>, punkstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndEnableContent(&mut self, presult: ::core::option::Option<IMFAsyncResult>) -> ::windows::core::Result<()>;
}
impl IMFContentProtectionManager_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFContentProtectionManager_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFContentProtectionManager_Vtbl {
        unsafe extern "system" fn BeginEnableContent<Impl: IMFContentProtectionManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, penableractivate: ::windows::core::RawPtr, ptopo: ::windows::core::RawPtr, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginEnableContent(::core::mem::transmute(&penableractivate), ::core::mem::transmute(&ptopo), ::core::mem::transmute(&pcallback), ::core::mem::transmute(&punkstate)).into()
        }
        unsafe extern "system" fn EndEnableContent<Impl: IMFContentProtectionManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndEnableContent(::core::mem::transmute(&presult)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            BeginEnableContent: BeginEnableContent::<Impl, IMPL_OFFSET>,
            EndEnableContent: EndEnableContent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFContentProtectionManager as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFD3D12SynchronizationObject_Impl: Sized {
    fn SignalEventOnFinalResourceRelease(&mut self, hevent: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn Reset(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFD3D12SynchronizationObject_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFD3D12SynchronizationObject_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFD3D12SynchronizationObject_Vtbl {
        unsafe extern "system" fn SignalEventOnFinalResourceRelease<Impl: IMFD3D12SynchronizationObject_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hevent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SignalEventOnFinalResourceRelease(::core::mem::transmute_copy(&hevent)).into()
        }
        unsafe extern "system" fn Reset<Impl: IMFD3D12SynchronizationObject_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reset().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SignalEventOnFinalResourceRelease: SignalEventOnFinalResourceRelease::<Impl, IMPL_OFFSET>,
            Reset: Reset::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFD3D12SynchronizationObject as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
pub trait IMFD3D12SynchronizationObjectCommands_Impl: Sized {
    fn EnqueueResourceReady(&mut self, pproducercommandqueue: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12CommandQueue>) -> ::windows::core::Result<()>;
    fn EnqueueResourceReadyWait(&mut self, pconsumercommandqueue: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12CommandQueue>) -> ::windows::core::Result<()>;
    fn SignalEventOnResourceReady(&mut self, hevent: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn EnqueueResourceRelease(&mut self, pconsumercommandqueue: ::core::option::Option<super::super::Graphics::Direct3D12::ID3D12CommandQueue>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D12"))]
impl IMFD3D12SynchronizationObjectCommands_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFD3D12SynchronizationObjectCommands_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFD3D12SynchronizationObjectCommands_Vtbl {
        unsafe extern "system" fn EnqueueResourceReady<Impl: IMFD3D12SynchronizationObjectCommands_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pproducercommandqueue: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EnqueueResourceReady(::core::mem::transmute(&pproducercommandqueue)).into()
        }
        unsafe extern "system" fn EnqueueResourceReadyWait<Impl: IMFD3D12SynchronizationObjectCommands_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pconsumercommandqueue: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EnqueueResourceReadyWait(::core::mem::transmute(&pconsumercommandqueue)).into()
        }
        unsafe extern "system" fn SignalEventOnResourceReady<Impl: IMFD3D12SynchronizationObjectCommands_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hevent: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SignalEventOnResourceReady(::core::mem::transmute_copy(&hevent)).into()
        }
        unsafe extern "system" fn EnqueueResourceRelease<Impl: IMFD3D12SynchronizationObjectCommands_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pconsumercommandqueue: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EnqueueResourceRelease(::core::mem::transmute(&pconsumercommandqueue)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            EnqueueResourceReady: EnqueueResourceReady::<Impl, IMPL_OFFSET>,
            EnqueueResourceReadyWait: EnqueueResourceReadyWait::<Impl, IMPL_OFFSET>,
            SignalEventOnResourceReady: SignalEventOnResourceReady::<Impl, IMPL_OFFSET>,
            EnqueueResourceRelease: EnqueueResourceRelease::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFD3D12SynchronizationObjectCommands as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFDLNASinkInit_Impl: Sized {
    fn Initialize(&mut self, pbytestream: ::core::option::Option<IMFByteStream>, fpal: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFDLNASinkInit_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFDLNASinkInit_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFDLNASinkInit_Vtbl {
        unsafe extern "system" fn Initialize<Impl: IMFDLNASinkInit_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbytestream: ::windows::core::RawPtr, fpal: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Initialize(::core::mem::transmute(&pbytestream), ::core::mem::transmute_copy(&fpal)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Initialize: Initialize::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFDLNASinkInit as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFDRMNetHelper_Impl: Sized {
    fn ProcessLicenseRequest(&mut self, plicenserequest: *const u8, cblicenserequest: u32, pplicenseresponse: *mut *mut u8, pcblicenseresponse: *mut u32, pbstrkid: *mut super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn GetChainedLicenseResponse(&mut self, pplicenseresponse: *mut *mut u8, pcblicenseresponse: *mut u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFDRMNetHelper_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFDRMNetHelper_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFDRMNetHelper_Vtbl {
        unsafe extern "system" fn ProcessLicenseRequest<Impl: IMFDRMNetHelper_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plicenserequest: *const u8, cblicenserequest: u32, pplicenseresponse: *mut *mut u8, pcblicenseresponse: *mut u32, pbstrkid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ProcessLicenseRequest(::core::mem::transmute_copy(&plicenserequest), ::core::mem::transmute_copy(&cblicenserequest), ::core::mem::transmute_copy(&pplicenseresponse), ::core::mem::transmute_copy(&pcblicenseresponse), ::core::mem::transmute_copy(&pbstrkid)).into()
        }
        unsafe extern "system" fn GetChainedLicenseResponse<Impl: IMFDRMNetHelper_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pplicenseresponse: *mut *mut u8, pcblicenseresponse: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetChainedLicenseResponse(::core::mem::transmute_copy(&pplicenseresponse), ::core::mem::transmute_copy(&pcblicenseresponse)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            ProcessLicenseRequest: ProcessLicenseRequest::<Impl, IMPL_OFFSET>,
            GetChainedLicenseResponse: GetChainedLicenseResponse::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFDRMNetHelper as ::windows::core::Interface>::IID
    }
}
pub trait IMFDXGIBuffer_Impl: Sized {
    fn GetResource(&mut self, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn GetSubresourceIndex(&mut self) -> ::windows::core::Result<u32>;
    fn GetUnknown(&mut self, guid: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn SetUnknown(&mut self, guid: *const ::windows::core::GUID, punkdata: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
}
impl IMFDXGIBuffer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFDXGIBuffer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFDXGIBuffer_Vtbl {
        unsafe extern "system" fn GetResource<Impl: IMFDXGIBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetResource(::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvobject)).into()
        }
        unsafe extern "system" fn GetSubresourceIndex<Impl: IMFDXGIBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pusubresource: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSubresourceIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *pusubresource = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetUnknown<Impl: IMFDXGIBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guid: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetUnknown(::core::mem::transmute_copy(&guid), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvobject)).into()
        }
        unsafe extern "system" fn SetUnknown<Impl: IMFDXGIBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guid: *const ::windows::core::GUID, punkdata: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUnknown(::core::mem::transmute_copy(&guid), ::core::mem::transmute(&punkdata)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetResource: GetResource::<Impl, IMPL_OFFSET>,
            GetSubresourceIndex: GetSubresourceIndex::<Impl, IMPL_OFFSET>,
            GetUnknown: GetUnknown::<Impl, IMPL_OFFSET>,
            SetUnknown: SetUnknown::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFDXGIBuffer as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFDXGIDeviceManager_Impl: Sized {
    fn CloseDeviceHandle(&mut self, hdevice: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn GetVideoService(&mut self, hdevice: super::super::Foundation::HANDLE, riid: *const ::windows::core::GUID, ppservice: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn LockDevice(&mut self, hdevice: super::super::Foundation::HANDLE, riid: *const ::windows::core::GUID, ppunkdevice: *mut *mut ::core::ffi::c_void, fblock: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn OpenDeviceHandle(&mut self) -> ::windows::core::Result<super::super::Foundation::HANDLE>;
    fn ResetDevice(&mut self, punkdevice: ::core::option::Option<::windows::core::IUnknown>, resettoken: u32) -> ::windows::core::Result<()>;
    fn TestDevice(&mut self, hdevice: super::super::Foundation::HANDLE) -> ::windows::core::Result<()>;
    fn UnlockDevice(&mut self, hdevice: super::super::Foundation::HANDLE, fsavestate: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFDXGIDeviceManager_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFDXGIDeviceManager_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFDXGIDeviceManager_Vtbl {
        unsafe extern "system" fn CloseDeviceHandle<Impl: IMFDXGIDeviceManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CloseDeviceHandle(::core::mem::transmute_copy(&hdevice)).into()
        }
        unsafe extern "system" fn GetVideoService<Impl: IMFDXGIDeviceManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, riid: *const ::windows::core::GUID, ppservice: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoService(::core::mem::transmute_copy(&hdevice), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppservice)).into()
        }
        unsafe extern "system" fn LockDevice<Impl: IMFDXGIDeviceManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, riid: *const ::windows::core::GUID, ppunkdevice: *mut *mut ::core::ffi::c_void, fblock: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LockDevice(::core::mem::transmute_copy(&hdevice), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppunkdevice), ::core::mem::transmute_copy(&fblock)).into()
        }
        unsafe extern "system" fn OpenDeviceHandle<Impl: IMFDXGIDeviceManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phdevice: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OpenDeviceHandle() {
                ::core::result::Result::Ok(ok__) => {
                    *phdevice = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ResetDevice<Impl: IMFDXGIDeviceManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, punkdevice: *mut ::core::ffi::c_void, resettoken: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ResetDevice(::core::mem::transmute(&punkdevice), ::core::mem::transmute_copy(&resettoken)).into()
        }
        unsafe extern "system" fn TestDevice<Impl: IMFDXGIDeviceManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TestDevice(::core::mem::transmute_copy(&hdevice)).into()
        }
        unsafe extern "system" fn UnlockDevice<Impl: IMFDXGIDeviceManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hdevice: super::super::Foundation::HANDLE, fsavestate: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnlockDevice(::core::mem::transmute_copy(&hdevice), ::core::mem::transmute_copy(&fsavestate)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            CloseDeviceHandle: CloseDeviceHandle::<Impl, IMPL_OFFSET>,
            GetVideoService: GetVideoService::<Impl, IMPL_OFFSET>,
            LockDevice: LockDevice::<Impl, IMPL_OFFSET>,
            OpenDeviceHandle: OpenDeviceHandle::<Impl, IMPL_OFFSET>,
            ResetDevice: ResetDevice::<Impl, IMPL_OFFSET>,
            TestDevice: TestDevice::<Impl, IMPL_OFFSET>,
            UnlockDevice: UnlockDevice::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFDXGIDeviceManager as ::windows::core::Interface>::IID
    }
}
pub trait IMFDXGIDeviceManagerSource_Impl: Sized {
    fn GetManager(&mut self) -> ::windows::core::Result<IMFDXGIDeviceManager>;
}
impl IMFDXGIDeviceManagerSource_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFDXGIDeviceManagerSource_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFDXGIDeviceManagerSource_Vtbl {
        unsafe extern "system" fn GetManager<Impl: IMFDXGIDeviceManagerSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppmanager: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetManager() {
                ::core::result::Result::Ok(ok__) => {
                    *ppmanager = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetManager: GetManager::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFDXGIDeviceManagerSource as ::windows::core::Interface>::IID
    }
}
pub trait IMFDesiredSample_Impl: Sized {
    fn GetDesiredSampleTimeAndDuration(&mut self, phnssampletime: *mut i64, phnssampleduration: *mut i64) -> ::windows::core::Result<()>;
    fn SetDesiredSampleTimeAndDuration(&mut self, hnssampletime: i64, hnssampleduration: i64);
    fn Clear(&mut self);
}
impl IMFDesiredSample_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFDesiredSample_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFDesiredSample_Vtbl {
        unsafe extern "system" fn GetDesiredSampleTimeAndDuration<Impl: IMFDesiredSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phnssampletime: *mut i64, phnssampleduration: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDesiredSampleTimeAndDuration(::core::mem::transmute_copy(&phnssampletime), ::core::mem::transmute_copy(&phnssampleduration)).into()
        }
        unsafe extern "system" fn SetDesiredSampleTimeAndDuration<Impl: IMFDesiredSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnssampletime: i64, hnssampleduration: i64) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDesiredSampleTimeAndDuration(::core::mem::transmute_copy(&hnssampletime), ::core::mem::transmute_copy(&hnssampleduration))
        }
        unsafe extern "system" fn Clear<Impl: IMFDesiredSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Clear()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetDesiredSampleTimeAndDuration: GetDesiredSampleTimeAndDuration::<Impl, IMPL_OFFSET>,
            SetDesiredSampleTimeAndDuration: SetDesiredSampleTimeAndDuration::<Impl, IMPL_OFFSET>,
            Clear: Clear::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFDesiredSample as ::windows::core::Interface>::IID
    }
}
pub trait IMFExtendedCameraControl_Impl: Sized {
    fn GetCapabilities(&mut self) -> u64;
    fn SetFlags(&mut self, ulflags: u64) -> ::windows::core::Result<()>;
    fn GetFlags(&mut self) -> u64;
    fn LockPayload(&mut self, pppayload: *mut *mut u8, pulpayload: *mut u32) -> ::windows::core::Result<()>;
    fn UnlockPayload(&mut self) -> ::windows::core::Result<()>;
    fn CommitSettings(&mut self) -> ::windows::core::Result<()>;
}
impl IMFExtendedCameraControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFExtendedCameraControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFExtendedCameraControl_Vtbl {
        unsafe extern "system" fn GetCapabilities<Impl: IMFExtendedCameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u64 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCapabilities()
        }
        unsafe extern "system" fn SetFlags<Impl: IMFExtendedCameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulflags: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFlags(::core::mem::transmute_copy(&ulflags)).into()
        }
        unsafe extern "system" fn GetFlags<Impl: IMFExtendedCameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u64 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetFlags()
        }
        unsafe extern "system" fn LockPayload<Impl: IMFExtendedCameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pppayload: *mut *mut u8, pulpayload: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LockPayload(::core::mem::transmute_copy(&pppayload), ::core::mem::transmute_copy(&pulpayload)).into()
        }
        unsafe extern "system" fn UnlockPayload<Impl: IMFExtendedCameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnlockPayload().into()
        }
        unsafe extern "system" fn CommitSettings<Impl: IMFExtendedCameraControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CommitSettings().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetCapabilities: GetCapabilities::<Impl, IMPL_OFFSET>,
            SetFlags: SetFlags::<Impl, IMPL_OFFSET>,
            GetFlags: GetFlags::<Impl, IMPL_OFFSET>,
            LockPayload: LockPayload::<Impl, IMPL_OFFSET>,
            UnlockPayload: UnlockPayload::<Impl, IMPL_OFFSET>,
            CommitSettings: CommitSettings::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFExtendedCameraControl as ::windows::core::Interface>::IID
    }
}
pub trait IMFExtendedCameraController_Impl: Sized {
    fn GetExtendedCameraControl(&mut self, dwstreamindex: u32, ulpropertyid: u32) -> ::windows::core::Result<IMFExtendedCameraControl>;
}
impl IMFExtendedCameraController_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFExtendedCameraController_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFExtendedCameraController_Vtbl {
        unsafe extern "system" fn GetExtendedCameraControl<Impl: IMFExtendedCameraController_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, ulpropertyid: u32, ppcontrol: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetExtendedCameraControl(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&ulpropertyid)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcontrol = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetExtendedCameraControl: GetExtendedCameraControl::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFExtendedCameraController as ::windows::core::Interface>::IID
    }
}
pub trait IMFExtendedCameraIntrinsicModel_Impl: Sized {
    fn GetModel(&mut self) -> ::windows::core::Result<MFExtendedCameraIntrinsic_IntrinsicModel>;
    fn SetModel(&mut self, pintrinsicmodel: *const MFExtendedCameraIntrinsic_IntrinsicModel) -> ::windows::core::Result<()>;
    fn GetDistortionModelType(&mut self) -> ::windows::core::Result<MFCameraIntrinsic_DistortionModelType>;
}
impl IMFExtendedCameraIntrinsicModel_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFExtendedCameraIntrinsicModel_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFExtendedCameraIntrinsicModel_Vtbl {
        unsafe extern "system" fn GetModel<Impl: IMFExtendedCameraIntrinsicModel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pintrinsicmodel: *mut MFExtendedCameraIntrinsic_IntrinsicModel) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetModel() {
                ::core::result::Result::Ok(ok__) => {
                    *pintrinsicmodel = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetModel<Impl: IMFExtendedCameraIntrinsicModel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pintrinsicmodel: *const MFExtendedCameraIntrinsic_IntrinsicModel) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetModel(::core::mem::transmute_copy(&pintrinsicmodel)).into()
        }
        unsafe extern "system" fn GetDistortionModelType<Impl: IMFExtendedCameraIntrinsicModel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdistortionmodeltype: *mut MFCameraIntrinsic_DistortionModelType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDistortionModelType() {
                ::core::result::Result::Ok(ok__) => {
                    *pdistortionmodeltype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetModel: GetModel::<Impl, IMPL_OFFSET>,
            SetModel: SetModel::<Impl, IMPL_OFFSET>,
            GetDistortionModelType: GetDistortionModelType::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFExtendedCameraIntrinsicModel as ::windows::core::Interface>::IID
    }
}
pub trait IMFExtendedCameraIntrinsics_Impl: Sized {
    fn InitializeFromBuffer(&mut self, pbbuffer: *const u8, dwbuffersize: u32) -> ::windows::core::Result<()>;
    fn GetBufferSize(&mut self) -> ::windows::core::Result<u32>;
    fn SerializeToBuffer(&mut self, pbbuffer: *mut u8, pdwbuffersize: *mut u32) -> ::windows::core::Result<()>;
    fn GetIntrinsicModelCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetIntrinsicModelByIndex(&mut self, dwindex: u32) -> ::windows::core::Result<IMFExtendedCameraIntrinsicModel>;
    fn AddIntrinsicModel(&mut self, pintrinsicmodel: ::core::option::Option<IMFExtendedCameraIntrinsicModel>) -> ::windows::core::Result<()>;
}
impl IMFExtendedCameraIntrinsics_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFExtendedCameraIntrinsics_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFExtendedCameraIntrinsics_Vtbl {
        unsafe extern "system" fn InitializeFromBuffer<Impl: IMFExtendedCameraIntrinsics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbbuffer: *const u8, dwbuffersize: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InitializeFromBuffer(::core::mem::transmute_copy(&pbbuffer), ::core::mem::transmute_copy(&dwbuffersize)).into()
        }
        unsafe extern "system" fn GetBufferSize<Impl: IMFExtendedCameraIntrinsics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwbuffersize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBufferSize() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwbuffersize = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SerializeToBuffer<Impl: IMFExtendedCameraIntrinsics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbbuffer: *mut u8, pdwbuffersize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SerializeToBuffer(::core::mem::transmute_copy(&pbbuffer), ::core::mem::transmute_copy(&pdwbuffersize)).into()
        }
        unsafe extern "system" fn GetIntrinsicModelCount<Impl: IMFExtendedCameraIntrinsics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIntrinsicModelCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIntrinsicModelByIndex<Impl: IMFExtendedCameraIntrinsics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppintrinsicmodel: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIntrinsicModelByIndex(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppintrinsicmodel = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddIntrinsicModel<Impl: IMFExtendedCameraIntrinsics_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pintrinsicmodel: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddIntrinsicModel(::core::mem::transmute(&pintrinsicmodel)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            InitializeFromBuffer: InitializeFromBuffer::<Impl, IMPL_OFFSET>,
            GetBufferSize: GetBufferSize::<Impl, IMPL_OFFSET>,
            SerializeToBuffer: SerializeToBuffer::<Impl, IMPL_OFFSET>,
            GetIntrinsicModelCount: GetIntrinsicModelCount::<Impl, IMPL_OFFSET>,
            GetIntrinsicModelByIndex: GetIntrinsicModelByIndex::<Impl, IMPL_OFFSET>,
            AddIntrinsicModel: AddIntrinsicModel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFExtendedCameraIntrinsics as ::windows::core::Interface>::IID
    }
}
pub trait IMFExtendedCameraIntrinsicsDistortionModel6KT_Impl: Sized {
    fn GetDistortionModel(&mut self) -> ::windows::core::Result<MFCameraIntrinsic_DistortionModel6KT>;
    fn SetDistortionModel(&mut self, pdistortionmodel: *const MFCameraIntrinsic_DistortionModel6KT) -> ::windows::core::Result<()>;
}
impl IMFExtendedCameraIntrinsicsDistortionModel6KT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFExtendedCameraIntrinsicsDistortionModel6KT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFExtendedCameraIntrinsicsDistortionModel6KT_Vtbl {
        unsafe extern "system" fn GetDistortionModel<Impl: IMFExtendedCameraIntrinsicsDistortionModel6KT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdistortionmodel: *mut MFCameraIntrinsic_DistortionModel6KT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDistortionModel() {
                ::core::result::Result::Ok(ok__) => {
                    *pdistortionmodel = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDistortionModel<Impl: IMFExtendedCameraIntrinsicsDistortionModel6KT_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdistortionmodel: *const MFCameraIntrinsic_DistortionModel6KT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDistortionModel(::core::mem::transmute_copy(&pdistortionmodel)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetDistortionModel: GetDistortionModel::<Impl, IMPL_OFFSET>,
            SetDistortionModel: SetDistortionModel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFExtendedCameraIntrinsicsDistortionModel6KT as ::windows::core::Interface>::IID
    }
}
pub trait IMFExtendedCameraIntrinsicsDistortionModelArcTan_Impl: Sized {
    fn GetDistortionModel(&mut self) -> ::windows::core::Result<MFCameraIntrinsic_DistortionModelArcTan>;
    fn SetDistortionModel(&mut self, pdistortionmodel: *const MFCameraIntrinsic_DistortionModelArcTan) -> ::windows::core::Result<()>;
}
impl IMFExtendedCameraIntrinsicsDistortionModelArcTan_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFExtendedCameraIntrinsicsDistortionModelArcTan_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFExtendedCameraIntrinsicsDistortionModelArcTan_Vtbl {
        unsafe extern "system" fn GetDistortionModel<Impl: IMFExtendedCameraIntrinsicsDistortionModelArcTan_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdistortionmodel: *mut MFCameraIntrinsic_DistortionModelArcTan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDistortionModel() {
                ::core::result::Result::Ok(ok__) => {
                    *pdistortionmodel = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDistortionModel<Impl: IMFExtendedCameraIntrinsicsDistortionModelArcTan_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdistortionmodel: *const MFCameraIntrinsic_DistortionModelArcTan) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDistortionModel(::core::mem::transmute_copy(&pdistortionmodel)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetDistortionModel: GetDistortionModel::<Impl, IMPL_OFFSET>,
            SetDistortionModel: SetDistortionModel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFExtendedCameraIntrinsicsDistortionModelArcTan as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFExtendedDRMTypeSupport_Impl: Sized {
    fn IsTypeSupportedEx(&mut self, r#type: super::super::Foundation::BSTR, keysystem: super::super::Foundation::BSTR) -> ::windows::core::Result<MF_MEDIA_ENGINE_CANPLAY>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFExtendedDRMTypeSupport_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFExtendedDRMTypeSupport_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFExtendedDRMTypeSupport_Vtbl {
        unsafe extern "system" fn IsTypeSupportedEx<Impl: IMFExtendedDRMTypeSupport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, r#type: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, keysystem: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, panswer: *mut MF_MEDIA_ENGINE_CANPLAY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTypeSupportedEx(::core::mem::transmute_copy(&r#type), ::core::mem::transmute_copy(&keysystem)) {
                ::core::result::Result::Ok(ok__) => {
                    *panswer = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), IsTypeSupportedEx: IsTypeSupportedEx::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFExtendedDRMTypeSupport as ::windows::core::Interface>::IID
    }
}
pub trait IMFFieldOfUseMFTUnlock_Impl: Sized {
    fn Unlock(&mut self, punkmft: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
}
impl IMFFieldOfUseMFTUnlock_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFFieldOfUseMFTUnlock_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFFieldOfUseMFTUnlock_Vtbl {
        unsafe extern "system" fn Unlock<Impl: IMFFieldOfUseMFTUnlock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, punkmft: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Unlock(::core::mem::transmute(&punkmft)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Unlock: Unlock::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFFieldOfUseMFTUnlock as ::windows::core::Interface>::IID
    }
}
pub trait IMFFinalizableMediaSink_Impl: Sized + IMFMediaSink_Impl {
    fn BeginFinalize(&mut self, pcallback: ::core::option::Option<IMFAsyncCallback>, punkstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndFinalize(&mut self, presult: ::core::option::Option<IMFAsyncResult>) -> ::windows::core::Result<()>;
}
impl IMFFinalizableMediaSink_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFFinalizableMediaSink_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFFinalizableMediaSink_Vtbl {
        unsafe extern "system" fn BeginFinalize<Impl: IMFFinalizableMediaSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginFinalize(::core::mem::transmute(&pcallback), ::core::mem::transmute(&punkstate)).into()
        }
        unsafe extern "system" fn EndFinalize<Impl: IMFFinalizableMediaSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndFinalize(::core::mem::transmute(&presult)).into()
        }
        Self {
            base: IMFMediaSink_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            BeginFinalize: BeginFinalize::<Impl, IMPL_OFFSET>,
            EndFinalize: EndFinalize::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFFinalizableMediaSink as ::windows::core::Interface>::IID
    }
}
pub trait IMFGetService_Impl: Sized {
    fn GetService(&mut self, guidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
impl IMFGetService_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFGetService_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFGetService_Vtbl {
        unsafe extern "system" fn GetService<Impl: IMFGetService_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetService(::core::mem::transmute_copy(&guidservice), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvobject)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetService: GetService::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFGetService as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFHDCPStatus_Impl: Sized {
    fn Query(&mut self, pstatus: *mut MF_HDCP_STATUS, pfstatus: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn Set(&mut self, status: MF_HDCP_STATUS) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFHDCPStatus_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFHDCPStatus_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFHDCPStatus_Vtbl {
        unsafe extern "system" fn Query<Impl: IMFHDCPStatus_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstatus: *mut MF_HDCP_STATUS, pfstatus: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Query(::core::mem::transmute_copy(&pstatus), ::core::mem::transmute_copy(&pfstatus)).into()
        }
        unsafe extern "system" fn Set<Impl: IMFHDCPStatus_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, status: MF_HDCP_STATUS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Set(::core::mem::transmute_copy(&status)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Query: Query::<Impl, IMPL_OFFSET>, Set: Set::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFHDCPStatus as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFHttpDownloadRequest_Impl: Sized {
    fn AddHeader(&mut self, szheader: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn BeginSendRequest(&mut self, pbpayload: *const u8, cbpayload: u32, pcallback: ::core::option::Option<IMFAsyncCallback>, punkstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndSendRequest(&mut self, presult: ::core::option::Option<IMFAsyncResult>) -> ::windows::core::Result<()>;
    fn BeginReceiveResponse(&mut self, pcallback: ::core::option::Option<IMFAsyncCallback>, punkstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndReceiveResponse(&mut self, presult: ::core::option::Option<IMFAsyncResult>) -> ::windows::core::Result<()>;
    fn BeginReadPayload(&mut self, pb: *mut u8, cb: u32, pcallback: ::core::option::Option<IMFAsyncCallback>, punkstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndReadPayload(&mut self, presult: ::core::option::Option<IMFAsyncResult>, pqwoffset: *mut u64, pcbread: *mut u32) -> ::windows::core::Result<()>;
    fn QueryHeader(&mut self, szheadername: super::super::Foundation::PWSTR, dwindex: u32) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
    fn GetURL(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
    fn HasNullSourceOrigin(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetTimeSeekResult(&mut self, pqwstarttime: *mut u64, pqwstoptime: *mut u64, pqwduration: *mut u64) -> ::windows::core::Result<()>;
    fn GetHttpStatus(&mut self) -> ::windows::core::Result<u32>;
    fn GetAtEndOfPayload(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetTotalLength(&mut self) -> ::windows::core::Result<u64>;
    fn GetRangeEndOffset(&mut self) -> ::windows::core::Result<u64>;
    fn Close(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFHttpDownloadRequest_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFHttpDownloadRequest_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFHttpDownloadRequest_Vtbl {
        unsafe extern "system" fn AddHeader<Impl: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, szheader: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddHeader(::core::mem::transmute_copy(&szheader)).into()
        }
        unsafe extern "system" fn BeginSendRequest<Impl: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbpayload: *const u8, cbpayload: u32, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginSendRequest(::core::mem::transmute_copy(&pbpayload), ::core::mem::transmute_copy(&cbpayload), ::core::mem::transmute(&pcallback), ::core::mem::transmute(&punkstate)).into()
        }
        unsafe extern "system" fn EndSendRequest<Impl: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndSendRequest(::core::mem::transmute(&presult)).into()
        }
        unsafe extern "system" fn BeginReceiveResponse<Impl: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginReceiveResponse(::core::mem::transmute(&pcallback), ::core::mem::transmute(&punkstate)).into()
        }
        unsafe extern "system" fn EndReceiveResponse<Impl: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndReceiveResponse(::core::mem::transmute(&presult)).into()
        }
        unsafe extern "system" fn BeginReadPayload<Impl: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pb: *mut u8, cb: u32, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginReadPayload(::core::mem::transmute_copy(&pb), ::core::mem::transmute_copy(&cb), ::core::mem::transmute(&pcallback), ::core::mem::transmute(&punkstate)).into()
        }
        unsafe extern "system" fn EndReadPayload<Impl: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, pqwoffset: *mut u64, pcbread: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndReadPayload(::core::mem::transmute(&presult), ::core::mem::transmute_copy(&pqwoffset), ::core::mem::transmute_copy(&pcbread)).into()
        }
        unsafe extern "system" fn QueryHeader<Impl: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, szheadername: super::super::Foundation::PWSTR, dwindex: u32, ppszheadervalue: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).QueryHeader(::core::mem::transmute_copy(&szheadername), ::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppszheadervalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetURL<Impl: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppszurl: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetURL() {
                ::core::result::Result::Ok(ok__) => {
                    *ppszurl = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn HasNullSourceOrigin<Impl: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfnullsourceorigin: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).HasNullSourceOrigin() {
                ::core::result::Result::Ok(ok__) => {
                    *pfnullsourceorigin = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTimeSeekResult<Impl: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pqwstarttime: *mut u64, pqwstoptime: *mut u64, pqwduration: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTimeSeekResult(::core::mem::transmute_copy(&pqwstarttime), ::core::mem::transmute_copy(&pqwstoptime), ::core::mem::transmute_copy(&pqwduration)).into()
        }
        unsafe extern "system" fn GetHttpStatus<Impl: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwhttpstatus: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetHttpStatus() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwhttpstatus = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAtEndOfPayload<Impl: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfatendofpayload: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAtEndOfPayload() {
                ::core::result::Result::Ok(ok__) => {
                    *pfatendofpayload = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTotalLength<Impl: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pqwtotallength: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTotalLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pqwtotallength = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRangeEndOffset<Impl: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pqwrangeend: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRangeEndOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *pqwrangeend = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Close<Impl: IMFHttpDownloadRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Close().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            AddHeader: AddHeader::<Impl, IMPL_OFFSET>,
            BeginSendRequest: BeginSendRequest::<Impl, IMPL_OFFSET>,
            EndSendRequest: EndSendRequest::<Impl, IMPL_OFFSET>,
            BeginReceiveResponse: BeginReceiveResponse::<Impl, IMPL_OFFSET>,
            EndReceiveResponse: EndReceiveResponse::<Impl, IMPL_OFFSET>,
            BeginReadPayload: BeginReadPayload::<Impl, IMPL_OFFSET>,
            EndReadPayload: EndReadPayload::<Impl, IMPL_OFFSET>,
            QueryHeader: QueryHeader::<Impl, IMPL_OFFSET>,
            GetURL: GetURL::<Impl, IMPL_OFFSET>,
            HasNullSourceOrigin: HasNullSourceOrigin::<Impl, IMPL_OFFSET>,
            GetTimeSeekResult: GetTimeSeekResult::<Impl, IMPL_OFFSET>,
            GetHttpStatus: GetHttpStatus::<Impl, IMPL_OFFSET>,
            GetAtEndOfPayload: GetAtEndOfPayload::<Impl, IMPL_OFFSET>,
            GetTotalLength: GetTotalLength::<Impl, IMPL_OFFSET>,
            GetRangeEndOffset: GetRangeEndOffset::<Impl, IMPL_OFFSET>,
            Close: Close::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFHttpDownloadRequest as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFHttpDownloadSession_Impl: Sized {
    fn SetServer(&mut self, szservername: super::super::Foundation::PWSTR, nport: u32) -> ::windows::core::Result<()>;
    fn CreateRequest(&mut self, szobjectname: super::super::Foundation::PWSTR, fbypassproxycache: super::super::Foundation::BOOL, fsecure: super::super::Foundation::BOOL, szverb: super::super::Foundation::PWSTR, szreferrer: super::super::Foundation::PWSTR) -> ::windows::core::Result<IMFHttpDownloadRequest>;
    fn Close(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFHttpDownloadSession_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFHttpDownloadSession_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFHttpDownloadSession_Vtbl {
        unsafe extern "system" fn SetServer<Impl: IMFHttpDownloadSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, szservername: super::super::Foundation::PWSTR, nport: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetServer(::core::mem::transmute_copy(&szservername), ::core::mem::transmute_copy(&nport)).into()
        }
        unsafe extern "system" fn CreateRequest<Impl: IMFHttpDownloadSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, szobjectname: super::super::Foundation::PWSTR, fbypassproxycache: super::super::Foundation::BOOL, fsecure: super::super::Foundation::BOOL, szverb: super::super::Foundation::PWSTR, szreferrer: super::super::Foundation::PWSTR, pprequest: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateRequest(::core::mem::transmute_copy(&szobjectname), ::core::mem::transmute_copy(&fbypassproxycache), ::core::mem::transmute_copy(&fsecure), ::core::mem::transmute_copy(&szverb), ::core::mem::transmute_copy(&szreferrer)) {
                ::core::result::Result::Ok(ok__) => {
                    *pprequest = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Close<Impl: IMFHttpDownloadSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Close().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetServer: SetServer::<Impl, IMPL_OFFSET>,
            CreateRequest: CreateRequest::<Impl, IMPL_OFFSET>,
            Close: Close::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFHttpDownloadSession as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFHttpDownloadSessionProvider_Impl: Sized {
    fn CreateHttpDownloadSession(&mut self, wszscheme: super::super::Foundation::PWSTR) -> ::windows::core::Result<IMFHttpDownloadSession>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFHttpDownloadSessionProvider_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFHttpDownloadSessionProvider_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFHttpDownloadSessionProvider_Vtbl {
        unsafe extern "system" fn CreateHttpDownloadSession<Impl: IMFHttpDownloadSessionProvider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wszscheme: super::super::Foundation::PWSTR, ppdownloadsession: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateHttpDownloadSession(::core::mem::transmute_copy(&wszscheme)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdownloadsession = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), CreateHttpDownloadSession: CreateHttpDownloadSession::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFHttpDownloadSessionProvider as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFImageSharingEngine_Impl: Sized {
    fn SetSource(&mut self, pstream: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn GetDevice(&mut self) -> ::windows::core::Result<DEVICE_INFO>;
    fn Shutdown(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFImageSharingEngine_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFImageSharingEngine_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFImageSharingEngine_Vtbl {
        unsafe extern "system" fn SetSource<Impl: IMFImageSharingEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstream: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSource(::core::mem::transmute(&pstream)).into()
        }
        unsafe extern "system" fn GetDevice<Impl: IMFImageSharingEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdevice: *mut DEVICE_INFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDevice() {
                ::core::result::Result::Ok(ok__) => {
                    *pdevice = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Shutdown<Impl: IMFImageSharingEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Shutdown().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetSource: SetSource::<Impl, IMPL_OFFSET>,
            GetDevice: GetDevice::<Impl, IMPL_OFFSET>,
            Shutdown: Shutdown::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFImageSharingEngine as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFImageSharingEngineClassFactory_Impl: Sized {
    fn CreateInstanceFromUDN(&mut self, puniquedevicename: super::super::Foundation::BSTR) -> ::windows::core::Result<IMFImageSharingEngine>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFImageSharingEngineClassFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFImageSharingEngineClassFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFImageSharingEngineClassFactory_Vtbl {
        unsafe extern "system" fn CreateInstanceFromUDN<Impl: IMFImageSharingEngineClassFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, puniquedevicename: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, ppengine: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstanceFromUDN(::core::mem::transmute_copy(&puniquedevicename)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppengine = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), CreateInstanceFromUDN: CreateInstanceFromUDN::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFImageSharingEngineClassFactory as ::windows::core::Interface>::IID
    }
}
pub trait IMFInputTrustAuthority_Impl: Sized {
    fn GetDecrypter(&mut self, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn RequestAccess(&mut self, action: MFPOLICYMANAGER_ACTION) -> ::windows::core::Result<IMFActivate>;
    fn GetPolicy(&mut self, action: MFPOLICYMANAGER_ACTION) -> ::windows::core::Result<IMFOutputPolicy>;
    fn BindAccess(&mut self, pparam: *const MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS) -> ::windows::core::Result<()>;
    fn UpdateAccess(&mut self, pparam: *const MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS) -> ::windows::core::Result<()>;
    fn Reset(&mut self) -> ::windows::core::Result<()>;
}
impl IMFInputTrustAuthority_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFInputTrustAuthority_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFInputTrustAuthority_Vtbl {
        unsafe extern "system" fn GetDecrypter<Impl: IMFInputTrustAuthority_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDecrypter(::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppv)).into()
        }
        unsafe extern "system" fn RequestAccess<Impl: IMFInputTrustAuthority_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, action: MFPOLICYMANAGER_ACTION, ppcontentenableractivate: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).RequestAccess(::core::mem::transmute_copy(&action)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcontentenableractivate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPolicy<Impl: IMFInputTrustAuthority_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, action: MFPOLICYMANAGER_ACTION, pppolicy: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPolicy(::core::mem::transmute_copy(&action)) {
                ::core::result::Result::Ok(ok__) => {
                    *pppolicy = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BindAccess<Impl: IMFInputTrustAuthority_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pparam: *const MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BindAccess(::core::mem::transmute_copy(&pparam)).into()
        }
        unsafe extern "system" fn UpdateAccess<Impl: IMFInputTrustAuthority_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pparam: *const MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UpdateAccess(::core::mem::transmute_copy(&pparam)).into()
        }
        unsafe extern "system" fn Reset<Impl: IMFInputTrustAuthority_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reset().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetDecrypter: GetDecrypter::<Impl, IMPL_OFFSET>,
            RequestAccess: RequestAccess::<Impl, IMPL_OFFSET>,
            GetPolicy: GetPolicy::<Impl, IMPL_OFFSET>,
            BindAccess: BindAccess::<Impl, IMPL_OFFSET>,
            UpdateAccess: UpdateAccess::<Impl, IMPL_OFFSET>,
            Reset: Reset::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFInputTrustAuthority as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFLocalMFTRegistration_Impl: Sized {
    fn RegisterMFTs(&mut self, pmfts: *const MFT_REGISTRATION_INFO, cmfts: u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFLocalMFTRegistration_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFLocalMFTRegistration_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFLocalMFTRegistration_Vtbl {
        unsafe extern "system" fn RegisterMFTs<Impl: IMFLocalMFTRegistration_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmfts: *const MFT_REGISTRATION_INFO, cmfts: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterMFTs(::core::mem::transmute_copy(&pmfts), ::core::mem::transmute_copy(&cmfts)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), RegisterMFTs: RegisterMFTs::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFLocalMFTRegistration as ::windows::core::Interface>::IID
    }
}
pub trait IMFMediaBuffer_Impl: Sized {
    fn Lock(&mut self, ppbbuffer: *mut *mut u8, pcbmaxlength: *mut u32, pcbcurrentlength: *mut u32) -> ::windows::core::Result<()>;
    fn Unlock(&mut self) -> ::windows::core::Result<()>;
    fn GetCurrentLength(&mut self) -> ::windows::core::Result<u32>;
    fn SetCurrentLength(&mut self, cbcurrentlength: u32) -> ::windows::core::Result<()>;
    fn GetMaxLength(&mut self) -> ::windows::core::Result<u32>;
}
impl IMFMediaBuffer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaBuffer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaBuffer_Vtbl {
        unsafe extern "system" fn Lock<Impl: IMFMediaBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppbbuffer: *mut *mut u8, pcbmaxlength: *mut u32, pcbcurrentlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Lock(::core::mem::transmute_copy(&ppbbuffer), ::core::mem::transmute_copy(&pcbmaxlength), ::core::mem::transmute_copy(&pcbcurrentlength)).into()
        }
        unsafe extern "system" fn Unlock<Impl: IMFMediaBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Unlock().into()
        }
        unsafe extern "system" fn GetCurrentLength<Impl: IMFMediaBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcbcurrentlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pcbcurrentlength = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentLength<Impl: IMFMediaBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cbcurrentlength: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCurrentLength(::core::mem::transmute_copy(&cbcurrentlength)).into()
        }
        unsafe extern "system" fn GetMaxLength<Impl: IMFMediaBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcbmaxlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMaxLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pcbmaxlength = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Lock: Lock::<Impl, IMPL_OFFSET>,
            Unlock: Unlock::<Impl, IMPL_OFFSET>,
            GetCurrentLength: GetCurrentLength::<Impl, IMPL_OFFSET>,
            SetCurrentLength: SetCurrentLength::<Impl, IMPL_OFFSET>,
            GetMaxLength: GetMaxLength::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaBuffer as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFMediaEngine_Impl: Sized {
    fn GetError(&mut self) -> ::windows::core::Result<IMFMediaError>;
    fn SetErrorCode(&mut self, error: MF_MEDIA_ENGINE_ERR) -> ::windows::core::Result<()>;
    fn SetSourceElements(&mut self, psrcelements: ::core::option::Option<IMFMediaEngineSrcElements>) -> ::windows::core::Result<()>;
    fn SetSource(&mut self, purl: super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn GetCurrentSource(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn GetNetworkState(&mut self) -> u16;
    fn GetPreload(&mut self) -> MF_MEDIA_ENGINE_PRELOAD;
    fn SetPreload(&mut self, preload: MF_MEDIA_ENGINE_PRELOAD) -> ::windows::core::Result<()>;
    fn GetBuffered(&mut self) -> ::windows::core::Result<IMFMediaTimeRange>;
    fn Load(&mut self) -> ::windows::core::Result<()>;
    fn CanPlayType(&mut self, r#type: super::super::Foundation::BSTR) -> ::windows::core::Result<MF_MEDIA_ENGINE_CANPLAY>;
    fn GetReadyState(&mut self) -> u16;
    fn IsSeeking(&mut self) -> super::super::Foundation::BOOL;
    fn GetCurrentTime(&mut self) -> f64;
    fn SetCurrentTime(&mut self, seektime: f64) -> ::windows::core::Result<()>;
    fn GetStartTime(&mut self) -> f64;
    fn GetDuration(&mut self) -> f64;
    fn IsPaused(&mut self) -> super::super::Foundation::BOOL;
    fn GetDefaultPlaybackRate(&mut self) -> f64;
    fn SetDefaultPlaybackRate(&mut self, rate: f64) -> ::windows::core::Result<()>;
    fn GetPlaybackRate(&mut self) -> f64;
    fn SetPlaybackRate(&mut self, rate: f64) -> ::windows::core::Result<()>;
    fn GetPlayed(&mut self) -> ::windows::core::Result<IMFMediaTimeRange>;
    fn GetSeekable(&mut self) -> ::windows::core::Result<IMFMediaTimeRange>;
    fn IsEnded(&mut self) -> super::super::Foundation::BOOL;
    fn GetAutoPlay(&mut self) -> super::super::Foundation::BOOL;
    fn SetAutoPlay(&mut self, autoplay: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetLoop(&mut self) -> super::super::Foundation::BOOL;
    fn SetLoop(&mut self, r#loop: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn Play(&mut self) -> ::windows::core::Result<()>;
    fn Pause(&mut self) -> ::windows::core::Result<()>;
    fn GetMuted(&mut self) -> super::super::Foundation::BOOL;
    fn SetMuted(&mut self, muted: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetVolume(&mut self) -> f64;
    fn SetVolume(&mut self, volume: f64) -> ::windows::core::Result<()>;
    fn HasVideo(&mut self) -> super::super::Foundation::BOOL;
    fn HasAudio(&mut self) -> super::super::Foundation::BOOL;
    fn GetNativeVideoSize(&mut self, cx: *mut u32, cy: *mut u32) -> ::windows::core::Result<()>;
    fn GetVideoAspectRatio(&mut self, cx: *mut u32, cy: *mut u32) -> ::windows::core::Result<()>;
    fn Shutdown(&mut self) -> ::windows::core::Result<()>;
    fn TransferVideoFrame(&mut self, pdstsurf: ::core::option::Option<::windows::core::IUnknown>, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const MFARGB) -> ::windows::core::Result<()>;
    fn OnVideoStreamTick(&mut self) -> ::windows::core::Result<i64>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFMediaEngine_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaEngine_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaEngine_Vtbl {
        unsafe extern "system" fn GetError<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pperror: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetError() {
                ::core::result::Result::Ok(ok__) => {
                    *pperror = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetErrorCode<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, error: MF_MEDIA_ENGINE_ERR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetErrorCode(::core::mem::transmute_copy(&error)).into()
        }
        unsafe extern "system" fn SetSourceElements<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psrcelements: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSourceElements(::core::mem::transmute(&psrcelements)).into()
        }
        unsafe extern "system" fn SetSource<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, purl: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSource(::core::mem::transmute_copy(&purl)).into()
        }
        unsafe extern "system" fn GetCurrentSource<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppurl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentSource() {
                ::core::result::Result::Ok(ok__) => {
                    *ppurl = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNetworkState<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u16 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNetworkState()
        }
        unsafe extern "system" fn GetPreload<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> MF_MEDIA_ENGINE_PRELOAD {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPreload()
        }
        unsafe extern "system" fn SetPreload<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, preload: MF_MEDIA_ENGINE_PRELOAD) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPreload(::core::mem::transmute_copy(&preload)).into()
        }
        unsafe extern "system" fn GetBuffered<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppbuffered: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBuffered() {
                ::core::result::Result::Ok(ok__) => {
                    *ppbuffered = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Load<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Load().into()
        }
        unsafe extern "system" fn CanPlayType<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, r#type: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, panswer: *mut MF_MEDIA_ENGINE_CANPLAY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanPlayType(::core::mem::transmute_copy(&r#type)) {
                ::core::result::Result::Ok(ok__) => {
                    *panswer = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetReadyState<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u16 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetReadyState()
        }
        unsafe extern "system" fn IsSeeking<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsSeeking()
        }
        unsafe extern "system" fn GetCurrentTime<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrentTime()
        }
        unsafe extern "system" fn SetCurrentTime<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, seektime: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCurrentTime(::core::mem::transmute_copy(&seektime)).into()
        }
        unsafe extern "system" fn GetStartTime<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetStartTime()
        }
        unsafe extern "system" fn GetDuration<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDuration()
        }
        unsafe extern "system" fn IsPaused<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsPaused()
        }
        unsafe extern "system" fn GetDefaultPlaybackRate<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDefaultPlaybackRate()
        }
        unsafe extern "system" fn SetDefaultPlaybackRate<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rate: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultPlaybackRate(::core::mem::transmute_copy(&rate)).into()
        }
        unsafe extern "system" fn GetPlaybackRate<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPlaybackRate()
        }
        unsafe extern "system" fn SetPlaybackRate<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rate: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPlaybackRate(::core::mem::transmute_copy(&rate)).into()
        }
        unsafe extern "system" fn GetPlayed<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppplayed: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPlayed() {
                ::core::result::Result::Ok(ok__) => {
                    *ppplayed = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSeekable<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppseekable: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSeekable() {
                ::core::result::Result::Ok(ok__) => {
                    *ppseekable = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsEnded<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsEnded()
        }
        unsafe extern "system" fn GetAutoPlay<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAutoPlay()
        }
        unsafe extern "system" fn SetAutoPlay<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, autoplay: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAutoPlay(::core::mem::transmute_copy(&autoplay)).into()
        }
        unsafe extern "system" fn GetLoop<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLoop()
        }
        unsafe extern "system" fn SetLoop<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, r#loop: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLoop(::core::mem::transmute_copy(&r#loop)).into()
        }
        unsafe extern "system" fn Play<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Play().into()
        }
        unsafe extern "system" fn Pause<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Pause().into()
        }
        unsafe extern "system" fn GetMuted<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetMuted()
        }
        unsafe extern "system" fn SetMuted<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, muted: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMuted(::core::mem::transmute_copy(&muted)).into()
        }
        unsafe extern "system" fn GetVolume<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVolume()
        }
        unsafe extern "system" fn SetVolume<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, volume: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVolume(::core::mem::transmute_copy(&volume)).into()
        }
        unsafe extern "system" fn HasVideo<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).HasVideo()
        }
        unsafe extern "system" fn HasAudio<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).HasAudio()
        }
        unsafe extern "system" fn GetNativeVideoSize<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cx: *mut u32, cy: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNativeVideoSize(::core::mem::transmute_copy(&cx), ::core::mem::transmute_copy(&cy)).into()
        }
        unsafe extern "system" fn GetVideoAspectRatio<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cx: *mut u32, cy: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoAspectRatio(::core::mem::transmute_copy(&cx), ::core::mem::transmute_copy(&cy)).into()
        }
        unsafe extern "system" fn Shutdown<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Shutdown().into()
        }
        unsafe extern "system" fn TransferVideoFrame<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdstsurf: *mut ::core::ffi::c_void, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const MFARGB) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TransferVideoFrame(::core::mem::transmute(&pdstsurf), ::core::mem::transmute_copy(&psrc), ::core::mem::transmute_copy(&pdst), ::core::mem::transmute_copy(&pborderclr)).into()
        }
        unsafe extern "system" fn OnVideoStreamTick<Impl: IMFMediaEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppts: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OnVideoStreamTick() {
                ::core::result::Result::Ok(ok__) => {
                    *ppts = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetError: GetError::<Impl, IMPL_OFFSET>,
            SetErrorCode: SetErrorCode::<Impl, IMPL_OFFSET>,
            SetSourceElements: SetSourceElements::<Impl, IMPL_OFFSET>,
            SetSource: SetSource::<Impl, IMPL_OFFSET>,
            GetCurrentSource: GetCurrentSource::<Impl, IMPL_OFFSET>,
            GetNetworkState: GetNetworkState::<Impl, IMPL_OFFSET>,
            GetPreload: GetPreload::<Impl, IMPL_OFFSET>,
            SetPreload: SetPreload::<Impl, IMPL_OFFSET>,
            GetBuffered: GetBuffered::<Impl, IMPL_OFFSET>,
            Load: Load::<Impl, IMPL_OFFSET>,
            CanPlayType: CanPlayType::<Impl, IMPL_OFFSET>,
            GetReadyState: GetReadyState::<Impl, IMPL_OFFSET>,
            IsSeeking: IsSeeking::<Impl, IMPL_OFFSET>,
            GetCurrentTime: GetCurrentTime::<Impl, IMPL_OFFSET>,
            SetCurrentTime: SetCurrentTime::<Impl, IMPL_OFFSET>,
            GetStartTime: GetStartTime::<Impl, IMPL_OFFSET>,
            GetDuration: GetDuration::<Impl, IMPL_OFFSET>,
            IsPaused: IsPaused::<Impl, IMPL_OFFSET>,
            GetDefaultPlaybackRate: GetDefaultPlaybackRate::<Impl, IMPL_OFFSET>,
            SetDefaultPlaybackRate: SetDefaultPlaybackRate::<Impl, IMPL_OFFSET>,
            GetPlaybackRate: GetPlaybackRate::<Impl, IMPL_OFFSET>,
            SetPlaybackRate: SetPlaybackRate::<Impl, IMPL_OFFSET>,
            GetPlayed: GetPlayed::<Impl, IMPL_OFFSET>,
            GetSeekable: GetSeekable::<Impl, IMPL_OFFSET>,
            IsEnded: IsEnded::<Impl, IMPL_OFFSET>,
            GetAutoPlay: GetAutoPlay::<Impl, IMPL_OFFSET>,
            SetAutoPlay: SetAutoPlay::<Impl, IMPL_OFFSET>,
            GetLoop: GetLoop::<Impl, IMPL_OFFSET>,
            SetLoop: SetLoop::<Impl, IMPL_OFFSET>,
            Play: Play::<Impl, IMPL_OFFSET>,
            Pause: Pause::<Impl, IMPL_OFFSET>,
            GetMuted: GetMuted::<Impl, IMPL_OFFSET>,
            SetMuted: SetMuted::<Impl, IMPL_OFFSET>,
            GetVolume: GetVolume::<Impl, IMPL_OFFSET>,
            SetVolume: SetVolume::<Impl, IMPL_OFFSET>,
            HasVideo: HasVideo::<Impl, IMPL_OFFSET>,
            HasAudio: HasAudio::<Impl, IMPL_OFFSET>,
            GetNativeVideoSize: GetNativeVideoSize::<Impl, IMPL_OFFSET>,
            GetVideoAspectRatio: GetVideoAspectRatio::<Impl, IMPL_OFFSET>,
            Shutdown: Shutdown::<Impl, IMPL_OFFSET>,
            TransferVideoFrame: TransferVideoFrame::<Impl, IMPL_OFFSET>,
            OnVideoStreamTick: OnVideoStreamTick::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaEngine as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFMediaEngineAudioEndpointId_Impl: Sized {
    fn SetAudioEndpointId(&mut self, pszendpointid: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn GetAudioEndpointId(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFMediaEngineAudioEndpointId_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaEngineAudioEndpointId_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaEngineAudioEndpointId_Vtbl {
        unsafe extern "system" fn SetAudioEndpointId<Impl: IMFMediaEngineAudioEndpointId_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszendpointid: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAudioEndpointId(::core::mem::transmute_copy(&pszendpointid)).into()
        }
        unsafe extern "system" fn GetAudioEndpointId<Impl: IMFMediaEngineAudioEndpointId_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppszendpointid: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAudioEndpointId() {
                ::core::result::Result::Ok(ok__) => {
                    *ppszendpointid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetAudioEndpointId: SetAudioEndpointId::<Impl, IMPL_OFFSET>,
            GetAudioEndpointId: GetAudioEndpointId::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaEngineAudioEndpointId as ::windows::core::Interface>::IID
    }
}
pub trait IMFMediaEngineClassFactory_Impl: Sized {
    fn CreateInstance(&mut self, dwflags: u32, pattr: ::core::option::Option<IMFAttributes>) -> ::windows::core::Result<IMFMediaEngine>;
    fn CreateTimeRange(&mut self) -> ::windows::core::Result<IMFMediaTimeRange>;
    fn CreateError(&mut self) -> ::windows::core::Result<IMFMediaError>;
}
impl IMFMediaEngineClassFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaEngineClassFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaEngineClassFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMFMediaEngineClassFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32, pattr: ::windows::core::RawPtr, ppplayer: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(::core::mem::transmute_copy(&dwflags), ::core::mem::transmute(&pattr)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppplayer = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateTimeRange<Impl: IMFMediaEngineClassFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pptimerange: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateTimeRange() {
                ::core::result::Result::Ok(ok__) => {
                    *pptimerange = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateError<Impl: IMFMediaEngineClassFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pperror: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateError() {
                ::core::result::Result::Ok(ok__) => {
                    *pperror = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            CreateInstance: CreateInstance::<Impl, IMPL_OFFSET>,
            CreateTimeRange: CreateTimeRange::<Impl, IMPL_OFFSET>,
            CreateError: CreateError::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaEngineClassFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFMediaEngineClassFactory2_Impl: Sized {
    fn CreateMediaKeys2(&mut self, keysystem: super::super::Foundation::BSTR, defaultcdmstorepath: super::super::Foundation::BSTR, inprivatecdmstorepath: super::super::Foundation::BSTR) -> ::windows::core::Result<IMFMediaKeys>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFMediaEngineClassFactory2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaEngineClassFactory2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaEngineClassFactory2_Vtbl {
        unsafe extern "system" fn CreateMediaKeys2<Impl: IMFMediaEngineClassFactory2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, keysystem: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, defaultcdmstorepath: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, inprivatecdmstorepath: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, ppkeys: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateMediaKeys2(::core::mem::transmute_copy(&keysystem), ::core::mem::transmute_copy(&defaultcdmstorepath), ::core::mem::transmute_copy(&inprivatecdmstorepath)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppkeys = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), CreateMediaKeys2: CreateMediaKeys2::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaEngineClassFactory2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_Shell_PropertiesSystem"))]
pub trait IMFMediaEngineClassFactory3_Impl: Sized {
    fn CreateMediaKeySystemAccess(&mut self, keysystem: super::super::Foundation::BSTR, ppsupportedconfigurationsarray: *const ::core::option::Option<super::super::UI::Shell::PropertiesSystem::IPropertyStore>, usize: u32) -> ::windows::core::Result<IMFMediaKeySystemAccess>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_Shell_PropertiesSystem"))]
impl IMFMediaEngineClassFactory3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaEngineClassFactory3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaEngineClassFactory3_Vtbl {
        unsafe extern "system" fn CreateMediaKeySystemAccess<Impl: IMFMediaEngineClassFactory3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, keysystem: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, ppsupportedconfigurationsarray: *const ::windows::core::RawPtr, usize: u32, ppkeyaccess: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateMediaKeySystemAccess(::core::mem::transmute_copy(&keysystem), ::core::mem::transmute_copy(&ppsupportedconfigurationsarray), ::core::mem::transmute_copy(&usize)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppkeyaccess = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), CreateMediaKeySystemAccess: CreateMediaKeySystemAccess::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaEngineClassFactory3 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFMediaEngineClassFactory4_Impl: Sized {
    fn CreateContentDecryptionModuleFactory(&mut self, keysystem: super::super::Foundation::PWSTR, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFMediaEngineClassFactory4_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaEngineClassFactory4_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaEngineClassFactory4_Vtbl {
        unsafe extern "system" fn CreateContentDecryptionModuleFactory<Impl: IMFMediaEngineClassFactory4_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, keysystem: super::super::Foundation::PWSTR, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateContentDecryptionModuleFactory(::core::mem::transmute_copy(&keysystem), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvobject)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            CreateContentDecryptionModuleFactory: CreateContentDecryptionModuleFactory::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaEngineClassFactory4 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFMediaEngineClassFactoryEx_Impl: Sized + IMFMediaEngineClassFactory_Impl {
    fn CreateMediaSourceExtension(&mut self, dwflags: u32, pattr: ::core::option::Option<IMFAttributes>) -> ::windows::core::Result<IMFMediaSourceExtension>;
    fn CreateMediaKeys(&mut self, keysystem: super::super::Foundation::BSTR, cdmstorepath: super::super::Foundation::BSTR) -> ::windows::core::Result<IMFMediaKeys>;
    fn IsTypeSupported(&mut self, r#type: super::super::Foundation::BSTR, keysystem: super::super::Foundation::BSTR) -> ::windows::core::Result<super::super::Foundation::BOOL>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFMediaEngineClassFactoryEx_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaEngineClassFactoryEx_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaEngineClassFactoryEx_Vtbl {
        unsafe extern "system" fn CreateMediaSourceExtension<Impl: IMFMediaEngineClassFactoryEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32, pattr: ::windows::core::RawPtr, ppmse: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateMediaSourceExtension(::core::mem::transmute_copy(&dwflags), ::core::mem::transmute(&pattr)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppmse = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateMediaKeys<Impl: IMFMediaEngineClassFactoryEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, keysystem: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, cdmstorepath: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, ppkeys: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateMediaKeys(::core::mem::transmute_copy(&keysystem), ::core::mem::transmute_copy(&cdmstorepath)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppkeys = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTypeSupported<Impl: IMFMediaEngineClassFactoryEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, r#type: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, keysystem: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, issupported: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTypeSupported(::core::mem::transmute_copy(&r#type), ::core::mem::transmute_copy(&keysystem)) {
                ::core::result::Result::Ok(ok__) => {
                    *issupported = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMFMediaEngineClassFactory_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            CreateMediaSourceExtension: CreateMediaSourceExtension::<Impl, IMPL_OFFSET>,
            CreateMediaKeys: CreateMediaKeys::<Impl, IMPL_OFFSET>,
            IsTypeSupported: IsTypeSupported::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaEngineClassFactoryEx as ::windows::core::Interface>::IID
    }
}
pub trait IMFMediaEngineEME_Impl: Sized {
    fn Keys(&mut self) -> ::windows::core::Result<IMFMediaKeys>;
    fn SetMediaKeys(&mut self, keys: ::core::option::Option<IMFMediaKeys>) -> ::windows::core::Result<()>;
}
impl IMFMediaEngineEME_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaEngineEME_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaEngineEME_Vtbl {
        unsafe extern "system" fn Keys<Impl: IMFMediaEngineEME_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, keys: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Keys() {
                ::core::result::Result::Ok(ok__) => {
                    *keys = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaKeys<Impl: IMFMediaEngineEME_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, keys: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMediaKeys(::core::mem::transmute(&keys)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Keys: Keys::<Impl, IMPL_OFFSET>,
            SetMediaKeys: SetMediaKeys::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaEngineEME as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFMediaEngineEMENotify_Impl: Sized {
    fn Encrypted(&mut self, pbinitdata: *const u8, cb: u32, bstrinitdatatype: super::super::Foundation::BSTR);
    fn WaitingForKey(&mut self);
}
#[cfg(feature = "Win32_Foundation")]
impl IMFMediaEngineEMENotify_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaEngineEMENotify_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaEngineEMENotify_Vtbl {
        unsafe extern "system" fn Encrypted<Impl: IMFMediaEngineEMENotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbinitdata: *const u8, cb: u32, bstrinitdatatype: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Encrypted(::core::mem::transmute_copy(&pbinitdata), ::core::mem::transmute_copy(&cb), ::core::mem::transmute_copy(&bstrinitdatatype))
        }
        unsafe extern "system" fn WaitingForKey<Impl: IMFMediaEngineEMENotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).WaitingForKey()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Encrypted: Encrypted::<Impl, IMPL_OFFSET>,
            WaitingForKey: WaitingForKey::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaEngineEMENotify as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFMediaEngineEx_Impl: Sized + IMFMediaEngine_Impl {
    fn SetSourceFromByteStream(&mut self, pbytestream: ::core::option::Option<IMFByteStream>, purl: super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn GetStatistics(&mut self, statisticid: MF_MEDIA_ENGINE_STATISTIC) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
    fn UpdateVideoStream(&mut self, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const MFARGB) -> ::windows::core::Result<()>;
    fn GetBalance(&mut self) -> f64;
    fn SetBalance(&mut self, balance: f64) -> ::windows::core::Result<()>;
    fn IsPlaybackRateSupported(&mut self, rate: f64) -> super::super::Foundation::BOOL;
    fn FrameStep(&mut self, forward: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetResourceCharacteristics(&mut self) -> ::windows::core::Result<u32>;
    fn GetPresentationAttribute(&mut self, guidmfattribute: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
    fn GetNumberOfStreams(&mut self) -> ::windows::core::Result<u32>;
    fn GetStreamAttribute(&mut self, dwstreamindex: u32, guidmfattribute: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
    fn GetStreamSelection(&mut self, dwstreamindex: u32) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn SetStreamSelection(&mut self, dwstreamindex: u32, enabled: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn ApplyStreamSelections(&mut self) -> ::windows::core::Result<()>;
    fn IsProtected(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn InsertVideoEffect(&mut self, peffect: ::core::option::Option<::windows::core::IUnknown>, foptional: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn InsertAudioEffect(&mut self, peffect: ::core::option::Option<::windows::core::IUnknown>, foptional: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn RemoveAllEffects(&mut self) -> ::windows::core::Result<()>;
    fn SetTimelineMarkerTimer(&mut self, timetofire: f64) -> ::windows::core::Result<()>;
    fn GetTimelineMarkerTimer(&mut self) -> ::windows::core::Result<f64>;
    fn CancelTimelineMarkerTimer(&mut self) -> ::windows::core::Result<()>;
    fn IsStereo3D(&mut self) -> super::super::Foundation::BOOL;
    fn GetStereo3DFramePackingMode(&mut self) -> ::windows::core::Result<MF_MEDIA_ENGINE_S3D_PACKING_MODE>;
    fn SetStereo3DFramePackingMode(&mut self, packmode: MF_MEDIA_ENGINE_S3D_PACKING_MODE) -> ::windows::core::Result<()>;
    fn GetStereo3DRenderMode(&mut self) -> ::windows::core::Result<MF3DVideoOutputType>;
    fn SetStereo3DRenderMode(&mut self, outputtype: MF3DVideoOutputType) -> ::windows::core::Result<()>;
    fn EnableWindowlessSwapchainMode(&mut self, fenable: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetVideoSwapchainHandle(&mut self) -> ::windows::core::Result<super::super::Foundation::HANDLE>;
    fn EnableHorizontalMirrorMode(&mut self, fenable: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetAudioStreamCategory(&mut self) -> ::windows::core::Result<u32>;
    fn SetAudioStreamCategory(&mut self, category: u32) -> ::windows::core::Result<()>;
    fn GetAudioEndpointRole(&mut self) -> ::windows::core::Result<u32>;
    fn SetAudioEndpointRole(&mut self, role: u32) -> ::windows::core::Result<()>;
    fn GetRealTimeMode(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn SetRealTimeMode(&mut self, fenable: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn SetCurrentTimeEx(&mut self, seektime: f64, seekmode: MF_MEDIA_ENGINE_SEEK_MODE) -> ::windows::core::Result<()>;
    fn EnableTimeUpdateTimer(&mut self, fenabletimer: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFMediaEngineEx_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaEngineEx_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaEngineEx_Vtbl {
        unsafe extern "system" fn SetSourceFromByteStream<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbytestream: ::windows::core::RawPtr, purl: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSourceFromByteStream(::core::mem::transmute(&pbytestream), ::core::mem::transmute_copy(&purl)).into()
        }
        unsafe extern "system" fn GetStatistics<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, statisticid: MF_MEDIA_ENGINE_STATISTIC, pstatistic: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStatistics(::core::mem::transmute_copy(&statisticid)) {
                ::core::result::Result::Ok(ok__) => {
                    *pstatistic = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UpdateVideoStream<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const MFARGB) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UpdateVideoStream(::core::mem::transmute_copy(&psrc), ::core::mem::transmute_copy(&pdst), ::core::mem::transmute_copy(&pborderclr)).into()
        }
        unsafe extern "system" fn GetBalance<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetBalance()
        }
        unsafe extern "system" fn SetBalance<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, balance: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBalance(::core::mem::transmute_copy(&balance)).into()
        }
        unsafe extern "system" fn IsPlaybackRateSupported<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rate: f64) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsPlaybackRateSupported(::core::mem::transmute_copy(&rate))
        }
        unsafe extern "system" fn FrameStep<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, forward: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).FrameStep(::core::mem::transmute_copy(&forward)).into()
        }
        unsafe extern "system" fn GetResourceCharacteristics<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcharacteristics: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetResourceCharacteristics() {
                ::core::result::Result::Ok(ok__) => {
                    *pcharacteristics = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPresentationAttribute<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidmfattribute: *const ::windows::core::GUID, pvvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPresentationAttribute(::core::mem::transmute_copy(&guidmfattribute)) {
                ::core::result::Result::Ok(ok__) => {
                    *pvvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNumberOfStreams<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwstreamcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNumberOfStreams() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwstreamcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamAttribute<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, guidmfattribute: *const ::windows::core::GUID, pvvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamAttribute(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&guidmfattribute)) {
                ::core::result::Result::Ok(ok__) => {
                    *pvvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamSelection<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, penabled: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamSelection(::core::mem::transmute_copy(&dwstreamindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *penabled = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamSelection<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, enabled: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStreamSelection(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&enabled)).into()
        }
        unsafe extern "system" fn ApplyStreamSelections<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ApplyStreamSelections().into()
        }
        unsafe extern "system" fn IsProtected<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pprotected: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsProtected() {
                ::core::result::Result::Ok(ok__) => {
                    *pprotected = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InsertVideoEffect<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, peffect: *mut ::core::ffi::c_void, foptional: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InsertVideoEffect(::core::mem::transmute(&peffect), ::core::mem::transmute_copy(&foptional)).into()
        }
        unsafe extern "system" fn InsertAudioEffect<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, peffect: *mut ::core::ffi::c_void, foptional: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InsertAudioEffect(::core::mem::transmute(&peffect), ::core::mem::transmute_copy(&foptional)).into()
        }
        unsafe extern "system" fn RemoveAllEffects<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveAllEffects().into()
        }
        unsafe extern "system" fn SetTimelineMarkerTimer<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, timetofire: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTimelineMarkerTimer(::core::mem::transmute_copy(&timetofire)).into()
        }
        unsafe extern "system" fn GetTimelineMarkerTimer<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptimetofire: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTimelineMarkerTimer() {
                ::core::result::Result::Ok(ok__) => {
                    *ptimetofire = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CancelTimelineMarkerTimer<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CancelTimelineMarkerTimer().into()
        }
        unsafe extern "system" fn IsStereo3D<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsStereo3D()
        }
        unsafe extern "system" fn GetStereo3DFramePackingMode<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, packmode: *mut MF_MEDIA_ENGINE_S3D_PACKING_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStereo3DFramePackingMode() {
                ::core::result::Result::Ok(ok__) => {
                    *packmode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStereo3DFramePackingMode<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, packmode: MF_MEDIA_ENGINE_S3D_PACKING_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStereo3DFramePackingMode(::core::mem::transmute_copy(&packmode)).into()
        }
        unsafe extern "system" fn GetStereo3DRenderMode<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, outputtype: *mut MF3DVideoOutputType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStereo3DRenderMode() {
                ::core::result::Result::Ok(ok__) => {
                    *outputtype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStereo3DRenderMode<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, outputtype: MF3DVideoOutputType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStereo3DRenderMode(::core::mem::transmute_copy(&outputtype)).into()
        }
        unsafe extern "system" fn EnableWindowlessSwapchainMode<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fenable: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EnableWindowlessSwapchainMode(::core::mem::transmute_copy(&fenable)).into()
        }
        unsafe extern "system" fn GetVideoSwapchainHandle<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phswapchain: *mut super::super::Foundation::HANDLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVideoSwapchainHandle() {
                ::core::result::Result::Ok(ok__) => {
                    *phswapchain = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnableHorizontalMirrorMode<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fenable: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EnableHorizontalMirrorMode(::core::mem::transmute_copy(&fenable)).into()
        }
        unsafe extern "system" fn GetAudioStreamCategory<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcategory: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAudioStreamCategory() {
                ::core::result::Result::Ok(ok__) => {
                    *pcategory = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAudioStreamCategory<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, category: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAudioStreamCategory(::core::mem::transmute_copy(&category)).into()
        }
        unsafe extern "system" fn GetAudioEndpointRole<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prole: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAudioEndpointRole() {
                ::core::result::Result::Ok(ok__) => {
                    *prole = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAudioEndpointRole<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, role: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAudioEndpointRole(::core::mem::transmute_copy(&role)).into()
        }
        unsafe extern "system" fn GetRealTimeMode<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfenabled: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRealTimeMode() {
                ::core::result::Result::Ok(ok__) => {
                    *pfenabled = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRealTimeMode<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fenable: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRealTimeMode(::core::mem::transmute_copy(&fenable)).into()
        }
        unsafe extern "system" fn SetCurrentTimeEx<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, seektime: f64, seekmode: MF_MEDIA_ENGINE_SEEK_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCurrentTimeEx(::core::mem::transmute_copy(&seektime), ::core::mem::transmute_copy(&seekmode)).into()
        }
        unsafe extern "system" fn EnableTimeUpdateTimer<Impl: IMFMediaEngineEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fenabletimer: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EnableTimeUpdateTimer(::core::mem::transmute_copy(&fenabletimer)).into()
        }
        Self {
            base: IMFMediaEngine_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetSourceFromByteStream: SetSourceFromByteStream::<Impl, IMPL_OFFSET>,
            GetStatistics: GetStatistics::<Impl, IMPL_OFFSET>,
            UpdateVideoStream: UpdateVideoStream::<Impl, IMPL_OFFSET>,
            GetBalance: GetBalance::<Impl, IMPL_OFFSET>,
            SetBalance: SetBalance::<Impl, IMPL_OFFSET>,
            IsPlaybackRateSupported: IsPlaybackRateSupported::<Impl, IMPL_OFFSET>,
            FrameStep: FrameStep::<Impl, IMPL_OFFSET>,
            GetResourceCharacteristics: GetResourceCharacteristics::<Impl, IMPL_OFFSET>,
            GetPresentationAttribute: GetPresentationAttribute::<Impl, IMPL_OFFSET>,
            GetNumberOfStreams: GetNumberOfStreams::<Impl, IMPL_OFFSET>,
            GetStreamAttribute: GetStreamAttribute::<Impl, IMPL_OFFSET>,
            GetStreamSelection: GetStreamSelection::<Impl, IMPL_OFFSET>,
            SetStreamSelection: SetStreamSelection::<Impl, IMPL_OFFSET>,
            ApplyStreamSelections: ApplyStreamSelections::<Impl, IMPL_OFFSET>,
            IsProtected: IsProtected::<Impl, IMPL_OFFSET>,
            InsertVideoEffect: InsertVideoEffect::<Impl, IMPL_OFFSET>,
            InsertAudioEffect: InsertAudioEffect::<Impl, IMPL_OFFSET>,
            RemoveAllEffects: RemoveAllEffects::<Impl, IMPL_OFFSET>,
            SetTimelineMarkerTimer: SetTimelineMarkerTimer::<Impl, IMPL_OFFSET>,
            GetTimelineMarkerTimer: GetTimelineMarkerTimer::<Impl, IMPL_OFFSET>,
            CancelTimelineMarkerTimer: CancelTimelineMarkerTimer::<Impl, IMPL_OFFSET>,
            IsStereo3D: IsStereo3D::<Impl, IMPL_OFFSET>,
            GetStereo3DFramePackingMode: GetStereo3DFramePackingMode::<Impl, IMPL_OFFSET>,
            SetStereo3DFramePackingMode: SetStereo3DFramePackingMode::<Impl, IMPL_OFFSET>,
            GetStereo3DRenderMode: GetStereo3DRenderMode::<Impl, IMPL_OFFSET>,
            SetStereo3DRenderMode: SetStereo3DRenderMode::<Impl, IMPL_OFFSET>,
            EnableWindowlessSwapchainMode: EnableWindowlessSwapchainMode::<Impl, IMPL_OFFSET>,
            GetVideoSwapchainHandle: GetVideoSwapchainHandle::<Impl, IMPL_OFFSET>,
            EnableHorizontalMirrorMode: EnableHorizontalMirrorMode::<Impl, IMPL_OFFSET>,
            GetAudioStreamCategory: GetAudioStreamCategory::<Impl, IMPL_OFFSET>,
            SetAudioStreamCategory: SetAudioStreamCategory::<Impl, IMPL_OFFSET>,
            GetAudioEndpointRole: GetAudioEndpointRole::<Impl, IMPL_OFFSET>,
            SetAudioEndpointRole: SetAudioEndpointRole::<Impl, IMPL_OFFSET>,
            GetRealTimeMode: GetRealTimeMode::<Impl, IMPL_OFFSET>,
            SetRealTimeMode: SetRealTimeMode::<Impl, IMPL_OFFSET>,
            SetCurrentTimeEx: SetCurrentTimeEx::<Impl, IMPL_OFFSET>,
            EnableTimeUpdateTimer: EnableTimeUpdateTimer::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaEngineEx as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFMediaEngineExtension_Impl: Sized {
    fn CanPlayType(&mut self, audioonly: super::super::Foundation::BOOL, mimetype: super::super::Foundation::BSTR) -> ::windows::core::Result<MF_MEDIA_ENGINE_CANPLAY>;
    fn BeginCreateObject(&mut self, bstrurl: super::super::Foundation::BSTR, pbytestream: ::core::option::Option<IMFByteStream>, r#type: MF_OBJECT_TYPE, ppiunknowncancelcookie: *mut ::core::option::Option<::windows::core::IUnknown>, pcallback: ::core::option::Option<IMFAsyncCallback>, punkstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn CancelObjectCreation(&mut self, piunknowncancelcookie: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndCreateObject(&mut self, presult: ::core::option::Option<IMFAsyncResult>) -> ::windows::core::Result<::windows::core::IUnknown>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFMediaEngineExtension_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaEngineExtension_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaEngineExtension_Vtbl {
        unsafe extern "system" fn CanPlayType<Impl: IMFMediaEngineExtension_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, audioonly: super::super::Foundation::BOOL, mimetype: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, panswer: *mut MF_MEDIA_ENGINE_CANPLAY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CanPlayType(::core::mem::transmute_copy(&audioonly), ::core::mem::transmute_copy(&mimetype)) {
                ::core::result::Result::Ok(ok__) => {
                    *panswer = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginCreateObject<Impl: IMFMediaEngineExtension_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bstrurl: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pbytestream: ::windows::core::RawPtr, r#type: MF_OBJECT_TYPE, ppiunknowncancelcookie: *mut *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginCreateObject(::core::mem::transmute_copy(&bstrurl), ::core::mem::transmute(&pbytestream), ::core::mem::transmute_copy(&r#type), ::core::mem::transmute_copy(&ppiunknowncancelcookie), ::core::mem::transmute(&pcallback), ::core::mem::transmute(&punkstate)).into()
        }
        unsafe extern "system" fn CancelObjectCreation<Impl: IMFMediaEngineExtension_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, piunknowncancelcookie: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CancelObjectCreation(::core::mem::transmute(&piunknowncancelcookie)).into()
        }
        unsafe extern "system" fn EndCreateObject<Impl: IMFMediaEngineExtension_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EndCreateObject(::core::mem::transmute(&presult)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppobject = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            CanPlayType: CanPlayType::<Impl, IMPL_OFFSET>,
            BeginCreateObject: BeginCreateObject::<Impl, IMPL_OFFSET>,
            CancelObjectCreation: CancelObjectCreation::<Impl, IMPL_OFFSET>,
            EndCreateObject: EndCreateObject::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaEngineExtension as ::windows::core::Interface>::IID
    }
}
pub trait IMFMediaEngineNeedKeyNotify_Impl: Sized {
    fn NeedKey(&mut self, initdata: *const u8, cb: u32);
}
impl IMFMediaEngineNeedKeyNotify_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaEngineNeedKeyNotify_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaEngineNeedKeyNotify_Vtbl {
        unsafe extern "system" fn NeedKey<Impl: IMFMediaEngineNeedKeyNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, initdata: *const u8, cb: u32) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NeedKey(::core::mem::transmute_copy(&initdata), ::core::mem::transmute_copy(&cb))
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), NeedKey: NeedKey::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaEngineNeedKeyNotify as ::windows::core::Interface>::IID
    }
}
pub trait IMFMediaEngineNotify_Impl: Sized {
    fn EventNotify(&mut self, event: u32, param1: usize, param2: u32) -> ::windows::core::Result<()>;
}
impl IMFMediaEngineNotify_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaEngineNotify_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaEngineNotify_Vtbl {
        unsafe extern "system" fn EventNotify<Impl: IMFMediaEngineNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, event: u32, param1: usize, param2: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EventNotify(::core::mem::transmute_copy(&event), ::core::mem::transmute_copy(&param1), ::core::mem::transmute_copy(&param2)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), EventNotify: EventNotify::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaEngineNotify as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFMediaEngineOPMInfo_Impl: Sized {
    fn GetOPMInfo(&mut self, pstatus: *mut MF_MEDIA_ENGINE_OPM_STATUS, pconstricted: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFMediaEngineOPMInfo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaEngineOPMInfo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaEngineOPMInfo_Vtbl {
        unsafe extern "system" fn GetOPMInfo<Impl: IMFMediaEngineOPMInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstatus: *mut MF_MEDIA_ENGINE_OPM_STATUS, pconstricted: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetOPMInfo(::core::mem::transmute_copy(&pstatus), ::core::mem::transmute_copy(&pconstricted)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetOPMInfo: GetOPMInfo::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaEngineOPMInfo as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFMediaEngineProtectedContent_Impl: Sized {
    fn ShareResources(&mut self, punkdevicecontext: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn GetRequiredProtections(&mut self) -> ::windows::core::Result<u32>;
    fn SetOPMWindow(&mut self, hwnd: super::super::Foundation::HWND) -> ::windows::core::Result<()>;
    fn TransferVideoFrame(&mut self, pdstsurf: ::core::option::Option<::windows::core::IUnknown>, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const MFARGB) -> ::windows::core::Result<u32>;
    fn SetContentProtectionManager(&mut self, pcpm: ::core::option::Option<IMFContentProtectionManager>) -> ::windows::core::Result<()>;
    fn SetApplicationCertificate(&mut self, pbblob: *const u8, cbblob: u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFMediaEngineProtectedContent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaEngineProtectedContent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaEngineProtectedContent_Vtbl {
        unsafe extern "system" fn ShareResources<Impl: IMFMediaEngineProtectedContent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, punkdevicecontext: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ShareResources(::core::mem::transmute(&punkdevicecontext)).into()
        }
        unsafe extern "system" fn GetRequiredProtections<Impl: IMFMediaEngineProtectedContent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pframeprotectionflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRequiredProtections() {
                ::core::result::Result::Ok(ok__) => {
                    *pframeprotectionflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOPMWindow<Impl: IMFMediaEngineProtectedContent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hwnd: super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOPMWindow(::core::mem::transmute_copy(&hwnd)).into()
        }
        unsafe extern "system" fn TransferVideoFrame<Impl: IMFMediaEngineProtectedContent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdstsurf: *mut ::core::ffi::c_void, psrc: *const MFVideoNormalizedRect, pdst: *const super::super::Foundation::RECT, pborderclr: *const MFARGB, pframeprotectionflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).TransferVideoFrame(::core::mem::transmute(&pdstsurf), ::core::mem::transmute_copy(&psrc), ::core::mem::transmute_copy(&pdst), ::core::mem::transmute_copy(&pborderclr)) {
                ::core::result::Result::Ok(ok__) => {
                    *pframeprotectionflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContentProtectionManager<Impl: IMFMediaEngineProtectedContent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcpm: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContentProtectionManager(::core::mem::transmute(&pcpm)).into()
        }
        unsafe extern "system" fn SetApplicationCertificate<Impl: IMFMediaEngineProtectedContent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbblob: *const u8, cbblob: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetApplicationCertificate(::core::mem::transmute_copy(&pbblob), ::core::mem::transmute_copy(&cbblob)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            ShareResources: ShareResources::<Impl, IMPL_OFFSET>,
            GetRequiredProtections: GetRequiredProtections::<Impl, IMPL_OFFSET>,
            SetOPMWindow: SetOPMWindow::<Impl, IMPL_OFFSET>,
            TransferVideoFrame: TransferVideoFrame::<Impl, IMPL_OFFSET>,
            SetContentProtectionManager: SetContentProtectionManager::<Impl, IMPL_OFFSET>,
            SetApplicationCertificate: SetApplicationCertificate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaEngineProtectedContent as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFMediaEngineSrcElements_Impl: Sized {
    fn GetLength(&mut self) -> u32;
    fn GetURL(&mut self, index: u32) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn GetType(&mut self, index: u32) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn GetMedia(&mut self, index: u32) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn AddElement(&mut self, purl: super::super::Foundation::BSTR, ptype: super::super::Foundation::BSTR, pmedia: super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn RemoveAllElements(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFMediaEngineSrcElements_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaEngineSrcElements_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaEngineSrcElements_Vtbl {
        unsafe extern "system" fn GetLength<Impl: IMFMediaEngineSrcElements_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLength()
        }
        unsafe extern "system" fn GetURL<Impl: IMFMediaEngineSrcElements_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, purl: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetURL(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    *purl = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetType<Impl: IMFMediaEngineSrcElements_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, ptype: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetType(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    *ptype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMedia<Impl: IMFMediaEngineSrcElements_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, pmedia: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMedia(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    *pmedia = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddElement<Impl: IMFMediaEngineSrcElements_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, purl: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, ptype: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pmedia: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddElement(::core::mem::transmute_copy(&purl), ::core::mem::transmute_copy(&ptype), ::core::mem::transmute_copy(&pmedia)).into()
        }
        unsafe extern "system" fn RemoveAllElements<Impl: IMFMediaEngineSrcElements_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveAllElements().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetURL: GetURL::<Impl, IMPL_OFFSET>,
            GetType: GetType::<Impl, IMPL_OFFSET>,
            GetMedia: GetMedia::<Impl, IMPL_OFFSET>,
            AddElement: AddElement::<Impl, IMPL_OFFSET>,
            RemoveAllElements: RemoveAllElements::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaEngineSrcElements as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFMediaEngineSrcElementsEx_Impl: Sized + IMFMediaEngineSrcElements_Impl {
    fn AddElementEx(&mut self, purl: super::super::Foundation::BSTR, ptype: super::super::Foundation::BSTR, pmedia: super::super::Foundation::BSTR, keysystem: super::super::Foundation::BSTR) -> ::windows::core::Result<()>;
    fn GetKeySystem(&mut self, index: u32) -> ::windows::core::Result<super::super::Foundation::BSTR>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFMediaEngineSrcElementsEx_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaEngineSrcElementsEx_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaEngineSrcElementsEx_Vtbl {
        unsafe extern "system" fn AddElementEx<Impl: IMFMediaEngineSrcElementsEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, purl: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, ptype: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pmedia: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, keysystem: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddElementEx(::core::mem::transmute_copy(&purl), ::core::mem::transmute_copy(&ptype), ::core::mem::transmute_copy(&pmedia), ::core::mem::transmute_copy(&keysystem)).into()
        }
        unsafe extern "system" fn GetKeySystem<Impl: IMFMediaEngineSrcElementsEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, ptype: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetKeySystem(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    *ptype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMFMediaEngineSrcElements_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            AddElementEx: AddElementEx::<Impl, IMPL_OFFSET>,
            GetKeySystem: GetKeySystem::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaEngineSrcElementsEx as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFMediaEngineSupportsSourceTransfer_Impl: Sized {
    fn ShouldTransferSource(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn DetachMediaSource(&mut self, ppbytestream: *mut ::core::option::Option<IMFByteStream>, ppmediasource: *mut ::core::option::Option<IMFMediaSource>, ppmse: *mut ::core::option::Option<IMFMediaSourceExtension>) -> ::windows::core::Result<()>;
    fn AttachMediaSource(&mut self, pbytestream: ::core::option::Option<IMFByteStream>, pmediasource: ::core::option::Option<IMFMediaSource>, pmse: ::core::option::Option<IMFMediaSourceExtension>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFMediaEngineSupportsSourceTransfer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaEngineSupportsSourceTransfer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaEngineSupportsSourceTransfer_Vtbl {
        unsafe extern "system" fn ShouldTransferSource<Impl: IMFMediaEngineSupportsSourceTransfer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfshouldtransfer: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ShouldTransferSource() {
                ::core::result::Result::Ok(ok__) => {
                    *pfshouldtransfer = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DetachMediaSource<Impl: IMFMediaEngineSupportsSourceTransfer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppbytestream: *mut ::windows::core::RawPtr, ppmediasource: *mut ::windows::core::RawPtr, ppmse: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DetachMediaSource(::core::mem::transmute_copy(&ppbytestream), ::core::mem::transmute_copy(&ppmediasource), ::core::mem::transmute_copy(&ppmse)).into()
        }
        unsafe extern "system" fn AttachMediaSource<Impl: IMFMediaEngineSupportsSourceTransfer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbytestream: ::windows::core::RawPtr, pmediasource: ::windows::core::RawPtr, pmse: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AttachMediaSource(::core::mem::transmute(&pbytestream), ::core::mem::transmute(&pmediasource), ::core::mem::transmute(&pmse)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            ShouldTransferSource: ShouldTransferSource::<Impl, IMPL_OFFSET>,
            DetachMediaSource: DetachMediaSource::<Impl, IMPL_OFFSET>,
            AttachMediaSource: AttachMediaSource::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaEngineSupportsSourceTransfer as ::windows::core::Interface>::IID
    }
}
pub trait IMFMediaEngineTransferSource_Impl: Sized {
    fn TransferSourceToMediaEngine(&mut self, destination: ::core::option::Option<IMFMediaEngine>) -> ::windows::core::Result<()>;
}
impl IMFMediaEngineTransferSource_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaEngineTransferSource_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaEngineTransferSource_Vtbl {
        unsafe extern "system" fn TransferSourceToMediaEngine<Impl: IMFMediaEngineTransferSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, destination: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TransferSourceToMediaEngine(::core::mem::transmute(&destination)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            TransferSourceToMediaEngine: TransferSourceToMediaEngine::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaEngineTransferSource as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFMediaEngineWebSupport_Impl: Sized {
    fn ShouldDelayTheLoadEvent(&mut self) -> super::super::Foundation::BOOL;
    fn ConnectWebAudio(&mut self, dwsamplerate: u32) -> ::windows::core::Result<IAudioSourceProvider>;
    fn DisconnectWebAudio(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFMediaEngineWebSupport_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaEngineWebSupport_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaEngineWebSupport_Vtbl {
        unsafe extern "system" fn ShouldDelayTheLoadEvent<Impl: IMFMediaEngineWebSupport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ShouldDelayTheLoadEvent()
        }
        unsafe extern "system" fn ConnectWebAudio<Impl: IMFMediaEngineWebSupport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsamplerate: u32, ppsourceprovider: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ConnectWebAudio(::core::mem::transmute_copy(&dwsamplerate)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppsourceprovider = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DisconnectWebAudio<Impl: IMFMediaEngineWebSupport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DisconnectWebAudio().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            ShouldDelayTheLoadEvent: ShouldDelayTheLoadEvent::<Impl, IMPL_OFFSET>,
            ConnectWebAudio: ConnectWebAudio::<Impl, IMPL_OFFSET>,
            DisconnectWebAudio: DisconnectWebAudio::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaEngineWebSupport as ::windows::core::Interface>::IID
    }
}
pub trait IMFMediaError_Impl: Sized {
    fn GetErrorCode(&mut self) -> u16;
    fn GetExtendedErrorCode(&mut self) -> ::windows::core::Result<()>;
    fn SetErrorCode(&mut self, error: MF_MEDIA_ENGINE_ERR) -> ::windows::core::Result<()>;
    fn SetExtendedErrorCode(&mut self, error: ::windows::core::HRESULT) -> ::windows::core::Result<()>;
}
impl IMFMediaError_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaError_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaError_Vtbl {
        unsafe extern "system" fn GetErrorCode<Impl: IMFMediaError_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u16 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetErrorCode()
        }
        unsafe extern "system" fn GetExtendedErrorCode<Impl: IMFMediaError_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetExtendedErrorCode().into()
        }
        unsafe extern "system" fn SetErrorCode<Impl: IMFMediaError_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, error: MF_MEDIA_ENGINE_ERR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetErrorCode(::core::mem::transmute_copy(&error)).into()
        }
        unsafe extern "system" fn SetExtendedErrorCode<Impl: IMFMediaError_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, error: ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetExtendedErrorCode(::core::mem::transmute_copy(&error)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetErrorCode: GetErrorCode::<Impl, IMPL_OFFSET>,
            GetExtendedErrorCode: GetExtendedErrorCode::<Impl, IMPL_OFFSET>,
            SetErrorCode: SetErrorCode::<Impl, IMPL_OFFSET>,
            SetExtendedErrorCode: SetExtendedErrorCode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaError as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFMediaEvent_Impl: Sized + IMFAttributes_Impl {
    fn GetType(&mut self) -> ::windows::core::Result<u32>;
    fn GetExtendedType(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn GetStatus(&mut self) -> ::windows::core::Result<::windows::core::HRESULT>;
    fn GetValue(&mut self) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFMediaEvent_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaEvent_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaEvent_Vtbl {
        unsafe extern "system" fn GetType<Impl: IMFMediaEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmet: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetType() {
                ::core::result::Result::Ok(ok__) => {
                    *pmet = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetExtendedType<Impl: IMFMediaEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguidextendedtype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetExtendedType() {
                ::core::result::Result::Ok(ok__) => {
                    *pguidextendedtype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStatus<Impl: IMFMediaEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phrstatus: *mut ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStatus() {
                ::core::result::Result::Ok(ok__) => {
                    *phrstatus = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetValue<Impl: IMFMediaEvent_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetValue() {
                ::core::result::Result::Ok(ok__) => {
                    *pvvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMFAttributes_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetType: GetType::<Impl, IMPL_OFFSET>,
            GetExtendedType: GetExtendedType::<Impl, IMPL_OFFSET>,
            GetStatus: GetStatus::<Impl, IMPL_OFFSET>,
            GetValue: GetValue::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaEvent as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFMediaEventGenerator_Impl: Sized {
    fn GetEvent(&mut self, dwflags: MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS) -> ::windows::core::Result<IMFMediaEvent>;
    fn BeginGetEvent(&mut self, pcallback: ::core::option::Option<IMFAsyncCallback>, punkstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndGetEvent(&mut self, presult: ::core::option::Option<IMFAsyncResult>) -> ::windows::core::Result<IMFMediaEvent>;
    fn QueueEvent(&mut self, met: u32, guidextendedtype: *const ::windows::core::GUID, hrstatus: ::windows::core::HRESULT, pvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFMediaEventGenerator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaEventGenerator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaEventGenerator_Vtbl {
        unsafe extern "system" fn GetEvent<Impl: IMFMediaEventGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: MEDIA_EVENT_GENERATOR_GET_EVENT_FLAGS, ppevent: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEvent(::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppevent = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginGetEvent<Impl: IMFMediaEventGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginGetEvent(::core::mem::transmute(&pcallback), ::core::mem::transmute(&punkstate)).into()
        }
        unsafe extern "system" fn EndGetEvent<Impl: IMFMediaEventGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, ppevent: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EndGetEvent(::core::mem::transmute(&presult)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppevent = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueueEvent<Impl: IMFMediaEventGenerator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, met: u32, guidextendedtype: *const ::windows::core::GUID, hrstatus: ::windows::core::HRESULT, pvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).QueueEvent(::core::mem::transmute_copy(&met), ::core::mem::transmute_copy(&guidextendedtype), ::core::mem::transmute_copy(&hrstatus), ::core::mem::transmute_copy(&pvvalue)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetEvent: GetEvent::<Impl, IMPL_OFFSET>,
            BeginGetEvent: BeginGetEvent::<Impl, IMPL_OFFSET>,
            EndGetEvent: EndGetEvent::<Impl, IMPL_OFFSET>,
            QueueEvent: QueueEvent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaEventGenerator as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFMediaEventQueue_Impl: Sized {
    fn GetEvent(&mut self, dwflags: u32) -> ::windows::core::Result<IMFMediaEvent>;
    fn BeginGetEvent(&mut self, pcallback: ::core::option::Option<IMFAsyncCallback>, punkstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndGetEvent(&mut self, presult: ::core::option::Option<IMFAsyncResult>) -> ::windows::core::Result<IMFMediaEvent>;
    fn QueueEvent(&mut self, pevent: ::core::option::Option<IMFMediaEvent>) -> ::windows::core::Result<()>;
    fn QueueEventParamVar(&mut self, met: u32, guidextendedtype: *const ::windows::core::GUID, hrstatus: ::windows::core::HRESULT, pvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()>;
    fn QueueEventParamUnk(&mut self, met: u32, guidextendedtype: *const ::windows::core::GUID, hrstatus: ::windows::core::HRESULT, punk: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn Shutdown(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFMediaEventQueue_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaEventQueue_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaEventQueue_Vtbl {
        unsafe extern "system" fn GetEvent<Impl: IMFMediaEventQueue_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32, ppevent: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEvent(::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppevent = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginGetEvent<Impl: IMFMediaEventQueue_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginGetEvent(::core::mem::transmute(&pcallback), ::core::mem::transmute(&punkstate)).into()
        }
        unsafe extern "system" fn EndGetEvent<Impl: IMFMediaEventQueue_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, ppevent: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EndGetEvent(::core::mem::transmute(&presult)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppevent = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn QueueEvent<Impl: IMFMediaEventQueue_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pevent: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).QueueEvent(::core::mem::transmute(&pevent)).into()
        }
        unsafe extern "system" fn QueueEventParamVar<Impl: IMFMediaEventQueue_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, met: u32, guidextendedtype: *const ::windows::core::GUID, hrstatus: ::windows::core::HRESULT, pvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).QueueEventParamVar(::core::mem::transmute_copy(&met), ::core::mem::transmute_copy(&guidextendedtype), ::core::mem::transmute_copy(&hrstatus), ::core::mem::transmute_copy(&pvvalue)).into()
        }
        unsafe extern "system" fn QueueEventParamUnk<Impl: IMFMediaEventQueue_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, met: u32, guidextendedtype: *const ::windows::core::GUID, hrstatus: ::windows::core::HRESULT, punk: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).QueueEventParamUnk(::core::mem::transmute_copy(&met), ::core::mem::transmute_copy(&guidextendedtype), ::core::mem::transmute_copy(&hrstatus), ::core::mem::transmute(&punk)).into()
        }
        unsafe extern "system" fn Shutdown<Impl: IMFMediaEventQueue_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Shutdown().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetEvent: GetEvent::<Impl, IMPL_OFFSET>,
            BeginGetEvent: BeginGetEvent::<Impl, IMPL_OFFSET>,
            EndGetEvent: EndGetEvent::<Impl, IMPL_OFFSET>,
            QueueEvent: QueueEvent::<Impl, IMPL_OFFSET>,
            QueueEventParamVar: QueueEventParamVar::<Impl, IMPL_OFFSET>,
            QueueEventParamUnk: QueueEventParamUnk::<Impl, IMPL_OFFSET>,
            Shutdown: Shutdown::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaEventQueue as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFMediaKeySession_Impl: Sized {
    fn GetError(&mut self, code: *mut u16, systemcode: *mut u32) -> ::windows::core::Result<()>;
    fn KeySystem(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn SessionId(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn Update(&mut self, key: *const u8, cb: u32) -> ::windows::core::Result<()>;
    fn Close(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFMediaKeySession_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaKeySession_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaKeySession_Vtbl {
        unsafe extern "system" fn GetError<Impl: IMFMediaKeySession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, code: *mut u16, systemcode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetError(::core::mem::transmute_copy(&code), ::core::mem::transmute_copy(&systemcode)).into()
        }
        unsafe extern "system" fn KeySystem<Impl: IMFMediaKeySession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, keysystem: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KeySystem() {
                ::core::result::Result::Ok(ok__) => {
                    *keysystem = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SessionId<Impl: IMFMediaKeySession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sessionid: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SessionId() {
                ::core::result::Result::Ok(ok__) => {
                    *sessionid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Update<Impl: IMFMediaKeySession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, key: *const u8, cb: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Update(::core::mem::transmute_copy(&key), ::core::mem::transmute_copy(&cb)).into()
        }
        unsafe extern "system" fn Close<Impl: IMFMediaKeySession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Close().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetError: GetError::<Impl, IMPL_OFFSET>,
            KeySystem: KeySystem::<Impl, IMPL_OFFSET>,
            SessionId: SessionId::<Impl, IMPL_OFFSET>,
            Update: Update::<Impl, IMPL_OFFSET>,
            Close: Close::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaKeySession as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFMediaKeySession2_Impl: Sized + IMFMediaKeySession_Impl {
    fn KeyStatuses(&mut self, pkeystatusesarray: *mut *mut MFMediaKeyStatus, pusize: *mut u32) -> ::windows::core::Result<()>;
    fn Load(&mut self, bstrsessionid: super::super::Foundation::BSTR) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GenerateRequest(&mut self, initdatatype: super::super::Foundation::BSTR, pbinitdata: *const u8, cb: u32) -> ::windows::core::Result<()>;
    fn Expiration(&mut self) -> ::windows::core::Result<f64>;
    fn Remove(&mut self) -> ::windows::core::Result<()>;
    fn Shutdown(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFMediaKeySession2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaKeySession2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaKeySession2_Vtbl {
        unsafe extern "system" fn KeyStatuses<Impl: IMFMediaKeySession2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pkeystatusesarray: *mut *mut MFMediaKeyStatus, pusize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).KeyStatuses(::core::mem::transmute_copy(&pkeystatusesarray), ::core::mem::transmute_copy(&pusize)).into()
        }
        unsafe extern "system" fn Load<Impl: IMFMediaKeySession2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bstrsessionid: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pfloaded: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Load(::core::mem::transmute_copy(&bstrsessionid)) {
                ::core::result::Result::Ok(ok__) => {
                    *pfloaded = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GenerateRequest<Impl: IMFMediaKeySession2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, initdatatype: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pbinitdata: *const u8, cb: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GenerateRequest(::core::mem::transmute_copy(&initdatatype), ::core::mem::transmute_copy(&pbinitdata), ::core::mem::transmute_copy(&cb)).into()
        }
        unsafe extern "system" fn Expiration<Impl: IMFMediaKeySession2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dblexpiration: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Expiration() {
                ::core::result::Result::Ok(ok__) => {
                    *dblexpiration = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Remove<Impl: IMFMediaKeySession2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Remove().into()
        }
        unsafe extern "system" fn Shutdown<Impl: IMFMediaKeySession2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Shutdown().into()
        }
        Self {
            base: IMFMediaKeySession_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            KeyStatuses: KeyStatuses::<Impl, IMPL_OFFSET>,
            Load: Load::<Impl, IMPL_OFFSET>,
            GenerateRequest: GenerateRequest::<Impl, IMPL_OFFSET>,
            Expiration: Expiration::<Impl, IMPL_OFFSET>,
            Remove: Remove::<Impl, IMPL_OFFSET>,
            Shutdown: Shutdown::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaKeySession2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFMediaKeySessionNotify_Impl: Sized {
    fn KeyMessage(&mut self, destinationurl: super::super::Foundation::BSTR, message: *const u8, cb: u32);
    fn KeyAdded(&mut self);
    fn KeyError(&mut self, code: u16, systemcode: u32);
}
#[cfg(feature = "Win32_Foundation")]
impl IMFMediaKeySessionNotify_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaKeySessionNotify_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaKeySessionNotify_Vtbl {
        unsafe extern "system" fn KeyMessage<Impl: IMFMediaKeySessionNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, destinationurl: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, message: *const u8, cb: u32) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).KeyMessage(::core::mem::transmute_copy(&destinationurl), ::core::mem::transmute_copy(&message), ::core::mem::transmute_copy(&cb))
        }
        unsafe extern "system" fn KeyAdded<Impl: IMFMediaKeySessionNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).KeyAdded()
        }
        unsafe extern "system" fn KeyError<Impl: IMFMediaKeySessionNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, code: u16, systemcode: u32) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).KeyError(::core::mem::transmute_copy(&code), ::core::mem::transmute_copy(&systemcode))
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            KeyMessage: KeyMessage::<Impl, IMPL_OFFSET>,
            KeyAdded: KeyAdded::<Impl, IMPL_OFFSET>,
            KeyError: KeyError::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaKeySessionNotify as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFMediaKeySessionNotify2_Impl: Sized + IMFMediaKeySessionNotify_Impl {
    fn KeyMessage2(&mut self, emessagetype: MF_MEDIAKEYSESSION_MESSAGETYPE, destinationurl: super::super::Foundation::BSTR, pbmessage: *const u8, cbmessage: u32);
    fn KeyStatusChange(&mut self);
}
#[cfg(feature = "Win32_Foundation")]
impl IMFMediaKeySessionNotify2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaKeySessionNotify2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaKeySessionNotify2_Vtbl {
        unsafe extern "system" fn KeyMessage2<Impl: IMFMediaKeySessionNotify2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, emessagetype: MF_MEDIAKEYSESSION_MESSAGETYPE, destinationurl: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pbmessage: *const u8, cbmessage: u32) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).KeyMessage2(::core::mem::transmute_copy(&emessagetype), ::core::mem::transmute_copy(&destinationurl), ::core::mem::transmute_copy(&pbmessage), ::core::mem::transmute_copy(&cbmessage))
        }
        unsafe extern "system" fn KeyStatusChange<Impl: IMFMediaKeySessionNotify2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).KeyStatusChange()
        }
        Self {
            base: IMFMediaKeySessionNotify_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            KeyMessage2: KeyMessage2::<Impl, IMPL_OFFSET>,
            KeyStatusChange: KeyStatusChange::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaKeySessionNotify2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_Shell_PropertiesSystem"))]
pub trait IMFMediaKeySystemAccess_Impl: Sized {
    fn CreateMediaKeys(&mut self, pcdmcustomconfig: ::core::option::Option<super::super::UI::Shell::PropertiesSystem::IPropertyStore>) -> ::windows::core::Result<IMFMediaKeys2>;
    fn SupportedConfiguration(&mut self) -> ::windows::core::Result<super::super::UI::Shell::PropertiesSystem::IPropertyStore>;
    fn KeySystem(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_Shell_PropertiesSystem"))]
impl IMFMediaKeySystemAccess_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaKeySystemAccess_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaKeySystemAccess_Vtbl {
        unsafe extern "system" fn CreateMediaKeys<Impl: IMFMediaKeySystemAccess_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcdmcustomconfig: ::windows::core::RawPtr, ppkeys: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateMediaKeys(::core::mem::transmute(&pcdmcustomconfig)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppkeys = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SupportedConfiguration<Impl: IMFMediaKeySystemAccess_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppsupportedconfiguration: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SupportedConfiguration() {
                ::core::result::Result::Ok(ok__) => {
                    *ppsupportedconfiguration = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KeySystem<Impl: IMFMediaKeySystemAccess_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pkeysystem: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KeySystem() {
                ::core::result::Result::Ok(ok__) => {
                    *pkeysystem = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            CreateMediaKeys: CreateMediaKeys::<Impl, IMPL_OFFSET>,
            SupportedConfiguration: SupportedConfiguration::<Impl, IMPL_OFFSET>,
            KeySystem: KeySystem::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaKeySystemAccess as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFMediaKeys_Impl: Sized {
    fn CreateSession(&mut self, mimetype: super::super::Foundation::BSTR, initdata: *const u8, cb: u32, customdata: *const u8, cbcustomdata: u32, notify: ::core::option::Option<IMFMediaKeySessionNotify>) -> ::windows::core::Result<IMFMediaKeySession>;
    fn KeySystem(&mut self) -> ::windows::core::Result<super::super::Foundation::BSTR>;
    fn Shutdown(&mut self) -> ::windows::core::Result<()>;
    fn GetSuspendNotify(&mut self) -> ::windows::core::Result<IMFCdmSuspendNotify>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFMediaKeys_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaKeys_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaKeys_Vtbl {
        unsafe extern "system" fn CreateSession<Impl: IMFMediaKeys_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mimetype: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, initdata: *const u8, cb: u32, customdata: *const u8, cbcustomdata: u32, notify: ::windows::core::RawPtr, ppsession: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateSession(::core::mem::transmute_copy(&mimetype), ::core::mem::transmute_copy(&initdata), ::core::mem::transmute_copy(&cb), ::core::mem::transmute_copy(&customdata), ::core::mem::transmute_copy(&cbcustomdata), ::core::mem::transmute(&notify)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppsession = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn KeySystem<Impl: IMFMediaKeys_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, keysystem: *mut super::super::Foundation::BSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).KeySystem() {
                ::core::result::Result::Ok(ok__) => {
                    *keysystem = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Shutdown<Impl: IMFMediaKeys_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Shutdown().into()
        }
        unsafe extern "system" fn GetSuspendNotify<Impl: IMFMediaKeys_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, notify: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSuspendNotify() {
                ::core::result::Result::Ok(ok__) => {
                    *notify = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            CreateSession: CreateSession::<Impl, IMPL_OFFSET>,
            KeySystem: KeySystem::<Impl, IMPL_OFFSET>,
            Shutdown: Shutdown::<Impl, IMPL_OFFSET>,
            GetSuspendNotify: GetSuspendNotify::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaKeys as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFMediaKeys2_Impl: Sized + IMFMediaKeys_Impl {
    fn CreateSession2(&mut self, esessiontype: MF_MEDIAKEYSESSION_TYPE, pmfmediakeysessionnotify2: ::core::option::Option<IMFMediaKeySessionNotify2>) -> ::windows::core::Result<IMFMediaKeySession2>;
    fn SetServerCertificate(&mut self, pbservercertificate: *const u8, cb: u32) -> ::windows::core::Result<()>;
    fn GetDOMException(&mut self, systemcode: ::windows::core::HRESULT) -> ::windows::core::Result<::windows::core::HRESULT>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFMediaKeys2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaKeys2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaKeys2_Vtbl {
        unsafe extern "system" fn CreateSession2<Impl: IMFMediaKeys2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, esessiontype: MF_MEDIAKEYSESSION_TYPE, pmfmediakeysessionnotify2: ::windows::core::RawPtr, ppsession: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateSession2(::core::mem::transmute_copy(&esessiontype), ::core::mem::transmute(&pmfmediakeysessionnotify2)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppsession = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetServerCertificate<Impl: IMFMediaKeys2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbservercertificate: *const u8, cb: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetServerCertificate(::core::mem::transmute_copy(&pbservercertificate), ::core::mem::transmute_copy(&cb)).into()
        }
        unsafe extern "system" fn GetDOMException<Impl: IMFMediaKeys2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, systemcode: ::windows::core::HRESULT, code: *mut ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDOMException(::core::mem::transmute_copy(&systemcode)) {
                ::core::result::Result::Ok(ok__) => {
                    *code = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMFMediaKeys_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            CreateSession2: CreateSession2::<Impl, IMPL_OFFSET>,
            SetServerCertificate: SetServerCertificate::<Impl, IMPL_OFFSET>,
            GetDOMException: GetDOMException::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaKeys2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFMediaSession_Impl: Sized + IMFMediaEventGenerator_Impl {
    fn SetTopology(&mut self, dwsettopologyflags: u32, ptopology: ::core::option::Option<IMFTopology>) -> ::windows::core::Result<()>;
    fn ClearTopologies(&mut self) -> ::windows::core::Result<()>;
    fn Start(&mut self, pguidtimeformat: *const ::windows::core::GUID, pvarstartposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()>;
    fn Pause(&mut self) -> ::windows::core::Result<()>;
    fn Stop(&mut self) -> ::windows::core::Result<()>;
    fn Close(&mut self) -> ::windows::core::Result<()>;
    fn Shutdown(&mut self) -> ::windows::core::Result<()>;
    fn GetClock(&mut self) -> ::windows::core::Result<IMFClock>;
    fn GetSessionCapabilities(&mut self) -> ::windows::core::Result<u32>;
    fn GetFullTopology(&mut self, dwgetfulltopologyflags: u32, topoid: u64) -> ::windows::core::Result<IMFTopology>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFMediaSession_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaSession_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaSession_Vtbl {
        unsafe extern "system" fn SetTopology<Impl: IMFMediaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsettopologyflags: u32, ptopology: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTopology(::core::mem::transmute_copy(&dwsettopologyflags), ::core::mem::transmute(&ptopology)).into()
        }
        unsafe extern "system" fn ClearTopologies<Impl: IMFMediaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ClearTopologies().into()
        }
        unsafe extern "system" fn Start<Impl: IMFMediaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguidtimeformat: *const ::windows::core::GUID, pvarstartposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Start(::core::mem::transmute_copy(&pguidtimeformat), ::core::mem::transmute_copy(&pvarstartposition)).into()
        }
        unsafe extern "system" fn Pause<Impl: IMFMediaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Pause().into()
        }
        unsafe extern "system" fn Stop<Impl: IMFMediaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        unsafe extern "system" fn Close<Impl: IMFMediaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Close().into()
        }
        unsafe extern "system" fn Shutdown<Impl: IMFMediaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Shutdown().into()
        }
        unsafe extern "system" fn GetClock<Impl: IMFMediaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppclock: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetClock() {
                ::core::result::Result::Ok(ok__) => {
                    *ppclock = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSessionCapabilities<Impl: IMFMediaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwcaps: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSessionCapabilities() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwcaps = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFullTopology<Impl: IMFMediaSession_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwgetfulltopologyflags: u32, topoid: u64, ppfulltopology: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFullTopology(::core::mem::transmute_copy(&dwgetfulltopologyflags), ::core::mem::transmute_copy(&topoid)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppfulltopology = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMFMediaEventGenerator_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetTopology: SetTopology::<Impl, IMPL_OFFSET>,
            ClearTopologies: ClearTopologies::<Impl, IMPL_OFFSET>,
            Start: Start::<Impl, IMPL_OFFSET>,
            Pause: Pause::<Impl, IMPL_OFFSET>,
            Stop: Stop::<Impl, IMPL_OFFSET>,
            Close: Close::<Impl, IMPL_OFFSET>,
            Shutdown: Shutdown::<Impl, IMPL_OFFSET>,
            GetClock: GetClock::<Impl, IMPL_OFFSET>,
            GetSessionCapabilities: GetSessionCapabilities::<Impl, IMPL_OFFSET>,
            GetFullTopology: GetFullTopology::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaSession as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFMediaSharingEngine_Impl: Sized + IMFMediaEngine_Impl {
    fn GetDevice(&mut self) -> ::windows::core::Result<DEVICE_INFO>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFMediaSharingEngine_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaSharingEngine_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaSharingEngine_Vtbl {
        unsafe extern "system" fn GetDevice<Impl: IMFMediaSharingEngine_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdevice: *mut DEVICE_INFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDevice() {
                ::core::result::Result::Ok(ok__) => {
                    *pdevice = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: IMFMediaEngine_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), GetDevice: GetDevice::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaSharingEngine as ::windows::core::Interface>::IID
    }
}
pub trait IMFMediaSharingEngineClassFactory_Impl: Sized {
    fn CreateInstance(&mut self, dwflags: u32, pattr: ::core::option::Option<IMFAttributes>) -> ::windows::core::Result<IMFMediaSharingEngine>;
}
impl IMFMediaSharingEngineClassFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaSharingEngineClassFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaSharingEngineClassFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMFMediaSharingEngineClassFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32, pattr: ::windows::core::RawPtr, ppengine: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(::core::mem::transmute_copy(&dwflags), ::core::mem::transmute(&pattr)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppengine = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaSharingEngineClassFactory as ::windows::core::Interface>::IID
    }
}
pub trait IMFMediaSink_Impl: Sized {
    fn GetCharacteristics(&mut self) -> ::windows::core::Result<u32>;
    fn AddStreamSink(&mut self, dwstreamsinkidentifier: u32, pmediatype: ::core::option::Option<IMFMediaType>) -> ::windows::core::Result<IMFStreamSink>;
    fn RemoveStreamSink(&mut self, dwstreamsinkidentifier: u32) -> ::windows::core::Result<()>;
    fn GetStreamSinkCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetStreamSinkByIndex(&mut self, dwindex: u32) -> ::windows::core::Result<IMFStreamSink>;
    fn GetStreamSinkById(&mut self, dwstreamsinkidentifier: u32) -> ::windows::core::Result<IMFStreamSink>;
    fn SetPresentationClock(&mut self, ppresentationclock: ::core::option::Option<IMFPresentationClock>) -> ::windows::core::Result<()>;
    fn GetPresentationClock(&mut self) -> ::windows::core::Result<IMFPresentationClock>;
    fn Shutdown(&mut self) -> ::windows::core::Result<()>;
}
impl IMFMediaSink_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaSink_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaSink_Vtbl {
        unsafe extern "system" fn GetCharacteristics<Impl: IMFMediaSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwcharacteristics: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCharacteristics() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwcharacteristics = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddStreamSink<Impl: IMFMediaSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamsinkidentifier: u32, pmediatype: ::windows::core::RawPtr, ppstreamsink: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddStreamSink(::core::mem::transmute_copy(&dwstreamsinkidentifier), ::core::mem::transmute(&pmediatype)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppstreamsink = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveStreamSink<Impl: IMFMediaSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamsinkidentifier: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveStreamSink(::core::mem::transmute_copy(&dwstreamsinkidentifier)).into()
        }
        unsafe extern "system" fn GetStreamSinkCount<Impl: IMFMediaSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcstreamsinkcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamSinkCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pcstreamsinkcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamSinkByIndex<Impl: IMFMediaSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppstreamsink: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamSinkByIndex(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppstreamsink = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamSinkById<Impl: IMFMediaSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamsinkidentifier: u32, ppstreamsink: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamSinkById(::core::mem::transmute_copy(&dwstreamsinkidentifier)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppstreamsink = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPresentationClock<Impl: IMFMediaSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppresentationclock: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPresentationClock(::core::mem::transmute(&ppresentationclock)).into()
        }
        unsafe extern "system" fn GetPresentationClock<Impl: IMFMediaSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pppresentationclock: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPresentationClock() {
                ::core::result::Result::Ok(ok__) => {
                    *pppresentationclock = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Shutdown<Impl: IMFMediaSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Shutdown().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetCharacteristics: GetCharacteristics::<Impl, IMPL_OFFSET>,
            AddStreamSink: AddStreamSink::<Impl, IMPL_OFFSET>,
            RemoveStreamSink: RemoveStreamSink::<Impl, IMPL_OFFSET>,
            GetStreamSinkCount: GetStreamSinkCount::<Impl, IMPL_OFFSET>,
            GetStreamSinkByIndex: GetStreamSinkByIndex::<Impl, IMPL_OFFSET>,
            GetStreamSinkById: GetStreamSinkById::<Impl, IMPL_OFFSET>,
            SetPresentationClock: SetPresentationClock::<Impl, IMPL_OFFSET>,
            GetPresentationClock: GetPresentationClock::<Impl, IMPL_OFFSET>,
            Shutdown: Shutdown::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaSink as ::windows::core::Interface>::IID
    }
}
pub trait IMFMediaSinkPreroll_Impl: Sized {
    fn NotifyPreroll(&mut self, hnsupcomingstarttime: i64) -> ::windows::core::Result<()>;
}
impl IMFMediaSinkPreroll_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaSinkPreroll_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaSinkPreroll_Vtbl {
        unsafe extern "system" fn NotifyPreroll<Impl: IMFMediaSinkPreroll_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnsupcomingstarttime: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NotifyPreroll(::core::mem::transmute_copy(&hnsupcomingstarttime)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), NotifyPreroll: NotifyPreroll::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaSinkPreroll as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFMediaSource_Impl: Sized + IMFMediaEventGenerator_Impl {
    fn GetCharacteristics(&mut self) -> ::windows::core::Result<u32>;
    fn CreatePresentationDescriptor(&mut self) -> ::windows::core::Result<IMFPresentationDescriptor>;
    fn Start(&mut self, ppresentationdescriptor: ::core::option::Option<IMFPresentationDescriptor>, pguidtimeformat: *const ::windows::core::GUID, pvarstartposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()>;
    fn Stop(&mut self) -> ::windows::core::Result<()>;
    fn Pause(&mut self) -> ::windows::core::Result<()>;
    fn Shutdown(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFMediaSource_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaSource_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaSource_Vtbl {
        unsafe extern "system" fn GetCharacteristics<Impl: IMFMediaSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwcharacteristics: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCharacteristics() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwcharacteristics = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreatePresentationDescriptor<Impl: IMFMediaSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pppresentationdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreatePresentationDescriptor() {
                ::core::result::Result::Ok(ok__) => {
                    *pppresentationdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Start<Impl: IMFMediaSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppresentationdescriptor: ::windows::core::RawPtr, pguidtimeformat: *const ::windows::core::GUID, pvarstartposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Start(::core::mem::transmute(&ppresentationdescriptor), ::core::mem::transmute_copy(&pguidtimeformat), ::core::mem::transmute_copy(&pvarstartposition)).into()
        }
        unsafe extern "system" fn Stop<Impl: IMFMediaSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        unsafe extern "system" fn Pause<Impl: IMFMediaSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Pause().into()
        }
        unsafe extern "system" fn Shutdown<Impl: IMFMediaSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Shutdown().into()
        }
        Self {
            base: IMFMediaEventGenerator_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetCharacteristics: GetCharacteristics::<Impl, IMPL_OFFSET>,
            CreatePresentationDescriptor: CreatePresentationDescriptor::<Impl, IMPL_OFFSET>,
            Start: Start::<Impl, IMPL_OFFSET>,
            Stop: Stop::<Impl, IMPL_OFFSET>,
            Pause: Pause::<Impl, IMPL_OFFSET>,
            Shutdown: Shutdown::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaSource as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFMediaSource2_Impl: Sized + IMFMediaEventGenerator_Impl + IMFMediaSource_Impl + IMFMediaSourceEx_Impl {
    fn SetMediaType(&mut self, dwstreamid: u32, pmediatype: ::core::option::Option<IMFMediaType>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFMediaSource2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaSource2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaSource2_Vtbl {
        unsafe extern "system" fn SetMediaType<Impl: IMFMediaSource2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, pmediatype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMediaType(::core::mem::transmute_copy(&dwstreamid), ::core::mem::transmute(&pmediatype)).into()
        }
        Self { base: IMFMediaSourceEx_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), SetMediaType: SetMediaType::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaSource2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFMediaSourceEx_Impl: Sized + IMFMediaEventGenerator_Impl + IMFMediaSource_Impl {
    fn GetSourceAttributes(&mut self) -> ::windows::core::Result<IMFAttributes>;
    fn GetStreamAttributes(&mut self, dwstreamidentifier: u32) -> ::windows::core::Result<IMFAttributes>;
    fn SetD3DManager(&mut self, pmanager: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFMediaSourceEx_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaSourceEx_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaSourceEx_Vtbl {
        unsafe extern "system" fn GetSourceAttributes<Impl: IMFMediaSourceEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppattributes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSourceAttributes() {
                ::core::result::Result::Ok(ok__) => {
                    *ppattributes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamAttributes<Impl: IMFMediaSourceEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamidentifier: u32, ppattributes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamAttributes(::core::mem::transmute_copy(&dwstreamidentifier)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppattributes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetD3DManager<Impl: IMFMediaSourceEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmanager: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetD3DManager(::core::mem::transmute(&pmanager)).into()
        }
        Self {
            base: IMFMediaSource_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetSourceAttributes: GetSourceAttributes::<Impl, IMPL_OFFSET>,
            GetStreamAttributes: GetStreamAttributes::<Impl, IMPL_OFFSET>,
            SetD3DManager: SetD3DManager::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaSourceEx as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFMediaSourceExtension_Impl: Sized {
    fn GetSourceBuffers(&mut self) -> ::core::option::Option<IMFSourceBufferList>;
    fn GetActiveSourceBuffers(&mut self) -> ::core::option::Option<IMFSourceBufferList>;
    fn GetReadyState(&mut self) -> MF_MSE_READY;
    fn GetDuration(&mut self) -> f64;
    fn SetDuration(&mut self, duration: f64) -> ::windows::core::Result<()>;
    fn AddSourceBuffer(&mut self, r#type: super::super::Foundation::BSTR, pnotify: ::core::option::Option<IMFSourceBufferNotify>) -> ::windows::core::Result<IMFSourceBuffer>;
    fn RemoveSourceBuffer(&mut self, psourcebuffer: ::core::option::Option<IMFSourceBuffer>) -> ::windows::core::Result<()>;
    fn SetEndOfStream(&mut self, error: MF_MSE_ERROR) -> ::windows::core::Result<()>;
    fn IsTypeSupported(&mut self, r#type: super::super::Foundation::BSTR) -> super::super::Foundation::BOOL;
    fn GetSourceBuffer(&mut self, dwstreamindex: u32) -> ::core::option::Option<IMFSourceBuffer>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFMediaSourceExtension_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaSourceExtension_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaSourceExtension_Vtbl {
        unsafe extern "system" fn GetSourceBuffers<Impl: IMFMediaSourceExtension_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::core::option::Option<IMFSourceBufferList> {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSourceBuffers()
        }
        unsafe extern "system" fn GetActiveSourceBuffers<Impl: IMFMediaSourceExtension_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::core::option::Option<IMFSourceBufferList> {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetActiveSourceBuffers()
        }
        unsafe extern "system" fn GetReadyState<Impl: IMFMediaSourceExtension_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> MF_MSE_READY {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetReadyState()
        }
        unsafe extern "system" fn GetDuration<Impl: IMFMediaSourceExtension_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDuration()
        }
        unsafe extern "system" fn SetDuration<Impl: IMFMediaSourceExtension_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, duration: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDuration(::core::mem::transmute_copy(&duration)).into()
        }
        unsafe extern "system" fn AddSourceBuffer<Impl: IMFMediaSourceExtension_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, r#type: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>, pnotify: ::windows::core::RawPtr, ppsourcebuffer: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddSourceBuffer(::core::mem::transmute_copy(&r#type), ::core::mem::transmute(&pnotify)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppsourcebuffer = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveSourceBuffer<Impl: IMFMediaSourceExtension_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psourcebuffer: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveSourceBuffer(::core::mem::transmute(&psourcebuffer)).into()
        }
        unsafe extern "system" fn SetEndOfStream<Impl: IMFMediaSourceExtension_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, error: MF_MSE_ERROR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetEndOfStream(::core::mem::transmute_copy(&error)).into()
        }
        unsafe extern "system" fn IsTypeSupported<Impl: IMFMediaSourceExtension_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, r#type: ::core::mem::ManuallyDrop<super::super::Foundation::BSTR>) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsTypeSupported(::core::mem::transmute_copy(&r#type))
        }
        unsafe extern "system" fn GetSourceBuffer<Impl: IMFMediaSourceExtension_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32) -> ::core::option::Option<IMFSourceBuffer> {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSourceBuffer(::core::mem::transmute_copy(&dwstreamindex))
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetSourceBuffers: GetSourceBuffers::<Impl, IMPL_OFFSET>,
            GetActiveSourceBuffers: GetActiveSourceBuffers::<Impl, IMPL_OFFSET>,
            GetReadyState: GetReadyState::<Impl, IMPL_OFFSET>,
            GetDuration: GetDuration::<Impl, IMPL_OFFSET>,
            SetDuration: SetDuration::<Impl, IMPL_OFFSET>,
            AddSourceBuffer: AddSourceBuffer::<Impl, IMPL_OFFSET>,
            RemoveSourceBuffer: RemoveSourceBuffer::<Impl, IMPL_OFFSET>,
            SetEndOfStream: SetEndOfStream::<Impl, IMPL_OFFSET>,
            IsTypeSupported: IsTypeSupported::<Impl, IMPL_OFFSET>,
            GetSourceBuffer: GetSourceBuffer::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaSourceExtension as ::windows::core::Interface>::IID
    }
}
pub trait IMFMediaSourceExtensionLiveSeekableRange_Impl: Sized {
    fn SetLiveSeekableRange(&mut self, start: f64, end: f64) -> ::windows::core::Result<()>;
    fn ClearLiveSeekableRange(&mut self) -> ::windows::core::Result<()>;
}
impl IMFMediaSourceExtensionLiveSeekableRange_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaSourceExtensionLiveSeekableRange_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaSourceExtensionLiveSeekableRange_Vtbl {
        unsafe extern "system" fn SetLiveSeekableRange<Impl: IMFMediaSourceExtensionLiveSeekableRange_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, start: f64, end: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLiveSeekableRange(::core::mem::transmute_copy(&start), ::core::mem::transmute_copy(&end)).into()
        }
        unsafe extern "system" fn ClearLiveSeekableRange<Impl: IMFMediaSourceExtensionLiveSeekableRange_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ClearLiveSeekableRange().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetLiveSeekableRange: SetLiveSeekableRange::<Impl, IMPL_OFFSET>,
            ClearLiveSeekableRange: ClearLiveSeekableRange::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaSourceExtensionLiveSeekableRange as ::windows::core::Interface>::IID
    }
}
pub trait IMFMediaSourceExtensionNotify_Impl: Sized {
    fn OnSourceOpen(&mut self);
    fn OnSourceEnded(&mut self);
    fn OnSourceClose(&mut self);
}
impl IMFMediaSourceExtensionNotify_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaSourceExtensionNotify_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaSourceExtensionNotify_Vtbl {
        unsafe extern "system" fn OnSourceOpen<Impl: IMFMediaSourceExtensionNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnSourceOpen()
        }
        unsafe extern "system" fn OnSourceEnded<Impl: IMFMediaSourceExtensionNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnSourceEnded()
        }
        unsafe extern "system" fn OnSourceClose<Impl: IMFMediaSourceExtensionNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnSourceClose()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            OnSourceOpen: OnSourceOpen::<Impl, IMPL_OFFSET>,
            OnSourceEnded: OnSourceEnded::<Impl, IMPL_OFFSET>,
            OnSourceClose: OnSourceClose::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaSourceExtensionNotify as ::windows::core::Interface>::IID
    }
}
pub trait IMFMediaSourcePresentationProvider_Impl: Sized {
    fn ForceEndOfPresentation(&mut self, ppresentationdescriptor: ::core::option::Option<IMFPresentationDescriptor>) -> ::windows::core::Result<()>;
}
impl IMFMediaSourcePresentationProvider_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaSourcePresentationProvider_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaSourcePresentationProvider_Vtbl {
        unsafe extern "system" fn ForceEndOfPresentation<Impl: IMFMediaSourcePresentationProvider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppresentationdescriptor: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ForceEndOfPresentation(::core::mem::transmute(&ppresentationdescriptor)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), ForceEndOfPresentation: ForceEndOfPresentation::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaSourcePresentationProvider as ::windows::core::Interface>::IID
    }
}
pub trait IMFMediaSourceTopologyProvider_Impl: Sized {
    fn GetMediaSourceTopology(&mut self, ppresentationdescriptor: ::core::option::Option<IMFPresentationDescriptor>) -> ::windows::core::Result<IMFTopology>;
}
impl IMFMediaSourceTopologyProvider_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaSourceTopologyProvider_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaSourceTopologyProvider_Vtbl {
        unsafe extern "system" fn GetMediaSourceTopology<Impl: IMFMediaSourceTopologyProvider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppresentationdescriptor: ::windows::core::RawPtr, pptopology: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMediaSourceTopology(::core::mem::transmute(&ppresentationdescriptor)) {
                ::core::result::Result::Ok(ok__) => {
                    *pptopology = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetMediaSourceTopology: GetMediaSourceTopology::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaSourceTopologyProvider as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFMediaStream_Impl: Sized + IMFMediaEventGenerator_Impl {
    fn GetMediaSource(&mut self) -> ::windows::core::Result<IMFMediaSource>;
    fn GetStreamDescriptor(&mut self) -> ::windows::core::Result<IMFStreamDescriptor>;
    fn RequestSample(&mut self, ptoken: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFMediaStream_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaStream_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaStream_Vtbl {
        unsafe extern "system" fn GetMediaSource<Impl: IMFMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppmediasource: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMediaSource() {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediasource = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamDescriptor<Impl: IMFMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppstreamdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamDescriptor() {
                ::core::result::Result::Ok(ok__) => {
                    *ppstreamdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RequestSample<Impl: IMFMediaStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptoken: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RequestSample(::core::mem::transmute(&ptoken)).into()
        }
        Self {
            base: IMFMediaEventGenerator_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetMediaSource: GetMediaSource::<Impl, IMPL_OFFSET>,
            GetStreamDescriptor: GetStreamDescriptor::<Impl, IMPL_OFFSET>,
            RequestSample: RequestSample::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaStream as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFMediaStream2_Impl: Sized + IMFMediaEventGenerator_Impl + IMFMediaStream_Impl {
    fn SetStreamState(&mut self, value: MF_STREAM_STATE) -> ::windows::core::Result<()>;
    fn GetStreamState(&mut self) -> ::windows::core::Result<MF_STREAM_STATE>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFMediaStream2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaStream2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaStream2_Vtbl {
        unsafe extern "system" fn SetStreamState<Impl: IMFMediaStream2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: MF_STREAM_STATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStreamState(::core::mem::transmute_copy(&value)).into()
        }
        unsafe extern "system" fn GetStreamState<Impl: IMFMediaStream2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut MF_STREAM_STATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamState() {
                ::core::result::Result::Ok(ok__) => {
                    *value = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMFMediaStream_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetStreamState: SetStreamState::<Impl, IMPL_OFFSET>,
            GetStreamState: GetStreamState::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaStream2 as ::windows::core::Interface>::IID
    }
}
pub trait IMFMediaStreamSourceSampleRequest_Impl: Sized {
    fn SetSample(&mut self, value: ::core::option::Option<IMFSample>) -> ::windows::core::Result<()>;
}
impl IMFMediaStreamSourceSampleRequest_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaStreamSourceSampleRequest_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaStreamSourceSampleRequest_Vtbl {
        unsafe extern "system" fn SetSample<Impl: IMFMediaStreamSourceSampleRequest_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSample(::core::mem::transmute(&value)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), SetSample: SetSample::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaStreamSourceSampleRequest as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFMediaTimeRange_Impl: Sized {
    fn GetLength(&mut self) -> u32;
    fn GetStart(&mut self, index: u32) -> ::windows::core::Result<f64>;
    fn GetEnd(&mut self, index: u32) -> ::windows::core::Result<f64>;
    fn ContainsTime(&mut self, time: f64) -> super::super::Foundation::BOOL;
    fn AddRange(&mut self, starttime: f64, endtime: f64) -> ::windows::core::Result<()>;
    fn Clear(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFMediaTimeRange_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaTimeRange_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaTimeRange_Vtbl {
        unsafe extern "system" fn GetLength<Impl: IMFMediaTimeRange_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLength()
        }
        unsafe extern "system" fn GetStart<Impl: IMFMediaTimeRange_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, pstart: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStart(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    *pstart = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetEnd<Impl: IMFMediaTimeRange_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, pend: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEnd(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    *pend = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ContainsTime<Impl: IMFMediaTimeRange_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, time: f64) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ContainsTime(::core::mem::transmute_copy(&time))
        }
        unsafe extern "system" fn AddRange<Impl: IMFMediaTimeRange_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, starttime: f64, endtime: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddRange(::core::mem::transmute_copy(&starttime), ::core::mem::transmute_copy(&endtime)).into()
        }
        unsafe extern "system" fn Clear<Impl: IMFMediaTimeRange_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Clear().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetStart: GetStart::<Impl, IMPL_OFFSET>,
            GetEnd: GetEnd::<Impl, IMPL_OFFSET>,
            ContainsTime: ContainsTime::<Impl, IMPL_OFFSET>,
            AddRange: AddRange::<Impl, IMPL_OFFSET>,
            Clear: Clear::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaTimeRange as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFMediaType_Impl: Sized + IMFAttributes_Impl {
    fn GetMajorType(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn IsCompressedFormat(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn IsEqual(&mut self, pimediatype: ::core::option::Option<IMFMediaType>) -> ::windows::core::Result<u32>;
    fn GetRepresentation(&mut self, guidrepresentation: ::windows::core::GUID, ppvrepresentation: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn FreeRepresentation(&mut self, guidrepresentation: ::windows::core::GUID, pvrepresentation: *const ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFMediaType_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaType_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaType_Vtbl {
        unsafe extern "system" fn GetMajorType<Impl: IMFMediaType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguidmajortype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMajorType() {
                ::core::result::Result::Ok(ok__) => {
                    *pguidmajortype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsCompressedFormat<Impl: IMFMediaType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfcompressed: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsCompressedFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *pfcompressed = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsEqual<Impl: IMFMediaType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pimediatype: ::windows::core::RawPtr, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsEqual(::core::mem::transmute(&pimediatype)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRepresentation<Impl: IMFMediaType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidrepresentation: ::windows::core::GUID, ppvrepresentation: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRepresentation(::core::mem::transmute_copy(&guidrepresentation), ::core::mem::transmute_copy(&ppvrepresentation)).into()
        }
        unsafe extern "system" fn FreeRepresentation<Impl: IMFMediaType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidrepresentation: ::windows::core::GUID, pvrepresentation: *const ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).FreeRepresentation(::core::mem::transmute_copy(&guidrepresentation), ::core::mem::transmute_copy(&pvrepresentation)).into()
        }
        Self {
            base: IMFAttributes_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetMajorType: GetMajorType::<Impl, IMPL_OFFSET>,
            IsCompressedFormat: IsCompressedFormat::<Impl, IMPL_OFFSET>,
            IsEqual: IsEqual::<Impl, IMPL_OFFSET>,
            GetRepresentation: GetRepresentation::<Impl, IMPL_OFFSET>,
            FreeRepresentation: FreeRepresentation::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaType as ::windows::core::Interface>::IID
    }
}
pub trait IMFMediaTypeHandler_Impl: Sized {
    fn IsMediaTypeSupported(&mut self, pmediatype: ::core::option::Option<IMFMediaType>) -> ::windows::core::Result<IMFMediaType>;
    fn GetMediaTypeCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetMediaTypeByIndex(&mut self, dwindex: u32) -> ::windows::core::Result<IMFMediaType>;
    fn SetCurrentMediaType(&mut self, pmediatype: ::core::option::Option<IMFMediaType>) -> ::windows::core::Result<()>;
    fn GetCurrentMediaType(&mut self) -> ::windows::core::Result<IMFMediaType>;
    fn GetMajorType(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
}
impl IMFMediaTypeHandler_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMediaTypeHandler_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMediaTypeHandler_Vtbl {
        unsafe extern "system" fn IsMediaTypeSupported<Impl: IMFMediaTypeHandler_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmediatype: ::windows::core::RawPtr, ppmediatype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsMediaTypeSupported(::core::mem::transmute(&pmediatype)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediatype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaTypeCount<Impl: IMFMediaTypeHandler_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwtypecount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMediaTypeCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwtypecount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaTypeByIndex<Impl: IMFMediaTypeHandler_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, pptype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMediaTypeByIndex(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pptype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentMediaType<Impl: IMFMediaTypeHandler_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmediatype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCurrentMediaType(::core::mem::transmute(&pmediatype)).into()
        }
        unsafe extern "system" fn GetCurrentMediaType<Impl: IMFMediaTypeHandler_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppmediatype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentMediaType() {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediatype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMajorType<Impl: IMFMediaTypeHandler_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguidmajortype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMajorType() {
                ::core::result::Result::Ok(ok__) => {
                    *pguidmajortype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            IsMediaTypeSupported: IsMediaTypeSupported::<Impl, IMPL_OFFSET>,
            GetMediaTypeCount: GetMediaTypeCount::<Impl, IMPL_OFFSET>,
            GetMediaTypeByIndex: GetMediaTypeByIndex::<Impl, IMPL_OFFSET>,
            SetCurrentMediaType: SetCurrentMediaType::<Impl, IMPL_OFFSET>,
            GetCurrentMediaType: GetCurrentMediaType::<Impl, IMPL_OFFSET>,
            GetMajorType: GetMajorType::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMediaTypeHandler as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFMetadata_Impl: Sized {
    fn SetLanguage(&mut self, pwszrfc1766: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn GetLanguage(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
    fn GetAllLanguages(&mut self) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
    fn SetProperty(&mut self, pwszname: super::super::Foundation::PWSTR, ppvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()>;
    fn GetProperty(&mut self, pwszname: super::super::Foundation::PWSTR) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
    fn DeleteProperty(&mut self, pwszname: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn GetAllPropertyNames(&mut self) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFMetadata_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMetadata_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMetadata_Vtbl {
        unsafe extern "system" fn SetLanguage<Impl: IMFMetadata_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwszrfc1766: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLanguage(::core::mem::transmute_copy(&pwszrfc1766)).into()
        }
        unsafe extern "system" fn GetLanguage<Impl: IMFMetadata_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppwszrfc1766: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLanguage() {
                ::core::result::Result::Ok(ok__) => {
                    *ppwszrfc1766 = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAllLanguages<Impl: IMFMetadata_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppvlanguages: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAllLanguages() {
                ::core::result::Result::Ok(ok__) => {
                    *ppvlanguages = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProperty<Impl: IMFMetadata_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwszname: super::super::Foundation::PWSTR, ppvvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetProperty(::core::mem::transmute_copy(&pwszname), ::core::mem::transmute_copy(&ppvvalue)).into()
        }
        unsafe extern "system" fn GetProperty<Impl: IMFMetadata_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwszname: super::super::Foundation::PWSTR, ppvvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProperty(::core::mem::transmute_copy(&pwszname)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppvvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DeleteProperty<Impl: IMFMetadata_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwszname: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DeleteProperty(::core::mem::transmute_copy(&pwszname)).into()
        }
        unsafe extern "system" fn GetAllPropertyNames<Impl: IMFMetadata_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppvnames: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAllPropertyNames() {
                ::core::result::Result::Ok(ok__) => {
                    *ppvnames = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetLanguage: SetLanguage::<Impl, IMPL_OFFSET>,
            GetLanguage: GetLanguage::<Impl, IMPL_OFFSET>,
            GetAllLanguages: GetAllLanguages::<Impl, IMPL_OFFSET>,
            SetProperty: SetProperty::<Impl, IMPL_OFFSET>,
            GetProperty: GetProperty::<Impl, IMPL_OFFSET>,
            DeleteProperty: DeleteProperty::<Impl, IMPL_OFFSET>,
            GetAllPropertyNames: GetAllPropertyNames::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMetadata as ::windows::core::Interface>::IID
    }
}
pub trait IMFMetadataProvider_Impl: Sized {
    fn GetMFMetadata(&mut self, ppresentationdescriptor: ::core::option::Option<IMFPresentationDescriptor>, dwstreamidentifier: u32, dwflags: u32) -> ::windows::core::Result<IMFMetadata>;
}
impl IMFMetadataProvider_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMetadataProvider_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMetadataProvider_Vtbl {
        unsafe extern "system" fn GetMFMetadata<Impl: IMFMetadataProvider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppresentationdescriptor: ::windows::core::RawPtr, dwstreamidentifier: u32, dwflags: u32, ppmfmetadata: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMFMetadata(::core::mem::transmute(&ppresentationdescriptor), ::core::mem::transmute_copy(&dwstreamidentifier), ::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppmfmetadata = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetMFMetadata: GetMFMetadata::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMetadataProvider as ::windows::core::Interface>::IID
    }
}
pub trait IMFMuxStreamAttributesManager_Impl: Sized {
    fn GetStreamCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetAttributes(&mut self, dwmuxstreamindex: u32) -> ::windows::core::Result<IMFAttributes>;
}
impl IMFMuxStreamAttributesManager_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMuxStreamAttributesManager_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMuxStreamAttributesManager_Vtbl {
        unsafe extern "system" fn GetStreamCount<Impl: IMFMuxStreamAttributesManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwmuxstreamcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwmuxstreamcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAttributes<Impl: IMFMuxStreamAttributesManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwmuxstreamindex: u32, ppstreamattributes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAttributes(::core::mem::transmute_copy(&dwmuxstreamindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppstreamattributes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetStreamCount: GetStreamCount::<Impl, IMPL_OFFSET>,
            GetAttributes: GetAttributes::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMuxStreamAttributesManager as ::windows::core::Interface>::IID
    }
}
pub trait IMFMuxStreamMediaTypeManager_Impl: Sized {
    fn GetStreamCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetMediaType(&mut self, dwmuxstreamindex: u32) -> ::windows::core::Result<IMFMediaType>;
    fn GetStreamConfigurationCount(&mut self) -> ::windows::core::Result<u32>;
    fn AddStreamConfiguration(&mut self, ullstreammask: u64) -> ::windows::core::Result<()>;
    fn RemoveStreamConfiguration(&mut self, ullstreammask: u64) -> ::windows::core::Result<()>;
    fn GetStreamConfiguration(&mut self, ulindex: u32) -> ::windows::core::Result<u64>;
}
impl IMFMuxStreamMediaTypeManager_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMuxStreamMediaTypeManager_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMuxStreamMediaTypeManager_Vtbl {
        unsafe extern "system" fn GetStreamCount<Impl: IMFMuxStreamMediaTypeManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwmuxstreamcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwmuxstreamcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaType<Impl: IMFMuxStreamMediaTypeManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwmuxstreamindex: u32, ppmediatype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMediaType(::core::mem::transmute_copy(&dwmuxstreamindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediatype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamConfigurationCount<Impl: IMFMuxStreamMediaTypeManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamConfigurationCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddStreamConfiguration<Impl: IMFMuxStreamMediaTypeManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ullstreammask: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddStreamConfiguration(::core::mem::transmute_copy(&ullstreammask)).into()
        }
        unsafe extern "system" fn RemoveStreamConfiguration<Impl: IMFMuxStreamMediaTypeManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ullstreammask: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveStreamConfiguration(::core::mem::transmute_copy(&ullstreammask)).into()
        }
        unsafe extern "system" fn GetStreamConfiguration<Impl: IMFMuxStreamMediaTypeManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulindex: u32, pullstreammask: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamConfiguration(::core::mem::transmute_copy(&ulindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pullstreammask = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetStreamCount: GetStreamCount::<Impl, IMPL_OFFSET>,
            GetMediaType: GetMediaType::<Impl, IMPL_OFFSET>,
            GetStreamConfigurationCount: GetStreamConfigurationCount::<Impl, IMPL_OFFSET>,
            AddStreamConfiguration: AddStreamConfiguration::<Impl, IMPL_OFFSET>,
            RemoveStreamConfiguration: RemoveStreamConfiguration::<Impl, IMPL_OFFSET>,
            GetStreamConfiguration: GetStreamConfiguration::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMuxStreamMediaTypeManager as ::windows::core::Interface>::IID
    }
}
pub trait IMFMuxStreamSampleManager_Impl: Sized {
    fn GetStreamCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetSample(&mut self, dwmuxstreamindex: u32) -> ::windows::core::Result<IMFSample>;
    fn GetStreamConfiguration(&mut self) -> u64;
}
impl IMFMuxStreamSampleManager_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFMuxStreamSampleManager_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFMuxStreamSampleManager_Vtbl {
        unsafe extern "system" fn GetStreamCount<Impl: IMFMuxStreamSampleManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwmuxstreamcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwmuxstreamcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSample<Impl: IMFMuxStreamSampleManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwmuxstreamindex: u32, ppsample: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSample(::core::mem::transmute_copy(&dwmuxstreamindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppsample = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamConfiguration<Impl: IMFMuxStreamSampleManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u64 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetStreamConfiguration()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetStreamCount: GetStreamCount::<Impl, IMPL_OFFSET>,
            GetSample: GetSample::<Impl, IMPL_OFFSET>,
            GetStreamConfiguration: GetStreamConfiguration::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFMuxStreamSampleManager as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFNetCredential_Impl: Sized {
    fn SetUser(&mut self, pbdata: *const u8, cbdata: u32, fdataisencrypted: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn SetPassword(&mut self, pbdata: *const u8, cbdata: u32, fdataisencrypted: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetUser(&mut self, pbdata: *mut u8, pcbdata: *mut u32, fencryptdata: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetPassword(&mut self, pbdata: *mut u8, pcbdata: *mut u32, fencryptdata: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn LoggedOnUser(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFNetCredential_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFNetCredential_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFNetCredential_Vtbl {
        unsafe extern "system" fn SetUser<Impl: IMFNetCredential_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbdata: *const u8, cbdata: u32, fdataisencrypted: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUser(::core::mem::transmute_copy(&pbdata), ::core::mem::transmute_copy(&cbdata), ::core::mem::transmute_copy(&fdataisencrypted)).into()
        }
        unsafe extern "system" fn SetPassword<Impl: IMFNetCredential_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbdata: *const u8, cbdata: u32, fdataisencrypted: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPassword(::core::mem::transmute_copy(&pbdata), ::core::mem::transmute_copy(&cbdata), ::core::mem::transmute_copy(&fdataisencrypted)).into()
        }
        unsafe extern "system" fn GetUser<Impl: IMFNetCredential_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbdata: *mut u8, pcbdata: *mut u32, fencryptdata: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetUser(::core::mem::transmute_copy(&pbdata), ::core::mem::transmute_copy(&pcbdata), ::core::mem::transmute_copy(&fencryptdata)).into()
        }
        unsafe extern "system" fn GetPassword<Impl: IMFNetCredential_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbdata: *mut u8, pcbdata: *mut u32, fencryptdata: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPassword(::core::mem::transmute_copy(&pbdata), ::core::mem::transmute_copy(&pcbdata), ::core::mem::transmute_copy(&fencryptdata)).into()
        }
        unsafe extern "system" fn LoggedOnUser<Impl: IMFNetCredential_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfloggedonuser: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).LoggedOnUser() {
                ::core::result::Result::Ok(ok__) => {
                    *pfloggedonuser = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetUser: SetUser::<Impl, IMPL_OFFSET>,
            SetPassword: SetPassword::<Impl, IMPL_OFFSET>,
            GetUser: GetUser::<Impl, IMPL_OFFSET>,
            GetPassword: GetPassword::<Impl, IMPL_OFFSET>,
            LoggedOnUser: LoggedOnUser::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFNetCredential as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFNetCredentialCache_Impl: Sized {
    fn GetCredential(&mut self, pszurl: super::super::Foundation::PWSTR, pszrealm: super::super::Foundation::PWSTR, dwauthenticationflags: u32, ppcred: *mut ::core::option::Option<IMFNetCredential>, pdwrequirementsflags: *mut u32) -> ::windows::core::Result<()>;
    fn SetGood(&mut self, pcred: ::core::option::Option<IMFNetCredential>, fgood: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn SetUserOptions(&mut self, pcred: ::core::option::Option<IMFNetCredential>, dwoptionsflags: u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFNetCredentialCache_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFNetCredentialCache_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFNetCredentialCache_Vtbl {
        unsafe extern "system" fn GetCredential<Impl: IMFNetCredentialCache_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszurl: super::super::Foundation::PWSTR, pszrealm: super::super::Foundation::PWSTR, dwauthenticationflags: u32, ppcred: *mut ::windows::core::RawPtr, pdwrequirementsflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCredential(::core::mem::transmute_copy(&pszurl), ::core::mem::transmute_copy(&pszrealm), ::core::mem::transmute_copy(&dwauthenticationflags), ::core::mem::transmute_copy(&ppcred), ::core::mem::transmute_copy(&pdwrequirementsflags)).into()
        }
        unsafe extern "system" fn SetGood<Impl: IMFNetCredentialCache_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcred: ::windows::core::RawPtr, fgood: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGood(::core::mem::transmute(&pcred), ::core::mem::transmute_copy(&fgood)).into()
        }
        unsafe extern "system" fn SetUserOptions<Impl: IMFNetCredentialCache_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcred: ::windows::core::RawPtr, dwoptionsflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUserOptions(::core::mem::transmute(&pcred), ::core::mem::transmute_copy(&dwoptionsflags)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetCredential: GetCredential::<Impl, IMPL_OFFSET>,
            SetGood: SetGood::<Impl, IMPL_OFFSET>,
            SetUserOptions: SetUserOptions::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFNetCredentialCache as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFNetCredentialManager_Impl: Sized {
    fn BeginGetCredentials(&mut self, pparam: *const MFNetCredentialManagerGetParam, pcallback: ::core::option::Option<IMFAsyncCallback>, pstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndGetCredentials(&mut self, presult: ::core::option::Option<IMFAsyncResult>) -> ::windows::core::Result<IMFNetCredential>;
    fn SetGood(&mut self, pcred: ::core::option::Option<IMFNetCredential>, fgood: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFNetCredentialManager_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFNetCredentialManager_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFNetCredentialManager_Vtbl {
        unsafe extern "system" fn BeginGetCredentials<Impl: IMFNetCredentialManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pparam: *const MFNetCredentialManagerGetParam, pcallback: ::windows::core::RawPtr, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginGetCredentials(::core::mem::transmute_copy(&pparam), ::core::mem::transmute(&pcallback), ::core::mem::transmute(&pstate)).into()
        }
        unsafe extern "system" fn EndGetCredentials<Impl: IMFNetCredentialManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, ppcred: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EndGetCredentials(::core::mem::transmute(&presult)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppcred = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetGood<Impl: IMFNetCredentialManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcred: ::windows::core::RawPtr, fgood: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetGood(::core::mem::transmute(&pcred), ::core::mem::transmute_copy(&fgood)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            BeginGetCredentials: BeginGetCredentials::<Impl, IMPL_OFFSET>,
            EndGetCredentials: EndGetCredentials::<Impl, IMPL_OFFSET>,
            SetGood: SetGood::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFNetCredentialManager as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFNetCrossOriginSupport_Impl: Sized {
    fn GetCrossOriginPolicy(&mut self) -> ::windows::core::Result<MF_CROSS_ORIGIN_POLICY>;
    fn GetSourceOrigin(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
    fn IsSameOrigin(&mut self, wszurl: super::super::Foundation::PWSTR) -> ::windows::core::Result<super::super::Foundation::BOOL>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFNetCrossOriginSupport_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFNetCrossOriginSupport_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFNetCrossOriginSupport_Vtbl {
        unsafe extern "system" fn GetCrossOriginPolicy<Impl: IMFNetCrossOriginSupport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppolicy: *mut MF_CROSS_ORIGIN_POLICY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCrossOriginPolicy() {
                ::core::result::Result::Ok(ok__) => {
                    *ppolicy = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceOrigin<Impl: IMFNetCrossOriginSupport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wszsourceorigin: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSourceOrigin() {
                ::core::result::Result::Ok(ok__) => {
                    *wszsourceorigin = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsSameOrigin<Impl: IMFNetCrossOriginSupport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wszurl: super::super::Foundation::PWSTR, pfissameorigin: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsSameOrigin(::core::mem::transmute_copy(&wszurl)) {
                ::core::result::Result::Ok(ok__) => {
                    *pfissameorigin = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetCrossOriginPolicy: GetCrossOriginPolicy::<Impl, IMPL_OFFSET>,
            GetSourceOrigin: GetSourceOrigin::<Impl, IMPL_OFFSET>,
            IsSameOrigin: IsSameOrigin::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFNetCrossOriginSupport as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFNetProxyLocator_Impl: Sized {
    fn FindFirstProxy(&mut self, pszhost: super::super::Foundation::PWSTR, pszurl: super::super::Foundation::PWSTR, freserved: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn FindNextProxy(&mut self) -> ::windows::core::Result<()>;
    fn RegisterProxyResult(&mut self, hrop: ::windows::core::HRESULT) -> ::windows::core::Result<()>;
    fn GetCurrentProxy(&mut self, pszstr: super::super::Foundation::PWSTR, pcchstr: *mut u32) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<IMFNetProxyLocator>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFNetProxyLocator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFNetProxyLocator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFNetProxyLocator_Vtbl {
        unsafe extern "system" fn FindFirstProxy<Impl: IMFNetProxyLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszhost: super::super::Foundation::PWSTR, pszurl: super::super::Foundation::PWSTR, freserved: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).FindFirstProxy(::core::mem::transmute_copy(&pszhost), ::core::mem::transmute_copy(&pszurl), ::core::mem::transmute_copy(&freserved)).into()
        }
        unsafe extern "system" fn FindNextProxy<Impl: IMFNetProxyLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).FindNextProxy().into()
        }
        unsafe extern "system" fn RegisterProxyResult<Impl: IMFNetProxyLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hrop: ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterProxyResult(::core::mem::transmute_copy(&hrop)).into()
        }
        unsafe extern "system" fn GetCurrentProxy<Impl: IMFNetProxyLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszstr: super::super::Foundation::PWSTR, pcchstr: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrentProxy(::core::mem::transmute_copy(&pszstr), ::core::mem::transmute_copy(&pcchstr)).into()
        }
        unsafe extern "system" fn Clone<Impl: IMFNetProxyLocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppproxylocator: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *ppproxylocator = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            FindFirstProxy: FindFirstProxy::<Impl, IMPL_OFFSET>,
            FindNextProxy: FindNextProxy::<Impl, IMPL_OFFSET>,
            RegisterProxyResult: RegisterProxyResult::<Impl, IMPL_OFFSET>,
            GetCurrentProxy: GetCurrentProxy::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFNetProxyLocator as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFNetProxyLocatorFactory_Impl: Sized {
    fn CreateProxyLocator(&mut self, pszprotocol: super::super::Foundation::PWSTR) -> ::windows::core::Result<IMFNetProxyLocator>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFNetProxyLocatorFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFNetProxyLocatorFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFNetProxyLocatorFactory_Vtbl {
        unsafe extern "system" fn CreateProxyLocator<Impl: IMFNetProxyLocatorFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszprotocol: super::super::Foundation::PWSTR, ppproxylocator: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateProxyLocator(::core::mem::transmute_copy(&pszprotocol)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppproxylocator = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), CreateProxyLocator: CreateProxyLocator::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFNetProxyLocatorFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFNetResourceFilter_Impl: Sized {
    fn OnRedirect(&mut self, pszurl: super::super::Foundation::PWSTR) -> ::windows::core::Result<i16>;
    fn OnSendingRequest(&mut self, pszurl: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFNetResourceFilter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFNetResourceFilter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFNetResourceFilter_Vtbl {
        unsafe extern "system" fn OnRedirect<Impl: IMFNetResourceFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszurl: super::super::Foundation::PWSTR, pvbcancel: *mut i16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OnRedirect(::core::mem::transmute_copy(&pszurl)) {
                ::core::result::Result::Ok(ok__) => {
                    *pvbcancel = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OnSendingRequest<Impl: IMFNetResourceFilter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszurl: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnSendingRequest(::core::mem::transmute_copy(&pszurl)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            OnRedirect: OnRedirect::<Impl, IMPL_OFFSET>,
            OnSendingRequest: OnSendingRequest::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFNetResourceFilter as ::windows::core::Interface>::IID
    }
}
pub trait IMFNetSchemeHandlerConfig_Impl: Sized {
    fn GetNumberOfSupportedProtocols(&mut self) -> ::windows::core::Result<u32>;
    fn GetSupportedProtocolType(&mut self, nprotocolindex: u32) -> ::windows::core::Result<MFNETSOURCE_PROTOCOL_TYPE>;
    fn ResetProtocolRolloverSettings(&mut self) -> ::windows::core::Result<()>;
}
impl IMFNetSchemeHandlerConfig_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFNetSchemeHandlerConfig_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFNetSchemeHandlerConfig_Vtbl {
        unsafe extern "system" fn GetNumberOfSupportedProtocols<Impl: IMFNetSchemeHandlerConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcprotocols: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNumberOfSupportedProtocols() {
                ::core::result::Result::Ok(ok__) => {
                    *pcprotocols = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSupportedProtocolType<Impl: IMFNetSchemeHandlerConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, nprotocolindex: u32, pnprotocoltype: *mut MFNETSOURCE_PROTOCOL_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSupportedProtocolType(::core::mem::transmute_copy(&nprotocolindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pnprotocoltype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ResetProtocolRolloverSettings<Impl: IMFNetSchemeHandlerConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ResetProtocolRolloverSettings().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetNumberOfSupportedProtocols: GetNumberOfSupportedProtocols::<Impl, IMPL_OFFSET>,
            GetSupportedProtocolType: GetSupportedProtocolType::<Impl, IMPL_OFFSET>,
            ResetProtocolRolloverSettings: ResetProtocolRolloverSettings::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFNetSchemeHandlerConfig as ::windows::core::Interface>::IID
    }
}
pub trait IMFObjectReferenceStream_Impl: Sized {
    fn SaveReference(&mut self, riid: *const ::windows::core::GUID, punk: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn LoadReference(&mut self, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
impl IMFObjectReferenceStream_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFObjectReferenceStream_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFObjectReferenceStream_Vtbl {
        unsafe extern "system" fn SaveReference<Impl: IMFObjectReferenceStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, punk: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SaveReference(::core::mem::transmute_copy(&riid), ::core::mem::transmute(&punk)).into()
        }
        unsafe extern "system" fn LoadReference<Impl: IMFObjectReferenceStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LoadReference(::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppv)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SaveReference: SaveReference::<Impl, IMPL_OFFSET>,
            LoadReference: LoadReference::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFObjectReferenceStream as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFOutputPolicy_Impl: Sized + IMFAttributes_Impl {
    fn GenerateRequiredSchemas(&mut self, dwattributes: u32, guidoutputsubtype: ::windows::core::GUID, rgguidprotectionschemassupported: *const ::windows::core::GUID, cprotectionschemassupported: u32) -> ::windows::core::Result<IMFCollection>;
    fn GetOriginatorID(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn GetMinimumGRLVersion(&mut self) -> ::windows::core::Result<u32>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFOutputPolicy_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFOutputPolicy_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFOutputPolicy_Vtbl {
        unsafe extern "system" fn GenerateRequiredSchemas<Impl: IMFOutputPolicy_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwattributes: u32, guidoutputsubtype: ::windows::core::GUID, rgguidprotectionschemassupported: *const ::windows::core::GUID, cprotectionschemassupported: u32, pprequiredprotectionschemas: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GenerateRequiredSchemas(::core::mem::transmute_copy(&dwattributes), ::core::mem::transmute_copy(&guidoutputsubtype), ::core::mem::transmute_copy(&rgguidprotectionschemassupported), ::core::mem::transmute_copy(&cprotectionschemassupported)) {
                ::core::result::Result::Ok(ok__) => {
                    *pprequiredprotectionschemas = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginatorID<Impl: IMFOutputPolicy_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguidoriginatorid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOriginatorID() {
                ::core::result::Result::Ok(ok__) => {
                    *pguidoriginatorid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMinimumGRLVersion<Impl: IMFOutputPolicy_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwminimumgrlversion: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMinimumGRLVersion() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwminimumgrlversion = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMFAttributes_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GenerateRequiredSchemas: GenerateRequiredSchemas::<Impl, IMPL_OFFSET>,
            GetOriginatorID: GetOriginatorID::<Impl, IMPL_OFFSET>,
            GetMinimumGRLVersion: GetMinimumGRLVersion::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFOutputPolicy as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFOutputSchema_Impl: Sized + IMFAttributes_Impl {
    fn GetSchemaType(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn GetConfigurationData(&mut self) -> ::windows::core::Result<u32>;
    fn GetOriginatorID(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFOutputSchema_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFOutputSchema_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFOutputSchema_Vtbl {
        unsafe extern "system" fn GetSchemaType<Impl: IMFOutputSchema_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguidschematype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSchemaType() {
                ::core::result::Result::Ok(ok__) => {
                    *pguidschematype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetConfigurationData<Impl: IMFOutputSchema_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwval: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetConfigurationData() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwval = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOriginatorID<Impl: IMFOutputSchema_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguidoriginatorid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOriginatorID() {
                ::core::result::Result::Ok(ok__) => {
                    *pguidoriginatorid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMFAttributes_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetSchemaType: GetSchemaType::<Impl, IMPL_OFFSET>,
            GetConfigurationData: GetConfigurationData::<Impl, IMPL_OFFSET>,
            GetOriginatorID: GetOriginatorID::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFOutputSchema as ::windows::core::Interface>::IID
    }
}
pub trait IMFOutputTrustAuthority_Impl: Sized {
    fn GetAction(&mut self) -> ::windows::core::Result<MFPOLICYMANAGER_ACTION>;
    fn SetPolicy(&mut self, pppolicy: *const ::core::option::Option<IMFOutputPolicy>, npolicy: u32, ppbticket: *mut *mut u8, pcbticket: *mut u32) -> ::windows::core::Result<()>;
}
impl IMFOutputTrustAuthority_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFOutputTrustAuthority_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFOutputTrustAuthority_Vtbl {
        unsafe extern "system" fn GetAction<Impl: IMFOutputTrustAuthority_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, paction: *mut MFPOLICYMANAGER_ACTION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAction() {
                ::core::result::Result::Ok(ok__) => {
                    *paction = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetPolicy<Impl: IMFOutputTrustAuthority_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pppolicy: *const ::windows::core::RawPtr, npolicy: u32, ppbticket: *mut *mut u8, pcbticket: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPolicy(::core::mem::transmute_copy(&pppolicy), ::core::mem::transmute_copy(&npolicy), ::core::mem::transmute_copy(&ppbticket), ::core::mem::transmute_copy(&pcbticket)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetAction: GetAction::<Impl, IMPL_OFFSET>,
            SetPolicy: SetPolicy::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFOutputTrustAuthority as ::windows::core::Interface>::IID
    }
}
pub trait IMFPMPClient_Impl: Sized {
    fn SetPMPHost(&mut self, ppmphost: ::core::option::Option<IMFPMPHost>) -> ::windows::core::Result<()>;
}
impl IMFPMPClient_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFPMPClient_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFPMPClient_Vtbl {
        unsafe extern "system" fn SetPMPHost<Impl: IMFPMPClient_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppmphost: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPMPHost(::core::mem::transmute(&ppmphost)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), SetPMPHost: SetPMPHost::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFPMPClient as ::windows::core::Interface>::IID
    }
}
pub trait IMFPMPClientApp_Impl: Sized {
    fn SetPMPHost(&mut self, ppmphost: ::core::option::Option<IMFPMPHostApp>) -> ::windows::core::Result<()>;
}
impl IMFPMPClientApp_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFPMPClientApp_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFPMPClientApp_Vtbl {
        unsafe extern "system" fn SetPMPHost<Impl: IMFPMPClientApp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppmphost: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPMPHost(::core::mem::transmute(&ppmphost)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), SetPMPHost: SetPMPHost::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFPMPClientApp as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_System_Com")]
pub trait IMFPMPHost_Impl: Sized {
    fn LockProcess(&mut self) -> ::windows::core::Result<()>;
    fn UnlockProcess(&mut self) -> ::windows::core::Result<()>;
    fn CreateObjectByCLSID(&mut self, clsid: *const ::windows::core::GUID, pstream: ::core::option::Option<super::super::System::Com::IStream>, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_System_Com")]
impl IMFPMPHost_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFPMPHost_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFPMPHost_Vtbl {
        unsafe extern "system" fn LockProcess<Impl: IMFPMPHost_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LockProcess().into()
        }
        unsafe extern "system" fn UnlockProcess<Impl: IMFPMPHost_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnlockProcess().into()
        }
        unsafe extern "system" fn CreateObjectByCLSID<Impl: IMFPMPHost_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clsid: *const ::windows::core::GUID, pstream: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateObjectByCLSID(::core::mem::transmute_copy(&clsid), ::core::mem::transmute(&pstream), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppv)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            LockProcess: LockProcess::<Impl, IMPL_OFFSET>,
            UnlockProcess: UnlockProcess::<Impl, IMPL_OFFSET>,
            CreateObjectByCLSID: CreateObjectByCLSID::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFPMPHost as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
pub trait IMFPMPHostApp_Impl: Sized {
    fn LockProcess(&mut self) -> ::windows::core::Result<()>;
    fn UnlockProcess(&mut self) -> ::windows::core::Result<()>;
    fn ActivateClassById(&mut self, id: super::super::Foundation::PWSTR, pstream: ::core::option::Option<super::super::System::Com::IStream>, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com"))]
impl IMFPMPHostApp_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFPMPHostApp_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFPMPHostApp_Vtbl {
        unsafe extern "system" fn LockProcess<Impl: IMFPMPHostApp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LockProcess().into()
        }
        unsafe extern "system" fn UnlockProcess<Impl: IMFPMPHostApp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnlockProcess().into()
        }
        unsafe extern "system" fn ActivateClassById<Impl: IMFPMPHostApp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, id: super::super::Foundation::PWSTR, pstream: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ActivateClassById(::core::mem::transmute_copy(&id), ::core::mem::transmute(&pstream), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppv)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            LockProcess: LockProcess::<Impl, IMPL_OFFSET>,
            UnlockProcess: UnlockProcess::<Impl, IMPL_OFFSET>,
            ActivateClassById: ActivateClassById::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFPMPHostApp as ::windows::core::Interface>::IID
    }
}
pub trait IMFPMPServer_Impl: Sized {
    fn LockProcess(&mut self) -> ::windows::core::Result<()>;
    fn UnlockProcess(&mut self) -> ::windows::core::Result<()>;
    fn CreateObjectByCLSID(&mut self, clsid: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
impl IMFPMPServer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFPMPServer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFPMPServer_Vtbl {
        unsafe extern "system" fn LockProcess<Impl: IMFPMPServer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LockProcess().into()
        }
        unsafe extern "system" fn UnlockProcess<Impl: IMFPMPServer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnlockProcess().into()
        }
        unsafe extern "system" fn CreateObjectByCLSID<Impl: IMFPMPServer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clsid: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateObjectByCLSID(::core::mem::transmute_copy(&clsid), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppobject)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            LockProcess: LockProcess::<Impl, IMPL_OFFSET>,
            UnlockProcess: UnlockProcess::<Impl, IMPL_OFFSET>,
            CreateObjectByCLSID: CreateObjectByCLSID::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFPMPServer as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage", feature = "Win32_UI_Shell_PropertiesSystem"))]
pub trait IMFPMediaItem_Impl: Sized {
    fn GetMediaPlayer(&mut self) -> ::windows::core::Result<IMFPMediaPlayer>;
    fn GetURL(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
    fn GetObject(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn GetUserData(&mut self) -> ::windows::core::Result<usize>;
    fn SetUserData(&mut self, dwuserdata: usize) -> ::windows::core::Result<()>;
    fn GetStartStopPosition(&mut self, pguidstartpositiontype: *mut ::windows::core::GUID, pvstartvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT, pguidstoppositiontype: *mut ::windows::core::GUID, pvstopvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()>;
    fn SetStartStopPosition(&mut self, pguidstartpositiontype: *const ::windows::core::GUID, pvstartvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pguidstoppositiontype: *const ::windows::core::GUID, pvstopvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()>;
    fn HasVideo(&mut self, pfhasvideo: *mut super::super::Foundation::BOOL, pfselected: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn HasAudio(&mut self, pfhasaudio: *mut super::super::Foundation::BOOL, pfselected: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn IsProtected(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetDuration(&mut self, guidpositiontype: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
    fn GetNumberOfStreams(&mut self) -> ::windows::core::Result<u32>;
    fn GetStreamSelection(&mut self, dwstreamindex: u32) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn SetStreamSelection(&mut self, dwstreamindex: u32, fenabled: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetStreamAttribute(&mut self, dwstreamindex: u32, guidmfattribute: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
    fn GetPresentationAttribute(&mut self, guidmfattribute: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
    fn GetCharacteristics(&mut self) -> ::windows::core::Result<u32>;
    fn SetStreamSink(&mut self, dwstreamindex: u32, pmediasink: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn GetMetadata(&mut self) -> ::windows::core::Result<super::super::UI::Shell::PropertiesSystem::IPropertyStore>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage", feature = "Win32_UI_Shell_PropertiesSystem"))]
impl IMFPMediaItem_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFPMediaItem_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFPMediaItem_Vtbl {
        unsafe extern "system" fn GetMediaPlayer<Impl: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppmediaplayer: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMediaPlayer() {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediaplayer = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetURL<Impl: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppwszurl: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetURL() {
                ::core::result::Result::Ok(ok__) => {
                    *ppwszurl = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetObject<Impl: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppiunknown: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetObject() {
                ::core::result::Result::Ok(ok__) => {
                    *ppiunknown = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetUserData<Impl: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwuserdata: *mut usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetUserData() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwuserdata = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetUserData<Impl: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwuserdata: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUserData(::core::mem::transmute_copy(&dwuserdata)).into()
        }
        unsafe extern "system" fn GetStartStopPosition<Impl: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguidstartpositiontype: *mut ::windows::core::GUID, pvstartvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT, pguidstoppositiontype: *mut ::windows::core::GUID, pvstopvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetStartStopPosition(::core::mem::transmute_copy(&pguidstartpositiontype), ::core::mem::transmute_copy(&pvstartvalue), ::core::mem::transmute_copy(&pguidstoppositiontype), ::core::mem::transmute_copy(&pvstopvalue)).into()
        }
        unsafe extern "system" fn SetStartStopPosition<Impl: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguidstartpositiontype: *const ::windows::core::GUID, pvstartvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pguidstoppositiontype: *const ::windows::core::GUID, pvstopvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStartStopPosition(::core::mem::transmute_copy(&pguidstartpositiontype), ::core::mem::transmute_copy(&pvstartvalue), ::core::mem::transmute_copy(&pguidstoppositiontype), ::core::mem::transmute_copy(&pvstopvalue)).into()
        }
        unsafe extern "system" fn HasVideo<Impl: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfhasvideo: *mut super::super::Foundation::BOOL, pfselected: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).HasVideo(::core::mem::transmute_copy(&pfhasvideo), ::core::mem::transmute_copy(&pfselected)).into()
        }
        unsafe extern "system" fn HasAudio<Impl: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfhasaudio: *mut super::super::Foundation::BOOL, pfselected: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).HasAudio(::core::mem::transmute_copy(&pfhasaudio), ::core::mem::transmute_copy(&pfselected)).into()
        }
        unsafe extern "system" fn IsProtected<Impl: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfprotected: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsProtected() {
                ::core::result::Result::Ok(ok__) => {
                    *pfprotected = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDuration<Impl: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidpositiontype: *const ::windows::core::GUID, pvdurationvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDuration(::core::mem::transmute_copy(&guidpositiontype)) {
                ::core::result::Result::Ok(ok__) => {
                    *pvdurationvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNumberOfStreams<Impl: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwstreamcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNumberOfStreams() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwstreamcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamSelection<Impl: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pfenabled: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamSelection(::core::mem::transmute_copy(&dwstreamindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pfenabled = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamSelection<Impl: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, fenabled: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStreamSelection(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&fenabled)).into()
        }
        unsafe extern "system" fn GetStreamAttribute<Impl: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, guidmfattribute: *const ::windows::core::GUID, pvvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamAttribute(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&guidmfattribute)) {
                ::core::result::Result::Ok(ok__) => {
                    *pvvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPresentationAttribute<Impl: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidmfattribute: *const ::windows::core::GUID, pvvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPresentationAttribute(::core::mem::transmute_copy(&guidmfattribute)) {
                ::core::result::Result::Ok(ok__) => {
                    *pvvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCharacteristics<Impl: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcharacteristics: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCharacteristics() {
                ::core::result::Result::Ok(ok__) => {
                    *pcharacteristics = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamSink<Impl: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pmediasink: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStreamSink(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute(&pmediasink)).into()
        }
        unsafe extern "system" fn GetMetadata<Impl: IMFPMediaItem_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppmetadatastore: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMetadata() {
                ::core::result::Result::Ok(ok__) => {
                    *ppmetadatastore = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetMediaPlayer: GetMediaPlayer::<Impl, IMPL_OFFSET>,
            GetURL: GetURL::<Impl, IMPL_OFFSET>,
            GetObject: GetObject::<Impl, IMPL_OFFSET>,
            GetUserData: GetUserData::<Impl, IMPL_OFFSET>,
            SetUserData: SetUserData::<Impl, IMPL_OFFSET>,
            GetStartStopPosition: GetStartStopPosition::<Impl, IMPL_OFFSET>,
            SetStartStopPosition: SetStartStopPosition::<Impl, IMPL_OFFSET>,
            HasVideo: HasVideo::<Impl, IMPL_OFFSET>,
            HasAudio: HasAudio::<Impl, IMPL_OFFSET>,
            IsProtected: IsProtected::<Impl, IMPL_OFFSET>,
            GetDuration: GetDuration::<Impl, IMPL_OFFSET>,
            GetNumberOfStreams: GetNumberOfStreams::<Impl, IMPL_OFFSET>,
            GetStreamSelection: GetStreamSelection::<Impl, IMPL_OFFSET>,
            SetStreamSelection: SetStreamSelection::<Impl, IMPL_OFFSET>,
            GetStreamAttribute: GetStreamAttribute::<Impl, IMPL_OFFSET>,
            GetPresentationAttribute: GetPresentationAttribute::<Impl, IMPL_OFFSET>,
            GetCharacteristics: GetCharacteristics::<Impl, IMPL_OFFSET>,
            SetStreamSink: SetStreamSink::<Impl, IMPL_OFFSET>,
            GetMetadata: GetMetadata::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFPMediaItem as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFPMediaPlayer_Impl: Sized {
    fn Play(&mut self) -> ::windows::core::Result<()>;
    fn Pause(&mut self) -> ::windows::core::Result<()>;
    fn Stop(&mut self) -> ::windows::core::Result<()>;
    fn FrameStep(&mut self) -> ::windows::core::Result<()>;
    fn SetPosition(&mut self, guidpositiontype: *const ::windows::core::GUID, pvpositionvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()>;
    fn GetPosition(&mut self, guidpositiontype: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
    fn GetDuration(&mut self, guidpositiontype: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
    fn SetRate(&mut self, flrate: f32) -> ::windows::core::Result<()>;
    fn GetRate(&mut self) -> ::windows::core::Result<f32>;
    fn GetSupportedRates(&mut self, fforwarddirection: super::super::Foundation::BOOL, pflslowestrate: *mut f32, pflfastestrate: *mut f32) -> ::windows::core::Result<()>;
    fn GetState(&mut self) -> ::windows::core::Result<MFP_MEDIAPLAYER_STATE>;
    fn CreateMediaItemFromURL(&mut self, pwszurl: super::super::Foundation::PWSTR, fsync: super::super::Foundation::BOOL, dwuserdata: usize) -> ::windows::core::Result<IMFPMediaItem>;
    fn CreateMediaItemFromObject(&mut self, piunknownobj: ::core::option::Option<::windows::core::IUnknown>, fsync: super::super::Foundation::BOOL, dwuserdata: usize) -> ::windows::core::Result<IMFPMediaItem>;
    fn SetMediaItem(&mut self, pimfpmediaitem: ::core::option::Option<IMFPMediaItem>) -> ::windows::core::Result<()>;
    fn ClearMediaItem(&mut self) -> ::windows::core::Result<()>;
    fn GetMediaItem(&mut self) -> ::windows::core::Result<IMFPMediaItem>;
    fn GetVolume(&mut self) -> ::windows::core::Result<f32>;
    fn SetVolume(&mut self, flvolume: f32) -> ::windows::core::Result<()>;
    fn GetBalance(&mut self) -> ::windows::core::Result<f32>;
    fn SetBalance(&mut self, flbalance: f32) -> ::windows::core::Result<()>;
    fn GetMute(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn SetMute(&mut self, fmute: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetNativeVideoSize(&mut self, pszvideo: *mut super::super::Foundation::SIZE, pszarvideo: *mut super::super::Foundation::SIZE) -> ::windows::core::Result<()>;
    fn GetIdealVideoSize(&mut self, pszmin: *mut super::super::Foundation::SIZE, pszmax: *mut super::super::Foundation::SIZE) -> ::windows::core::Result<()>;
    fn SetVideoSourceRect(&mut self, pnrcsource: *const MFVideoNormalizedRect) -> ::windows::core::Result<()>;
    fn GetVideoSourceRect(&mut self) -> ::windows::core::Result<MFVideoNormalizedRect>;
    fn SetAspectRatioMode(&mut self, dwaspectratiomode: u32) -> ::windows::core::Result<()>;
    fn GetAspectRatioMode(&mut self) -> ::windows::core::Result<u32>;
    fn GetVideoWindow(&mut self) -> ::windows::core::Result<super::super::Foundation::HWND>;
    fn UpdateVideo(&mut self) -> ::windows::core::Result<()>;
    fn SetBorderColor(&mut self, clr: u32) -> ::windows::core::Result<()>;
    fn GetBorderColor(&mut self) -> ::windows::core::Result<u32>;
    fn InsertEffect(&mut self, peffect: ::core::option::Option<::windows::core::IUnknown>, foptional: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn RemoveEffect(&mut self, peffect: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn RemoveAllEffects(&mut self) -> ::windows::core::Result<()>;
    fn Shutdown(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFPMediaPlayer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFPMediaPlayer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFPMediaPlayer_Vtbl {
        unsafe extern "system" fn Play<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Play().into()
        }
        unsafe extern "system" fn Pause<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Pause().into()
        }
        unsafe extern "system" fn Stop<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        unsafe extern "system" fn FrameStep<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).FrameStep().into()
        }
        unsafe extern "system" fn SetPosition<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidpositiontype: *const ::windows::core::GUID, pvpositionvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPosition(::core::mem::transmute_copy(&guidpositiontype), ::core::mem::transmute_copy(&pvpositionvalue)).into()
        }
        unsafe extern "system" fn GetPosition<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidpositiontype: *const ::windows::core::GUID, pvpositionvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPosition(::core::mem::transmute_copy(&guidpositiontype)) {
                ::core::result::Result::Ok(ok__) => {
                    *pvpositionvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDuration<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidpositiontype: *const ::windows::core::GUID, pvdurationvalue: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDuration(::core::mem::transmute_copy(&guidpositiontype)) {
                ::core::result::Result::Ok(ok__) => {
                    *pvdurationvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRate<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, flrate: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRate(::core::mem::transmute_copy(&flrate)).into()
        }
        unsafe extern "system" fn GetRate<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pflrate: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRate() {
                ::core::result::Result::Ok(ok__) => {
                    *pflrate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSupportedRates<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fforwarddirection: super::super::Foundation::BOOL, pflslowestrate: *mut f32, pflfastestrate: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSupportedRates(::core::mem::transmute_copy(&fforwarddirection), ::core::mem::transmute_copy(&pflslowestrate), ::core::mem::transmute_copy(&pflfastestrate)).into()
        }
        unsafe extern "system" fn GetState<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pestate: *mut MFP_MEDIAPLAYER_STATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetState() {
                ::core::result::Result::Ok(ok__) => {
                    *pestate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateMediaItemFromURL<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwszurl: super::super::Foundation::PWSTR, fsync: super::super::Foundation::BOOL, dwuserdata: usize, ppmediaitem: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateMediaItemFromURL(::core::mem::transmute_copy(&pwszurl), ::core::mem::transmute_copy(&fsync), ::core::mem::transmute_copy(&dwuserdata)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediaitem = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateMediaItemFromObject<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, piunknownobj: *mut ::core::ffi::c_void, fsync: super::super::Foundation::BOOL, dwuserdata: usize, ppmediaitem: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateMediaItemFromObject(::core::mem::transmute(&piunknownobj), ::core::mem::transmute_copy(&fsync), ::core::mem::transmute_copy(&dwuserdata)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediaitem = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMediaItem<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pimfpmediaitem: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMediaItem(::core::mem::transmute(&pimfpmediaitem)).into()
        }
        unsafe extern "system" fn ClearMediaItem<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ClearMediaItem().into()
        }
        unsafe extern "system" fn GetMediaItem<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppimfpmediaitem: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMediaItem() {
                ::core::result::Result::Ok(ok__) => {
                    *ppimfpmediaitem = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVolume<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pflvolume: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVolume() {
                ::core::result::Result::Ok(ok__) => {
                    *pflvolume = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVolume<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, flvolume: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVolume(::core::mem::transmute_copy(&flvolume)).into()
        }
        unsafe extern "system" fn GetBalance<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pflbalance: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBalance() {
                ::core::result::Result::Ok(ok__) => {
                    *pflbalance = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBalance<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, flbalance: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBalance(::core::mem::transmute_copy(&flbalance)).into()
        }
        unsafe extern "system" fn GetMute<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfmute: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMute() {
                ::core::result::Result::Ok(ok__) => {
                    *pfmute = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMute<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fmute: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMute(::core::mem::transmute_copy(&fmute)).into()
        }
        unsafe extern "system" fn GetNativeVideoSize<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszvideo: *mut super::super::Foundation::SIZE, pszarvideo: *mut super::super::Foundation::SIZE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNativeVideoSize(::core::mem::transmute_copy(&pszvideo), ::core::mem::transmute_copy(&pszarvideo)).into()
        }
        unsafe extern "system" fn GetIdealVideoSize<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszmin: *mut super::super::Foundation::SIZE, pszmax: *mut super::super::Foundation::SIZE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetIdealVideoSize(::core::mem::transmute_copy(&pszmin), ::core::mem::transmute_copy(&pszmax)).into()
        }
        unsafe extern "system" fn SetVideoSourceRect<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pnrcsource: *const MFVideoNormalizedRect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVideoSourceRect(::core::mem::transmute_copy(&pnrcsource)).into()
        }
        unsafe extern "system" fn GetVideoSourceRect<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pnrcsource: *mut MFVideoNormalizedRect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVideoSourceRect() {
                ::core::result::Result::Ok(ok__) => {
                    *pnrcsource = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetAspectRatioMode<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwaspectratiomode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAspectRatioMode(::core::mem::transmute_copy(&dwaspectratiomode)).into()
        }
        unsafe extern "system" fn GetAspectRatioMode<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwaspectratiomode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAspectRatioMode() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwaspectratiomode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoWindow<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phwndvideo: *mut super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVideoWindow() {
                ::core::result::Result::Ok(ok__) => {
                    *phwndvideo = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UpdateVideo<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UpdateVideo().into()
        }
        unsafe extern "system" fn SetBorderColor<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clr: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderColor(::core::mem::transmute_copy(&clr)).into()
        }
        unsafe extern "system" fn GetBorderColor<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pclr: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBorderColor() {
                ::core::result::Result::Ok(ok__) => {
                    *pclr = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InsertEffect<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, peffect: *mut ::core::ffi::c_void, foptional: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InsertEffect(::core::mem::transmute(&peffect), ::core::mem::transmute_copy(&foptional)).into()
        }
        unsafe extern "system" fn RemoveEffect<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, peffect: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveEffect(::core::mem::transmute(&peffect)).into()
        }
        unsafe extern "system" fn RemoveAllEffects<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveAllEffects().into()
        }
        unsafe extern "system" fn Shutdown<Impl: IMFPMediaPlayer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Shutdown().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Play: Play::<Impl, IMPL_OFFSET>,
            Pause: Pause::<Impl, IMPL_OFFSET>,
            Stop: Stop::<Impl, IMPL_OFFSET>,
            FrameStep: FrameStep::<Impl, IMPL_OFFSET>,
            SetPosition: SetPosition::<Impl, IMPL_OFFSET>,
            GetPosition: GetPosition::<Impl, IMPL_OFFSET>,
            GetDuration: GetDuration::<Impl, IMPL_OFFSET>,
            SetRate: SetRate::<Impl, IMPL_OFFSET>,
            GetRate: GetRate::<Impl, IMPL_OFFSET>,
            GetSupportedRates: GetSupportedRates::<Impl, IMPL_OFFSET>,
            GetState: GetState::<Impl, IMPL_OFFSET>,
            CreateMediaItemFromURL: CreateMediaItemFromURL::<Impl, IMPL_OFFSET>,
            CreateMediaItemFromObject: CreateMediaItemFromObject::<Impl, IMPL_OFFSET>,
            SetMediaItem: SetMediaItem::<Impl, IMPL_OFFSET>,
            ClearMediaItem: ClearMediaItem::<Impl, IMPL_OFFSET>,
            GetMediaItem: GetMediaItem::<Impl, IMPL_OFFSET>,
            GetVolume: GetVolume::<Impl, IMPL_OFFSET>,
            SetVolume: SetVolume::<Impl, IMPL_OFFSET>,
            GetBalance: GetBalance::<Impl, IMPL_OFFSET>,
            SetBalance: SetBalance::<Impl, IMPL_OFFSET>,
            GetMute: GetMute::<Impl, IMPL_OFFSET>,
            SetMute: SetMute::<Impl, IMPL_OFFSET>,
            GetNativeVideoSize: GetNativeVideoSize::<Impl, IMPL_OFFSET>,
            GetIdealVideoSize: GetIdealVideoSize::<Impl, IMPL_OFFSET>,
            SetVideoSourceRect: SetVideoSourceRect::<Impl, IMPL_OFFSET>,
            GetVideoSourceRect: GetVideoSourceRect::<Impl, IMPL_OFFSET>,
            SetAspectRatioMode: SetAspectRatioMode::<Impl, IMPL_OFFSET>,
            GetAspectRatioMode: GetAspectRatioMode::<Impl, IMPL_OFFSET>,
            GetVideoWindow: GetVideoWindow::<Impl, IMPL_OFFSET>,
            UpdateVideo: UpdateVideo::<Impl, IMPL_OFFSET>,
            SetBorderColor: SetBorderColor::<Impl, IMPL_OFFSET>,
            GetBorderColor: GetBorderColor::<Impl, IMPL_OFFSET>,
            InsertEffect: InsertEffect::<Impl, IMPL_OFFSET>,
            RemoveEffect: RemoveEffect::<Impl, IMPL_OFFSET>,
            RemoveAllEffects: RemoveAllEffects::<Impl, IMPL_OFFSET>,
            Shutdown: Shutdown::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFPMediaPlayer as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
pub trait IMFPMediaPlayerCallback_Impl: Sized {
    fn OnMediaPlayerEvent(&mut self, peventheader: *const MFP_EVENT_HEADER);
}
#[cfg(feature = "Win32_UI_Shell_PropertiesSystem")]
impl IMFPMediaPlayerCallback_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFPMediaPlayerCallback_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFPMediaPlayerCallback_Vtbl {
        unsafe extern "system" fn OnMediaPlayerEvent<Impl: IMFPMediaPlayerCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, peventheader: *const MFP_EVENT_HEADER) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnMediaPlayerEvent(::core::mem::transmute_copy(&peventheader))
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), OnMediaPlayerEvent: OnMediaPlayerEvent::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFPMediaPlayerCallback as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFPluginControl_Impl: Sized {
    fn GetPreferredClsid(&mut self, plugintype: u32, selector: super::super::Foundation::PWSTR) -> ::windows::core::Result<::windows::core::GUID>;
    fn GetPreferredClsidByIndex(&mut self, plugintype: u32, index: u32, selector: *mut super::super::Foundation::PWSTR, clsid: *mut ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn SetPreferredClsid(&mut self, plugintype: u32, selector: super::super::Foundation::PWSTR, clsid: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn IsDisabled(&mut self, plugintype: u32, clsid: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetDisabledByIndex(&mut self, plugintype: u32, index: u32) -> ::windows::core::Result<::windows::core::GUID>;
    fn SetDisabled(&mut self, plugintype: u32, clsid: *const ::windows::core::GUID, disabled: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFPluginControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFPluginControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFPluginControl_Vtbl {
        unsafe extern "system" fn GetPreferredClsid<Impl: IMFPluginControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plugintype: u32, selector: super::super::Foundation::PWSTR, clsid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPreferredClsid(::core::mem::transmute_copy(&plugintype), ::core::mem::transmute_copy(&selector)) {
                ::core::result::Result::Ok(ok__) => {
                    *clsid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPreferredClsidByIndex<Impl: IMFPluginControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plugintype: u32, index: u32, selector: *mut super::super::Foundation::PWSTR, clsid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPreferredClsidByIndex(::core::mem::transmute_copy(&plugintype), ::core::mem::transmute_copy(&index), ::core::mem::transmute_copy(&selector), ::core::mem::transmute_copy(&clsid)).into()
        }
        unsafe extern "system" fn SetPreferredClsid<Impl: IMFPluginControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plugintype: u32, selector: super::super::Foundation::PWSTR, clsid: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPreferredClsid(::core::mem::transmute_copy(&plugintype), ::core::mem::transmute_copy(&selector), ::core::mem::transmute_copy(&clsid)).into()
        }
        unsafe extern "system" fn IsDisabled<Impl: IMFPluginControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plugintype: u32, clsid: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsDisabled(::core::mem::transmute_copy(&plugintype), ::core::mem::transmute_copy(&clsid)).into()
        }
        unsafe extern "system" fn GetDisabledByIndex<Impl: IMFPluginControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plugintype: u32, index: u32, clsid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDisabledByIndex(::core::mem::transmute_copy(&plugintype), ::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    *clsid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDisabled<Impl: IMFPluginControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plugintype: u32, clsid: *const ::windows::core::GUID, disabled: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDisabled(::core::mem::transmute_copy(&plugintype), ::core::mem::transmute_copy(&clsid), ::core::mem::transmute_copy(&disabled)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetPreferredClsid: GetPreferredClsid::<Impl, IMPL_OFFSET>,
            GetPreferredClsidByIndex: GetPreferredClsidByIndex::<Impl, IMPL_OFFSET>,
            SetPreferredClsid: SetPreferredClsid::<Impl, IMPL_OFFSET>,
            IsDisabled: IsDisabled::<Impl, IMPL_OFFSET>,
            GetDisabledByIndex: GetDisabledByIndex::<Impl, IMPL_OFFSET>,
            SetDisabled: SetDisabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFPluginControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFPluginControl2_Impl: Sized + IMFPluginControl_Impl {
    fn SetPolicy(&mut self, policy: MF_PLUGIN_CONTROL_POLICY) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFPluginControl2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFPluginControl2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFPluginControl2_Vtbl {
        unsafe extern "system" fn SetPolicy<Impl: IMFPluginControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, policy: MF_PLUGIN_CONTROL_POLICY) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPolicy(::core::mem::transmute_copy(&policy)).into()
        }
        Self { base: IMFPluginControl_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), SetPolicy: SetPolicy::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFPluginControl2 as ::windows::core::Interface>::IID
    }
}
pub trait IMFPresentationClock_Impl: Sized + IMFClock_Impl {
    fn SetTimeSource(&mut self, ptimesource: ::core::option::Option<IMFPresentationTimeSource>) -> ::windows::core::Result<()>;
    fn GetTimeSource(&mut self) -> ::windows::core::Result<IMFPresentationTimeSource>;
    fn GetTime(&mut self) -> ::windows::core::Result<i64>;
    fn AddClockStateSink(&mut self, pstatesink: ::core::option::Option<IMFClockStateSink>) -> ::windows::core::Result<()>;
    fn RemoveClockStateSink(&mut self, pstatesink: ::core::option::Option<IMFClockStateSink>) -> ::windows::core::Result<()>;
    fn Start(&mut self, llclockstartoffset: i64) -> ::windows::core::Result<()>;
    fn Stop(&mut self) -> ::windows::core::Result<()>;
    fn Pause(&mut self) -> ::windows::core::Result<()>;
}
impl IMFPresentationClock_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFPresentationClock_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFPresentationClock_Vtbl {
        unsafe extern "system" fn SetTimeSource<Impl: IMFPresentationClock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptimesource: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTimeSource(::core::mem::transmute(&ptimesource)).into()
        }
        unsafe extern "system" fn GetTimeSource<Impl: IMFPresentationClock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pptimesource: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTimeSource() {
                ::core::result::Result::Ok(ok__) => {
                    *pptimesource = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTime<Impl: IMFPresentationClock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phnsclocktime: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTime() {
                ::core::result::Result::Ok(ok__) => {
                    *phnsclocktime = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddClockStateSink<Impl: IMFPresentationClock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstatesink: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddClockStateSink(::core::mem::transmute(&pstatesink)).into()
        }
        unsafe extern "system" fn RemoveClockStateSink<Impl: IMFPresentationClock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstatesink: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveClockStateSink(::core::mem::transmute(&pstatesink)).into()
        }
        unsafe extern "system" fn Start<Impl: IMFPresentationClock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, llclockstartoffset: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Start(::core::mem::transmute_copy(&llclockstartoffset)).into()
        }
        unsafe extern "system" fn Stop<Impl: IMFPresentationClock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        unsafe extern "system" fn Pause<Impl: IMFPresentationClock_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Pause().into()
        }
        Self {
            base: IMFClock_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetTimeSource: SetTimeSource::<Impl, IMPL_OFFSET>,
            GetTimeSource: GetTimeSource::<Impl, IMPL_OFFSET>,
            GetTime: GetTime::<Impl, IMPL_OFFSET>,
            AddClockStateSink: AddClockStateSink::<Impl, IMPL_OFFSET>,
            RemoveClockStateSink: RemoveClockStateSink::<Impl, IMPL_OFFSET>,
            Start: Start::<Impl, IMPL_OFFSET>,
            Stop: Stop::<Impl, IMPL_OFFSET>,
            Pause: Pause::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFPresentationClock as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFPresentationDescriptor_Impl: Sized + IMFAttributes_Impl {
    fn GetStreamDescriptorCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetStreamDescriptorByIndex(&mut self, dwindex: u32, pfselected: *mut super::super::Foundation::BOOL, ppdescriptor: *mut ::core::option::Option<IMFStreamDescriptor>) -> ::windows::core::Result<()>;
    fn SelectStream(&mut self, dwdescriptorindex: u32) -> ::windows::core::Result<()>;
    fn DeselectStream(&mut self, dwdescriptorindex: u32) -> ::windows::core::Result<()>;
    fn Clone(&mut self) -> ::windows::core::Result<IMFPresentationDescriptor>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFPresentationDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFPresentationDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFPresentationDescriptor_Vtbl {
        unsafe extern "system" fn GetStreamDescriptorCount<Impl: IMFPresentationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwdescriptorcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamDescriptorCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwdescriptorcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamDescriptorByIndex<Impl: IMFPresentationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, pfselected: *mut super::super::Foundation::BOOL, ppdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetStreamDescriptorByIndex(::core::mem::transmute_copy(&dwindex), ::core::mem::transmute_copy(&pfselected), ::core::mem::transmute_copy(&ppdescriptor)).into()
        }
        unsafe extern "system" fn SelectStream<Impl: IMFPresentationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwdescriptorindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectStream(::core::mem::transmute_copy(&dwdescriptorindex)).into()
        }
        unsafe extern "system" fn DeselectStream<Impl: IMFPresentationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwdescriptorindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DeselectStream(::core::mem::transmute_copy(&dwdescriptorindex)).into()
        }
        unsafe extern "system" fn Clone<Impl: IMFPresentationDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pppresentationdescriptor: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Clone() {
                ::core::result::Result::Ok(ok__) => {
                    *pppresentationdescriptor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMFAttributes_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetStreamDescriptorCount: GetStreamDescriptorCount::<Impl, IMPL_OFFSET>,
            GetStreamDescriptorByIndex: GetStreamDescriptorByIndex::<Impl, IMPL_OFFSET>,
            SelectStream: SelectStream::<Impl, IMPL_OFFSET>,
            DeselectStream: DeselectStream::<Impl, IMPL_OFFSET>,
            Clone: Clone::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFPresentationDescriptor as ::windows::core::Interface>::IID
    }
}
pub trait IMFPresentationTimeSource_Impl: Sized + IMFClock_Impl {
    fn GetUnderlyingClock(&mut self) -> ::windows::core::Result<IMFClock>;
}
impl IMFPresentationTimeSource_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFPresentationTimeSource_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFPresentationTimeSource_Vtbl {
        unsafe extern "system" fn GetUnderlyingClock<Impl: IMFPresentationTimeSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppclock: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetUnderlyingClock() {
                ::core::result::Result::Ok(ok__) => {
                    *ppclock = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: IMFClock_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), GetUnderlyingClock: GetUnderlyingClock::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFPresentationTimeSource as ::windows::core::Interface>::IID
    }
}
pub trait IMFProtectedEnvironmentAccess_Impl: Sized {
    fn Call(&mut self, inputlength: u32, input: *const u8, outputlength: u32) -> ::windows::core::Result<u8>;
    fn ReadGRL(&mut self, outputlength: *mut u32, output: *mut *mut u8) -> ::windows::core::Result<()>;
}
impl IMFProtectedEnvironmentAccess_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFProtectedEnvironmentAccess_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFProtectedEnvironmentAccess_Vtbl {
        unsafe extern "system" fn Call<Impl: IMFProtectedEnvironmentAccess_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, inputlength: u32, input: *const u8, outputlength: u32, output: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).Call(::core::mem::transmute_copy(&inputlength), ::core::mem::transmute_copy(&input), ::core::mem::transmute_copy(&outputlength)) {
                ::core::result::Result::Ok(ok__) => {
                    *output = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ReadGRL<Impl: IMFProtectedEnvironmentAccess_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, outputlength: *mut u32, output: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ReadGRL(::core::mem::transmute_copy(&outputlength), ::core::mem::transmute_copy(&output)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Call: Call::<Impl, IMPL_OFFSET>, ReadGRL: ReadGRL::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFProtectedEnvironmentAccess as ::windows::core::Interface>::IID
    }
}
pub trait IMFQualityAdvise_Impl: Sized {
    fn SetDropMode(&mut self, edropmode: MF_QUALITY_DROP_MODE) -> ::windows::core::Result<()>;
    fn SetQualityLevel(&mut self, equalitylevel: MF_QUALITY_LEVEL) -> ::windows::core::Result<()>;
    fn GetDropMode(&mut self) -> ::windows::core::Result<MF_QUALITY_DROP_MODE>;
    fn GetQualityLevel(&mut self) -> ::windows::core::Result<MF_QUALITY_LEVEL>;
    fn DropTime(&mut self, hnsamounttodrop: i64) -> ::windows::core::Result<()>;
}
impl IMFQualityAdvise_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFQualityAdvise_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFQualityAdvise_Vtbl {
        unsafe extern "system" fn SetDropMode<Impl: IMFQualityAdvise_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, edropmode: MF_QUALITY_DROP_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDropMode(::core::mem::transmute_copy(&edropmode)).into()
        }
        unsafe extern "system" fn SetQualityLevel<Impl: IMFQualityAdvise_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, equalitylevel: MF_QUALITY_LEVEL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetQualityLevel(::core::mem::transmute_copy(&equalitylevel)).into()
        }
        unsafe extern "system" fn GetDropMode<Impl: IMFQualityAdvise_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pedropmode: *mut MF_QUALITY_DROP_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDropMode() {
                ::core::result::Result::Ok(ok__) => {
                    *pedropmode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetQualityLevel<Impl: IMFQualityAdvise_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pequalitylevel: *mut MF_QUALITY_LEVEL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetQualityLevel() {
                ::core::result::Result::Ok(ok__) => {
                    *pequalitylevel = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DropTime<Impl: IMFQualityAdvise_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnsamounttodrop: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DropTime(::core::mem::transmute_copy(&hnsamounttodrop)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetDropMode: SetDropMode::<Impl, IMPL_OFFSET>,
            SetQualityLevel: SetQualityLevel::<Impl, IMPL_OFFSET>,
            GetDropMode: GetDropMode::<Impl, IMPL_OFFSET>,
            GetQualityLevel: GetQualityLevel::<Impl, IMPL_OFFSET>,
            DropTime: DropTime::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFQualityAdvise as ::windows::core::Interface>::IID
    }
}
pub trait IMFQualityAdvise2_Impl: Sized + IMFQualityAdvise_Impl {
    fn NotifyQualityEvent(&mut self, pevent: ::core::option::Option<IMFMediaEvent>) -> ::windows::core::Result<u32>;
}
impl IMFQualityAdvise2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFQualityAdvise2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFQualityAdvise2_Vtbl {
        unsafe extern "system" fn NotifyQualityEvent<Impl: IMFQualityAdvise2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pevent: ::windows::core::RawPtr, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).NotifyQualityEvent(::core::mem::transmute(&pevent)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: IMFQualityAdvise_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), NotifyQualityEvent: NotifyQualityEvent::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFQualityAdvise2 as ::windows::core::Interface>::IID
    }
}
pub trait IMFQualityAdviseLimits_Impl: Sized {
    fn GetMaximumDropMode(&mut self) -> ::windows::core::Result<MF_QUALITY_DROP_MODE>;
    fn GetMinimumQualityLevel(&mut self) -> ::windows::core::Result<MF_QUALITY_LEVEL>;
}
impl IMFQualityAdviseLimits_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFQualityAdviseLimits_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFQualityAdviseLimits_Vtbl {
        unsafe extern "system" fn GetMaximumDropMode<Impl: IMFQualityAdviseLimits_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pedropmode: *mut MF_QUALITY_DROP_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMaximumDropMode() {
                ::core::result::Result::Ok(ok__) => {
                    *pedropmode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMinimumQualityLevel<Impl: IMFQualityAdviseLimits_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pequalitylevel: *mut MF_QUALITY_LEVEL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMinimumQualityLevel() {
                ::core::result::Result::Ok(ok__) => {
                    *pequalitylevel = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetMaximumDropMode: GetMaximumDropMode::<Impl, IMPL_OFFSET>,
            GetMinimumQualityLevel: GetMinimumQualityLevel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFQualityAdviseLimits as ::windows::core::Interface>::IID
    }
}
pub trait IMFQualityManager_Impl: Sized {
    fn NotifyTopology(&mut self, ptopology: ::core::option::Option<IMFTopology>) -> ::windows::core::Result<()>;
    fn NotifyPresentationClock(&mut self, pclock: ::core::option::Option<IMFPresentationClock>) -> ::windows::core::Result<()>;
    fn NotifyProcessInput(&mut self, pnode: ::core::option::Option<IMFTopologyNode>, linputindex: i32, psample: ::core::option::Option<IMFSample>) -> ::windows::core::Result<()>;
    fn NotifyProcessOutput(&mut self, pnode: ::core::option::Option<IMFTopologyNode>, loutputindex: i32, psample: ::core::option::Option<IMFSample>) -> ::windows::core::Result<()>;
    fn NotifyQualityEvent(&mut self, pobject: ::core::option::Option<::windows::core::IUnknown>, pevent: ::core::option::Option<IMFMediaEvent>) -> ::windows::core::Result<()>;
    fn Shutdown(&mut self) -> ::windows::core::Result<()>;
}
impl IMFQualityManager_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFQualityManager_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFQualityManager_Vtbl {
        unsafe extern "system" fn NotifyTopology<Impl: IMFQualityManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptopology: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NotifyTopology(::core::mem::transmute(&ptopology)).into()
        }
        unsafe extern "system" fn NotifyPresentationClock<Impl: IMFQualityManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pclock: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NotifyPresentationClock(::core::mem::transmute(&pclock)).into()
        }
        unsafe extern "system" fn NotifyProcessInput<Impl: IMFQualityManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pnode: ::windows::core::RawPtr, linputindex: i32, psample: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NotifyProcessInput(::core::mem::transmute(&pnode), ::core::mem::transmute_copy(&linputindex), ::core::mem::transmute(&psample)).into()
        }
        unsafe extern "system" fn NotifyProcessOutput<Impl: IMFQualityManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pnode: ::windows::core::RawPtr, loutputindex: i32, psample: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NotifyProcessOutput(::core::mem::transmute(&pnode), ::core::mem::transmute_copy(&loutputindex), ::core::mem::transmute(&psample)).into()
        }
        unsafe extern "system" fn NotifyQualityEvent<Impl: IMFQualityManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pobject: *mut ::core::ffi::c_void, pevent: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NotifyQualityEvent(::core::mem::transmute(&pobject), ::core::mem::transmute(&pevent)).into()
        }
        unsafe extern "system" fn Shutdown<Impl: IMFQualityManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Shutdown().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            NotifyTopology: NotifyTopology::<Impl, IMPL_OFFSET>,
            NotifyPresentationClock: NotifyPresentationClock::<Impl, IMPL_OFFSET>,
            NotifyProcessInput: NotifyProcessInput::<Impl, IMPL_OFFSET>,
            NotifyProcessOutput: NotifyProcessOutput::<Impl, IMPL_OFFSET>,
            NotifyQualityEvent: NotifyQualityEvent::<Impl, IMPL_OFFSET>,
            Shutdown: Shutdown::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFQualityManager as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFRateControl_Impl: Sized {
    fn SetRate(&mut self, fthin: super::super::Foundation::BOOL, flrate: f32) -> ::windows::core::Result<()>;
    fn GetRate(&mut self, pfthin: *mut super::super::Foundation::BOOL, pflrate: *mut f32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFRateControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFRateControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFRateControl_Vtbl {
        unsafe extern "system" fn SetRate<Impl: IMFRateControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fthin: super::super::Foundation::BOOL, flrate: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRate(::core::mem::transmute_copy(&fthin), ::core::mem::transmute_copy(&flrate)).into()
        }
        unsafe extern "system" fn GetRate<Impl: IMFRateControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfthin: *mut super::super::Foundation::BOOL, pflrate: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRate(::core::mem::transmute_copy(&pfthin), ::core::mem::transmute_copy(&pflrate)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetRate: SetRate::<Impl, IMPL_OFFSET>,
            GetRate: GetRate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFRateControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFRateSupport_Impl: Sized {
    fn GetSlowestRate(&mut self, edirection: MFRATE_DIRECTION, fthin: super::super::Foundation::BOOL) -> ::windows::core::Result<f32>;
    fn GetFastestRate(&mut self, edirection: MFRATE_DIRECTION, fthin: super::super::Foundation::BOOL) -> ::windows::core::Result<f32>;
    fn IsRateSupported(&mut self, fthin: super::super::Foundation::BOOL, flrate: f32, pflnearestsupportedrate: *mut f32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFRateSupport_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFRateSupport_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFRateSupport_Vtbl {
        unsafe extern "system" fn GetSlowestRate<Impl: IMFRateSupport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, edirection: MFRATE_DIRECTION, fthin: super::super::Foundation::BOOL, pflrate: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSlowestRate(::core::mem::transmute_copy(&edirection), ::core::mem::transmute_copy(&fthin)) {
                ::core::result::Result::Ok(ok__) => {
                    *pflrate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFastestRate<Impl: IMFRateSupport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, edirection: MFRATE_DIRECTION, fthin: super::super::Foundation::BOOL, pflrate: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFastestRate(::core::mem::transmute_copy(&edirection), ::core::mem::transmute_copy(&fthin)) {
                ::core::result::Result::Ok(ok__) => {
                    *pflrate = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsRateSupported<Impl: IMFRateSupport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fthin: super::super::Foundation::BOOL, flrate: f32, pflnearestsupportedrate: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsRateSupported(::core::mem::transmute_copy(&fthin), ::core::mem::transmute_copy(&flrate), ::core::mem::transmute_copy(&pflnearestsupportedrate)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetSlowestRate: GetSlowestRate::<Impl, IMPL_OFFSET>,
            GetFastestRate: GetFastestRate::<Impl, IMPL_OFFSET>,
            IsRateSupported: IsRateSupported::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFRateSupport as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFReadWriteClassFactory_Impl: Sized {
    fn CreateInstanceFromURL(&mut self, clsid: *const ::windows::core::GUID, pwszurl: super::super::Foundation::PWSTR, pattributes: ::core::option::Option<IMFAttributes>, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn CreateInstanceFromObject(&mut self, clsid: *const ::windows::core::GUID, punkobject: ::core::option::Option<::windows::core::IUnknown>, pattributes: ::core::option::Option<IMFAttributes>, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFReadWriteClassFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFReadWriteClassFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFReadWriteClassFactory_Vtbl {
        unsafe extern "system" fn CreateInstanceFromURL<Impl: IMFReadWriteClassFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clsid: *const ::windows::core::GUID, pwszurl: super::super::Foundation::PWSTR, pattributes: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateInstanceFromURL(::core::mem::transmute_copy(&clsid), ::core::mem::transmute_copy(&pwszurl), ::core::mem::transmute(&pattributes), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvobject)).into()
        }
        unsafe extern "system" fn CreateInstanceFromObject<Impl: IMFReadWriteClassFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clsid: *const ::windows::core::GUID, punkobject: *mut ::core::ffi::c_void, pattributes: ::windows::core::RawPtr, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateInstanceFromObject(::core::mem::transmute_copy(&clsid), ::core::mem::transmute(&punkobject), ::core::mem::transmute(&pattributes), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvobject)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            CreateInstanceFromURL: CreateInstanceFromURL::<Impl, IMPL_OFFSET>,
            CreateInstanceFromObject: CreateInstanceFromObject::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFReadWriteClassFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFRealTimeClient_Impl: Sized {
    fn RegisterThreads(&mut self, dwtaskindex: u32, wszclass: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn UnregisterThreads(&mut self) -> ::windows::core::Result<()>;
    fn SetWorkQueue(&mut self, dwworkqueueid: u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFRealTimeClient_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFRealTimeClient_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFRealTimeClient_Vtbl {
        unsafe extern "system" fn RegisterThreads<Impl: IMFRealTimeClient_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwtaskindex: u32, wszclass: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterThreads(::core::mem::transmute_copy(&dwtaskindex), ::core::mem::transmute_copy(&wszclass)).into()
        }
        unsafe extern "system" fn UnregisterThreads<Impl: IMFRealTimeClient_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnregisterThreads().into()
        }
        unsafe extern "system" fn SetWorkQueue<Impl: IMFRealTimeClient_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwworkqueueid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetWorkQueue(::core::mem::transmute_copy(&dwworkqueueid)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            RegisterThreads: RegisterThreads::<Impl, IMPL_OFFSET>,
            UnregisterThreads: UnregisterThreads::<Impl, IMPL_OFFSET>,
            SetWorkQueue: SetWorkQueue::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFRealTimeClient as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFRealTimeClientEx_Impl: Sized {
    fn RegisterThreadsEx(&mut self, pdwtaskindex: *mut u32, wszclassname: super::super::Foundation::PWSTR, lbasepriority: i32) -> ::windows::core::Result<()>;
    fn UnregisterThreads(&mut self) -> ::windows::core::Result<()>;
    fn SetWorkQueueEx(&mut self, dwmultithreadedworkqueueid: u32, lworkitembasepriority: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFRealTimeClientEx_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFRealTimeClientEx_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFRealTimeClientEx_Vtbl {
        unsafe extern "system" fn RegisterThreadsEx<Impl: IMFRealTimeClientEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwtaskindex: *mut u32, wszclassname: super::super::Foundation::PWSTR, lbasepriority: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterThreadsEx(::core::mem::transmute_copy(&pdwtaskindex), ::core::mem::transmute_copy(&wszclassname), ::core::mem::transmute_copy(&lbasepriority)).into()
        }
        unsafe extern "system" fn UnregisterThreads<Impl: IMFRealTimeClientEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UnregisterThreads().into()
        }
        unsafe extern "system" fn SetWorkQueueEx<Impl: IMFRealTimeClientEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwmultithreadedworkqueueid: u32, lworkitembasepriority: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetWorkQueueEx(::core::mem::transmute_copy(&dwmultithreadedworkqueueid), ::core::mem::transmute_copy(&lworkitembasepriority)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            RegisterThreadsEx: RegisterThreadsEx::<Impl, IMPL_OFFSET>,
            UnregisterThreads: UnregisterThreads::<Impl, IMPL_OFFSET>,
            SetWorkQueueEx: SetWorkQueueEx::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFRealTimeClientEx as ::windows::core::Interface>::IID
    }
}
pub trait IMFRelativePanelReport_Impl: Sized {
    fn GetRelativePanel(&mut self) -> ::windows::core::Result<u32>;
}
impl IMFRelativePanelReport_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFRelativePanelReport_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFRelativePanelReport_Vtbl {
        unsafe extern "system" fn GetRelativePanel<Impl: IMFRelativePanelReport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, panel: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRelativePanel() {
                ::core::result::Result::Ok(ok__) => {
                    *panel = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetRelativePanel: GetRelativePanel::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFRelativePanelReport as ::windows::core::Interface>::IID
    }
}
pub trait IMFRelativePanelWatcher_Impl: Sized + IMFShutdown_Impl {
    fn BeginGetReport(&mut self, pcallback: ::core::option::Option<IMFAsyncCallback>, pstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndGetReport(&mut self, presult: ::core::option::Option<IMFAsyncResult>) -> ::windows::core::Result<IMFRelativePanelReport>;
    fn GetReport(&mut self) -> ::windows::core::Result<IMFRelativePanelReport>;
}
impl IMFRelativePanelWatcher_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFRelativePanelWatcher_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFRelativePanelWatcher_Vtbl {
        unsafe extern "system" fn BeginGetReport<Impl: IMFRelativePanelWatcher_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginGetReport(::core::mem::transmute(&pcallback), ::core::mem::transmute(&pstate)).into()
        }
        unsafe extern "system" fn EndGetReport<Impl: IMFRelativePanelWatcher_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, pprelativepanelreport: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EndGetReport(::core::mem::transmute(&presult)) {
                ::core::result::Result::Ok(ok__) => {
                    *pprelativepanelreport = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetReport<Impl: IMFRelativePanelWatcher_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pprelativepanelreport: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetReport() {
                ::core::result::Result::Ok(ok__) => {
                    *pprelativepanelreport = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMFShutdown_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            BeginGetReport: BeginGetReport::<Impl, IMPL_OFFSET>,
            EndGetReport: EndGetReport::<Impl, IMPL_OFFSET>,
            GetReport: GetReport::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFRelativePanelWatcher as ::windows::core::Interface>::IID
    }
}
pub trait IMFRemoteAsyncCallback_Impl: Sized {
    fn Invoke(&mut self, hr: ::windows::core::HRESULT, premoteresult: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
}
impl IMFRemoteAsyncCallback_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFRemoteAsyncCallback_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFRemoteAsyncCallback_Vtbl {
        unsafe extern "system" fn Invoke<Impl: IMFRemoteAsyncCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hr: ::windows::core::HRESULT, premoteresult: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Invoke(::core::mem::transmute_copy(&hr), ::core::mem::transmute(&premoteresult)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Invoke: Invoke::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFRemoteAsyncCallback as ::windows::core::Interface>::IID
    }
}
pub trait IMFRemoteDesktopPlugin_Impl: Sized {
    fn UpdateTopology(&mut self, ptopology: ::core::option::Option<IMFTopology>) -> ::windows::core::Result<()>;
}
impl IMFRemoteDesktopPlugin_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFRemoteDesktopPlugin_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFRemoteDesktopPlugin_Vtbl {
        unsafe extern "system" fn UpdateTopology<Impl: IMFRemoteDesktopPlugin_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptopology: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UpdateTopology(::core::mem::transmute(&ptopology)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), UpdateTopology: UpdateTopology::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFRemoteDesktopPlugin as ::windows::core::Interface>::IID
    }
}
pub trait IMFRemoteProxy_Impl: Sized {
    fn GetRemoteObject(&mut self, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn GetRemoteHost(&mut self, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
impl IMFRemoteProxy_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFRemoteProxy_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFRemoteProxy_Vtbl {
        unsafe extern "system" fn GetRemoteObject<Impl: IMFRemoteProxy_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRemoteObject(::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppv)).into()
        }
        unsafe extern "system" fn GetRemoteHost<Impl: IMFRemoteProxy_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, riid: *const ::windows::core::GUID, ppv: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetRemoteHost(::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppv)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetRemoteObject: GetRemoteObject::<Impl, IMPL_OFFSET>,
            GetRemoteHost: GetRemoteHost::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFRemoteProxy as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFSAMIStyle_Impl: Sized {
    fn GetStyleCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetStyles(&mut self) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
    fn SetSelectedStyle(&mut self, pwszstyle: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn GetSelectedStyle(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFSAMIStyle_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSAMIStyle_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSAMIStyle_Vtbl {
        unsafe extern "system" fn GetStyleCount<Impl: IMFSAMIStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStyleCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStyles<Impl: IMFSAMIStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppropvarstylearray: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStyles() {
                ::core::result::Result::Ok(ok__) => {
                    *ppropvarstylearray = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSelectedStyle<Impl: IMFSAMIStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwszstyle: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSelectedStyle(::core::mem::transmute_copy(&pwszstyle)).into()
        }
        unsafe extern "system" fn GetSelectedStyle<Impl: IMFSAMIStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppwszstyle: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSelectedStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *ppwszstyle = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetStyleCount: GetStyleCount::<Impl, IMPL_OFFSET>,
            GetStyles: GetStyles::<Impl, IMPL_OFFSET>,
            SetSelectedStyle: SetSelectedStyle::<Impl, IMPL_OFFSET>,
            GetSelectedStyle: GetSelectedStyle::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSAMIStyle as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFSSLCertificateManager_Impl: Sized {
    fn GetClientCertificate(&mut self, pszurl: super::super::Foundation::PWSTR, ppbdata: *mut *mut u8, pcbdata: *mut u32) -> ::windows::core::Result<()>;
    fn BeginGetClientCertificate(&mut self, pszurl: super::super::Foundation::PWSTR, pcallback: ::core::option::Option<IMFAsyncCallback>, pstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndGetClientCertificate(&mut self, presult: ::core::option::Option<IMFAsyncResult>, ppbdata: *mut *mut u8, pcbdata: *mut u32) -> ::windows::core::Result<()>;
    fn GetCertificatePolicy(&mut self, pszurl: super::super::Foundation::PWSTR, pfoverrideautomaticcheck: *mut super::super::Foundation::BOOL, pfclientcertificateavailable: *mut super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn OnServerCertificate(&mut self, pszurl: super::super::Foundation::PWSTR, pbdata: *const u8, cbdata: u32) -> ::windows::core::Result<super::super::Foundation::BOOL>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFSSLCertificateManager_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSSLCertificateManager_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSSLCertificateManager_Vtbl {
        unsafe extern "system" fn GetClientCertificate<Impl: IMFSSLCertificateManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszurl: super::super::Foundation::PWSTR, ppbdata: *mut *mut u8, pcbdata: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetClientCertificate(::core::mem::transmute_copy(&pszurl), ::core::mem::transmute_copy(&ppbdata), ::core::mem::transmute_copy(&pcbdata)).into()
        }
        unsafe extern "system" fn BeginGetClientCertificate<Impl: IMFSSLCertificateManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszurl: super::super::Foundation::PWSTR, pcallback: ::windows::core::RawPtr, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginGetClientCertificate(::core::mem::transmute_copy(&pszurl), ::core::mem::transmute(&pcallback), ::core::mem::transmute(&pstate)).into()
        }
        unsafe extern "system" fn EndGetClientCertificate<Impl: IMFSSLCertificateManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, ppbdata: *mut *mut u8, pcbdata: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndGetClientCertificate(::core::mem::transmute(&presult), ::core::mem::transmute_copy(&ppbdata), ::core::mem::transmute_copy(&pcbdata)).into()
        }
        unsafe extern "system" fn GetCertificatePolicy<Impl: IMFSSLCertificateManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszurl: super::super::Foundation::PWSTR, pfoverrideautomaticcheck: *mut super::super::Foundation::BOOL, pfclientcertificateavailable: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCertificatePolicy(::core::mem::transmute_copy(&pszurl), ::core::mem::transmute_copy(&pfoverrideautomaticcheck), ::core::mem::transmute_copy(&pfclientcertificateavailable)).into()
        }
        unsafe extern "system" fn OnServerCertificate<Impl: IMFSSLCertificateManager_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszurl: super::super::Foundation::PWSTR, pbdata: *const u8, cbdata: u32, pfisgood: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).OnServerCertificate(::core::mem::transmute_copy(&pszurl), ::core::mem::transmute_copy(&pbdata), ::core::mem::transmute_copy(&cbdata)) {
                ::core::result::Result::Ok(ok__) => {
                    *pfisgood = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetClientCertificate: GetClientCertificate::<Impl, IMPL_OFFSET>,
            BeginGetClientCertificate: BeginGetClientCertificate::<Impl, IMPL_OFFSET>,
            EndGetClientCertificate: EndGetClientCertificate::<Impl, IMPL_OFFSET>,
            GetCertificatePolicy: GetCertificatePolicy::<Impl, IMPL_OFFSET>,
            OnServerCertificate: OnServerCertificate::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSSLCertificateManager as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFSample_Impl: Sized + IMFAttributes_Impl {
    fn GetSampleFlags(&mut self) -> ::windows::core::Result<u32>;
    fn SetSampleFlags(&mut self, dwsampleflags: u32) -> ::windows::core::Result<()>;
    fn GetSampleTime(&mut self) -> ::windows::core::Result<i64>;
    fn SetSampleTime(&mut self, hnssampletime: i64) -> ::windows::core::Result<()>;
    fn GetSampleDuration(&mut self) -> ::windows::core::Result<i64>;
    fn SetSampleDuration(&mut self, hnssampleduration: i64) -> ::windows::core::Result<()>;
    fn GetBufferCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetBufferByIndex(&mut self, dwindex: u32) -> ::windows::core::Result<IMFMediaBuffer>;
    fn ConvertToContiguousBuffer(&mut self) -> ::windows::core::Result<IMFMediaBuffer>;
    fn AddBuffer(&mut self, pbuffer: ::core::option::Option<IMFMediaBuffer>) -> ::windows::core::Result<()>;
    fn RemoveBufferByIndex(&mut self, dwindex: u32) -> ::windows::core::Result<()>;
    fn RemoveAllBuffers(&mut self) -> ::windows::core::Result<()>;
    fn GetTotalLength(&mut self) -> ::windows::core::Result<u32>;
    fn CopyToBuffer(&mut self, pbuffer: ::core::option::Option<IMFMediaBuffer>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFSample_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSample_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSample_Vtbl {
        unsafe extern "system" fn GetSampleFlags<Impl: IMFSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwsampleflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSampleFlags() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwsampleflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSampleFlags<Impl: IMFSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwsampleflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSampleFlags(::core::mem::transmute_copy(&dwsampleflags)).into()
        }
        unsafe extern "system" fn GetSampleTime<Impl: IMFSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phnssampletime: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSampleTime() {
                ::core::result::Result::Ok(ok__) => {
                    *phnssampletime = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSampleTime<Impl: IMFSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnssampletime: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSampleTime(::core::mem::transmute_copy(&hnssampletime)).into()
        }
        unsafe extern "system" fn GetSampleDuration<Impl: IMFSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phnssampleduration: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSampleDuration() {
                ::core::result::Result::Ok(ok__) => {
                    *phnssampleduration = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSampleDuration<Impl: IMFSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnssampleduration: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSampleDuration(::core::mem::transmute_copy(&hnssampleduration)).into()
        }
        unsafe extern "system" fn GetBufferCount<Impl: IMFSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwbuffercount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBufferCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwbuffercount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBufferByIndex<Impl: IMFSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppbuffer: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBufferByIndex(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppbuffer = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConvertToContiguousBuffer<Impl: IMFSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppbuffer: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).ConvertToContiguousBuffer() {
                ::core::result::Result::Ok(ok__) => {
                    *ppbuffer = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddBuffer<Impl: IMFSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbuffer: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddBuffer(::core::mem::transmute(&pbuffer)).into()
        }
        unsafe extern "system" fn RemoveBufferByIndex<Impl: IMFSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveBufferByIndex(::core::mem::transmute_copy(&dwindex)).into()
        }
        unsafe extern "system" fn RemoveAllBuffers<Impl: IMFSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveAllBuffers().into()
        }
        unsafe extern "system" fn GetTotalLength<Impl: IMFSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcbtotallength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTotalLength() {
                ::core::result::Result::Ok(ok__) => {
                    *pcbtotallength = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CopyToBuffer<Impl: IMFSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbuffer: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CopyToBuffer(::core::mem::transmute(&pbuffer)).into()
        }
        Self {
            base: IMFAttributes_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetSampleFlags: GetSampleFlags::<Impl, IMPL_OFFSET>,
            SetSampleFlags: SetSampleFlags::<Impl, IMPL_OFFSET>,
            GetSampleTime: GetSampleTime::<Impl, IMPL_OFFSET>,
            SetSampleTime: SetSampleTime::<Impl, IMPL_OFFSET>,
            GetSampleDuration: GetSampleDuration::<Impl, IMPL_OFFSET>,
            SetSampleDuration: SetSampleDuration::<Impl, IMPL_OFFSET>,
            GetBufferCount: GetBufferCount::<Impl, IMPL_OFFSET>,
            GetBufferByIndex: GetBufferByIndex::<Impl, IMPL_OFFSET>,
            ConvertToContiguousBuffer: ConvertToContiguousBuffer::<Impl, IMPL_OFFSET>,
            AddBuffer: AddBuffer::<Impl, IMPL_OFFSET>,
            RemoveBufferByIndex: RemoveBufferByIndex::<Impl, IMPL_OFFSET>,
            RemoveAllBuffers: RemoveAllBuffers::<Impl, IMPL_OFFSET>,
            GetTotalLength: GetTotalLength::<Impl, IMPL_OFFSET>,
            CopyToBuffer: CopyToBuffer::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSample as ::windows::core::Interface>::IID
    }
}
pub trait IMFSampleAllocatorControl_Impl: Sized {
    fn SetDefaultAllocator(&mut self, dwoutputstreamid: u32, pallocator: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn GetAllocatorUsage(&mut self, dwoutputstreamid: u32, pdwinputstreamid: *mut u32, peusage: *mut MFSampleAllocatorUsage) -> ::windows::core::Result<()>;
}
impl IMFSampleAllocatorControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSampleAllocatorControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSampleAllocatorControl_Vtbl {
        unsafe extern "system" fn SetDefaultAllocator<Impl: IMFSampleAllocatorControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, pallocator: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultAllocator(::core::mem::transmute_copy(&dwoutputstreamid), ::core::mem::transmute(&pallocator)).into()
        }
        unsafe extern "system" fn GetAllocatorUsage<Impl: IMFSampleAllocatorControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, pdwinputstreamid: *mut u32, peusage: *mut MFSampleAllocatorUsage) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAllocatorUsage(::core::mem::transmute_copy(&dwoutputstreamid), ::core::mem::transmute_copy(&pdwinputstreamid), ::core::mem::transmute_copy(&peusage)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetDefaultAllocator: SetDefaultAllocator::<Impl, IMPL_OFFSET>,
            GetAllocatorUsage: GetAllocatorUsage::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSampleAllocatorControl as ::windows::core::Interface>::IID
    }
}
pub trait IMFSampleGrabberSinkCallback_Impl: Sized + IMFClockStateSink_Impl {
    fn OnSetPresentationClock(&mut self, ppresentationclock: ::core::option::Option<IMFPresentationClock>) -> ::windows::core::Result<()>;
    fn OnProcessSample(&mut self, guidmajormediatype: *const ::windows::core::GUID, dwsampleflags: u32, llsampletime: i64, llsampleduration: i64, psamplebuffer: *const u8, dwsamplesize: u32) -> ::windows::core::Result<()>;
    fn OnShutdown(&mut self) -> ::windows::core::Result<()>;
}
impl IMFSampleGrabberSinkCallback_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSampleGrabberSinkCallback_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSampleGrabberSinkCallback_Vtbl {
        unsafe extern "system" fn OnSetPresentationClock<Impl: IMFSampleGrabberSinkCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppresentationclock: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnSetPresentationClock(::core::mem::transmute(&ppresentationclock)).into()
        }
        unsafe extern "system" fn OnProcessSample<Impl: IMFSampleGrabberSinkCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidmajormediatype: *const ::windows::core::GUID, dwsampleflags: u32, llsampletime: i64, llsampleduration: i64, psamplebuffer: *const u8, dwsamplesize: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnProcessSample(::core::mem::transmute_copy(&guidmajormediatype), ::core::mem::transmute_copy(&dwsampleflags), ::core::mem::transmute_copy(&llsampletime), ::core::mem::transmute_copy(&llsampleduration), ::core::mem::transmute_copy(&psamplebuffer), ::core::mem::transmute_copy(&dwsamplesize)).into()
        }
        unsafe extern "system" fn OnShutdown<Impl: IMFSampleGrabberSinkCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnShutdown().into()
        }
        Self {
            base: IMFClockStateSink_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            OnSetPresentationClock: OnSetPresentationClock::<Impl, IMPL_OFFSET>,
            OnProcessSample: OnProcessSample::<Impl, IMPL_OFFSET>,
            OnShutdown: OnShutdown::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSampleGrabberSinkCallback as ::windows::core::Interface>::IID
    }
}
pub trait IMFSampleGrabberSinkCallback2_Impl: Sized + IMFClockStateSink_Impl + IMFSampleGrabberSinkCallback_Impl {
    fn OnProcessSampleEx(&mut self, guidmajormediatype: *const ::windows::core::GUID, dwsampleflags: u32, llsampletime: i64, llsampleduration: i64, psamplebuffer: *const u8, dwsamplesize: u32, pattributes: ::core::option::Option<IMFAttributes>) -> ::windows::core::Result<()>;
}
impl IMFSampleGrabberSinkCallback2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSampleGrabberSinkCallback2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSampleGrabberSinkCallback2_Vtbl {
        unsafe extern "system" fn OnProcessSampleEx<Impl: IMFSampleGrabberSinkCallback2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidmajormediatype: *const ::windows::core::GUID, dwsampleflags: u32, llsampletime: i64, llsampleduration: i64, psamplebuffer: *const u8, dwsamplesize: u32, pattributes: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnProcessSampleEx(::core::mem::transmute_copy(&guidmajormediatype), ::core::mem::transmute_copy(&dwsampleflags), ::core::mem::transmute_copy(&llsampletime), ::core::mem::transmute_copy(&llsampleduration), ::core::mem::transmute_copy(&psamplebuffer), ::core::mem::transmute_copy(&dwsamplesize), ::core::mem::transmute(&pattributes)).into()
        }
        Self {
            base: IMFSampleGrabberSinkCallback_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            OnProcessSampleEx: OnProcessSampleEx::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSampleGrabberSinkCallback2 as ::windows::core::Interface>::IID
    }
}
pub trait IMFSampleOutputStream_Impl: Sized {
    fn BeginWriteSample(&mut self, psample: ::core::option::Option<IMFSample>, pcallback: ::core::option::Option<IMFAsyncCallback>, punkstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndWriteSample(&mut self, presult: ::core::option::Option<IMFAsyncResult>) -> ::windows::core::Result<()>;
    fn Close(&mut self) -> ::windows::core::Result<()>;
}
impl IMFSampleOutputStream_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSampleOutputStream_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSampleOutputStream_Vtbl {
        unsafe extern "system" fn BeginWriteSample<Impl: IMFSampleOutputStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psample: ::windows::core::RawPtr, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginWriteSample(::core::mem::transmute(&psample), ::core::mem::transmute(&pcallback), ::core::mem::transmute(&punkstate)).into()
        }
        unsafe extern "system" fn EndWriteSample<Impl: IMFSampleOutputStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndWriteSample(::core::mem::transmute(&presult)).into()
        }
        unsafe extern "system" fn Close<Impl: IMFSampleOutputStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Close().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            BeginWriteSample: BeginWriteSample::<Impl, IMPL_OFFSET>,
            EndWriteSample: EndWriteSample::<Impl, IMPL_OFFSET>,
            Close: Close::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSampleOutputStream as ::windows::core::Interface>::IID
    }
}
pub trait IMFSampleProtection_Impl: Sized {
    fn GetInputProtectionVersion(&mut self) -> ::windows::core::Result<u32>;
    fn GetOutputProtectionVersion(&mut self) -> ::windows::core::Result<u32>;
    fn GetProtectionCertificate(&mut self, dwversion: u32, ppcert: *mut *mut u8, pcbcert: *mut u32) -> ::windows::core::Result<()>;
    fn InitOutputProtection(&mut self, dwversion: u32, dwoutputid: u32, pbcert: *const u8, cbcert: u32, ppbseed: *mut *mut u8, pcbseed: *mut u32) -> ::windows::core::Result<()>;
    fn InitInputProtection(&mut self, dwversion: u32, dwinputid: u32, pbseed: *const u8, cbseed: u32) -> ::windows::core::Result<()>;
}
impl IMFSampleProtection_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSampleProtection_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSampleProtection_Vtbl {
        unsafe extern "system" fn GetInputProtectionVersion<Impl: IMFSampleProtection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwversion: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetInputProtectionVersion() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwversion = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputProtectionVersion<Impl: IMFSampleProtection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwversion: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOutputProtectionVersion() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwversion = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProtectionCertificate<Impl: IMFSampleProtection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwversion: u32, ppcert: *mut *mut u8, pcbcert: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetProtectionCertificate(::core::mem::transmute_copy(&dwversion), ::core::mem::transmute_copy(&ppcert), ::core::mem::transmute_copy(&pcbcert)).into()
        }
        unsafe extern "system" fn InitOutputProtection<Impl: IMFSampleProtection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwversion: u32, dwoutputid: u32, pbcert: *const u8, cbcert: u32, ppbseed: *mut *mut u8, pcbseed: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InitOutputProtection(::core::mem::transmute_copy(&dwversion), ::core::mem::transmute_copy(&dwoutputid), ::core::mem::transmute_copy(&pbcert), ::core::mem::transmute_copy(&cbcert), ::core::mem::transmute_copy(&ppbseed), ::core::mem::transmute_copy(&pcbseed)).into()
        }
        unsafe extern "system" fn InitInputProtection<Impl: IMFSampleProtection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwversion: u32, dwinputid: u32, pbseed: *const u8, cbseed: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InitInputProtection(::core::mem::transmute_copy(&dwversion), ::core::mem::transmute_copy(&dwinputid), ::core::mem::transmute_copy(&pbseed), ::core::mem::transmute_copy(&cbseed)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetInputProtectionVersion: GetInputProtectionVersion::<Impl, IMPL_OFFSET>,
            GetOutputProtectionVersion: GetOutputProtectionVersion::<Impl, IMPL_OFFSET>,
            GetProtectionCertificate: GetProtectionCertificate::<Impl, IMPL_OFFSET>,
            InitOutputProtection: InitOutputProtection::<Impl, IMPL_OFFSET>,
            InitInputProtection: InitInputProtection::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSampleProtection as ::windows::core::Interface>::IID
    }
}
pub trait IMFSaveJob_Impl: Sized {
    fn BeginSave(&mut self, pstream: ::core::option::Option<IMFByteStream>, pcallback: ::core::option::Option<IMFAsyncCallback>, pstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndSave(&mut self, presult: ::core::option::Option<IMFAsyncResult>) -> ::windows::core::Result<()>;
    fn CancelSave(&mut self) -> ::windows::core::Result<()>;
    fn GetProgress(&mut self) -> ::windows::core::Result<u32>;
}
impl IMFSaveJob_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSaveJob_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSaveJob_Vtbl {
        unsafe extern "system" fn BeginSave<Impl: IMFSaveJob_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstream: ::windows::core::RawPtr, pcallback: ::windows::core::RawPtr, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginSave(::core::mem::transmute(&pstream), ::core::mem::transmute(&pcallback), ::core::mem::transmute(&pstate)).into()
        }
        unsafe extern "system" fn EndSave<Impl: IMFSaveJob_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndSave(::core::mem::transmute(&presult)).into()
        }
        unsafe extern "system" fn CancelSave<Impl: IMFSaveJob_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CancelSave().into()
        }
        unsafe extern "system" fn GetProgress<Impl: IMFSaveJob_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwpercentcomplete: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProgress() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwpercentcomplete = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            BeginSave: BeginSave::<Impl, IMPL_OFFSET>,
            EndSave: EndSave::<Impl, IMPL_OFFSET>,
            CancelSave: CancelSave::<Impl, IMPL_OFFSET>,
            GetProgress: GetProgress::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSaveJob as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_Shell_PropertiesSystem"))]
pub trait IMFSchemeHandler_Impl: Sized {
    fn BeginCreateObject(&mut self, pwszurl: super::super::Foundation::PWSTR, dwflags: u32, pprops: ::core::option::Option<super::super::UI::Shell::PropertiesSystem::IPropertyStore>, ppiunknowncancelcookie: *mut ::core::option::Option<::windows::core::IUnknown>, pcallback: ::core::option::Option<IMFAsyncCallback>, punkstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndCreateObject(&mut self, presult: ::core::option::Option<IMFAsyncResult>, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn CancelObjectCreation(&mut self, piunknowncancelcookie: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_Shell_PropertiesSystem"))]
impl IMFSchemeHandler_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSchemeHandler_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSchemeHandler_Vtbl {
        unsafe extern "system" fn BeginCreateObject<Impl: IMFSchemeHandler_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwszurl: super::super::Foundation::PWSTR, dwflags: u32, pprops: ::windows::core::RawPtr, ppiunknowncancelcookie: *mut *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginCreateObject(::core::mem::transmute_copy(&pwszurl), ::core::mem::transmute_copy(&dwflags), ::core::mem::transmute(&pprops), ::core::mem::transmute_copy(&ppiunknowncancelcookie), ::core::mem::transmute(&pcallback), ::core::mem::transmute(&punkstate)).into()
        }
        unsafe extern "system" fn EndCreateObject<Impl: IMFSchemeHandler_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndCreateObject(::core::mem::transmute(&presult), ::core::mem::transmute_copy(&pobjecttype), ::core::mem::transmute_copy(&ppobject)).into()
        }
        unsafe extern "system" fn CancelObjectCreation<Impl: IMFSchemeHandler_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, piunknowncancelcookie: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CancelObjectCreation(::core::mem::transmute(&piunknowncancelcookie)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            BeginCreateObject: BeginCreateObject::<Impl, IMPL_OFFSET>,
            EndCreateObject: EndCreateObject::<Impl, IMPL_OFFSET>,
            CancelObjectCreation: CancelObjectCreation::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSchemeHandler as ::windows::core::Interface>::IID
    }
}
pub trait IMFSecureBuffer_Impl: Sized {
    fn GetIdentifier(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
}
impl IMFSecureBuffer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSecureBuffer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSecureBuffer_Vtbl {
        unsafe extern "system" fn GetIdentifier<Impl: IMFSecureBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguididentifier: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIdentifier() {
                ::core::result::Result::Ok(ok__) => {
                    *pguididentifier = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetIdentifier: GetIdentifier::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSecureBuffer as ::windows::core::Interface>::IID
    }
}
pub trait IMFSecureChannel_Impl: Sized {
    fn GetCertificate(&mut self, ppcert: *mut *mut u8, pcbcert: *mut u32) -> ::windows::core::Result<()>;
    fn SetupSession(&mut self, pbencryptedsessionkey: *const u8, cbsessionkey: u32) -> ::windows::core::Result<()>;
}
impl IMFSecureChannel_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSecureChannel_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSecureChannel_Vtbl {
        unsafe extern "system" fn GetCertificate<Impl: IMFSecureChannel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppcert: *mut *mut u8, pcbcert: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCertificate(::core::mem::transmute_copy(&ppcert), ::core::mem::transmute_copy(&pcbcert)).into()
        }
        unsafe extern "system" fn SetupSession<Impl: IMFSecureChannel_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbencryptedsessionkey: *const u8, cbsessionkey: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetupSession(::core::mem::transmute_copy(&pbencryptedsessionkey), ::core::mem::transmute_copy(&cbsessionkey)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetCertificate: GetCertificate::<Impl, IMPL_OFFSET>,
            SetupSession: SetupSession::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSecureChannel as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFSeekInfo_Impl: Sized {
    fn GetNearestKeyFrames(&mut self, pguidtimeformat: *const ::windows::core::GUID, pvarstartposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pvarpreviouskeyframe: *mut super::super::System::Com::StructuredStorage::PROPVARIANT, pvarnextkeyframe: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFSeekInfo_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSeekInfo_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSeekInfo_Vtbl {
        unsafe extern "system" fn GetNearestKeyFrames<Impl: IMFSeekInfo_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pguidtimeformat: *const ::windows::core::GUID, pvarstartposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pvarpreviouskeyframe: *mut super::super::System::Com::StructuredStorage::PROPVARIANT, pvarnextkeyframe: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNearestKeyFrames(::core::mem::transmute_copy(&pguidtimeformat), ::core::mem::transmute_copy(&pvarstartposition), ::core::mem::transmute_copy(&pvarpreviouskeyframe), ::core::mem::transmute_copy(&pvarnextkeyframe)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetNearestKeyFrames: GetNearestKeyFrames::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSeekInfo as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFSensorActivitiesReport_Impl: Sized {
    fn GetCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetActivityReport(&mut self, index: u32) -> ::windows::core::Result<IMFSensorActivityReport>;
    fn GetActivityReportByDeviceName(&mut self, symbolicname: super::super::Foundation::PWSTR) -> ::windows::core::Result<IMFSensorActivityReport>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFSensorActivitiesReport_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSensorActivitiesReport_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSensorActivitiesReport_Vtbl {
        unsafe extern "system" fn GetCount<Impl: IMFSensorActivitiesReport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pccount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pccount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetActivityReport<Impl: IMFSensorActivitiesReport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, sensoractivityreport: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetActivityReport(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    *sensoractivityreport = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetActivityReportByDeviceName<Impl: IMFSensorActivitiesReport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, symbolicname: super::super::Foundation::PWSTR, sensoractivityreport: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetActivityReportByDeviceName(::core::mem::transmute_copy(&symbolicname)) {
                ::core::result::Result::Ok(ok__) => {
                    *sensoractivityreport = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetCount: GetCount::<Impl, IMPL_OFFSET>,
            GetActivityReport: GetActivityReport::<Impl, IMPL_OFFSET>,
            GetActivityReportByDeviceName: GetActivityReportByDeviceName::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSensorActivitiesReport as ::windows::core::Interface>::IID
    }
}
pub trait IMFSensorActivitiesReportCallback_Impl: Sized {
    fn OnActivitiesReport(&mut self, sensoractivitiesreport: ::core::option::Option<IMFSensorActivitiesReport>) -> ::windows::core::Result<()>;
}
impl IMFSensorActivitiesReportCallback_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSensorActivitiesReportCallback_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSensorActivitiesReportCallback_Vtbl {
        unsafe extern "system" fn OnActivitiesReport<Impl: IMFSensorActivitiesReportCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, sensoractivitiesreport: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnActivitiesReport(::core::mem::transmute(&sensoractivitiesreport)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), OnActivitiesReport: OnActivitiesReport::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSensorActivitiesReportCallback as ::windows::core::Interface>::IID
    }
}
pub trait IMFSensorActivityMonitor_Impl: Sized {
    fn Start(&mut self) -> ::windows::core::Result<()>;
    fn Stop(&mut self) -> ::windows::core::Result<()>;
}
impl IMFSensorActivityMonitor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSensorActivityMonitor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSensorActivityMonitor_Vtbl {
        unsafe extern "system" fn Start<Impl: IMFSensorActivityMonitor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Start().into()
        }
        unsafe extern "system" fn Stop<Impl: IMFSensorActivityMonitor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Start: Start::<Impl, IMPL_OFFSET>, Stop: Stop::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSensorActivityMonitor as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFSensorActivityReport_Impl: Sized {
    fn GetFriendlyName(&mut self, friendlyname: super::super::Foundation::PWSTR, cchfriendlyname: u32, pcchwritten: *mut u32) -> ::windows::core::Result<()>;
    fn GetSymbolicLink(&mut self, symboliclink: super::super::Foundation::PWSTR, cchsymboliclink: u32, pcchwritten: *mut u32) -> ::windows::core::Result<()>;
    fn GetProcessCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetProcessActivity(&mut self, index: u32) -> ::windows::core::Result<IMFSensorProcessActivity>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFSensorActivityReport_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSensorActivityReport_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSensorActivityReport_Vtbl {
        unsafe extern "system" fn GetFriendlyName<Impl: IMFSensorActivityReport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, friendlyname: super::super::Foundation::PWSTR, cchfriendlyname: u32, pcchwritten: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetFriendlyName(::core::mem::transmute_copy(&friendlyname), ::core::mem::transmute_copy(&cchfriendlyname), ::core::mem::transmute_copy(&pcchwritten)).into()
        }
        unsafe extern "system" fn GetSymbolicLink<Impl: IMFSensorActivityReport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, symboliclink: super::super::Foundation::PWSTR, cchsymboliclink: u32, pcchwritten: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSymbolicLink(::core::mem::transmute_copy(&symboliclink), ::core::mem::transmute_copy(&cchsymboliclink), ::core::mem::transmute_copy(&pcchwritten)).into()
        }
        unsafe extern "system" fn GetProcessCount<Impl: IMFSensorActivityReport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pccount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProcessCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pccount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProcessActivity<Impl: IMFSensorActivityReport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, ppprocessactivity: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProcessActivity(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppprocessactivity = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetFriendlyName: GetFriendlyName::<Impl, IMPL_OFFSET>,
            GetSymbolicLink: GetSymbolicLink::<Impl, IMPL_OFFSET>,
            GetProcessCount: GetProcessCount::<Impl, IMPL_OFFSET>,
            GetProcessActivity: GetProcessActivity::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSensorActivityReport as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFSensorDevice_Impl: Sized {
    fn GetDeviceId(&mut self) -> ::windows::core::Result<u64>;
    fn GetDeviceType(&mut self) -> ::windows::core::Result<MFSensorDeviceType>;
    fn GetFlags(&mut self) -> ::windows::core::Result<u64>;
    fn GetSymbolicLink(&mut self, symboliclink: super::super::Foundation::PWSTR, cchsymboliclink: i32, pcchwritten: *mut i32) -> ::windows::core::Result<()>;
    fn GetDeviceAttributes(&mut self) -> ::windows::core::Result<IMFAttributes>;
    fn GetStreamAttributesCount(&mut self, etype: MFSensorStreamType) -> ::windows::core::Result<u32>;
    fn GetStreamAttributes(&mut self, etype: MFSensorStreamType, dwindex: u32) -> ::windows::core::Result<IMFAttributes>;
    fn SetSensorDeviceMode(&mut self, emode: MFSensorDeviceMode) -> ::windows::core::Result<()>;
    fn GetSensorDeviceMode(&mut self) -> ::windows::core::Result<MFSensorDeviceMode>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFSensorDevice_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSensorDevice_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSensorDevice_Vtbl {
        unsafe extern "system" fn GetDeviceId<Impl: IMFSensorDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdeviceid: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDeviceId() {
                ::core::result::Result::Ok(ok__) => {
                    *pdeviceid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDeviceType<Impl: IMFSensorDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptype: *mut MFSensorDeviceType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDeviceType() {
                ::core::result::Result::Ok(ok__) => {
                    *ptype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFlags<Impl: IMFSensorDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pflags: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFlags() {
                ::core::result::Result::Ok(ok__) => {
                    *pflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSymbolicLink<Impl: IMFSensorDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, symboliclink: super::super::Foundation::PWSTR, cchsymboliclink: i32, pcchwritten: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSymbolicLink(::core::mem::transmute_copy(&symboliclink), ::core::mem::transmute_copy(&cchsymboliclink), ::core::mem::transmute_copy(&pcchwritten)).into()
        }
        unsafe extern "system" fn GetDeviceAttributes<Impl: IMFSensorDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppattributes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDeviceAttributes() {
                ::core::result::Result::Ok(ok__) => {
                    *ppattributes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamAttributesCount<Impl: IMFSensorDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, etype: MFSensorStreamType, pdwcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamAttributesCount(::core::mem::transmute_copy(&etype)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamAttributes<Impl: IMFSensorDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, etype: MFSensorStreamType, dwindex: u32, ppattributes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamAttributes(::core::mem::transmute_copy(&etype), ::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppattributes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetSensorDeviceMode<Impl: IMFSensorDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, emode: MFSensorDeviceMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSensorDeviceMode(::core::mem::transmute_copy(&emode)).into()
        }
        unsafe extern "system" fn GetSensorDeviceMode<Impl: IMFSensorDevice_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pemode: *mut MFSensorDeviceMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSensorDeviceMode() {
                ::core::result::Result::Ok(ok__) => {
                    *pemode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetDeviceId: GetDeviceId::<Impl, IMPL_OFFSET>,
            GetDeviceType: GetDeviceType::<Impl, IMPL_OFFSET>,
            GetFlags: GetFlags::<Impl, IMPL_OFFSET>,
            GetSymbolicLink: GetSymbolicLink::<Impl, IMPL_OFFSET>,
            GetDeviceAttributes: GetDeviceAttributes::<Impl, IMPL_OFFSET>,
            GetStreamAttributesCount: GetStreamAttributesCount::<Impl, IMPL_OFFSET>,
            GetStreamAttributes: GetStreamAttributes::<Impl, IMPL_OFFSET>,
            SetSensorDeviceMode: SetSensorDeviceMode::<Impl, IMPL_OFFSET>,
            GetSensorDeviceMode: GetSensorDeviceMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSensorDevice as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFSensorGroup_Impl: Sized {
    fn GetSymbolicLink(&mut self, symboliclink: super::super::Foundation::PWSTR, cchsymboliclink: i32, pcchwritten: *mut i32) -> ::windows::core::Result<()>;
    fn GetFlags(&mut self) -> ::windows::core::Result<u64>;
    fn GetSensorGroupAttributes(&mut self) -> ::windows::core::Result<IMFAttributes>;
    fn GetSensorDeviceCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetSensorDevice(&mut self, dwindex: u32) -> ::windows::core::Result<IMFSensorDevice>;
    fn SetDefaultSensorDeviceIndex(&mut self, dwindex: u32) -> ::windows::core::Result<()>;
    fn GetDefaultSensorDeviceIndex(&mut self) -> ::windows::core::Result<u32>;
    fn CreateMediaSource(&mut self) -> ::windows::core::Result<IMFMediaSource>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFSensorGroup_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSensorGroup_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSensorGroup_Vtbl {
        unsafe extern "system" fn GetSymbolicLink<Impl: IMFSensorGroup_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, symboliclink: super::super::Foundation::PWSTR, cchsymboliclink: i32, pcchwritten: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSymbolicLink(::core::mem::transmute_copy(&symboliclink), ::core::mem::transmute_copy(&cchsymboliclink), ::core::mem::transmute_copy(&pcchwritten)).into()
        }
        unsafe extern "system" fn GetFlags<Impl: IMFSensorGroup_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pflags: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFlags() {
                ::core::result::Result::Ok(ok__) => {
                    *pflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSensorGroupAttributes<Impl: IMFSensorGroup_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppattributes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSensorGroupAttributes() {
                ::core::result::Result::Ok(ok__) => {
                    *ppattributes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSensorDeviceCount<Impl: IMFSensorGroup_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSensorDeviceCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSensorDevice<Impl: IMFSensorGroup_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppdevice: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSensorDevice(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdevice = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetDefaultSensorDeviceIndex<Impl: IMFSensorGroup_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDefaultSensorDeviceIndex(::core::mem::transmute_copy(&dwindex)).into()
        }
        unsafe extern "system" fn GetDefaultSensorDeviceIndex<Impl: IMFSensorGroup_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwindex: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDefaultSensorDeviceIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwindex = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateMediaSource<Impl: IMFSensorGroup_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppsource: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateMediaSource() {
                ::core::result::Result::Ok(ok__) => {
                    *ppsource = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetSymbolicLink: GetSymbolicLink::<Impl, IMPL_OFFSET>,
            GetFlags: GetFlags::<Impl, IMPL_OFFSET>,
            GetSensorGroupAttributes: GetSensorGroupAttributes::<Impl, IMPL_OFFSET>,
            GetSensorDeviceCount: GetSensorDeviceCount::<Impl, IMPL_OFFSET>,
            GetSensorDevice: GetSensorDevice::<Impl, IMPL_OFFSET>,
            SetDefaultSensorDeviceIndex: SetDefaultSensorDeviceIndex::<Impl, IMPL_OFFSET>,
            GetDefaultSensorDeviceIndex: GetDefaultSensorDeviceIndex::<Impl, IMPL_OFFSET>,
            CreateMediaSource: CreateMediaSource::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSensorGroup as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFSensorProcessActivity_Impl: Sized {
    fn GetProcessId(&mut self) -> ::windows::core::Result<u32>;
    fn GetStreamingState(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetStreamingMode(&mut self) -> ::windows::core::Result<MFSensorDeviceMode>;
    fn GetReportTime(&mut self) -> ::windows::core::Result<super::super::Foundation::FILETIME>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFSensorProcessActivity_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSensorProcessActivity_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSensorProcessActivity_Vtbl {
        unsafe extern "system" fn GetProcessId<Impl: IMFSensorProcessActivity_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProcessId() {
                ::core::result::Result::Ok(ok__) => {
                    *ppid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamingState<Impl: IMFSensorProcessActivity_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfstreaming: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamingState() {
                ::core::result::Result::Ok(ok__) => {
                    *pfstreaming = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStreamingMode<Impl: IMFSensorProcessActivity_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmode: *mut MFSensorDeviceMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamingMode() {
                ::core::result::Result::Ok(ok__) => {
                    *pmode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetReportTime<Impl: IMFSensorProcessActivity_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pft: *mut super::super::Foundation::FILETIME) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetReportTime() {
                ::core::result::Result::Ok(ok__) => {
                    *pft = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetProcessId: GetProcessId::<Impl, IMPL_OFFSET>,
            GetStreamingState: GetStreamingState::<Impl, IMPL_OFFSET>,
            GetStreamingMode: GetStreamingMode::<Impl, IMPL_OFFSET>,
            GetReportTime: GetReportTime::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSensorProcessActivity as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFSensorProfile_Impl: Sized {
    fn GetProfileId(&mut self) -> ::windows::core::Result<SENSORPROFILEID>;
    fn AddProfileFilter(&mut self, streamid: u32, wzfiltersetstring: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn IsMediaTypeSupported(&mut self, streamid: u32, pmediatype: ::core::option::Option<IMFMediaType>) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn AddBlockedControl(&mut self, wzblockedcontrol: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFSensorProfile_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSensorProfile_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSensorProfile_Vtbl {
        unsafe extern "system" fn GetProfileId<Impl: IMFSensorProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pid: *mut SENSORPROFILEID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProfileId() {
                ::core::result::Result::Ok(ok__) => {
                    *pid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddProfileFilter<Impl: IMFSensorProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, streamid: u32, wzfiltersetstring: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddProfileFilter(::core::mem::transmute_copy(&streamid), ::core::mem::transmute_copy(&wzfiltersetstring)).into()
        }
        unsafe extern "system" fn IsMediaTypeSupported<Impl: IMFSensorProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, streamid: u32, pmediatype: ::windows::core::RawPtr, pfsupported: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsMediaTypeSupported(::core::mem::transmute_copy(&streamid), ::core::mem::transmute(&pmediatype)) {
                ::core::result::Result::Ok(ok__) => {
                    *pfsupported = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddBlockedControl<Impl: IMFSensorProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wzblockedcontrol: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddBlockedControl(::core::mem::transmute_copy(&wzblockedcontrol)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetProfileId: GetProfileId::<Impl, IMPL_OFFSET>,
            AddProfileFilter: AddProfileFilter::<Impl, IMPL_OFFSET>,
            IsMediaTypeSupported: IsMediaTypeSupported::<Impl, IMPL_OFFSET>,
            AddBlockedControl: AddBlockedControl::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSensorProfile as ::windows::core::Interface>::IID
    }
}
pub trait IMFSensorProfileCollection_Impl: Sized {
    fn GetProfileCount(&mut self) -> u32;
    fn GetProfile(&mut self, index: u32) -> ::windows::core::Result<IMFSensorProfile>;
    fn AddProfile(&mut self, pprofile: ::core::option::Option<IMFSensorProfile>) -> ::windows::core::Result<()>;
    fn FindProfile(&mut self, profileid: *const SENSORPROFILEID) -> ::windows::core::Result<IMFSensorProfile>;
    fn RemoveProfileByIndex(&mut self, index: u32);
    fn RemoveProfile(&mut self, profileid: *const SENSORPROFILEID);
}
impl IMFSensorProfileCollection_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSensorProfileCollection_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSensorProfileCollection_Vtbl {
        unsafe extern "system" fn GetProfileCount<Impl: IMFSensorProfileCollection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetProfileCount()
        }
        unsafe extern "system" fn GetProfile<Impl: IMFSensorProfileCollection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, ppprofile: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProfile(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppprofile = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddProfile<Impl: IMFSensorProfileCollection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pprofile: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddProfile(::core::mem::transmute(&pprofile)).into()
        }
        unsafe extern "system" fn FindProfile<Impl: IMFSensorProfileCollection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, profileid: *const SENSORPROFILEID, ppprofile: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).FindProfile(::core::mem::transmute_copy(&profileid)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppprofile = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveProfileByIndex<Impl: IMFSensorProfileCollection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveProfileByIndex(::core::mem::transmute_copy(&index))
        }
        unsafe extern "system" fn RemoveProfile<Impl: IMFSensorProfileCollection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, profileid: *const SENSORPROFILEID) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveProfile(::core::mem::transmute_copy(&profileid))
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetProfileCount: GetProfileCount::<Impl, IMPL_OFFSET>,
            GetProfile: GetProfile::<Impl, IMPL_OFFSET>,
            AddProfile: AddProfile::<Impl, IMPL_OFFSET>,
            FindProfile: FindProfile::<Impl, IMPL_OFFSET>,
            RemoveProfileByIndex: RemoveProfileByIndex::<Impl, IMPL_OFFSET>,
            RemoveProfile: RemoveProfile::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSensorProfileCollection as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFSensorStream_Impl: Sized + IMFAttributes_Impl {
    fn GetMediaTypeCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetMediaType(&mut self, dwindex: u32) -> ::windows::core::Result<IMFMediaType>;
    fn CloneSensorStream(&mut self) -> ::windows::core::Result<IMFSensorStream>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFSensorStream_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSensorStream_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSensorStream_Vtbl {
        unsafe extern "system" fn GetMediaTypeCount<Impl: IMFSensorStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMediaTypeCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaType<Impl: IMFSensorStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppmediatype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMediaType(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediatype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CloneSensorStream<Impl: IMFSensorStream_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppstream: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CloneSensorStream() {
                ::core::result::Result::Ok(ok__) => {
                    *ppstream = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMFAttributes_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetMediaTypeCount: GetMediaTypeCount::<Impl, IMPL_OFFSET>,
            GetMediaType: GetMediaType::<Impl, IMPL_OFFSET>,
            CloneSensorStream: CloneSensorStream::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSensorStream as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_Streaming")]
pub trait IMFSensorTransformFactory_Impl: Sized {
    fn GetFactoryAttributes(&mut self) -> ::windows::core::Result<IMFAttributes>;
    fn InitializeFactory(&mut self, dwmaxtransformcount: u32, psensordevices: ::core::option::Option<IMFCollection>, pattributes: ::core::option::Option<IMFAttributes>) -> ::windows::core::Result<()>;
    fn GetTransformCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetTransformInformation(&mut self, transformindex: u32, pguidtransformid: *mut ::windows::core::GUID, ppattributes: *mut ::core::option::Option<IMFAttributes>, ppstreaminformation: *mut ::core::option::Option<IMFCollection>) -> ::windows::core::Result<()>;
    fn CreateTransform(&mut self, guidsensortransformid: *const ::windows::core::GUID, pattributes: ::core::option::Option<IMFAttributes>) -> ::windows::core::Result<super::Streaming::IMFDeviceTransform>;
}
#[cfg(feature = "Win32_Media_Streaming")]
impl IMFSensorTransformFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSensorTransformFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSensorTransformFactory_Vtbl {
        unsafe extern "system" fn GetFactoryAttributes<Impl: IMFSensorTransformFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppattributes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFactoryAttributes() {
                ::core::result::Result::Ok(ok__) => {
                    *ppattributes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn InitializeFactory<Impl: IMFSensorTransformFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwmaxtransformcount: u32, psensordevices: ::windows::core::RawPtr, pattributes: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InitializeFactory(::core::mem::transmute_copy(&dwmaxtransformcount), ::core::mem::transmute(&psensordevices), ::core::mem::transmute(&pattributes)).into()
        }
        unsafe extern "system" fn GetTransformCount<Impl: IMFSensorTransformFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTransformCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTransformInformation<Impl: IMFSensorTransformFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, transformindex: u32, pguidtransformid: *mut ::windows::core::GUID, ppattributes: *mut ::windows::core::RawPtr, ppstreaminformation: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTransformInformation(::core::mem::transmute_copy(&transformindex), ::core::mem::transmute_copy(&pguidtransformid), ::core::mem::transmute_copy(&ppattributes), ::core::mem::transmute_copy(&ppstreaminformation)).into()
        }
        unsafe extern "system" fn CreateTransform<Impl: IMFSensorTransformFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidsensortransformid: *const ::windows::core::GUID, pattributes: ::windows::core::RawPtr, ppdevicemft: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateTransform(::core::mem::transmute_copy(&guidsensortransformid), ::core::mem::transmute(&pattributes)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppdevicemft = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetFactoryAttributes: GetFactoryAttributes::<Impl, IMPL_OFFSET>,
            InitializeFactory: InitializeFactory::<Impl, IMPL_OFFSET>,
            GetTransformCount: GetTransformCount::<Impl, IMPL_OFFSET>,
            GetTransformInformation: GetTransformInformation::<Impl, IMPL_OFFSET>,
            CreateTransform: CreateTransform::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSensorTransformFactory as ::windows::core::Interface>::IID
    }
}
pub trait IMFSequencerSource_Impl: Sized {
    fn AppendTopology(&mut self, ptopology: ::core::option::Option<IMFTopology>, dwflags: u32) -> ::windows::core::Result<u32>;
    fn DeleteTopology(&mut self, dwid: u32) -> ::windows::core::Result<()>;
    fn GetPresentationContext(&mut self, ppd: ::core::option::Option<IMFPresentationDescriptor>, pid: *mut u32, pptopology: *mut ::core::option::Option<IMFTopology>) -> ::windows::core::Result<()>;
    fn UpdateTopology(&mut self, dwid: u32, ptopology: ::core::option::Option<IMFTopology>) -> ::windows::core::Result<()>;
    fn UpdateTopologyFlags(&mut self, dwid: u32, dwflags: u32) -> ::windows::core::Result<()>;
}
impl IMFSequencerSource_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSequencerSource_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSequencerSource_Vtbl {
        unsafe extern "system" fn AppendTopology<Impl: IMFSequencerSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptopology: ::windows::core::RawPtr, dwflags: u32, pdwid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AppendTopology(::core::mem::transmute(&ptopology), ::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DeleteTopology<Impl: IMFSequencerSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DeleteTopology(::core::mem::transmute_copy(&dwid)).into()
        }
        unsafe extern "system" fn GetPresentationContext<Impl: IMFSequencerSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppd: ::windows::core::RawPtr, pid: *mut u32, pptopology: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPresentationContext(::core::mem::transmute(&ppd), ::core::mem::transmute_copy(&pid), ::core::mem::transmute_copy(&pptopology)).into()
        }
        unsafe extern "system" fn UpdateTopology<Impl: IMFSequencerSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwid: u32, ptopology: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UpdateTopology(::core::mem::transmute_copy(&dwid), ::core::mem::transmute(&ptopology)).into()
        }
        unsafe extern "system" fn UpdateTopologyFlags<Impl: IMFSequencerSource_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwid: u32, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UpdateTopologyFlags(::core::mem::transmute_copy(&dwid), ::core::mem::transmute_copy(&dwflags)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            AppendTopology: AppendTopology::<Impl, IMPL_OFFSET>,
            DeleteTopology: DeleteTopology::<Impl, IMPL_OFFSET>,
            GetPresentationContext: GetPresentationContext::<Impl, IMPL_OFFSET>,
            UpdateTopology: UpdateTopology::<Impl, IMPL_OFFSET>,
            UpdateTopologyFlags: UpdateTopologyFlags::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSequencerSource as ::windows::core::Interface>::IID
    }
}
pub trait IMFSharingEngineClassFactory_Impl: Sized {
    fn CreateInstance(&mut self, dwflags: u32, pattr: ::core::option::Option<IMFAttributes>) -> ::windows::core::Result<::windows::core::IUnknown>;
}
impl IMFSharingEngineClassFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSharingEngineClassFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSharingEngineClassFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IMFSharingEngineClassFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32, pattr: ::windows::core::RawPtr, ppengine: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(::core::mem::transmute_copy(&dwflags), ::core::mem::transmute(&pattr)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppengine = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSharingEngineClassFactory as ::windows::core::Interface>::IID
    }
}
pub trait IMFShutdown_Impl: Sized {
    fn Shutdown(&mut self) -> ::windows::core::Result<()>;
    fn GetShutdownStatus(&mut self) -> ::windows::core::Result<MFSHUTDOWN_STATUS>;
}
impl IMFShutdown_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFShutdown_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFShutdown_Vtbl {
        unsafe extern "system" fn Shutdown<Impl: IMFShutdown_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Shutdown().into()
        }
        unsafe extern "system" fn GetShutdownStatus<Impl: IMFShutdown_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstatus: *mut MFSHUTDOWN_STATUS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetShutdownStatus() {
                ::core::result::Result::Ok(ok__) => {
                    *pstatus = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Shutdown: Shutdown::<Impl, IMPL_OFFSET>,
            GetShutdownStatus: GetShutdownStatus::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFShutdown as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFSignedLibrary_Impl: Sized {
    fn GetProcedureAddress(&mut self, name: super::super::Foundation::PSTR, address: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFSignedLibrary_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSignedLibrary_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSignedLibrary_Vtbl {
        unsafe extern "system" fn GetProcedureAddress<Impl: IMFSignedLibrary_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, name: super::super::Foundation::PSTR, address: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetProcedureAddress(::core::mem::transmute_copy(&name), ::core::mem::transmute_copy(&address)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetProcedureAddress: GetProcedureAddress::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSignedLibrary as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFSimpleAudioVolume_Impl: Sized {
    fn SetMasterVolume(&mut self, flevel: f32) -> ::windows::core::Result<()>;
    fn GetMasterVolume(&mut self) -> ::windows::core::Result<f32>;
    fn SetMute(&mut self, bmute: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetMute(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFSimpleAudioVolume_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSimpleAudioVolume_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSimpleAudioVolume_Vtbl {
        unsafe extern "system" fn SetMasterVolume<Impl: IMFSimpleAudioVolume_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, flevel: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMasterVolume(::core::mem::transmute_copy(&flevel)).into()
        }
        unsafe extern "system" fn GetMasterVolume<Impl: IMFSimpleAudioVolume_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pflevel: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMasterVolume() {
                ::core::result::Result::Ok(ok__) => {
                    *pflevel = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetMute<Impl: IMFSimpleAudioVolume_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bmute: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMute(::core::mem::transmute_copy(&bmute)).into()
        }
        unsafe extern "system" fn GetMute<Impl: IMFSimpleAudioVolume_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbmute: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMute() {
                ::core::result::Result::Ok(ok__) => {
                    *pbmute = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetMasterVolume: SetMasterVolume::<Impl, IMPL_OFFSET>,
            GetMasterVolume: GetMasterVolume::<Impl, IMPL_OFFSET>,
            SetMute: SetMute::<Impl, IMPL_OFFSET>,
            GetMute: GetMute::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSimpleAudioVolume as ::windows::core::Interface>::IID
    }
}
pub trait IMFSinkWriter_Impl: Sized {
    fn AddStream(&mut self, ptargetmediatype: ::core::option::Option<IMFMediaType>) -> ::windows::core::Result<u32>;
    fn SetInputMediaType(&mut self, dwstreamindex: u32, pinputmediatype: ::core::option::Option<IMFMediaType>, pencodingparameters: ::core::option::Option<IMFAttributes>) -> ::windows::core::Result<()>;
    fn BeginWriting(&mut self) -> ::windows::core::Result<()>;
    fn WriteSample(&mut self, dwstreamindex: u32, psample: ::core::option::Option<IMFSample>) -> ::windows::core::Result<()>;
    fn SendStreamTick(&mut self, dwstreamindex: u32, lltimestamp: i64) -> ::windows::core::Result<()>;
    fn PlaceMarker(&mut self, dwstreamindex: u32, pvcontext: *const ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn NotifyEndOfSegment(&mut self, dwstreamindex: u32) -> ::windows::core::Result<()>;
    fn Flush(&mut self, dwstreamindex: u32) -> ::windows::core::Result<()>;
    fn Finalize(&mut self) -> ::windows::core::Result<()>;
    fn GetServiceForStream(&mut self, dwstreamindex: u32, guidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn GetStatistics(&mut self, dwstreamindex: u32) -> ::windows::core::Result<MF_SINK_WRITER_STATISTICS>;
}
impl IMFSinkWriter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSinkWriter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSinkWriter_Vtbl {
        unsafe extern "system" fn AddStream<Impl: IMFSinkWriter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptargetmediatype: ::windows::core::RawPtr, pdwstreamindex: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddStream(::core::mem::transmute(&ptargetmediatype)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwstreamindex = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputMediaType<Impl: IMFSinkWriter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pinputmediatype: ::windows::core::RawPtr, pencodingparameters: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInputMediaType(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute(&pinputmediatype), ::core::mem::transmute(&pencodingparameters)).into()
        }
        unsafe extern "system" fn BeginWriting<Impl: IMFSinkWriter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginWriting().into()
        }
        unsafe extern "system" fn WriteSample<Impl: IMFSinkWriter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, psample: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).WriteSample(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute(&psample)).into()
        }
        unsafe extern "system" fn SendStreamTick<Impl: IMFSinkWriter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, lltimestamp: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SendStreamTick(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&lltimestamp)).into()
        }
        unsafe extern "system" fn PlaceMarker<Impl: IMFSinkWriter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pvcontext: *const ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlaceMarker(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&pvcontext)).into()
        }
        unsafe extern "system" fn NotifyEndOfSegment<Impl: IMFSinkWriter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NotifyEndOfSegment(::core::mem::transmute_copy(&dwstreamindex)).into()
        }
        unsafe extern "system" fn Flush<Impl: IMFSinkWriter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Flush(::core::mem::transmute_copy(&dwstreamindex)).into()
        }
        unsafe extern "system" fn Finalize<Impl: IMFSinkWriter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Finalize().into()
        }
        unsafe extern "system" fn GetServiceForStream<Impl: IMFSinkWriter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, guidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetServiceForStream(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&guidservice), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvobject)).into()
        }
        unsafe extern "system" fn GetStatistics<Impl: IMFSinkWriter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pstats: *mut MF_SINK_WRITER_STATISTICS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStatistics(::core::mem::transmute_copy(&dwstreamindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pstats = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            AddStream: AddStream::<Impl, IMPL_OFFSET>,
            SetInputMediaType: SetInputMediaType::<Impl, IMPL_OFFSET>,
            BeginWriting: BeginWriting::<Impl, IMPL_OFFSET>,
            WriteSample: WriteSample::<Impl, IMPL_OFFSET>,
            SendStreamTick: SendStreamTick::<Impl, IMPL_OFFSET>,
            PlaceMarker: PlaceMarker::<Impl, IMPL_OFFSET>,
            NotifyEndOfSegment: NotifyEndOfSegment::<Impl, IMPL_OFFSET>,
            Flush: Flush::<Impl, IMPL_OFFSET>,
            Finalize: Finalize::<Impl, IMPL_OFFSET>,
            GetServiceForStream: GetServiceForStream::<Impl, IMPL_OFFSET>,
            GetStatistics: GetStatistics::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSinkWriter as ::windows::core::Interface>::IID
    }
}
pub trait IMFSinkWriterCallback_Impl: Sized {
    fn OnFinalize(&mut self, hrstatus: ::windows::core::HRESULT) -> ::windows::core::Result<()>;
    fn OnMarker(&mut self, dwstreamindex: u32, pvcontext: *const ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
impl IMFSinkWriterCallback_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSinkWriterCallback_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSinkWriterCallback_Vtbl {
        unsafe extern "system" fn OnFinalize<Impl: IMFSinkWriterCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hrstatus: ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnFinalize(::core::mem::transmute_copy(&hrstatus)).into()
        }
        unsafe extern "system" fn OnMarker<Impl: IMFSinkWriterCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pvcontext: *const ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnMarker(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&pvcontext)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            OnFinalize: OnFinalize::<Impl, IMPL_OFFSET>,
            OnMarker: OnMarker::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSinkWriterCallback as ::windows::core::Interface>::IID
    }
}
pub trait IMFSinkWriterCallback2_Impl: Sized + IMFSinkWriterCallback_Impl {
    fn OnTransformChange(&mut self) -> ::windows::core::Result<()>;
    fn OnStreamError(&mut self, dwstreamindex: u32, hrstatus: ::windows::core::HRESULT) -> ::windows::core::Result<()>;
}
impl IMFSinkWriterCallback2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSinkWriterCallback2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSinkWriterCallback2_Vtbl {
        unsafe extern "system" fn OnTransformChange<Impl: IMFSinkWriterCallback2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnTransformChange().into()
        }
        unsafe extern "system" fn OnStreamError<Impl: IMFSinkWriterCallback2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, hrstatus: ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnStreamError(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&hrstatus)).into()
        }
        Self {
            base: IMFSinkWriterCallback_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            OnTransformChange: OnTransformChange::<Impl, IMPL_OFFSET>,
            OnStreamError: OnStreamError::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSinkWriterCallback2 as ::windows::core::Interface>::IID
    }
}
pub trait IMFSinkWriterEncoderConfig_Impl: Sized {
    fn SetTargetMediaType(&mut self, dwstreamindex: u32, ptargetmediatype: ::core::option::Option<IMFMediaType>, pencodingparameters: ::core::option::Option<IMFAttributes>) -> ::windows::core::Result<()>;
    fn PlaceEncodingParameters(&mut self, dwstreamindex: u32, pencodingparameters: ::core::option::Option<IMFAttributes>) -> ::windows::core::Result<()>;
}
impl IMFSinkWriterEncoderConfig_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSinkWriterEncoderConfig_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSinkWriterEncoderConfig_Vtbl {
        unsafe extern "system" fn SetTargetMediaType<Impl: IMFSinkWriterEncoderConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, ptargetmediatype: ::windows::core::RawPtr, pencodingparameters: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTargetMediaType(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute(&ptargetmediatype), ::core::mem::transmute(&pencodingparameters)).into()
        }
        unsafe extern "system" fn PlaceEncodingParameters<Impl: IMFSinkWriterEncoderConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pencodingparameters: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlaceEncodingParameters(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute(&pencodingparameters)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetTargetMediaType: SetTargetMediaType::<Impl, IMPL_OFFSET>,
            PlaceEncodingParameters: PlaceEncodingParameters::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSinkWriterEncoderConfig as ::windows::core::Interface>::IID
    }
}
pub trait IMFSinkWriterEx_Impl: Sized + IMFSinkWriter_Impl {
    fn GetTransformForStream(&mut self, dwstreamindex: u32, dwtransformindex: u32, pguidcategory: *mut ::windows::core::GUID, pptransform: *mut ::core::option::Option<IMFTransform>) -> ::windows::core::Result<()>;
}
impl IMFSinkWriterEx_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSinkWriterEx_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSinkWriterEx_Vtbl {
        unsafe extern "system" fn GetTransformForStream<Impl: IMFSinkWriterEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, dwtransformindex: u32, pguidcategory: *mut ::windows::core::GUID, pptransform: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTransformForStream(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&dwtransformindex), ::core::mem::transmute_copy(&pguidcategory), ::core::mem::transmute_copy(&pptransform)).into()
        }
        Self { base: IMFSinkWriter_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), GetTransformForStream: GetTransformForStream::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSinkWriterEx as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFSourceBuffer_Impl: Sized {
    fn GetUpdating(&mut self) -> super::super::Foundation::BOOL;
    fn GetBuffered(&mut self) -> ::windows::core::Result<IMFMediaTimeRange>;
    fn GetTimeStampOffset(&mut self) -> f64;
    fn SetTimeStampOffset(&mut self, offset: f64) -> ::windows::core::Result<()>;
    fn GetAppendWindowStart(&mut self) -> f64;
    fn SetAppendWindowStart(&mut self, time: f64) -> ::windows::core::Result<()>;
    fn GetAppendWindowEnd(&mut self) -> f64;
    fn SetAppendWindowEnd(&mut self, time: f64) -> ::windows::core::Result<()>;
    fn Append(&mut self, pdata: *const u8, len: u32) -> ::windows::core::Result<()>;
    fn AppendByteStream(&mut self, pstream: ::core::option::Option<IMFByteStream>, pmaxlen: *const u64) -> ::windows::core::Result<()>;
    fn Abort(&mut self) -> ::windows::core::Result<()>;
    fn Remove(&mut self, start: f64, end: f64) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFSourceBuffer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSourceBuffer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSourceBuffer_Vtbl {
        unsafe extern "system" fn GetUpdating<Impl: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetUpdating()
        }
        unsafe extern "system" fn GetBuffered<Impl: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppbuffered: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBuffered() {
                ::core::result::Result::Ok(ok__) => {
                    *ppbuffered = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTimeStampOffset<Impl: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTimeStampOffset()
        }
        unsafe extern "system" fn SetTimeStampOffset<Impl: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, offset: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTimeStampOffset(::core::mem::transmute_copy(&offset)).into()
        }
        unsafe extern "system" fn GetAppendWindowStart<Impl: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAppendWindowStart()
        }
        unsafe extern "system" fn SetAppendWindowStart<Impl: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, time: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAppendWindowStart(::core::mem::transmute_copy(&time)).into()
        }
        unsafe extern "system" fn GetAppendWindowEnd<Impl: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAppendWindowEnd()
        }
        unsafe extern "system" fn SetAppendWindowEnd<Impl: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, time: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAppendWindowEnd(::core::mem::transmute_copy(&time)).into()
        }
        unsafe extern "system" fn Append<Impl: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdata: *const u8, len: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Append(::core::mem::transmute_copy(&pdata), ::core::mem::transmute_copy(&len)).into()
        }
        unsafe extern "system" fn AppendByteStream<Impl: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pstream: ::windows::core::RawPtr, pmaxlen: *const u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AppendByteStream(::core::mem::transmute(&pstream), ::core::mem::transmute_copy(&pmaxlen)).into()
        }
        unsafe extern "system" fn Abort<Impl: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Abort().into()
        }
        unsafe extern "system" fn Remove<Impl: IMFSourceBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, start: f64, end: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Remove(::core::mem::transmute_copy(&start), ::core::mem::transmute_copy(&end)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetUpdating: GetUpdating::<Impl, IMPL_OFFSET>,
            GetBuffered: GetBuffered::<Impl, IMPL_OFFSET>,
            GetTimeStampOffset: GetTimeStampOffset::<Impl, IMPL_OFFSET>,
            SetTimeStampOffset: SetTimeStampOffset::<Impl, IMPL_OFFSET>,
            GetAppendWindowStart: GetAppendWindowStart::<Impl, IMPL_OFFSET>,
            SetAppendWindowStart: SetAppendWindowStart::<Impl, IMPL_OFFSET>,
            GetAppendWindowEnd: GetAppendWindowEnd::<Impl, IMPL_OFFSET>,
            SetAppendWindowEnd: SetAppendWindowEnd::<Impl, IMPL_OFFSET>,
            Append: Append::<Impl, IMPL_OFFSET>,
            AppendByteStream: AppendByteStream::<Impl, IMPL_OFFSET>,
            Abort: Abort::<Impl, IMPL_OFFSET>,
            Remove: Remove::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSourceBuffer as ::windows::core::Interface>::IID
    }
}
pub trait IMFSourceBufferAppendMode_Impl: Sized {
    fn GetAppendMode(&mut self) -> MF_MSE_APPEND_MODE;
    fn SetAppendMode(&mut self, mode: MF_MSE_APPEND_MODE) -> ::windows::core::Result<()>;
}
impl IMFSourceBufferAppendMode_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSourceBufferAppendMode_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSourceBufferAppendMode_Vtbl {
        unsafe extern "system" fn GetAppendMode<Impl: IMFSourceBufferAppendMode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> MF_MSE_APPEND_MODE {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAppendMode()
        }
        unsafe extern "system" fn SetAppendMode<Impl: IMFSourceBufferAppendMode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, mode: MF_MSE_APPEND_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAppendMode(::core::mem::transmute_copy(&mode)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetAppendMode: GetAppendMode::<Impl, IMPL_OFFSET>,
            SetAppendMode: SetAppendMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSourceBufferAppendMode as ::windows::core::Interface>::IID
    }
}
pub trait IMFSourceBufferList_Impl: Sized {
    fn GetLength(&mut self) -> u32;
    fn GetSourceBuffer(&mut self, index: u32) -> ::core::option::Option<IMFSourceBuffer>;
}
impl IMFSourceBufferList_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSourceBufferList_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSourceBufferList_Vtbl {
        unsafe extern "system" fn GetLength<Impl: IMFSourceBufferList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLength()
        }
        unsafe extern "system" fn GetSourceBuffer<Impl: IMFSourceBufferList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32) -> ::core::option::Option<IMFSourceBuffer> {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSourceBuffer(::core::mem::transmute_copy(&index))
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetSourceBuffer: GetSourceBuffer::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSourceBufferList as ::windows::core::Interface>::IID
    }
}
pub trait IMFSourceBufferNotify_Impl: Sized {
    fn OnUpdateStart(&mut self);
    fn OnAbort(&mut self);
    fn OnError(&mut self, hr: ::windows::core::HRESULT);
    fn OnUpdate(&mut self);
    fn OnUpdateEnd(&mut self);
}
impl IMFSourceBufferNotify_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSourceBufferNotify_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSourceBufferNotify_Vtbl {
        unsafe extern "system" fn OnUpdateStart<Impl: IMFSourceBufferNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnUpdateStart()
        }
        unsafe extern "system" fn OnAbort<Impl: IMFSourceBufferNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnAbort()
        }
        unsafe extern "system" fn OnError<Impl: IMFSourceBufferNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hr: ::windows::core::HRESULT) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnError(::core::mem::transmute_copy(&hr))
        }
        unsafe extern "system" fn OnUpdate<Impl: IMFSourceBufferNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnUpdate()
        }
        unsafe extern "system" fn OnUpdateEnd<Impl: IMFSourceBufferNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnUpdateEnd()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            OnUpdateStart: OnUpdateStart::<Impl, IMPL_OFFSET>,
            OnAbort: OnAbort::<Impl, IMPL_OFFSET>,
            OnError: OnError::<Impl, IMPL_OFFSET>,
            OnUpdate: OnUpdate::<Impl, IMPL_OFFSET>,
            OnUpdateEnd: OnUpdateEnd::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSourceBufferNotify as ::windows::core::Interface>::IID
    }
}
pub trait IMFSourceOpenMonitor_Impl: Sized {
    fn OnSourceEvent(&mut self, pevent: ::core::option::Option<IMFMediaEvent>) -> ::windows::core::Result<()>;
}
impl IMFSourceOpenMonitor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSourceOpenMonitor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSourceOpenMonitor_Vtbl {
        unsafe extern "system" fn OnSourceEvent<Impl: IMFSourceOpenMonitor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pevent: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnSourceEvent(::core::mem::transmute(&pevent)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), OnSourceEvent: OnSourceEvent::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSourceOpenMonitor as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFSourceReader_Impl: Sized {
    fn GetStreamSelection(&mut self, dwstreamindex: u32) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn SetStreamSelection(&mut self, dwstreamindex: u32, fselected: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetNativeMediaType(&mut self, dwstreamindex: u32, dwmediatypeindex: u32) -> ::windows::core::Result<IMFMediaType>;
    fn GetCurrentMediaType(&mut self, dwstreamindex: u32) -> ::windows::core::Result<IMFMediaType>;
    fn SetCurrentMediaType(&mut self, dwstreamindex: u32, pdwreserved: *mut u32, pmediatype: ::core::option::Option<IMFMediaType>) -> ::windows::core::Result<()>;
    fn SetCurrentPosition(&mut self, guidtimeformat: *const ::windows::core::GUID, varposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()>;
    fn ReadSample(&mut self, dwstreamindex: u32, dwcontrolflags: u32, pdwactualstreamindex: *mut u32, pdwstreamflags: *mut u32, plltimestamp: *mut i64, ppsample: *mut ::core::option::Option<IMFSample>) -> ::windows::core::Result<()>;
    fn Flush(&mut self, dwstreamindex: u32) -> ::windows::core::Result<()>;
    fn GetServiceForStream(&mut self, dwstreamindex: u32, guidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::Result<()>;
    fn GetPresentationAttribute(&mut self, dwstreamindex: u32, guidattribute: *const ::windows::core::GUID) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFSourceReader_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSourceReader_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSourceReader_Vtbl {
        unsafe extern "system" fn GetStreamSelection<Impl: IMFSourceReader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pfselected: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamSelection(::core::mem::transmute_copy(&dwstreamindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pfselected = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamSelection<Impl: IMFSourceReader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, fselected: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStreamSelection(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&fselected)).into()
        }
        unsafe extern "system" fn GetNativeMediaType<Impl: IMFSourceReader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, dwmediatypeindex: u32, ppmediatype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNativeMediaType(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&dwmediatypeindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediatype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCurrentMediaType<Impl: IMFSourceReader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, ppmediatype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentMediaType(::core::mem::transmute_copy(&dwstreamindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediatype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCurrentMediaType<Impl: IMFSourceReader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pdwreserved: *mut u32, pmediatype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCurrentMediaType(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&pdwreserved), ::core::mem::transmute(&pmediatype)).into()
        }
        unsafe extern "system" fn SetCurrentPosition<Impl: IMFSourceReader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidtimeformat: *const ::windows::core::GUID, varposition: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCurrentPosition(::core::mem::transmute_copy(&guidtimeformat), ::core::mem::transmute_copy(&varposition)).into()
        }
        unsafe extern "system" fn ReadSample<Impl: IMFSourceReader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, dwcontrolflags: u32, pdwactualstreamindex: *mut u32, pdwstreamflags: *mut u32, plltimestamp: *mut i64, ppsample: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ReadSample(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&dwcontrolflags), ::core::mem::transmute_copy(&pdwactualstreamindex), ::core::mem::transmute_copy(&pdwstreamflags), ::core::mem::transmute_copy(&plltimestamp), ::core::mem::transmute_copy(&ppsample)).into()
        }
        unsafe extern "system" fn Flush<Impl: IMFSourceReader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Flush(::core::mem::transmute_copy(&dwstreamindex)).into()
        }
        unsafe extern "system" fn GetServiceForStream<Impl: IMFSourceReader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, guidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetServiceForStream(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&guidservice), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvobject)).into()
        }
        unsafe extern "system" fn GetPresentationAttribute<Impl: IMFSourceReader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, guidattribute: *const ::windows::core::GUID, pvarattribute: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPresentationAttribute(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&guidattribute)) {
                ::core::result::Result::Ok(ok__) => {
                    *pvarattribute = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetStreamSelection: GetStreamSelection::<Impl, IMPL_OFFSET>,
            SetStreamSelection: SetStreamSelection::<Impl, IMPL_OFFSET>,
            GetNativeMediaType: GetNativeMediaType::<Impl, IMPL_OFFSET>,
            GetCurrentMediaType: GetCurrentMediaType::<Impl, IMPL_OFFSET>,
            SetCurrentMediaType: SetCurrentMediaType::<Impl, IMPL_OFFSET>,
            SetCurrentPosition: SetCurrentPosition::<Impl, IMPL_OFFSET>,
            ReadSample: ReadSample::<Impl, IMPL_OFFSET>,
            Flush: Flush::<Impl, IMPL_OFFSET>,
            GetServiceForStream: GetServiceForStream::<Impl, IMPL_OFFSET>,
            GetPresentationAttribute: GetPresentationAttribute::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSourceReader as ::windows::core::Interface>::IID
    }
}
pub trait IMFSourceReaderCallback_Impl: Sized {
    fn OnReadSample(&mut self, hrstatus: ::windows::core::HRESULT, dwstreamindex: u32, dwstreamflags: u32, lltimestamp: i64, psample: ::core::option::Option<IMFSample>) -> ::windows::core::Result<()>;
    fn OnFlush(&mut self, dwstreamindex: u32) -> ::windows::core::Result<()>;
    fn OnEvent(&mut self, dwstreamindex: u32, pevent: ::core::option::Option<IMFMediaEvent>) -> ::windows::core::Result<()>;
}
impl IMFSourceReaderCallback_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSourceReaderCallback_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSourceReaderCallback_Vtbl {
        unsafe extern "system" fn OnReadSample<Impl: IMFSourceReaderCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hrstatus: ::windows::core::HRESULT, dwstreamindex: u32, dwstreamflags: u32, lltimestamp: i64, psample: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnReadSample(::core::mem::transmute_copy(&hrstatus), ::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&dwstreamflags), ::core::mem::transmute_copy(&lltimestamp), ::core::mem::transmute(&psample)).into()
        }
        unsafe extern "system" fn OnFlush<Impl: IMFSourceReaderCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnFlush(::core::mem::transmute_copy(&dwstreamindex)).into()
        }
        unsafe extern "system" fn OnEvent<Impl: IMFSourceReaderCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pevent: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnEvent(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute(&pevent)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            OnReadSample: OnReadSample::<Impl, IMPL_OFFSET>,
            OnFlush: OnFlush::<Impl, IMPL_OFFSET>,
            OnEvent: OnEvent::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSourceReaderCallback as ::windows::core::Interface>::IID
    }
}
pub trait IMFSourceReaderCallback2_Impl: Sized + IMFSourceReaderCallback_Impl {
    fn OnTransformChange(&mut self) -> ::windows::core::Result<()>;
    fn OnStreamError(&mut self, dwstreamindex: u32, hrstatus: ::windows::core::HRESULT) -> ::windows::core::Result<()>;
}
impl IMFSourceReaderCallback2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSourceReaderCallback2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSourceReaderCallback2_Vtbl {
        unsafe extern "system" fn OnTransformChange<Impl: IMFSourceReaderCallback2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnTransformChange().into()
        }
        unsafe extern "system" fn OnStreamError<Impl: IMFSourceReaderCallback2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, hrstatus: ::windows::core::HRESULT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnStreamError(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&hrstatus)).into()
        }
        Self {
            base: IMFSourceReaderCallback_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            OnTransformChange: OnTransformChange::<Impl, IMPL_OFFSET>,
            OnStreamError: OnStreamError::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSourceReaderCallback2 as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFSourceReaderEx_Impl: Sized + IMFSourceReader_Impl {
    fn SetNativeMediaType(&mut self, dwstreamindex: u32, pmediatype: ::core::option::Option<IMFMediaType>) -> ::windows::core::Result<u32>;
    fn AddTransformForStream(&mut self, dwstreamindex: u32, ptransformoractivate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn RemoveAllTransformsForStream(&mut self, dwstreamindex: u32) -> ::windows::core::Result<()>;
    fn GetTransformForStream(&mut self, dwstreamindex: u32, dwtransformindex: u32, pguidcategory: *mut ::windows::core::GUID, pptransform: *mut ::core::option::Option<IMFTransform>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFSourceReaderEx_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSourceReaderEx_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSourceReaderEx_Vtbl {
        unsafe extern "system" fn SetNativeMediaType<Impl: IMFSourceReaderEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, pmediatype: ::windows::core::RawPtr, pdwstreamflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SetNativeMediaType(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute(&pmediatype)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwstreamflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddTransformForStream<Impl: IMFSourceReaderEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, ptransformoractivate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddTransformForStream(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute(&ptransformoractivate)).into()
        }
        unsafe extern "system" fn RemoveAllTransformsForStream<Impl: IMFSourceReaderEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveAllTransformsForStream(::core::mem::transmute_copy(&dwstreamindex)).into()
        }
        unsafe extern "system" fn GetTransformForStream<Impl: IMFSourceReaderEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamindex: u32, dwtransformindex: u32, pguidcategory: *mut ::windows::core::GUID, pptransform: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTransformForStream(::core::mem::transmute_copy(&dwstreamindex), ::core::mem::transmute_copy(&dwtransformindex), ::core::mem::transmute_copy(&pguidcategory), ::core::mem::transmute_copy(&pptransform)).into()
        }
        Self {
            base: IMFSourceReader_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetNativeMediaType: SetNativeMediaType::<Impl, IMPL_OFFSET>,
            AddTransformForStream: AddTransformForStream::<Impl, IMPL_OFFSET>,
            RemoveAllTransformsForStream: RemoveAllTransformsForStream::<Impl, IMPL_OFFSET>,
            GetTransformForStream: GetTransformForStream::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSourceReaderEx as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_Shell_PropertiesSystem"))]
pub trait IMFSourceResolver_Impl: Sized {
    fn CreateObjectFromURL(&mut self, pwszurl: super::super::Foundation::PWSTR, dwflags: u32, pprops: ::core::option::Option<super::super::UI::Shell::PropertiesSystem::IPropertyStore>, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn CreateObjectFromByteStream(&mut self, pbytestream: ::core::option::Option<IMFByteStream>, pwszurl: super::super::Foundation::PWSTR, dwflags: u32, pprops: ::core::option::Option<super::super::UI::Shell::PropertiesSystem::IPropertyStore>, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn BeginCreateObjectFromURL(&mut self, pwszurl: super::super::Foundation::PWSTR, dwflags: u32, pprops: ::core::option::Option<super::super::UI::Shell::PropertiesSystem::IPropertyStore>, ppiunknowncancelcookie: *mut ::core::option::Option<::windows::core::IUnknown>, pcallback: ::core::option::Option<IMFAsyncCallback>, punkstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndCreateObjectFromURL(&mut self, presult: ::core::option::Option<IMFAsyncResult>, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn BeginCreateObjectFromByteStream(&mut self, pbytestream: ::core::option::Option<IMFByteStream>, pwszurl: super::super::Foundation::PWSTR, dwflags: u32, pprops: ::core::option::Option<super::super::UI::Shell::PropertiesSystem::IPropertyStore>, ppiunknowncancelcookie: *mut ::core::option::Option<::windows::core::IUnknown>, pcallback: ::core::option::Option<IMFAsyncCallback>, punkstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndCreateObjectFromByteStream(&mut self, presult: ::core::option::Option<IMFAsyncResult>, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn CancelObjectCreation(&mut self, piunknowncancelcookie: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_UI_Shell_PropertiesSystem"))]
impl IMFSourceResolver_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSourceResolver_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSourceResolver_Vtbl {
        unsafe extern "system" fn CreateObjectFromURL<Impl: IMFSourceResolver_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwszurl: super::super::Foundation::PWSTR, dwflags: u32, pprops: ::windows::core::RawPtr, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateObjectFromURL(::core::mem::transmute_copy(&pwszurl), ::core::mem::transmute_copy(&dwflags), ::core::mem::transmute(&pprops), ::core::mem::transmute_copy(&pobjecttype), ::core::mem::transmute_copy(&ppobject)).into()
        }
        unsafe extern "system" fn CreateObjectFromByteStream<Impl: IMFSourceResolver_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbytestream: ::windows::core::RawPtr, pwszurl: super::super::Foundation::PWSTR, dwflags: u32, pprops: ::windows::core::RawPtr, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CreateObjectFromByteStream(::core::mem::transmute(&pbytestream), ::core::mem::transmute_copy(&pwszurl), ::core::mem::transmute_copy(&dwflags), ::core::mem::transmute(&pprops), ::core::mem::transmute_copy(&pobjecttype), ::core::mem::transmute_copy(&ppobject)).into()
        }
        unsafe extern "system" fn BeginCreateObjectFromURL<Impl: IMFSourceResolver_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwszurl: super::super::Foundation::PWSTR, dwflags: u32, pprops: ::windows::core::RawPtr, ppiunknowncancelcookie: *mut *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginCreateObjectFromURL(::core::mem::transmute_copy(&pwszurl), ::core::mem::transmute_copy(&dwflags), ::core::mem::transmute(&pprops), ::core::mem::transmute_copy(&ppiunknowncancelcookie), ::core::mem::transmute(&pcallback), ::core::mem::transmute(&punkstate)).into()
        }
        unsafe extern "system" fn EndCreateObjectFromURL<Impl: IMFSourceResolver_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndCreateObjectFromURL(::core::mem::transmute(&presult), ::core::mem::transmute_copy(&pobjecttype), ::core::mem::transmute_copy(&ppobject)).into()
        }
        unsafe extern "system" fn BeginCreateObjectFromByteStream<Impl: IMFSourceResolver_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbytestream: ::windows::core::RawPtr, pwszurl: super::super::Foundation::PWSTR, dwflags: u32, pprops: ::windows::core::RawPtr, ppiunknowncancelcookie: *mut *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginCreateObjectFromByteStream(::core::mem::transmute(&pbytestream), ::core::mem::transmute_copy(&pwszurl), ::core::mem::transmute_copy(&dwflags), ::core::mem::transmute(&pprops), ::core::mem::transmute_copy(&ppiunknowncancelcookie), ::core::mem::transmute(&pcallback), ::core::mem::transmute(&punkstate)).into()
        }
        unsafe extern "system" fn EndCreateObjectFromByteStream<Impl: IMFSourceResolver_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, pobjecttype: *mut MF_OBJECT_TYPE, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndCreateObjectFromByteStream(::core::mem::transmute(&presult), ::core::mem::transmute_copy(&pobjecttype), ::core::mem::transmute_copy(&ppobject)).into()
        }
        unsafe extern "system" fn CancelObjectCreation<Impl: IMFSourceResolver_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, piunknowncancelcookie: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CancelObjectCreation(::core::mem::transmute(&piunknowncancelcookie)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            CreateObjectFromURL: CreateObjectFromURL::<Impl, IMPL_OFFSET>,
            CreateObjectFromByteStream: CreateObjectFromByteStream::<Impl, IMPL_OFFSET>,
            BeginCreateObjectFromURL: BeginCreateObjectFromURL::<Impl, IMPL_OFFSET>,
            EndCreateObjectFromURL: EndCreateObjectFromURL::<Impl, IMPL_OFFSET>,
            BeginCreateObjectFromByteStream: BeginCreateObjectFromByteStream::<Impl, IMPL_OFFSET>,
            EndCreateObjectFromByteStream: EndCreateObjectFromByteStream::<Impl, IMPL_OFFSET>,
            CancelObjectCreation: CancelObjectCreation::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSourceResolver as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_Audio")]
pub trait IMFSpatialAudioObjectBuffer_Impl: Sized + IMFMediaBuffer_Impl {
    fn SetID(&mut self, u32id: u32) -> ::windows::core::Result<()>;
    fn GetID(&mut self) -> ::windows::core::Result<u32>;
    fn SetType(&mut self, r#type: super::Audio::AudioObjectType) -> ::windows::core::Result<()>;
    fn GetType(&mut self) -> ::windows::core::Result<super::Audio::AudioObjectType>;
    fn GetMetadataItems(&mut self) -> ::windows::core::Result<super::Audio::ISpatialAudioMetadataItems>;
}
#[cfg(feature = "Win32_Media_Audio")]
impl IMFSpatialAudioObjectBuffer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSpatialAudioObjectBuffer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSpatialAudioObjectBuffer_Vtbl {
        unsafe extern "system" fn SetID<Impl: IMFSpatialAudioObjectBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, u32id: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetID(::core::mem::transmute_copy(&u32id)).into()
        }
        unsafe extern "system" fn GetID<Impl: IMFSpatialAudioObjectBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pu32id: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetID() {
                ::core::result::Result::Ok(ok__) => {
                    *pu32id = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetType<Impl: IMFSpatialAudioObjectBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, r#type: super::Audio::AudioObjectType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetType(::core::mem::transmute_copy(&r#type)).into()
        }
        unsafe extern "system" fn GetType<Impl: IMFSpatialAudioObjectBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptype: *mut super::Audio::AudioObjectType) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetType() {
                ::core::result::Result::Ok(ok__) => {
                    *ptype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMetadataItems<Impl: IMFSpatialAudioObjectBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppmetadataitems: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMetadataItems() {
                ::core::result::Result::Ok(ok__) => {
                    *ppmetadataitems = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMFMediaBuffer_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetID: SetID::<Impl, IMPL_OFFSET>,
            GetID: GetID::<Impl, IMPL_OFFSET>,
            SetType: SetType::<Impl, IMPL_OFFSET>,
            GetType: GetType::<Impl, IMPL_OFFSET>,
            GetMetadataItems: GetMetadataItems::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSpatialAudioObjectBuffer as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFSpatialAudioSample_Impl: Sized + IMFAttributes_Impl + IMFSample_Impl {
    fn GetObjectCount(&mut self) -> ::windows::core::Result<u32>;
    fn AddSpatialAudioObject(&mut self, paudioobjbuffer: ::core::option::Option<IMFSpatialAudioObjectBuffer>) -> ::windows::core::Result<()>;
    fn GetSpatialAudioObjectByIndex(&mut self, dwindex: u32) -> ::windows::core::Result<IMFSpatialAudioObjectBuffer>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFSpatialAudioSample_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSpatialAudioSample_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSpatialAudioSample_Vtbl {
        unsafe extern "system" fn GetObjectCount<Impl: IMFSpatialAudioSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwobjectcount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetObjectCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwobjectcount = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddSpatialAudioObject<Impl: IMFSpatialAudioSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, paudioobjbuffer: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddSpatialAudioObject(::core::mem::transmute(&paudioobjbuffer)).into()
        }
        unsafe extern "system" fn GetSpatialAudioObjectByIndex<Impl: IMFSpatialAudioSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppaudioobjbuffer: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSpatialAudioObjectByIndex(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppaudioobjbuffer = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMFSample_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetObjectCount: GetObjectCount::<Impl, IMPL_OFFSET>,
            AddSpatialAudioObject: AddSpatialAudioObject::<Impl, IMPL_OFFSET>,
            GetSpatialAudioObjectByIndex: GetSpatialAudioObjectByIndex::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSpatialAudioSample as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFStreamDescriptor_Impl: Sized + IMFAttributes_Impl {
    fn GetStreamIdentifier(&mut self) -> ::windows::core::Result<u32>;
    fn GetMediaTypeHandler(&mut self) -> ::windows::core::Result<IMFMediaTypeHandler>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFStreamDescriptor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFStreamDescriptor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFStreamDescriptor_Vtbl {
        unsafe extern "system" fn GetStreamIdentifier<Impl: IMFStreamDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwstreamidentifier: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamIdentifier() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwstreamidentifier = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaTypeHandler<Impl: IMFStreamDescriptor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppmediatypehandler: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMediaTypeHandler() {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediatypehandler = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMFAttributes_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetStreamIdentifier: GetStreamIdentifier::<Impl, IMPL_OFFSET>,
            GetMediaTypeHandler: GetMediaTypeHandler::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFStreamDescriptor as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFStreamSink_Impl: Sized + IMFMediaEventGenerator_Impl {
    fn GetMediaSink(&mut self) -> ::windows::core::Result<IMFMediaSink>;
    fn GetIdentifier(&mut self) -> ::windows::core::Result<u32>;
    fn GetMediaTypeHandler(&mut self) -> ::windows::core::Result<IMFMediaTypeHandler>;
    fn ProcessSample(&mut self, psample: ::core::option::Option<IMFSample>) -> ::windows::core::Result<()>;
    fn PlaceMarker(&mut self, emarkertype: MFSTREAMSINK_MARKER_TYPE, pvarmarkervalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pvarcontextvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::Result<()>;
    fn Flush(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFStreamSink_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFStreamSink_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFStreamSink_Vtbl {
        unsafe extern "system" fn GetMediaSink<Impl: IMFStreamSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppmediasink: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMediaSink() {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediasink = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetIdentifier<Impl: IMFStreamSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwidentifier: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetIdentifier() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwidentifier = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMediaTypeHandler<Impl: IMFStreamSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pphandler: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMediaTypeHandler() {
                ::core::result::Result::Ok(ok__) => {
                    *pphandler = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ProcessSample<Impl: IMFStreamSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psample: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ProcessSample(::core::mem::transmute(&psample)).into()
        }
        unsafe extern "system" fn PlaceMarker<Impl: IMFStreamSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, emarkertype: MFSTREAMSINK_MARKER_TYPE, pvarmarkervalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pvarcontextvalue: *const super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).PlaceMarker(::core::mem::transmute_copy(&emarkertype), ::core::mem::transmute_copy(&pvarmarkervalue), ::core::mem::transmute_copy(&pvarcontextvalue)).into()
        }
        unsafe extern "system" fn Flush<Impl: IMFStreamSink_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Flush().into()
        }
        Self {
            base: IMFMediaEventGenerator_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetMediaSink: GetMediaSink::<Impl, IMPL_OFFSET>,
            GetIdentifier: GetIdentifier::<Impl, IMPL_OFFSET>,
            GetMediaTypeHandler: GetMediaTypeHandler::<Impl, IMPL_OFFSET>,
            ProcessSample: ProcessSample::<Impl, IMPL_OFFSET>,
            PlaceMarker: PlaceMarker::<Impl, IMPL_OFFSET>,
            Flush: Flush::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFStreamSink as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFStreamingSinkConfig_Impl: Sized {
    fn StartStreaming(&mut self, fseekoffsetisbyteoffset: super::super::Foundation::BOOL, qwseekoffset: u64) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFStreamingSinkConfig_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFStreamingSinkConfig_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFStreamingSinkConfig_Vtbl {
        unsafe extern "system" fn StartStreaming<Impl: IMFStreamingSinkConfig_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fseekoffsetisbyteoffset: super::super::Foundation::BOOL, qwseekoffset: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StartStreaming(::core::mem::transmute_copy(&fseekoffsetisbyteoffset), ::core::mem::transmute_copy(&qwseekoffset)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), StartStreaming: StartStreaming::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFStreamingSinkConfig as ::windows::core::Interface>::IID
    }
}
pub trait IMFSystemId_Impl: Sized {
    fn GetData(&mut self, size: *mut u32, data: *mut *mut u8) -> ::windows::core::Result<()>;
    fn Setup(&mut self, stage: u32, cbin: u32, pbin: *const u8, pcbout: *mut u32, ppbout: *mut *mut u8) -> ::windows::core::Result<()>;
}
impl IMFSystemId_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFSystemId_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFSystemId_Vtbl {
        unsafe extern "system" fn GetData<Impl: IMFSystemId_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, size: *mut u32, data: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetData(::core::mem::transmute_copy(&size), ::core::mem::transmute_copy(&data)).into()
        }
        unsafe extern "system" fn Setup<Impl: IMFSystemId_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, stage: u32, cbin: u32, pbin: *const u8, pcbout: *mut u32, ppbout: *mut *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Setup(::core::mem::transmute_copy(&stage), ::core::mem::transmute_copy(&cbin), ::core::mem::transmute_copy(&pbin), ::core::mem::transmute_copy(&pcbout), ::core::mem::transmute_copy(&ppbout)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetData: GetData::<Impl, IMPL_OFFSET>, Setup: Setup::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFSystemId as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFTimecodeTranslate_Impl: Sized {
    fn BeginConvertTimecodeToHNS(&mut self, ppropvartimecode: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pcallback: ::core::option::Option<IMFAsyncCallback>, punkstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndConvertTimecodeToHNS(&mut self, presult: ::core::option::Option<IMFAsyncResult>) -> ::windows::core::Result<i64>;
    fn BeginConvertHNSToTimecode(&mut self, hnstime: i64, pcallback: ::core::option::Option<IMFAsyncCallback>, punkstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndConvertHNSToTimecode(&mut self, presult: ::core::option::Option<IMFAsyncResult>) -> ::windows::core::Result<super::super::System::Com::StructuredStorage::PROPVARIANT>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFTimecodeTranslate_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTimecodeTranslate_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTimecodeTranslate_Vtbl {
        unsafe extern "system" fn BeginConvertTimecodeToHNS<Impl: IMFTimecodeTranslate_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppropvartimecode: *const super::super::System::Com::StructuredStorage::PROPVARIANT, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginConvertTimecodeToHNS(::core::mem::transmute_copy(&ppropvartimecode), ::core::mem::transmute(&pcallback), ::core::mem::transmute(&punkstate)).into()
        }
        unsafe extern "system" fn EndConvertTimecodeToHNS<Impl: IMFTimecodeTranslate_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, phnstime: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EndConvertTimecodeToHNS(::core::mem::transmute(&presult)) {
                ::core::result::Result::Ok(ok__) => {
                    *phnstime = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginConvertHNSToTimecode<Impl: IMFTimecodeTranslate_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnstime: i64, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginConvertHNSToTimecode(::core::mem::transmute_copy(&hnstime), ::core::mem::transmute(&pcallback), ::core::mem::transmute(&punkstate)).into()
        }
        unsafe extern "system" fn EndConvertHNSToTimecode<Impl: IMFTimecodeTranslate_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, ppropvartimecode: *mut super::super::System::Com::StructuredStorage::PROPVARIANT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EndConvertHNSToTimecode(::core::mem::transmute(&presult)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppropvartimecode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            BeginConvertTimecodeToHNS: BeginConvertTimecodeToHNS::<Impl, IMPL_OFFSET>,
            EndConvertTimecodeToHNS: EndConvertTimecodeToHNS::<Impl, IMPL_OFFSET>,
            BeginConvertHNSToTimecode: BeginConvertHNSToTimecode::<Impl, IMPL_OFFSET>,
            EndConvertHNSToTimecode: EndConvertHNSToTimecode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTimecodeTranslate as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFTimedText_Impl: Sized {
    fn RegisterNotifications(&mut self, notify: ::core::option::Option<IMFTimedTextNotify>) -> ::windows::core::Result<()>;
    fn SelectTrack(&mut self, trackid: u32, selected: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn AddDataSource(&mut self, bytestream: ::core::option::Option<IMFByteStream>, label: super::super::Foundation::PWSTR, language: super::super::Foundation::PWSTR, kind: MF_TIMED_TEXT_TRACK_KIND, isdefault: super::super::Foundation::BOOL) -> ::windows::core::Result<u32>;
    fn AddDataSourceFromUrl(&mut self, url: super::super::Foundation::PWSTR, label: super::super::Foundation::PWSTR, language: super::super::Foundation::PWSTR, kind: MF_TIMED_TEXT_TRACK_KIND, isdefault: super::super::Foundation::BOOL) -> ::windows::core::Result<u32>;
    fn AddTrack(&mut self, label: super::super::Foundation::PWSTR, language: super::super::Foundation::PWSTR, kind: MF_TIMED_TEXT_TRACK_KIND) -> ::windows::core::Result<IMFTimedTextTrack>;
    fn RemoveTrack(&mut self, track: ::core::option::Option<IMFTimedTextTrack>) -> ::windows::core::Result<()>;
    fn GetCueTimeOffset(&mut self) -> ::windows::core::Result<f64>;
    fn SetCueTimeOffset(&mut self, offset: f64) -> ::windows::core::Result<()>;
    fn GetTracks(&mut self) -> ::windows::core::Result<IMFTimedTextTrackList>;
    fn GetActiveTracks(&mut self) -> ::windows::core::Result<IMFTimedTextTrackList>;
    fn GetTextTracks(&mut self) -> ::windows::core::Result<IMFTimedTextTrackList>;
    fn GetMetadataTracks(&mut self) -> ::windows::core::Result<IMFTimedTextTrackList>;
    fn SetInBandEnabled(&mut self, enabled: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn IsInBandEnabled(&mut self) -> super::super::Foundation::BOOL;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFTimedText_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTimedText_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTimedText_Vtbl {
        unsafe extern "system" fn RegisterNotifications<Impl: IMFTimedText_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, notify: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RegisterNotifications(::core::mem::transmute(&notify)).into()
        }
        unsafe extern "system" fn SelectTrack<Impl: IMFTimedText_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, trackid: u32, selected: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SelectTrack(::core::mem::transmute_copy(&trackid), ::core::mem::transmute_copy(&selected)).into()
        }
        unsafe extern "system" fn AddDataSource<Impl: IMFTimedText_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bytestream: ::windows::core::RawPtr, label: super::super::Foundation::PWSTR, language: super::super::Foundation::PWSTR, kind: MF_TIMED_TEXT_TRACK_KIND, isdefault: super::super::Foundation::BOOL, trackid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddDataSource(::core::mem::transmute(&bytestream), ::core::mem::transmute_copy(&label), ::core::mem::transmute_copy(&language), ::core::mem::transmute_copy(&kind), ::core::mem::transmute_copy(&isdefault)) {
                ::core::result::Result::Ok(ok__) => {
                    *trackid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddDataSourceFromUrl<Impl: IMFTimedText_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, url: super::super::Foundation::PWSTR, label: super::super::Foundation::PWSTR, language: super::super::Foundation::PWSTR, kind: MF_TIMED_TEXT_TRACK_KIND, isdefault: super::super::Foundation::BOOL, trackid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddDataSourceFromUrl(::core::mem::transmute_copy(&url), ::core::mem::transmute_copy(&label), ::core::mem::transmute_copy(&language), ::core::mem::transmute_copy(&kind), ::core::mem::transmute_copy(&isdefault)) {
                ::core::result::Result::Ok(ok__) => {
                    *trackid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddTrack<Impl: IMFTimedText_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, label: super::super::Foundation::PWSTR, language: super::super::Foundation::PWSTR, kind: MF_TIMED_TEXT_TRACK_KIND, track: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddTrack(::core::mem::transmute_copy(&label), ::core::mem::transmute_copy(&language), ::core::mem::transmute_copy(&kind)) {
                ::core::result::Result::Ok(ok__) => {
                    *track = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveTrack<Impl: IMFTimedText_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, track: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTrack(::core::mem::transmute(&track)).into()
        }
        unsafe extern "system" fn GetCueTimeOffset<Impl: IMFTimedText_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, offset: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCueTimeOffset() {
                ::core::result::Result::Ok(ok__) => {
                    *offset = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetCueTimeOffset<Impl: IMFTimedText_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, offset: f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCueTimeOffset(::core::mem::transmute_copy(&offset)).into()
        }
        unsafe extern "system" fn GetTracks<Impl: IMFTimedText_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, tracks: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTracks() {
                ::core::result::Result::Ok(ok__) => {
                    *tracks = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetActiveTracks<Impl: IMFTimedText_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, activetracks: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetActiveTracks() {
                ::core::result::Result::Ok(ok__) => {
                    *activetracks = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTextTracks<Impl: IMFTimedText_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, texttracks: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTextTracks() {
                ::core::result::Result::Ok(ok__) => {
                    *texttracks = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetMetadataTracks<Impl: IMFTimedText_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, metadatatracks: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMetadataTracks() {
                ::core::result::Result::Ok(ok__) => {
                    *metadatatracks = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInBandEnabled<Impl: IMFTimedText_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, enabled: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInBandEnabled(::core::mem::transmute_copy(&enabled)).into()
        }
        unsafe extern "system" fn IsInBandEnabled<Impl: IMFTimedText_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsInBandEnabled()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            RegisterNotifications: RegisterNotifications::<Impl, IMPL_OFFSET>,
            SelectTrack: SelectTrack::<Impl, IMPL_OFFSET>,
            AddDataSource: AddDataSource::<Impl, IMPL_OFFSET>,
            AddDataSourceFromUrl: AddDataSourceFromUrl::<Impl, IMPL_OFFSET>,
            AddTrack: AddTrack::<Impl, IMPL_OFFSET>,
            RemoveTrack: RemoveTrack::<Impl, IMPL_OFFSET>,
            GetCueTimeOffset: GetCueTimeOffset::<Impl, IMPL_OFFSET>,
            SetCueTimeOffset: SetCueTimeOffset::<Impl, IMPL_OFFSET>,
            GetTracks: GetTracks::<Impl, IMPL_OFFSET>,
            GetActiveTracks: GetActiveTracks::<Impl, IMPL_OFFSET>,
            GetTextTracks: GetTextTracks::<Impl, IMPL_OFFSET>,
            GetMetadataTracks: GetMetadataTracks::<Impl, IMPL_OFFSET>,
            SetInBandEnabled: SetInBandEnabled::<Impl, IMPL_OFFSET>,
            IsInBandEnabled: IsInBandEnabled::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTimedText as ::windows::core::Interface>::IID
    }
}
pub trait IMFTimedTextBinary_Impl: Sized {
    fn GetData(&mut self, data: *mut *mut u8, length: *mut u32) -> ::windows::core::Result<()>;
}
impl IMFTimedTextBinary_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTimedTextBinary_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTimedTextBinary_Vtbl {
        unsafe extern "system" fn GetData<Impl: IMFTimedTextBinary_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, data: *mut *mut u8, length: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetData(::core::mem::transmute_copy(&data), ::core::mem::transmute_copy(&length)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetData: GetData::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTimedTextBinary as ::windows::core::Interface>::IID
    }
}
pub trait IMFTimedTextBouten_Impl: Sized {
    fn GetBoutenType(&mut self) -> ::windows::core::Result<MF_TIMED_TEXT_BOUTEN_TYPE>;
    fn GetBoutenColor(&mut self) -> ::windows::core::Result<MFARGB>;
    fn GetBoutenPosition(&mut self) -> ::windows::core::Result<MF_TIMED_TEXT_BOUTEN_POSITION>;
}
impl IMFTimedTextBouten_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTimedTextBouten_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTimedTextBouten_Vtbl {
        unsafe extern "system" fn GetBoutenType<Impl: IMFTimedTextBouten_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut MF_TIMED_TEXT_BOUTEN_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBoutenType() {
                ::core::result::Result::Ok(ok__) => {
                    *value = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBoutenColor<Impl: IMFTimedTextBouten_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut MFARGB) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBoutenColor() {
                ::core::result::Result::Ok(ok__) => {
                    *value = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBoutenPosition<Impl: IMFTimedTextBouten_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut MF_TIMED_TEXT_BOUTEN_POSITION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBoutenPosition() {
                ::core::result::Result::Ok(ok__) => {
                    *value = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetBoutenType: GetBoutenType::<Impl, IMPL_OFFSET>,
            GetBoutenColor: GetBoutenColor::<Impl, IMPL_OFFSET>,
            GetBoutenPosition: GetBoutenPosition::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTimedTextBouten as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFTimedTextCue_Impl: Sized {
    fn GetId(&mut self) -> u32;
    fn GetOriginalId(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
    fn GetCueKind(&mut self) -> MF_TIMED_TEXT_TRACK_KIND;
    fn GetStartTime(&mut self) -> f64;
    fn GetDuration(&mut self) -> f64;
    fn GetTrackId(&mut self) -> u32;
    fn GetData(&mut self) -> ::windows::core::Result<IMFTimedTextBinary>;
    fn GetRegion(&mut self) -> ::windows::core::Result<IMFTimedTextRegion>;
    fn GetStyle(&mut self) -> ::windows::core::Result<IMFTimedTextStyle>;
    fn GetLineCount(&mut self) -> u32;
    fn GetLine(&mut self, index: u32) -> ::windows::core::Result<IMFTimedTextFormattedText>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFTimedTextCue_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTimedTextCue_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTimedTextCue_Vtbl {
        unsafe extern "system" fn GetId<Impl: IMFTimedTextCue_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetId()
        }
        unsafe extern "system" fn GetOriginalId<Impl: IMFTimedTextCue_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, originalid: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOriginalId() {
                ::core::result::Result::Ok(ok__) => {
                    *originalid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCueKind<Impl: IMFTimedTextCue_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> MF_TIMED_TEXT_TRACK_KIND {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCueKind()
        }
        unsafe extern "system" fn GetStartTime<Impl: IMFTimedTextCue_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetStartTime()
        }
        unsafe extern "system" fn GetDuration<Impl: IMFTimedTextCue_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> f64 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDuration()
        }
        unsafe extern "system" fn GetTrackId<Impl: IMFTimedTextCue_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTrackId()
        }
        unsafe extern "system" fn GetData<Impl: IMFTimedTextCue_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, data: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetData() {
                ::core::result::Result::Ok(ok__) => {
                    *data = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRegion<Impl: IMFTimedTextCue_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, region: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRegion() {
                ::core::result::Result::Ok(ok__) => {
                    *region = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetStyle<Impl: IMFTimedTextCue_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, style: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *style = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLineCount<Impl: IMFTimedTextCue_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLineCount()
        }
        unsafe extern "system" fn GetLine<Impl: IMFTimedTextCue_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, line: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLine(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    *line = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetId: GetId::<Impl, IMPL_OFFSET>,
            GetOriginalId: GetOriginalId::<Impl, IMPL_OFFSET>,
            GetCueKind: GetCueKind::<Impl, IMPL_OFFSET>,
            GetStartTime: GetStartTime::<Impl, IMPL_OFFSET>,
            GetDuration: GetDuration::<Impl, IMPL_OFFSET>,
            GetTrackId: GetTrackId::<Impl, IMPL_OFFSET>,
            GetData: GetData::<Impl, IMPL_OFFSET>,
            GetRegion: GetRegion::<Impl, IMPL_OFFSET>,
            GetStyle: GetStyle::<Impl, IMPL_OFFSET>,
            GetLineCount: GetLineCount::<Impl, IMPL_OFFSET>,
            GetLine: GetLine::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTimedTextCue as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFTimedTextCueList_Impl: Sized {
    fn GetLength(&mut self) -> u32;
    fn GetCueByIndex(&mut self, index: u32) -> ::windows::core::Result<IMFTimedTextCue>;
    fn GetCueById(&mut self, id: u32) -> ::windows::core::Result<IMFTimedTextCue>;
    fn GetCueByOriginalId(&mut self, originalid: super::super::Foundation::PWSTR) -> ::windows::core::Result<IMFTimedTextCue>;
    fn AddTextCue(&mut self, start: f64, duration: f64, text: super::super::Foundation::PWSTR) -> ::windows::core::Result<IMFTimedTextCue>;
    fn AddDataCue(&mut self, start: f64, duration: f64, data: *const u8, datasize: u32) -> ::windows::core::Result<IMFTimedTextCue>;
    fn RemoveCue(&mut self, cue: ::core::option::Option<IMFTimedTextCue>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFTimedTextCueList_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTimedTextCueList_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTimedTextCueList_Vtbl {
        unsafe extern "system" fn GetLength<Impl: IMFTimedTextCueList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLength()
        }
        unsafe extern "system" fn GetCueByIndex<Impl: IMFTimedTextCueList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, cue: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCueByIndex(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    *cue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCueById<Impl: IMFTimedTextCueList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, id: u32, cue: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCueById(::core::mem::transmute_copy(&id)) {
                ::core::result::Result::Ok(ok__) => {
                    *cue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetCueByOriginalId<Impl: IMFTimedTextCueList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, originalid: super::super::Foundation::PWSTR, cue: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCueByOriginalId(::core::mem::transmute_copy(&originalid)) {
                ::core::result::Result::Ok(ok__) => {
                    *cue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddTextCue<Impl: IMFTimedTextCueList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, start: f64, duration: f64, text: super::super::Foundation::PWSTR, cue: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddTextCue(::core::mem::transmute_copy(&start), ::core::mem::transmute_copy(&duration), ::core::mem::transmute_copy(&text)) {
                ::core::result::Result::Ok(ok__) => {
                    *cue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddDataCue<Impl: IMFTimedTextCueList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, start: f64, duration: f64, data: *const u8, datasize: u32, cue: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AddDataCue(::core::mem::transmute_copy(&start), ::core::mem::transmute_copy(&duration), ::core::mem::transmute_copy(&data), ::core::mem::transmute_copy(&datasize)) {
                ::core::result::Result::Ok(ok__) => {
                    *cue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RemoveCue<Impl: IMFTimedTextCueList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cue: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveCue(::core::mem::transmute(&cue)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetCueByIndex: GetCueByIndex::<Impl, IMPL_OFFSET>,
            GetCueById: GetCueById::<Impl, IMPL_OFFSET>,
            GetCueByOriginalId: GetCueByOriginalId::<Impl, IMPL_OFFSET>,
            AddTextCue: AddTextCue::<Impl, IMPL_OFFSET>,
            AddDataCue: AddDataCue::<Impl, IMPL_OFFSET>,
            RemoveCue: RemoveCue::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTimedTextCueList as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFTimedTextFormattedText_Impl: Sized {
    fn GetText(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
    fn GetSubformattingCount(&mut self) -> u32;
    fn GetSubformatting(&mut self, index: u32, firstchar: *mut u32, charlength: *mut u32, style: *mut ::core::option::Option<IMFTimedTextStyle>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFTimedTextFormattedText_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTimedTextFormattedText_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTimedTextFormattedText_Vtbl {
        unsafe extern "system" fn GetText<Impl: IMFTimedTextFormattedText_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, text: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetText() {
                ::core::result::Result::Ok(ok__) => {
                    *text = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSubformattingCount<Impl: IMFTimedTextFormattedText_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSubformattingCount()
        }
        unsafe extern "system" fn GetSubformatting<Impl: IMFTimedTextFormattedText_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, firstchar: *mut u32, charlength: *mut u32, style: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSubformatting(::core::mem::transmute_copy(&index), ::core::mem::transmute_copy(&firstchar), ::core::mem::transmute_copy(&charlength), ::core::mem::transmute_copy(&style)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetText: GetText::<Impl, IMPL_OFFSET>,
            GetSubformattingCount: GetSubformattingCount::<Impl, IMPL_OFFSET>,
            GetSubformatting: GetSubformatting::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTimedTextFormattedText as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFTimedTextNotify_Impl: Sized {
    fn TrackAdded(&mut self, trackid: u32);
    fn TrackRemoved(&mut self, trackid: u32);
    fn TrackSelected(&mut self, trackid: u32, selected: super::super::Foundation::BOOL);
    fn TrackReadyStateChanged(&mut self, trackid: u32);
    fn Error(&mut self, errorcode: MF_TIMED_TEXT_ERROR_CODE, extendederrorcode: ::windows::core::HRESULT, sourcetrackid: u32);
    fn Cue(&mut self, cueevent: MF_TIMED_TEXT_CUE_EVENT, currenttime: f64, cue: ::core::option::Option<IMFTimedTextCue>);
    fn Reset(&mut self);
}
#[cfg(feature = "Win32_Foundation")]
impl IMFTimedTextNotify_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTimedTextNotify_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTimedTextNotify_Vtbl {
        unsafe extern "system" fn TrackAdded<Impl: IMFTimedTextNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, trackid: u32) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TrackAdded(::core::mem::transmute_copy(&trackid))
        }
        unsafe extern "system" fn TrackRemoved<Impl: IMFTimedTextNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, trackid: u32) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TrackRemoved(::core::mem::transmute_copy(&trackid))
        }
        unsafe extern "system" fn TrackSelected<Impl: IMFTimedTextNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, trackid: u32, selected: super::super::Foundation::BOOL) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TrackSelected(::core::mem::transmute_copy(&trackid), ::core::mem::transmute_copy(&selected))
        }
        unsafe extern "system" fn TrackReadyStateChanged<Impl: IMFTimedTextNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, trackid: u32) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).TrackReadyStateChanged(::core::mem::transmute_copy(&trackid))
        }
        unsafe extern "system" fn Error<Impl: IMFTimedTextNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, errorcode: MF_TIMED_TEXT_ERROR_CODE, extendederrorcode: ::windows::core::HRESULT, sourcetrackid: u32) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Error(::core::mem::transmute_copy(&errorcode), ::core::mem::transmute_copy(&extendederrorcode), ::core::mem::transmute_copy(&sourcetrackid))
        }
        unsafe extern "system" fn Cue<Impl: IMFTimedTextNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cueevent: MF_TIMED_TEXT_CUE_EVENT, currenttime: f64, cue: ::windows::core::RawPtr) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Cue(::core::mem::transmute_copy(&cueevent), ::core::mem::transmute_copy(&currenttime), ::core::mem::transmute(&cue))
        }
        unsafe extern "system" fn Reset<Impl: IMFTimedTextNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Reset()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            TrackAdded: TrackAdded::<Impl, IMPL_OFFSET>,
            TrackRemoved: TrackRemoved::<Impl, IMPL_OFFSET>,
            TrackSelected: TrackSelected::<Impl, IMPL_OFFSET>,
            TrackReadyStateChanged: TrackReadyStateChanged::<Impl, IMPL_OFFSET>,
            Error: Error::<Impl, IMPL_OFFSET>,
            Cue: Cue::<Impl, IMPL_OFFSET>,
            Reset: Reset::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTimedTextNotify as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFTimedTextRegion_Impl: Sized {
    fn GetName(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
    fn GetPosition(&mut self, px: *mut f64, py: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::Result<()>;
    fn GetExtent(&mut self, pwidth: *mut f64, pheight: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::Result<()>;
    fn GetBackgroundColor(&mut self) -> ::windows::core::Result<MFARGB>;
    fn GetWritingMode(&mut self) -> ::windows::core::Result<MF_TIMED_TEXT_WRITING_MODE>;
    fn GetDisplayAlignment(&mut self) -> ::windows::core::Result<MF_TIMED_TEXT_DISPLAY_ALIGNMENT>;
    fn GetLineHeight(&mut self, plineheight: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::Result<()>;
    fn GetClipOverflow(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetPadding(&mut self, before: *mut f64, start: *mut f64, after: *mut f64, end: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::Result<()>;
    fn GetWrap(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetZIndex(&mut self) -> ::windows::core::Result<i32>;
    fn GetScrollMode(&mut self) -> ::windows::core::Result<MF_TIMED_TEXT_SCROLL_MODE>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFTimedTextRegion_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTimedTextRegion_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTimedTextRegion_Vtbl {
        unsafe extern "system" fn GetName<Impl: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, name: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetName() {
                ::core::result::Result::Ok(ok__) => {
                    *name = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPosition<Impl: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, px: *mut f64, py: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPosition(::core::mem::transmute_copy(&px), ::core::mem::transmute_copy(&py), ::core::mem::transmute_copy(&unittype)).into()
        }
        unsafe extern "system" fn GetExtent<Impl: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwidth: *mut f64, pheight: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetExtent(::core::mem::transmute_copy(&pwidth), ::core::mem::transmute_copy(&pheight), ::core::mem::transmute_copy(&unittype)).into()
        }
        unsafe extern "system" fn GetBackgroundColor<Impl: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bgcolor: *mut MFARGB) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBackgroundColor() {
                ::core::result::Result::Ok(ok__) => {
                    *bgcolor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetWritingMode<Impl: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, writingmode: *mut MF_TIMED_TEXT_WRITING_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetWritingMode() {
                ::core::result::Result::Ok(ok__) => {
                    *writingmode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetDisplayAlignment<Impl: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, displayalign: *mut MF_TIMED_TEXT_DISPLAY_ALIGNMENT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDisplayAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *displayalign = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetLineHeight<Impl: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plineheight: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLineHeight(::core::mem::transmute_copy(&plineheight), ::core::mem::transmute_copy(&unittype)).into()
        }
        unsafe extern "system" fn GetClipOverflow<Impl: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clipoverflow: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetClipOverflow() {
                ::core::result::Result::Ok(ok__) => {
                    *clipoverflow = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPadding<Impl: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, before: *mut f64, start: *mut f64, after: *mut f64, end: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPadding(::core::mem::transmute_copy(&before), ::core::mem::transmute_copy(&start), ::core::mem::transmute_copy(&after), ::core::mem::transmute_copy(&end), ::core::mem::transmute_copy(&unittype)).into()
        }
        unsafe extern "system" fn GetWrap<Impl: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wrap: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetWrap() {
                ::core::result::Result::Ok(ok__) => {
                    *wrap = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetZIndex<Impl: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, zindex: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetZIndex() {
                ::core::result::Result::Ok(ok__) => {
                    *zindex = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetScrollMode<Impl: IMFTimedTextRegion_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, scrollmode: *mut MF_TIMED_TEXT_SCROLL_MODE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetScrollMode() {
                ::core::result::Result::Ok(ok__) => {
                    *scrollmode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetName: GetName::<Impl, IMPL_OFFSET>,
            GetPosition: GetPosition::<Impl, IMPL_OFFSET>,
            GetExtent: GetExtent::<Impl, IMPL_OFFSET>,
            GetBackgroundColor: GetBackgroundColor::<Impl, IMPL_OFFSET>,
            GetWritingMode: GetWritingMode::<Impl, IMPL_OFFSET>,
            GetDisplayAlignment: GetDisplayAlignment::<Impl, IMPL_OFFSET>,
            GetLineHeight: GetLineHeight::<Impl, IMPL_OFFSET>,
            GetClipOverflow: GetClipOverflow::<Impl, IMPL_OFFSET>,
            GetPadding: GetPadding::<Impl, IMPL_OFFSET>,
            GetWrap: GetWrap::<Impl, IMPL_OFFSET>,
            GetZIndex: GetZIndex::<Impl, IMPL_OFFSET>,
            GetScrollMode: GetScrollMode::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTimedTextRegion as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFTimedTextRuby_Impl: Sized {
    fn GetRubyText(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
    fn GetRubyPosition(&mut self) -> ::windows::core::Result<MF_TIMED_TEXT_RUBY_POSITION>;
    fn GetRubyAlign(&mut self) -> ::windows::core::Result<MF_TIMED_TEXT_RUBY_ALIGN>;
    fn GetRubyReserve(&mut self) -> ::windows::core::Result<MF_TIMED_TEXT_RUBY_RESERVE>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFTimedTextRuby_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTimedTextRuby_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTimedTextRuby_Vtbl {
        unsafe extern "system" fn GetRubyText<Impl: IMFTimedTextRuby_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, rubytext: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRubyText() {
                ::core::result::Result::Ok(ok__) => {
                    *rubytext = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRubyPosition<Impl: IMFTimedTextRuby_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut MF_TIMED_TEXT_RUBY_POSITION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRubyPosition() {
                ::core::result::Result::Ok(ok__) => {
                    *value = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRubyAlign<Impl: IMFTimedTextRuby_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut MF_TIMED_TEXT_RUBY_ALIGN) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRubyAlign() {
                ::core::result::Result::Ok(ok__) => {
                    *value = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRubyReserve<Impl: IMFTimedTextRuby_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut MF_TIMED_TEXT_RUBY_RESERVE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRubyReserve() {
                ::core::result::Result::Ok(ok__) => {
                    *value = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetRubyText: GetRubyText::<Impl, IMPL_OFFSET>,
            GetRubyPosition: GetRubyPosition::<Impl, IMPL_OFFSET>,
            GetRubyAlign: GetRubyAlign::<Impl, IMPL_OFFSET>,
            GetRubyReserve: GetRubyReserve::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTimedTextRuby as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFTimedTextStyle_Impl: Sized {
    fn GetName(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
    fn IsExternal(&mut self) -> super::super::Foundation::BOOL;
    fn GetFontFamily(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
    fn GetFontSize(&mut self, fontsize: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::Result<()>;
    fn GetColor(&mut self) -> ::windows::core::Result<MFARGB>;
    fn GetBackgroundColor(&mut self) -> ::windows::core::Result<MFARGB>;
    fn GetShowBackgroundAlways(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetFontStyle(&mut self) -> ::windows::core::Result<MF_TIMED_TEXT_FONT_STYLE>;
    fn GetBold(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetRightToLeft(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetTextAlignment(&mut self) -> ::windows::core::Result<MF_TIMED_TEXT_ALIGNMENT>;
    fn GetTextDecoration(&mut self) -> ::windows::core::Result<u32>;
    fn GetTextOutline(&mut self, color: *mut MFARGB, thickness: *mut f64, blurradius: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFTimedTextStyle_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTimedTextStyle_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTimedTextStyle_Vtbl {
        unsafe extern "system" fn GetName<Impl: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, name: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetName() {
                ::core::result::Result::Ok(ok__) => {
                    *name = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsExternal<Impl: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsExternal()
        }
        unsafe extern "system" fn GetFontFamily<Impl: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fontfamily: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFontFamily() {
                ::core::result::Result::Ok(ok__) => {
                    *fontfamily = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFontSize<Impl: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fontsize: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetFontSize(::core::mem::transmute_copy(&fontsize), ::core::mem::transmute_copy(&unittype)).into()
        }
        unsafe extern "system" fn GetColor<Impl: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, color: *mut MFARGB) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetColor() {
                ::core::result::Result::Ok(ok__) => {
                    *color = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBackgroundColor<Impl: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bgcolor: *mut MFARGB) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBackgroundColor() {
                ::core::result::Result::Ok(ok__) => {
                    *bgcolor = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetShowBackgroundAlways<Impl: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, showbackgroundalways: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetShowBackgroundAlways() {
                ::core::result::Result::Ok(ok__) => {
                    *showbackgroundalways = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFontStyle<Impl: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fontstyle: *mut MF_TIMED_TEXT_FONT_STYLE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFontStyle() {
                ::core::result::Result::Ok(ok__) => {
                    *fontstyle = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBold<Impl: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bold: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBold() {
                ::core::result::Result::Ok(ok__) => {
                    *bold = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetRightToLeft<Impl: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, righttoleft: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRightToLeft() {
                ::core::result::Result::Ok(ok__) => {
                    *righttoleft = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTextAlignment<Impl: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, textalign: *mut MF_TIMED_TEXT_ALIGNMENT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTextAlignment() {
                ::core::result::Result::Ok(ok__) => {
                    *textalign = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTextDecoration<Impl: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, textdecoration: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTextDecoration() {
                ::core::result::Result::Ok(ok__) => {
                    *textdecoration = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTextOutline<Impl: IMFTimedTextStyle_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, color: *mut MFARGB, thickness: *mut f64, blurradius: *mut f64, unittype: *mut MF_TIMED_TEXT_UNIT_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTextOutline(::core::mem::transmute_copy(&color), ::core::mem::transmute_copy(&thickness), ::core::mem::transmute_copy(&blurradius), ::core::mem::transmute_copy(&unittype)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetName: GetName::<Impl, IMPL_OFFSET>,
            IsExternal: IsExternal::<Impl, IMPL_OFFSET>,
            GetFontFamily: GetFontFamily::<Impl, IMPL_OFFSET>,
            GetFontSize: GetFontSize::<Impl, IMPL_OFFSET>,
            GetColor: GetColor::<Impl, IMPL_OFFSET>,
            GetBackgroundColor: GetBackgroundColor::<Impl, IMPL_OFFSET>,
            GetShowBackgroundAlways: GetShowBackgroundAlways::<Impl, IMPL_OFFSET>,
            GetFontStyle: GetFontStyle::<Impl, IMPL_OFFSET>,
            GetBold: GetBold::<Impl, IMPL_OFFSET>,
            GetRightToLeft: GetRightToLeft::<Impl, IMPL_OFFSET>,
            GetTextAlignment: GetTextAlignment::<Impl, IMPL_OFFSET>,
            GetTextDecoration: GetTextDecoration::<Impl, IMPL_OFFSET>,
            GetTextOutline: GetTextOutline::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTimedTextStyle as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFTimedTextStyle2_Impl: Sized {
    fn GetRuby(&mut self) -> ::windows::core::Result<IMFTimedTextRuby>;
    fn GetBouten(&mut self) -> ::windows::core::Result<IMFTimedTextBouten>;
    fn IsTextCombined(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
    fn GetFontAngleInDegrees(&mut self) -> ::windows::core::Result<f64>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFTimedTextStyle2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTimedTextStyle2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTimedTextStyle2_Vtbl {
        unsafe extern "system" fn GetRuby<Impl: IMFTimedTextStyle2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ruby: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRuby() {
                ::core::result::Result::Ok(ok__) => {
                    *ruby = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetBouten<Impl: IMFTimedTextStyle2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bouten: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBouten() {
                ::core::result::Result::Ok(ok__) => {
                    *bouten = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsTextCombined<Impl: IMFTimedTextStyle2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsTextCombined() {
                ::core::result::Result::Ok(ok__) => {
                    *value = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFontAngleInDegrees<Impl: IMFTimedTextStyle2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, value: *mut f64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFontAngleInDegrees() {
                ::core::result::Result::Ok(ok__) => {
                    *value = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetRuby: GetRuby::<Impl, IMPL_OFFSET>,
            GetBouten: GetBouten::<Impl, IMPL_OFFSET>,
            IsTextCombined: IsTextCombined::<Impl, IMPL_OFFSET>,
            GetFontAngleInDegrees: GetFontAngleInDegrees::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTimedTextStyle2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFTimedTextTrack_Impl: Sized {
    fn GetId(&mut self) -> u32;
    fn GetLabel(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
    fn SetLabel(&mut self, label: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn GetLanguage(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
    fn GetTrackKind(&mut self) -> MF_TIMED_TEXT_TRACK_KIND;
    fn IsInBand(&mut self) -> super::super::Foundation::BOOL;
    fn GetInBandMetadataTrackDispatchType(&mut self) -> ::windows::core::Result<super::super::Foundation::PWSTR>;
    fn IsActive(&mut self) -> super::super::Foundation::BOOL;
    fn GetErrorCode(&mut self) -> MF_TIMED_TEXT_ERROR_CODE;
    fn GetExtendedErrorCode(&mut self) -> ::windows::core::Result<()>;
    fn GetDataFormat(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn GetReadyState(&mut self) -> MF_TIMED_TEXT_TRACK_READY_STATE;
    fn GetCueList(&mut self) -> ::windows::core::Result<IMFTimedTextCueList>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFTimedTextTrack_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTimedTextTrack_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTimedTextTrack_Vtbl {
        unsafe extern "system" fn GetId<Impl: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetId()
        }
        unsafe extern "system" fn GetLabel<Impl: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, label: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLabel() {
                ::core::result::Result::Ok(ok__) => {
                    *label = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetLabel<Impl: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, label: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLabel(::core::mem::transmute_copy(&label)).into()
        }
        unsafe extern "system" fn GetLanguage<Impl: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, language: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetLanguage() {
                ::core::result::Result::Ok(ok__) => {
                    *language = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTrackKind<Impl: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> MF_TIMED_TEXT_TRACK_KIND {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTrackKind()
        }
        unsafe extern "system" fn IsInBand<Impl: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsInBand()
        }
        unsafe extern "system" fn GetInBandMetadataTrackDispatchType<Impl: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dispatchtype: *mut super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetInBandMetadataTrackDispatchType() {
                ::core::result::Result::Ok(ok__) => {
                    *dispatchtype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsActive<Impl: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> super::super::Foundation::BOOL {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).IsActive()
        }
        unsafe extern "system" fn GetErrorCode<Impl: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> MF_TIMED_TEXT_ERROR_CODE {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetErrorCode()
        }
        unsafe extern "system" fn GetExtendedErrorCode<Impl: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetExtendedErrorCode().into()
        }
        unsafe extern "system" fn GetDataFormat<Impl: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, format: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDataFormat() {
                ::core::result::Result::Ok(ok__) => {
                    *format = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetReadyState<Impl: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> MF_TIMED_TEXT_TRACK_READY_STATE {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetReadyState()
        }
        unsafe extern "system" fn GetCueList<Impl: IMFTimedTextTrack_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cues: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCueList() {
                ::core::result::Result::Ok(ok__) => {
                    *cues = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetId: GetId::<Impl, IMPL_OFFSET>,
            GetLabel: GetLabel::<Impl, IMPL_OFFSET>,
            SetLabel: SetLabel::<Impl, IMPL_OFFSET>,
            GetLanguage: GetLanguage::<Impl, IMPL_OFFSET>,
            GetTrackKind: GetTrackKind::<Impl, IMPL_OFFSET>,
            IsInBand: IsInBand::<Impl, IMPL_OFFSET>,
            GetInBandMetadataTrackDispatchType: GetInBandMetadataTrackDispatchType::<Impl, IMPL_OFFSET>,
            IsActive: IsActive::<Impl, IMPL_OFFSET>,
            GetErrorCode: GetErrorCode::<Impl, IMPL_OFFSET>,
            GetExtendedErrorCode: GetExtendedErrorCode::<Impl, IMPL_OFFSET>,
            GetDataFormat: GetDataFormat::<Impl, IMPL_OFFSET>,
            GetReadyState: GetReadyState::<Impl, IMPL_OFFSET>,
            GetCueList: GetCueList::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTimedTextTrack as ::windows::core::Interface>::IID
    }
}
pub trait IMFTimedTextTrackList_Impl: Sized {
    fn GetLength(&mut self) -> u32;
    fn GetTrack(&mut self, index: u32) -> ::windows::core::Result<IMFTimedTextTrack>;
    fn GetTrackById(&mut self, trackid: u32) -> ::windows::core::Result<IMFTimedTextTrack>;
}
impl IMFTimedTextTrackList_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTimedTextTrackList_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTimedTextTrackList_Vtbl {
        unsafe extern "system" fn GetLength<Impl: IMFTimedTextTrackList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> u32 {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetLength()
        }
        unsafe extern "system" fn GetTrack<Impl: IMFTimedTextTrackList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, index: u32, track: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTrack(::core::mem::transmute_copy(&index)) {
                ::core::result::Result::Ok(ok__) => {
                    *track = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTrackById<Impl: IMFTimedTextTrackList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, trackid: u32, track: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTrackById(::core::mem::transmute_copy(&trackid)) {
                ::core::result::Result::Ok(ok__) => {
                    *track = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetLength: GetLength::<Impl, IMPL_OFFSET>,
            GetTrack: GetTrack::<Impl, IMPL_OFFSET>,
            GetTrackById: GetTrackById::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTimedTextTrackList as ::windows::core::Interface>::IID
    }
}
pub trait IMFTimer_Impl: Sized {
    fn SetTimer(&mut self, dwflags: u32, llclocktime: i64, pcallback: ::core::option::Option<IMFAsyncCallback>, punkstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn CancelTimer(&mut self, punkkey: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
}
impl IMFTimer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTimer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTimer_Vtbl {
        unsafe extern "system" fn SetTimer<Impl: IMFTimer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32, llclocktime: i64, pcallback: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void, ppunkkey: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).SetTimer(::core::mem::transmute_copy(&dwflags), ::core::mem::transmute_copy(&llclocktime), ::core::mem::transmute(&pcallback), ::core::mem::transmute(&punkstate)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppunkkey = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CancelTimer<Impl: IMFTimer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, punkkey: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CancelTimer(::core::mem::transmute(&punkkey)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetTimer: SetTimer::<Impl, IMPL_OFFSET>,
            CancelTimer: CancelTimer::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTimer as ::windows::core::Interface>::IID
    }
}
pub trait IMFTopoLoader_Impl: Sized {
    fn Load(&mut self, pinputtopo: ::core::option::Option<IMFTopology>, ppoutputtopo: *mut ::core::option::Option<IMFTopology>, pcurrenttopo: ::core::option::Option<IMFTopology>) -> ::windows::core::Result<()>;
}
impl IMFTopoLoader_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTopoLoader_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTopoLoader_Vtbl {
        unsafe extern "system" fn Load<Impl: IMFTopoLoader_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pinputtopo: ::windows::core::RawPtr, ppoutputtopo: *mut ::windows::core::RawPtr, pcurrenttopo: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Load(::core::mem::transmute(&pinputtopo), ::core::mem::transmute_copy(&ppoutputtopo), ::core::mem::transmute(&pcurrenttopo)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), Load: Load::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTopoLoader as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFTopology_Impl: Sized + IMFAttributes_Impl {
    fn GetTopologyID(&mut self) -> ::windows::core::Result<u64>;
    fn AddNode(&mut self, pnode: ::core::option::Option<IMFTopologyNode>) -> ::windows::core::Result<()>;
    fn RemoveNode(&mut self, pnode: ::core::option::Option<IMFTopologyNode>) -> ::windows::core::Result<()>;
    fn GetNodeCount(&mut self) -> ::windows::core::Result<u16>;
    fn GetNode(&mut self, windex: u16) -> ::windows::core::Result<IMFTopologyNode>;
    fn Clear(&mut self) -> ::windows::core::Result<()>;
    fn CloneFrom(&mut self, ptopology: ::core::option::Option<IMFTopology>) -> ::windows::core::Result<()>;
    fn GetNodeByID(&mut self, qwtoponodeid: u64) -> ::windows::core::Result<IMFTopologyNode>;
    fn GetSourceNodeCollection(&mut self) -> ::windows::core::Result<IMFCollection>;
    fn GetOutputNodeCollection(&mut self) -> ::windows::core::Result<IMFCollection>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFTopology_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTopology_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTopology_Vtbl {
        unsafe extern "system" fn GetTopologyID<Impl: IMFTopology_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pid: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTopologyID() {
                ::core::result::Result::Ok(ok__) => {
                    *pid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddNode<Impl: IMFTopology_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pnode: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddNode(::core::mem::transmute(&pnode)).into()
        }
        unsafe extern "system" fn RemoveNode<Impl: IMFTopology_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pnode: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveNode(::core::mem::transmute(&pnode)).into()
        }
        unsafe extern "system" fn GetNodeCount<Impl: IMFTopology_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwnodes: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNodeCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pwnodes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNode<Impl: IMFTopology_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, windex: u16, ppnode: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNode(::core::mem::transmute_copy(&windex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppnode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Clear<Impl: IMFTopology_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Clear().into()
        }
        unsafe extern "system" fn CloneFrom<Impl: IMFTopology_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptopology: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CloneFrom(::core::mem::transmute(&ptopology)).into()
        }
        unsafe extern "system" fn GetNodeByID<Impl: IMFTopology_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, qwtoponodeid: u64, ppnode: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNodeByID(::core::mem::transmute_copy(&qwtoponodeid)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppnode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetSourceNodeCollection<Impl: IMFTopology_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppcollection: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSourceNodeCollection() {
                ::core::result::Result::Ok(ok__) => {
                    *ppcollection = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputNodeCollection<Impl: IMFTopology_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppcollection: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOutputNodeCollection() {
                ::core::result::Result::Ok(ok__) => {
                    *ppcollection = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMFAttributes_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetTopologyID: GetTopologyID::<Impl, IMPL_OFFSET>,
            AddNode: AddNode::<Impl, IMPL_OFFSET>,
            RemoveNode: RemoveNode::<Impl, IMPL_OFFSET>,
            GetNodeCount: GetNodeCount::<Impl, IMPL_OFFSET>,
            GetNode: GetNode::<Impl, IMPL_OFFSET>,
            Clear: Clear::<Impl, IMPL_OFFSET>,
            CloneFrom: CloneFrom::<Impl, IMPL_OFFSET>,
            GetNodeByID: GetNodeByID::<Impl, IMPL_OFFSET>,
            GetSourceNodeCollection: GetSourceNodeCollection::<Impl, IMPL_OFFSET>,
            GetOutputNodeCollection: GetOutputNodeCollection::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTopology as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFTopologyNode_Impl: Sized + IMFAttributes_Impl {
    fn SetObject(&mut self, pobject: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn GetObject(&mut self) -> ::windows::core::Result<::windows::core::IUnknown>;
    fn GetNodeType(&mut self) -> ::windows::core::Result<MF_TOPOLOGY_TYPE>;
    fn GetTopoNodeID(&mut self) -> ::windows::core::Result<u64>;
    fn SetTopoNodeID(&mut self, ulltopoid: u64) -> ::windows::core::Result<()>;
    fn GetInputCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetOutputCount(&mut self) -> ::windows::core::Result<u32>;
    fn ConnectOutput(&mut self, dwoutputindex: u32, pdownstreamnode: ::core::option::Option<IMFTopologyNode>, dwinputindexondownstreamnode: u32) -> ::windows::core::Result<()>;
    fn DisconnectOutput(&mut self, dwoutputindex: u32) -> ::windows::core::Result<()>;
    fn GetInput(&mut self, dwinputindex: u32, ppupstreamnode: *mut ::core::option::Option<IMFTopologyNode>, pdwoutputindexonupstreamnode: *mut u32) -> ::windows::core::Result<()>;
    fn GetOutput(&mut self, dwoutputindex: u32, ppdownstreamnode: *mut ::core::option::Option<IMFTopologyNode>, pdwinputindexondownstreamnode: *mut u32) -> ::windows::core::Result<()>;
    fn SetOutputPrefType(&mut self, dwoutputindex: u32, ptype: ::core::option::Option<IMFMediaType>) -> ::windows::core::Result<()>;
    fn GetOutputPrefType(&mut self, dwoutputindex: u32) -> ::windows::core::Result<IMFMediaType>;
    fn SetInputPrefType(&mut self, dwinputindex: u32, ptype: ::core::option::Option<IMFMediaType>) -> ::windows::core::Result<()>;
    fn GetInputPrefType(&mut self, dwinputindex: u32) -> ::windows::core::Result<IMFMediaType>;
    fn CloneFrom(&mut self, pnode: ::core::option::Option<IMFTopologyNode>) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFTopologyNode_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTopologyNode_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTopologyNode_Vtbl {
        unsafe extern "system" fn SetObject<Impl: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pobject: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetObject(::core::mem::transmute(&pobject)).into()
        }
        unsafe extern "system" fn GetObject<Impl: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetObject() {
                ::core::result::Result::Ok(ok__) => {
                    *ppobject = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetNodeType<Impl: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptype: *mut MF_TOPOLOGY_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNodeType() {
                ::core::result::Result::Ok(ok__) => {
                    *ptype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTopoNodeID<Impl: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pid: *mut u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTopoNodeID() {
                ::core::result::Result::Ok(ok__) => {
                    *pid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetTopoNodeID<Impl: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulltopoid: u64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTopoNodeID(::core::mem::transmute_copy(&ulltopoid)).into()
        }
        unsafe extern "system" fn GetInputCount<Impl: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcinputs: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetInputCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pcinputs = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputCount<Impl: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcoutputs: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOutputCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pcoutputs = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn ConnectOutput<Impl: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwoutputindex: u32, pdownstreamnode: ::windows::core::RawPtr, dwinputindexondownstreamnode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ConnectOutput(::core::mem::transmute_copy(&dwoutputindex), ::core::mem::transmute(&pdownstreamnode), ::core::mem::transmute_copy(&dwinputindexondownstreamnode)).into()
        }
        unsafe extern "system" fn DisconnectOutput<Impl: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwoutputindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DisconnectOutput(::core::mem::transmute_copy(&dwoutputindex)).into()
        }
        unsafe extern "system" fn GetInput<Impl: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwinputindex: u32, ppupstreamnode: *mut ::windows::core::RawPtr, pdwoutputindexonupstreamnode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetInput(::core::mem::transmute_copy(&dwinputindex), ::core::mem::transmute_copy(&ppupstreamnode), ::core::mem::transmute_copy(&pdwoutputindexonupstreamnode)).into()
        }
        unsafe extern "system" fn GetOutput<Impl: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwoutputindex: u32, ppdownstreamnode: *mut ::windows::core::RawPtr, pdwinputindexondownstreamnode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetOutput(::core::mem::transmute_copy(&dwoutputindex), ::core::mem::transmute_copy(&ppdownstreamnode), ::core::mem::transmute_copy(&pdwinputindexondownstreamnode)).into()
        }
        unsafe extern "system" fn SetOutputPrefType<Impl: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwoutputindex: u32, ptype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputPrefType(::core::mem::transmute_copy(&dwoutputindex), ::core::mem::transmute(&ptype)).into()
        }
        unsafe extern "system" fn GetOutputPrefType<Impl: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwoutputindex: u32, pptype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOutputPrefType(::core::mem::transmute_copy(&dwoutputindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pptype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputPrefType<Impl: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwinputindex: u32, ptype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInputPrefType(::core::mem::transmute_copy(&dwinputindex), ::core::mem::transmute(&ptype)).into()
        }
        unsafe extern "system" fn GetInputPrefType<Impl: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwinputindex: u32, pptype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetInputPrefType(::core::mem::transmute_copy(&dwinputindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pptype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CloneFrom<Impl: IMFTopologyNode_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pnode: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).CloneFrom(::core::mem::transmute(&pnode)).into()
        }
        Self {
            base: IMFAttributes_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetObject: SetObject::<Impl, IMPL_OFFSET>,
            GetObject: GetObject::<Impl, IMPL_OFFSET>,
            GetNodeType: GetNodeType::<Impl, IMPL_OFFSET>,
            GetTopoNodeID: GetTopoNodeID::<Impl, IMPL_OFFSET>,
            SetTopoNodeID: SetTopoNodeID::<Impl, IMPL_OFFSET>,
            GetInputCount: GetInputCount::<Impl, IMPL_OFFSET>,
            GetOutputCount: GetOutputCount::<Impl, IMPL_OFFSET>,
            ConnectOutput: ConnectOutput::<Impl, IMPL_OFFSET>,
            DisconnectOutput: DisconnectOutput::<Impl, IMPL_OFFSET>,
            GetInput: GetInput::<Impl, IMPL_OFFSET>,
            GetOutput: GetOutput::<Impl, IMPL_OFFSET>,
            SetOutputPrefType: SetOutputPrefType::<Impl, IMPL_OFFSET>,
            GetOutputPrefType: GetOutputPrefType::<Impl, IMPL_OFFSET>,
            SetInputPrefType: SetInputPrefType::<Impl, IMPL_OFFSET>,
            GetInputPrefType: GetInputPrefType::<Impl, IMPL_OFFSET>,
            CloneFrom: CloneFrom::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTopologyNode as ::windows::core::Interface>::IID
    }
}
pub trait IMFTopologyNodeAttributeEditor_Impl: Sized {
    fn UpdateNodeAttributes(&mut self, topoid: u64, cupdates: u32, pupdates: *const MFTOPONODE_ATTRIBUTE_UPDATE) -> ::windows::core::Result<()>;
}
impl IMFTopologyNodeAttributeEditor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTopologyNodeAttributeEditor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTopologyNodeAttributeEditor_Vtbl {
        unsafe extern "system" fn UpdateNodeAttributes<Impl: IMFTopologyNodeAttributeEditor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, topoid: u64, cupdates: u32, pupdates: *const MFTOPONODE_ATTRIBUTE_UPDATE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UpdateNodeAttributes(::core::mem::transmute_copy(&topoid), ::core::mem::transmute_copy(&cupdates), ::core::mem::transmute_copy(&pupdates)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), UpdateNodeAttributes: UpdateNodeAttributes::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTopologyNodeAttributeEditor as ::windows::core::Interface>::IID
    }
}
pub trait IMFTopologyServiceLookup_Impl: Sized {
    fn LookupService(&mut self, r#type: MF_SERVICE_LOOKUP_TYPE, dwindex: u32, guidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobjects: *mut *mut ::core::ffi::c_void, pnobjects: *mut u32) -> ::windows::core::Result<()>;
}
impl IMFTopologyServiceLookup_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTopologyServiceLookup_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTopologyServiceLookup_Vtbl {
        unsafe extern "system" fn LookupService<Impl: IMFTopologyServiceLookup_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, r#type: MF_SERVICE_LOOKUP_TYPE, dwindex: u32, guidservice: *const ::windows::core::GUID, riid: *const ::windows::core::GUID, ppvobjects: *mut *mut ::core::ffi::c_void, pnobjects: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).LookupService(::core::mem::transmute_copy(&r#type), ::core::mem::transmute_copy(&dwindex), ::core::mem::transmute_copy(&guidservice), ::core::mem::transmute_copy(&riid), ::core::mem::transmute_copy(&ppvobjects), ::core::mem::transmute_copy(&pnobjects)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), LookupService: LookupService::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTopologyServiceLookup as ::windows::core::Interface>::IID
    }
}
pub trait IMFTopologyServiceLookupClient_Impl: Sized {
    fn InitServicePointers(&mut self, plookup: ::core::option::Option<IMFTopologyServiceLookup>) -> ::windows::core::Result<()>;
    fn ReleaseServicePointers(&mut self) -> ::windows::core::Result<()>;
}
impl IMFTopologyServiceLookupClient_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTopologyServiceLookupClient_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTopologyServiceLookupClient_Vtbl {
        unsafe extern "system" fn InitServicePointers<Impl: IMFTopologyServiceLookupClient_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plookup: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InitServicePointers(::core::mem::transmute(&plookup)).into()
        }
        unsafe extern "system" fn ReleaseServicePointers<Impl: IMFTopologyServiceLookupClient_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ReleaseServicePointers().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            InitServicePointers: InitServicePointers::<Impl, IMPL_OFFSET>,
            ReleaseServicePointers: ReleaseServicePointers::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTopologyServiceLookupClient as ::windows::core::Interface>::IID
    }
}
pub trait IMFTrackedSample_Impl: Sized {
    fn SetAllocator(&mut self, psampleallocator: ::core::option::Option<IMFAsyncCallback>, punkstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
}
impl IMFTrackedSample_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTrackedSample_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTrackedSample_Vtbl {
        unsafe extern "system" fn SetAllocator<Impl: IMFTrackedSample_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psampleallocator: ::windows::core::RawPtr, punkstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAllocator(::core::mem::transmute(&psampleallocator), ::core::mem::transmute(&punkstate)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), SetAllocator: SetAllocator::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTrackedSample as ::windows::core::Interface>::IID
    }
}
pub trait IMFTranscodeProfile_Impl: Sized {
    fn SetAudioAttributes(&mut self, pattrs: ::core::option::Option<IMFAttributes>) -> ::windows::core::Result<()>;
    fn GetAudioAttributes(&mut self) -> ::windows::core::Result<IMFAttributes>;
    fn SetVideoAttributes(&mut self, pattrs: ::core::option::Option<IMFAttributes>) -> ::windows::core::Result<()>;
    fn GetVideoAttributes(&mut self) -> ::windows::core::Result<IMFAttributes>;
    fn SetContainerAttributes(&mut self, pattrs: ::core::option::Option<IMFAttributes>) -> ::windows::core::Result<()>;
    fn GetContainerAttributes(&mut self) -> ::windows::core::Result<IMFAttributes>;
}
impl IMFTranscodeProfile_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTranscodeProfile_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTranscodeProfile_Vtbl {
        unsafe extern "system" fn SetAudioAttributes<Impl: IMFTranscodeProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pattrs: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAudioAttributes(::core::mem::transmute(&pattrs)).into()
        }
        unsafe extern "system" fn GetAudioAttributes<Impl: IMFTranscodeProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppattrs: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAudioAttributes() {
                ::core::result::Result::Ok(ok__) => {
                    *ppattrs = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoAttributes<Impl: IMFTranscodeProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pattrs: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVideoAttributes(::core::mem::transmute(&pattrs)).into()
        }
        unsafe extern "system" fn GetVideoAttributes<Impl: IMFTranscodeProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppattrs: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVideoAttributes() {
                ::core::result::Result::Ok(ok__) => {
                    *ppattrs = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetContainerAttributes<Impl: IMFTranscodeProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pattrs: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContainerAttributes(::core::mem::transmute(&pattrs)).into()
        }
        unsafe extern "system" fn GetContainerAttributes<Impl: IMFTranscodeProfile_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppattrs: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetContainerAttributes() {
                ::core::result::Result::Ok(ok__) => {
                    *ppattrs = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetAudioAttributes: SetAudioAttributes::<Impl, IMPL_OFFSET>,
            GetAudioAttributes: GetAudioAttributes::<Impl, IMPL_OFFSET>,
            SetVideoAttributes: SetVideoAttributes::<Impl, IMPL_OFFSET>,
            GetVideoAttributes: GetVideoAttributes::<Impl, IMPL_OFFSET>,
            SetContainerAttributes: SetContainerAttributes::<Impl, IMPL_OFFSET>,
            GetContainerAttributes: GetContainerAttributes::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTranscodeProfile as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFTranscodeSinkInfoProvider_Impl: Sized {
    fn SetOutputFile(&mut self, pwszfilename: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn SetOutputByteStream(&mut self, pbytestreamactivate: ::core::option::Option<IMFActivate>) -> ::windows::core::Result<()>;
    fn SetProfile(&mut self, pprofile: ::core::option::Option<IMFTranscodeProfile>) -> ::windows::core::Result<()>;
    fn GetSinkInfo(&mut self) -> ::windows::core::Result<MF_TRANSCODE_SINK_INFO>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFTranscodeSinkInfoProvider_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTranscodeSinkInfoProvider_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTranscodeSinkInfoProvider_Vtbl {
        unsafe extern "system" fn SetOutputFile<Impl: IMFTranscodeSinkInfoProvider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwszfilename: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputFile(::core::mem::transmute_copy(&pwszfilename)).into()
        }
        unsafe extern "system" fn SetOutputByteStream<Impl: IMFTranscodeSinkInfoProvider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbytestreamactivate: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputByteStream(::core::mem::transmute(&pbytestreamactivate)).into()
        }
        unsafe extern "system" fn SetProfile<Impl: IMFTranscodeSinkInfoProvider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pprofile: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetProfile(::core::mem::transmute(&pprofile)).into()
        }
        unsafe extern "system" fn GetSinkInfo<Impl: IMFTranscodeSinkInfoProvider_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psinkinfo: *mut MF_TRANSCODE_SINK_INFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSinkInfo() {
                ::core::result::Result::Ok(ok__) => {
                    *psinkinfo = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetOutputFile: SetOutputFile::<Impl, IMPL_OFFSET>,
            SetOutputByteStream: SetOutputByteStream::<Impl, IMPL_OFFSET>,
            SetProfile: SetProfile::<Impl, IMPL_OFFSET>,
            GetSinkInfo: GetSinkInfo::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTranscodeSinkInfoProvider as ::windows::core::Interface>::IID
    }
}
pub trait IMFTransform_Impl: Sized {
    fn GetStreamLimits(&mut self, pdwinputminimum: *mut u32, pdwinputmaximum: *mut u32, pdwoutputminimum: *mut u32, pdwoutputmaximum: *mut u32) -> ::windows::core::Result<()>;
    fn GetStreamCount(&mut self, pcinputstreams: *mut u32, pcoutputstreams: *mut u32) -> ::windows::core::Result<()>;
    fn GetStreamIDs(&mut self, dwinputidarraysize: u32, pdwinputids: *mut u32, dwoutputidarraysize: u32, pdwoutputids: *mut u32) -> ::windows::core::Result<()>;
    fn GetInputStreamInfo(&mut self, dwinputstreamid: u32) -> ::windows::core::Result<MFT_INPUT_STREAM_INFO>;
    fn GetOutputStreamInfo(&mut self, dwoutputstreamid: u32) -> ::windows::core::Result<MFT_OUTPUT_STREAM_INFO>;
    fn GetAttributes(&mut self) -> ::windows::core::Result<IMFAttributes>;
    fn GetInputStreamAttributes(&mut self, dwinputstreamid: u32) -> ::windows::core::Result<IMFAttributes>;
    fn GetOutputStreamAttributes(&mut self, dwoutputstreamid: u32) -> ::windows::core::Result<IMFAttributes>;
    fn DeleteInputStream(&mut self, dwstreamid: u32) -> ::windows::core::Result<()>;
    fn AddInputStreams(&mut self, cstreams: u32, adwstreamids: *const u32) -> ::windows::core::Result<()>;
    fn GetInputAvailableType(&mut self, dwinputstreamid: u32, dwtypeindex: u32) -> ::windows::core::Result<IMFMediaType>;
    fn GetOutputAvailableType(&mut self, dwoutputstreamid: u32, dwtypeindex: u32) -> ::windows::core::Result<IMFMediaType>;
    fn SetInputType(&mut self, dwinputstreamid: u32, ptype: ::core::option::Option<IMFMediaType>, dwflags: u32) -> ::windows::core::Result<()>;
    fn SetOutputType(&mut self, dwoutputstreamid: u32, ptype: ::core::option::Option<IMFMediaType>, dwflags: u32) -> ::windows::core::Result<()>;
    fn GetInputCurrentType(&mut self, dwinputstreamid: u32) -> ::windows::core::Result<IMFMediaType>;
    fn GetOutputCurrentType(&mut self, dwoutputstreamid: u32) -> ::windows::core::Result<IMFMediaType>;
    fn GetInputStatus(&mut self, dwinputstreamid: u32) -> ::windows::core::Result<u32>;
    fn GetOutputStatus(&mut self) -> ::windows::core::Result<u32>;
    fn SetOutputBounds(&mut self, hnslowerbound: i64, hnsupperbound: i64) -> ::windows::core::Result<()>;
    fn ProcessEvent(&mut self, dwinputstreamid: u32, pevent: ::core::option::Option<IMFMediaEvent>) -> ::windows::core::Result<()>;
    fn ProcessMessage(&mut self, emessage: MFT_MESSAGE_TYPE, ulparam: usize) -> ::windows::core::Result<()>;
    fn ProcessInput(&mut self, dwinputstreamid: u32, psample: ::core::option::Option<IMFSample>, dwflags: u32) -> ::windows::core::Result<()>;
    fn ProcessOutput(&mut self, dwflags: u32, coutputbuffercount: u32, poutputsamples: *mut MFT_OUTPUT_DATA_BUFFER, pdwstatus: *mut u32) -> ::windows::core::Result<()>;
}
impl IMFTransform_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTransform_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTransform_Vtbl {
        unsafe extern "system" fn GetStreamLimits<Impl: IMFTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwinputminimum: *mut u32, pdwinputmaximum: *mut u32, pdwoutputminimum: *mut u32, pdwoutputmaximum: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetStreamLimits(::core::mem::transmute_copy(&pdwinputminimum), ::core::mem::transmute_copy(&pdwinputmaximum), ::core::mem::transmute_copy(&pdwoutputminimum), ::core::mem::transmute_copy(&pdwoutputmaximum)).into()
        }
        unsafe extern "system" fn GetStreamCount<Impl: IMFTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcinputstreams: *mut u32, pcoutputstreams: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetStreamCount(::core::mem::transmute_copy(&pcinputstreams), ::core::mem::transmute_copy(&pcoutputstreams)).into()
        }
        unsafe extern "system" fn GetStreamIDs<Impl: IMFTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwinputidarraysize: u32, pdwinputids: *mut u32, dwoutputidarraysize: u32, pdwoutputids: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetStreamIDs(::core::mem::transmute_copy(&dwinputidarraysize), ::core::mem::transmute_copy(&pdwinputids), ::core::mem::transmute_copy(&dwoutputidarraysize), ::core::mem::transmute_copy(&pdwoutputids)).into()
        }
        unsafe extern "system" fn GetInputStreamInfo<Impl: IMFTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, pstreaminfo: *mut MFT_INPUT_STREAM_INFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetInputStreamInfo(::core::mem::transmute_copy(&dwinputstreamid)) {
                ::core::result::Result::Ok(ok__) => {
                    *pstreaminfo = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputStreamInfo<Impl: IMFTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, pstreaminfo: *mut MFT_OUTPUT_STREAM_INFO) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOutputStreamInfo(::core::mem::transmute_copy(&dwoutputstreamid)) {
                ::core::result::Result::Ok(ok__) => {
                    *pstreaminfo = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetAttributes<Impl: IMFTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pattributes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAttributes() {
                ::core::result::Result::Ok(ok__) => {
                    *pattributes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInputStreamAttributes<Impl: IMFTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, pattributes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetInputStreamAttributes(::core::mem::transmute_copy(&dwinputstreamid)) {
                ::core::result::Result::Ok(ok__) => {
                    *pattributes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputStreamAttributes<Impl: IMFTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, pattributes: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOutputStreamAttributes(::core::mem::transmute_copy(&dwoutputstreamid)) {
                ::core::result::Result::Ok(ok__) => {
                    *pattributes = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn DeleteInputStream<Impl: IMFTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).DeleteInputStream(::core::mem::transmute_copy(&dwstreamid)).into()
        }
        unsafe extern "system" fn AddInputStreams<Impl: IMFTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cstreams: u32, adwstreamids: *const u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddInputStreams(::core::mem::transmute_copy(&cstreams), ::core::mem::transmute_copy(&adwstreamids)).into()
        }
        unsafe extern "system" fn GetInputAvailableType<Impl: IMFTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, dwtypeindex: u32, pptype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetInputAvailableType(::core::mem::transmute_copy(&dwinputstreamid), ::core::mem::transmute_copy(&dwtypeindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pptype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputAvailableType<Impl: IMFTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, dwtypeindex: u32, pptype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOutputAvailableType(::core::mem::transmute_copy(&dwoutputstreamid), ::core::mem::transmute_copy(&dwtypeindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pptype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetInputType<Impl: IMFTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, ptype: ::windows::core::RawPtr, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInputType(::core::mem::transmute_copy(&dwinputstreamid), ::core::mem::transmute(&ptype), ::core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn SetOutputType<Impl: IMFTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, ptype: ::windows::core::RawPtr, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputType(::core::mem::transmute_copy(&dwoutputstreamid), ::core::mem::transmute(&ptype), ::core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn GetInputCurrentType<Impl: IMFTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, pptype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetInputCurrentType(::core::mem::transmute_copy(&dwinputstreamid)) {
                ::core::result::Result::Ok(ok__) => {
                    *pptype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputCurrentType<Impl: IMFTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwoutputstreamid: u32, pptype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOutputCurrentType(::core::mem::transmute_copy(&dwoutputstreamid)) {
                ::core::result::Result::Ok(ok__) => {
                    *pptype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetInputStatus<Impl: IMFTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetInputStatus(::core::mem::transmute_copy(&dwinputstreamid)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputStatus<Impl: IMFTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOutputStatus() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetOutputBounds<Impl: IMFTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hnslowerbound: i64, hnsupperbound: i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputBounds(::core::mem::transmute_copy(&hnslowerbound), ::core::mem::transmute_copy(&hnsupperbound)).into()
        }
        unsafe extern "system" fn ProcessEvent<Impl: IMFTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, pevent: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ProcessEvent(::core::mem::transmute_copy(&dwinputstreamid), ::core::mem::transmute(&pevent)).into()
        }
        unsafe extern "system" fn ProcessMessage<Impl: IMFTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, emessage: MFT_MESSAGE_TYPE, ulparam: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ProcessMessage(::core::mem::transmute_copy(&emessage), ::core::mem::transmute_copy(&ulparam)).into()
        }
        unsafe extern "system" fn ProcessInput<Impl: IMFTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwinputstreamid: u32, psample: ::windows::core::RawPtr, dwflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ProcessInput(::core::mem::transmute_copy(&dwinputstreamid), ::core::mem::transmute(&psample), ::core::mem::transmute_copy(&dwflags)).into()
        }
        unsafe extern "system" fn ProcessOutput<Impl: IMFTransform_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32, coutputbuffercount: u32, poutputsamples: *mut MFT_OUTPUT_DATA_BUFFER, pdwstatus: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ProcessOutput(::core::mem::transmute_copy(&dwflags), ::core::mem::transmute_copy(&coutputbuffercount), ::core::mem::transmute_copy(&poutputsamples), ::core::mem::transmute_copy(&pdwstatus)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetStreamLimits: GetStreamLimits::<Impl, IMPL_OFFSET>,
            GetStreamCount: GetStreamCount::<Impl, IMPL_OFFSET>,
            GetStreamIDs: GetStreamIDs::<Impl, IMPL_OFFSET>,
            GetInputStreamInfo: GetInputStreamInfo::<Impl, IMPL_OFFSET>,
            GetOutputStreamInfo: GetOutputStreamInfo::<Impl, IMPL_OFFSET>,
            GetAttributes: GetAttributes::<Impl, IMPL_OFFSET>,
            GetInputStreamAttributes: GetInputStreamAttributes::<Impl, IMPL_OFFSET>,
            GetOutputStreamAttributes: GetOutputStreamAttributes::<Impl, IMPL_OFFSET>,
            DeleteInputStream: DeleteInputStream::<Impl, IMPL_OFFSET>,
            AddInputStreams: AddInputStreams::<Impl, IMPL_OFFSET>,
            GetInputAvailableType: GetInputAvailableType::<Impl, IMPL_OFFSET>,
            GetOutputAvailableType: GetOutputAvailableType::<Impl, IMPL_OFFSET>,
            SetInputType: SetInputType::<Impl, IMPL_OFFSET>,
            SetOutputType: SetOutputType::<Impl, IMPL_OFFSET>,
            GetInputCurrentType: GetInputCurrentType::<Impl, IMPL_OFFSET>,
            GetOutputCurrentType: GetOutputCurrentType::<Impl, IMPL_OFFSET>,
            GetInputStatus: GetInputStatus::<Impl, IMPL_OFFSET>,
            GetOutputStatus: GetOutputStatus::<Impl, IMPL_OFFSET>,
            SetOutputBounds: SetOutputBounds::<Impl, IMPL_OFFSET>,
            ProcessEvent: ProcessEvent::<Impl, IMPL_OFFSET>,
            ProcessMessage: ProcessMessage::<Impl, IMPL_OFFSET>,
            ProcessInput: ProcessInput::<Impl, IMPL_OFFSET>,
            ProcessOutput: ProcessOutput::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTransform as ::windows::core::Interface>::IID
    }
}
pub trait IMFTrustedInput_Impl: Sized {
    fn GetInputTrustAuthority(&mut self, dwstreamid: u32, riid: *const ::windows::core::GUID) -> ::windows::core::Result<::windows::core::IUnknown>;
}
impl IMFTrustedInput_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTrustedInput_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTrustedInput_Vtbl {
        unsafe extern "system" fn GetInputTrustAuthority<Impl: IMFTrustedInput_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, riid: *const ::windows::core::GUID, ppunkobject: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetInputTrustAuthority(::core::mem::transmute_copy(&dwstreamid), ::core::mem::transmute_copy(&riid)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppunkobject = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetInputTrustAuthority: GetInputTrustAuthority::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTrustedInput as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFTrustedOutput_Impl: Sized {
    fn GetOutputTrustAuthorityCount(&mut self) -> ::windows::core::Result<u32>;
    fn GetOutputTrustAuthorityByIndex(&mut self, dwindex: u32) -> ::windows::core::Result<IMFOutputTrustAuthority>;
    fn IsFinal(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFTrustedOutput_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFTrustedOutput_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFTrustedOutput_Vtbl {
        unsafe extern "system" fn GetOutputTrustAuthorityCount<Impl: IMFTrustedOutput_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcoutputtrustauthorities: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOutputTrustAuthorityCount() {
                ::core::result::Result::Ok(ok__) => {
                    *pcoutputtrustauthorities = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetOutputTrustAuthorityByIndex<Impl: IMFTrustedOutput_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwindex: u32, ppauthority: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetOutputTrustAuthorityByIndex(::core::mem::transmute_copy(&dwindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppauthority = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn IsFinal<Impl: IMFTrustedOutput_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfisfinal: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).IsFinal() {
                ::core::result::Result::Ok(ok__) => {
                    *pfisfinal = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetOutputTrustAuthorityCount: GetOutputTrustAuthorityCount::<Impl, IMPL_OFFSET>,
            GetOutputTrustAuthorityByIndex: GetOutputTrustAuthorityByIndex::<Impl, IMPL_OFFSET>,
            IsFinal: IsFinal::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFTrustedOutput as ::windows::core::Interface>::IID
    }
}
pub trait IMFVideoCaptureSampleAllocator_Impl: Sized + IMFVideoSampleAllocator_Impl {
    fn InitializeCaptureSampleAllocator(&mut self, cbsamplesize: u32, cbcapturemetadatasize: u32, cbalignment: u32, cminimumsamples: u32, pattributes: ::core::option::Option<IMFAttributes>, pmediatype: ::core::option::Option<IMFMediaType>) -> ::windows::core::Result<()>;
}
impl IMFVideoCaptureSampleAllocator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFVideoCaptureSampleAllocator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFVideoCaptureSampleAllocator_Vtbl {
        unsafe extern "system" fn InitializeCaptureSampleAllocator<Impl: IMFVideoCaptureSampleAllocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cbsamplesize: u32, cbcapturemetadatasize: u32, cbalignment: u32, cminimumsamples: u32, pattributes: ::windows::core::RawPtr, pmediatype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InitializeCaptureSampleAllocator(::core::mem::transmute_copy(&cbsamplesize), ::core::mem::transmute_copy(&cbcapturemetadatasize), ::core::mem::transmute_copy(&cbalignment), ::core::mem::transmute_copy(&cminimumsamples), ::core::mem::transmute(&pattributes), ::core::mem::transmute(&pmediatype)).into()
        }
        Self {
            base: IMFVideoSampleAllocator_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            InitializeCaptureSampleAllocator: InitializeCaptureSampleAllocator::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFVideoCaptureSampleAllocator as ::windows::core::Interface>::IID
    }
}
pub trait IMFVideoDeviceID_Impl: Sized {
    fn GetDeviceID(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
}
impl IMFVideoDeviceID_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFVideoDeviceID_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFVideoDeviceID_Vtbl {
        unsafe extern "system" fn GetDeviceID<Impl: IMFVideoDeviceID_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdeviceid: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetDeviceID() {
                ::core::result::Result::Ok(ok__) => {
                    *pdeviceid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetDeviceID: GetDeviceID::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFVideoDeviceID as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
pub trait IMFVideoDisplayControl_Impl: Sized {
    fn GetNativeVideoSize(&mut self, pszvideo: *mut super::super::Foundation::SIZE, pszarvideo: *mut super::super::Foundation::SIZE) -> ::windows::core::Result<()>;
    fn GetIdealVideoSize(&mut self, pszmin: *mut super::super::Foundation::SIZE, pszmax: *mut super::super::Foundation::SIZE) -> ::windows::core::Result<()>;
    fn SetVideoPosition(&mut self, pnrcsource: *const MFVideoNormalizedRect, prcdest: *const super::super::Foundation::RECT) -> ::windows::core::Result<()>;
    fn GetVideoPosition(&mut self, pnrcsource: *mut MFVideoNormalizedRect, prcdest: *mut super::super::Foundation::RECT) -> ::windows::core::Result<()>;
    fn SetAspectRatioMode(&mut self, dwaspectratiomode: u32) -> ::windows::core::Result<()>;
    fn GetAspectRatioMode(&mut self) -> ::windows::core::Result<u32>;
    fn SetVideoWindow(&mut self, hwndvideo: super::super::Foundation::HWND) -> ::windows::core::Result<()>;
    fn GetVideoWindow(&mut self) -> ::windows::core::Result<super::super::Foundation::HWND>;
    fn RepaintVideo(&mut self) -> ::windows::core::Result<()>;
    fn GetCurrentImage(&mut self, pbih: *mut super::super::Graphics::Gdi::BITMAPINFOHEADER, pdib: *mut *mut u8, pcbdib: *mut u32, ptimestamp: *mut i64) -> ::windows::core::Result<()>;
    fn SetBorderColor(&mut self, clr: u32) -> ::windows::core::Result<()>;
    fn GetBorderColor(&mut self) -> ::windows::core::Result<u32>;
    fn SetRenderingPrefs(&mut self, dwrenderflags: u32) -> ::windows::core::Result<()>;
    fn GetRenderingPrefs(&mut self) -> ::windows::core::Result<u32>;
    fn SetFullscreen(&mut self, ffullscreen: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetFullscreen(&mut self) -> ::windows::core::Result<super::super::Foundation::BOOL>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Gdi"))]
impl IMFVideoDisplayControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFVideoDisplayControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFVideoDisplayControl_Vtbl {
        unsafe extern "system" fn GetNativeVideoSize<Impl: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszvideo: *mut super::super::Foundation::SIZE, pszarvideo: *mut super::super::Foundation::SIZE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNativeVideoSize(::core::mem::transmute_copy(&pszvideo), ::core::mem::transmute_copy(&pszarvideo)).into()
        }
        unsafe extern "system" fn GetIdealVideoSize<Impl: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pszmin: *mut super::super::Foundation::SIZE, pszmax: *mut super::super::Foundation::SIZE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetIdealVideoSize(::core::mem::transmute_copy(&pszmin), ::core::mem::transmute_copy(&pszmax)).into()
        }
        unsafe extern "system" fn SetVideoPosition<Impl: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pnrcsource: *const MFVideoNormalizedRect, prcdest: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVideoPosition(::core::mem::transmute_copy(&pnrcsource), ::core::mem::transmute_copy(&prcdest)).into()
        }
        unsafe extern "system" fn GetVideoPosition<Impl: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pnrcsource: *mut MFVideoNormalizedRect, prcdest: *mut super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoPosition(::core::mem::transmute_copy(&pnrcsource), ::core::mem::transmute_copy(&prcdest)).into()
        }
        unsafe extern "system" fn SetAspectRatioMode<Impl: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwaspectratiomode: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAspectRatioMode(::core::mem::transmute_copy(&dwaspectratiomode)).into()
        }
        unsafe extern "system" fn GetAspectRatioMode<Impl: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwaspectratiomode: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAspectRatioMode() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwaspectratiomode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoWindow<Impl: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, hwndvideo: super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVideoWindow(::core::mem::transmute_copy(&hwndvideo)).into()
        }
        unsafe extern "system" fn GetVideoWindow<Impl: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, phwndvideo: *mut super::super::Foundation::HWND) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVideoWindow() {
                ::core::result::Result::Ok(ok__) => {
                    *phwndvideo = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn RepaintVideo<Impl: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RepaintVideo().into()
        }
        unsafe extern "system" fn GetCurrentImage<Impl: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbih: *mut super::super::Graphics::Gdi::BITMAPINFOHEADER, pdib: *mut *mut u8, pcbdib: *mut u32, ptimestamp: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCurrentImage(::core::mem::transmute_copy(&pbih), ::core::mem::transmute_copy(&pdib), ::core::mem::transmute_copy(&pcbdib), ::core::mem::transmute_copy(&ptimestamp)).into()
        }
        unsafe extern "system" fn SetBorderColor<Impl: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clr: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderColor(::core::mem::transmute_copy(&clr)).into()
        }
        unsafe extern "system" fn GetBorderColor<Impl: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pclr: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBorderColor() {
                ::core::result::Result::Ok(ok__) => {
                    *pclr = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetRenderingPrefs<Impl: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwrenderflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRenderingPrefs(::core::mem::transmute_copy(&dwrenderflags)).into()
        }
        unsafe extern "system" fn GetRenderingPrefs<Impl: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwrenderflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetRenderingPrefs() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwrenderflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFullscreen<Impl: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ffullscreen: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFullscreen(::core::mem::transmute_copy(&ffullscreen)).into()
        }
        unsafe extern "system" fn GetFullscreen<Impl: IMFVideoDisplayControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pffullscreen: *mut super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFullscreen() {
                ::core::result::Result::Ok(ok__) => {
                    *pffullscreen = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetNativeVideoSize: GetNativeVideoSize::<Impl, IMPL_OFFSET>,
            GetIdealVideoSize: GetIdealVideoSize::<Impl, IMPL_OFFSET>,
            SetVideoPosition: SetVideoPosition::<Impl, IMPL_OFFSET>,
            GetVideoPosition: GetVideoPosition::<Impl, IMPL_OFFSET>,
            SetAspectRatioMode: SetAspectRatioMode::<Impl, IMPL_OFFSET>,
            GetAspectRatioMode: GetAspectRatioMode::<Impl, IMPL_OFFSET>,
            SetVideoWindow: SetVideoWindow::<Impl, IMPL_OFFSET>,
            GetVideoWindow: GetVideoWindow::<Impl, IMPL_OFFSET>,
            RepaintVideo: RepaintVideo::<Impl, IMPL_OFFSET>,
            GetCurrentImage: GetCurrentImage::<Impl, IMPL_OFFSET>,
            SetBorderColor: SetBorderColor::<Impl, IMPL_OFFSET>,
            GetBorderColor: GetBorderColor::<Impl, IMPL_OFFSET>,
            SetRenderingPrefs: SetRenderingPrefs::<Impl, IMPL_OFFSET>,
            GetRenderingPrefs: GetRenderingPrefs::<Impl, IMPL_OFFSET>,
            SetFullscreen: SetFullscreen::<Impl, IMPL_OFFSET>,
            GetFullscreen: GetFullscreen::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFVideoDisplayControl as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFVideoMediaType_Impl: Sized + IMFAttributes_Impl + IMFMediaType_Impl {
    fn GetVideoFormat(&mut self) -> *mut MFVIDEOFORMAT;
    fn GetVideoRepresentation(&mut self, guidrepresentation: ::windows::core::GUID, ppvrepresentation: *mut *mut ::core::ffi::c_void, lstride: i32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFVideoMediaType_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFVideoMediaType_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFVideoMediaType_Vtbl {
        unsafe extern "system" fn GetVideoFormat<Impl: IMFVideoMediaType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> *mut MFVIDEOFORMAT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoFormat()
        }
        unsafe extern "system" fn GetVideoRepresentation<Impl: IMFVideoMediaType_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidrepresentation: ::windows::core::GUID, ppvrepresentation: *mut *mut ::core::ffi::c_void, lstride: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetVideoRepresentation(::core::mem::transmute_copy(&guidrepresentation), ::core::mem::transmute_copy(&ppvrepresentation), ::core::mem::transmute_copy(&lstride)).into()
        }
        Self {
            base: IMFMediaType_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetVideoFormat: GetVideoFormat::<Impl, IMPL_OFFSET>,
            GetVideoRepresentation: GetVideoRepresentation::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFVideoMediaType as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
pub trait IMFVideoMixerBitmap_Impl: Sized {
    fn SetAlphaBitmap(&mut self, pbmpparms: *const MFVideoAlphaBitmap) -> ::windows::core::Result<()>;
    fn ClearAlphaBitmap(&mut self) -> ::windows::core::Result<()>;
    fn UpdateAlphaBitmapParameters(&mut self, pbmpparms: *const MFVideoAlphaBitmapParams) -> ::windows::core::Result<()>;
    fn GetAlphaBitmapParameters(&mut self) -> ::windows::core::Result<MFVideoAlphaBitmapParams>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_Direct3D9", feature = "Win32_Graphics_Gdi"))]
impl IMFVideoMixerBitmap_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFVideoMixerBitmap_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFVideoMixerBitmap_Vtbl {
        unsafe extern "system" fn SetAlphaBitmap<Impl: IMFVideoMixerBitmap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbmpparms: *const MFVideoAlphaBitmap) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetAlphaBitmap(::core::mem::transmute_copy(&pbmpparms)).into()
        }
        unsafe extern "system" fn ClearAlphaBitmap<Impl: IMFVideoMixerBitmap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ClearAlphaBitmap().into()
        }
        unsafe extern "system" fn UpdateAlphaBitmapParameters<Impl: IMFVideoMixerBitmap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbmpparms: *const MFVideoAlphaBitmapParams) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UpdateAlphaBitmapParameters(::core::mem::transmute_copy(&pbmpparms)).into()
        }
        unsafe extern "system" fn GetAlphaBitmapParameters<Impl: IMFVideoMixerBitmap_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbmpparms: *mut MFVideoAlphaBitmapParams) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetAlphaBitmapParameters() {
                ::core::result::Result::Ok(ok__) => {
                    *pbmpparms = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetAlphaBitmap: SetAlphaBitmap::<Impl, IMPL_OFFSET>,
            ClearAlphaBitmap: ClearAlphaBitmap::<Impl, IMPL_OFFSET>,
            UpdateAlphaBitmapParameters: UpdateAlphaBitmapParameters::<Impl, IMPL_OFFSET>,
            GetAlphaBitmapParameters: GetAlphaBitmapParameters::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFVideoMixerBitmap as ::windows::core::Interface>::IID
    }
}
pub trait IMFVideoMixerControl_Impl: Sized {
    fn SetStreamZOrder(&mut self, dwstreamid: u32, dwz: u32) -> ::windows::core::Result<()>;
    fn GetStreamZOrder(&mut self, dwstreamid: u32) -> ::windows::core::Result<u32>;
    fn SetStreamOutputRect(&mut self, dwstreamid: u32, pnrcoutput: *const MFVideoNormalizedRect) -> ::windows::core::Result<()>;
    fn GetStreamOutputRect(&mut self, dwstreamid: u32) -> ::windows::core::Result<MFVideoNormalizedRect>;
}
impl IMFVideoMixerControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFVideoMixerControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFVideoMixerControl_Vtbl {
        unsafe extern "system" fn SetStreamZOrder<Impl: IMFVideoMixerControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, dwz: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStreamZOrder(::core::mem::transmute_copy(&dwstreamid), ::core::mem::transmute_copy(&dwz)).into()
        }
        unsafe extern "system" fn GetStreamZOrder<Impl: IMFVideoMixerControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, pdwz: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamZOrder(::core::mem::transmute_copy(&dwstreamid)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwz = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetStreamOutputRect<Impl: IMFVideoMixerControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, pnrcoutput: *const MFVideoNormalizedRect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetStreamOutputRect(::core::mem::transmute_copy(&dwstreamid), ::core::mem::transmute_copy(&pnrcoutput)).into()
        }
        unsafe extern "system" fn GetStreamOutputRect<Impl: IMFVideoMixerControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwstreamid: u32, pnrcoutput: *mut MFVideoNormalizedRect) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetStreamOutputRect(::core::mem::transmute_copy(&dwstreamid)) {
                ::core::result::Result::Ok(ok__) => {
                    *pnrcoutput = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetStreamZOrder: SetStreamZOrder::<Impl, IMPL_OFFSET>,
            GetStreamZOrder: GetStreamZOrder::<Impl, IMPL_OFFSET>,
            SetStreamOutputRect: SetStreamOutputRect::<Impl, IMPL_OFFSET>,
            GetStreamOutputRect: GetStreamOutputRect::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFVideoMixerControl as ::windows::core::Interface>::IID
    }
}
pub trait IMFVideoMixerControl2_Impl: Sized + IMFVideoMixerControl_Impl {
    fn SetMixingPrefs(&mut self, dwmixflags: u32) -> ::windows::core::Result<()>;
    fn GetMixingPrefs(&mut self) -> ::windows::core::Result<u32>;
}
impl IMFVideoMixerControl2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFVideoMixerControl2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFVideoMixerControl2_Vtbl {
        unsafe extern "system" fn SetMixingPrefs<Impl: IMFVideoMixerControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwmixflags: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMixingPrefs(::core::mem::transmute_copy(&dwmixflags)).into()
        }
        unsafe extern "system" fn GetMixingPrefs<Impl: IMFVideoMixerControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwmixflags: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMixingPrefs() {
                ::core::result::Result::Ok(ok__) => {
                    *pdwmixflags = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMFVideoMixerControl_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetMixingPrefs: SetMixingPrefs::<Impl, IMPL_OFFSET>,
            GetMixingPrefs: GetMixingPrefs::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFVideoMixerControl2 as ::windows::core::Interface>::IID
    }
}
pub trait IMFVideoPositionMapper_Impl: Sized {
    fn MapOutputCoordinateToInputStream(&mut self, xout: f32, yout: f32, dwoutputstreamindex: u32, dwinputstreamindex: u32, pxin: *mut f32, pyin: *mut f32) -> ::windows::core::Result<()>;
}
impl IMFVideoPositionMapper_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFVideoPositionMapper_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFVideoPositionMapper_Vtbl {
        unsafe extern "system" fn MapOutputCoordinateToInputStream<Impl: IMFVideoPositionMapper_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, xout: f32, yout: f32, dwoutputstreamindex: u32, dwinputstreamindex: u32, pxin: *mut f32, pyin: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).MapOutputCoordinateToInputStream(::core::mem::transmute_copy(&xout), ::core::mem::transmute_copy(&yout), ::core::mem::transmute_copy(&dwoutputstreamindex), ::core::mem::transmute_copy(&dwinputstreamindex), ::core::mem::transmute_copy(&pxin), ::core::mem::transmute_copy(&pyin)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            MapOutputCoordinateToInputStream: MapOutputCoordinateToInputStream::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFVideoPositionMapper as ::windows::core::Interface>::IID
    }
}
pub trait IMFVideoPresenter_Impl: Sized + IMFClockStateSink_Impl {
    fn ProcessMessage(&mut self, emessage: MFVP_MESSAGE_TYPE, ulparam: usize) -> ::windows::core::Result<()>;
    fn GetCurrentMediaType(&mut self) -> ::windows::core::Result<IMFVideoMediaType>;
}
impl IMFVideoPresenter_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFVideoPresenter_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFVideoPresenter_Vtbl {
        unsafe extern "system" fn ProcessMessage<Impl: IMFVideoPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, emessage: MFVP_MESSAGE_TYPE, ulparam: usize) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).ProcessMessage(::core::mem::transmute_copy(&emessage), ::core::mem::transmute_copy(&ulparam)).into()
        }
        unsafe extern "system" fn GetCurrentMediaType<Impl: IMFVideoPresenter_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppmediatype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCurrentMediaType() {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediatype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMFClockStateSink_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            ProcessMessage: ProcessMessage::<Impl, IMPL_OFFSET>,
            GetCurrentMediaType: GetCurrentMediaType::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFVideoPresenter as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
pub trait IMFVideoProcessor_Impl: Sized {
    fn GetAvailableVideoProcessorModes(&mut self, lpdwnumprocessingmodes: *mut u32, ppvideoprocessingmodes: *mut *mut ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetVideoProcessorCaps(&mut self, lpvideoprocessormode: *const ::windows::core::GUID) -> ::windows::core::Result<DXVA2_VideoProcessorCaps>;
    fn GetVideoProcessorMode(&mut self) -> ::windows::core::Result<::windows::core::GUID>;
    fn SetVideoProcessorMode(&mut self, lpmode: *const ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetProcAmpRange(&mut self, dwproperty: u32) -> ::windows::core::Result<DXVA2_ValueRange>;
    fn GetProcAmpValues(&mut self, dwflags: u32) -> ::windows::core::Result<DXVA2_ProcAmpValues>;
    fn SetProcAmpValues(&mut self, dwflags: u32, pvalues: *const DXVA2_ProcAmpValues) -> ::windows::core::Result<()>;
    fn GetFilteringRange(&mut self, dwproperty: u32) -> ::windows::core::Result<DXVA2_ValueRange>;
    fn GetFilteringValue(&mut self, dwproperty: u32) -> ::windows::core::Result<DXVA2_Fixed32>;
    fn SetFilteringValue(&mut self, dwproperty: u32, pvalue: *const DXVA2_Fixed32) -> ::windows::core::Result<()>;
    fn GetBackgroundColor(&mut self) -> ::windows::core::Result<u32>;
    fn SetBackgroundColor(&mut self, clrbkg: u32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Graphics_Direct3D9")]
impl IMFVideoProcessor_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFVideoProcessor_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFVideoProcessor_Vtbl {
        unsafe extern "system" fn GetAvailableVideoProcessorModes<Impl: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpdwnumprocessingmodes: *mut u32, ppvideoprocessingmodes: *mut *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetAvailableVideoProcessorModes(::core::mem::transmute_copy(&lpdwnumprocessingmodes), ::core::mem::transmute_copy(&ppvideoprocessingmodes)).into()
        }
        unsafe extern "system" fn GetVideoProcessorCaps<Impl: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpvideoprocessormode: *const ::windows::core::GUID, lpvideoprocessorcaps: *mut DXVA2_VideoProcessorCaps) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVideoProcessorCaps(::core::mem::transmute_copy(&lpvideoprocessormode)) {
                ::core::result::Result::Ok(ok__) => {
                    *lpvideoprocessorcaps = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetVideoProcessorMode<Impl: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpmode: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetVideoProcessorMode() {
                ::core::result::Result::Ok(ok__) => {
                    *lpmode = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetVideoProcessorMode<Impl: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpmode: *const ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetVideoProcessorMode(::core::mem::transmute_copy(&lpmode)).into()
        }
        unsafe extern "system" fn GetProcAmpRange<Impl: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwproperty: u32, pproprange: *mut DXVA2_ValueRange) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProcAmpRange(::core::mem::transmute_copy(&dwproperty)) {
                ::core::result::Result::Ok(ok__) => {
                    *pproprange = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetProcAmpValues<Impl: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32, values: *mut DXVA2_ProcAmpValues) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetProcAmpValues(::core::mem::transmute_copy(&dwflags)) {
                ::core::result::Result::Ok(ok__) => {
                    *values = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetProcAmpValues<Impl: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32, pvalues: *const DXVA2_ProcAmpValues) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetProcAmpValues(::core::mem::transmute_copy(&dwflags), ::core::mem::transmute_copy(&pvalues)).into()
        }
        unsafe extern "system" fn GetFilteringRange<Impl: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwproperty: u32, pproprange: *mut DXVA2_ValueRange) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFilteringRange(::core::mem::transmute_copy(&dwproperty)) {
                ::core::result::Result::Ok(ok__) => {
                    *pproprange = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFilteringValue<Impl: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwproperty: u32, pvalue: *mut DXVA2_Fixed32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFilteringValue(::core::mem::transmute_copy(&dwproperty)) {
                ::core::result::Result::Ok(ok__) => {
                    *pvalue = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetFilteringValue<Impl: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwproperty: u32, pvalue: *const DXVA2_Fixed32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFilteringValue(::core::mem::transmute_copy(&dwproperty), ::core::mem::transmute_copy(&pvalue)).into()
        }
        unsafe extern "system" fn GetBackgroundColor<Impl: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lpclrbkg: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetBackgroundColor() {
                ::core::result::Result::Ok(ok__) => {
                    *lpclrbkg = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SetBackgroundColor<Impl: IMFVideoProcessor_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, clrbkg: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBackgroundColor(::core::mem::transmute_copy(&clrbkg)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetAvailableVideoProcessorModes: GetAvailableVideoProcessorModes::<Impl, IMPL_OFFSET>,
            GetVideoProcessorCaps: GetVideoProcessorCaps::<Impl, IMPL_OFFSET>,
            GetVideoProcessorMode: GetVideoProcessorMode::<Impl, IMPL_OFFSET>,
            SetVideoProcessorMode: SetVideoProcessorMode::<Impl, IMPL_OFFSET>,
            GetProcAmpRange: GetProcAmpRange::<Impl, IMPL_OFFSET>,
            GetProcAmpValues: GetProcAmpValues::<Impl, IMPL_OFFSET>,
            SetProcAmpValues: SetProcAmpValues::<Impl, IMPL_OFFSET>,
            GetFilteringRange: GetFilteringRange::<Impl, IMPL_OFFSET>,
            GetFilteringValue: GetFilteringValue::<Impl, IMPL_OFFSET>,
            SetFilteringValue: SetFilteringValue::<Impl, IMPL_OFFSET>,
            GetBackgroundColor: GetBackgroundColor::<Impl, IMPL_OFFSET>,
            SetBackgroundColor: SetBackgroundColor::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFVideoProcessor as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFVideoProcessorControl_Impl: Sized {
    fn SetBorderColor(&mut self, pbordercolor: *const MFARGB) -> ::windows::core::Result<()>;
    fn SetSourceRectangle(&mut self, psrcrect: *const super::super::Foundation::RECT) -> ::windows::core::Result<()>;
    fn SetDestinationRectangle(&mut self, pdstrect: *const super::super::Foundation::RECT) -> ::windows::core::Result<()>;
    fn SetMirror(&mut self, emirror: MF_VIDEO_PROCESSOR_MIRROR) -> ::windows::core::Result<()>;
    fn SetRotation(&mut self, erotation: MF_VIDEO_PROCESSOR_ROTATION) -> ::windows::core::Result<()>;
    fn SetConstrictionSize(&mut self, pconstrictionsize: *const super::super::Foundation::SIZE) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFVideoProcessorControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFVideoProcessorControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFVideoProcessorControl_Vtbl {
        unsafe extern "system" fn SetBorderColor<Impl: IMFVideoProcessorControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbordercolor: *const MFARGB) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBorderColor(::core::mem::transmute_copy(&pbordercolor)).into()
        }
        unsafe extern "system" fn SetSourceRectangle<Impl: IMFVideoProcessorControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, psrcrect: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSourceRectangle(::core::mem::transmute_copy(&psrcrect)).into()
        }
        unsafe extern "system" fn SetDestinationRectangle<Impl: IMFVideoProcessorControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdstrect: *const super::super::Foundation::RECT) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDestinationRectangle(::core::mem::transmute_copy(&pdstrect)).into()
        }
        unsafe extern "system" fn SetMirror<Impl: IMFVideoProcessorControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, emirror: MF_VIDEO_PROCESSOR_MIRROR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMirror(::core::mem::transmute_copy(&emirror)).into()
        }
        unsafe extern "system" fn SetRotation<Impl: IMFVideoProcessorControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, erotation: MF_VIDEO_PROCESSOR_ROTATION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRotation(::core::mem::transmute_copy(&erotation)).into()
        }
        unsafe extern "system" fn SetConstrictionSize<Impl: IMFVideoProcessorControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pconstrictionsize: *const super::super::Foundation::SIZE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetConstrictionSize(::core::mem::transmute_copy(&pconstrictionsize)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetBorderColor: SetBorderColor::<Impl, IMPL_OFFSET>,
            SetSourceRectangle: SetSourceRectangle::<Impl, IMPL_OFFSET>,
            SetDestinationRectangle: SetDestinationRectangle::<Impl, IMPL_OFFSET>,
            SetMirror: SetMirror::<Impl, IMPL_OFFSET>,
            SetRotation: SetRotation::<Impl, IMPL_OFFSET>,
            SetConstrictionSize: SetConstrictionSize::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFVideoProcessorControl as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFVideoProcessorControl2_Impl: Sized + IMFVideoProcessorControl_Impl {
    fn SetRotationOverride(&mut self, uirotation: u32) -> ::windows::core::Result<()>;
    fn EnableHardwareEffects(&mut self, fenabled: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn GetSupportedHardwareEffects(&mut self) -> ::windows::core::Result<u32>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFVideoProcessorControl2_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFVideoProcessorControl2_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFVideoProcessorControl2_Vtbl {
        unsafe extern "system" fn SetRotationOverride<Impl: IMFVideoProcessorControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, uirotation: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetRotationOverride(::core::mem::transmute_copy(&uirotation)).into()
        }
        unsafe extern "system" fn EnableHardwareEffects<Impl: IMFVideoProcessorControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fenabled: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EnableHardwareEffects(::core::mem::transmute_copy(&fenabled)).into()
        }
        unsafe extern "system" fn GetSupportedHardwareEffects<Impl: IMFVideoProcessorControl2_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, puisupport: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetSupportedHardwareEffects() {
                ::core::result::Result::Ok(ok__) => {
                    *puisupport = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMFVideoProcessorControl_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            SetRotationOverride: SetRotationOverride::<Impl, IMPL_OFFSET>,
            EnableHardwareEffects: EnableHardwareEffects::<Impl, IMPL_OFFSET>,
            GetSupportedHardwareEffects: GetSupportedHardwareEffects::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFVideoProcessorControl2 as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFVideoProcessorControl3_Impl: Sized + IMFVideoProcessorControl_Impl + IMFVideoProcessorControl2_Impl {
    fn GetNaturalOutputType(&mut self) -> ::windows::core::Result<IMFMediaType>;
    fn EnableSphericalVideoProcessing(&mut self, fenable: super::super::Foundation::BOOL, eformat: MFVideoSphericalFormat, eprojectionmode: MFVideoSphericalProjectionMode) -> ::windows::core::Result<()>;
    fn SetSphericalVideoProperties(&mut self, x: f32, y: f32, z: f32, w: f32, fieldofview: f32) -> ::windows::core::Result<()>;
    fn SetOutputDevice(&mut self, poutputdevice: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFVideoProcessorControl3_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFVideoProcessorControl3_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFVideoProcessorControl3_Vtbl {
        unsafe extern "system" fn GetNaturalOutputType<Impl: IMFVideoProcessorControl3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pptype: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetNaturalOutputType() {
                ::core::result::Result::Ok(ok__) => {
                    *pptype = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn EnableSphericalVideoProcessing<Impl: IMFVideoProcessorControl3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fenable: super::super::Foundation::BOOL, eformat: MFVideoSphericalFormat, eprojectionmode: MFVideoSphericalProjectionMode) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EnableSphericalVideoProcessing(::core::mem::transmute_copy(&fenable), ::core::mem::transmute_copy(&eformat), ::core::mem::transmute_copy(&eprojectionmode)).into()
        }
        unsafe extern "system" fn SetSphericalVideoProperties<Impl: IMFVideoProcessorControl3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, x: f32, y: f32, z: f32, w: f32, fieldofview: f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSphericalVideoProperties(::core::mem::transmute_copy(&x), ::core::mem::transmute_copy(&y), ::core::mem::transmute_copy(&z), ::core::mem::transmute_copy(&w), ::core::mem::transmute_copy(&fieldofview)).into()
        }
        unsafe extern "system" fn SetOutputDevice<Impl: IMFVideoProcessorControl3_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, poutputdevice: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetOutputDevice(::core::mem::transmute(&poutputdevice)).into()
        }
        Self {
            base: IMFVideoProcessorControl2_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetNaturalOutputType: GetNaturalOutputType::<Impl, IMPL_OFFSET>,
            EnableSphericalVideoProcessing: EnableSphericalVideoProcessing::<Impl, IMPL_OFFSET>,
            SetSphericalVideoProperties: SetSphericalVideoProperties::<Impl, IMPL_OFFSET>,
            SetOutputDevice: SetOutputDevice::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFVideoProcessorControl3 as ::windows::core::Interface>::IID
    }
}
pub trait IMFVideoRenderer_Impl: Sized {
    fn InitializeRenderer(&mut self, pvideomixer: ::core::option::Option<IMFTransform>, pvideopresenter: ::core::option::Option<IMFVideoPresenter>) -> ::windows::core::Result<()>;
}
impl IMFVideoRenderer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFVideoRenderer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFVideoRenderer_Vtbl {
        unsafe extern "system" fn InitializeRenderer<Impl: IMFVideoRenderer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pvideomixer: ::windows::core::RawPtr, pvideopresenter: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InitializeRenderer(::core::mem::transmute(&pvideomixer), ::core::mem::transmute(&pvideopresenter)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), InitializeRenderer: InitializeRenderer::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFVideoRenderer as ::windows::core::Interface>::IID
    }
}
pub trait IMFVideoRendererEffectControl_Impl: Sized {
    fn OnAppServiceConnectionEstablished(&mut self, pappserviceconnection: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
}
impl IMFVideoRendererEffectControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFVideoRendererEffectControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFVideoRendererEffectControl_Vtbl {
        unsafe extern "system" fn OnAppServiceConnectionEstablished<Impl: IMFVideoRendererEffectControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pappserviceconnection: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).OnAppServiceConnectionEstablished(::core::mem::transmute(&pappserviceconnection)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            OnAppServiceConnectionEstablished: OnAppServiceConnectionEstablished::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFVideoRendererEffectControl as ::windows::core::Interface>::IID
    }
}
pub trait IMFVideoSampleAllocator_Impl: Sized {
    fn SetDirectXManager(&mut self, pmanager: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn UninitializeSampleAllocator(&mut self) -> ::windows::core::Result<()>;
    fn InitializeSampleAllocator(&mut self, crequestedframes: u32, pmediatype: ::core::option::Option<IMFMediaType>) -> ::windows::core::Result<()>;
    fn AllocateSample(&mut self) -> ::windows::core::Result<IMFSample>;
}
impl IMFVideoSampleAllocator_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFVideoSampleAllocator_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFVideoSampleAllocator_Vtbl {
        unsafe extern "system" fn SetDirectXManager<Impl: IMFVideoSampleAllocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmanager: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDirectXManager(::core::mem::transmute(&pmanager)).into()
        }
        unsafe extern "system" fn UninitializeSampleAllocator<Impl: IMFVideoSampleAllocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).UninitializeSampleAllocator().into()
        }
        unsafe extern "system" fn InitializeSampleAllocator<Impl: IMFVideoSampleAllocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, crequestedframes: u32, pmediatype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InitializeSampleAllocator(::core::mem::transmute_copy(&crequestedframes), ::core::mem::transmute(&pmediatype)).into()
        }
        unsafe extern "system" fn AllocateSample<Impl: IMFVideoSampleAllocator_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppsample: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).AllocateSample() {
                ::core::result::Result::Ok(ok__) => {
                    *ppsample = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetDirectXManager: SetDirectXManager::<Impl, IMPL_OFFSET>,
            UninitializeSampleAllocator: UninitializeSampleAllocator::<Impl, IMPL_OFFSET>,
            InitializeSampleAllocator: InitializeSampleAllocator::<Impl, IMPL_OFFSET>,
            AllocateSample: AllocateSample::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFVideoSampleAllocator as ::windows::core::Interface>::IID
    }
}
pub trait IMFVideoSampleAllocatorCallback_Impl: Sized {
    fn SetCallback(&mut self, pnotify: ::core::option::Option<IMFVideoSampleAllocatorNotify>) -> ::windows::core::Result<()>;
    fn GetFreeSampleCount(&mut self) -> ::windows::core::Result<i32>;
}
impl IMFVideoSampleAllocatorCallback_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFVideoSampleAllocatorCallback_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFVideoSampleAllocatorCallback_Vtbl {
        unsafe extern "system" fn SetCallback<Impl: IMFVideoSampleAllocatorCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pnotify: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetCallback(::core::mem::transmute(&pnotify)).into()
        }
        unsafe extern "system" fn GetFreeSampleCount<Impl: IMFVideoSampleAllocatorCallback_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plsamples: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetFreeSampleCount() {
                ::core::result::Result::Ok(ok__) => {
                    *plsamples = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetCallback: SetCallback::<Impl, IMPL_OFFSET>,
            GetFreeSampleCount: GetFreeSampleCount::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFVideoSampleAllocatorCallback as ::windows::core::Interface>::IID
    }
}
pub trait IMFVideoSampleAllocatorEx_Impl: Sized + IMFVideoSampleAllocator_Impl {
    fn InitializeSampleAllocatorEx(&mut self, cinitialsamples: u32, cmaximumsamples: u32, pattributes: ::core::option::Option<IMFAttributes>, pmediatype: ::core::option::Option<IMFMediaType>) -> ::windows::core::Result<()>;
}
impl IMFVideoSampleAllocatorEx_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFVideoSampleAllocatorEx_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFVideoSampleAllocatorEx_Vtbl {
        unsafe extern "system" fn InitializeSampleAllocatorEx<Impl: IMFVideoSampleAllocatorEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, cinitialsamples: u32, cmaximumsamples: u32, pattributes: ::windows::core::RawPtr, pmediatype: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).InitializeSampleAllocatorEx(::core::mem::transmute_copy(&cinitialsamples), ::core::mem::transmute_copy(&cmaximumsamples), ::core::mem::transmute(&pattributes), ::core::mem::transmute(&pmediatype)).into()
        }
        Self {
            base: IMFVideoSampleAllocator_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            InitializeSampleAllocatorEx: InitializeSampleAllocatorEx::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFVideoSampleAllocatorEx as ::windows::core::Interface>::IID
    }
}
pub trait IMFVideoSampleAllocatorNotify_Impl: Sized {
    fn NotifyRelease(&mut self) -> ::windows::core::Result<()>;
}
impl IMFVideoSampleAllocatorNotify_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFVideoSampleAllocatorNotify_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFVideoSampleAllocatorNotify_Vtbl {
        unsafe extern "system" fn NotifyRelease<Impl: IMFVideoSampleAllocatorNotify_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NotifyRelease().into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), NotifyRelease: NotifyRelease::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFVideoSampleAllocatorNotify as ::windows::core::Interface>::IID
    }
}
pub trait IMFVideoSampleAllocatorNotifyEx_Impl: Sized + IMFVideoSampleAllocatorNotify_Impl {
    fn NotifyPrune(&mut self, __midl__imfvideosampleallocatornotifyex0000: ::core::option::Option<IMFSample>) -> ::windows::core::Result<()>;
}
impl IMFVideoSampleAllocatorNotifyEx_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFVideoSampleAllocatorNotifyEx_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFVideoSampleAllocatorNotifyEx_Vtbl {
        unsafe extern "system" fn NotifyPrune<Impl: IMFVideoSampleAllocatorNotifyEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, __midl__imfvideosampleallocatornotifyex0000: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).NotifyPrune(::core::mem::transmute(&__midl__imfvideosampleallocatornotifyex0000)).into()
        }
        Self { base: IMFVideoSampleAllocatorNotify_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), NotifyPrune: NotifyPrune::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFVideoSampleAllocatorNotifyEx as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Devices_Properties", feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
pub trait IMFVirtualCamera_Impl: Sized + IMFAttributes_Impl {
    fn AddDeviceSourceInfo(&mut self, devicesourceinfo: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn AddProperty(&mut self, pkey: *const super::super::Devices::Properties::DEVPROPKEY, r#type: u32, pbdata: *const u8, cbdata: u32) -> ::windows::core::Result<()>;
    fn AddRegistryEntry(&mut self, entryname: super::super::Foundation::PWSTR, subkeypath: super::super::Foundation::PWSTR, dwregtype: u32, pbdata: *const u8, cbdata: u32) -> ::windows::core::Result<()>;
    fn Start(&mut self, pcallback: ::core::option::Option<IMFAsyncCallback>) -> ::windows::core::Result<()>;
    fn Stop(&mut self) -> ::windows::core::Result<()>;
    fn Remove(&mut self) -> ::windows::core::Result<()>;
    fn GetMediaSource(&mut self) -> ::windows::core::Result<IMFMediaSource>;
    fn SendCameraProperty(&mut self, propertyset: *const ::windows::core::GUID, propertyid: u32, propertyflags: u32, propertypayload: *mut ::core::ffi::c_void, propertypayloadlength: u32, data: *mut ::core::ffi::c_void, datalength: u32, datawritten: *mut u32) -> ::windows::core::Result<()>;
    fn CreateSyncEvent(&mut self, kseventset: *const ::windows::core::GUID, kseventid: u32, kseventflags: u32, eventhandle: super::super::Foundation::HANDLE) -> ::windows::core::Result<IMFCameraSyncObject>;
    fn CreateSyncSemaphore(&mut self, kseventset: *const ::windows::core::GUID, kseventid: u32, kseventflags: u32, semaphorehandle: super::super::Foundation::HANDLE, semaphoreadjustment: i32) -> ::windows::core::Result<IMFCameraSyncObject>;
    fn Shutdown(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Devices_Properties", feature = "Win32_Foundation", feature = "Win32_System_Com", feature = "Win32_System_Com_StructuredStorage"))]
impl IMFVirtualCamera_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFVirtualCamera_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFVirtualCamera_Vtbl {
        unsafe extern "system" fn AddDeviceSourceInfo<Impl: IMFVirtualCamera_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, devicesourceinfo: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddDeviceSourceInfo(::core::mem::transmute_copy(&devicesourceinfo)).into()
        }
        unsafe extern "system" fn AddProperty<Impl: IMFVirtualCamera_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pkey: *const super::super::Devices::Properties::DEVPROPKEY, r#type: u32, pbdata: *const u8, cbdata: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddProperty(::core::mem::transmute_copy(&pkey), ::core::mem::transmute_copy(&r#type), ::core::mem::transmute_copy(&pbdata), ::core::mem::transmute_copy(&cbdata)).into()
        }
        unsafe extern "system" fn AddRegistryEntry<Impl: IMFVirtualCamera_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, entryname: super::super::Foundation::PWSTR, subkeypath: super::super::Foundation::PWSTR, dwregtype: u32, pbdata: *const u8, cbdata: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddRegistryEntry(::core::mem::transmute_copy(&entryname), ::core::mem::transmute_copy(&subkeypath), ::core::mem::transmute_copy(&dwregtype), ::core::mem::transmute_copy(&pbdata), ::core::mem::transmute_copy(&cbdata)).into()
        }
        unsafe extern "system" fn Start<Impl: IMFVirtualCamera_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Start(::core::mem::transmute(&pcallback)).into()
        }
        unsafe extern "system" fn Stop<Impl: IMFVirtualCamera_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Stop().into()
        }
        unsafe extern "system" fn Remove<Impl: IMFVirtualCamera_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Remove().into()
        }
        unsafe extern "system" fn GetMediaSource<Impl: IMFVirtualCamera_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ppmediasource: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetMediaSource() {
                ::core::result::Result::Ok(ok__) => {
                    *ppmediasource = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn SendCameraProperty<Impl: IMFVirtualCamera_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, propertyset: *const ::windows::core::GUID, propertyid: u32, propertyflags: u32, propertypayload: *mut ::core::ffi::c_void, propertypayloadlength: u32, data: *mut ::core::ffi::c_void, datalength: u32, datawritten: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SendCameraProperty(::core::mem::transmute_copy(&propertyset), ::core::mem::transmute_copy(&propertyid), ::core::mem::transmute_copy(&propertyflags), ::core::mem::transmute_copy(&propertypayload), ::core::mem::transmute_copy(&propertypayloadlength), ::core::mem::transmute_copy(&data), ::core::mem::transmute_copy(&datalength), ::core::mem::transmute_copy(&datawritten)).into()
        }
        unsafe extern "system" fn CreateSyncEvent<Impl: IMFVirtualCamera_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, kseventset: *const ::windows::core::GUID, kseventid: u32, kseventflags: u32, eventhandle: super::super::Foundation::HANDLE, camerasyncobject: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateSyncEvent(::core::mem::transmute_copy(&kseventset), ::core::mem::transmute_copy(&kseventid), ::core::mem::transmute_copy(&kseventflags), ::core::mem::transmute_copy(&eventhandle)) {
                ::core::result::Result::Ok(ok__) => {
                    *camerasyncobject = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateSyncSemaphore<Impl: IMFVirtualCamera_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, kseventset: *const ::windows::core::GUID, kseventid: u32, kseventflags: u32, semaphorehandle: super::super::Foundation::HANDLE, semaphoreadjustment: i32, camerasyncobject: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateSyncSemaphore(::core::mem::transmute_copy(&kseventset), ::core::mem::transmute_copy(&kseventid), ::core::mem::transmute_copy(&kseventflags), ::core::mem::transmute_copy(&semaphorehandle), ::core::mem::transmute_copy(&semaphoreadjustment)) {
                ::core::result::Result::Ok(ok__) => {
                    *camerasyncobject = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Shutdown<Impl: IMFVirtualCamera_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Shutdown().into()
        }
        Self {
            base: IMFAttributes_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            AddDeviceSourceInfo: AddDeviceSourceInfo::<Impl, IMPL_OFFSET>,
            AddProperty: AddProperty::<Impl, IMPL_OFFSET>,
            AddRegistryEntry: AddRegistryEntry::<Impl, IMPL_OFFSET>,
            Start: Start::<Impl, IMPL_OFFSET>,
            Stop: Stop::<Impl, IMPL_OFFSET>,
            Remove: Remove::<Impl, IMPL_OFFSET>,
            GetMediaSource: GetMediaSource::<Impl, IMPL_OFFSET>,
            SendCameraProperty: SendCameraProperty::<Impl, IMPL_OFFSET>,
            CreateSyncEvent: CreateSyncEvent::<Impl, IMPL_OFFSET>,
            CreateSyncSemaphore: CreateSyncSemaphore::<Impl, IMPL_OFFSET>,
            Shutdown: Shutdown::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFVirtualCamera as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFWorkQueueServices_Impl: Sized {
    fn BeginRegisterTopologyWorkQueuesWithMMCSS(&mut self, pcallback: ::core::option::Option<IMFAsyncCallback>, pstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndRegisterTopologyWorkQueuesWithMMCSS(&mut self, presult: ::core::option::Option<IMFAsyncResult>) -> ::windows::core::Result<()>;
    fn BeginUnregisterTopologyWorkQueuesWithMMCSS(&mut self, pcallback: ::core::option::Option<IMFAsyncCallback>, pstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndUnregisterTopologyWorkQueuesWithMMCSS(&mut self, presult: ::core::option::Option<IMFAsyncResult>) -> ::windows::core::Result<()>;
    fn GetTopologyWorkQueueMMCSSClass(&mut self, dwtopologyworkqueueid: u32, pwszclass: super::super::Foundation::PWSTR, pcchclass: *mut u32) -> ::windows::core::Result<()>;
    fn GetTopologyWorkQueueMMCSSTaskId(&mut self, dwtopologyworkqueueid: u32) -> ::windows::core::Result<u32>;
    fn BeginRegisterPlatformWorkQueueWithMMCSS(&mut self, dwplatformworkqueue: u32, wszclass: super::super::Foundation::PWSTR, dwtaskid: u32, pcallback: ::core::option::Option<IMFAsyncCallback>, pstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndRegisterPlatformWorkQueueWithMMCSS(&mut self, presult: ::core::option::Option<IMFAsyncResult>) -> ::windows::core::Result<u32>;
    fn BeginUnregisterPlatformWorkQueueWithMMCSS(&mut self, dwplatformworkqueue: u32, pcallback: ::core::option::Option<IMFAsyncCallback>, pstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn EndUnregisterPlatformWorkQueueWithMMCSS(&mut self, presult: ::core::option::Option<IMFAsyncResult>) -> ::windows::core::Result<()>;
    fn GetPlaftormWorkQueueMMCSSClass(&mut self, dwplatformworkqueueid: u32, pwszclass: super::super::Foundation::PWSTR, pcchclass: *mut u32) -> ::windows::core::Result<()>;
    fn GetPlatformWorkQueueMMCSSTaskId(&mut self, dwplatformworkqueueid: u32) -> ::windows::core::Result<u32>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFWorkQueueServices_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFWorkQueueServices_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFWorkQueueServices_Vtbl {
        unsafe extern "system" fn BeginRegisterTopologyWorkQueuesWithMMCSS<Impl: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginRegisterTopologyWorkQueuesWithMMCSS(::core::mem::transmute(&pcallback), ::core::mem::transmute(&pstate)).into()
        }
        unsafe extern "system" fn EndRegisterTopologyWorkQueuesWithMMCSS<Impl: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndRegisterTopologyWorkQueuesWithMMCSS(::core::mem::transmute(&presult)).into()
        }
        unsafe extern "system" fn BeginUnregisterTopologyWorkQueuesWithMMCSS<Impl: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcallback: ::windows::core::RawPtr, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginUnregisterTopologyWorkQueuesWithMMCSS(::core::mem::transmute(&pcallback), ::core::mem::transmute(&pstate)).into()
        }
        unsafe extern "system" fn EndUnregisterTopologyWorkQueuesWithMMCSS<Impl: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndUnregisterTopologyWorkQueuesWithMMCSS(::core::mem::transmute(&presult)).into()
        }
        unsafe extern "system" fn GetTopologyWorkQueueMMCSSClass<Impl: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwtopologyworkqueueid: u32, pwszclass: super::super::Foundation::PWSTR, pcchclass: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTopologyWorkQueueMMCSSClass(::core::mem::transmute_copy(&dwtopologyworkqueueid), ::core::mem::transmute_copy(&pwszclass), ::core::mem::transmute_copy(&pcchclass)).into()
        }
        unsafe extern "system" fn GetTopologyWorkQueueMMCSSTaskId<Impl: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwtopologyworkqueueid: u32, pdwtaskid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTopologyWorkQueueMMCSSTaskId(::core::mem::transmute_copy(&dwtopologyworkqueueid)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwtaskid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginRegisterPlatformWorkQueueWithMMCSS<Impl: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwplatformworkqueue: u32, wszclass: super::super::Foundation::PWSTR, dwtaskid: u32, pcallback: ::windows::core::RawPtr, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginRegisterPlatformWorkQueueWithMMCSS(::core::mem::transmute_copy(&dwplatformworkqueue), ::core::mem::transmute_copy(&wszclass), ::core::mem::transmute_copy(&dwtaskid), ::core::mem::transmute(&pcallback), ::core::mem::transmute(&pstate)).into()
        }
        unsafe extern "system" fn EndRegisterPlatformWorkQueueWithMMCSS<Impl: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr, pdwtaskid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).EndRegisterPlatformWorkQueueWithMMCSS(::core::mem::transmute(&presult)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwtaskid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginUnregisterPlatformWorkQueueWithMMCSS<Impl: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwplatformworkqueue: u32, pcallback: ::windows::core::RawPtr, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginUnregisterPlatformWorkQueueWithMMCSS(::core::mem::transmute_copy(&dwplatformworkqueue), ::core::mem::transmute(&pcallback), ::core::mem::transmute(&pstate)).into()
        }
        unsafe extern "system" fn EndUnregisterPlatformWorkQueueWithMMCSS<Impl: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, presult: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).EndUnregisterPlatformWorkQueueWithMMCSS(::core::mem::transmute(&presult)).into()
        }
        unsafe extern "system" fn GetPlaftormWorkQueueMMCSSClass<Impl: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwplatformworkqueueid: u32, pwszclass: super::super::Foundation::PWSTR, pcchclass: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPlaftormWorkQueueMMCSSClass(::core::mem::transmute_copy(&dwplatformworkqueueid), ::core::mem::transmute_copy(&pwszclass), ::core::mem::transmute_copy(&pcchclass)).into()
        }
        unsafe extern "system" fn GetPlatformWorkQueueMMCSSTaskId<Impl: IMFWorkQueueServices_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwplatformworkqueueid: u32, pdwtaskid: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPlatformWorkQueueMMCSSTaskId(::core::mem::transmute_copy(&dwplatformworkqueueid)) {
                ::core::result::Result::Ok(ok__) => {
                    *pdwtaskid = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            BeginRegisterTopologyWorkQueuesWithMMCSS: BeginRegisterTopologyWorkQueuesWithMMCSS::<Impl, IMPL_OFFSET>,
            EndRegisterTopologyWorkQueuesWithMMCSS: EndRegisterTopologyWorkQueuesWithMMCSS::<Impl, IMPL_OFFSET>,
            BeginUnregisterTopologyWorkQueuesWithMMCSS: BeginUnregisterTopologyWorkQueuesWithMMCSS::<Impl, IMPL_OFFSET>,
            EndUnregisterTopologyWorkQueuesWithMMCSS: EndUnregisterTopologyWorkQueuesWithMMCSS::<Impl, IMPL_OFFSET>,
            GetTopologyWorkQueueMMCSSClass: GetTopologyWorkQueueMMCSSClass::<Impl, IMPL_OFFSET>,
            GetTopologyWorkQueueMMCSSTaskId: GetTopologyWorkQueueMMCSSTaskId::<Impl, IMPL_OFFSET>,
            BeginRegisterPlatformWorkQueueWithMMCSS: BeginRegisterPlatformWorkQueueWithMMCSS::<Impl, IMPL_OFFSET>,
            EndRegisterPlatformWorkQueueWithMMCSS: EndRegisterPlatformWorkQueueWithMMCSS::<Impl, IMPL_OFFSET>,
            BeginUnregisterPlatformWorkQueueWithMMCSS: BeginUnregisterPlatformWorkQueueWithMMCSS::<Impl, IMPL_OFFSET>,
            EndUnregisterPlatformWorkQueueWithMMCSS: EndUnregisterPlatformWorkQueueWithMMCSS::<Impl, IMPL_OFFSET>,
            GetPlaftormWorkQueueMMCSSClass: GetPlaftormWorkQueueMMCSSClass::<Impl, IMPL_OFFSET>,
            GetPlatformWorkQueueMMCSSTaskId: GetPlatformWorkQueueMMCSSTaskId::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFWorkQueueServices as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IMFWorkQueueServicesEx_Impl: Sized + IMFWorkQueueServices_Impl {
    fn GetTopologyWorkQueueMMCSSPriority(&mut self, dwtopologyworkqueueid: u32) -> ::windows::core::Result<i32>;
    fn BeginRegisterPlatformWorkQueueWithMMCSSEx(&mut self, dwplatformworkqueue: u32, wszclass: super::super::Foundation::PWSTR, dwtaskid: u32, lpriority: i32, pcallback: ::core::option::Option<IMFAsyncCallback>, pstate: ::core::option::Option<::windows::core::IUnknown>) -> ::windows::core::Result<()>;
    fn GetPlatformWorkQueueMMCSSPriority(&mut self, dwplatformworkqueueid: u32) -> ::windows::core::Result<i32>;
}
#[cfg(feature = "Win32_Foundation")]
impl IMFWorkQueueServicesEx_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IMFWorkQueueServicesEx_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IMFWorkQueueServicesEx_Vtbl {
        unsafe extern "system" fn GetTopologyWorkQueueMMCSSPriority<Impl: IMFWorkQueueServicesEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwtopologyworkqueueid: u32, plpriority: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTopologyWorkQueueMMCSSPriority(::core::mem::transmute_copy(&dwtopologyworkqueueid)) {
                ::core::result::Result::Ok(ok__) => {
                    *plpriority = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn BeginRegisterPlatformWorkQueueWithMMCSSEx<Impl: IMFWorkQueueServicesEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwplatformworkqueue: u32, wszclass: super::super::Foundation::PWSTR, dwtaskid: u32, lpriority: i32, pcallback: ::windows::core::RawPtr, pstate: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).BeginRegisterPlatformWorkQueueWithMMCSSEx(::core::mem::transmute_copy(&dwplatformworkqueue), ::core::mem::transmute_copy(&wszclass), ::core::mem::transmute_copy(&dwtaskid), ::core::mem::transmute_copy(&lpriority), ::core::mem::transmute(&pcallback), ::core::mem::transmute(&pstate)).into()
        }
        unsafe extern "system" fn GetPlatformWorkQueueMMCSSPriority<Impl: IMFWorkQueueServicesEx_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwplatformworkqueueid: u32, plpriority: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetPlatformWorkQueueMMCSSPriority(::core::mem::transmute_copy(&dwplatformworkqueueid)) {
                ::core::result::Result::Ok(ok__) => {
                    *plpriority = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base: IMFWorkQueueServices_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(),
            GetTopologyWorkQueueMMCSSPriority: GetTopologyWorkQueueMMCSSPriority::<Impl, IMPL_OFFSET>,
            BeginRegisterPlatformWorkQueueWithMMCSSEx: BeginRegisterPlatformWorkQueueWithMMCSSEx::<Impl, IMPL_OFFSET>,
            GetPlatformWorkQueueMMCSSPriority: GetPlatformWorkQueueMMCSSPriority::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IMFWorkQueueServicesEx as ::windows::core::Interface>::IID
    }
}
pub trait IOPMVideoOutput_Impl: Sized {
    fn StartInitialization(&mut self, prnrandomnumber: *mut OPM_RANDOM_NUMBER, ppbcertificate: *mut *mut u8, pulcertificatelength: *mut u32) -> ::windows::core::Result<()>;
    fn FinishInitialization(&mut self, pparameters: *const OPM_ENCRYPTED_INITIALIZATION_PARAMETERS) -> ::windows::core::Result<()>;
    fn GetInformation(&mut self, pparameters: *const OPM_GET_INFO_PARAMETERS) -> ::windows::core::Result<OPM_REQUESTED_INFORMATION>;
    fn COPPCompatibleGetInformation(&mut self, pparameters: *const OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS) -> ::windows::core::Result<OPM_REQUESTED_INFORMATION>;
    fn Configure(&mut self, pparameters: *const OPM_CONFIGURE_PARAMETERS, uladditionalparameterssize: u32, pbadditionalparameters: *const u8) -> ::windows::core::Result<()>;
}
impl IOPMVideoOutput_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IOPMVideoOutput_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IOPMVideoOutput_Vtbl {
        unsafe extern "system" fn StartInitialization<Impl: IOPMVideoOutput_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prnrandomnumber: *mut OPM_RANDOM_NUMBER, ppbcertificate: *mut *mut u8, pulcertificatelength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).StartInitialization(::core::mem::transmute_copy(&prnrandomnumber), ::core::mem::transmute_copy(&ppbcertificate), ::core::mem::transmute_copy(&pulcertificatelength)).into()
        }
        unsafe extern "system" fn FinishInitialization<Impl: IOPMVideoOutput_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pparameters: *const OPM_ENCRYPTED_INITIALIZATION_PARAMETERS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).FinishInitialization(::core::mem::transmute_copy(&pparameters)).into()
        }
        unsafe extern "system" fn GetInformation<Impl: IOPMVideoOutput_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pparameters: *const OPM_GET_INFO_PARAMETERS, prequestedinformation: *mut OPM_REQUESTED_INFORMATION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetInformation(::core::mem::transmute_copy(&pparameters)) {
                ::core::result::Result::Ok(ok__) => {
                    *prequestedinformation = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn COPPCompatibleGetInformation<Impl: IOPMVideoOutput_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pparameters: *const OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS, prequestedinformation: *mut OPM_REQUESTED_INFORMATION) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).COPPCompatibleGetInformation(::core::mem::transmute_copy(&pparameters)) {
                ::core::result::Result::Ok(ok__) => {
                    *prequestedinformation = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn Configure<Impl: IOPMVideoOutput_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pparameters: *const OPM_CONFIGURE_PARAMETERS, uladditionalparameterssize: u32, pbadditionalparameters: *const u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Configure(::core::mem::transmute_copy(&pparameters), ::core::mem::transmute_copy(&uladditionalparameterssize), ::core::mem::transmute_copy(&pbadditionalparameters)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            StartInitialization: StartInitialization::<Impl, IMPL_OFFSET>,
            FinishInitialization: FinishInitialization::<Impl, IMPL_OFFSET>,
            GetInformation: GetInformation::<Impl, IMPL_OFFSET>,
            COPPCompatibleGetInformation: COPPCompatibleGetInformation::<Impl, IMPL_OFFSET>,
            Configure: Configure::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IOPMVideoOutput as ::windows::core::Interface>::IID
    }
}
pub trait IPlayToControl_Impl: Sized {
    fn Connect(&mut self, pfactory: ::core::option::Option<IMFSharingEngineClassFactory>) -> ::windows::core::Result<()>;
    fn Disconnect(&mut self) -> ::windows::core::Result<()>;
}
impl IPlayToControl_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPlayToControl_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPlayToControl_Vtbl {
        unsafe extern "system" fn Connect<Impl: IPlayToControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pfactory: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Connect(::core::mem::transmute(&pfactory)).into()
        }
        unsafe extern "system" fn Disconnect<Impl: IPlayToControl_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Disconnect().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Connect: Connect::<Impl, IMPL_OFFSET>,
            Disconnect: Disconnect::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPlayToControl as ::windows::core::Interface>::IID
    }
}
pub trait IPlayToControlWithCapabilities_Impl: Sized + IPlayToControl_Impl {
    fn GetCapabilities(&mut self) -> ::windows::core::Result<PLAYTO_SOURCE_CREATEFLAGS>;
}
impl IPlayToControlWithCapabilities_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPlayToControlWithCapabilities_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPlayToControlWithCapabilities_Vtbl {
        unsafe extern "system" fn GetCapabilities<Impl: IPlayToControlWithCapabilities_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pcapabilities: *mut PLAYTO_SOURCE_CREATEFLAGS) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetCapabilities() {
                ::core::result::Result::Ok(ok__) => {
                    *pcapabilities = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: IPlayToControl_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>(), GetCapabilities: GetCapabilities::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPlayToControlWithCapabilities as ::windows::core::Interface>::IID
    }
}
pub trait IPlayToSourceClassFactory_Impl: Sized {
    fn CreateInstance(&mut self, dwflags: u32, pcontrol: ::core::option::Option<IPlayToControl>) -> ::windows::core::Result<::windows::core::IInspectable>;
}
impl IPlayToSourceClassFactory_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IPlayToSourceClassFactory_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IPlayToSourceClassFactory_Vtbl {
        unsafe extern "system" fn CreateInstance<Impl: IPlayToSourceClassFactory_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwflags: u32, pcontrol: ::windows::core::RawPtr, ppsource: *mut *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).CreateInstance(::core::mem::transmute_copy(&dwflags), ::core::mem::transmute(&pcontrol)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppsource = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), CreateInstance: CreateInstance::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IPlayToSourceClassFactory as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IToc_Impl: Sized {
    fn SetDescriptor(&mut self, pdescriptor: *mut TOC_DESCRIPTOR) -> ::windows::core::Result<()>;
    fn GetDescriptor(&mut self, pdescriptor: *mut TOC_DESCRIPTOR) -> ::windows::core::Result<()>;
    fn SetDescription(&mut self, pwszdescription: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn GetDescription(&mut self, pwdescriptionsize: *mut u16, pwszdescription: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn SetContext(&mut self, dwcontextsize: u32, pbtcontext: *mut u8) -> ::windows::core::Result<()>;
    fn GetContext(&mut self, pdwcontextsize: *mut u32, pbtcontext: *mut u8) -> ::windows::core::Result<()>;
    fn GetEntryListCount(&mut self, pwcount: *mut u16) -> ::windows::core::Result<()>;
    fn GetEntryListByIndex(&mut self, wentrylistindex: u16) -> ::windows::core::Result<ITocEntryList>;
    fn AddEntryList(&mut self, pentrylist: ::core::option::Option<ITocEntryList>, pwentrylistindex: *mut u16) -> ::windows::core::Result<()>;
    fn AddEntryListByIndex(&mut self, wentrylistindex: u16, pentrylist: ::core::option::Option<ITocEntryList>) -> ::windows::core::Result<()>;
    fn RemoveEntryListByIndex(&mut self, wentrylistindex: u16) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IToc_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IToc_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IToc_Vtbl {
        unsafe extern "system" fn SetDescriptor<Impl: IToc_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdescriptor: *mut TOC_DESCRIPTOR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDescriptor(::core::mem::transmute_copy(&pdescriptor)).into()
        }
        unsafe extern "system" fn GetDescriptor<Impl: IToc_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdescriptor: *mut TOC_DESCRIPTOR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDescriptor(::core::mem::transmute_copy(&pdescriptor)).into()
        }
        unsafe extern "system" fn SetDescription<Impl: IToc_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwszdescription: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDescription(::core::mem::transmute_copy(&pwszdescription)).into()
        }
        unsafe extern "system" fn GetDescription<Impl: IToc_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwdescriptionsize: *mut u16, pwszdescription: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDescription(::core::mem::transmute_copy(&pwdescriptionsize), ::core::mem::transmute_copy(&pwszdescription)).into()
        }
        unsafe extern "system" fn SetContext<Impl: IToc_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwcontextsize: u32, pbtcontext: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetContext(::core::mem::transmute_copy(&dwcontextsize), ::core::mem::transmute_copy(&pbtcontext)).into()
        }
        unsafe extern "system" fn GetContext<Impl: IToc_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwcontextsize: *mut u32, pbtcontext: *mut u8) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetContext(::core::mem::transmute_copy(&pdwcontextsize), ::core::mem::transmute_copy(&pbtcontext)).into()
        }
        unsafe extern "system" fn GetEntryListCount<Impl: IToc_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwcount: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetEntryListCount(::core::mem::transmute_copy(&pwcount)).into()
        }
        unsafe extern "system" fn GetEntryListByIndex<Impl: IToc_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wentrylistindex: u16, ppentrylist: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEntryListByIndex(::core::mem::transmute_copy(&wentrylistindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppentrylist = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddEntryList<Impl: IToc_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pentrylist: ::windows::core::RawPtr, pwentrylistindex: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddEntryList(::core::mem::transmute(&pentrylist), ::core::mem::transmute_copy(&pwentrylistindex)).into()
        }
        unsafe extern "system" fn AddEntryListByIndex<Impl: IToc_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wentrylistindex: u16, pentrylist: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddEntryListByIndex(::core::mem::transmute_copy(&wentrylistindex), ::core::mem::transmute(&pentrylist)).into()
        }
        unsafe extern "system" fn RemoveEntryListByIndex<Impl: IToc_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, wentrylistindex: u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveEntryListByIndex(::core::mem::transmute_copy(&wentrylistindex)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetDescriptor: SetDescriptor::<Impl, IMPL_OFFSET>,
            GetDescriptor: GetDescriptor::<Impl, IMPL_OFFSET>,
            SetDescription: SetDescription::<Impl, IMPL_OFFSET>,
            GetDescription: GetDescription::<Impl, IMPL_OFFSET>,
            SetContext: SetContext::<Impl, IMPL_OFFSET>,
            GetContext: GetContext::<Impl, IMPL_OFFSET>,
            GetEntryListCount: GetEntryListCount::<Impl, IMPL_OFFSET>,
            GetEntryListByIndex: GetEntryListByIndex::<Impl, IMPL_OFFSET>,
            AddEntryList: AddEntryList::<Impl, IMPL_OFFSET>,
            AddEntryListByIndex: AddEntryListByIndex::<Impl, IMPL_OFFSET>,
            RemoveEntryListByIndex: RemoveEntryListByIndex::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IToc as ::windows::core::Interface>::IID
    }
}
pub trait ITocCollection_Impl: Sized {
    fn GetEntryCount(&mut self, pdwentrycount: *mut u32) -> ::windows::core::Result<()>;
    fn GetEntryByIndex(&mut self, dwentryindex: u32) -> ::windows::core::Result<IToc>;
    fn AddEntry(&mut self, ptoc: ::core::option::Option<IToc>, pdwentryindex: *mut u32) -> ::windows::core::Result<()>;
    fn AddEntryByIndex(&mut self, dwentryindex: u32, ptoc: ::core::option::Option<IToc>) -> ::windows::core::Result<()>;
    fn RemoveEntryByIndex(&mut self, dwentryindex: u32) -> ::windows::core::Result<()>;
}
impl ITocCollection_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITocCollection_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITocCollection_Vtbl {
        unsafe extern "system" fn GetEntryCount<Impl: ITocCollection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwentrycount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetEntryCount(::core::mem::transmute_copy(&pdwentrycount)).into()
        }
        unsafe extern "system" fn GetEntryByIndex<Impl: ITocCollection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwentryindex: u32, pptoc: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEntryByIndex(::core::mem::transmute_copy(&dwentryindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pptoc = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddEntry<Impl: ITocCollection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ptoc: ::windows::core::RawPtr, pdwentryindex: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddEntry(::core::mem::transmute(&ptoc), ::core::mem::transmute_copy(&pdwentryindex)).into()
        }
        unsafe extern "system" fn AddEntryByIndex<Impl: ITocCollection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwentryindex: u32, ptoc: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddEntryByIndex(::core::mem::transmute_copy(&dwentryindex), ::core::mem::transmute(&ptoc)).into()
        }
        unsafe extern "system" fn RemoveEntryByIndex<Impl: ITocCollection_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwentryindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveEntryByIndex(::core::mem::transmute_copy(&dwentryindex)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetEntryCount: GetEntryCount::<Impl, IMPL_OFFSET>,
            GetEntryByIndex: GetEntryByIndex::<Impl, IMPL_OFFSET>,
            AddEntry: AddEntry::<Impl, IMPL_OFFSET>,
            AddEntryByIndex: AddEntryByIndex::<Impl, IMPL_OFFSET>,
            RemoveEntryByIndex: RemoveEntryByIndex::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITocCollection as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait ITocEntry_Impl: Sized {
    fn SetTitle(&mut self, pwsztitle: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn GetTitle(&mut self, pwtitlesize: *mut u16, pwsztitle: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn SetDescriptor(&mut self, pdescriptor: *mut TOC_ENTRY_DESCRIPTOR) -> ::windows::core::Result<()>;
    fn GetDescriptor(&mut self, pdescriptor: *mut TOC_ENTRY_DESCRIPTOR) -> ::windows::core::Result<()>;
    fn SetSubEntries(&mut self, dwnumsubentries: u32, pwsubentryindices: *mut u16) -> ::windows::core::Result<()>;
    fn GetSubEntries(&mut self, pdwnumsubentries: *mut u32, pwsubentryindices: *mut u16) -> ::windows::core::Result<()>;
    fn SetDescriptionData(&mut self, dwdescriptiondatasize: u32, pbtdescriptiondata: *mut u8, pguidtype: *mut ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn GetDescriptionData(&mut self, pdwdescriptiondatasize: *mut u32, pbtdescriptiondata: *mut u8, pguidtype: *mut ::windows::core::GUID) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl ITocEntry_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITocEntry_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITocEntry_Vtbl {
        unsafe extern "system" fn SetTitle<Impl: ITocEntry_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwsztitle: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetTitle(::core::mem::transmute_copy(&pwsztitle)).into()
        }
        unsafe extern "system" fn GetTitle<Impl: ITocEntry_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwtitlesize: *mut u16, pwsztitle: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTitle(::core::mem::transmute_copy(&pwtitlesize), ::core::mem::transmute_copy(&pwsztitle)).into()
        }
        unsafe extern "system" fn SetDescriptor<Impl: ITocEntry_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdescriptor: *mut TOC_ENTRY_DESCRIPTOR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDescriptor(::core::mem::transmute_copy(&pdescriptor)).into()
        }
        unsafe extern "system" fn GetDescriptor<Impl: ITocEntry_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdescriptor: *mut TOC_ENTRY_DESCRIPTOR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDescriptor(::core::mem::transmute_copy(&pdescriptor)).into()
        }
        unsafe extern "system" fn SetSubEntries<Impl: ITocEntry_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwnumsubentries: u32, pwsubentryindices: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetSubEntries(::core::mem::transmute_copy(&dwnumsubentries), ::core::mem::transmute_copy(&pwsubentryindices)).into()
        }
        unsafe extern "system" fn GetSubEntries<Impl: ITocEntry_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwnumsubentries: *mut u32, pwsubentryindices: *mut u16) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetSubEntries(::core::mem::transmute_copy(&pdwnumsubentries), ::core::mem::transmute_copy(&pwsubentryindices)).into()
        }
        unsafe extern "system" fn SetDescriptionData<Impl: ITocEntry_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwdescriptiondatasize: u32, pbtdescriptiondata: *mut u8, pguidtype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetDescriptionData(::core::mem::transmute_copy(&dwdescriptiondatasize), ::core::mem::transmute_copy(&pbtdescriptiondata), ::core::mem::transmute_copy(&pguidtype)).into()
        }
        unsafe extern "system" fn GetDescriptionData<Impl: ITocEntry_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwdescriptiondatasize: *mut u32, pbtdescriptiondata: *mut u8, pguidtype: *mut ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDescriptionData(::core::mem::transmute_copy(&pdwdescriptiondatasize), ::core::mem::transmute_copy(&pbtdescriptiondata), ::core::mem::transmute_copy(&pguidtype)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetTitle: SetTitle::<Impl, IMPL_OFFSET>,
            GetTitle: GetTitle::<Impl, IMPL_OFFSET>,
            SetDescriptor: SetDescriptor::<Impl, IMPL_OFFSET>,
            GetDescriptor: GetDescriptor::<Impl, IMPL_OFFSET>,
            SetSubEntries: SetSubEntries::<Impl, IMPL_OFFSET>,
            GetSubEntries: GetSubEntries::<Impl, IMPL_OFFSET>,
            SetDescriptionData: SetDescriptionData::<Impl, IMPL_OFFSET>,
            GetDescriptionData: GetDescriptionData::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITocEntry as ::windows::core::Interface>::IID
    }
}
pub trait ITocEntryList_Impl: Sized {
    fn GetEntryCount(&mut self, pdwentrycount: *mut u32) -> ::windows::core::Result<()>;
    fn GetEntryByIndex(&mut self, dwentryindex: u32) -> ::windows::core::Result<ITocEntry>;
    fn AddEntry(&mut self, pentry: ::core::option::Option<ITocEntry>, pdwentryindex: *mut u32) -> ::windows::core::Result<()>;
    fn AddEntryByIndex(&mut self, dwentryindex: u32, pentry: ::core::option::Option<ITocEntry>) -> ::windows::core::Result<()>;
    fn RemoveEntryByIndex(&mut self, dwentryindex: u32) -> ::windows::core::Result<()>;
}
impl ITocEntryList_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITocEntryList_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITocEntryList_Vtbl {
        unsafe extern "system" fn GetEntryCount<Impl: ITocEntryList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwentrycount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetEntryCount(::core::mem::transmute_copy(&pdwentrycount)).into()
        }
        unsafe extern "system" fn GetEntryByIndex<Impl: ITocEntryList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwentryindex: u32, ppentry: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetEntryByIndex(::core::mem::transmute_copy(&dwentryindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *ppentry = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddEntry<Impl: ITocEntryList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pentry: ::windows::core::RawPtr, pdwentryindex: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddEntry(::core::mem::transmute(&pentry), ::core::mem::transmute_copy(&pdwentryindex)).into()
        }
        unsafe extern "system" fn AddEntryByIndex<Impl: ITocEntryList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwentryindex: u32, pentry: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddEntryByIndex(::core::mem::transmute_copy(&dwentryindex), ::core::mem::transmute(&pentry)).into()
        }
        unsafe extern "system" fn RemoveEntryByIndex<Impl: ITocEntryList_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwentryindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveEntryByIndex(::core::mem::transmute_copy(&dwentryindex)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetEntryCount: GetEntryCount::<Impl, IMPL_OFFSET>,
            GetEntryByIndex: GetEntryByIndex::<Impl, IMPL_OFFSET>,
            AddEntry: AddEntry::<Impl, IMPL_OFFSET>,
            AddEntryByIndex: AddEntryByIndex::<Impl, IMPL_OFFSET>,
            RemoveEntryByIndex: RemoveEntryByIndex::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITocEntryList as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait ITocParser_Impl: Sized {
    fn Init(&mut self, pwszfilename: super::super::Foundation::PWSTR) -> ::windows::core::Result<()>;
    fn GetTocCount(&mut self, enumtocpostype: TOC_POS_TYPE, pdwtoccount: *mut u32) -> ::windows::core::Result<()>;
    fn GetTocByIndex(&mut self, enumtocpostype: TOC_POS_TYPE, dwtocindex: u32) -> ::windows::core::Result<IToc>;
    fn GetTocByType(&mut self, enumtocpostype: TOC_POS_TYPE, guidtoctype: ::windows::core::GUID) -> ::windows::core::Result<ITocCollection>;
    fn AddToc(&mut self, enumtocpostype: TOC_POS_TYPE, ptoc: ::core::option::Option<IToc>, pdwtocindex: *mut u32) -> ::windows::core::Result<()>;
    fn RemoveTocByIndex(&mut self, enumtocpostype: TOC_POS_TYPE, dwtocindex: u32) -> ::windows::core::Result<()>;
    fn RemoveTocByType(&mut self, enumtocpostype: TOC_POS_TYPE, guidtoctype: ::windows::core::GUID) -> ::windows::core::Result<()>;
    fn Commit(&mut self) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl ITocParser_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: ITocParser_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> ITocParser_Vtbl {
        unsafe extern "system" fn Init<Impl: ITocParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pwszfilename: super::super::Foundation::PWSTR) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Init(::core::mem::transmute_copy(&pwszfilename)).into()
        }
        unsafe extern "system" fn GetTocCount<Impl: ITocParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, pdwtoccount: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetTocCount(::core::mem::transmute_copy(&enumtocpostype), ::core::mem::transmute_copy(&pdwtoccount)).into()
        }
        unsafe extern "system" fn GetTocByIndex<Impl: ITocParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, dwtocindex: u32, pptoc: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTocByIndex(::core::mem::transmute_copy(&enumtocpostype), ::core::mem::transmute_copy(&dwtocindex)) {
                ::core::result::Result::Ok(ok__) => {
                    *pptoc = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetTocByType<Impl: ITocParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, guidtoctype: ::windows::core::GUID, pptocs: *mut ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            match (*this).GetTocByType(::core::mem::transmute_copy(&enumtocpostype), ::core::mem::transmute_copy(&guidtoctype)) {
                ::core::result::Result::Ok(ok__) => {
                    *pptocs = ::core::mem::transmute(ok__);
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn AddToc<Impl: ITocParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, ptoc: ::windows::core::RawPtr, pdwtocindex: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).AddToc(::core::mem::transmute_copy(&enumtocpostype), ::core::mem::transmute(&ptoc), ::core::mem::transmute_copy(&pdwtocindex)).into()
        }
        unsafe extern "system" fn RemoveTocByIndex<Impl: ITocParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, dwtocindex: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTocByIndex(::core::mem::transmute_copy(&enumtocpostype), ::core::mem::transmute_copy(&dwtocindex)).into()
        }
        unsafe extern "system" fn RemoveTocByType<Impl: ITocParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, enumtocpostype: TOC_POS_TYPE, guidtoctype: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).RemoveTocByType(::core::mem::transmute_copy(&enumtocpostype), ::core::mem::transmute_copy(&guidtoctype)).into()
        }
        unsafe extern "system" fn Commit<Impl: ITocParser_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).Commit().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            Init: Init::<Impl, IMPL_OFFSET>,
            GetTocCount: GetTocCount::<Impl, IMPL_OFFSET>,
            GetTocByIndex: GetTocByIndex::<Impl, IMPL_OFFSET>,
            GetTocByType: GetTocByType::<Impl, IMPL_OFFSET>,
            AddToc: AddToc::<Impl, IMPL_OFFSET>,
            RemoveTocByIndex: RemoveTocByIndex::<Impl, IMPL_OFFSET>,
            RemoveTocByType: RemoveTocByType::<Impl, IMPL_OFFSET>,
            Commit: Commit::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ITocParser as ::windows::core::Interface>::IID
    }
}
pub trait IValidateBinding_Impl: Sized {
    fn GetIdentifier(&mut self, guidlicensorid: ::windows::core::GUID, pbephemeron: *const u8, cbephemeron: u32, ppbblobvalidationid: *mut *mut u8, pcbblobsize: *mut u32) -> ::windows::core::Result<()>;
}
impl IValidateBinding_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IValidateBinding_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IValidateBinding_Vtbl {
        unsafe extern "system" fn GetIdentifier<Impl: IValidateBinding_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidlicensorid: ::windows::core::GUID, pbephemeron: *const u8, cbephemeron: u32, ppbblobvalidationid: *mut *mut u8, pcbblobsize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetIdentifier(::core::mem::transmute_copy(&guidlicensorid), ::core::mem::transmute_copy(&pbephemeron), ::core::mem::transmute_copy(&cbephemeron), ::core::mem::transmute_copy(&ppbblobvalidationid), ::core::mem::transmute_copy(&pcbblobsize)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetIdentifier: GetIdentifier::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IValidateBinding as ::windows::core::Interface>::IID
    }
}
pub trait IWMCodecLeakyBucket_Impl: Sized {
    fn SetBufferSizeBits(&mut self, ulbuffersize: u32) -> ::windows::core::Result<()>;
    fn GetBufferSizeBits(&mut self, pulbuffersize: *mut u32) -> ::windows::core::Result<()>;
    fn SetBufferFullnessBits(&mut self, ulbufferfullness: u32) -> ::windows::core::Result<()>;
    fn GetBufferFullnessBits(&mut self, pulbufferfullness: *mut u32) -> ::windows::core::Result<()>;
}
impl IWMCodecLeakyBucket_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWMCodecLeakyBucket_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWMCodecLeakyBucket_Vtbl {
        unsafe extern "system" fn SetBufferSizeBits<Impl: IWMCodecLeakyBucket_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulbuffersize: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBufferSizeBits(::core::mem::transmute_copy(&ulbuffersize)).into()
        }
        unsafe extern "system" fn GetBufferSizeBits<Impl: IWMCodecLeakyBucket_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulbuffersize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetBufferSizeBits(::core::mem::transmute_copy(&pulbuffersize)).into()
        }
        unsafe extern "system" fn SetBufferFullnessBits<Impl: IWMCodecLeakyBucket_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, ulbufferfullness: u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetBufferFullnessBits(::core::mem::transmute_copy(&ulbufferfullness)).into()
        }
        unsafe extern "system" fn GetBufferFullnessBits<Impl: IWMCodecLeakyBucket_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pulbufferfullness: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetBufferFullnessBits(::core::mem::transmute_copy(&pulbufferfullness)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetBufferSizeBits: SetBufferSizeBits::<Impl, IMPL_OFFSET>,
            GetBufferSizeBits: GetBufferSizeBits::<Impl, IMPL_OFFSET>,
            SetBufferFullnessBits: SetBufferFullnessBits::<Impl, IMPL_OFFSET>,
            GetBufferFullnessBits: GetBufferFullnessBits::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWMCodecLeakyBucket as ::windows::core::Interface>::IID
    }
}
pub trait IWMCodecOutputTimestamp_Impl: Sized {
    fn GetNextOutputTime(&mut self, prttime: *mut i64) -> ::windows::core::Result<()>;
}
impl IWMCodecOutputTimestamp_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWMCodecOutputTimestamp_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWMCodecOutputTimestamp_Vtbl {
        unsafe extern "system" fn GetNextOutputTime<Impl: IWMCodecOutputTimestamp_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, prttime: *mut i64) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetNextOutputTime(::core::mem::transmute_copy(&prttime)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), GetNextOutputTime: GetNextOutputTime::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWMCodecOutputTimestamp as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_DxMediaObjects"))]
pub trait IWMCodecPrivateData_Impl: Sized {
    fn SetPartialOutputType(&mut self, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE) -> ::windows::core::Result<()>;
    fn GetPrivateData(&mut self, pbdata: *mut u8, pcbdata: *mut u32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_DxMediaObjects"))]
impl IWMCodecPrivateData_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWMCodecPrivateData_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWMCodecPrivateData_Vtbl {
        unsafe extern "system" fn SetPartialOutputType<Impl: IWMCodecPrivateData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetPartialOutputType(::core::mem::transmute_copy(&pmt)).into()
        }
        unsafe extern "system" fn GetPrivateData<Impl: IWMCodecPrivateData_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbdata: *mut u8, pcbdata: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetPrivateData(::core::mem::transmute_copy(&pbdata), ::core::mem::transmute_copy(&pcbdata)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetPartialOutputType: SetPartialOutputType::<Impl, IMPL_OFFSET>,
            GetPrivateData: GetPrivateData::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWMCodecPrivateData as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_DxMediaObjects"))]
pub trait IWMCodecProps_Impl: Sized {
    fn GetFormatProp(&mut self, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE, pszname: super::super::Foundation::PWSTR, ptype: *mut WMT_PROP_DATATYPE, pvalue: *mut u8, pdwsize: *mut u32) -> ::windows::core::Result<()>;
    fn GetCodecProp(&mut self, dwformat: u32, pszname: super::super::Foundation::PWSTR, ptype: *mut WMT_PROP_DATATYPE, pvalue: *mut u8, pdwsize: *mut u32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_DxMediaObjects"))]
impl IWMCodecProps_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWMCodecProps_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWMCodecProps_Vtbl {
        unsafe extern "system" fn GetFormatProp<Impl: IWMCodecProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE, pszname: super::super::Foundation::PWSTR, ptype: *mut WMT_PROP_DATATYPE, pvalue: *mut u8, pdwsize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetFormatProp(::core::mem::transmute_copy(&pmt), ::core::mem::transmute_copy(&pszname), ::core::mem::transmute_copy(&ptype), ::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pdwsize)).into()
        }
        unsafe extern "system" fn GetCodecProp<Impl: IWMCodecProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, dwformat: u32, pszname: super::super::Foundation::PWSTR, ptype: *mut WMT_PROP_DATATYPE, pvalue: *mut u8, pdwsize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetCodecProp(::core::mem::transmute_copy(&dwformat), ::core::mem::transmute_copy(&pszname), ::core::mem::transmute_copy(&ptype), ::core::mem::transmute_copy(&pvalue), ::core::mem::transmute_copy(&pdwsize)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetFormatProp: GetFormatProp::<Impl, IMPL_OFFSET>,
            GetCodecProp: GetCodecProp::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWMCodecProps as ::windows::core::Interface>::IID
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_DxMediaObjects"))]
pub trait IWMCodecStrings_Impl: Sized {
    fn GetName(&mut self, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE, cchlength: u32, szname: super::super::Foundation::PWSTR, pcchlength: *mut u32) -> ::windows::core::Result<()>;
    fn GetDescription(&mut self, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE, cchlength: u32, szdescription: super::super::Foundation::PWSTR, pcchlength: *mut u32) -> ::windows::core::Result<()>;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Media_DxMediaObjects"))]
impl IWMCodecStrings_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWMCodecStrings_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWMCodecStrings_Vtbl {
        unsafe extern "system" fn GetName<Impl: IWMCodecStrings_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE, cchlength: u32, szname: super::super::Foundation::PWSTR, pcchlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetName(::core::mem::transmute_copy(&pmt), ::core::mem::transmute_copy(&cchlength), ::core::mem::transmute_copy(&szname), ::core::mem::transmute_copy(&pcchlength)).into()
        }
        unsafe extern "system" fn GetDescription<Impl: IWMCodecStrings_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pmt: *mut super::DxMediaObjects::DMO_MEDIA_TYPE, cchlength: u32, szdescription: super::super::Foundation::PWSTR, pcchlength: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetDescription(::core::mem::transmute_copy(&pmt), ::core::mem::transmute_copy(&cchlength), ::core::mem::transmute_copy(&szdescription), ::core::mem::transmute_copy(&pcchlength)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetName: GetName::<Impl, IMPL_OFFSET>,
            GetDescription: GetDescription::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWMCodecStrings as ::windows::core::Interface>::IID
    }
}
pub trait IWMColorConvProps_Impl: Sized {
    fn SetMode(&mut self, lmode: i32) -> ::windows::core::Result<()>;
    fn SetFullCroppingParam(&mut self, lsrccropleft: i32, lsrccroptop: i32, ldstcropleft: i32, ldstcroptop: i32, lcropwidth: i32, lcropheight: i32) -> ::windows::core::Result<()>;
}
impl IWMColorConvProps_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWMColorConvProps_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWMColorConvProps_Vtbl {
        unsafe extern "system" fn SetMode<Impl: IWMColorConvProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lmode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetMode(::core::mem::transmute_copy(&lmode)).into()
        }
        unsafe extern "system" fn SetFullCroppingParam<Impl: IWMColorConvProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lsrccropleft: i32, lsrccroptop: i32, ldstcropleft: i32, ldstcroptop: i32, lcropwidth: i32, lcropheight: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFullCroppingParam(::core::mem::transmute_copy(&lsrccropleft), ::core::mem::transmute_copy(&lsrccroptop), ::core::mem::transmute_copy(&ldstcropleft), ::core::mem::transmute_copy(&ldstcroptop), ::core::mem::transmute_copy(&lcropwidth), ::core::mem::transmute_copy(&lcropheight)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetMode: SetMode::<Impl, IMPL_OFFSET>,
            SetFullCroppingParam: SetFullCroppingParam::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWMColorConvProps as ::windows::core::Interface>::IID
    }
}
pub trait IWMColorLegalizerProps_Impl: Sized {
    fn SetColorLegalizerQuality(&mut self, lquality: i32) -> ::windows::core::Result<()>;
}
impl IWMColorLegalizerProps_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWMColorLegalizerProps_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWMColorLegalizerProps_Vtbl {
        unsafe extern "system" fn SetColorLegalizerQuality<Impl: IWMColorLegalizerProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lquality: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetColorLegalizerQuality(::core::mem::transmute_copy(&lquality)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), SetColorLegalizerQuality: SetColorLegalizerQuality::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWMColorLegalizerProps as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IWMFrameInterpProps_Impl: Sized {
    fn SetFrameRateIn(&mut self, lframerate: i32, lscale: i32) -> ::windows::core::Result<()>;
    fn SetFrameRateOut(&mut self, lframerate: i32, lscale: i32) -> ::windows::core::Result<()>;
    fn SetFrameInterpEnabled(&mut self, bfienabled: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
    fn SetComplexityLevel(&mut self, icomplexity: i32) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IWMFrameInterpProps_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWMFrameInterpProps_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWMFrameInterpProps_Vtbl {
        unsafe extern "system" fn SetFrameRateIn<Impl: IWMFrameInterpProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lframerate: i32, lscale: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFrameRateIn(::core::mem::transmute_copy(&lframerate), ::core::mem::transmute_copy(&lscale)).into()
        }
        unsafe extern "system" fn SetFrameRateOut<Impl: IWMFrameInterpProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lframerate: i32, lscale: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFrameRateOut(::core::mem::transmute_copy(&lframerate), ::core::mem::transmute_copy(&lscale)).into()
        }
        unsafe extern "system" fn SetFrameInterpEnabled<Impl: IWMFrameInterpProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, bfienabled: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFrameInterpEnabled(::core::mem::transmute_copy(&bfienabled)).into()
        }
        unsafe extern "system" fn SetComplexityLevel<Impl: IWMFrameInterpProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, icomplexity: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetComplexityLevel(::core::mem::transmute_copy(&icomplexity)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetFrameRateIn: SetFrameRateIn::<Impl, IMPL_OFFSET>,
            SetFrameRateOut: SetFrameRateOut::<Impl, IMPL_OFFSET>,
            SetFrameInterpEnabled: SetFrameInterpEnabled::<Impl, IMPL_OFFSET>,
            SetComplexityLevel: SetComplexityLevel::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWMFrameInterpProps as ::windows::core::Interface>::IID
    }
}
pub trait IWMInterlaceProps_Impl: Sized {
    fn SetProcessType(&mut self, iprocesstype: i32) -> ::windows::core::Result<()>;
    fn SetInitInverseTeleCinePattern(&mut self, iinitpattern: i32) -> ::windows::core::Result<()>;
    fn SetLastFrame(&mut self) -> ::windows::core::Result<()>;
}
impl IWMInterlaceProps_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWMInterlaceProps_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWMInterlaceProps_Vtbl {
        unsafe extern "system" fn SetProcessType<Impl: IWMInterlaceProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, iprocesstype: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetProcessType(::core::mem::transmute_copy(&iprocesstype)).into()
        }
        unsafe extern "system" fn SetInitInverseTeleCinePattern<Impl: IWMInterlaceProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, iinitpattern: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInitInverseTeleCinePattern(::core::mem::transmute_copy(&iinitpattern)).into()
        }
        unsafe extern "system" fn SetLastFrame<Impl: IWMInterlaceProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetLastFrame().into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetProcessType: SetProcessType::<Impl, IMPL_OFFSET>,
            SetInitInverseTeleCinePattern: SetInitInverseTeleCinePattern::<Impl, IMPL_OFFSET>,
            SetLastFrame: SetLastFrame::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWMInterlaceProps as ::windows::core::Interface>::IID
    }
}
pub trait IWMResamplerProps_Impl: Sized {
    fn SetHalfFilterLength(&mut self, lhalffilterlen: i32) -> ::windows::core::Result<()>;
    fn SetUserChannelMtx(&mut self, userchannelmtx: *mut f32) -> ::windows::core::Result<()>;
}
impl IWMResamplerProps_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWMResamplerProps_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWMResamplerProps_Vtbl {
        unsafe extern "system" fn SetHalfFilterLength<Impl: IWMResamplerProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lhalffilterlen: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHalfFilterLength(::core::mem::transmute_copy(&lhalffilterlen)).into()
        }
        unsafe extern "system" fn SetUserChannelMtx<Impl: IWMResamplerProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, userchannelmtx: *mut f32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUserChannelMtx(::core::mem::transmute_copy(&userchannelmtx)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetHalfFilterLength: SetHalfFilterLength::<Impl, IMPL_OFFSET>,
            SetUserChannelMtx: SetUserChannelMtx::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWMResamplerProps as ::windows::core::Interface>::IID
    }
}
pub trait IWMResizerProps_Impl: Sized {
    fn SetResizerQuality(&mut self, lquality: i32) -> ::windows::core::Result<()>;
    fn SetInterlaceMode(&mut self, lmode: i32) -> ::windows::core::Result<()>;
    fn SetClipRegion(&mut self, lcliporixsrc: i32, lcliporiysrc: i32, lclipwidthsrc: i32, lclipheightsrc: i32) -> ::windows::core::Result<()>;
    fn SetFullCropRegion(&mut self, lcliporixsrc: i32, lcliporiysrc: i32, lclipwidthsrc: i32, lclipheightsrc: i32, lcliporixdst: i32, lcliporiydst: i32, lclipwidthdst: i32, lclipheightdst: i32) -> ::windows::core::Result<()>;
    fn GetFullCropRegion(&mut self, lcliporixsrc: *mut i32, lcliporiysrc: *mut i32, lclipwidthsrc: *mut i32, lclipheightsrc: *mut i32, lcliporixdst: *mut i32, lcliporiydst: *mut i32, lclipwidthdst: *mut i32, lclipheightdst: *mut i32) -> ::windows::core::Result<()>;
}
impl IWMResizerProps_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWMResizerProps_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWMResizerProps_Vtbl {
        unsafe extern "system" fn SetResizerQuality<Impl: IWMResizerProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lquality: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetResizerQuality(::core::mem::transmute_copy(&lquality)).into()
        }
        unsafe extern "system" fn SetInterlaceMode<Impl: IWMResizerProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lmode: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetInterlaceMode(::core::mem::transmute_copy(&lmode)).into()
        }
        unsafe extern "system" fn SetClipRegion<Impl: IWMResizerProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lcliporixsrc: i32, lcliporiysrc: i32, lclipwidthsrc: i32, lclipheightsrc: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetClipRegion(::core::mem::transmute_copy(&lcliporixsrc), ::core::mem::transmute_copy(&lcliporiysrc), ::core::mem::transmute_copy(&lclipwidthsrc), ::core::mem::transmute_copy(&lclipheightsrc)).into()
        }
        unsafe extern "system" fn SetFullCropRegion<Impl: IWMResizerProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lcliporixsrc: i32, lcliporiysrc: i32, lclipwidthsrc: i32, lclipheightsrc: i32, lcliporixdst: i32, lcliporiydst: i32, lclipwidthdst: i32, lclipheightdst: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetFullCropRegion(::core::mem::transmute_copy(&lcliporixsrc), ::core::mem::transmute_copy(&lcliporiysrc), ::core::mem::transmute_copy(&lclipwidthsrc), ::core::mem::transmute_copy(&lclipheightsrc), ::core::mem::transmute_copy(&lcliporixdst), ::core::mem::transmute_copy(&lcliporiydst), ::core::mem::transmute_copy(&lclipwidthdst), ::core::mem::transmute_copy(&lclipheightdst)).into()
        }
        unsafe extern "system" fn GetFullCropRegion<Impl: IWMResizerProps_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lcliporixsrc: *mut i32, lcliporiysrc: *mut i32, lclipwidthsrc: *mut i32, lclipheightsrc: *mut i32, lcliporixdst: *mut i32, lcliporiydst: *mut i32, lclipwidthdst: *mut i32, lclipheightdst: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetFullCropRegion(::core::mem::transmute_copy(&lcliporixsrc), ::core::mem::transmute_copy(&lcliporiysrc), ::core::mem::transmute_copy(&lclipwidthsrc), ::core::mem::transmute_copy(&lclipheightsrc), ::core::mem::transmute_copy(&lcliporixdst), ::core::mem::transmute_copy(&lcliporiydst), ::core::mem::transmute_copy(&lclipwidthdst), ::core::mem::transmute_copy(&lclipheightdst)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetResizerQuality: SetResizerQuality::<Impl, IMPL_OFFSET>,
            SetInterlaceMode: SetInterlaceMode::<Impl, IMPL_OFFSET>,
            SetClipRegion: SetClipRegion::<Impl, IMPL_OFFSET>,
            SetFullCropRegion: SetFullCropRegion::<Impl, IMPL_OFFSET>,
            GetFullCropRegion: GetFullCropRegion::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWMResizerProps as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Foundation")]
pub trait IWMSampleExtensionSupport_Impl: Sized {
    fn SetUseSampleExtensions(&mut self, fuseextensions: super::super::Foundation::BOOL) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Foundation")]
impl IWMSampleExtensionSupport_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWMSampleExtensionSupport_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWMSampleExtensionSupport_Vtbl {
        unsafe extern "system" fn SetUseSampleExtensions<Impl: IWMSampleExtensionSupport_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, fuseextensions: super::super::Foundation::BOOL) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetUseSampleExtensions(::core::mem::transmute_copy(&fuseextensions)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), SetUseSampleExtensions: SetUseSampleExtensions::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWMSampleExtensionSupport as ::windows::core::Interface>::IID
    }
}
pub trait IWMValidate_Impl: Sized {
    fn SetIdentifier(&mut self, guidvalidationid: ::windows::core::GUID) -> ::windows::core::Result<()>;
}
impl IWMValidate_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWMValidate_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWMValidate_Vtbl {
        unsafe extern "system" fn SetIdentifier<Impl: IWMValidate_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, guidvalidationid: ::windows::core::GUID) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetIdentifier(::core::mem::transmute_copy(&guidvalidationid)).into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), SetIdentifier: SetIdentifier::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWMValidate as ::windows::core::Interface>::IID
    }
}
pub trait IWMVideoDecoderHurryup_Impl: Sized {
    fn SetHurryup(&mut self, lhurryup: i32) -> ::windows::core::Result<()>;
    fn GetHurryup(&mut self, plhurryup: *mut i32) -> ::windows::core::Result<()>;
}
impl IWMVideoDecoderHurryup_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWMVideoDecoderHurryup_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWMVideoDecoderHurryup_Vtbl {
        unsafe extern "system" fn SetHurryup<Impl: IWMVideoDecoderHurryup_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, lhurryup: i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetHurryup(::core::mem::transmute_copy(&lhurryup)).into()
        }
        unsafe extern "system" fn GetHurryup<Impl: IWMVideoDecoderHurryup_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, plhurryup: *mut i32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetHurryup(::core::mem::transmute_copy(&plhurryup)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            SetHurryup: SetHurryup::<Impl, IMPL_OFFSET>,
            GetHurryup: GetHurryup::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWMVideoDecoderHurryup as ::windows::core::Interface>::IID
    }
}
#[cfg(feature = "Win32_Media_DxMediaObjects")]
pub trait IWMVideoDecoderReconBuffer_Impl: Sized {
    fn GetReconstructedVideoFrameSize(&mut self, pdwsize: *mut u32) -> ::windows::core::Result<()>;
    fn GetReconstructedVideoFrame(&mut self, pbuf: ::core::option::Option<super::DxMediaObjects::IMediaBuffer>) -> ::windows::core::Result<()>;
    fn SetReconstructedVideoFrame(&mut self, pbuf: ::core::option::Option<super::DxMediaObjects::IMediaBuffer>) -> ::windows::core::Result<()>;
}
#[cfg(feature = "Win32_Media_DxMediaObjects")]
impl IWMVideoDecoderReconBuffer_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWMVideoDecoderReconBuffer_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWMVideoDecoderReconBuffer_Vtbl {
        unsafe extern "system" fn GetReconstructedVideoFrameSize<Impl: IWMVideoDecoderReconBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pdwsize: *mut u32) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetReconstructedVideoFrameSize(::core::mem::transmute_copy(&pdwsize)).into()
        }
        unsafe extern "system" fn GetReconstructedVideoFrame<Impl: IWMVideoDecoderReconBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbuf: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).GetReconstructedVideoFrame(::core::mem::transmute(&pbuf)).into()
        }
        unsafe extern "system" fn SetReconstructedVideoFrame<Impl: IWMVideoDecoderReconBuffer_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void, pbuf: ::windows::core::RawPtr) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetReconstructedVideoFrame(::core::mem::transmute(&pbuf)).into()
        }
        Self {
            base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(),
            GetReconstructedVideoFrameSize: GetReconstructedVideoFrameSize::<Impl, IMPL_OFFSET>,
            GetReconstructedVideoFrame: GetReconstructedVideoFrame::<Impl, IMPL_OFFSET>,
            SetReconstructedVideoFrame: SetReconstructedVideoFrame::<Impl, IMPL_OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWMVideoDecoderReconBuffer as ::windows::core::Interface>::IID
    }
}
pub trait IWMVideoForceKeyFrame_Impl: Sized {
    fn SetKeyFrame(&mut self) -> ::windows::core::Result<()>;
}
impl IWMVideoForceKeyFrame_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: IWMVideoForceKeyFrame_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> IWMVideoForceKeyFrame_Vtbl {
        unsafe extern "system" fn SetKeyFrame<Impl: IWMVideoForceKeyFrame_Impl, const OFFSET: isize>(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT {
            let this = (this as *mut ::windows::core::RawPtr).offset(OFFSET) as *mut Impl;
            (*this).SetKeyFrame().into()
        }
        Self { base: ::windows::core::IUnknownVtbl::new::<Identity, BASE_OFFSET>(), SetKeyFrame: SetKeyFrame::<Impl, IMPL_OFFSET> }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<IWMVideoForceKeyFrame as ::windows::core::Interface>::IID
    }
}
pub trait MFASYNCRESULT_Impl: Sized + IMFAsyncResult_Impl {}
impl MFASYNCRESULT_Vtbl {
    pub const fn new<Identity: ::windows::core::IUnknownImpl, Impl: MFASYNCRESULT_Impl, const BASE_OFFSET: isize, const IMPL_OFFSET: isize>() -> MFASYNCRESULT_Vtbl {
        Self { base: IMFAsyncResult_Vtbl::new::<Identity, Impl, BASE_OFFSET, IMPL_OFFSET>() }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<MFASYNCRESULT as ::windows::core::Interface>::IID
    }
}
