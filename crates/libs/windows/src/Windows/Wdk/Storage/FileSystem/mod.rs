#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn AcceptSecurityContext(phcredential: ::core::option::Option<*const SecHandle>, phcontext: ::core::option::Option<*const SecHandle>, pinput: ::core::option::Option<*const SecBufferDesc>, fcontextreq: u32, targetdatarep: u32, phnewcontext: ::core::option::Option<*mut SecHandle>, poutput: ::core::option::Option<*mut SecBufferDesc>, pfcontextattr: *mut u32, ptsexpiry: ::core::option::Option<*mut i64>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn AcceptSecurityContext(phcredential : *const SecHandle, phcontext : *const SecHandle, pinput : *const SecBufferDesc, fcontextreq : u32, targetdatarep : u32, phnewcontext : *mut SecHandle, poutput : *mut SecBufferDesc, pfcontextattr : *mut u32, ptsexpiry : *mut i64) -> ::windows_core::HRESULT);
    AcceptSecurityContext(::core::mem::transmute(phcredential.unwrap_or(::std::ptr::null())), ::core::mem::transmute(phcontext.unwrap_or(::std::ptr::null())), ::core::mem::transmute(pinput.unwrap_or(::std::ptr::null())), fcontextreq, targetdatarep, ::core::mem::transmute(phnewcontext.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(poutput.unwrap_or(::std::ptr::null_mut())), pfcontextattr, ::core::mem::transmute(ptsexpiry.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn AcquireCredentialsHandleW(pprincipal: ::core::option::Option<*const super::super::super::Win32::Foundation::UNICODE_STRING>, ppackage: *const super::super::super::Win32::Foundation::UNICODE_STRING, fcredentialuse: u32, pvlogonid: ::core::option::Option<*const ::core::ffi::c_void>, pauthdata: ::core::option::Option<*const ::core::ffi::c_void>, pgetkeyfn: SEC_GET_KEY_FN, pvgetkeyargument: ::core::option::Option<*const ::core::ffi::c_void>, phcredential: *mut SecHandle, ptsexpiry: ::core::option::Option<*mut i64>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn AcquireCredentialsHandleW(pprincipal : *const super::super::super::Win32::Foundation:: UNICODE_STRING, ppackage : *const super::super::super::Win32::Foundation:: UNICODE_STRING, fcredentialuse : u32, pvlogonid : *const ::core::ffi::c_void, pauthdata : *const ::core::ffi::c_void, pgetkeyfn : SEC_GET_KEY_FN, pvgetkeyargument : *const ::core::ffi::c_void, phcredential : *mut SecHandle, ptsexpiry : *mut i64) -> ::windows_core::HRESULT);
    AcquireCredentialsHandleW(::core::mem::transmute(pprincipal.unwrap_or(::std::ptr::null())), ppackage, fcredentialuse, ::core::mem::transmute(pvlogonid.unwrap_or(::std::ptr::null())), ::core::mem::transmute(pauthdata.unwrap_or(::std::ptr::null())), pgetkeyfn, ::core::mem::transmute(pvgetkeyargument.unwrap_or(::std::ptr::null())), phcredential, ::core::mem::transmute(ptsexpiry.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn AddCredentialsA<P0, P1>(hcredentials: *const SecHandle, pszprincipal: P0, pszpackage: P1, fcredentialuse: u32, pauthdata: ::core::option::Option<*const ::core::ffi::c_void>, pgetkeyfn: SEC_GET_KEY_FN, pvgetkeyargument: ::core::option::Option<*const ::core::ffi::c_void>, ptsexpiry: ::core::option::Option<*mut i64>) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<::windows_core::PCSTR>,
    P1: ::windows_core::IntoParam<::windows_core::PCSTR>,
{
    ::windows_targets::link!("secur32.dll" "system" fn AddCredentialsA(hcredentials : *const SecHandle, pszprincipal : ::windows_core::PCSTR, pszpackage : ::windows_core::PCSTR, fcredentialuse : u32, pauthdata : *const ::core::ffi::c_void, pgetkeyfn : SEC_GET_KEY_FN, pvgetkeyargument : *const ::core::ffi::c_void, ptsexpiry : *mut i64) -> ::windows_core::HRESULT);
    AddCredentialsA(hcredentials, pszprincipal.into_param().abi(), pszpackage.into_param().abi(), fcredentialuse, ::core::mem::transmute(pauthdata.unwrap_or(::std::ptr::null())), pgetkeyfn, ::core::mem::transmute(pvgetkeyargument.unwrap_or(::std::ptr::null())), ::core::mem::transmute(ptsexpiry.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn AddCredentialsW(hcredentials: *const SecHandle, pprincipal: ::core::option::Option<*const super::super::super::Win32::Foundation::UNICODE_STRING>, ppackage: *const super::super::super::Win32::Foundation::UNICODE_STRING, fcredentialuse: u32, pauthdata: ::core::option::Option<*const ::core::ffi::c_void>, pgetkeyfn: SEC_GET_KEY_FN, pvgetkeyargument: ::core::option::Option<*const ::core::ffi::c_void>, ptsexpiry: ::core::option::Option<*mut i64>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn AddCredentialsW(hcredentials : *const SecHandle, pprincipal : *const super::super::super::Win32::Foundation:: UNICODE_STRING, ppackage : *const super::super::super::Win32::Foundation:: UNICODE_STRING, fcredentialuse : u32, pauthdata : *const ::core::ffi::c_void, pgetkeyfn : SEC_GET_KEY_FN, pvgetkeyargument : *const ::core::ffi::c_void, ptsexpiry : *mut i64) -> ::windows_core::HRESULT);
    AddCredentialsW(hcredentials, ::core::mem::transmute(pprincipal.unwrap_or(::std::ptr::null())), ppackage, fcredentialuse, ::core::mem::transmute(pauthdata.unwrap_or(::std::ptr::null())), pgetkeyfn, ::core::mem::transmute(pvgetkeyargument.unwrap_or(::std::ptr::null())), ::core::mem::transmute(ptsexpiry.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn ApplyControlToken(phcontext: *const SecHandle, pinput: *const SecBufferDesc) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn ApplyControlToken(phcontext : *const SecHandle, pinput : *const SecBufferDesc) -> ::windows_core::HRESULT);
    ApplyControlToken(phcontext, pinput).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcAsyncCopyRead<P0>(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, length: u32, wait: P0, buffer: *mut ::core::ffi::c_void, iostatus: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, ioissuerthread: *const super::super::Foundation::KTHREAD, asyncreadcontext: *const CC_ASYNC_READ_CONTEXT) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcAsyncCopyRead(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, length : u32, wait : super::super::super::Win32::Foundation:: BOOLEAN, buffer : *mut ::core::ffi::c_void, iostatus : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, ioissuerthread : *const super::super::Foundation:: KTHREAD, asyncreadcontext : *const CC_ASYNC_READ_CONTEXT) -> super::super::super::Win32::Foundation:: BOOLEAN);
    CcAsyncCopyRead(fileobject, fileoffset, length, wait.into_param().abi(), buffer, iostatus, ioissuerthread, asyncreadcontext)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcCanIWrite<P0>(fileobject: ::core::option::Option<*const super::super::Foundation::FILE_OBJECT>, bytestowrite: u32, wait: P0, retrying: u8) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcCanIWrite(fileobject : *const super::super::Foundation:: FILE_OBJECT, bytestowrite : u32, wait : super::super::super::Win32::Foundation:: BOOLEAN, retrying : u8) -> super::super::super::Win32::Foundation:: BOOLEAN);
    CcCanIWrite(::core::mem::transmute(fileobject.unwrap_or(::std::ptr::null())), bytestowrite, wait.into_param().abi(), retrying)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcCoherencyFlushAndPurgeCache(sectionobjectpointer: *const super::super::Foundation::SECTION_OBJECT_POINTERS, fileoffset: ::core::option::Option<*const i64>, length: u32, iostatus: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, flags: u32) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcCoherencyFlushAndPurgeCache(sectionobjectpointer : *const super::super::Foundation:: SECTION_OBJECT_POINTERS, fileoffset : *const i64, length : u32, iostatus : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, flags : u32) -> ());
    CcCoherencyFlushAndPurgeCache(sectionobjectpointer, ::core::mem::transmute(fileoffset.unwrap_or(::std::ptr::null())), length, iostatus, flags)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcCopyRead<P0>(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, length: u32, wait: P0, buffer: *mut ::core::ffi::c_void, iostatus: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcCopyRead(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, length : u32, wait : super::super::super::Win32::Foundation:: BOOLEAN, buffer : *mut ::core::ffi::c_void, iostatus : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK) -> super::super::super::Win32::Foundation:: BOOLEAN);
    CcCopyRead(fileobject, fileoffset, length, wait.into_param().abi(), buffer, iostatus)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcCopyReadEx<P0>(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, length: u32, wait: P0, buffer: *mut ::core::ffi::c_void, iostatus: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, ioissuerthread: *const super::super::Foundation::KTHREAD) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcCopyReadEx(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, length : u32, wait : super::super::super::Win32::Foundation:: BOOLEAN, buffer : *mut ::core::ffi::c_void, iostatus : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, ioissuerthread : *const super::super::Foundation:: KTHREAD) -> super::super::super::Win32::Foundation:: BOOLEAN);
    CcCopyReadEx(fileobject, fileoffset, length, wait.into_param().abi(), buffer, iostatus, ioissuerthread)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcCopyWrite<P0>(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, length: u32, wait: P0, buffer: *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcCopyWrite(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, length : u32, wait : super::super::super::Win32::Foundation:: BOOLEAN, buffer : *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: BOOLEAN);
    CcCopyWrite(fileobject, fileoffset, length, wait.into_param().abi(), buffer)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcCopyWriteEx<P0>(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, length: u32, wait: P0, buffer: *const ::core::ffi::c_void, ioissuerthread: *const super::super::Foundation::KTHREAD) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcCopyWriteEx(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, length : u32, wait : super::super::super::Win32::Foundation:: BOOLEAN, buffer : *const ::core::ffi::c_void, ioissuerthread : *const super::super::Foundation:: KTHREAD) -> super::super::super::Win32::Foundation:: BOOLEAN);
    CcCopyWriteEx(fileobject, fileoffset, length, wait.into_param().abi(), buffer, ioissuerthread)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcCopyWriteWontFlush(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: ::core::option::Option<*const i64>, length: u32) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcCopyWriteWontFlush(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, length : u32) -> super::super::super::Win32::Foundation:: BOOLEAN);
    CcCopyWriteWontFlush(fileobject, ::core::mem::transmute(fileoffset.unwrap_or(::std::ptr::null())), length)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcDeferWrite<P0>(fileobject: *const super::super::Foundation::FILE_OBJECT, postroutine: PCC_POST_DEFERRED_WRITE, context1: *const ::core::ffi::c_void, context2: *const ::core::ffi::c_void, bytestowrite: u32, retrying: P0)
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcDeferWrite(fileobject : *const super::super::Foundation:: FILE_OBJECT, postroutine : PCC_POST_DEFERRED_WRITE, context1 : *const ::core::ffi::c_void, context2 : *const ::core::ffi::c_void, bytestowrite : u32, retrying : super::super::super::Win32::Foundation:: BOOLEAN) -> ());
    CcDeferWrite(fileobject, postroutine, context1, context2, bytestowrite, retrying.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn CcErrorCallbackRoutine(context: *const CC_ERROR_CALLBACK_CONTEXT) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcErrorCallbackRoutine(context : *const CC_ERROR_CALLBACK_CONTEXT) -> super::super::super::Win32::Foundation:: NTSTATUS);
    CcErrorCallbackRoutine(context).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcFastCopyRead(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: u32, length: u32, pagecount: u32, buffer: *mut ::core::ffi::c_void, iostatus: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcFastCopyRead(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : u32, length : u32, pagecount : u32, buffer : *mut ::core::ffi::c_void, iostatus : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK) -> ());
    CcFastCopyRead(fileobject, fileoffset, length, pagecount, buffer, iostatus)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcFastCopyWrite(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: u32, length: u32, buffer: *const ::core::ffi::c_void) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcFastCopyWrite(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : u32, length : u32, buffer : *const ::core::ffi::c_void) -> ());
    CcFastCopyWrite(fileobject, fileoffset, length, buffer)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcFlushCache(sectionobjectpointer: *const super::super::Foundation::SECTION_OBJECT_POINTERS, fileoffset: ::core::option::Option<*const i64>, length: u32, iostatus: ::core::option::Option<*mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK>) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcFlushCache(sectionobjectpointer : *const super::super::Foundation:: SECTION_OBJECT_POINTERS, fileoffset : *const i64, length : u32, iostatus : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK) -> ());
    CcFlushCache(sectionobjectpointer, ::core::mem::transmute(fileoffset.unwrap_or(::std::ptr::null())), length, ::core::mem::transmute(iostatus.unwrap_or(::std::ptr::null_mut())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcGetDirtyPages(loghandle: *const ::core::ffi::c_void, dirtypageroutine: PDIRTY_PAGE_ROUTINE, context1: *const ::core::ffi::c_void, context2: *const ::core::ffi::c_void) -> i64 {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcGetDirtyPages(loghandle : *const ::core::ffi::c_void, dirtypageroutine : PDIRTY_PAGE_ROUTINE, context1 : *const ::core::ffi::c_void, context2 : *const ::core::ffi::c_void) -> i64);
    CcGetDirtyPages(loghandle, dirtypageroutine, context1, context2)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcGetFileObjectFromBcb(bcb: *const ::core::ffi::c_void) -> *mut super::super::Foundation::FILE_OBJECT {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcGetFileObjectFromBcb(bcb : *const ::core::ffi::c_void) -> *mut super::super::Foundation:: FILE_OBJECT);
    CcGetFileObjectFromBcb(bcb)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcGetFileObjectFromSectionPtrs(sectionobjectpointer: *const super::super::Foundation::SECTION_OBJECT_POINTERS) -> *mut super::super::Foundation::FILE_OBJECT {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcGetFileObjectFromSectionPtrs(sectionobjectpointer : *const super::super::Foundation:: SECTION_OBJECT_POINTERS) -> *mut super::super::Foundation:: FILE_OBJECT);
    CcGetFileObjectFromSectionPtrs(sectionobjectpointer)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcGetFileObjectFromSectionPtrsRef(sectionobjectpointer: *const super::super::Foundation::SECTION_OBJECT_POINTERS) -> *mut super::super::Foundation::FILE_OBJECT {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcGetFileObjectFromSectionPtrsRef(sectionobjectpointer : *const super::super::Foundation:: SECTION_OBJECT_POINTERS) -> *mut super::super::Foundation:: FILE_OBJECT);
    CcGetFileObjectFromSectionPtrsRef(sectionobjectpointer)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn CcGetFlushedValidData<P0>(sectionobjectpointer: *const super::super::Foundation::SECTION_OBJECT_POINTERS, bcblistheld: P0) -> i64
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcGetFlushedValidData(sectionobjectpointer : *const super::super::Foundation:: SECTION_OBJECT_POINTERS, bcblistheld : super::super::super::Win32::Foundation:: BOOLEAN) -> i64);
    CcGetFlushedValidData(sectionobjectpointer, bcblistheld.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcInitializeCacheMap<P0>(fileobject: *const super::super::Foundation::FILE_OBJECT, filesizes: *const CC_FILE_SIZES, pinaccess: P0, callbacks: *const CACHE_MANAGER_CALLBACKS, lazywritecontext: *const ::core::ffi::c_void)
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcInitializeCacheMap(fileobject : *const super::super::Foundation:: FILE_OBJECT, filesizes : *const CC_FILE_SIZES, pinaccess : super::super::super::Win32::Foundation:: BOOLEAN, callbacks : *const CACHE_MANAGER_CALLBACKS, lazywritecontext : *const ::core::ffi::c_void) -> ());
    CcInitializeCacheMap(fileobject, filesizes, pinaccess.into_param().abi(), callbacks, lazywritecontext)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcInitializeCacheMapEx<P0>(fileobject: *const super::super::Foundation::FILE_OBJECT, filesizes: *const CC_FILE_SIZES, pinaccess: P0, callbacks: *const CACHE_MANAGER_CALLBACKS, lazywritecontext: *const ::core::ffi::c_void, flags: u32)
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcInitializeCacheMapEx(fileobject : *const super::super::Foundation:: FILE_OBJECT, filesizes : *const CC_FILE_SIZES, pinaccess : super::super::super::Win32::Foundation:: BOOLEAN, callbacks : *const CACHE_MANAGER_CALLBACKS, lazywritecontext : *const ::core::ffi::c_void, flags : u32) -> ());
    CcInitializeCacheMapEx(fileobject, filesizes, pinaccess.into_param().abi(), callbacks, lazywritecontext, flags)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn CcIsCacheManagerCallbackNeeded<P0>(status: P0) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::NTSTATUS>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcIsCacheManagerCallbackNeeded(status : super::super::super::Win32::Foundation:: NTSTATUS) -> super::super::super::Win32::Foundation:: BOOLEAN);
    CcIsCacheManagerCallbackNeeded(status.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcIsThereDirtyData(vpb: *const super::super::Foundation::VPB) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcIsThereDirtyData(vpb : *const super::super::Foundation:: VPB) -> super::super::super::Win32::Foundation:: BOOLEAN);
    CcIsThereDirtyData(vpb)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcIsThereDirtyDataEx(vpb: *const super::super::Foundation::VPB, numberofdirtypages: ::core::option::Option<*const u32>) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcIsThereDirtyDataEx(vpb : *const super::super::Foundation:: VPB, numberofdirtypages : *const u32) -> super::super::super::Win32::Foundation:: BOOLEAN);
    CcIsThereDirtyDataEx(vpb, ::core::mem::transmute(numberofdirtypages.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcMapData(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, length: u32, flags: u32, bcb: *mut *mut ::core::ffi::c_void, buffer: *mut *mut ::core::ffi::c_void) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcMapData(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, length : u32, flags : u32, bcb : *mut *mut ::core::ffi::c_void, buffer : *mut *mut ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: BOOLEAN);
    CcMapData(fileobject, fileoffset, length, flags, bcb, buffer)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcMdlRead(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, length: u32, mdlchain: *mut *mut super::super::super::Win32::Graphics::DirectDraw::MDL, iostatus: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcMdlRead(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, length : u32, mdlchain : *mut *mut super::super::super::Win32::Graphics::DirectDraw:: MDL, iostatus : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK) -> ());
    CcMdlRead(fileobject, fileoffset, length, mdlchain, iostatus)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcMdlReadComplete(fileobject: *const super::super::Foundation::FILE_OBJECT, mdlchain: *const super::super::super::Win32::Graphics::DirectDraw::MDL) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcMdlReadComplete(fileobject : *const super::super::Foundation:: FILE_OBJECT, mdlchain : *const super::super::super::Win32::Graphics::DirectDraw:: MDL) -> ());
    CcMdlReadComplete(fileobject, mdlchain)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcMdlWriteAbort(fileobject: *const super::super::Foundation::FILE_OBJECT, mdlchain: *const super::super::super::Win32::Graphics::DirectDraw::MDL) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcMdlWriteAbort(fileobject : *const super::super::Foundation:: FILE_OBJECT, mdlchain : *const super::super::super::Win32::Graphics::DirectDraw:: MDL) -> ());
    CcMdlWriteAbort(fileobject, mdlchain)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcMdlWriteComplete(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, mdlchain: *const super::super::super::Win32::Graphics::DirectDraw::MDL) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcMdlWriteComplete(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, mdlchain : *const super::super::super::Win32::Graphics::DirectDraw:: MDL) -> ());
    CcMdlWriteComplete(fileobject, fileoffset, mdlchain)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcPinMappedData(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, length: u32, flags: u32, bcb: *mut *mut ::core::ffi::c_void) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcPinMappedData(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, length : u32, flags : u32, bcb : *mut *mut ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: BOOLEAN);
    CcPinMappedData(fileobject, fileoffset, length, flags, bcb)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcPinRead(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, length: u32, flags: u32, bcb: *mut *mut ::core::ffi::c_void, buffer: *mut *mut ::core::ffi::c_void) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcPinRead(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, length : u32, flags : u32, bcb : *mut *mut ::core::ffi::c_void, buffer : *mut *mut ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: BOOLEAN);
    CcPinRead(fileobject, fileoffset, length, flags, bcb, buffer)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcPrepareMdlWrite(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, length: u32, mdlchain: *mut *mut super::super::super::Win32::Graphics::DirectDraw::MDL, iostatus: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcPrepareMdlWrite(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, length : u32, mdlchain : *mut *mut super::super::super::Win32::Graphics::DirectDraw:: MDL, iostatus : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK) -> ());
    CcPrepareMdlWrite(fileobject, fileoffset, length, mdlchain, iostatus)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcPreparePinWrite<P0>(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, length: u32, zero: P0, flags: u32, bcb: *mut *mut ::core::ffi::c_void, buffer: *mut *mut ::core::ffi::c_void) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcPreparePinWrite(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, length : u32, zero : super::super::super::Win32::Foundation:: BOOLEAN, flags : u32, bcb : *mut *mut ::core::ffi::c_void, buffer : *mut *mut ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: BOOLEAN);
    CcPreparePinWrite(fileobject, fileoffset, length, zero.into_param().abi(), flags, bcb, buffer)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn CcPurgeCacheSection(sectionobjectpointer: *const super::super::Foundation::SECTION_OBJECT_POINTERS, fileoffset: ::core::option::Option<*const i64>, length: u32, flags: u32) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcPurgeCacheSection(sectionobjectpointer : *const super::super::Foundation:: SECTION_OBJECT_POINTERS, fileoffset : *const i64, length : u32, flags : u32) -> super::super::super::Win32::Foundation:: BOOLEAN);
    CcPurgeCacheSection(sectionobjectpointer, ::core::mem::transmute(fileoffset.unwrap_or(::std::ptr::null())), length, flags)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn CcRemapBcb(bcb: *const ::core::ffi::c_void) -> *mut ::core::ffi::c_void {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcRemapBcb(bcb : *const ::core::ffi::c_void) -> *mut ::core::ffi::c_void);
    CcRemapBcb(bcb)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn CcRepinBcb(bcb: *const ::core::ffi::c_void) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcRepinBcb(bcb : *const ::core::ffi::c_void) -> ());
    CcRepinBcb(bcb)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcScheduleReadAhead(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, length: u32) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcScheduleReadAhead(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, length : u32) -> ());
    CcScheduleReadAhead(fileobject, fileoffset, length)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcScheduleReadAheadEx(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, length: u32, ioissuerthread: *const super::super::Foundation::KTHREAD) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcScheduleReadAheadEx(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, length : u32, ioissuerthread : *const super::super::Foundation:: KTHREAD) -> ());
    CcScheduleReadAheadEx(fileobject, fileoffset, length, ioissuerthread)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcSetAdditionalCacheAttributes<P0, P1>(fileobject: *const super::super::Foundation::FILE_OBJECT, disablereadahead: P0, disablewritebehind: P1)
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcSetAdditionalCacheAttributes(fileobject : *const super::super::Foundation:: FILE_OBJECT, disablereadahead : super::super::super::Win32::Foundation:: BOOLEAN, disablewritebehind : super::super::super::Win32::Foundation:: BOOLEAN) -> ());
    CcSetAdditionalCacheAttributes(fileobject, disablereadahead.into_param().abi(), disablewritebehind.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcSetAdditionalCacheAttributesEx(fileobject: *const super::super::Foundation::FILE_OBJECT, flags: u32) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcSetAdditionalCacheAttributesEx(fileobject : *const super::super::Foundation:: FILE_OBJECT, flags : u32) -> ());
    CcSetAdditionalCacheAttributesEx(fileobject, flags)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn CcSetBcbOwnerPointer(bcb: *const ::core::ffi::c_void, ownerpointer: *const ::core::ffi::c_void) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcSetBcbOwnerPointer(bcb : *const ::core::ffi::c_void, ownerpointer : *const ::core::ffi::c_void) -> ());
    CcSetBcbOwnerPointer(bcb, ownerpointer)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcSetDirtyPageThreshold(fileobject: *const super::super::Foundation::FILE_OBJECT, dirtypagethreshold: u32) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcSetDirtyPageThreshold(fileobject : *const super::super::Foundation:: FILE_OBJECT, dirtypagethreshold : u32) -> ());
    CcSetDirtyPageThreshold(fileobject, dirtypagethreshold)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn CcSetDirtyPinnedData(bcbvoid: *const ::core::ffi::c_void, lsn: ::core::option::Option<*const i64>) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcSetDirtyPinnedData(bcbvoid : *const ::core::ffi::c_void, lsn : *const i64) -> ());
    CcSetDirtyPinnedData(bcbvoid, ::core::mem::transmute(lsn.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcSetFileSizes(fileobject: *const super::super::Foundation::FILE_OBJECT, filesizes: *const CC_FILE_SIZES) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcSetFileSizes(fileobject : *const super::super::Foundation:: FILE_OBJECT, filesizes : *const CC_FILE_SIZES) -> ());
    CcSetFileSizes(fileobject, filesizes)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcSetFileSizesEx(fileobject: *const super::super::Foundation::FILE_OBJECT, filesizes: *const CC_FILE_SIZES) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcSetFileSizesEx(fileobject : *const super::super::Foundation:: FILE_OBJECT, filesizes : *const CC_FILE_SIZES) -> super::super::super::Win32::Foundation:: NTSTATUS);
    CcSetFileSizesEx(fileobject, filesizes).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcSetLogHandleForFile(fileobject: *const super::super::Foundation::FILE_OBJECT, loghandle: *const ::core::ffi::c_void, flushtolsnroutine: PFLUSH_TO_LSN) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcSetLogHandleForFile(fileobject : *const super::super::Foundation:: FILE_OBJECT, loghandle : *const ::core::ffi::c_void, flushtolsnroutine : PFLUSH_TO_LSN) -> ());
    CcSetLogHandleForFile(fileobject, loghandle, flushtolsnroutine)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcSetParallelFlushFile<P0>(fileobject: *const super::super::Foundation::FILE_OBJECT, enableparallelflush: P0)
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcSetParallelFlushFile(fileobject : *const super::super::Foundation:: FILE_OBJECT, enableparallelflush : super::super::super::Win32::Foundation:: BOOLEAN) -> ());
    CcSetParallelFlushFile(fileobject, enableparallelflush.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcSetReadAheadGranularity(fileobject: *const super::super::Foundation::FILE_OBJECT, granularity: u32) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcSetReadAheadGranularity(fileobject : *const super::super::Foundation:: FILE_OBJECT, granularity : u32) -> ());
    CcSetReadAheadGranularity(fileobject, granularity)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcUninitializeCacheMap(fileobject: *const super::super::Foundation::FILE_OBJECT, truncatesize: ::core::option::Option<*const i64>, uninitializeevent: ::core::option::Option<*const CACHE_UNINITIALIZE_EVENT>) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcUninitializeCacheMap(fileobject : *const super::super::Foundation:: FILE_OBJECT, truncatesize : *const i64, uninitializeevent : *const CACHE_UNINITIALIZE_EVENT) -> super::super::super::Win32::Foundation:: BOOLEAN);
    CcUninitializeCacheMap(fileobject, ::core::mem::transmute(truncatesize.unwrap_or(::std::ptr::null())), ::core::mem::transmute(uninitializeevent.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn CcUnpinData(bcb: *const ::core::ffi::c_void) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcUnpinData(bcb : *const ::core::ffi::c_void) -> ());
    CcUnpinData(bcb)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn CcUnpinDataForThread(bcb: *const ::core::ffi::c_void, resourcethreadid: usize) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcUnpinDataForThread(bcb : *const ::core::ffi::c_void, resourcethreadid : usize) -> ());
    CcUnpinDataForThread(bcb, resourcethreadid)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcUnpinRepinnedBcb<P0>(bcb: *const ::core::ffi::c_void, writethrough: P0) -> super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcUnpinRepinnedBcb(bcb : *const ::core::ffi::c_void, writethrough : super::super::super::Win32::Foundation:: BOOLEAN, iostatus : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK) -> ());
    let mut result__ = ::std::mem::zeroed();
    CcUnpinRepinnedBcb(bcb, writethrough.into_param().abi(), &mut result__);
    ::std::mem::transmute(result__)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn CcWaitForCurrentLazyWriterActivity() -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcWaitForCurrentLazyWriterActivity() -> super::super::super::Win32::Foundation:: NTSTATUS);
    CcWaitForCurrentLazyWriterActivity().ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn CcZeroData<P0>(fileobject: *const super::super::Foundation::FILE_OBJECT, startoffset: *const i64, endoffset: *const i64, wait: P0) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn CcZeroData(fileobject : *const super::super::Foundation:: FILE_OBJECT, startoffset : *const i64, endoffset : *const i64, wait : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: BOOLEAN);
    CcZeroData(fileobject, startoffset, endoffset, wait.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn CompleteAuthToken(phcontext: *const SecHandle, ptoken: *const SecBufferDesc) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn CompleteAuthToken(phcontext : *const SecHandle, ptoken : *const SecBufferDesc) -> ::windows_core::HRESULT);
    CompleteAuthToken(phcontext, ptoken).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn DecryptMessage(phcontext: *const SecHandle, pmessage: *const SecBufferDesc, messageseqno: u32, pfqop: ::core::option::Option<*mut u32>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn DecryptMessage(phcontext : *const SecHandle, pmessage : *const SecBufferDesc, messageseqno : u32, pfqop : *mut u32) -> ::windows_core::HRESULT);
    DecryptMessage(phcontext, pmessage, messageseqno, ::core::mem::transmute(pfqop.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn DeleteSecurityContext(phcontext: *const SecHandle) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn DeleteSecurityContext(phcontext : *const SecHandle) -> ::windows_core::HRESULT);
    DeleteSecurityContext(phcontext).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn EncryptMessage(phcontext: *const SecHandle, fqop: u32, pmessage: *const SecBufferDesc, messageseqno: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn EncryptMessage(phcontext : *const SecHandle, fqop : u32, pmessage : *const SecBufferDesc, messageseqno : u32) -> ::windows_core::HRESULT);
    EncryptMessage(phcontext, fqop, pmessage, messageseqno).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn EnumerateSecurityPackagesW(pcpackages: *mut u32, pppackageinfo: *mut *mut SecPkgInfoW) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn EnumerateSecurityPackagesW(pcpackages : *mut u32, pppackageinfo : *mut *mut SecPkgInfoW) -> ::windows_core::HRESULT);
    EnumerateSecurityPackagesW(pcpackages, pppackageinfo).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn ExDisableResourceBoostLite(resource: *const super::super::Foundation::ERESOURCE) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn ExDisableResourceBoostLite(resource : *const super::super::Foundation:: ERESOURCE) -> ());
    ExDisableResourceBoostLite(resource)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn ExQueryPoolBlockSize(poolblock: *const ::core::ffi::c_void, quotacharged: *mut super::super::super::Win32::Foundation::BOOLEAN) -> usize {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn ExQueryPoolBlockSize(poolblock : *const ::core::ffi::c_void, quotacharged : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> usize);
    ExQueryPoolBlockSize(poolblock, quotacharged)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn ExportSecurityContext(phcontext: *const SecHandle, fflags: u32, ppackedcontext: *mut SecBuffer, ptoken: *mut *mut ::core::ffi::c_void) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn ExportSecurityContext(phcontext : *const SecHandle, fflags : u32, ppackedcontext : *mut SecBuffer, ptoken : *mut *mut ::core::ffi::c_void) -> ::windows_core::HRESULT);
    ExportSecurityContext(phcontext, fflags, ppackedcontext, ptoken).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FreeContextBuffer(pvcontextbuffer: *mut ::core::ffi::c_void) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn FreeContextBuffer(pvcontextbuffer : *mut ::core::ffi::c_void) -> ::windows_core::HRESULT);
    FreeContextBuffer(pvcontextbuffer).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FreeCredentialsHandle(phcredential: *const SecHandle) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn FreeCredentialsHandle(phcredential : *const SecHandle) -> ::windows_core::HRESULT);
    FreeCredentialsHandle(phcredential).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlAcknowledgeEcp(ecpcontext: *const ::core::ffi::c_void) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlAcknowledgeEcp(ecpcontext : *const ::core::ffi::c_void) -> ());
    FsRtlAcknowledgeEcp(ecpcontext)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlAcquireFileExclusive(fileobject: *const super::super::Foundation::FILE_OBJECT) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlAcquireFileExclusive(fileobject : *const super::super::Foundation:: FILE_OBJECT) -> ());
    FsRtlAcquireFileExclusive(fileobject)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlAddBaseMcbEntry(mcb: *mut BASE_MCB, vbn: i64, lbn: i64, sectorcount: i64) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlAddBaseMcbEntry(mcb : *mut BASE_MCB, vbn : i64, lbn : i64, sectorcount : i64) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlAddBaseMcbEntry(mcb, vbn, lbn, sectorcount)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlAddBaseMcbEntryEx(mcb: *mut BASE_MCB, vbn: i64, lbn: i64, sectorcount: i64) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlAddBaseMcbEntryEx(mcb : *mut BASE_MCB, vbn : i64, lbn : i64, sectorcount : i64) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlAddBaseMcbEntryEx(mcb, vbn, lbn, sectorcount).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlAddLargeMcbEntry(mcb: *mut LARGE_MCB, vbn: i64, lbn: i64, sectorcount: i64) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlAddLargeMcbEntry(mcb : *mut LARGE_MCB, vbn : i64, lbn : i64, sectorcount : i64) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlAddLargeMcbEntry(mcb, vbn, lbn, sectorcount)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlAddMcbEntry(mcb: *mut MCB, vbn: u32, lbn: u32, sectorcount: u32) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlAddMcbEntry(mcb : *mut MCB, vbn : u32, lbn : u32, sectorcount : u32) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlAddMcbEntry(mcb, vbn, lbn, sectorcount)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlAddToTunnelCache<P0>(cache: *mut TUNNEL, directorykey: u64, shortname: *const super::super::super::Win32::Foundation::UNICODE_STRING, longname: *const super::super::super::Win32::Foundation::UNICODE_STRING, keybyshortname: P0, datalength: u32, data: *const ::core::ffi::c_void)
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlAddToTunnelCache(cache : *mut TUNNEL, directorykey : u64, shortname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, longname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, keybyshortname : super::super::super::Win32::Foundation:: BOOLEAN, datalength : u32, data : *const ::core::ffi::c_void) -> ());
    FsRtlAddToTunnelCache(cache, directorykey, shortname, longname, keybyshortname.into_param().abi(), datalength, data)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlAddToTunnelCacheEx(cache: *mut TUNNEL, directorykey: u64, shortname: *const super::super::super::Win32::Foundation::UNICODE_STRING, longname: *const super::super::super::Win32::Foundation::UNICODE_STRING, flags: u32, datalength: u32, data: *const ::core::ffi::c_void) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlAddToTunnelCacheEx(cache : *mut TUNNEL, directorykey : u64, shortname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, longname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, flags : u32, datalength : u32, data : *const ::core::ffi::c_void) -> ());
    FsRtlAddToTunnelCacheEx(cache, directorykey, shortname, longname, flags, datalength, data)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`*"]
#[cfg(feature = "Wdk_Foundation")]
#[inline]
pub unsafe fn FsRtlAllocateAePushLock(pooltype: super::super::Foundation::POOL_TYPE, tag: u32) -> *mut ::core::ffi::c_void {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlAllocateAePushLock(pooltype : super::super::Foundation:: POOL_TYPE, tag : u32) -> *mut ::core::ffi::c_void);
    FsRtlAllocateAePushLock(pooltype, tag)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlAllocateExtraCreateParameter(ecptype: *const ::windows_core::GUID, sizeofcontext: u32, flags: u32, cleanupcallback: PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK, pooltag: u32, ecpcontext: *mut *mut ::core::ffi::c_void) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlAllocateExtraCreateParameter(ecptype : *const ::windows_core::GUID, sizeofcontext : u32, flags : u32, cleanupcallback : PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK, pooltag : u32, ecpcontext : *mut *mut ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlAllocateExtraCreateParameter(ecptype, sizeofcontext, flags, cleanupcallback, pooltag, ecpcontext).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlAllocateExtraCreateParameterFromLookasideList(ecptype: *const ::windows_core::GUID, sizeofcontext: u32, flags: u32, cleanupcallback: PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK, lookasidelist: *mut ::core::ffi::c_void, ecpcontext: *mut *mut ::core::ffi::c_void) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlAllocateExtraCreateParameterFromLookasideList(ecptype : *const ::windows_core::GUID, sizeofcontext : u32, flags : u32, cleanupcallback : PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK, lookasidelist : *mut ::core::ffi::c_void, ecpcontext : *mut *mut ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlAllocateExtraCreateParameterFromLookasideList(ecptype, sizeofcontext, flags, cleanupcallback, lookasidelist, ecpcontext).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn FsRtlAllocateExtraCreateParameterList(flags: u32, ecplist: *mut *mut super::super::Foundation::ECP_LIST) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlAllocateExtraCreateParameterList(flags : u32, ecplist : *mut *mut super::super::Foundation:: ECP_LIST) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlAllocateExtraCreateParameterList(flags, ecplist).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlAllocateFileLock(completelockirproutine: PCOMPLETE_LOCK_IRP_ROUTINE, unlockroutine: PUNLOCK_ROUTINE) -> *mut FILE_LOCK {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlAllocateFileLock(completelockirproutine : PCOMPLETE_LOCK_IRP_ROUTINE, unlockroutine : PUNLOCK_ROUTINE) -> *mut FILE_LOCK);
    FsRtlAllocateFileLock(completelockirproutine, unlockroutine)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlAllocateResource() -> *mut super::super::Foundation::ERESOURCE {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlAllocateResource() -> *mut super::super::Foundation:: ERESOURCE);
    FsRtlAllocateResource()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlAreNamesEqual<P0>(constantnamea: *const super::super::super::Win32::Foundation::UNICODE_STRING, constantnameb: *const super::super::super::Win32::Foundation::UNICODE_STRING, ignorecase: P0, upcasetable: ::core::option::Option<*const u16>) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlAreNamesEqual(constantnamea : *const super::super::super::Win32::Foundation:: UNICODE_STRING, constantnameb : *const super::super::super::Win32::Foundation:: UNICODE_STRING, ignorecase : super::super::super::Win32::Foundation:: BOOLEAN, upcasetable : *const u16) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlAreNamesEqual(constantnamea, constantnameb, ignorecase.into_param().abi(), ::core::mem::transmute(upcasetable.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlAreThereCurrentOrInProgressFileLocks(filelock: *const FILE_LOCK) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlAreThereCurrentOrInProgressFileLocks(filelock : *const FILE_LOCK) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlAreThereCurrentOrInProgressFileLocks(filelock)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlAreThereWaitingFileLocks(filelock: *const FILE_LOCK) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlAreThereWaitingFileLocks(filelock : *const FILE_LOCK) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlAreThereWaitingFileLocks(filelock)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlAreVolumeStartupApplicationsComplete() -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlAreVolumeStartupApplicationsComplete() -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlAreVolumeStartupApplicationsComplete()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlBalanceReads(targetdevice: *const super::super::Foundation::DEVICE_OBJECT) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlBalanceReads(targetdevice : *const super::super::Foundation:: DEVICE_OBJECT) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlBalanceReads(targetdevice).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlCancellableWaitForMultipleObjects(objectarray: &[*const ::core::ffi::c_void], waittype: super::super::super::Win32::System::Kernel::WAIT_TYPE, timeout: ::core::option::Option<*const i64>, waitblockarray: ::core::option::Option<*const super::super::Foundation::KWAIT_BLOCK>, irp: ::core::option::Option<*const super::super::Foundation::IRP>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlCancellableWaitForMultipleObjects(count : u32, objectarray : *const *const ::core::ffi::c_void, waittype : super::super::super::Win32::System::Kernel:: WAIT_TYPE, timeout : *const i64, waitblockarray : *const super::super::Foundation:: KWAIT_BLOCK, irp : *const super::super::Foundation:: IRP) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlCancellableWaitForMultipleObjects(objectarray.len() as _, ::core::mem::transmute(objectarray.as_ptr()), waittype, ::core::mem::transmute(timeout.unwrap_or(::std::ptr::null())), ::core::mem::transmute(waitblockarray.unwrap_or(::std::ptr::null())), ::core::mem::transmute(irp.unwrap_or(::std::ptr::null()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlCancellableWaitForSingleObject(object: *const ::core::ffi::c_void, timeout: ::core::option::Option<*const i64>, irp: ::core::option::Option<*const super::super::Foundation::IRP>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlCancellableWaitForSingleObject(object : *const ::core::ffi::c_void, timeout : *const i64, irp : *const super::super::Foundation:: IRP) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlCancellableWaitForSingleObject(object, ::core::mem::transmute(timeout.unwrap_or(::std::ptr::null())), ::core::mem::transmute(irp.unwrap_or(::std::ptr::null()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlChangeBackingFileObject(currentfileobject: ::core::option::Option<*const super::super::Foundation::FILE_OBJECT>, newfileobject: *const super::super::Foundation::FILE_OBJECT, changebackingtype: FSRTL_CHANGE_BACKING_TYPE, flags: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlChangeBackingFileObject(currentfileobject : *const super::super::Foundation:: FILE_OBJECT, newfileobject : *const super::super::Foundation:: FILE_OBJECT, changebackingtype : FSRTL_CHANGE_BACKING_TYPE, flags : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlChangeBackingFileObject(::core::mem::transmute(currentfileobject.unwrap_or(::std::ptr::null())), newfileobject, changebackingtype, flags).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlCheckLockForOplockRequest(filelock: *const FILE_LOCK, allocationsize: *const i64) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlCheckLockForOplockRequest(filelock : *const FILE_LOCK, allocationsize : *const i64) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlCheckLockForOplockRequest(filelock, allocationsize)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlCheckLockForReadAccess(filelock: *const FILE_LOCK, irp: *const super::super::Foundation::IRP) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlCheckLockForReadAccess(filelock : *const FILE_LOCK, irp : *const super::super::Foundation:: IRP) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlCheckLockForReadAccess(filelock, irp)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlCheckLockForWriteAccess(filelock: *const FILE_LOCK, irp: *const super::super::Foundation::IRP) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlCheckLockForWriteAccess(filelock : *const FILE_LOCK, irp : *const super::super::Foundation:: IRP) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlCheckLockForWriteAccess(filelock, irp)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlCheckOplock(oplock: *const *const ::core::ffi::c_void, irp: *const super::super::Foundation::IRP, context: ::core::option::Option<*const ::core::ffi::c_void>, completionroutine: POPLOCK_WAIT_COMPLETE_ROUTINE, postirproutine: POPLOCK_FS_PREPOST_IRP) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlCheckOplock(oplock : *const *const ::core::ffi::c_void, irp : *const super::super::Foundation:: IRP, context : *const ::core::ffi::c_void, completionroutine : POPLOCK_WAIT_COMPLETE_ROUTINE, postirproutine : POPLOCK_FS_PREPOST_IRP) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlCheckOplock(oplock, irp, ::core::mem::transmute(context.unwrap_or(::std::ptr::null())), completionroutine, postirproutine).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlCheckOplockEx(oplock: *const *const ::core::ffi::c_void, irp: *const super::super::Foundation::IRP, flags: u32, context: ::core::option::Option<*const ::core::ffi::c_void>, completionroutine: POPLOCK_WAIT_COMPLETE_ROUTINE, postirproutine: POPLOCK_FS_PREPOST_IRP) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlCheckOplockEx(oplock : *const *const ::core::ffi::c_void, irp : *const super::super::Foundation:: IRP, flags : u32, context : *const ::core::ffi::c_void, completionroutine : POPLOCK_WAIT_COMPLETE_ROUTINE, postirproutine : POPLOCK_FS_PREPOST_IRP) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlCheckOplockEx(oplock, irp, flags, ::core::mem::transmute(context.unwrap_or(::std::ptr::null())), completionroutine, postirproutine).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlCheckOplockEx2(oplock: *const *const ::core::ffi::c_void, irp: *const super::super::Foundation::IRP, flags: u32, flagsex2: u32, completionroutinecontext: ::core::option::Option<*const ::core::ffi::c_void>, completionroutine: POPLOCK_WAIT_COMPLETE_ROUTINE, postirproutine: POPLOCK_FS_PREPOST_IRP, timeout: u64, notifycontext: ::core::option::Option<*const ::core::ffi::c_void>, notifyroutine: POPLOCK_NOTIFY_ROUTINE) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlCheckOplockEx2(oplock : *const *const ::core::ffi::c_void, irp : *const super::super::Foundation:: IRP, flags : u32, flagsex2 : u32, completionroutinecontext : *const ::core::ffi::c_void, completionroutine : POPLOCK_WAIT_COMPLETE_ROUTINE, postirproutine : POPLOCK_FS_PREPOST_IRP, timeout : u64, notifycontext : *const ::core::ffi::c_void, notifyroutine : POPLOCK_NOTIFY_ROUTINE) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlCheckOplockEx2(oplock, irp, flags, flagsex2, ::core::mem::transmute(completionroutinecontext.unwrap_or(::std::ptr::null())), completionroutine, postirproutine, timeout, ::core::mem::transmute(notifycontext.unwrap_or(::std::ptr::null())), notifyroutine).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlCheckUpperOplock(oplock: *const *const ::core::ffi::c_void, newloweroplockstate: u32, completionroutinecontext: ::core::option::Option<*const ::core::ffi::c_void>, completionroutine: POPLOCK_WAIT_COMPLETE_ROUTINE, prependroutine: POPLOCK_FS_PREPOST_IRP, flags: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlCheckUpperOplock(oplock : *const *const ::core::ffi::c_void, newloweroplockstate : u32, completionroutinecontext : *const ::core::ffi::c_void, completionroutine : POPLOCK_WAIT_COMPLETE_ROUTINE, prependroutine : POPLOCK_FS_PREPOST_IRP, flags : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlCheckUpperOplock(oplock, newloweroplockstate, ::core::mem::transmute(completionroutinecontext.unwrap_or(::std::ptr::null())), completionroutine, prependroutine, flags).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlCopyRead<P0>(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, length: u32, wait: P0, lockkey: u32, buffer: *mut ::core::ffi::c_void, iostatus: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, deviceobject: *const super::super::Foundation::DEVICE_OBJECT) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlCopyRead(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, length : u32, wait : super::super::super::Win32::Foundation:: BOOLEAN, lockkey : u32, buffer : *mut ::core::ffi::c_void, iostatus : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, deviceobject : *const super::super::Foundation:: DEVICE_OBJECT) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlCopyRead(fileobject, fileoffset, length, wait.into_param().abi(), lockkey, buffer, iostatus, deviceobject)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlCopyWrite<P0>(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, length: u32, wait: P0, lockkey: u32, buffer: *const ::core::ffi::c_void, iostatus: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, deviceobject: *const super::super::Foundation::DEVICE_OBJECT) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlCopyWrite(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, length : u32, wait : super::super::super::Win32::Foundation:: BOOLEAN, lockkey : u32, buffer : *const ::core::ffi::c_void, iostatus : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, deviceobject : *const super::super::Foundation:: DEVICE_OBJECT) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlCopyWrite(fileobject, fileoffset, length, wait.into_param().abi(), lockkey, buffer, iostatus, deviceobject)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlCreateSectionForDataScan(sectionhandle: *mut super::super::super::Win32::Foundation::HANDLE, sectionobject: *mut *mut ::core::ffi::c_void, sectionfilesize: ::core::option::Option<*mut i64>, fileobject: *const super::super::Foundation::FILE_OBJECT, desiredaccess: u32, objectattributes: ::core::option::Option<*const super::super::super::Win32::System::WindowsProgramming::OBJECT_ATTRIBUTES>, maximumsize: ::core::option::Option<*const i64>, sectionpageprotection: u32, allocationattributes: u32, flags: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlCreateSectionForDataScan(sectionhandle : *mut super::super::super::Win32::Foundation:: HANDLE, sectionobject : *mut *mut ::core::ffi::c_void, sectionfilesize : *mut i64, fileobject : *const super::super::Foundation:: FILE_OBJECT, desiredaccess : u32, objectattributes : *const super::super::super::Win32::System::WindowsProgramming:: OBJECT_ATTRIBUTES, maximumsize : *const i64, sectionpageprotection : u32, allocationattributes : u32, flags : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlCreateSectionForDataScan(sectionhandle, sectionobject, ::core::mem::transmute(sectionfilesize.unwrap_or(::std::ptr::null_mut())), fileobject, desiredaccess, ::core::mem::transmute(objectattributes.unwrap_or(::std::ptr::null())), ::core::mem::transmute(maximumsize.unwrap_or(::std::ptr::null())), sectionpageprotection, allocationattributes, flags).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlCurrentBatchOplock(oplock: *const *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlCurrentBatchOplock(oplock : *const *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlCurrentBatchOplock(oplock)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlCurrentOplock(oplock: *const *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlCurrentOplock(oplock : *const *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlCurrentOplock(oplock)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlCurrentOplockH(oplock: *const *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlCurrentOplockH(oplock : *const *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlCurrentOplockH(oplock)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlDeleteExtraCreateParameterLookasideList(lookaside: *mut ::core::ffi::c_void, flags: u32) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlDeleteExtraCreateParameterLookasideList(lookaside : *mut ::core::ffi::c_void, flags : u32) -> ());
    FsRtlDeleteExtraCreateParameterLookasideList(lookaside, flags)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlDeleteKeyFromTunnelCache(cache: *mut TUNNEL, directorykey: u64) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlDeleteKeyFromTunnelCache(cache : *mut TUNNEL, directorykey : u64) -> ());
    FsRtlDeleteKeyFromTunnelCache(cache, directorykey)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlDeleteTunnelCache(cache: *mut TUNNEL) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlDeleteTunnelCache(cache : *mut TUNNEL) -> ());
    FsRtlDeleteTunnelCache(cache)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlDeregisterUncProvider<P0>(handle: P0)
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlDeregisterUncProvider(handle : super::super::super::Win32::Foundation:: HANDLE) -> ());
    FsRtlDeregisterUncProvider(handle.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlDismountComplete<P0>(deviceobject: *const super::super::Foundation::DEVICE_OBJECT, dismountstatus: P0)
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::NTSTATUS>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlDismountComplete(deviceobject : *const super::super::Foundation:: DEVICE_OBJECT, dismountstatus : super::super::super::Win32::Foundation:: NTSTATUS) -> ());
    FsRtlDismountComplete(deviceobject, dismountstatus.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(feature = "Win32_System_Kernel")]
#[inline]
pub unsafe fn FsRtlDissectDbcs(path: super::super::super::Win32::System::Kernel::STRING, firstname: *mut super::super::super::Win32::System::Kernel::STRING, remainingname: *mut super::super::super::Win32::System::Kernel::STRING) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlDissectDbcs(path : super::super::super::Win32::System::Kernel:: STRING, firstname : *mut super::super::super::Win32::System::Kernel:: STRING, remainingname : *mut super::super::super::Win32::System::Kernel:: STRING) -> ());
    FsRtlDissectDbcs(::core::mem::transmute(path), firstname, remainingname)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlDissectName(path: super::super::super::Win32::Foundation::UNICODE_STRING, firstname: *mut super::super::super::Win32::Foundation::UNICODE_STRING, remainingname: *mut super::super::super::Win32::Foundation::UNICODE_STRING) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlDissectName(path : super::super::super::Win32::Foundation:: UNICODE_STRING, firstname : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, remainingname : *mut super::super::super::Win32::Foundation:: UNICODE_STRING) -> ());
    FsRtlDissectName(::core::mem::transmute(path), firstname, remainingname)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlDoesDbcsContainWildCards(name: *const super::super::super::Win32::System::Kernel::STRING) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlDoesDbcsContainWildCards(name : *const super::super::super::Win32::System::Kernel:: STRING) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlDoesDbcsContainWildCards(name)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlDoesNameContainWildCards(name: *const super::super::super::Win32::Foundation::UNICODE_STRING) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlDoesNameContainWildCards(name : *const super::super::super::Win32::Foundation:: UNICODE_STRING) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlDoesNameContainWildCards(name)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlFastCheckLockForRead(filelock: *const FILE_LOCK, startingbyte: *const i64, length: *const i64, key: u32, fileobject: *const super::super::Foundation::FILE_OBJECT, processid: *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlFastCheckLockForRead(filelock : *const FILE_LOCK, startingbyte : *const i64, length : *const i64, key : u32, fileobject : *const super::super::Foundation:: FILE_OBJECT, processid : *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlFastCheckLockForRead(filelock, startingbyte, length, key, fileobject, processid)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlFastCheckLockForWrite(filelock: *const FILE_LOCK, startingbyte: *const i64, length: *const i64, key: u32, fileobject: *const ::core::ffi::c_void, processid: *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlFastCheckLockForWrite(filelock : *const FILE_LOCK, startingbyte : *const i64, length : *const i64, key : u32, fileobject : *const ::core::ffi::c_void, processid : *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlFastCheckLockForWrite(filelock, startingbyte, length, key, fileobject, processid)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlFastUnlockAll(filelock: *const FILE_LOCK, fileobject: *const super::super::Foundation::FILE_OBJECT, processid: *const super::super::Foundation::KPROCESS, context: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlFastUnlockAll(filelock : *const FILE_LOCK, fileobject : *const super::super::Foundation:: FILE_OBJECT, processid : *const super::super::Foundation:: KPROCESS, context : *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlFastUnlockAll(filelock, fileobject, processid, ::core::mem::transmute(context.unwrap_or(::std::ptr::null()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlFastUnlockAllByKey(filelock: *const FILE_LOCK, fileobject: *const super::super::Foundation::FILE_OBJECT, processid: *const super::super::Foundation::KPROCESS, key: u32, context: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlFastUnlockAllByKey(filelock : *const FILE_LOCK, fileobject : *const super::super::Foundation:: FILE_OBJECT, processid : *const super::super::Foundation:: KPROCESS, key : u32, context : *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlFastUnlockAllByKey(filelock, fileobject, processid, key, ::core::mem::transmute(context.unwrap_or(::std::ptr::null()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlFastUnlockSingle<P0>(filelock: *const FILE_LOCK, fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, length: *const i64, processid: *const super::super::Foundation::KPROCESS, key: u32, context: ::core::option::Option<*const ::core::ffi::c_void>, alreadysynchronized: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlFastUnlockSingle(filelock : *const FILE_LOCK, fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, length : *const i64, processid : *const super::super::Foundation:: KPROCESS, key : u32, context : *const ::core::ffi::c_void, alreadysynchronized : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlFastUnlockSingle(filelock, fileobject, fileoffset, length, processid, key, ::core::mem::transmute(context.unwrap_or(::std::ptr::null())), alreadysynchronized.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn FsRtlFindExtraCreateParameter(ecplist: *const super::super::Foundation::ECP_LIST, ecptype: *const ::windows_core::GUID, ecpcontext: ::core::option::Option<*mut *mut ::core::ffi::c_void>, ecpcontextsize: ::core::option::Option<*mut u32>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlFindExtraCreateParameter(ecplist : *const super::super::Foundation:: ECP_LIST, ecptype : *const ::windows_core::GUID, ecpcontext : *mut *mut ::core::ffi::c_void, ecpcontextsize : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlFindExtraCreateParameter(ecplist, ecptype, ::core::mem::transmute(ecpcontext.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(ecpcontextsize.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlFindInTunnelCache(cache: *const TUNNEL, directorykey: u64, name: *const super::super::super::Win32::Foundation::UNICODE_STRING, shortname: *mut super::super::super::Win32::Foundation::UNICODE_STRING, longname: *mut super::super::super::Win32::Foundation::UNICODE_STRING, datalength: *mut u32, data: *mut ::core::ffi::c_void) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlFindInTunnelCache(cache : *const TUNNEL, directorykey : u64, name : *const super::super::super::Win32::Foundation:: UNICODE_STRING, shortname : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, longname : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, datalength : *mut u32, data : *mut ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlFindInTunnelCache(cache, directorykey, name, shortname, longname, datalength, data)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlFindInTunnelCacheEx(cache: *const TUNNEL, directorykey: u64, name: *const super::super::super::Win32::Foundation::UNICODE_STRING, shortname: *mut super::super::super::Win32::Foundation::UNICODE_STRING, longname: *mut super::super::super::Win32::Foundation::UNICODE_STRING, flags: u32, datalength: *mut u32, data: *mut ::core::ffi::c_void) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlFindInTunnelCacheEx(cache : *const TUNNEL, directorykey : u64, name : *const super::super::super::Win32::Foundation:: UNICODE_STRING, shortname : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, longname : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, flags : u32, datalength : *mut u32, data : *mut ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlFindInTunnelCacheEx(cache, directorykey, name, shortname, longname, flags, datalength, data)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlFreeAePushLock(aepushlock: *mut ::core::ffi::c_void) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlFreeAePushLock(aepushlock : *mut ::core::ffi::c_void) -> ());
    FsRtlFreeAePushLock(aepushlock)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlFreeExtraCreateParameter(ecpcontext: *const ::core::ffi::c_void) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlFreeExtraCreateParameter(ecpcontext : *const ::core::ffi::c_void) -> ());
    FsRtlFreeExtraCreateParameter(ecpcontext)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`*"]
#[cfg(feature = "Wdk_Foundation")]
#[inline]
pub unsafe fn FsRtlFreeExtraCreateParameterList(ecplist: *const super::super::Foundation::ECP_LIST) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlFreeExtraCreateParameterList(ecplist : *const super::super::Foundation:: ECP_LIST) -> ());
    FsRtlFreeExtraCreateParameterList(ecplist)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlFreeFileLock(filelock: *const FILE_LOCK) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlFreeFileLock(filelock : *const FILE_LOCK) -> ());
    FsRtlFreeFileLock(filelock)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(feature = "Win32_System_Kernel")]
#[inline]
pub unsafe fn FsRtlGetCurrentProcessLoaderList() -> *mut super::super::super::Win32::System::Kernel::LIST_ENTRY {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlGetCurrentProcessLoaderList() -> *mut super::super::super::Win32::System::Kernel:: LIST_ENTRY);
    FsRtlGetCurrentProcessLoaderList()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlGetEcpListFromIrp(irp: *const super::super::Foundation::IRP, ecplist: *mut *mut super::super::Foundation::ECP_LIST) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlGetEcpListFromIrp(irp : *const super::super::Foundation:: IRP, ecplist : *mut *mut super::super::Foundation:: ECP_LIST) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlGetEcpListFromIrp(irp, ecplist).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlGetFileSize(fileobject: *const super::super::Foundation::FILE_OBJECT, filesize: *mut i64) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlGetFileSize(fileobject : *const super::super::Foundation:: FILE_OBJECT, filesize : *mut i64) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlGetFileSize(fileobject, filesize).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlGetNextBaseMcbEntry(mcb: *const BASE_MCB, runindex: u32, vbn: *mut i64, lbn: *mut i64, sectorcount: *mut i64) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlGetNextBaseMcbEntry(mcb : *const BASE_MCB, runindex : u32, vbn : *mut i64, lbn : *mut i64, sectorcount : *mut i64) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlGetNextBaseMcbEntry(mcb, runindex, vbn, lbn, sectorcount)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn FsRtlGetNextExtraCreateParameter(ecplist: *const super::super::Foundation::ECP_LIST, currentecpcontext: ::core::option::Option<*const ::core::ffi::c_void>, nextecptype: ::core::option::Option<*mut ::windows_core::GUID>, nextecpcontext: ::core::option::Option<*mut *mut ::core::ffi::c_void>, nextecpcontextsize: ::core::option::Option<*mut u32>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlGetNextExtraCreateParameter(ecplist : *const super::super::Foundation:: ECP_LIST, currentecpcontext : *const ::core::ffi::c_void, nextecptype : *mut ::windows_core::GUID, nextecpcontext : *mut *mut ::core::ffi::c_void, nextecpcontextsize : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlGetNextExtraCreateParameter(ecplist, ::core::mem::transmute(currentecpcontext.unwrap_or(::std::ptr::null())), ::core::mem::transmute(nextecptype.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(nextecpcontext.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(nextecpcontextsize.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlGetNextFileLock<P0>(filelock: *const FILE_LOCK, restart: P0) -> *mut FILE_LOCK_INFO
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlGetNextFileLock(filelock : *const FILE_LOCK, restart : super::super::super::Win32::Foundation:: BOOLEAN) -> *mut FILE_LOCK_INFO);
    FsRtlGetNextFileLock(filelock, restart.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlGetNextLargeMcbEntry(mcb: *const LARGE_MCB, runindex: u32, vbn: *mut i64, lbn: *mut i64, sectorcount: *mut i64) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlGetNextLargeMcbEntry(mcb : *const LARGE_MCB, runindex : u32, vbn : *mut i64, lbn : *mut i64, sectorcount : *mut i64) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlGetNextLargeMcbEntry(mcb, runindex, vbn, lbn, sectorcount)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlGetNextMcbEntry(mcb: *const MCB, runindex: u32, vbn: *mut u32, lbn: *mut u32, sectorcount: *mut u32) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlGetNextMcbEntry(mcb : *const MCB, runindex : u32, vbn : *mut u32, lbn : *mut u32, sectorcount : *mut u32) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlGetNextMcbEntry(mcb, runindex, vbn, lbn, sectorcount)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlGetSectorSizeInformation(deviceobject: *const super::super::Foundation::DEVICE_OBJECT, sectorsizeinfo: *mut FILE_FS_SECTOR_SIZE_INFORMATION) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlGetSectorSizeInformation(deviceobject : *const super::super::Foundation:: DEVICE_OBJECT, sectorsizeinfo : *mut FILE_FS_SECTOR_SIZE_INFORMATION) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlGetSectorSizeInformation(deviceobject, sectorsizeinfo).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlGetSupportedFeatures(deviceobject: *const super::super::Foundation::DEVICE_OBJECT, supportedfeatures: *mut u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlGetSupportedFeatures(deviceobject : *const super::super::Foundation:: DEVICE_OBJECT, supportedfeatures : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlGetSupportedFeatures(deviceobject, supportedfeatures).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlGetVirtualDiskNestingLevel(deviceobject: *const super::super::Foundation::DEVICE_OBJECT, nestinglevel: *mut u32, nestingflags: ::core::option::Option<*mut u32>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlGetVirtualDiskNestingLevel(deviceobject : *const super::super::Foundation:: DEVICE_OBJECT, nestinglevel : *mut u32, nestingflags : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlGetVirtualDiskNestingLevel(deviceobject, nestinglevel, ::core::mem::transmute(nestingflags.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlIncrementCcFastMdlReadWait() {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlIncrementCcFastMdlReadWait() -> ());
    FsRtlIncrementCcFastMdlReadWait()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlIncrementCcFastReadNoWait() {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlIncrementCcFastReadNoWait() -> ());
    FsRtlIncrementCcFastReadNoWait()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlIncrementCcFastReadNotPossible() {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlIncrementCcFastReadNotPossible() -> ());
    FsRtlIncrementCcFastReadNotPossible()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlIncrementCcFastReadResourceMiss() {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlIncrementCcFastReadResourceMiss() -> ());
    FsRtlIncrementCcFastReadResourceMiss()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlIncrementCcFastReadWait() {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlIncrementCcFastReadWait() -> ());
    FsRtlIncrementCcFastReadWait()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlInitExtraCreateParameterLookasideList(lookaside: *mut ::core::ffi::c_void, flags: u32, size: usize, tag: u32) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlInitExtraCreateParameterLookasideList(lookaside : *mut ::core::ffi::c_void, flags : u32, size : usize, tag : u32) -> ());
    FsRtlInitExtraCreateParameterLookasideList(lookaside, flags, size, tag)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`*"]
#[cfg(feature = "Wdk_Foundation")]
#[inline]
pub unsafe fn FsRtlInitializeBaseMcb(mcb: *mut BASE_MCB, pooltype: super::super::Foundation::POOL_TYPE) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlInitializeBaseMcb(mcb : *mut BASE_MCB, pooltype : super::super::Foundation:: POOL_TYPE) -> ());
    FsRtlInitializeBaseMcb(mcb, pooltype)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn FsRtlInitializeBaseMcbEx(mcb: *mut BASE_MCB, pooltype: super::super::Foundation::POOL_TYPE, flags: u16) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlInitializeBaseMcbEx(mcb : *mut BASE_MCB, pooltype : super::super::Foundation:: POOL_TYPE, flags : u16) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlInitializeBaseMcbEx(mcb, pooltype, flags)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlInitializeExtraCreateParameter(ecp: *mut ECP_HEADER, ecpflags: u32, cleanupcallback: PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK, totalsize: u32, ecptype: *const ::windows_core::GUID, listallocatedfrom: ::core::option::Option<*const ::core::ffi::c_void>) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlInitializeExtraCreateParameter(ecp : *mut ECP_HEADER, ecpflags : u32, cleanupcallback : PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK, totalsize : u32, ecptype : *const ::windows_core::GUID, listallocatedfrom : *const ::core::ffi::c_void) -> ());
    FsRtlInitializeExtraCreateParameter(ecp, ecpflags, cleanupcallback, totalsize, ecptype, ::core::mem::transmute(listallocatedfrom.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn FsRtlInitializeExtraCreateParameterList(ecplist: *mut super::super::Foundation::ECP_LIST) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlInitializeExtraCreateParameterList(ecplist : *mut super::super::Foundation:: ECP_LIST) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlInitializeExtraCreateParameterList(ecplist).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlInitializeFileLock(filelock: *mut FILE_LOCK, completelockirproutine: PCOMPLETE_LOCK_IRP_ROUTINE, unlockroutine: PUNLOCK_ROUTINE) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlInitializeFileLock(filelock : *mut FILE_LOCK, completelockirproutine : PCOMPLETE_LOCK_IRP_ROUTINE, unlockroutine : PUNLOCK_ROUTINE) -> ());
    FsRtlInitializeFileLock(filelock, completelockirproutine, unlockroutine)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlInitializeLargeMcb(mcb: *mut LARGE_MCB, pooltype: super::super::Foundation::POOL_TYPE) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlInitializeLargeMcb(mcb : *mut LARGE_MCB, pooltype : super::super::Foundation:: POOL_TYPE) -> ());
    FsRtlInitializeLargeMcb(mcb, pooltype)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlInitializeMcb(mcb: *mut MCB, pooltype: super::super::Foundation::POOL_TYPE) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlInitializeMcb(mcb : *mut MCB, pooltype : super::super::Foundation:: POOL_TYPE) -> ());
    FsRtlInitializeMcb(mcb, pooltype)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlInitializeOplock(oplock: *mut *mut ::core::ffi::c_void) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlInitializeOplock(oplock : *mut *mut ::core::ffi::c_void) -> ());
    FsRtlInitializeOplock(oplock)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlInitializeTunnelCache(cache: *mut TUNNEL) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlInitializeTunnelCache(cache : *mut TUNNEL) -> ());
    FsRtlInitializeTunnelCache(cache)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn FsRtlInsertExtraCreateParameter(ecplist: *mut super::super::Foundation::ECP_LIST, ecpcontext: *mut ::core::ffi::c_void) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlInsertExtraCreateParameter(ecplist : *mut super::super::Foundation:: ECP_LIST, ecpcontext : *mut ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlInsertExtraCreateParameter(ecplist, ecpcontext).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlInsertPerFileContext(perfilecontextpointer: *const *const ::core::ffi::c_void, ptr: *const FSRTL_PER_FILE_CONTEXT) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlInsertPerFileContext(perfilecontextpointer : *const *const ::core::ffi::c_void, ptr : *const FSRTL_PER_FILE_CONTEXT) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlInsertPerFileContext(perfilecontextpointer, ptr).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlInsertPerFileObjectContext(fileobject: *const super::super::Foundation::FILE_OBJECT, ptr: *const FSRTL_PER_FILEOBJECT_CONTEXT) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlInsertPerFileObjectContext(fileobject : *const super::super::Foundation:: FILE_OBJECT, ptr : *const FSRTL_PER_FILEOBJECT_CONTEXT) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlInsertPerFileObjectContext(fileobject, ptr).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlInsertPerStreamContext(perstreamcontext: *const FSRTL_ADVANCED_FCB_HEADER, ptr: *const FSRTL_PER_STREAM_CONTEXT) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlInsertPerStreamContext(perstreamcontext : *const FSRTL_ADVANCED_FCB_HEADER, ptr : *const FSRTL_PER_STREAM_CONTEXT) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlInsertPerStreamContext(perstreamcontext, ptr).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn FsRtlIs32BitProcess(process: *const super::super::Foundation::KPROCESS) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlIs32BitProcess(process : *const super::super::Foundation:: KPROCESS) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlIs32BitProcess(process)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlIsDaxVolume(fileobject: *const super::super::Foundation::FILE_OBJECT) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlIsDaxVolume(fileobject : *const super::super::Foundation:: FILE_OBJECT) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlIsDaxVolume(fileobject)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlIsDbcsInExpression(expression: *const super::super::super::Win32::System::Kernel::STRING, name: *const super::super::super::Win32::System::Kernel::STRING) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlIsDbcsInExpression(expression : *const super::super::super::Win32::System::Kernel:: STRING, name : *const super::super::super::Win32::System::Kernel:: STRING) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlIsDbcsInExpression(expression, name)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlIsEcpAcknowledged(ecpcontext: *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlIsEcpAcknowledged(ecpcontext : *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlIsEcpAcknowledged(ecpcontext)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlIsEcpFromUserMode(ecpcontext: *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlIsEcpFromUserMode(ecpcontext : *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlIsEcpFromUserMode(ecpcontext)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlIsExtentDangling(startpage: u32, numberofpages: u32, flags: u32) -> u32 {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlIsExtentDangling(startpage : u32, numberofpages : u32, flags : u32) -> u32);
    FsRtlIsExtentDangling(startpage, numberofpages, flags)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlIsFatDbcsLegal<P0, P1, P2>(dbcsname: super::super::super::Win32::System::Kernel::STRING, wildcardspermissible: P0, pathnamepermissible: P1, leadingbackslashpermissible: P2) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P2: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlIsFatDbcsLegal(dbcsname : super::super::super::Win32::System::Kernel:: STRING, wildcardspermissible : super::super::super::Win32::Foundation:: BOOLEAN, pathnamepermissible : super::super::super::Win32::Foundation:: BOOLEAN, leadingbackslashpermissible : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlIsFatDbcsLegal(::core::mem::transmute(dbcsname), wildcardspermissible.into_param().abi(), pathnamepermissible.into_param().abi(), leadingbackslashpermissible.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlIsHpfsDbcsLegal<P0, P1, P2>(dbcsname: super::super::super::Win32::System::Kernel::STRING, wildcardspermissible: P0, pathnamepermissible: P1, leadingbackslashpermissible: P2) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P2: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlIsHpfsDbcsLegal(dbcsname : super::super::super::Win32::System::Kernel:: STRING, wildcardspermissible : super::super::super::Win32::Foundation:: BOOLEAN, pathnamepermissible : super::super::super::Win32::Foundation:: BOOLEAN, leadingbackslashpermissible : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlIsHpfsDbcsLegal(::core::mem::transmute(dbcsname), wildcardspermissible.into_param().abi(), pathnamepermissible.into_param().abi(), leadingbackslashpermissible.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlIsMobileOS() -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlIsMobileOS() -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlIsMobileOS()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlIsNameInExpression<P0, P1>(expression: *const super::super::super::Win32::Foundation::UNICODE_STRING, name: *const super::super::super::Win32::Foundation::UNICODE_STRING, ignorecase: P0, upcasetable: P1) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P1: ::windows_core::IntoParam<::windows_core::PCWSTR>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlIsNameInExpression(expression : *const super::super::super::Win32::Foundation:: UNICODE_STRING, name : *const super::super::super::Win32::Foundation:: UNICODE_STRING, ignorecase : super::super::super::Win32::Foundation:: BOOLEAN, upcasetable : ::windows_core::PCWSTR) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlIsNameInExpression(expression, name, ignorecase.into_param().abi(), upcasetable.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlIsNameInUnUpcasedExpression<P0, P1>(expression: *const super::super::super::Win32::Foundation::UNICODE_STRING, name: *const super::super::super::Win32::Foundation::UNICODE_STRING, ignorecase: P0, upcasetable: P1) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P1: ::windows_core::IntoParam<::windows_core::PCWSTR>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlIsNameInUnUpcasedExpression(expression : *const super::super::super::Win32::Foundation:: UNICODE_STRING, name : *const super::super::super::Win32::Foundation:: UNICODE_STRING, ignorecase : super::super::super::Win32::Foundation:: BOOLEAN, upcasetable : ::windows_core::PCWSTR) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlIsNameInUnUpcasedExpression(expression, name, ignorecase.into_param().abi(), upcasetable.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlIsNonEmptyDirectoryReparsePointAllowed(reparsetag: u32) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlIsNonEmptyDirectoryReparsePointAllowed(reparsetag : u32) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlIsNonEmptyDirectoryReparsePointAllowed(reparsetag)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlIsNtstatusExpected<P0>(exception: P0) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::NTSTATUS>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlIsNtstatusExpected(exception : super::super::super::Win32::Foundation:: NTSTATUS) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlIsNtstatusExpected(exception.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlIsPagingFile(fileobject: *const super::super::Foundation::FILE_OBJECT) -> u32 {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlIsPagingFile(fileobject : *const super::super::Foundation:: FILE_OBJECT) -> u32);
    FsRtlIsPagingFile(fileobject)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlIsSystemPagingFile(fileobject: *const super::super::Foundation::FILE_OBJECT) -> u32 {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlIsSystemPagingFile(fileobject : *const super::super::Foundation:: FILE_OBJECT) -> u32);
    FsRtlIsSystemPagingFile(fileobject)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlIssueDeviceIoControl(deviceobject: *const super::super::Foundation::DEVICE_OBJECT, ioctl: u32, flags: u8, inputbuffer: ::core::option::Option<*const ::core::ffi::c_void>, inputbufferlength: u32, outputbuffer: ::core::option::Option<*const ::core::ffi::c_void>, outputbufferlength: u32, iosbinformation: ::core::option::Option<*mut usize>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlIssueDeviceIoControl(deviceobject : *const super::super::Foundation:: DEVICE_OBJECT, ioctl : u32, flags : u8, inputbuffer : *const ::core::ffi::c_void, inputbufferlength : u32, outputbuffer : *const ::core::ffi::c_void, outputbufferlength : u32, iosbinformation : *mut usize) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlIssueDeviceIoControl(deviceobject, ioctl, flags, ::core::mem::transmute(inputbuffer.unwrap_or(::std::ptr::null())), inputbufferlength, ::core::mem::transmute(outputbuffer.unwrap_or(::std::ptr::null())), outputbufferlength, ::core::mem::transmute(iosbinformation.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlKernelFsControlFile(fileobject: *const super::super::Foundation::FILE_OBJECT, fscontrolcode: u32, inputbuffer: *const ::core::ffi::c_void, inputbufferlength: u32, outputbuffer: *mut ::core::ffi::c_void, outputbufferlength: u32, retoutputbuffersize: *mut u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlKernelFsControlFile(fileobject : *const super::super::Foundation:: FILE_OBJECT, fscontrolcode : u32, inputbuffer : *const ::core::ffi::c_void, inputbufferlength : u32, outputbuffer : *mut ::core::ffi::c_void, outputbufferlength : u32, retoutputbuffersize : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlKernelFsControlFile(fileobject, fscontrolcode, inputbuffer, inputbufferlength, outputbuffer, outputbufferlength, retoutputbuffersize).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlLogCcFlushError<P0>(filename: *const super::super::super::Win32::Foundation::UNICODE_STRING, deviceobject: *const super::super::Foundation::DEVICE_OBJECT, sectionobjectpointer: *const super::super::Foundation::SECTION_OBJECT_POINTERS, flusherror: P0, flags: u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::NTSTATUS>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlLogCcFlushError(filename : *const super::super::super::Win32::Foundation:: UNICODE_STRING, deviceobject : *const super::super::Foundation:: DEVICE_OBJECT, sectionobjectpointer : *const super::super::Foundation:: SECTION_OBJECT_POINTERS, flusherror : super::super::super::Win32::Foundation:: NTSTATUS, flags : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlLogCcFlushError(filename, deviceobject, sectionobjectpointer, flusherror.into_param().abi(), flags).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlLookupBaseMcbEntry(mcb: *const BASE_MCB, vbn: i64, lbn: ::core::option::Option<*mut i64>, sectorcountfromlbn: ::core::option::Option<*mut i64>, startinglbn: ::core::option::Option<*mut i64>, sectorcountfromstartinglbn: ::core::option::Option<*mut i64>, index: ::core::option::Option<*mut u32>) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlLookupBaseMcbEntry(mcb : *const BASE_MCB, vbn : i64, lbn : *mut i64, sectorcountfromlbn : *mut i64, startinglbn : *mut i64, sectorcountfromstartinglbn : *mut i64, index : *mut u32) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlLookupBaseMcbEntry(mcb, vbn, ::core::mem::transmute(lbn.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(sectorcountfromlbn.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(startinglbn.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(sectorcountfromstartinglbn.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(index.unwrap_or(::std::ptr::null_mut())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlLookupLargeMcbEntry(mcb: *const LARGE_MCB, vbn: i64, lbn: ::core::option::Option<*mut i64>, sectorcountfromlbn: ::core::option::Option<*mut i64>, startinglbn: ::core::option::Option<*mut i64>, sectorcountfromstartinglbn: ::core::option::Option<*mut i64>, index: ::core::option::Option<*mut u32>) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlLookupLargeMcbEntry(mcb : *const LARGE_MCB, vbn : i64, lbn : *mut i64, sectorcountfromlbn : *mut i64, startinglbn : *mut i64, sectorcountfromstartinglbn : *mut i64, index : *mut u32) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlLookupLargeMcbEntry(mcb, vbn, ::core::mem::transmute(lbn.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(sectorcountfromlbn.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(startinglbn.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(sectorcountfromstartinglbn.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(index.unwrap_or(::std::ptr::null_mut())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlLookupLastBaseMcbEntry(mcb: *const BASE_MCB, vbn: *mut i64, lbn: *mut i64) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlLookupLastBaseMcbEntry(mcb : *const BASE_MCB, vbn : *mut i64, lbn : *mut i64) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlLookupLastBaseMcbEntry(mcb, vbn, lbn)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlLookupLastBaseMcbEntryAndIndex(opaquemcb: *const BASE_MCB, largevbn: *mut i64, largelbn: *mut i64, index: *mut u32) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlLookupLastBaseMcbEntryAndIndex(opaquemcb : *const BASE_MCB, largevbn : *mut i64, largelbn : *mut i64, index : *mut u32) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlLookupLastBaseMcbEntryAndIndex(opaquemcb, largevbn, largelbn, index)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlLookupLastLargeMcbEntry(mcb: *const LARGE_MCB, vbn: *mut i64, lbn: *mut i64) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlLookupLastLargeMcbEntry(mcb : *const LARGE_MCB, vbn : *mut i64, lbn : *mut i64) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlLookupLastLargeMcbEntry(mcb, vbn, lbn)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlLookupLastLargeMcbEntryAndIndex(opaquemcb: *const LARGE_MCB, largevbn: *mut i64, largelbn: *mut i64, index: *mut u32) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlLookupLastLargeMcbEntryAndIndex(opaquemcb : *const LARGE_MCB, largevbn : *mut i64, largelbn : *mut i64, index : *mut u32) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlLookupLastLargeMcbEntryAndIndex(opaquemcb, largevbn, largelbn, index)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlLookupLastMcbEntry(mcb: *const MCB, vbn: *mut u32, lbn: *mut u32) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlLookupLastMcbEntry(mcb : *const MCB, vbn : *mut u32, lbn : *mut u32) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlLookupLastMcbEntry(mcb, vbn, lbn)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlLookupMcbEntry(mcb: *const MCB, vbn: u32, lbn: *mut u32, sectorcount: ::core::option::Option<*mut u32>, index: *mut u32) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlLookupMcbEntry(mcb : *const MCB, vbn : u32, lbn : *mut u32, sectorcount : *mut u32, index : *mut u32) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlLookupMcbEntry(mcb, vbn, lbn, ::core::mem::transmute(sectorcount.unwrap_or(::std::ptr::null_mut())), index)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlLookupPerFileContext(perfilecontextpointer: *const *const ::core::ffi::c_void, ownerid: ::core::option::Option<*const ::core::ffi::c_void>, instanceid: ::core::option::Option<*const ::core::ffi::c_void>) -> *mut FSRTL_PER_FILE_CONTEXT {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlLookupPerFileContext(perfilecontextpointer : *const *const ::core::ffi::c_void, ownerid : *const ::core::ffi::c_void, instanceid : *const ::core::ffi::c_void) -> *mut FSRTL_PER_FILE_CONTEXT);
    FsRtlLookupPerFileContext(perfilecontextpointer, ::core::mem::transmute(ownerid.unwrap_or(::std::ptr::null())), ::core::mem::transmute(instanceid.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlLookupPerFileObjectContext(fileobject: *const super::super::Foundation::FILE_OBJECT, ownerid: ::core::option::Option<*const ::core::ffi::c_void>, instanceid: ::core::option::Option<*const ::core::ffi::c_void>) -> *mut FSRTL_PER_FILEOBJECT_CONTEXT {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlLookupPerFileObjectContext(fileobject : *const super::super::Foundation:: FILE_OBJECT, ownerid : *const ::core::ffi::c_void, instanceid : *const ::core::ffi::c_void) -> *mut FSRTL_PER_FILEOBJECT_CONTEXT);
    FsRtlLookupPerFileObjectContext(fileobject, ::core::mem::transmute(ownerid.unwrap_or(::std::ptr::null())), ::core::mem::transmute(instanceid.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlLookupPerStreamContextInternal(streamcontext: *const FSRTL_ADVANCED_FCB_HEADER, ownerid: ::core::option::Option<*const ::core::ffi::c_void>, instanceid: ::core::option::Option<*const ::core::ffi::c_void>) -> *mut FSRTL_PER_STREAM_CONTEXT {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlLookupPerStreamContextInternal(streamcontext : *const FSRTL_ADVANCED_FCB_HEADER, ownerid : *const ::core::ffi::c_void, instanceid : *const ::core::ffi::c_void) -> *mut FSRTL_PER_STREAM_CONTEXT);
    FsRtlLookupPerStreamContextInternal(streamcontext, ::core::mem::transmute(ownerid.unwrap_or(::std::ptr::null())), ::core::mem::transmute(instanceid.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlMdlReadCompleteDev(fileobject: *const super::super::Foundation::FILE_OBJECT, mdlchain: *const super::super::super::Win32::Graphics::DirectDraw::MDL, deviceobject: ::core::option::Option<*const super::super::Foundation::DEVICE_OBJECT>) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlMdlReadCompleteDev(fileobject : *const super::super::Foundation:: FILE_OBJECT, mdlchain : *const super::super::super::Win32::Graphics::DirectDraw:: MDL, deviceobject : *const super::super::Foundation:: DEVICE_OBJECT) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlMdlReadCompleteDev(fileobject, mdlchain, ::core::mem::transmute(deviceobject.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlMdlReadDev(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, length: u32, lockkey: u32, mdlchain: *mut *mut super::super::super::Win32::Graphics::DirectDraw::MDL, iostatus: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, deviceobject: ::core::option::Option<*const super::super::Foundation::DEVICE_OBJECT>) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlMdlReadDev(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, length : u32, lockkey : u32, mdlchain : *mut *mut super::super::super::Win32::Graphics::DirectDraw:: MDL, iostatus : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, deviceobject : *const super::super::Foundation:: DEVICE_OBJECT) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlMdlReadDev(fileobject, fileoffset, length, lockkey, mdlchain, iostatus, ::core::mem::transmute(deviceobject.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlMdlReadEx(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, length: u32, lockkey: u32, mdlchain: *mut *mut super::super::super::Win32::Graphics::DirectDraw::MDL, iostatus: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlMdlReadEx(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, length : u32, lockkey : u32, mdlchain : *mut *mut super::super::super::Win32::Graphics::DirectDraw:: MDL, iostatus : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlMdlReadEx(fileobject, fileoffset, length, lockkey, mdlchain, iostatus).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlMdlWriteCompleteDev(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, mdlchain: *const super::super::super::Win32::Graphics::DirectDraw::MDL, deviceobject: ::core::option::Option<*const super::super::Foundation::DEVICE_OBJECT>) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlMdlWriteCompleteDev(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, mdlchain : *const super::super::super::Win32::Graphics::DirectDraw:: MDL, deviceobject : *const super::super::Foundation:: DEVICE_OBJECT) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlMdlWriteCompleteDev(fileobject, fileoffset, mdlchain, ::core::mem::transmute(deviceobject.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlMupGetProviderIdFromName(pprovidername: *const super::super::super::Win32::Foundation::UNICODE_STRING, pproviderid: *mut u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlMupGetProviderIdFromName(pprovidername : *const super::super::super::Win32::Foundation:: UNICODE_STRING, pproviderid : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlMupGetProviderIdFromName(pprovidername, pproviderid).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlMupGetProviderInfoFromFileObject(pfileobject: *const super::super::Foundation::FILE_OBJECT, level: u32, pbuffer: *mut ::core::ffi::c_void, pbuffersize: *mut u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlMupGetProviderInfoFromFileObject(pfileobject : *const super::super::Foundation:: FILE_OBJECT, level : u32, pbuffer : *mut ::core::ffi::c_void, pbuffersize : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlMupGetProviderInfoFromFileObject(pfileobject, level, pbuffer, pbuffersize).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlNormalizeNtstatus<P0, P1>(exception: P0, genericexception: P1) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::NTSTATUS>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::NTSTATUS>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlNormalizeNtstatus(exception : super::super::super::Win32::Foundation:: NTSTATUS, genericexception : super::super::super::Win32::Foundation:: NTSTATUS) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlNormalizeNtstatus(exception.into_param().abi(), genericexception.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(feature = "Win32_System_Kernel")]
#[inline]
pub unsafe fn FsRtlNotifyCleanup(notifysync: *const _REAL_NOTIFY_SYNC, notifylist: *const super::super::super::Win32::System::Kernel::LIST_ENTRY, fscontext: *const ::core::ffi::c_void) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlNotifyCleanup(notifysync : *const _REAL_NOTIFY_SYNC, notifylist : *const super::super::super::Win32::System::Kernel:: LIST_ENTRY, fscontext : *const ::core::ffi::c_void) -> ());
    FsRtlNotifyCleanup(notifysync, notifylist, fscontext)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(feature = "Win32_System_Kernel")]
#[inline]
pub unsafe fn FsRtlNotifyCleanupAll(notifysync: *const _REAL_NOTIFY_SYNC, notifylist: *const super::super::super::Win32::System::Kernel::LIST_ENTRY) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlNotifyCleanupAll(notifysync : *const _REAL_NOTIFY_SYNC, notifylist : *const super::super::super::Win32::System::Kernel:: LIST_ENTRY) -> ());
    FsRtlNotifyCleanupAll(notifysync, notifylist)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlNotifyFilterChangeDirectory<P0, P1>(notifysync: *const _REAL_NOTIFY_SYNC, notifylist: *const super::super::super::Win32::System::Kernel::LIST_ENTRY, fscontext: *const ::core::ffi::c_void, fulldirectoryname: *const super::super::super::Win32::System::Kernel::STRING, watchtree: P0, ignorebuffer: P1, completionfilter: u32, notifyirp: ::core::option::Option<*const super::super::Foundation::IRP>, traversecallback: PCHECK_FOR_TRAVERSE_ACCESS, subjectcontext: ::core::option::Option<*const super::super::Foundation::SECURITY_SUBJECT_CONTEXT>, filtercallback: PFILTER_REPORT_CHANGE)
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlNotifyFilterChangeDirectory(notifysync : *const _REAL_NOTIFY_SYNC, notifylist : *const super::super::super::Win32::System::Kernel:: LIST_ENTRY, fscontext : *const ::core::ffi::c_void, fulldirectoryname : *const super::super::super::Win32::System::Kernel:: STRING, watchtree : super::super::super::Win32::Foundation:: BOOLEAN, ignorebuffer : super::super::super::Win32::Foundation:: BOOLEAN, completionfilter : u32, notifyirp : *const super::super::Foundation:: IRP, traversecallback : PCHECK_FOR_TRAVERSE_ACCESS, subjectcontext : *const super::super::Foundation:: SECURITY_SUBJECT_CONTEXT, filtercallback : PFILTER_REPORT_CHANGE) -> ());
    FsRtlNotifyFilterChangeDirectory(notifysync, notifylist, fscontext, fulldirectoryname, watchtree.into_param().abi(), ignorebuffer.into_param().abi(), completionfilter, ::core::mem::transmute(notifyirp.unwrap_or(::std::ptr::null())), traversecallback, ::core::mem::transmute(subjectcontext.unwrap_or(::std::ptr::null())), filtercallback)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(feature = "Win32_System_Kernel")]
#[inline]
pub unsafe fn FsRtlNotifyFilterReportChange(notifysync: *const _REAL_NOTIFY_SYNC, notifylist: *const super::super::super::Win32::System::Kernel::LIST_ENTRY, fulltargetname: *const super::super::super::Win32::System::Kernel::STRING, targetnameoffset: u16, streamname: ::core::option::Option<*const super::super::super::Win32::System::Kernel::STRING>, normalizedparentname: ::core::option::Option<*const super::super::super::Win32::System::Kernel::STRING>, filtermatch: u32, action: u32, targetcontext: ::core::option::Option<*const ::core::ffi::c_void>, filtercontext: ::core::option::Option<*const ::core::ffi::c_void>) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlNotifyFilterReportChange(notifysync : *const _REAL_NOTIFY_SYNC, notifylist : *const super::super::super::Win32::System::Kernel:: LIST_ENTRY, fulltargetname : *const super::super::super::Win32::System::Kernel:: STRING, targetnameoffset : u16, streamname : *const super::super::super::Win32::System::Kernel:: STRING, normalizedparentname : *const super::super::super::Win32::System::Kernel:: STRING, filtermatch : u32, action : u32, targetcontext : *const ::core::ffi::c_void, filtercontext : *const ::core::ffi::c_void) -> ());
    FsRtlNotifyFilterReportChange(notifysync, notifylist, fulltargetname, targetnameoffset, ::core::mem::transmute(streamname.unwrap_or(::std::ptr::null())), ::core::mem::transmute(normalizedparentname.unwrap_or(::std::ptr::null())), filtermatch, action, ::core::mem::transmute(targetcontext.unwrap_or(::std::ptr::null())), ::core::mem::transmute(filtercontext.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlNotifyFullChangeDirectory<P0, P1>(notifysync: *const _REAL_NOTIFY_SYNC, notifylist: *const super::super::super::Win32::System::Kernel::LIST_ENTRY, fscontext: *const ::core::ffi::c_void, fulldirectoryname: *mut super::super::super::Win32::System::Kernel::STRING, watchtree: P0, ignorebuffer: P1, completionfilter: u32, notifyirp: ::core::option::Option<*const super::super::Foundation::IRP>, traversecallback: PCHECK_FOR_TRAVERSE_ACCESS, subjectcontext: ::core::option::Option<*const super::super::Foundation::SECURITY_SUBJECT_CONTEXT>)
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlNotifyFullChangeDirectory(notifysync : *const _REAL_NOTIFY_SYNC, notifylist : *const super::super::super::Win32::System::Kernel:: LIST_ENTRY, fscontext : *const ::core::ffi::c_void, fulldirectoryname : *mut super::super::super::Win32::System::Kernel:: STRING, watchtree : super::super::super::Win32::Foundation:: BOOLEAN, ignorebuffer : super::super::super::Win32::Foundation:: BOOLEAN, completionfilter : u32, notifyirp : *const super::super::Foundation:: IRP, traversecallback : PCHECK_FOR_TRAVERSE_ACCESS, subjectcontext : *const super::super::Foundation:: SECURITY_SUBJECT_CONTEXT) -> ());
    FsRtlNotifyFullChangeDirectory(notifysync, notifylist, fscontext, fulldirectoryname, watchtree.into_param().abi(), ignorebuffer.into_param().abi(), completionfilter, ::core::mem::transmute(notifyirp.unwrap_or(::std::ptr::null())), traversecallback, ::core::mem::transmute(subjectcontext.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(feature = "Win32_System_Kernel")]
#[inline]
pub unsafe fn FsRtlNotifyFullReportChange(notifysync: *const _REAL_NOTIFY_SYNC, notifylist: *const super::super::super::Win32::System::Kernel::LIST_ENTRY, fulltargetname: *const super::super::super::Win32::System::Kernel::STRING, targetnameoffset: u16, streamname: ::core::option::Option<*const super::super::super::Win32::System::Kernel::STRING>, normalizedparentname: ::core::option::Option<*const super::super::super::Win32::System::Kernel::STRING>, filtermatch: u32, action: u32, targetcontext: ::core::option::Option<*const ::core::ffi::c_void>) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlNotifyFullReportChange(notifysync : *const _REAL_NOTIFY_SYNC, notifylist : *const super::super::super::Win32::System::Kernel:: LIST_ENTRY, fulltargetname : *const super::super::super::Win32::System::Kernel:: STRING, targetnameoffset : u16, streamname : *const super::super::super::Win32::System::Kernel:: STRING, normalizedparentname : *const super::super::super::Win32::System::Kernel:: STRING, filtermatch : u32, action : u32, targetcontext : *const ::core::ffi::c_void) -> ());
    FsRtlNotifyFullReportChange(notifysync, notifylist, fulltargetname, targetnameoffset, ::core::mem::transmute(streamname.unwrap_or(::std::ptr::null())), ::core::mem::transmute(normalizedparentname.unwrap_or(::std::ptr::null())), filtermatch, action, ::core::mem::transmute(targetcontext.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlNotifyInitializeSync() -> *mut _REAL_NOTIFY_SYNC {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlNotifyInitializeSync(notifysync : *mut *mut _REAL_NOTIFY_SYNC) -> ());
    let mut result__ = ::std::mem::zeroed();
    FsRtlNotifyInitializeSync(&mut result__);
    ::std::mem::transmute(result__)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlNotifyUninitializeSync(notifysync: *mut *mut _REAL_NOTIFY_SYNC) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlNotifyUninitializeSync(notifysync : *mut *mut _REAL_NOTIFY_SYNC) -> ());
    FsRtlNotifyUninitializeSync(notifysync)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlNotifyVolumeEvent(fileobject: *const super::super::Foundation::FILE_OBJECT, eventcode: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlNotifyVolumeEvent(fileobject : *const super::super::Foundation:: FILE_OBJECT, eventcode : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlNotifyVolumeEvent(fileobject, eventcode).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlNotifyVolumeEventEx(fileobject: *const super::super::Foundation::FILE_OBJECT, eventcode: u32, event: *const super::super::Foundation::TARGET_DEVICE_CUSTOM_NOTIFICATION) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlNotifyVolumeEventEx(fileobject : *const super::super::Foundation:: FILE_OBJECT, eventcode : u32, event : *const super::super::Foundation:: TARGET_DEVICE_CUSTOM_NOTIFICATION) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlNotifyVolumeEventEx(fileobject, eventcode, event).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlNumberOfRunsInBaseMcb(mcb: *const BASE_MCB) -> u32 {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlNumberOfRunsInBaseMcb(mcb : *const BASE_MCB) -> u32);
    FsRtlNumberOfRunsInBaseMcb(mcb)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlNumberOfRunsInLargeMcb(mcb: *const LARGE_MCB) -> u32 {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlNumberOfRunsInLargeMcb(mcb : *const LARGE_MCB) -> u32);
    FsRtlNumberOfRunsInLargeMcb(mcb)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlNumberOfRunsInMcb(mcb: *const MCB) -> u32 {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlNumberOfRunsInMcb(mcb : *const MCB) -> u32);
    FsRtlNumberOfRunsInMcb(mcb)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlOplockBreakH(oplock: *const *const ::core::ffi::c_void, irp: *const super::super::Foundation::IRP, flags: u32, context: ::core::option::Option<*const ::core::ffi::c_void>, completionroutine: POPLOCK_WAIT_COMPLETE_ROUTINE, postirproutine: POPLOCK_FS_PREPOST_IRP) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlOplockBreakH(oplock : *const *const ::core::ffi::c_void, irp : *const super::super::Foundation:: IRP, flags : u32, context : *const ::core::ffi::c_void, completionroutine : POPLOCK_WAIT_COMPLETE_ROUTINE, postirproutine : POPLOCK_FS_PREPOST_IRP) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlOplockBreakH(oplock, irp, flags, ::core::mem::transmute(context.unwrap_or(::std::ptr::null())), completionroutine, postirproutine).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlOplockBreakH2(oplock: *const *const ::core::ffi::c_void, irp: *const super::super::Foundation::IRP, flags: u32, context: ::core::option::Option<*const ::core::ffi::c_void>, completionroutine: POPLOCK_WAIT_COMPLETE_ROUTINE, postirproutine: POPLOCK_FS_PREPOST_IRP, grantedaccess: ::core::option::Option<*const u32>, shareaccess: ::core::option::Option<*const u16>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlOplockBreakH2(oplock : *const *const ::core::ffi::c_void, irp : *const super::super::Foundation:: IRP, flags : u32, context : *const ::core::ffi::c_void, completionroutine : POPLOCK_WAIT_COMPLETE_ROUTINE, postirproutine : POPLOCK_FS_PREPOST_IRP, grantedaccess : *const u32, shareaccess : *const u16) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlOplockBreakH2(oplock, irp, flags, ::core::mem::transmute(context.unwrap_or(::std::ptr::null())), completionroutine, postirproutine, ::core::mem::transmute(grantedaccess.unwrap_or(::std::ptr::null())), ::core::mem::transmute(shareaccess.unwrap_or(::std::ptr::null()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlOplockBreakToNone(oplock: *mut *mut ::core::ffi::c_void, irpsp: ::core::option::Option<*const super::super::Foundation::IO_STACK_LOCATION>, irp: *const super::super::Foundation::IRP, context: ::core::option::Option<*const ::core::ffi::c_void>, completionroutine: POPLOCK_WAIT_COMPLETE_ROUTINE, postirproutine: POPLOCK_FS_PREPOST_IRP) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlOplockBreakToNone(oplock : *mut *mut ::core::ffi::c_void, irpsp : *const super::super::Foundation:: IO_STACK_LOCATION, irp : *const super::super::Foundation:: IRP, context : *const ::core::ffi::c_void, completionroutine : POPLOCK_WAIT_COMPLETE_ROUTINE, postirproutine : POPLOCK_FS_PREPOST_IRP) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlOplockBreakToNone(oplock, ::core::mem::transmute(irpsp.unwrap_or(::std::ptr::null())), irp, ::core::mem::transmute(context.unwrap_or(::std::ptr::null())), completionroutine, postirproutine).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlOplockBreakToNoneEx(oplock: *mut *mut ::core::ffi::c_void, irp: *const super::super::Foundation::IRP, flags: u32, context: ::core::option::Option<*const ::core::ffi::c_void>, completionroutine: POPLOCK_WAIT_COMPLETE_ROUTINE, postirproutine: POPLOCK_FS_PREPOST_IRP) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlOplockBreakToNoneEx(oplock : *mut *mut ::core::ffi::c_void, irp : *const super::super::Foundation:: IRP, flags : u32, context : *const ::core::ffi::c_void, completionroutine : POPLOCK_WAIT_COMPLETE_ROUTINE, postirproutine : POPLOCK_FS_PREPOST_IRP) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlOplockBreakToNoneEx(oplock, irp, flags, ::core::mem::transmute(context.unwrap_or(::std::ptr::null())), completionroutine, postirproutine).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlOplockFsctrl(oplock: *const *const ::core::ffi::c_void, irp: *const super::super::Foundation::IRP, opencount: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlOplockFsctrl(oplock : *const *const ::core::ffi::c_void, irp : *const super::super::Foundation:: IRP, opencount : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlOplockFsctrl(oplock, irp, opencount).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlOplockFsctrlEx(oplock: *const *const ::core::ffi::c_void, irp: *const super::super::Foundation::IRP, opencount: u32, flags: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlOplockFsctrlEx(oplock : *const *const ::core::ffi::c_void, irp : *const super::super::Foundation:: IRP, opencount : u32, flags : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlOplockFsctrlEx(oplock, irp, opencount, flags).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`*"]
#[cfg(feature = "Wdk_Foundation")]
#[inline]
pub unsafe fn FsRtlOplockGetAnyBreakOwnerProcess(oplock: *const *const ::core::ffi::c_void) -> *mut super::super::Foundation::KPROCESS {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlOplockGetAnyBreakOwnerProcess(oplock : *const *const ::core::ffi::c_void) -> *mut super::super::Foundation:: KPROCESS);
    FsRtlOplockGetAnyBreakOwnerProcess(oplock)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlOplockIsFastIoPossible(oplock: *const *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlOplockIsFastIoPossible(oplock : *const *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlOplockIsFastIoPossible(oplock)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlOplockIsSharedRequest(irp: *const super::super::Foundation::IRP) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlOplockIsSharedRequest(irp : *const super::super::Foundation:: IRP) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlOplockIsSharedRequest(irp)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlOplockKeysEqual(fo1: ::core::option::Option<*const super::super::Foundation::FILE_OBJECT>, fo2: ::core::option::Option<*const super::super::Foundation::FILE_OBJECT>) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlOplockKeysEqual(fo1 : *const super::super::Foundation:: FILE_OBJECT, fo2 : *const super::super::Foundation:: FILE_OBJECT) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlOplockKeysEqual(::core::mem::transmute(fo1.unwrap_or(::std::ptr::null())), ::core::mem::transmute(fo2.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlPostPagingFileStackOverflow(context: *const ::core::ffi::c_void, event: *const super::super::Foundation::KEVENT, stackoverflowroutine: PFSRTL_STACK_OVERFLOW_ROUTINE) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlPostPagingFileStackOverflow(context : *const ::core::ffi::c_void, event : *const super::super::Foundation:: KEVENT, stackoverflowroutine : PFSRTL_STACK_OVERFLOW_ROUTINE) -> ());
    FsRtlPostPagingFileStackOverflow(context, event, stackoverflowroutine)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlPostStackOverflow(context: *const ::core::ffi::c_void, event: *const super::super::Foundation::KEVENT, stackoverflowroutine: PFSRTL_STACK_OVERFLOW_ROUTINE) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlPostStackOverflow(context : *const ::core::ffi::c_void, event : *const super::super::Foundation:: KEVENT, stackoverflowroutine : PFSRTL_STACK_OVERFLOW_ROUTINE) -> ());
    FsRtlPostStackOverflow(context, event, stackoverflowroutine)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlPrepareMdlWriteDev(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, length: u32, lockkey: u32, mdlchain: *mut *mut super::super::super::Win32::Graphics::DirectDraw::MDL, iostatus: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, deviceobject: *const super::super::Foundation::DEVICE_OBJECT) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlPrepareMdlWriteDev(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, length : u32, lockkey : u32, mdlchain : *mut *mut super::super::super::Win32::Graphics::DirectDraw:: MDL, iostatus : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, deviceobject : *const super::super::Foundation:: DEVICE_OBJECT) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlPrepareMdlWriteDev(fileobject, fileoffset, length, lockkey, mdlchain, iostatus, deviceobject)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlPrepareMdlWriteEx(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, length: u32, lockkey: u32, mdlchain: *mut *mut super::super::super::Win32::Graphics::DirectDraw::MDL, iostatus: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlPrepareMdlWriteEx(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, length : u32, lockkey : u32, mdlchain : *mut *mut super::super::super::Win32::Graphics::DirectDraw:: MDL, iostatus : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlPrepareMdlWriteEx(fileobject, fileoffset, length, lockkey, mdlchain, iostatus).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlPrepareToReuseEcp(ecpcontext: *const ::core::ffi::c_void) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlPrepareToReuseEcp(ecpcontext : *const ::core::ffi::c_void) -> ());
    FsRtlPrepareToReuseEcp(ecpcontext)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlPrivateLock<P0, P1, P2>(filelock: *const FILE_LOCK, fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, length: *const i64, processid: *const super::super::Foundation::KPROCESS, key: u32, failimmediately: P0, exclusivelock: P1, iosb: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, irp: ::core::option::Option<*const super::super::Foundation::IRP>, context: ::core::option::Option<*const ::core::ffi::c_void>, alreadysynchronized: P2) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P2: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlPrivateLock(filelock : *const FILE_LOCK, fileobject : *const super::super::Foundation:: FILE_OBJECT, fileoffset : *const i64, length : *const i64, processid : *const super::super::Foundation:: KPROCESS, key : u32, failimmediately : super::super::super::Win32::Foundation:: BOOLEAN, exclusivelock : super::super::super::Win32::Foundation:: BOOLEAN, iosb : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, irp : *const super::super::Foundation:: IRP, context : *const ::core::ffi::c_void, alreadysynchronized : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlPrivateLock(filelock, fileobject, fileoffset, length, processid, key, failimmediately.into_param().abi(), exclusivelock.into_param().abi(), iosb, ::core::mem::transmute(irp.unwrap_or(::std::ptr::null())), ::core::mem::transmute(context.unwrap_or(::std::ptr::null())), alreadysynchronized.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlProcessFileLock(filelock: *const FILE_LOCK, irp: *const super::super::Foundation::IRP, context: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlProcessFileLock(filelock : *const FILE_LOCK, irp : *const super::super::Foundation:: IRP, context : *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlProcessFileLock(filelock, irp, ::core::mem::transmute(context.unwrap_or(::std::ptr::null()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlQueryCachedVdl(fileobject: *const super::super::Foundation::FILE_OBJECT, vdl: *mut i64) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlQueryCachedVdl(fileobject : *const super::super::Foundation:: FILE_OBJECT, vdl : *mut i64) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlQueryCachedVdl(fileobject, vdl).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlQueryInformationFile(fileobject: *const super::super::Foundation::FILE_OBJECT, fileinformation: *mut ::core::ffi::c_void, length: u32, fileinformationclass: super::super::super::Win32::System::WindowsProgramming::FILE_INFORMATION_CLASS, retfileinformationsize: *mut u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlQueryInformationFile(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileinformation : *mut ::core::ffi::c_void, length : u32, fileinformationclass : super::super::super::Win32::System::WindowsProgramming:: FILE_INFORMATION_CLASS, retfileinformationsize : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlQueryInformationFile(fileobject, fileinformation, length, fileinformationclass, retfileinformationsize).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlQueryKernelEaFile<P0, P1>(fileobject: *const super::super::Foundation::FILE_OBJECT, returnedeadata: *mut ::core::ffi::c_void, length: u32, returnsingleentry: P0, ealist: ::core::option::Option<*const ::core::ffi::c_void>, ealistlength: u32, eaindex: ::core::option::Option<*const u32>, restartscan: P1, lengthreturned: ::core::option::Option<*mut u32>) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlQueryKernelEaFile(fileobject : *const super::super::Foundation:: FILE_OBJECT, returnedeadata : *mut ::core::ffi::c_void, length : u32, returnsingleentry : super::super::super::Win32::Foundation:: BOOLEAN, ealist : *const ::core::ffi::c_void, ealistlength : u32, eaindex : *const u32, restartscan : super::super::super::Win32::Foundation:: BOOLEAN, lengthreturned : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlQueryKernelEaFile(fileobject, returnedeadata, length, returnsingleentry.into_param().abi(), ::core::mem::transmute(ealist.unwrap_or(::std::ptr::null())), ealistlength, ::core::mem::transmute(eaindex.unwrap_or(::std::ptr::null())), restartscan.into_param().abi(), ::core::mem::transmute(lengthreturned.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlQueryMaximumVirtualDiskNestingLevel() -> u32 {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlQueryMaximumVirtualDiskNestingLevel() -> u32);
    FsRtlQueryMaximumVirtualDiskNestingLevel()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlRegisterFileSystemFilterCallbacks(filterdriverobject: *const super::super::Foundation::DRIVER_OBJECT, callbacks: *const FS_FILTER_CALLBACKS) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlRegisterFileSystemFilterCallbacks(filterdriverobject : *const super::super::Foundation:: DRIVER_OBJECT, callbacks : *const FS_FILTER_CALLBACKS) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlRegisterFileSystemFilterCallbacks(filterdriverobject, callbacks).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlRegisterUncProvider<P0>(muphandle: *mut super::super::super::Win32::Foundation::HANDLE, redirectordevicename: *const super::super::super::Win32::Foundation::UNICODE_STRING, mailslotssupported: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlRegisterUncProvider(muphandle : *mut super::super::super::Win32::Foundation:: HANDLE, redirectordevicename : *const super::super::super::Win32::Foundation:: UNICODE_STRING, mailslotssupported : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlRegisterUncProvider(muphandle, redirectordevicename, mailslotssupported.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlRegisterUncProviderEx(muphandle: *mut super::super::super::Win32::Foundation::HANDLE, redirdevname: *const super::super::super::Win32::Foundation::UNICODE_STRING, deviceobject: *const super::super::Foundation::DEVICE_OBJECT, flags: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlRegisterUncProviderEx(muphandle : *mut super::super::super::Win32::Foundation:: HANDLE, redirdevname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, deviceobject : *const super::super::Foundation:: DEVICE_OBJECT, flags : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlRegisterUncProviderEx(muphandle, redirdevname, deviceobject, flags).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlRegisterUncProviderEx2(redirdevname: *const super::super::super::Win32::Foundation::UNICODE_STRING, deviceobject: *const super::super::Foundation::DEVICE_OBJECT, registration: *const FSRTL_UNC_PROVIDER_REGISTRATION, muphandle: *mut super::super::super::Win32::Foundation::HANDLE) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlRegisterUncProviderEx2(redirdevname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, deviceobject : *const super::super::Foundation:: DEVICE_OBJECT, registration : *const FSRTL_UNC_PROVIDER_REGISTRATION, muphandle : *mut super::super::super::Win32::Foundation:: HANDLE) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlRegisterUncProviderEx2(redirdevname, deviceobject, registration, muphandle).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlReleaseFile(fileobject: *const super::super::Foundation::FILE_OBJECT) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlReleaseFile(fileobject : *const super::super::Foundation:: FILE_OBJECT) -> ());
    FsRtlReleaseFile(fileobject)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlRemoveBaseMcbEntry(mcb: *mut BASE_MCB, vbn: i64, sectorcount: i64) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlRemoveBaseMcbEntry(mcb : *mut BASE_MCB, vbn : i64, sectorcount : i64) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlRemoveBaseMcbEntry(mcb, vbn, sectorcount)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlRemoveDotsFromPath(originalstring: ::windows_core::PWSTR, pathlength: u16, newlength: *mut u16) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlRemoveDotsFromPath(originalstring : ::windows_core::PWSTR, pathlength : u16, newlength : *mut u16) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlRemoveDotsFromPath(::core::mem::transmute(originalstring), pathlength, newlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn FsRtlRemoveExtraCreateParameter(ecplist: *mut super::super::Foundation::ECP_LIST, ecptype: *const ::windows_core::GUID, ecpcontext: *mut *mut ::core::ffi::c_void, ecpcontextsize: ::core::option::Option<*mut u32>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlRemoveExtraCreateParameter(ecplist : *mut super::super::Foundation:: ECP_LIST, ecptype : *const ::windows_core::GUID, ecpcontext : *mut *mut ::core::ffi::c_void, ecpcontextsize : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlRemoveExtraCreateParameter(ecplist, ecptype, ecpcontext, ::core::mem::transmute(ecpcontextsize.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlRemoveLargeMcbEntry(mcb: *mut LARGE_MCB, vbn: i64, sectorcount: i64) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlRemoveLargeMcbEntry(mcb : *mut LARGE_MCB, vbn : i64, sectorcount : i64) -> ());
    FsRtlRemoveLargeMcbEntry(mcb, vbn, sectorcount)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlRemoveMcbEntry(mcb: *mut MCB, vbn: u32, sectorcount: u32) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlRemoveMcbEntry(mcb : *mut MCB, vbn : u32, sectorcount : u32) -> ());
    FsRtlRemoveMcbEntry(mcb, vbn, sectorcount)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlRemovePerFileContext(perfilecontextpointer: *const *const ::core::ffi::c_void, ownerid: ::core::option::Option<*const ::core::ffi::c_void>, instanceid: ::core::option::Option<*const ::core::ffi::c_void>) -> *mut FSRTL_PER_FILE_CONTEXT {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlRemovePerFileContext(perfilecontextpointer : *const *const ::core::ffi::c_void, ownerid : *const ::core::ffi::c_void, instanceid : *const ::core::ffi::c_void) -> *mut FSRTL_PER_FILE_CONTEXT);
    FsRtlRemovePerFileContext(perfilecontextpointer, ::core::mem::transmute(ownerid.unwrap_or(::std::ptr::null())), ::core::mem::transmute(instanceid.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlRemovePerFileObjectContext(fileobject: *const super::super::Foundation::FILE_OBJECT, ownerid: ::core::option::Option<*const ::core::ffi::c_void>, instanceid: ::core::option::Option<*const ::core::ffi::c_void>) -> *mut FSRTL_PER_FILEOBJECT_CONTEXT {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlRemovePerFileObjectContext(fileobject : *const super::super::Foundation:: FILE_OBJECT, ownerid : *const ::core::ffi::c_void, instanceid : *const ::core::ffi::c_void) -> *mut FSRTL_PER_FILEOBJECT_CONTEXT);
    FsRtlRemovePerFileObjectContext(fileobject, ::core::mem::transmute(ownerid.unwrap_or(::std::ptr::null())), ::core::mem::transmute(instanceid.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlRemovePerStreamContext(streamcontext: *const FSRTL_ADVANCED_FCB_HEADER, ownerid: ::core::option::Option<*const ::core::ffi::c_void>, instanceid: ::core::option::Option<*const ::core::ffi::c_void>) -> *mut FSRTL_PER_STREAM_CONTEXT {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlRemovePerStreamContext(streamcontext : *const FSRTL_ADVANCED_FCB_HEADER, ownerid : *const ::core::ffi::c_void, instanceid : *const ::core::ffi::c_void) -> *mut FSRTL_PER_STREAM_CONTEXT);
    FsRtlRemovePerStreamContext(streamcontext, ::core::mem::transmute(ownerid.unwrap_or(::std::ptr::null())), ::core::mem::transmute(instanceid.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlResetBaseMcb() -> BASE_MCB {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlResetBaseMcb(mcb : *mut BASE_MCB) -> ());
    let mut result__ = ::std::mem::zeroed();
    FsRtlResetBaseMcb(&mut result__);
    ::std::mem::transmute(result__)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlResetLargeMcb<P0>(mcb: *mut LARGE_MCB, selfsynchronized: P0)
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlResetLargeMcb(mcb : *mut LARGE_MCB, selfsynchronized : super::super::super::Win32::Foundation:: BOOLEAN) -> ());
    FsRtlResetLargeMcb(mcb, selfsynchronized.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlSetDriverBacking(driverobj: *const super::super::Foundation::DRIVER_OBJECT, flags: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlSetDriverBacking(driverobj : *const super::super::Foundation:: DRIVER_OBJECT, flags : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlSetDriverBacking(driverobj, flags).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlSetEcpListIntoIrp(irp: *mut super::super::Foundation::IRP, ecplist: *const super::super::Foundation::ECP_LIST) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlSetEcpListIntoIrp(irp : *mut super::super::Foundation:: IRP, ecplist : *const super::super::Foundation:: ECP_LIST) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlSetEcpListIntoIrp(irp, ecplist).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlSetKernelEaFile(fileobject: *const super::super::Foundation::FILE_OBJECT, eabuffer: *const ::core::ffi::c_void, length: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlSetKernelEaFile(fileobject : *const super::super::Foundation:: FILE_OBJECT, eabuffer : *const ::core::ffi::c_void, length : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlSetKernelEaFile(fileobject, eabuffer, length).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlSplitBaseMcb(mcb: *mut BASE_MCB, vbn: i64, amount: i64) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlSplitBaseMcb(mcb : *mut BASE_MCB, vbn : i64, amount : i64) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlSplitBaseMcb(mcb, vbn, amount)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlSplitLargeMcb(mcb: *mut LARGE_MCB, vbn: i64, amount: i64) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlSplitLargeMcb(mcb : *mut LARGE_MCB, vbn : i64, amount : i64) -> super::super::super::Win32::Foundation:: BOOLEAN);
    FsRtlSplitLargeMcb(mcb, vbn, amount)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlTeardownPerFileContexts(perfilecontextpointer: *const *const ::core::ffi::c_void) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlTeardownPerFileContexts(perfilecontextpointer : *const *const ::core::ffi::c_void) -> ());
    FsRtlTeardownPerFileContexts(perfilecontextpointer)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlTeardownPerStreamContexts(advancedheader: *const FSRTL_ADVANCED_FCB_HEADER) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlTeardownPerStreamContexts(advancedheader : *const FSRTL_ADVANCED_FCB_HEADER) -> ());
    FsRtlTeardownPerStreamContexts(advancedheader)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlTruncateBaseMcb(mcb: *mut BASE_MCB, vbn: i64) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlTruncateBaseMcb(mcb : *mut BASE_MCB, vbn : i64) -> ());
    FsRtlTruncateBaseMcb(mcb, vbn)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlTruncateLargeMcb(mcb: *mut LARGE_MCB, vbn: i64) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlTruncateLargeMcb(mcb : *mut LARGE_MCB, vbn : i64) -> ());
    FsRtlTruncateLargeMcb(mcb, vbn)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlTruncateMcb(mcb: *mut MCB, vbn: u32) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlTruncateMcb(mcb : *mut MCB, vbn : u32) -> ());
    FsRtlTruncateMcb(mcb, vbn)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlUninitializeBaseMcb(mcb: *const BASE_MCB) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlUninitializeBaseMcb(mcb : *const BASE_MCB) -> ());
    FsRtlUninitializeBaseMcb(mcb)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlUninitializeFileLock(filelock: *mut FILE_LOCK) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlUninitializeFileLock(filelock : *mut FILE_LOCK) -> ());
    FsRtlUninitializeFileLock(filelock)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlUninitializeLargeMcb(mcb: *mut LARGE_MCB) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlUninitializeLargeMcb(mcb : *mut LARGE_MCB) -> ());
    FsRtlUninitializeLargeMcb(mcb)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn FsRtlUninitializeMcb(mcb: *mut MCB) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlUninitializeMcb(mcb : *mut MCB) -> ());
    FsRtlUninitializeMcb(mcb)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlUninitializeOplock(oplock: *mut *mut ::core::ffi::c_void) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlUninitializeOplock(oplock : *mut *mut ::core::ffi::c_void) -> ());
    FsRtlUninitializeOplock(oplock)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn FsRtlUpdateDiskCounters(bytesread: u64, byteswritten: u64) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlUpdateDiskCounters(bytesread : u64, byteswritten : u64) -> ());
    FsRtlUpdateDiskCounters(bytesread, byteswritten)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlUpperOplockFsctrl(oplock: *const *const ::core::ffi::c_void, irp: *const super::super::Foundation::IRP, opencount: u32, loweroplockstate: u32, flags: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlUpperOplockFsctrl(oplock : *const *const ::core::ffi::c_void, irp : *const super::super::Foundation:: IRP, opencount : u32, loweroplockstate : u32, flags : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlUpperOplockFsctrl(oplock, irp, opencount, loweroplockstate, flags).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn FsRtlValidateReparsePointBuffer(bufferlength: u32, reparsebuffer: *const REPARSE_DATA_BUFFER) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlValidateReparsePointBuffer(bufferlength : u32, reparsebuffer : *const REPARSE_DATA_BUFFER) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlValidateReparsePointBuffer(bufferlength, reparsebuffer).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn FsRtlVolumeDeviceToCorrelationId(volumedeviceobject: *const super::super::Foundation::DEVICE_OBJECT, guid: *mut ::windows_core::GUID) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn FsRtlVolumeDeviceToCorrelationId(volumedeviceobject : *const super::super::Foundation:: DEVICE_OBJECT, guid : *mut ::windows_core::GUID) -> super::super::super::Win32::Foundation:: NTSTATUS);
    FsRtlVolumeDeviceToCorrelationId(volumedeviceobject, guid).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn GetSecurityUserInfo(logonid: ::core::option::Option<*const super::super::super::Win32::Foundation::LUID>, flags: u32, userinformation: *mut *mut SECURITY_USER_DATA) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn GetSecurityUserInfo(logonid : *const super::super::super::Win32::Foundation:: LUID, flags : u32, userinformation : *mut *mut SECURITY_USER_DATA) -> super::super::super::Win32::Foundation:: NTSTATUS);
    GetSecurityUserInfo(::core::mem::transmute(logonid.unwrap_or(::std::ptr::null())), flags, userinformation).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn ImpersonateSecurityContext(phcontext: *const SecHandle) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn ImpersonateSecurityContext(phcontext : *const SecHandle) -> ::windows_core::HRESULT);
    ImpersonateSecurityContext(phcontext).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn ImportSecurityContextW(pszpackage: *const super::super::super::Win32::Foundation::UNICODE_STRING, ppackedcontext: *const SecBuffer, token: *const ::core::ffi::c_void) -> ::windows_core::Result<SecHandle> {
    ::windows_targets::link!("secur32.dll" "system" fn ImportSecurityContextW(pszpackage : *const super::super::super::Win32::Foundation:: UNICODE_STRING, ppackedcontext : *const SecBuffer, token : *const ::core::ffi::c_void, phcontext : *mut SecHandle) -> ::windows_core::HRESULT);
    let mut result__ = ::std::mem::zeroed();
    ImportSecurityContextW(pszpackage, ppackedcontext, token, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn InitSecurityInterfaceW() -> *mut SecurityFunctionTableW {
    ::windows_targets::link!("secur32.dll" "system" fn InitSecurityInterfaceW() -> *mut SecurityFunctionTableW);
    InitSecurityInterfaceW()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn InitializeSecurityContextW(phcredential: ::core::option::Option<*const SecHandle>, phcontext: ::core::option::Option<*const SecHandle>, ptargetname: ::core::option::Option<*const super::super::super::Win32::Foundation::UNICODE_STRING>, fcontextreq: u32, reserved1: u32, targetdatarep: u32, pinput: ::core::option::Option<*const SecBufferDesc>, reserved2: u32, phnewcontext: ::core::option::Option<*mut SecHandle>, poutput: ::core::option::Option<*mut SecBufferDesc>, pfcontextattr: *mut u32, ptsexpiry: ::core::option::Option<*mut i64>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn InitializeSecurityContextW(phcredential : *const SecHandle, phcontext : *const SecHandle, ptargetname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, fcontextreq : u32, reserved1 : u32, targetdatarep : u32, pinput : *const SecBufferDesc, reserved2 : u32, phnewcontext : *mut SecHandle, poutput : *mut SecBufferDesc, pfcontextattr : *mut u32, ptsexpiry : *mut i64) -> ::windows_core::HRESULT);
    InitializeSecurityContextW(
        ::core::mem::transmute(phcredential.unwrap_or(::std::ptr::null())),
        ::core::mem::transmute(phcontext.unwrap_or(::std::ptr::null())),
        ::core::mem::transmute(ptargetname.unwrap_or(::std::ptr::null())),
        fcontextreq,
        reserved1,
        targetdatarep,
        ::core::mem::transmute(pinput.unwrap_or(::std::ptr::null())),
        reserved2,
        ::core::mem::transmute(phnewcontext.unwrap_or(::std::ptr::null_mut())),
        ::core::mem::transmute(poutput.unwrap_or(::std::ptr::null_mut())),
        pfcontextattr,
        ::core::mem::transmute(ptsexpiry.unwrap_or(::std::ptr::null_mut())),
    )
    .ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn IoAcquireVpbSpinLock() -> u8 {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoAcquireVpbSpinLock(irql : *mut u8) -> ());
    let mut result__ = ::std::mem::zeroed();
    IoAcquireVpbSpinLock(&mut result__);
    ::std::mem::transmute(result__)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn IoApplyPriorityInfoThread(inputpriorityinfo: *const IO_PRIORITY_INFO, outputpriorityinfo: ::core::option::Option<*mut IO_PRIORITY_INFO>, thread: *const super::super::Foundation::KTHREAD) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoApplyPriorityInfoThread(inputpriorityinfo : *const IO_PRIORITY_INFO, outputpriorityinfo : *mut IO_PRIORITY_INFO, thread : *const super::super::Foundation:: KTHREAD) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoApplyPriorityInfoThread(inputpriorityinfo, ::core::mem::transmute(outputpriorityinfo.unwrap_or(::std::ptr::null_mut())), thread).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn IoCheckDesiredAccess(desiredaccess: *mut u32, grantedaccess: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoCheckDesiredAccess(desiredaccess : *mut u32, grantedaccess : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoCheckDesiredAccess(desiredaccess, grantedaccess).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn IoCheckEaBufferValidity(eabuffer: *const FILE_FULL_EA_INFORMATION, ealength: u32, erroroffset: *mut u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoCheckEaBufferValidity(eabuffer : *const FILE_FULL_EA_INFORMATION, ealength : u32, erroroffset : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoCheckEaBufferValidity(eabuffer, ealength, erroroffset).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn IoCheckFunctionAccess(grantedaccess: u32, majorfunction: u8, minorfunction: u8, iocontrolcode: u32, arg1: ::core::option::Option<*const ::core::ffi::c_void>, arg2: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoCheckFunctionAccess(grantedaccess : u32, majorfunction : u8, minorfunction : u8, iocontrolcode : u32, arg1 : *const ::core::ffi::c_void, arg2 : *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoCheckFunctionAccess(grantedaccess, majorfunction, minorfunction, iocontrolcode, ::core::mem::transmute(arg1.unwrap_or(::std::ptr::null())), ::core::mem::transmute(arg2.unwrap_or(::std::ptr::null()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoCheckQuerySetFileInformation<P0>(fileinformationclass: super::super::super::Win32::System::WindowsProgramming::FILE_INFORMATION_CLASS, length: u32, setoperation: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoCheckQuerySetFileInformation(fileinformationclass : super::super::super::Win32::System::WindowsProgramming:: FILE_INFORMATION_CLASS, length : u32, setoperation : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoCheckQuerySetFileInformation(fileinformationclass, length, setoperation.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn IoCheckQuerySetVolumeInformation<P0>(fsinformationclass: FS_INFORMATION_CLASS, length: u32, setoperation: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoCheckQuerySetVolumeInformation(fsinformationclass : FS_INFORMATION_CLASS, length : u32, setoperation : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoCheckQuerySetVolumeInformation(fsinformationclass, length, setoperation.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn IoCheckQuotaBufferValidity(quotabuffer: *const FILE_QUOTA_INFORMATION, quotalength: u32, erroroffset: *mut u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoCheckQuotaBufferValidity(quotabuffer : *const FILE_QUOTA_INFORMATION, quotalength : u32, erroroffset : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoCheckQuotaBufferValidity(quotabuffer, quotalength, erroroffset).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoClearFsTrackOffsetState(irp: *mut super::super::Foundation::IRP) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoClearFsTrackOffsetState(irp : *mut super::super::Foundation:: IRP) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoClearFsTrackOffsetState(irp).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoCreateStreamFileObject(fileobject: ::core::option::Option<*const super::super::Foundation::FILE_OBJECT>, deviceobject: ::core::option::Option<*const super::super::Foundation::DEVICE_OBJECT>) -> *mut super::super::Foundation::FILE_OBJECT {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoCreateStreamFileObject(fileobject : *const super::super::Foundation:: FILE_OBJECT, deviceobject : *const super::super::Foundation:: DEVICE_OBJECT) -> *mut super::super::Foundation:: FILE_OBJECT);
    IoCreateStreamFileObject(::core::mem::transmute(fileobject.unwrap_or(::std::ptr::null())), ::core::mem::transmute(deviceobject.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoCreateStreamFileObjectEx(fileobject: ::core::option::Option<*const super::super::Foundation::FILE_OBJECT>, deviceobject: ::core::option::Option<*const super::super::Foundation::DEVICE_OBJECT>, filehandle: ::core::option::Option<*mut super::super::super::Win32::Foundation::HANDLE>) -> *mut super::super::Foundation::FILE_OBJECT {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoCreateStreamFileObjectEx(fileobject : *const super::super::Foundation:: FILE_OBJECT, deviceobject : *const super::super::Foundation:: DEVICE_OBJECT, filehandle : *mut super::super::super::Win32::Foundation:: HANDLE) -> *mut super::super::Foundation:: FILE_OBJECT);
    IoCreateStreamFileObjectEx(::core::mem::transmute(fileobject.unwrap_or(::std::ptr::null())), ::core::mem::transmute(deviceobject.unwrap_or(::std::ptr::null())), ::core::mem::transmute(filehandle.unwrap_or(::std::ptr::null_mut())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoCreateStreamFileObjectEx2(createoptions: *const IO_CREATE_STREAM_FILE_OPTIONS, fileobject: ::core::option::Option<*const super::super::Foundation::FILE_OBJECT>, deviceobject: ::core::option::Option<*const super::super::Foundation::DEVICE_OBJECT>, streamfileobject: *mut *mut super::super::Foundation::FILE_OBJECT, filehandle: ::core::option::Option<*mut super::super::super::Win32::Foundation::HANDLE>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoCreateStreamFileObjectEx2(createoptions : *const IO_CREATE_STREAM_FILE_OPTIONS, fileobject : *const super::super::Foundation:: FILE_OBJECT, deviceobject : *const super::super::Foundation:: DEVICE_OBJECT, streamfileobject : *mut *mut super::super::Foundation:: FILE_OBJECT, filehandle : *mut super::super::super::Win32::Foundation:: HANDLE) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoCreateStreamFileObjectEx2(createoptions, ::core::mem::transmute(fileobject.unwrap_or(::std::ptr::null())), ::core::mem::transmute(deviceobject.unwrap_or(::std::ptr::null())), streamfileobject, ::core::mem::transmute(filehandle.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoCreateStreamFileObjectLite(fileobject: ::core::option::Option<*const super::super::Foundation::FILE_OBJECT>, deviceobject: ::core::option::Option<*const super::super::Foundation::DEVICE_OBJECT>) -> *mut super::super::Foundation::FILE_OBJECT {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoCreateStreamFileObjectLite(fileobject : *const super::super::Foundation:: FILE_OBJECT, deviceobject : *const super::super::Foundation:: DEVICE_OBJECT) -> *mut super::super::Foundation:: FILE_OBJECT);
    IoCreateStreamFileObjectLite(::core::mem::transmute(fileobject.unwrap_or(::std::ptr::null())), ::core::mem::transmute(deviceobject.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoEnumerateDeviceObjectList(driverobject: *const super::super::Foundation::DRIVER_OBJECT, deviceobjectlist: ::core::option::Option<*mut *mut super::super::Foundation::DEVICE_OBJECT>, deviceobjectlistsize: u32, actualnumberdeviceobjects: *mut u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoEnumerateDeviceObjectList(driverobject : *const super::super::Foundation:: DRIVER_OBJECT, deviceobjectlist : *mut *mut super::super::Foundation:: DEVICE_OBJECT, deviceobjectlistsize : u32, actualnumberdeviceobjects : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoEnumerateDeviceObjectList(driverobject, ::core::mem::transmute(deviceobjectlist.unwrap_or(::std::ptr::null_mut())), deviceobjectlistsize, actualnumberdeviceobjects).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoEnumerateRegisteredFiltersList(driverobjectlist: ::core::option::Option<*mut *mut super::super::Foundation::DRIVER_OBJECT>, driverobjectlistsize: u32, actualnumberdriverobjects: *mut u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoEnumerateRegisteredFiltersList(driverobjectlist : *mut *mut super::super::Foundation:: DRIVER_OBJECT, driverobjectlistsize : u32, actualnumberdriverobjects : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoEnumerateRegisteredFiltersList(::core::mem::transmute(driverobjectlist.unwrap_or(::std::ptr::null_mut())), driverobjectlistsize, actualnumberdriverobjects).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoFastQueryNetworkAttributes(objectattributes: *const super::super::super::Win32::System::WindowsProgramming::OBJECT_ATTRIBUTES, desiredaccess: u32, openoptions: u32, iostatus: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, buffer: *mut FILE_NETWORK_OPEN_INFORMATION) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoFastQueryNetworkAttributes(objectattributes : *const super::super::super::Win32::System::WindowsProgramming:: OBJECT_ATTRIBUTES, desiredaccess : u32, openoptions : u32, iostatus : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, buffer : *mut FILE_NETWORK_OPEN_INFORMATION) -> super::super::super::Win32::Foundation:: BOOLEAN);
    IoFastQueryNetworkAttributes(objectattributes, desiredaccess, openoptions, iostatus, buffer)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoGetAttachedDevice(deviceobject: *const super::super::Foundation::DEVICE_OBJECT) -> *mut super::super::Foundation::DEVICE_OBJECT {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoGetAttachedDevice(deviceobject : *const super::super::Foundation:: DEVICE_OBJECT) -> *mut super::super::Foundation:: DEVICE_OBJECT);
    IoGetAttachedDevice(deviceobject)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoGetBaseFileSystemDeviceObject(fileobject: *const super::super::Foundation::FILE_OBJECT) -> *mut super::super::Foundation::DEVICE_OBJECT {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoGetBaseFileSystemDeviceObject(fileobject : *const super::super::Foundation:: FILE_OBJECT) -> *mut super::super::Foundation:: DEVICE_OBJECT);
    IoGetBaseFileSystemDeviceObject(fileobject)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoGetDeviceAttachmentBaseRef(deviceobject: *const super::super::Foundation::DEVICE_OBJECT) -> *mut super::super::Foundation::DEVICE_OBJECT {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoGetDeviceAttachmentBaseRef(deviceobject : *const super::super::Foundation:: DEVICE_OBJECT) -> *mut super::super::Foundation:: DEVICE_OBJECT);
    IoGetDeviceAttachmentBaseRef(deviceobject)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoGetDeviceToVerify(thread: *const super::super::Foundation::KTHREAD) -> *mut super::super::Foundation::DEVICE_OBJECT {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoGetDeviceToVerify(thread : *const super::super::Foundation:: KTHREAD) -> *mut super::super::Foundation:: DEVICE_OBJECT);
    IoGetDeviceToVerify(thread)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoGetDiskDeviceObject(filesystemdeviceobject: *const super::super::Foundation::DEVICE_OBJECT, diskdeviceobject: *mut *mut super::super::Foundation::DEVICE_OBJECT) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoGetDiskDeviceObject(filesystemdeviceobject : *const super::super::Foundation:: DEVICE_OBJECT, diskdeviceobject : *mut *mut super::super::Foundation:: DEVICE_OBJECT) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoGetDiskDeviceObject(filesystemdeviceobject, diskdeviceobject).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoGetFsTrackOffsetState(irp: *const super::super::Foundation::IRP, retfstrackoffsetblob: *mut *mut IO_IRP_EXT_TRACK_OFFSET_HEADER, rettrackedoffset: *mut i64) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoGetFsTrackOffsetState(irp : *const super::super::Foundation:: IRP, retfstrackoffsetblob : *mut *mut IO_IRP_EXT_TRACK_OFFSET_HEADER, rettrackedoffset : *mut i64) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoGetFsTrackOffsetState(irp, retfstrackoffsetblob, rettrackedoffset).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoGetLowerDeviceObject(deviceobject: *const super::super::Foundation::DEVICE_OBJECT) -> *mut super::super::Foundation::DEVICE_OBJECT {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoGetLowerDeviceObject(deviceobject : *const super::super::Foundation:: DEVICE_OBJECT) -> *mut super::super::Foundation:: DEVICE_OBJECT);
    IoGetLowerDeviceObject(deviceobject)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoGetOplockKeyContext(fileobject: *const super::super::Foundation::FILE_OBJECT) -> *mut OPLOCK_KEY_ECP_CONTEXT {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoGetOplockKeyContext(fileobject : *const super::super::Foundation:: FILE_OBJECT) -> *mut OPLOCK_KEY_ECP_CONTEXT);
    IoGetOplockKeyContext(fileobject)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoGetOplockKeyContextEx(fileobject: *const super::super::Foundation::FILE_OBJECT) -> *mut OPLOCK_KEY_CONTEXT {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoGetOplockKeyContextEx(fileobject : *const super::super::Foundation:: FILE_OBJECT) -> *mut OPLOCK_KEY_CONTEXT);
    IoGetOplockKeyContextEx(fileobject)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoGetRequestorProcess(irp: *const super::super::Foundation::IRP) -> *mut super::super::Foundation::KPROCESS {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoGetRequestorProcess(irp : *const super::super::Foundation:: IRP) -> *mut super::super::Foundation:: KPROCESS);
    IoGetRequestorProcess(irp)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoGetRequestorProcessId(irp: *const super::super::Foundation::IRP) -> u32 {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoGetRequestorProcessId(irp : *const super::super::Foundation:: IRP) -> u32);
    IoGetRequestorProcessId(irp)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoGetRequestorSessionId(irp: *const super::super::Foundation::IRP, psessionid: *mut u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoGetRequestorSessionId(irp : *const super::super::Foundation:: IRP, psessionid : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoGetRequestorSessionId(irp, psessionid).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoIrpHasFsTrackOffsetExtensionType(irp: *const super::super::Foundation::IRP) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoIrpHasFsTrackOffsetExtensionType(irp : *const super::super::Foundation:: IRP) -> super::super::super::Win32::Foundation:: BOOLEAN);
    IoIrpHasFsTrackOffsetExtensionType(irp)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoIsOperationSynchronous(irp: *const super::super::Foundation::IRP) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoIsOperationSynchronous(irp : *const super::super::Foundation:: IRP) -> super::super::super::Win32::Foundation:: BOOLEAN);
    IoIsOperationSynchronous(irp)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn IoIsSystemThread(thread: *const super::super::Foundation::KTHREAD) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoIsSystemThread(thread : *const super::super::Foundation:: KTHREAD) -> super::super::super::Win32::Foundation:: BOOLEAN);
    IoIsSystemThread(thread)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoIsValidNameGraftingBuffer(irp: *const super::super::Foundation::IRP, reparsebuffer: *const REPARSE_DATA_BUFFER) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoIsValidNameGraftingBuffer(irp : *const super::super::Foundation:: IRP, reparsebuffer : *const REPARSE_DATA_BUFFER) -> super::super::super::Win32::Foundation:: BOOLEAN);
    IoIsValidNameGraftingBuffer(irp, reparsebuffer)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoPageRead(fileobject: *const super::super::Foundation::FILE_OBJECT, memorydescriptorlist: *const super::super::super::Win32::Graphics::DirectDraw::MDL, startingoffset: *const i64, event: *const super::super::Foundation::KEVENT, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoPageRead(fileobject : *const super::super::Foundation:: FILE_OBJECT, memorydescriptorlist : *const super::super::super::Win32::Graphics::DirectDraw:: MDL, startingoffset : *const i64, event : *const super::super::Foundation:: KEVENT, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoPageRead(fileobject, memorydescriptorlist, startingoffset, event, iostatusblock).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoQueryFileDosDeviceName(fileobject: *const super::super::Foundation::FILE_OBJECT, objectnameinformation: *mut *mut super::super::Foundation::OBJECT_NAME_INFORMATION) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoQueryFileDosDeviceName(fileobject : *const super::super::Foundation:: FILE_OBJECT, objectnameinformation : *mut *mut super::super::Foundation:: OBJECT_NAME_INFORMATION) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoQueryFileDosDeviceName(fileobject, objectnameinformation).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoQueryFileInformation(fileobject: *const super::super::Foundation::FILE_OBJECT, fileinformationclass: super::super::super::Win32::System::WindowsProgramming::FILE_INFORMATION_CLASS, length: u32, fileinformation: *mut ::core::ffi::c_void, returnedlength: *mut u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoQueryFileInformation(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileinformationclass : super::super::super::Win32::System::WindowsProgramming:: FILE_INFORMATION_CLASS, length : u32, fileinformation : *mut ::core::ffi::c_void, returnedlength : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoQueryFileInformation(fileobject, fileinformationclass, length, fileinformation, returnedlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoQueryVolumeInformation(fileobject: *const super::super::Foundation::FILE_OBJECT, fsinformationclass: FS_INFORMATION_CLASS, length: u32, fsinformation: *mut ::core::ffi::c_void, returnedlength: *mut u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoQueryVolumeInformation(fileobject : *const super::super::Foundation:: FILE_OBJECT, fsinformationclass : FS_INFORMATION_CLASS, length : u32, fsinformation : *mut ::core::ffi::c_void, returnedlength : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoQueryVolumeInformation(fileobject, fsinformationclass, length, fsinformation, returnedlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoQueueThreadIrp(irp: *const super::super::Foundation::IRP) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoQueueThreadIrp(irp : *const super::super::Foundation:: IRP) -> ());
    IoQueueThreadIrp(irp)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoRegisterFileSystem(deviceobject: *const super::super::Foundation::DEVICE_OBJECT) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoRegisterFileSystem(deviceobject : *const super::super::Foundation:: DEVICE_OBJECT) -> ());
    IoRegisterFileSystem(deviceobject)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoRegisterFsRegistrationChange(driverobject: *const super::super::Foundation::DRIVER_OBJECT, drivernotificationroutine: PDRIVER_FS_NOTIFICATION) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoRegisterFsRegistrationChange(driverobject : *const super::super::Foundation:: DRIVER_OBJECT, drivernotificationroutine : PDRIVER_FS_NOTIFICATION) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoRegisterFsRegistrationChange(driverobject, drivernotificationroutine).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoRegisterFsRegistrationChangeMountAware<P0>(driverobject: *const super::super::Foundation::DRIVER_OBJECT, drivernotificationroutine: PDRIVER_FS_NOTIFICATION, synchronizewithmounts: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoRegisterFsRegistrationChangeMountAware(driverobject : *const super::super::Foundation:: DRIVER_OBJECT, drivernotificationroutine : PDRIVER_FS_NOTIFICATION, synchronizewithmounts : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoRegisterFsRegistrationChangeMountAware(driverobject, drivernotificationroutine, synchronizewithmounts.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn IoReleaseVpbSpinLock(irql: u8) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoReleaseVpbSpinLock(irql : u8) -> ());
    IoReleaseVpbSpinLock(irql)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoReplaceFileObjectName<P0>(fileobject: *const super::super::Foundation::FILE_OBJECT, newfilename: P0, filenamelength: u16) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<::windows_core::PCWSTR>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoReplaceFileObjectName(fileobject : *const super::super::Foundation:: FILE_OBJECT, newfilename : ::windows_core::PCWSTR, filenamelength : u16) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoReplaceFileObjectName(fileobject, newfilename.into_param().abi(), filenamelength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoRequestDeviceRemovalForReset(physicaldeviceobject: *const super::super::Foundation::DEVICE_OBJECT, flags: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoRequestDeviceRemovalForReset(physicaldeviceobject : *const super::super::Foundation:: DEVICE_OBJECT, flags : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoRequestDeviceRemovalForReset(physicaldeviceobject, flags).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoRetrievePriorityInfo(irp: ::core::option::Option<*const super::super::Foundation::IRP>, fileobject: ::core::option::Option<*const super::super::Foundation::FILE_OBJECT>, thread: ::core::option::Option<*const super::super::Foundation::KTHREAD>, priorityinfo: *mut IO_PRIORITY_INFO) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoRetrievePriorityInfo(irp : *const super::super::Foundation:: IRP, fileobject : *const super::super::Foundation:: FILE_OBJECT, thread : *const super::super::Foundation:: KTHREAD, priorityinfo : *mut IO_PRIORITY_INFO) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoRetrievePriorityInfo(::core::mem::transmute(irp.unwrap_or(::std::ptr::null())), ::core::mem::transmute(fileobject.unwrap_or(::std::ptr::null())), ::core::mem::transmute(thread.unwrap_or(::std::ptr::null())), priorityinfo).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoSetDeviceToVerify(thread: *const super::super::Foundation::KTHREAD, deviceobject: ::core::option::Option<*const super::super::Foundation::DEVICE_OBJECT>) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoSetDeviceToVerify(thread : *const super::super::Foundation:: KTHREAD, deviceobject : *const super::super::Foundation:: DEVICE_OBJECT) -> ());
    IoSetDeviceToVerify(thread, ::core::mem::transmute(deviceobject.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoSetFsTrackOffsetState(irp: *mut super::super::Foundation::IRP, fstrackoffsetblob: *const IO_IRP_EXT_TRACK_OFFSET_HEADER, trackedoffset: i64) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoSetFsTrackOffsetState(irp : *mut super::super::Foundation:: IRP, fstrackoffsetblob : *const IO_IRP_EXT_TRACK_OFFSET_HEADER, trackedoffset : i64) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoSetFsTrackOffsetState(irp, fstrackoffsetblob, trackedoffset).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoSetInformation(fileobject: *const super::super::Foundation::FILE_OBJECT, fileinformationclass: super::super::super::Win32::System::WindowsProgramming::FILE_INFORMATION_CLASS, length: u32, fileinformation: *const ::core::ffi::c_void) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoSetInformation(fileobject : *const super::super::Foundation:: FILE_OBJECT, fileinformationclass : super::super::super::Win32::System::WindowsProgramming:: FILE_INFORMATION_CLASS, length : u32, fileinformation : *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoSetInformation(fileobject, fileinformationclass, length, fileinformation).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoSynchronousPageWrite(fileobject: *const super::super::Foundation::FILE_OBJECT, memorydescriptorlist: *const super::super::super::Win32::Graphics::DirectDraw::MDL, startingoffset: *const i64, event: *const super::super::Foundation::KEVENT, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoSynchronousPageWrite(fileobject : *const super::super::Foundation:: FILE_OBJECT, memorydescriptorlist : *const super::super::super::Win32::Graphics::DirectDraw:: MDL, startingoffset : *const i64, event : *const super::super::Foundation:: KEVENT, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoSynchronousPageWrite(fileobject, memorydescriptorlist, startingoffset, event, iostatusblock).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`*"]
#[cfg(feature = "Wdk_Foundation")]
#[inline]
pub unsafe fn IoThreadToProcess(thread: *const super::super::Foundation::KTHREAD) -> *mut super::super::Foundation::KPROCESS {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoThreadToProcess(thread : *const super::super::Foundation:: KTHREAD) -> *mut super::super::Foundation:: KPROCESS);
    IoThreadToProcess(thread)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoUnregisterFileSystem(deviceobject: *const super::super::Foundation::DEVICE_OBJECT) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoUnregisterFileSystem(deviceobject : *const super::super::Foundation:: DEVICE_OBJECT) -> ());
    IoUnregisterFileSystem(deviceobject)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoUnregisterFsRegistrationChange(driverobject: *const super::super::Foundation::DRIVER_OBJECT, drivernotificationroutine: PDRIVER_FS_NOTIFICATION) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoUnregisterFsRegistrationChange(driverobject : *const super::super::Foundation:: DRIVER_OBJECT, drivernotificationroutine : PDRIVER_FS_NOTIFICATION) -> ());
    IoUnregisterFsRegistrationChange(driverobject, drivernotificationroutine)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn IoVerifyVolume<P0>(deviceobject: *const super::super::Foundation::DEVICE_OBJECT, allowrawmount: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn IoVerifyVolume(deviceobject : *const super::super::Foundation:: DEVICE_OBJECT, allowrawmount : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    IoVerifyVolume(deviceobject, allowrawmount.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`*"]
#[cfg(feature = "Wdk_Foundation")]
#[inline]
pub unsafe fn KeAcquireQueuedSpinLock(number: super::super::Foundation::KSPIN_LOCK_QUEUE_NUMBER) -> u8 {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn KeAcquireQueuedSpinLock(number : super::super::Foundation:: KSPIN_LOCK_QUEUE_NUMBER) -> u8);
    KeAcquireQueuedSpinLock(number)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn KeAcquireSpinLockRaiseToSynch(spinlock: *mut usize) -> u8 {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn KeAcquireSpinLockRaiseToSynch(spinlock : *mut usize) -> u8);
    KeAcquireSpinLockRaiseToSynch(spinlock)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`*"]
#[cfg(feature = "Wdk_Foundation")]
#[inline]
pub unsafe fn KeAttachProcess(process: *mut super::super::Foundation::KPROCESS) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn KeAttachProcess(process : *mut super::super::Foundation:: KPROCESS) -> ());
    KeAttachProcess(process)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn KeDetachProcess() {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn KeDetachProcess() -> ());
    KeDetachProcess()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn KeInitializeMutant<P0>(mutant: *mut super::super::Foundation::KMUTANT, initialowner: P0)
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn KeInitializeMutant(mutant : *mut super::super::Foundation:: KMUTANT, initialowner : super::super::super::Win32::Foundation:: BOOLEAN) -> ());
    KeInitializeMutant(mutant, initialowner.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn KeInitializeQueue(queue: *mut super::super::Foundation::KQUEUE, count: u32) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn KeInitializeQueue(queue : *mut super::super::Foundation:: KQUEUE, count : u32) -> ());
    KeInitializeQueue(queue, count)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn KeInsertHeadQueue(queue: *mut super::super::Foundation::KQUEUE, entry: *mut super::super::super::Win32::System::Kernel::LIST_ENTRY) -> i32 {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn KeInsertHeadQueue(queue : *mut super::super::Foundation:: KQUEUE, entry : *mut super::super::super::Win32::System::Kernel:: LIST_ENTRY) -> i32);
    KeInsertHeadQueue(queue, entry)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn KeInsertQueue(queue: *mut super::super::Foundation::KQUEUE, entry: *mut super::super::super::Win32::System::Kernel::LIST_ENTRY) -> i32 {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn KeInsertQueue(queue : *mut super::super::Foundation:: KQUEUE, entry : *mut super::super::super::Win32::System::Kernel:: LIST_ENTRY) -> i32);
    KeInsertQueue(queue, entry)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn KeReadStateMutant(mutant: *const super::super::Foundation::KMUTANT) -> i32 {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn KeReadStateMutant(mutant : *const super::super::Foundation:: KMUTANT) -> i32);
    KeReadStateMutant(mutant)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn KeReadStateQueue(queue: *const super::super::Foundation::KQUEUE) -> i32 {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn KeReadStateQueue(queue : *const super::super::Foundation:: KQUEUE) -> i32);
    KeReadStateQueue(queue)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn KeReleaseMutant<P0, P1>(mutant: *mut super::super::Foundation::KMUTANT, increment: i32, abandoned: P0, wait: P1) -> i32
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn KeReleaseMutant(mutant : *mut super::super::Foundation:: KMUTANT, increment : i32, abandoned : super::super::super::Win32::Foundation:: BOOLEAN, wait : super::super::super::Win32::Foundation:: BOOLEAN) -> i32);
    KeReleaseMutant(mutant, increment, abandoned.into_param().abi(), wait.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`*"]
#[cfg(feature = "Wdk_Foundation")]
#[inline]
pub unsafe fn KeReleaseQueuedSpinLock(number: super::super::Foundation::KSPIN_LOCK_QUEUE_NUMBER, oldirql: u8) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn KeReleaseQueuedSpinLock(number : super::super::Foundation:: KSPIN_LOCK_QUEUE_NUMBER, oldirql : u8) -> ());
    KeReleaseQueuedSpinLock(number, oldirql)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn KeRemoveQueue(queue: *mut super::super::Foundation::KQUEUE, waitmode: i8, timeout: ::core::option::Option<*const i64>) -> *mut super::super::super::Win32::System::Kernel::LIST_ENTRY {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn KeRemoveQueue(queue : *mut super::super::Foundation:: KQUEUE, waitmode : i8, timeout : *const i64) -> *mut super::super::super::Win32::System::Kernel:: LIST_ENTRY);
    KeRemoveQueue(queue, waitmode, ::core::mem::transmute(timeout.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn KeRemoveQueueEx<P0>(queue: *mut super::super::Foundation::KQUEUE, waitmode: i8, alertable: P0, timeout: ::core::option::Option<*const i64>, entryarray: &mut [*mut super::super::super::Win32::System::Kernel::LIST_ENTRY]) -> u32
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn KeRemoveQueueEx(queue : *mut super::super::Foundation:: KQUEUE, waitmode : i8, alertable : super::super::super::Win32::Foundation:: BOOLEAN, timeout : *const i64, entryarray : *mut *mut super::super::super::Win32::System::Kernel:: LIST_ENTRY, count : u32) -> u32);
    KeRemoveQueueEx(queue, waitmode, alertable.into_param().abi(), ::core::mem::transmute(timeout.unwrap_or(::std::ptr::null())), ::core::mem::transmute(entryarray.as_ptr()), entryarray.len() as _)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn KeRundownQueue(queue: *mut super::super::Foundation::KQUEUE) -> *mut super::super::super::Win32::System::Kernel::LIST_ENTRY {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn KeRundownQueue(queue : *mut super::super::Foundation:: KQUEUE) -> *mut super::super::super::Win32::System::Kernel:: LIST_ENTRY);
    KeRundownQueue(queue)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`*"]
#[cfg(feature = "Wdk_Foundation")]
#[inline]
pub unsafe fn KeSetIdealProcessorThread(thread: *mut super::super::Foundation::KTHREAD, processor: u8) -> u8 {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn KeSetIdealProcessorThread(thread : *mut super::super::Foundation:: KTHREAD, processor : u8) -> u8);
    KeSetIdealProcessorThread(thread, processor)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn KeSetKernelStackSwapEnable<P0>(enable: P0) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn KeSetKernelStackSwapEnable(enable : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: BOOLEAN);
    KeSetKernelStackSwapEnable(enable.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn KeStackAttachProcess(process: *mut super::super::Foundation::KPROCESS, apcstate: *mut KAPC_STATE) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn KeStackAttachProcess(process : *mut super::super::Foundation:: KPROCESS, apcstate : *mut KAPC_STATE) -> ());
    KeStackAttachProcess(process, apcstate)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`*"]
#[cfg(feature = "Wdk_Foundation")]
#[inline]
pub unsafe fn KeTryToAcquireQueuedSpinLock(number: super::super::Foundation::KSPIN_LOCK_QUEUE_NUMBER, oldirql: *mut u8) -> u32 {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn KeTryToAcquireQueuedSpinLock(number : super::super::Foundation:: KSPIN_LOCK_QUEUE_NUMBER, oldirql : *mut u8) -> u32);
    KeTryToAcquireQueuedSpinLock(number, oldirql)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn KeUnstackDetachProcess(apcstate: *const KAPC_STATE) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn KeUnstackDetachProcess(apcstate : *const KAPC_STATE) -> ());
    KeUnstackDetachProcess(apcstate)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn LsaFreeReturnBuffer(buffer: *const ::core::ffi::c_void) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn LsaFreeReturnBuffer(buffer : *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: NTSTATUS);
    LsaFreeReturnBuffer(buffer).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn LsaLogonUser<P0>(lsahandle: P0, originname: *const super::super::super::Win32::System::Kernel::STRING, logontype: SECURITY_LOGON_TYPE, authenticationpackage: u32, authenticationinformation: *const ::core::ffi::c_void, authenticationinformationlength: u32, localgroups: ::core::option::Option<*const TOKEN_GROUPS>, sourcecontext: *const TOKEN_SOURCE, profilebuffer: *mut *mut ::core::ffi::c_void, profilebufferlength: *mut u32, logonid: *mut super::super::super::Win32::Foundation::LUID, token: *mut super::super::super::Win32::Foundation::HANDLE, quotas: *mut super::super::super::Win32::Security::QUOTA_LIMITS, substatus: *mut i32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("secur32.dll" "system" fn LsaLogonUser(lsahandle : super::super::super::Win32::Foundation:: HANDLE, originname : *const super::super::super::Win32::System::Kernel:: STRING, logontype : SECURITY_LOGON_TYPE, authenticationpackage : u32, authenticationinformation : *const ::core::ffi::c_void, authenticationinformationlength : u32, localgroups : *const TOKEN_GROUPS, sourcecontext : *const TOKEN_SOURCE, profilebuffer : *mut *mut ::core::ffi::c_void, profilebufferlength : *mut u32, logonid : *mut super::super::super::Win32::Foundation:: LUID, token : *mut super::super::super::Win32::Foundation:: HANDLE, quotas : *mut super::super::super::Win32::Security:: QUOTA_LIMITS, substatus : *mut i32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    LsaLogonUser(lsahandle.into_param().abi(), originname, logontype, authenticationpackage, authenticationinformation, authenticationinformationlength, ::core::mem::transmute(localgroups.unwrap_or(::std::ptr::null())), sourcecontext, profilebuffer, profilebufferlength, logonid, token, quotas, substatus).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn LsaRegisterLogonProcess(logonprocessname: *const super::super::super::Win32::System::Kernel::STRING, lsahandle: *mut super::super::super::Win32::Foundation::HANDLE, securitymode: *mut u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn LsaRegisterLogonProcess(logonprocessname : *const super::super::super::Win32::System::Kernel:: STRING, lsahandle : *mut super::super::super::Win32::Foundation:: HANDLE, securitymode : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    LsaRegisterLogonProcess(logonprocessname, lsahandle, securitymode).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn MakeSignature(phcontext: *const SecHandle, fqop: u32, pmessage: *const SecBufferDesc, messageseqno: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn MakeSignature(phcontext : *const SecHandle, fqop : u32, pmessage : *const SecBufferDesc, messageseqno : u32) -> ::windows_core::HRESULT);
    MakeSignature(phcontext, fqop, pmessage, messageseqno).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MapSecurityError(secstatus: ::windows_core::HRESULT) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ksecdd.sys" "system" fn MapSecurityError(secstatus : ::windows_core::HRESULT) -> super::super::super::Win32::Foundation:: NTSTATUS);
    MapSecurityError(secstatus).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn MmCanFileBeTruncated(sectionpointer: *const super::super::Foundation::SECTION_OBJECT_POINTERS, newfilesize: ::core::option::Option<*const i64>) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn MmCanFileBeTruncated(sectionpointer : *const super::super::Foundation:: SECTION_OBJECT_POINTERS, newfilesize : *const i64) -> super::super::super::Win32::Foundation:: BOOLEAN);
    MmCanFileBeTruncated(sectionpointer, ::core::mem::transmute(newfilesize.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`*"]
#[cfg(feature = "Wdk_Foundation")]
#[inline]
pub unsafe fn MmDoesFileHaveUserWritableReferences(sectionpointer: *const super::super::Foundation::SECTION_OBJECT_POINTERS) -> u32 {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn MmDoesFileHaveUserWritableReferences(sectionpointer : *const super::super::Foundation:: SECTION_OBJECT_POINTERS) -> u32);
    MmDoesFileHaveUserWritableReferences(sectionpointer)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn MmFlushImageSection(sectionobjectpointer: *const super::super::Foundation::SECTION_OBJECT_POINTERS, flushtype: MMFLUSH_TYPE) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn MmFlushImageSection(sectionobjectpointer : *const super::super::Foundation:: SECTION_OBJECT_POINTERS, flushtype : MMFLUSH_TYPE) -> super::super::super::Win32::Foundation:: BOOLEAN);
    MmFlushImageSection(sectionobjectpointer, flushtype)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn MmForceSectionClosed<P0>(sectionobjectpointer: *const super::super::Foundation::SECTION_OBJECT_POINTERS, delayclose: P0) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn MmForceSectionClosed(sectionobjectpointer : *const super::super::Foundation:: SECTION_OBJECT_POINTERS, delayclose : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: BOOLEAN);
    MmForceSectionClosed(sectionobjectpointer, delayclose.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn MmForceSectionClosedEx(sectionobjectpointer: *const super::super::Foundation::SECTION_OBJECT_POINTERS, forcecloseflags: u32) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn MmForceSectionClosedEx(sectionobjectpointer : *const super::super::Foundation:: SECTION_OBJECT_POINTERS, forcecloseflags : u32) -> super::super::super::Win32::Foundation:: BOOLEAN);
    MmForceSectionClosedEx(sectionobjectpointer, forcecloseflags)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn MmGetMaximumFileSectionSize() -> u64 {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn MmGetMaximumFileSectionSize() -> u64);
    MmGetMaximumFileSectionSize()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn MmIsFileSectionActive(fssectionpointer: *const super::super::Foundation::SECTION_OBJECT_POINTERS, flags: u32, sectionisactive: *mut u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn MmIsFileSectionActive(fssectionpointer : *const super::super::Foundation:: SECTION_OBJECT_POINTERS, flags : u32, sectionisactive : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    MmIsFileSectionActive(fssectionpointer, flags, sectionisactive).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MmIsRecursiveIoFault() -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn MmIsRecursiveIoFault() -> super::super::super::Win32::Foundation:: BOOLEAN);
    MmIsRecursiveIoFault()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Graphics_DirectDraw\"`*"]
#[cfg(feature = "Win32_Graphics_DirectDraw")]
#[inline]
pub unsafe fn MmMdlPagesAreZero(mdl: *const super::super::super::Win32::Graphics::DirectDraw::MDL) -> u32 {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn MmMdlPagesAreZero(mdl : *const super::super::super::Win32::Graphics::DirectDraw:: MDL) -> u32);
    MmMdlPagesAreZero(mdl)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_Storage_FileSystem\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_Storage_FileSystem", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn MmPrefetchPages(readlists: &[*const READ_LIST]) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn MmPrefetchPages(numberoflists : u32, readlists : *const *const READ_LIST) -> super::super::super::Win32::Foundation:: NTSTATUS);
    MmPrefetchPages(readlists.len() as _, ::core::mem::transmute(readlists.as_ptr())).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn MmSetAddressRangeModified(address: *const ::core::ffi::c_void, length: usize) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn MmSetAddressRangeModified(address : *const ::core::ffi::c_void, length : usize) -> super::super::super::Win32::Foundation:: BOOLEAN);
    MmSetAddressRangeModified(address, length)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn NtAccessCheckAndAuditAlarm<P0, P1>(subsystemname: *const super::super::super::Win32::Foundation::UNICODE_STRING, handleid: ::core::option::Option<*const ::core::ffi::c_void>, objecttypename: *const super::super::super::Win32::Foundation::UNICODE_STRING, objectname: *const super::super::super::Win32::Foundation::UNICODE_STRING, securitydescriptor: P0, desiredaccess: u32, genericmapping: *const super::super::super::Win32::Security::GENERIC_MAPPING, objectcreation: P1, grantedaccess: *mut u32, accessstatus: *mut i32, generateonclose: *mut super::super::super::Win32::Foundation::BOOLEAN) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtAccessCheckAndAuditAlarm(subsystemname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, handleid : *const ::core::ffi::c_void, objecttypename : *const super::super::super::Win32::Foundation:: UNICODE_STRING, objectname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, desiredaccess : u32, genericmapping : *const super::super::super::Win32::Security:: GENERIC_MAPPING, objectcreation : super::super::super::Win32::Foundation:: BOOLEAN, grantedaccess : *mut u32, accessstatus : *mut i32, generateonclose : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtAccessCheckAndAuditAlarm(subsystemname, ::core::mem::transmute(handleid.unwrap_or(::std::ptr::null())), objecttypename, objectname, securitydescriptor.into_param().abi(), desiredaccess, genericmapping, objectcreation.into_param().abi(), grantedaccess, accessstatus, generateonclose).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn NtAccessCheckByTypeAndAuditAlarm<P0, P1, P2>(subsystemname: *const super::super::super::Win32::Foundation::UNICODE_STRING, handleid: ::core::option::Option<*const ::core::ffi::c_void>, objecttypename: *const super::super::super::Win32::Foundation::UNICODE_STRING, objectname: *const super::super::super::Win32::Foundation::UNICODE_STRING, securitydescriptor: P0, principalselfsid: P1, desiredaccess: u32, audittype: AUDIT_EVENT_TYPE, flags: u32, objecttypelist: ::core::option::Option<&[OBJECT_TYPE_LIST]>, genericmapping: *const super::super::super::Win32::Security::GENERIC_MAPPING, objectcreation: P2, grantedaccess: *mut u32, accessstatus: *mut i32, generateonclose: *mut super::super::super::Win32::Foundation::BOOLEAN) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
    P2: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtAccessCheckByTypeAndAuditAlarm(subsystemname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, handleid : *const ::core::ffi::c_void, objecttypename : *const super::super::super::Win32::Foundation:: UNICODE_STRING, objectname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, principalselfsid : super::super::super::Win32::Foundation:: PSID, desiredaccess : u32, audittype : AUDIT_EVENT_TYPE, flags : u32, objecttypelist : *const OBJECT_TYPE_LIST, objecttypelistlength : u32, genericmapping : *const super::super::super::Win32::Security:: GENERIC_MAPPING, objectcreation : super::super::super::Win32::Foundation:: BOOLEAN, grantedaccess : *mut u32, accessstatus : *mut i32, generateonclose : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtAccessCheckByTypeAndAuditAlarm(subsystemname, ::core::mem::transmute(handleid.unwrap_or(::std::ptr::null())), objecttypename, objectname, securitydescriptor.into_param().abi(), principalselfsid.into_param().abi(), desiredaccess, audittype, flags, ::core::mem::transmute(objecttypelist.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr())), objecttypelist.as_deref().map_or(0, |slice| slice.len() as _), genericmapping, objectcreation.into_param().abi(), grantedaccess, accessstatus, generateonclose).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn NtAccessCheckByTypeResultListAndAuditAlarm<P0, P1, P2>(
    subsystemname: *const super::super::super::Win32::Foundation::UNICODE_STRING,
    handleid: ::core::option::Option<*const ::core::ffi::c_void>,
    objecttypename: *const super::super::super::Win32::Foundation::UNICODE_STRING,
    objectname: *const super::super::super::Win32::Foundation::UNICODE_STRING,
    securitydescriptor: P0,
    principalselfsid: P1,
    desiredaccess: u32,
    audittype: AUDIT_EVENT_TYPE,
    flags: u32,
    objecttypelist: ::core::option::Option<*const OBJECT_TYPE_LIST>,
    objecttypelistlength: u32,
    genericmapping: *const super::super::super::Win32::Security::GENERIC_MAPPING,
    objectcreation: P2,
    grantedaccess: *mut u32,
    accessstatus: *mut i32,
    generateonclose: *mut super::super::super::Win32::Foundation::BOOLEAN,
) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
    P2: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtAccessCheckByTypeResultListAndAuditAlarm(subsystemname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, handleid : *const ::core::ffi::c_void, objecttypename : *const super::super::super::Win32::Foundation:: UNICODE_STRING, objectname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, principalselfsid : super::super::super::Win32::Foundation:: PSID, desiredaccess : u32, audittype : AUDIT_EVENT_TYPE, flags : u32, objecttypelist : *const OBJECT_TYPE_LIST, objecttypelistlength : u32, genericmapping : *const super::super::super::Win32::Security:: GENERIC_MAPPING, objectcreation : super::super::super::Win32::Foundation:: BOOLEAN, grantedaccess : *mut u32, accessstatus : *mut i32, generateonclose : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtAccessCheckByTypeResultListAndAuditAlarm(subsystemname, ::core::mem::transmute(handleid.unwrap_or(::std::ptr::null())), objecttypename, objectname, securitydescriptor.into_param().abi(), principalselfsid.into_param().abi(), desiredaccess, audittype, flags, ::core::mem::transmute(objecttypelist.unwrap_or(::std::ptr::null())), objecttypelistlength, genericmapping, objectcreation.into_param().abi(), grantedaccess, accessstatus, generateonclose).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn NtAccessCheckByTypeResultListAndAuditAlarmByHandle<P0, P1, P2, P3>(
    subsystemname: *const super::super::super::Win32::Foundation::UNICODE_STRING,
    handleid: ::core::option::Option<*const ::core::ffi::c_void>,
    clienttoken: P0,
    objecttypename: *const super::super::super::Win32::Foundation::UNICODE_STRING,
    objectname: *const super::super::super::Win32::Foundation::UNICODE_STRING,
    securitydescriptor: P1,
    principalselfsid: P2,
    desiredaccess: u32,
    audittype: AUDIT_EVENT_TYPE,
    flags: u32,
    objecttypelist: ::core::option::Option<*const OBJECT_TYPE_LIST>,
    objecttypelistlength: u32,
    genericmapping: *const super::super::super::Win32::Security::GENERIC_MAPPING,
    objectcreation: P3,
    grantedaccess: *mut u32,
    accessstatus: *mut i32,
    generateonclose: *mut super::super::super::Win32::Foundation::BOOLEAN,
) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
    P2: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
    P3: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtAccessCheckByTypeResultListAndAuditAlarmByHandle(subsystemname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, handleid : *const ::core::ffi::c_void, clienttoken : super::super::super::Win32::Foundation:: HANDLE, objecttypename : *const super::super::super::Win32::Foundation:: UNICODE_STRING, objectname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, principalselfsid : super::super::super::Win32::Foundation:: PSID, desiredaccess : u32, audittype : AUDIT_EVENT_TYPE, flags : u32, objecttypelist : *const OBJECT_TYPE_LIST, objecttypelistlength : u32, genericmapping : *const super::super::super::Win32::Security:: GENERIC_MAPPING, objectcreation : super::super::super::Win32::Foundation:: BOOLEAN, grantedaccess : *mut u32, accessstatus : *mut i32, generateonclose : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtAccessCheckByTypeResultListAndAuditAlarmByHandle(subsystemname, ::core::mem::transmute(handleid.unwrap_or(::std::ptr::null())), clienttoken.into_param().abi(), objecttypename, objectname, securitydescriptor.into_param().abi(), principalselfsid.into_param().abi(), desiredaccess, audittype, flags, ::core::mem::transmute(objecttypelist.unwrap_or(::std::ptr::null())), objecttypelistlength, genericmapping, objectcreation.into_param().abi(), grantedaccess, accessstatus, generateonclose).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn NtAdjustGroupsToken<P0, P1>(tokenhandle: P0, resettodefault: P1, newstate: ::core::option::Option<*const TOKEN_GROUPS>, bufferlength: u32, previousstate: ::core::option::Option<*mut TOKEN_GROUPS>, returnlength: *mut u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtAdjustGroupsToken(tokenhandle : super::super::super::Win32::Foundation:: HANDLE, resettodefault : super::super::super::Win32::Foundation:: BOOLEAN, newstate : *const TOKEN_GROUPS, bufferlength : u32, previousstate : *mut TOKEN_GROUPS, returnlength : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtAdjustGroupsToken(tokenhandle.into_param().abi(), resettodefault.into_param().abi(), ::core::mem::transmute(newstate.unwrap_or(::std::ptr::null())), bufferlength, ::core::mem::transmute(previousstate.unwrap_or(::std::ptr::null_mut())), returnlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn NtAdjustPrivilegesToken<P0, P1>(tokenhandle: P0, disableallprivileges: P1, newstate: ::core::option::Option<*const TOKEN_PRIVILEGES>, bufferlength: u32, previousstate: ::core::option::Option<*mut TOKEN_PRIVILEGES>, returnlength: ::core::option::Option<*mut u32>) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtAdjustPrivilegesToken(tokenhandle : super::super::super::Win32::Foundation:: HANDLE, disableallprivileges : super::super::super::Win32::Foundation:: BOOLEAN, newstate : *const TOKEN_PRIVILEGES, bufferlength : u32, previousstate : *mut TOKEN_PRIVILEGES, returnlength : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtAdjustPrivilegesToken(tokenhandle.into_param().abi(), disableallprivileges.into_param().abi(), ::core::mem::transmute(newstate.unwrap_or(::std::ptr::null())), bufferlength, ::core::mem::transmute(previousstate.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(returnlength.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn NtAllocateVirtualMemory<P0>(processhandle: P0, baseaddress: *mut *mut ::core::ffi::c_void, zerobits: usize, regionsize: *mut usize, allocationtype: u32, protect: u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtAllocateVirtualMemory(processhandle : super::super::super::Win32::Foundation:: HANDLE, baseaddress : *mut *mut ::core::ffi::c_void, zerobits : usize, regionsize : *mut usize, allocationtype : u32, protect : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtAllocateVirtualMemory(processhandle.into_param().abi(), baseaddress, zerobits, regionsize, allocationtype, protect).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn NtClose<P0>(handle: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtClose(handle : super::super::super::Win32::Foundation:: HANDLE) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtClose(handle.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn NtCloseObjectAuditAlarm<P0>(subsystemname: *const super::super::super::Win32::Foundation::UNICODE_STRING, handleid: ::core::option::Option<*const ::core::ffi::c_void>, generateonclose: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtCloseObjectAuditAlarm(subsystemname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, handleid : *const ::core::ffi::c_void, generateonclose : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtCloseObjectAuditAlarm(subsystemname, ::core::mem::transmute(handleid.unwrap_or(::std::ptr::null())), generateonclose.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Storage_FileSystem\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Storage_FileSystem", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn NtCreateFile(filehandle: *mut super::super::super::Win32::Foundation::HANDLE, desiredaccess: super::super::super::Win32::Storage::FileSystem::FILE_ACCESS_RIGHTS, objectattributes: *const super::super::super::Win32::System::WindowsProgramming::OBJECT_ATTRIBUTES, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, allocationsize: ::core::option::Option<*const i64>, fileattributes: super::super::super::Win32::Storage::FileSystem::FILE_FLAGS_AND_ATTRIBUTES, shareaccess: super::super::super::Win32::Storage::FileSystem::FILE_SHARE_MODE, createdisposition: NTCREATEFILE_CREATE_DISPOSITION, createoptions: NTCREATEFILE_CREATE_OPTIONS, eabuffer: ::core::option::Option<*const ::core::ffi::c_void>, ealength: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn NtCreateFile(filehandle : *mut super::super::super::Win32::Foundation:: HANDLE, desiredaccess : super::super::super::Win32::Storage::FileSystem:: FILE_ACCESS_RIGHTS, objectattributes : *const super::super::super::Win32::System::WindowsProgramming:: OBJECT_ATTRIBUTES, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, allocationsize : *const i64, fileattributes : super::super::super::Win32::Storage::FileSystem:: FILE_FLAGS_AND_ATTRIBUTES, shareaccess : super::super::super::Win32::Storage::FileSystem:: FILE_SHARE_MODE, createdisposition : NTCREATEFILE_CREATE_DISPOSITION, createoptions : NTCREATEFILE_CREATE_OPTIONS, eabuffer : *const ::core::ffi::c_void, ealength : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtCreateFile(filehandle, desiredaccess, objectattributes, iostatusblock, ::core::mem::transmute(allocationsize.unwrap_or(::std::ptr::null())), fileattributes, shareaccess, createdisposition, createoptions, ::core::mem::transmute(eabuffer.unwrap_or(::std::ptr::null())), ealength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn NtCreateSection<P0>(sectionhandle: *mut super::super::super::Win32::Foundation::HANDLE, desiredaccess: u32, objectattributes: ::core::option::Option<*const super::super::super::Win32::System::WindowsProgramming::OBJECT_ATTRIBUTES>, maximumsize: ::core::option::Option<*const i64>, sectionpageprotection: u32, allocationattributes: u32, filehandle: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtCreateSection(sectionhandle : *mut super::super::super::Win32::Foundation:: HANDLE, desiredaccess : u32, objectattributes : *const super::super::super::Win32::System::WindowsProgramming:: OBJECT_ATTRIBUTES, maximumsize : *const i64, sectionpageprotection : u32, allocationattributes : u32, filehandle : super::super::super::Win32::Foundation:: HANDLE) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtCreateSection(sectionhandle, desiredaccess, ::core::mem::transmute(objectattributes.unwrap_or(::std::ptr::null())), ::core::mem::transmute(maximumsize.unwrap_or(::std::ptr::null())), sectionpageprotection, allocationattributes, filehandle.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_Memory\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Memory", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn NtCreateSectionEx<P0>(sectionhandle: *mut super::super::super::Win32::Foundation::HANDLE, desiredaccess: u32, objectattributes: ::core::option::Option<*const super::super::super::Win32::System::WindowsProgramming::OBJECT_ATTRIBUTES>, maximumsize: ::core::option::Option<*const i64>, sectionpageprotection: u32, allocationattributes: u32, filehandle: P0, extendedparameters: ::core::option::Option<&mut [super::super::super::Win32::System::Memory::MEM_EXTENDED_PARAMETER]>) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtCreateSectionEx(sectionhandle : *mut super::super::super::Win32::Foundation:: HANDLE, desiredaccess : u32, objectattributes : *const super::super::super::Win32::System::WindowsProgramming:: OBJECT_ATTRIBUTES, maximumsize : *const i64, sectionpageprotection : u32, allocationattributes : u32, filehandle : super::super::super::Win32::Foundation:: HANDLE, extendedparameters : *mut super::super::super::Win32::System::Memory:: MEM_EXTENDED_PARAMETER, extendedparametercount : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtCreateSectionEx(sectionhandle, desiredaccess, ::core::mem::transmute(objectattributes.unwrap_or(::std::ptr::null())), ::core::mem::transmute(maximumsize.unwrap_or(::std::ptr::null())), sectionpageprotection, allocationattributes, filehandle.into_param().abi(), ::core::mem::transmute(extendedparameters.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr())), extendedparameters.as_deref().map_or(0, |slice| slice.len() as _)).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn NtDeleteObjectAuditAlarm<P0>(subsystemname: *const super::super::super::Win32::Foundation::UNICODE_STRING, handleid: ::core::option::Option<*const ::core::ffi::c_void>, generateonclose: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtDeleteObjectAuditAlarm(subsystemname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, handleid : *const ::core::ffi::c_void, generateonclose : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtDeleteObjectAuditAlarm(subsystemname, ::core::mem::transmute(handleid.unwrap_or(::std::ptr::null())), generateonclose.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn NtDeviceIoControlFile<P0, P1>(filehandle: P0, event: P1, apcroutine: super::super::Foundation::PIO_APC_ROUTINE, apccontext: ::core::option::Option<*const ::core::ffi::c_void>, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, iocontrolcode: u32, inputbuffer: ::core::option::Option<*const ::core::ffi::c_void>, inputbufferlength: u32, outputbuffer: ::core::option::Option<*mut ::core::ffi::c_void>, outputbufferlength: u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtDeviceIoControlFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, event : super::super::super::Win32::Foundation:: HANDLE, apcroutine : super::super::Foundation:: PIO_APC_ROUTINE, apccontext : *const ::core::ffi::c_void, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, iocontrolcode : u32, inputbuffer : *const ::core::ffi::c_void, inputbufferlength : u32, outputbuffer : *mut ::core::ffi::c_void, outputbufferlength : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtDeviceIoControlFile(filehandle.into_param().abi(), event.into_param().abi(), apcroutine, ::core::mem::transmute(apccontext.unwrap_or(::std::ptr::null())), iostatusblock, iocontrolcode, ::core::mem::transmute(inputbuffer.unwrap_or(::std::ptr::null())), inputbufferlength, ::core::mem::transmute(outputbuffer.unwrap_or(::std::ptr::null_mut())), outputbufferlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn NtDuplicateToken<P0, P1>(existingtokenhandle: P0, desiredaccess: u32, objectattributes: ::core::option::Option<*const super::super::super::Win32::System::WindowsProgramming::OBJECT_ATTRIBUTES>, effectiveonly: P1, tokentype: TOKEN_TYPE, newtokenhandle: *mut super::super::super::Win32::Foundation::HANDLE) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtDuplicateToken(existingtokenhandle : super::super::super::Win32::Foundation:: HANDLE, desiredaccess : u32, objectattributes : *const super::super::super::Win32::System::WindowsProgramming:: OBJECT_ATTRIBUTES, effectiveonly : super::super::super::Win32::Foundation:: BOOLEAN, tokentype : TOKEN_TYPE, newtokenhandle : *mut super::super::super::Win32::Foundation:: HANDLE) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtDuplicateToken(existingtokenhandle.into_param().abi(), desiredaccess, ::core::mem::transmute(objectattributes.unwrap_or(::std::ptr::null())), effectiveonly.into_param().abi(), tokentype, newtokenhandle).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn NtFilterToken<P0>(existingtokenhandle: P0, flags: u32, sidstodisable: ::core::option::Option<*const TOKEN_GROUPS>, privilegestodelete: ::core::option::Option<*const TOKEN_PRIVILEGES>, restrictedsids: ::core::option::Option<*const TOKEN_GROUPS>, newtokenhandle: *mut super::super::super::Win32::Foundation::HANDLE) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtFilterToken(existingtokenhandle : super::super::super::Win32::Foundation:: HANDLE, flags : u32, sidstodisable : *const TOKEN_GROUPS, privilegestodelete : *const TOKEN_PRIVILEGES, restrictedsids : *const TOKEN_GROUPS, newtokenhandle : *mut super::super::super::Win32::Foundation:: HANDLE) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtFilterToken(existingtokenhandle.into_param().abi(), flags, ::core::mem::transmute(sidstodisable.unwrap_or(::std::ptr::null())), ::core::mem::transmute(privilegestodelete.unwrap_or(::std::ptr::null())), ::core::mem::transmute(restrictedsids.unwrap_or(::std::ptr::null())), newtokenhandle).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn NtFlushBuffersFileEx<P0>(filehandle: P0, flags: u32, parameters: *const ::core::ffi::c_void, parameterssize: u32, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtFlushBuffersFileEx(filehandle : super::super::super::Win32::Foundation:: HANDLE, flags : u32, parameters : *const ::core::ffi::c_void, parameterssize : u32, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtFlushBuffersFileEx(filehandle.into_param().abi(), flags, parameters, parameterssize, iostatusblock).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn NtFreeVirtualMemory<P0>(processhandle: P0, baseaddress: *mut *mut ::core::ffi::c_void, regionsize: *mut usize, freetype: u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtFreeVirtualMemory(processhandle : super::super::super::Win32::Foundation:: HANDLE, baseaddress : *mut *mut ::core::ffi::c_void, regionsize : *mut usize, freetype : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtFreeVirtualMemory(processhandle.into_param().abi(), baseaddress, regionsize, freetype).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn NtFsControlFile<P0, P1>(filehandle: P0, event: P1, apcroutine: super::super::Foundation::PIO_APC_ROUTINE, apccontext: ::core::option::Option<*const ::core::ffi::c_void>, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, fscontrolcode: u32, inputbuffer: ::core::option::Option<*const ::core::ffi::c_void>, inputbufferlength: u32, outputbuffer: ::core::option::Option<*mut ::core::ffi::c_void>, outputbufferlength: u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtFsControlFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, event : super::super::super::Win32::Foundation:: HANDLE, apcroutine : super::super::Foundation:: PIO_APC_ROUTINE, apccontext : *const ::core::ffi::c_void, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, fscontrolcode : u32, inputbuffer : *const ::core::ffi::c_void, inputbufferlength : u32, outputbuffer : *mut ::core::ffi::c_void, outputbufferlength : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtFsControlFile(filehandle.into_param().abi(), event.into_param().abi(), apcroutine, ::core::mem::transmute(apccontext.unwrap_or(::std::ptr::null())), iostatusblock, fscontrolcode, ::core::mem::transmute(inputbuffer.unwrap_or(::std::ptr::null())), inputbufferlength, ::core::mem::transmute(outputbuffer.unwrap_or(::std::ptr::null_mut())), outputbufferlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn NtImpersonateAnonymousToken<P0>(threadhandle: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtImpersonateAnonymousToken(threadhandle : super::super::super::Win32::Foundation:: HANDLE) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtImpersonateAnonymousToken(threadhandle.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn NtLockFile<P0, P1, P2, P3>(filehandle: P0, event: P1, apcroutine: super::super::Foundation::PIO_APC_ROUTINE, apccontext: ::core::option::Option<*const ::core::ffi::c_void>, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, byteoffset: *const i64, length: *const i64, key: u32, failimmediately: P2, exclusivelock: P3) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P2: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P3: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtLockFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, event : super::super::super::Win32::Foundation:: HANDLE, apcroutine : super::super::Foundation:: PIO_APC_ROUTINE, apccontext : *const ::core::ffi::c_void, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, byteoffset : *const i64, length : *const i64, key : u32, failimmediately : super::super::super::Win32::Foundation:: BOOLEAN, exclusivelock : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtLockFile(filehandle.into_param().abi(), event.into_param().abi(), apcroutine, ::core::mem::transmute(apccontext.unwrap_or(::std::ptr::null())), iostatusblock, byteoffset, length, key, failimmediately.into_param().abi(), exclusivelock.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn NtOpenFile(filehandle: *mut super::super::super::Win32::Foundation::HANDLE, desiredaccess: u32, objectattributes: *const super::super::super::Win32::System::WindowsProgramming::OBJECT_ATTRIBUTES, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, shareaccess: u32, openoptions: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn NtOpenFile(filehandle : *mut super::super::super::Win32::Foundation:: HANDLE, desiredaccess : u32, objectattributes : *const super::super::super::Win32::System::WindowsProgramming:: OBJECT_ATTRIBUTES, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, shareaccess : u32, openoptions : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtOpenFile(filehandle, desiredaccess, objectattributes, iostatusblock, shareaccess, openoptions).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn NtOpenObjectAuditAlarm<P0, P1, P2, P3>(subsystemname: *const super::super::super::Win32::Foundation::UNICODE_STRING, handleid: ::core::option::Option<*const ::core::ffi::c_void>, objecttypename: *const super::super::super::Win32::Foundation::UNICODE_STRING, objectname: *const super::super::super::Win32::Foundation::UNICODE_STRING, securitydescriptor: P0, clienttoken: P1, desiredaccess: u32, grantedaccess: u32, privileges: ::core::option::Option<*const super::super::super::Win32::Security::PRIVILEGE_SET>, objectcreation: P2, accessgranted: P3, generateonclose: *mut super::super::super::Win32::Foundation::BOOLEAN) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P2: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P3: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtOpenObjectAuditAlarm(subsystemname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, handleid : *const ::core::ffi::c_void, objecttypename : *const super::super::super::Win32::Foundation:: UNICODE_STRING, objectname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, clienttoken : super::super::super::Win32::Foundation:: HANDLE, desiredaccess : u32, grantedaccess : u32, privileges : *const super::super::super::Win32::Security:: PRIVILEGE_SET, objectcreation : super::super::super::Win32::Foundation:: BOOLEAN, accessgranted : super::super::super::Win32::Foundation:: BOOLEAN, generateonclose : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtOpenObjectAuditAlarm(subsystemname, ::core::mem::transmute(handleid.unwrap_or(::std::ptr::null())), objecttypename, objectname, securitydescriptor.into_param().abi(), clienttoken.into_param().abi(), desiredaccess, grantedaccess, ::core::mem::transmute(privileges.unwrap_or(::std::ptr::null())), objectcreation.into_param().abi(), accessgranted.into_param().abi(), generateonclose).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn NtOpenProcessToken<P0>(processhandle: P0, desiredaccess: u32, tokenhandle: *mut super::super::super::Win32::Foundation::HANDLE) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtOpenProcessToken(processhandle : super::super::super::Win32::Foundation:: HANDLE, desiredaccess : u32, tokenhandle : *mut super::super::super::Win32::Foundation:: HANDLE) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtOpenProcessToken(processhandle.into_param().abi(), desiredaccess, tokenhandle).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn NtOpenProcessTokenEx<P0>(processhandle: P0, desiredaccess: u32, handleattributes: u32, tokenhandle: *mut super::super::super::Win32::Foundation::HANDLE) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtOpenProcessTokenEx(processhandle : super::super::super::Win32::Foundation:: HANDLE, desiredaccess : u32, handleattributes : u32, tokenhandle : *mut super::super::super::Win32::Foundation:: HANDLE) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtOpenProcessTokenEx(processhandle.into_param().abi(), desiredaccess, handleattributes, tokenhandle).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn NtOpenThreadToken<P0, P1>(threadhandle: P0, desiredaccess: u32, openasself: P1, tokenhandle: *mut super::super::super::Win32::Foundation::HANDLE) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtOpenThreadToken(threadhandle : super::super::super::Win32::Foundation:: HANDLE, desiredaccess : u32, openasself : super::super::super::Win32::Foundation:: BOOLEAN, tokenhandle : *mut super::super::super::Win32::Foundation:: HANDLE) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtOpenThreadToken(threadhandle.into_param().abi(), desiredaccess, openasself.into_param().abi(), tokenhandle).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn NtOpenThreadTokenEx<P0, P1>(threadhandle: P0, desiredaccess: u32, openasself: P1, handleattributes: u32, tokenhandle: *mut super::super::super::Win32::Foundation::HANDLE) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtOpenThreadTokenEx(threadhandle : super::super::super::Win32::Foundation:: HANDLE, desiredaccess : u32, openasself : super::super::super::Win32::Foundation:: BOOLEAN, handleattributes : u32, tokenhandle : *mut super::super::super::Win32::Foundation:: HANDLE) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtOpenThreadTokenEx(threadhandle.into_param().abi(), desiredaccess, openasself.into_param().abi(), handleattributes, tokenhandle).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn NtPrivilegeCheck<P0>(clienttoken: P0, requiredprivileges: *mut super::super::super::Win32::Security::PRIVILEGE_SET, result: *mut super::super::super::Win32::Foundation::BOOLEAN) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtPrivilegeCheck(clienttoken : super::super::super::Win32::Foundation:: HANDLE, requiredprivileges : *mut super::super::super::Win32::Security:: PRIVILEGE_SET, result : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtPrivilegeCheck(clienttoken.into_param().abi(), requiredprivileges, result).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn NtPrivilegeObjectAuditAlarm<P0, P1>(subsystemname: *const super::super::super::Win32::Foundation::UNICODE_STRING, handleid: ::core::option::Option<*const ::core::ffi::c_void>, clienttoken: P0, desiredaccess: u32, privileges: *const super::super::super::Win32::Security::PRIVILEGE_SET, accessgranted: P1) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtPrivilegeObjectAuditAlarm(subsystemname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, handleid : *const ::core::ffi::c_void, clienttoken : super::super::super::Win32::Foundation:: HANDLE, desiredaccess : u32, privileges : *const super::super::super::Win32::Security:: PRIVILEGE_SET, accessgranted : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtPrivilegeObjectAuditAlarm(subsystemname, ::core::mem::transmute(handleid.unwrap_or(::std::ptr::null())), clienttoken.into_param().abi(), desiredaccess, privileges, accessgranted.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn NtPrivilegedServiceAuditAlarm<P0, P1>(subsystemname: *const super::super::super::Win32::Foundation::UNICODE_STRING, servicename: *const super::super::super::Win32::Foundation::UNICODE_STRING, clienttoken: P0, privileges: *const super::super::super::Win32::Security::PRIVILEGE_SET, accessgranted: P1) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtPrivilegedServiceAuditAlarm(subsystemname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, servicename : *const super::super::super::Win32::Foundation:: UNICODE_STRING, clienttoken : super::super::super::Win32::Foundation:: HANDLE, privileges : *const super::super::super::Win32::Security:: PRIVILEGE_SET, accessgranted : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtPrivilegedServiceAuditAlarm(subsystemname, servicename, clienttoken.into_param().abi(), privileges, accessgranted.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn NtQueryDirectoryFile<P0, P1, P2, P3>(filehandle: P0, event: P1, apcroutine: super::super::Foundation::PIO_APC_ROUTINE, apccontext: ::core::option::Option<*const ::core::ffi::c_void>, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, fileinformation: *mut ::core::ffi::c_void, length: u32, fileinformationclass: super::super::super::Win32::System::WindowsProgramming::FILE_INFORMATION_CLASS, returnsingleentry: P2, filename: ::core::option::Option<*const super::super::super::Win32::Foundation::UNICODE_STRING>, restartscan: P3) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P2: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P3: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtQueryDirectoryFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, event : super::super::super::Win32::Foundation:: HANDLE, apcroutine : super::super::Foundation:: PIO_APC_ROUTINE, apccontext : *const ::core::ffi::c_void, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, fileinformation : *mut ::core::ffi::c_void, length : u32, fileinformationclass : super::super::super::Win32::System::WindowsProgramming:: FILE_INFORMATION_CLASS, returnsingleentry : super::super::super::Win32::Foundation:: BOOLEAN, filename : *const super::super::super::Win32::Foundation:: UNICODE_STRING, restartscan : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtQueryDirectoryFile(filehandle.into_param().abi(), event.into_param().abi(), apcroutine, ::core::mem::transmute(apccontext.unwrap_or(::std::ptr::null())), iostatusblock, fileinformation, length, fileinformationclass, returnsingleentry.into_param().abi(), ::core::mem::transmute(filename.unwrap_or(::std::ptr::null())), restartscan.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn NtQueryDirectoryFileEx<P0, P1>(filehandle: P0, event: P1, apcroutine: super::super::Foundation::PIO_APC_ROUTINE, apccontext: ::core::option::Option<*const ::core::ffi::c_void>, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, fileinformation: *mut ::core::ffi::c_void, length: u32, fileinformationclass: super::super::super::Win32::System::WindowsProgramming::FILE_INFORMATION_CLASS, queryflags: u32, filename: ::core::option::Option<*const super::super::super::Win32::Foundation::UNICODE_STRING>) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtQueryDirectoryFileEx(filehandle : super::super::super::Win32::Foundation:: HANDLE, event : super::super::super::Win32::Foundation:: HANDLE, apcroutine : super::super::Foundation:: PIO_APC_ROUTINE, apccontext : *const ::core::ffi::c_void, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, fileinformation : *mut ::core::ffi::c_void, length : u32, fileinformationclass : super::super::super::Win32::System::WindowsProgramming:: FILE_INFORMATION_CLASS, queryflags : u32, filename : *const super::super::super::Win32::Foundation:: UNICODE_STRING) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtQueryDirectoryFileEx(filehandle.into_param().abi(), event.into_param().abi(), apcroutine, ::core::mem::transmute(apccontext.unwrap_or(::std::ptr::null())), iostatusblock, fileinformation, length, fileinformationclass, queryflags, ::core::mem::transmute(filename.unwrap_or(::std::ptr::null()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn NtQueryInformationByName(objectattributes: *const super::super::super::Win32::System::WindowsProgramming::OBJECT_ATTRIBUTES, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, fileinformation: *mut ::core::ffi::c_void, length: u32, fileinformationclass: super::super::super::Win32::System::WindowsProgramming::FILE_INFORMATION_CLASS) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn NtQueryInformationByName(objectattributes : *const super::super::super::Win32::System::WindowsProgramming:: OBJECT_ATTRIBUTES, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, fileinformation : *mut ::core::ffi::c_void, length : u32, fileinformationclass : super::super::super::Win32::System::WindowsProgramming:: FILE_INFORMATION_CLASS) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtQueryInformationByName(objectattributes, iostatusblock, fileinformation, length, fileinformationclass).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn NtQueryInformationFile<P0>(filehandle: P0, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, fileinformation: *mut ::core::ffi::c_void, length: u32, fileinformationclass: super::super::super::Win32::System::WindowsProgramming::FILE_INFORMATION_CLASS) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtQueryInformationFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, fileinformation : *mut ::core::ffi::c_void, length : u32, fileinformationclass : super::super::super::Win32::System::WindowsProgramming:: FILE_INFORMATION_CLASS) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtQueryInformationFile(filehandle.into_param().abi(), iostatusblock, fileinformation, length, fileinformationclass).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn NtQueryInformationToken<P0>(tokenhandle: P0, tokeninformationclass: TOKEN_INFORMATION_CLASS, tokeninformation: ::core::option::Option<*mut ::core::ffi::c_void>, tokeninformationlength: u32, returnlength: *mut u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtQueryInformationToken(tokenhandle : super::super::super::Win32::Foundation:: HANDLE, tokeninformationclass : TOKEN_INFORMATION_CLASS, tokeninformation : *mut ::core::ffi::c_void, tokeninformationlength : u32, returnlength : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtQueryInformationToken(tokenhandle.into_param().abi(), tokeninformationclass, ::core::mem::transmute(tokeninformation.unwrap_or(::std::ptr::null_mut())), tokeninformationlength, returnlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn NtQueryObject<P0>(handle: P0, objectinformationclass: OBJECT_INFORMATION_CLASS, objectinformation: ::core::option::Option<*mut ::core::ffi::c_void>, objectinformationlength: u32, returnlength: ::core::option::Option<*mut u32>) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtQueryObject(handle : super::super::super::Win32::Foundation:: HANDLE, objectinformationclass : OBJECT_INFORMATION_CLASS, objectinformation : *mut ::core::ffi::c_void, objectinformationlength : u32, returnlength : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtQueryObject(handle.into_param().abi(), objectinformationclass, ::core::mem::transmute(objectinformation.unwrap_or(::std::ptr::null_mut())), objectinformationlength, ::core::mem::transmute(returnlength.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn NtQueryQuotaInformationFile<P0, P1, P2, P3>(filehandle: P0, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, buffer: *mut ::core::ffi::c_void, length: u32, returnsingleentry: P1, sidlist: ::core::option::Option<*const ::core::ffi::c_void>, sidlistlength: u32, startsid: P2, restartscan: P3) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P2: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
    P3: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtQueryQuotaInformationFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, buffer : *mut ::core::ffi::c_void, length : u32, returnsingleentry : super::super::super::Win32::Foundation:: BOOLEAN, sidlist : *const ::core::ffi::c_void, sidlistlength : u32, startsid : super::super::super::Win32::Foundation:: PSID, restartscan : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtQueryQuotaInformationFile(filehandle.into_param().abi(), iostatusblock, buffer, length, returnsingleentry.into_param().abi(), ::core::mem::transmute(sidlist.unwrap_or(::std::ptr::null())), sidlistlength, startsid.into_param().abi(), restartscan.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn NtQuerySecurityObject<P0>(handle: P0, securityinformation: u32, securitydescriptor: super::super::super::Win32::Security::PSECURITY_DESCRIPTOR, length: u32, lengthneeded: *mut u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtQuerySecurityObject(handle : super::super::super::Win32::Foundation:: HANDLE, securityinformation : u32, securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, length : u32, lengthneeded : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtQuerySecurityObject(handle.into_param().abi(), securityinformation, securitydescriptor, length, lengthneeded).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn NtQueryVirtualMemory<P0>(processhandle: P0, baseaddress: ::core::option::Option<*const ::core::ffi::c_void>, memoryinformationclass: MEMORY_INFORMATION_CLASS, memoryinformation: *mut ::core::ffi::c_void, memoryinformationlength: usize, returnlength: ::core::option::Option<*mut usize>) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtQueryVirtualMemory(processhandle : super::super::super::Win32::Foundation:: HANDLE, baseaddress : *const ::core::ffi::c_void, memoryinformationclass : MEMORY_INFORMATION_CLASS, memoryinformation : *mut ::core::ffi::c_void, memoryinformationlength : usize, returnlength : *mut usize) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtQueryVirtualMemory(processhandle.into_param().abi(), ::core::mem::transmute(baseaddress.unwrap_or(::std::ptr::null())), memoryinformationclass, memoryinformation, memoryinformationlength, ::core::mem::transmute(returnlength.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn NtQueryVolumeInformationFile<P0>(filehandle: P0, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, fsinformation: *mut ::core::ffi::c_void, length: u32, fsinformationclass: FS_INFORMATION_CLASS) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtQueryVolumeInformationFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, fsinformation : *mut ::core::ffi::c_void, length : u32, fsinformationclass : FS_INFORMATION_CLASS) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtQueryVolumeInformationFile(filehandle.into_param().abi(), iostatusblock, fsinformation, length, fsinformationclass).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn NtReadFile<P0, P1>(filehandle: P0, event: P1, apcroutine: super::super::Foundation::PIO_APC_ROUTINE, apccontext: ::core::option::Option<*const ::core::ffi::c_void>, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, buffer: *mut ::core::ffi::c_void, length: u32, byteoffset: ::core::option::Option<*const i64>, key: ::core::option::Option<*const u32>) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtReadFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, event : super::super::super::Win32::Foundation:: HANDLE, apcroutine : super::super::Foundation:: PIO_APC_ROUTINE, apccontext : *const ::core::ffi::c_void, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, buffer : *mut ::core::ffi::c_void, length : u32, byteoffset : *const i64, key : *const u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtReadFile(filehandle.into_param().abi(), event.into_param().abi(), apcroutine, ::core::mem::transmute(apccontext.unwrap_or(::std::ptr::null())), iostatusblock, buffer, length, ::core::mem::transmute(byteoffset.unwrap_or(::std::ptr::null())), ::core::mem::transmute(key.unwrap_or(::std::ptr::null()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn NtSetInformationFile<P0>(filehandle: P0, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, fileinformation: *const ::core::ffi::c_void, length: u32, fileinformationclass: super::super::super::Win32::System::WindowsProgramming::FILE_INFORMATION_CLASS) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtSetInformationFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, fileinformation : *const ::core::ffi::c_void, length : u32, fileinformationclass : super::super::super::Win32::System::WindowsProgramming:: FILE_INFORMATION_CLASS) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtSetInformationFile(filehandle.into_param().abi(), iostatusblock, fileinformation, length, fileinformationclass).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_Threading\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Threading"))]
#[inline]
pub unsafe fn NtSetInformationThread<P0>(threadhandle: P0, threadinformationclass: super::super::super::Win32::System::Threading::THREADINFOCLASS, threadinformation: *mut ::core::ffi::c_void, threadinformationlength: u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtSetInformationThread(threadhandle : super::super::super::Win32::Foundation:: HANDLE, threadinformationclass : super::super::super::Win32::System::Threading:: THREADINFOCLASS, threadinformation : *mut ::core::ffi::c_void, threadinformationlength : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtSetInformationThread(threadhandle.into_param().abi(), threadinformationclass, threadinformation, threadinformationlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn NtSetInformationToken<P0>(tokenhandle: P0, tokeninformationclass: TOKEN_INFORMATION_CLASS, tokeninformation: *const ::core::ffi::c_void, tokeninformationlength: u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtSetInformationToken(tokenhandle : super::super::super::Win32::Foundation:: HANDLE, tokeninformationclass : TOKEN_INFORMATION_CLASS, tokeninformation : *const ::core::ffi::c_void, tokeninformationlength : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtSetInformationToken(tokenhandle.into_param().abi(), tokeninformationclass, tokeninformation, tokeninformationlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn NtSetInformationVirtualMemory<P0>(processhandle: P0, vminformationclass: VIRTUAL_MEMORY_INFORMATION_CLASS, virtualaddresses: &[MEMORY_RANGE_ENTRY], vminformation: *const ::core::ffi::c_void, vminformationlength: u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtSetInformationVirtualMemory(processhandle : super::super::super::Win32::Foundation:: HANDLE, vminformationclass : VIRTUAL_MEMORY_INFORMATION_CLASS, numberofentries : usize, virtualaddresses : *const MEMORY_RANGE_ENTRY, vminformation : *const ::core::ffi::c_void, vminformationlength : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtSetInformationVirtualMemory(processhandle.into_param().abi(), vminformationclass, virtualaddresses.len() as _, ::core::mem::transmute(virtualaddresses.as_ptr()), vminformation, vminformationlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn NtSetQuotaInformationFile<P0>(filehandle: P0, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, buffer: *const ::core::ffi::c_void, length: u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtSetQuotaInformationFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, buffer : *const ::core::ffi::c_void, length : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtSetQuotaInformationFile(filehandle.into_param().abi(), iostatusblock, buffer, length).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn NtSetSecurityObject<P0, P1>(handle: P0, securityinformation: u32, securitydescriptor: P1) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtSetSecurityObject(handle : super::super::super::Win32::Foundation:: HANDLE, securityinformation : u32, securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtSetSecurityObject(handle.into_param().abi(), securityinformation, securitydescriptor.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn NtSetVolumeInformationFile<P0>(filehandle: P0, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, fsinformation: *const ::core::ffi::c_void, length: u32, fsinformationclass: FS_INFORMATION_CLASS) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtSetVolumeInformationFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, fsinformation : *const ::core::ffi::c_void, length : u32, fsinformationclass : FS_INFORMATION_CLASS) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtSetVolumeInformationFile(filehandle.into_param().abi(), iostatusblock, fsinformation, length, fsinformationclass).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn NtUnlockFile<P0>(filehandle: P0, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, byteoffset: *const i64, length: *const i64, key: u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtUnlockFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, byteoffset : *const i64, length : *const i64, key : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtUnlockFile(filehandle.into_param().abi(), iostatusblock, byteoffset, length, key).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn NtWriteFile<P0, P1>(filehandle: P0, event: P1, apcroutine: super::super::Foundation::PIO_APC_ROUTINE, apccontext: ::core::option::Option<*const ::core::ffi::c_void>, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, buffer: *const ::core::ffi::c_void, length: u32, byteoffset: ::core::option::Option<*const i64>, key: ::core::option::Option<*const u32>) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn NtWriteFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, event : super::super::super::Win32::Foundation:: HANDLE, apcroutine : super::super::Foundation:: PIO_APC_ROUTINE, apccontext : *const ::core::ffi::c_void, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, buffer : *const ::core::ffi::c_void, length : u32, byteoffset : *const i64, key : *const u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    NtWriteFile(filehandle.into_param().abi(), event.into_param().abi(), apcroutine, ::core::mem::transmute(apccontext.unwrap_or(::std::ptr::null())), iostatusblock, buffer, length, ::core::mem::transmute(byteoffset.unwrap_or(::std::ptr::null())), ::core::mem::transmute(key.unwrap_or(::std::ptr::null()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn ObInsertObject(object: *const ::core::ffi::c_void, passedaccessstate: ::core::option::Option<*mut super::super::Foundation::ACCESS_STATE>, desiredaccess: u32, objectpointerbias: u32, newobject: ::core::option::Option<*mut *mut ::core::ffi::c_void>, handle: ::core::option::Option<*mut super::super::super::Win32::Foundation::HANDLE>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn ObInsertObject(object : *const ::core::ffi::c_void, passedaccessstate : *mut super::super::Foundation:: ACCESS_STATE, desiredaccess : u32, objectpointerbias : u32, newobject : *mut *mut ::core::ffi::c_void, handle : *mut super::super::super::Win32::Foundation:: HANDLE) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ObInsertObject(object, ::core::mem::transmute(passedaccessstate.unwrap_or(::std::ptr::null_mut())), desiredaccess, objectpointerbias, ::core::mem::transmute(newobject.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(handle.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn ObIsKernelHandle<P0>(handle: P0) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn ObIsKernelHandle(handle : super::super::super::Win32::Foundation:: HANDLE) -> super::super::super::Win32::Foundation:: BOOLEAN);
    ObIsKernelHandle(handle.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn ObMakeTemporaryObject(object: *const ::core::ffi::c_void) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn ObMakeTemporaryObject(object : *const ::core::ffi::c_void) -> ());
    ObMakeTemporaryObject(object)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn ObOpenObjectByPointer(object: *const ::core::ffi::c_void, handleattributes: u32, passedaccessstate: ::core::option::Option<*const super::super::Foundation::ACCESS_STATE>, desiredaccess: u32, objecttype: ::core::option::Option<*const super::super::Foundation::OBJECT_TYPE>, accessmode: i8, handle: *mut super::super::super::Win32::Foundation::HANDLE) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn ObOpenObjectByPointer(object : *const ::core::ffi::c_void, handleattributes : u32, passedaccessstate : *const super::super::Foundation:: ACCESS_STATE, desiredaccess : u32, objecttype : *const super::super::Foundation:: OBJECT_TYPE, accessmode : i8, handle : *mut super::super::super::Win32::Foundation:: HANDLE) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ObOpenObjectByPointer(object, handleattributes, ::core::mem::transmute(passedaccessstate.unwrap_or(::std::ptr::null())), desiredaccess, ::core::mem::transmute(objecttype.unwrap_or(::std::ptr::null())), accessmode, handle).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn ObOpenObjectByPointerWithTag(object: *const ::core::ffi::c_void, handleattributes: u32, passedaccessstate: ::core::option::Option<*const super::super::Foundation::ACCESS_STATE>, desiredaccess: u32, objecttype: ::core::option::Option<*const super::super::Foundation::OBJECT_TYPE>, accessmode: i8, tag: u32, handle: *mut super::super::super::Win32::Foundation::HANDLE) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn ObOpenObjectByPointerWithTag(object : *const ::core::ffi::c_void, handleattributes : u32, passedaccessstate : *const super::super::Foundation:: ACCESS_STATE, desiredaccess : u32, objecttype : *const super::super::Foundation:: OBJECT_TYPE, accessmode : i8, tag : u32, handle : *mut super::super::super::Win32::Foundation:: HANDLE) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ObOpenObjectByPointerWithTag(object, handleattributes, ::core::mem::transmute(passedaccessstate.unwrap_or(::std::ptr::null())), desiredaccess, ::core::mem::transmute(objecttype.unwrap_or(::std::ptr::null())), accessmode, tag, handle).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn ObQueryNameString(object: *const ::core::ffi::c_void, objectnameinfo: ::core::option::Option<*mut super::super::Foundation::OBJECT_NAME_INFORMATION>, length: u32, returnlength: *mut u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn ObQueryNameString(object : *const ::core::ffi::c_void, objectnameinfo : *mut super::super::Foundation:: OBJECT_NAME_INFORMATION, length : u32, returnlength : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ObQueryNameString(object, ::core::mem::transmute(objectnameinfo.unwrap_or(::std::ptr::null_mut())), length, returnlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn ObQueryObjectAuditingByHandle<P0>(handle: P0, generateonclose: *mut super::super::super::Win32::Foundation::BOOLEAN) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn ObQueryObjectAuditingByHandle(handle : super::super::super::Win32::Foundation:: HANDLE, generateonclose : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ObQueryObjectAuditingByHandle(handle.into_param().abi(), generateonclose).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn PfxFindPrefix(prefixtable: *const PREFIX_TABLE, fullname: *const super::super::super::Win32::System::Kernel::STRING) -> *mut PREFIX_TABLE_ENTRY {
    ::windows_targets::link!("ntdll.dll" "system" fn PfxFindPrefix(prefixtable : *const PREFIX_TABLE, fullname : *const super::super::super::Win32::System::Kernel:: STRING) -> *mut PREFIX_TABLE_ENTRY);
    PfxFindPrefix(prefixtable, fullname)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn PfxInitialize() -> PREFIX_TABLE {
    ::windows_targets::link!("ntdll.dll" "system" fn PfxInitialize(prefixtable : *mut PREFIX_TABLE) -> ());
    let mut result__ = ::std::mem::zeroed();
    PfxInitialize(&mut result__);
    ::std::mem::transmute(result__)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn PfxInsertPrefix(prefixtable: *const PREFIX_TABLE, prefix: *const super::super::super::Win32::System::Kernel::STRING, prefixtableentry: *mut PREFIX_TABLE_ENTRY) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntdll.dll" "system" fn PfxInsertPrefix(prefixtable : *const PREFIX_TABLE, prefix : *const super::super::super::Win32::System::Kernel:: STRING, prefixtableentry : *mut PREFIX_TABLE_ENTRY) -> super::super::super::Win32::Foundation:: BOOLEAN);
    PfxInsertPrefix(prefixtable, prefix, prefixtableentry)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn PfxRemovePrefix(prefixtable: *const PREFIX_TABLE, prefixtableentry: *const PREFIX_TABLE_ENTRY) {
    ::windows_targets::link!("ntdll.dll" "system" fn PfxRemovePrefix(prefixtable : *const PREFIX_TABLE, prefixtableentry : *const PREFIX_TABLE_ENTRY) -> ());
    PfxRemovePrefix(prefixtable, prefixtableentry)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn PoQueueShutdownWorkItem(workitem: *mut super::super::Foundation::WORK_QUEUE_ITEM) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn PoQueueShutdownWorkItem(workitem : *mut super::super::Foundation:: WORK_QUEUE_ITEM) -> super::super::super::Win32::Foundation:: NTSTATUS);
    PoQueueShutdownWorkItem(workitem).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn PsAssignImpersonationToken<P0>(thread: *const super::super::Foundation::KTHREAD, token: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn PsAssignImpersonationToken(thread : *const super::super::Foundation:: KTHREAD, token : super::super::super::Win32::Foundation:: HANDLE) -> super::super::super::Win32::Foundation:: NTSTATUS);
    PsAssignImpersonationToken(thread, token.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`*"]
#[cfg(feature = "Wdk_Foundation")]
#[inline]
pub unsafe fn PsChargePoolQuota(process: *const super::super::Foundation::KPROCESS, pooltype: super::super::Foundation::POOL_TYPE, amount: usize) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn PsChargePoolQuota(process : *const super::super::Foundation:: KPROCESS, pooltype : super::super::Foundation:: POOL_TYPE, amount : usize) -> ());
    PsChargePoolQuota(process, pooltype, amount)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn PsChargeProcessPoolQuota(process: *const super::super::Foundation::KPROCESS, pooltype: super::super::Foundation::POOL_TYPE, amount: usize) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn PsChargeProcessPoolQuota(process : *const super::super::Foundation:: KPROCESS, pooltype : super::super::Foundation:: POOL_TYPE, amount : usize) -> super::super::super::Win32::Foundation:: NTSTATUS);
    PsChargeProcessPoolQuota(process, pooltype, amount).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn PsDereferenceImpersonationToken(impersonationtoken: *const ::core::ffi::c_void) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn PsDereferenceImpersonationToken(impersonationtoken : *const ::core::ffi::c_void) -> ());
    PsDereferenceImpersonationToken(impersonationtoken)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn PsDereferencePrimaryToken(primarytoken: *const ::core::ffi::c_void) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn PsDereferencePrimaryToken(primarytoken : *const ::core::ffi::c_void) -> ());
    PsDereferencePrimaryToken(primarytoken)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn PsDisableImpersonation(thread: *mut super::super::Foundation::KTHREAD, impersonationstate: *mut super::super::super::Win32::Security::SE_IMPERSONATION_STATE) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn PsDisableImpersonation(thread : *mut super::super::Foundation:: KTHREAD, impersonationstate : *mut super::super::super::Win32::Security:: SE_IMPERSONATION_STATE) -> super::super::super::Win32::Foundation:: BOOLEAN);
    PsDisableImpersonation(thread, impersonationstate)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn PsGetProcessExitTime() -> i64 {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn PsGetProcessExitTime() -> i64);
    PsGetProcessExitTime()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`*"]
#[cfg(feature = "Wdk_Foundation")]
#[inline]
pub unsafe fn PsGetThreadProcess(thread: *const super::super::Foundation::KTHREAD) -> *mut super::super::Foundation::KPROCESS {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn PsGetThreadProcess(thread : *const super::super::Foundation:: KTHREAD) -> *mut super::super::Foundation:: KPROCESS);
    PsGetThreadProcess(thread)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn PsImpersonateClient<P0, P1>(thread: *mut super::super::Foundation::KTHREAD, token: ::core::option::Option<*const ::core::ffi::c_void>, copyonopen: P0, effectiveonly: P1, impersonationlevel: super::super::super::Win32::Security::SECURITY_IMPERSONATION_LEVEL) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn PsImpersonateClient(thread : *mut super::super::Foundation:: KTHREAD, token : *const ::core::ffi::c_void, copyonopen : super::super::super::Win32::Foundation:: BOOLEAN, effectiveonly : super::super::super::Win32::Foundation:: BOOLEAN, impersonationlevel : super::super::super::Win32::Security:: SECURITY_IMPERSONATION_LEVEL) -> super::super::super::Win32::Foundation:: NTSTATUS);
    PsImpersonateClient(thread, ::core::mem::transmute(token.unwrap_or(::std::ptr::null())), copyonopen.into_param().abi(), effectiveonly.into_param().abi(), impersonationlevel).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn PsIsDiskCountersEnabled() -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn PsIsDiskCountersEnabled() -> super::super::super::Win32::Foundation:: BOOLEAN);
    PsIsDiskCountersEnabled()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn PsIsSystemThread(thread: *const super::super::Foundation::KTHREAD) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn PsIsSystemThread(thread : *const super::super::Foundation:: KTHREAD) -> super::super::super::Win32::Foundation:: BOOLEAN);
    PsIsSystemThread(thread)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn PsIsThreadTerminating(thread: *const super::super::Foundation::KTHREAD) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn PsIsThreadTerminating(thread : *const super::super::Foundation:: KTHREAD) -> super::super::super::Win32::Foundation:: BOOLEAN);
    PsIsThreadTerminating(thread)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn PsLookupProcessByProcessId<P0>(processid: P0, process: *mut *mut super::super::Foundation::KPROCESS) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn PsLookupProcessByProcessId(processid : super::super::super::Win32::Foundation:: HANDLE, process : *mut *mut super::super::Foundation:: KPROCESS) -> super::super::super::Win32::Foundation:: NTSTATUS);
    PsLookupProcessByProcessId(processid.into_param().abi(), process).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn PsLookupThreadByThreadId<P0>(threadid: P0, thread: *mut *mut super::super::Foundation::KTHREAD) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn PsLookupThreadByThreadId(threadid : super::super::super::Win32::Foundation:: HANDLE, thread : *mut *mut super::super::Foundation:: KTHREAD) -> super::super::super::Win32::Foundation:: NTSTATUS);
    PsLookupThreadByThreadId(threadid.into_param().abi(), thread).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn PsReferenceImpersonationToken(thread: *mut super::super::Foundation::KTHREAD, copyonopen: *mut super::super::super::Win32::Foundation::BOOLEAN, effectiveonly: *mut super::super::super::Win32::Foundation::BOOLEAN, impersonationlevel: *mut super::super::super::Win32::Security::SECURITY_IMPERSONATION_LEVEL) -> *mut ::core::ffi::c_void {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn PsReferenceImpersonationToken(thread : *mut super::super::Foundation:: KTHREAD, copyonopen : *mut super::super::super::Win32::Foundation:: BOOLEAN, effectiveonly : *mut super::super::super::Win32::Foundation:: BOOLEAN, impersonationlevel : *mut super::super::super::Win32::Security:: SECURITY_IMPERSONATION_LEVEL) -> *mut ::core::ffi::c_void);
    PsReferenceImpersonationToken(thread, copyonopen, effectiveonly, impersonationlevel)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`*"]
#[cfg(feature = "Wdk_Foundation")]
#[inline]
pub unsafe fn PsReferencePrimaryToken(process: *mut super::super::Foundation::KPROCESS) -> *mut ::core::ffi::c_void {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn PsReferencePrimaryToken(process : *mut super::super::Foundation:: KPROCESS) -> *mut ::core::ffi::c_void);
    PsReferencePrimaryToken(process)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn PsRestoreImpersonation(thread: *mut super::super::Foundation::KTHREAD, impersonationstate: *const super::super::super::Win32::Security::SE_IMPERSONATION_STATE) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn PsRestoreImpersonation(thread : *mut super::super::Foundation:: KTHREAD, impersonationstate : *const super::super::super::Win32::Security:: SE_IMPERSONATION_STATE) -> ());
    PsRestoreImpersonation(thread, impersonationstate)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`*"]
#[cfg(feature = "Wdk_Foundation")]
#[inline]
pub unsafe fn PsReturnPoolQuota(process: *const super::super::Foundation::KPROCESS, pooltype: super::super::Foundation::POOL_TYPE, amount: usize) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn PsReturnPoolQuota(process : *const super::super::Foundation:: KPROCESS, pooltype : super::super::Foundation:: POOL_TYPE, amount : usize) -> ());
    PsReturnPoolQuota(process, pooltype, amount)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn PsRevertToSelf() {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn PsRevertToSelf() -> ());
    PsRevertToSelf()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`*"]
#[cfg(feature = "Wdk_Foundation")]
#[inline]
pub unsafe fn PsUpdateDiskCounters(process: *mut super::super::Foundation::KPROCESS, bytesread: u64, byteswritten: u64, readoperationcount: u32, writeoperationcount: u32, flushoperationcount: u32) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn PsUpdateDiskCounters(process : *mut super::super::Foundation:: KPROCESS, bytesread : u64, byteswritten : u64, readoperationcount : u32, writeoperationcount : u32, flushoperationcount : u32) -> ());
    PsUpdateDiskCounters(process, bytesread, byteswritten, readoperationcount, writeoperationcount, flushoperationcount)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn QueryContextAttributesExW(phcontext: *const SecHandle, ulattribute: u32, pbuffer: *mut ::core::ffi::c_void, cbbuffer: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("sspicli.dll" "system" fn QueryContextAttributesExW(phcontext : *const SecHandle, ulattribute : u32, pbuffer : *mut ::core::ffi::c_void, cbbuffer : u32) -> ::windows_core::HRESULT);
    QueryContextAttributesExW(phcontext, ulattribute, pbuffer, cbbuffer).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn QueryContextAttributesW(phcontext: *const SecHandle, ulattribute: u32, pbuffer: *mut ::core::ffi::c_void) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn QueryContextAttributesW(phcontext : *const SecHandle, ulattribute : u32, pbuffer : *mut ::core::ffi::c_void) -> ::windows_core::HRESULT);
    QueryContextAttributesW(phcontext, ulattribute, pbuffer).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn QueryCredentialsAttributesExW(phcredential: *const SecHandle, ulattribute: u32, pbuffer: *mut ::core::ffi::c_void, cbbuffer: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("sspicli.dll" "system" fn QueryCredentialsAttributesExW(phcredential : *const SecHandle, ulattribute : u32, pbuffer : *mut ::core::ffi::c_void, cbbuffer : u32) -> ::windows_core::HRESULT);
    QueryCredentialsAttributesExW(phcredential, ulattribute, pbuffer, cbbuffer).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn QueryCredentialsAttributesW(phcredential: *const SecHandle, ulattribute: u32, pbuffer: *mut ::core::ffi::c_void) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn QueryCredentialsAttributesW(phcredential : *const SecHandle, ulattribute : u32, pbuffer : *mut ::core::ffi::c_void) -> ::windows_core::HRESULT);
    QueryCredentialsAttributesW(phcredential, ulattribute, pbuffer).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn QuerySecurityContextToken(phcontext: *const SecHandle, token: *mut *mut ::core::ffi::c_void) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn QuerySecurityContextToken(phcontext : *const SecHandle, token : *mut *mut ::core::ffi::c_void) -> ::windows_core::HRESULT);
    QuerySecurityContextToken(phcontext, token).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn QuerySecurityPackageInfoW(ppackagename: *const super::super::super::Win32::Foundation::UNICODE_STRING) -> ::windows_core::Result<*mut SecPkgInfoW> {
    ::windows_targets::link!("secur32.dll" "system" fn QuerySecurityPackageInfoW(ppackagename : *const super::super::super::Win32::Foundation:: UNICODE_STRING, pppackageinfo : *mut *mut SecPkgInfoW) -> ::windows_core::HRESULT);
    let mut result__ = ::std::mem::zeroed();
    QuerySecurityPackageInfoW(ppackagename, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn RevertSecurityContext(phcontext: *const SecHandle) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn RevertSecurityContext(phcontext : *const SecHandle) -> ::windows_core::HRESULT);
    RevertSecurityContext(phcontext).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn RtlAbsoluteToSelfRelativeSD<P0>(absolutesecuritydescriptor: P0, selfrelativesecuritydescriptor: super::super::super::Win32::Security::PSECURITY_DESCRIPTOR, bufferlength: *mut u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlAbsoluteToSelfRelativeSD(absolutesecuritydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, selfrelativesecuritydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, bufferlength : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlAbsoluteToSelfRelativeSD(absolutesecuritydescriptor.into_param().abi(), selfrelativesecuritydescriptor, bufferlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn RtlAddAccessAllowedAce<P0>(acl: *mut super::super::super::Win32::Security::ACL, acerevision: u32, accessmask: u32, sid: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlAddAccessAllowedAce(acl : *mut super::super::super::Win32::Security:: ACL, acerevision : u32, accessmask : u32, sid : super::super::super::Win32::Foundation:: PSID) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlAddAccessAllowedAce(acl, acerevision, accessmask, sid.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn RtlAddAccessAllowedAceEx<P0>(acl: *mut super::super::super::Win32::Security::ACL, acerevision: u32, aceflags: u32, accessmask: u32, sid: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlAddAccessAllowedAceEx(acl : *mut super::super::super::Win32::Security:: ACL, acerevision : u32, aceflags : u32, accessmask : u32, sid : super::super::super::Win32::Foundation:: PSID) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlAddAccessAllowedAceEx(acl, acerevision, aceflags, accessmask, sid.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn RtlAddAce(acl: *mut super::super::super::Win32::Security::ACL, acerevision: u32, startingaceindex: u32, acelist: *const ::core::ffi::c_void, acelistlength: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlAddAce(acl : *mut super::super::super::Win32::Security:: ACL, acerevision : u32, startingaceindex : u32, acelist : *const ::core::ffi::c_void, acelistlength : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlAddAce(acl, acerevision, startingaceindex, acelist, acelistlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlAllocateAndInitializeSid(identifierauthority: *const SID_IDENTIFIER_AUTHORITY, subauthoritycount: u8, subauthority0: u32, subauthority1: u32, subauthority2: u32, subauthority3: u32, subauthority4: u32, subauthority5: u32, subauthority6: u32, subauthority7: u32, sid: *mut super::super::super::Win32::Foundation::PSID) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlAllocateAndInitializeSid(identifierauthority : *const SID_IDENTIFIER_AUTHORITY, subauthoritycount : u8, subauthority0 : u32, subauthority1 : u32, subauthority2 : u32, subauthority3 : u32, subauthority4 : u32, subauthority5 : u32, subauthority6 : u32, subauthority7 : u32, sid : *mut super::super::super::Win32::Foundation:: PSID) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlAllocateAndInitializeSid(identifierauthority, subauthoritycount, subauthority0, subauthority1, subauthority2, subauthority3, subauthority4, subauthority5, subauthority6, subauthority7, sid).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlAllocateAndInitializeSidEx(identifierauthority: *const SID_IDENTIFIER_AUTHORITY, subauthorities: &[u32], sid: *mut super::super::super::Win32::Foundation::PSID) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlAllocateAndInitializeSidEx(identifierauthority : *const SID_IDENTIFIER_AUTHORITY, subauthoritycount : u8, subauthorities : *const u32, sid : *mut super::super::super::Win32::Foundation:: PSID) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlAllocateAndInitializeSidEx(identifierauthority, subauthorities.len() as _, ::core::mem::transmute(subauthorities.as_ptr()), sid).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn RtlAllocateHeap(heaphandle: *const ::core::ffi::c_void, flags: u32, size: usize) -> *mut ::core::ffi::c_void {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlAllocateHeap(heaphandle : *const ::core::ffi::c_void, flags : u32, size : usize) -> *mut ::core::ffi::c_void);
    RtlAllocateHeap(heaphandle, flags, size)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn RtlAppendStringToString(destination: *mut super::super::super::Win32::System::Kernel::STRING, source: *const super::super::super::Win32::System::Kernel::STRING) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlAppendStringToString(destination : *mut super::super::super::Win32::System::Kernel:: STRING, source : *const super::super::super::Win32::System::Kernel:: STRING) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlAppendStringToString(destination, source).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn RtlCaptureStackBackTrace(framestoskip: u32, backtrace: &mut [*mut ::core::ffi::c_void], backtracehash: ::core::option::Option<*mut u32>) -> u16 {
    ::windows_targets::link!("kernel32.dll" "system" fn RtlCaptureStackBackTrace(framestoskip : u32, framestocapture : u32, backtrace : *mut *mut ::core::ffi::c_void, backtracehash : *mut u32) -> u16);
    RtlCaptureStackBackTrace(framestoskip, backtrace.len() as _, ::core::mem::transmute(backtrace.as_ptr()), ::core::mem::transmute(backtracehash.unwrap_or(::std::ptr::null_mut())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlCompareAltitudes(altitude1: *const super::super::super::Win32::Foundation::UNICODE_STRING, altitude2: *const super::super::super::Win32::Foundation::UNICODE_STRING) -> i32 {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlCompareAltitudes(altitude1 : *const super::super::super::Win32::Foundation:: UNICODE_STRING, altitude2 : *const super::super::super::Win32::Foundation:: UNICODE_STRING) -> i32);
    RtlCompareAltitudes(altitude1, altitude2)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn RtlCompareMemoryUlong(source: *const ::core::ffi::c_void, length: usize, pattern: u32) -> usize {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlCompareMemoryUlong(source : *const ::core::ffi::c_void, length : usize, pattern : u32) -> usize);
    RtlCompareMemoryUlong(source, length, pattern)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlCompressBuffer(compressionformatandengine: u16, uncompressedbuffer: &[u8], compressedbuffer: &mut [u8], uncompressedchunksize: u32, finalcompressedsize: *mut u32, workspace: *const ::core::ffi::c_void) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlCompressBuffer(compressionformatandengine : u16, uncompressedbuffer : *const u8, uncompressedbuffersize : u32, compressedbuffer : *mut u8, compressedbuffersize : u32, uncompressedchunksize : u32, finalcompressedsize : *mut u32, workspace : *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlCompressBuffer(compressionformatandengine, ::core::mem::transmute(uncompressedbuffer.as_ptr()), uncompressedbuffer.len() as _, ::core::mem::transmute(compressedbuffer.as_ptr()), compressedbuffer.len() as _, uncompressedchunksize, finalcompressedsize, workspace).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlCompressChunks(uncompressedbuffer: &[u8], compressedbuffer: &mut [u8], compresseddatainfo: *mut COMPRESSED_DATA_INFO, compresseddatainfolength: u32, workspace: *const ::core::ffi::c_void) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn RtlCompressChunks(uncompressedbuffer : *const u8, uncompressedbuffersize : u32, compressedbuffer : *mut u8, compressedbuffersize : u32, compresseddatainfo : *mut COMPRESSED_DATA_INFO, compresseddatainfolength : u32, workspace : *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlCompressChunks(::core::mem::transmute(uncompressedbuffer.as_ptr()), uncompressedbuffer.len() as _, ::core::mem::transmute(compressedbuffer.as_ptr()), compressedbuffer.len() as _, compresseddatainfo, compresseddatainfolength, workspace).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlConvertSidToUnicodeString<P0, P1>(unicodestring: *mut super::super::super::Win32::Foundation::UNICODE_STRING, sid: P0, allocatedestinationstring: P1) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlConvertSidToUnicodeString(unicodestring : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, sid : super::super::super::Win32::Foundation:: PSID, allocatedestinationstring : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlConvertSidToUnicodeString(unicodestring, sid.into_param().abi(), allocatedestinationstring.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlCopyLuid(destinationluid: *mut super::super::super::Win32::Foundation::LUID, sourceluid: *const super::super::super::Win32::Foundation::LUID) {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlCopyLuid(destinationluid : *mut super::super::super::Win32::Foundation:: LUID, sourceluid : *const super::super::super::Win32::Foundation:: LUID) -> ());
    RtlCopyLuid(destinationluid, sourceluid)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlCopySid<P0>(destinationsidlength: u32, destinationsid: super::super::super::Win32::Foundation::PSID, sourcesid: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlCopySid(destinationsidlength : u32, destinationsid : super::super::super::Win32::Foundation:: PSID, sourcesid : super::super::super::Win32::Foundation:: PSID) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlCopySid(destinationsidlength, destinationsid, sourcesid.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn RtlCreateAcl(acl: *mut super::super::super::Win32::Security::ACL, acllength: u32, aclrevision: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlCreateAcl(acl : *mut super::super::super::Win32::Security:: ACL, acllength : u32, aclrevision : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlCreateAcl(acl, acllength, aclrevision).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlCreateHeap(flags: u32, heapbase: ::core::option::Option<*const ::core::ffi::c_void>, reservesize: usize, commitsize: usize, lock: ::core::option::Option<*const ::core::ffi::c_void>, parameters: ::core::option::Option<*const RTL_HEAP_PARAMETERS>) -> *mut ::core::ffi::c_void {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlCreateHeap(flags : u32, heapbase : *const ::core::ffi::c_void, reservesize : usize, commitsize : usize, lock : *const ::core::ffi::c_void, parameters : *const RTL_HEAP_PARAMETERS) -> *mut ::core::ffi::c_void);
    RtlCreateHeap(flags, ::core::mem::transmute(heapbase.unwrap_or(::std::ptr::null())), reservesize, commitsize, ::core::mem::transmute(lock.unwrap_or(::std::ptr::null())), ::core::mem::transmute(parameters.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlCreateServiceSid(servicename: *const super::super::super::Win32::Foundation::UNICODE_STRING, servicesid: super::super::super::Win32::Foundation::PSID, servicesidlength: *mut u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlCreateServiceSid(servicename : *const super::super::super::Win32::Foundation:: UNICODE_STRING, servicesid : super::super::super::Win32::Foundation:: PSID, servicesidlength : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlCreateServiceSid(servicename, servicesid, servicesidlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlCreateSystemVolumeInformationFolder(volumerootpath: *const super::super::super::Win32::Foundation::UNICODE_STRING) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlCreateSystemVolumeInformationFolder(volumerootpath : *const super::super::super::Win32::Foundation:: UNICODE_STRING) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlCreateSystemVolumeInformationFolder(volumerootpath).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlCreateUnicodeString<P0>(destinationstring: *mut super::super::super::Win32::Foundation::UNICODE_STRING, sourcestring: P0) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<::windows_core::PCWSTR>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlCreateUnicodeString(destinationstring : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, sourcestring : ::windows_core::PCWSTR) -> super::super::super::Win32::Foundation:: BOOLEAN);
    RtlCreateUnicodeString(destinationstring, sourcestring.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlCreateVirtualAccountSid(name: *const super::super::super::Win32::Foundation::UNICODE_STRING, basesubauthority: u32, sid: super::super::super::Win32::Foundation::PSID, sidlength: *mut u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlCreateVirtualAccountSid(name : *const super::super::super::Win32::Foundation:: UNICODE_STRING, basesubauthority : u32, sid : super::super::super::Win32::Foundation:: PSID, sidlength : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlCreateVirtualAccountSid(name, basesubauthority, sid, sidlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlCustomCPToUnicodeN(customcp: *const CPTABLEINFO, unicodestring: ::windows_core::PWSTR, maxbytesinunicodestring: u32, bytesinunicodestring: ::core::option::Option<*mut u32>, customcpstring: &[u8]) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlCustomCPToUnicodeN(customcp : *const CPTABLEINFO, unicodestring : ::windows_core::PWSTR, maxbytesinunicodestring : u32, bytesinunicodestring : *mut u32, customcpstring : ::windows_core::PCSTR, bytesincustomcpstring : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlCustomCPToUnicodeN(customcp, ::core::mem::transmute(unicodestring), maxbytesinunicodestring, ::core::mem::transmute(bytesinunicodestring.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(customcpstring.as_ptr()), customcpstring.len() as _).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlDecompressBuffer(compressionformat: u16, uncompressedbuffer: &mut [u8], compressedbuffer: &[u8], finaluncompressedsize: *mut u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlDecompressBuffer(compressionformat : u16, uncompressedbuffer : *mut u8, uncompressedbuffersize : u32, compressedbuffer : *const u8, compressedbuffersize : u32, finaluncompressedsize : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlDecompressBuffer(compressionformat, ::core::mem::transmute(uncompressedbuffer.as_ptr()), uncompressedbuffer.len() as _, ::core::mem::transmute(compressedbuffer.as_ptr()), compressedbuffer.len() as _, finaluncompressedsize).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlDecompressBufferEx(compressionformat: u16, uncompressedbuffer: &mut [u8], compressedbuffer: &[u8], finaluncompressedsize: *mut u32, workspace: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlDecompressBufferEx(compressionformat : u16, uncompressedbuffer : *mut u8, uncompressedbuffersize : u32, compressedbuffer : *const u8, compressedbuffersize : u32, finaluncompressedsize : *mut u32, workspace : *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlDecompressBufferEx(compressionformat, ::core::mem::transmute(uncompressedbuffer.as_ptr()), uncompressedbuffer.len() as _, ::core::mem::transmute(compressedbuffer.as_ptr()), compressedbuffer.len() as _, finaluncompressedsize, ::core::mem::transmute(workspace.unwrap_or(::std::ptr::null()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlDecompressBufferEx2(compressionformat: u16, uncompressedbuffer: &mut [u8], compressedbuffer: &[u8], uncompressedchunksize: u32, finaluncompressedsize: *mut u32, workspace: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn RtlDecompressBufferEx2(compressionformat : u16, uncompressedbuffer : *mut u8, uncompressedbuffersize : u32, compressedbuffer : *const u8, compressedbuffersize : u32, uncompressedchunksize : u32, finaluncompressedsize : *mut u32, workspace : *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlDecompressBufferEx2(compressionformat, ::core::mem::transmute(uncompressedbuffer.as_ptr()), uncompressedbuffer.len() as _, ::core::mem::transmute(compressedbuffer.as_ptr()), compressedbuffer.len() as _, uncompressedchunksize, finaluncompressedsize, ::core::mem::transmute(workspace.unwrap_or(::std::ptr::null()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlDecompressChunks(uncompressedbuffer: &mut [u8], compressedbuffer: &[u8], compressedtail: &[u8], compresseddatainfo: *const COMPRESSED_DATA_INFO) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn RtlDecompressChunks(uncompressedbuffer : *mut u8, uncompressedbuffersize : u32, compressedbuffer : *const u8, compressedbuffersize : u32, compressedtail : *const u8, compressedtailsize : u32, compresseddatainfo : *const COMPRESSED_DATA_INFO) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlDecompressChunks(::core::mem::transmute(uncompressedbuffer.as_ptr()), uncompressedbuffer.len() as _, ::core::mem::transmute(compressedbuffer.as_ptr()), compressedbuffer.len() as _, ::core::mem::transmute(compressedtail.as_ptr()), compressedtail.len() as _, compresseddatainfo).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlDecompressFragment(compressionformat: u16, uncompressedfragment: &mut [u8], compressedbuffer: &[u8], fragmentoffset: u32, finaluncompressedsize: *mut u32, workspace: *const ::core::ffi::c_void) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlDecompressFragment(compressionformat : u16, uncompressedfragment : *mut u8, uncompressedfragmentsize : u32, compressedbuffer : *const u8, compressedbuffersize : u32, fragmentoffset : u32, finaluncompressedsize : *mut u32, workspace : *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlDecompressFragment(compressionformat, ::core::mem::transmute(uncompressedfragment.as_ptr()), uncompressedfragment.len() as _, ::core::mem::transmute(compressedbuffer.as_ptr()), compressedbuffer.len() as _, fragmentoffset, finaluncompressedsize, workspace).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlDecompressFragmentEx(compressionformat: u16, uncompressedfragment: &mut [u8], compressedbuffer: &[u8], fragmentoffset: u32, uncompressedchunksize: u32, finaluncompressedsize: *mut u32, workspace: *const ::core::ffi::c_void) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn RtlDecompressFragmentEx(compressionformat : u16, uncompressedfragment : *mut u8, uncompressedfragmentsize : u32, compressedbuffer : *const u8, compressedbuffersize : u32, fragmentoffset : u32, uncompressedchunksize : u32, finaluncompressedsize : *mut u32, workspace : *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlDecompressFragmentEx(compressionformat, ::core::mem::transmute(uncompressedfragment.as_ptr()), uncompressedfragment.len() as _, ::core::mem::transmute(compressedbuffer.as_ptr()), compressedbuffer.len() as _, fragmentoffset, uncompressedchunksize, finaluncompressedsize, workspace).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn RtlDeleteAce(acl: *mut super::super::super::Win32::Security::ACL, aceindex: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlDeleteAce(acl : *mut super::super::super::Win32::Security:: ACL, aceindex : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlDeleteAce(acl, aceindex).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlDescribeChunk(compressionformat: u16, compressedbuffer: *mut *mut u8, endofcompressedbufferplus1: *const u8, chunkbuffer: *mut *mut u8, chunksize: *mut u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn RtlDescribeChunk(compressionformat : u16, compressedbuffer : *mut *mut u8, endofcompressedbufferplus1 : *const u8, chunkbuffer : *mut *mut u8, chunksize : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlDescribeChunk(compressionformat, compressedbuffer, endofcompressedbufferplus1, chunkbuffer, chunksize).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn RtlDestroyHeap(heaphandle: *const ::core::ffi::c_void) -> *mut ::core::ffi::c_void {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlDestroyHeap(heaphandle : *const ::core::ffi::c_void) -> *mut ::core::ffi::c_void);
    RtlDestroyHeap(heaphandle)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlDowncaseUnicodeString<P0>(destinationstring: *mut super::super::super::Win32::Foundation::UNICODE_STRING, sourcestring: *const super::super::super::Win32::Foundation::UNICODE_STRING, allocatedestinationstring: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlDowncaseUnicodeString(destinationstring : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, sourcestring : *const super::super::super::Win32::Foundation:: UNICODE_STRING, allocatedestinationstring : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlDowncaseUnicodeString(destinationstring, sourcestring, allocatedestinationstring.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlDuplicateUnicodeString(flags: u32, stringin: *const super::super::super::Win32::Foundation::UNICODE_STRING, stringout: *mut super::super::super::Win32::Foundation::UNICODE_STRING) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlDuplicateUnicodeString(flags : u32, stringin : *const super::super::super::Win32::Foundation:: UNICODE_STRING, stringout : *mut super::super::super::Win32::Foundation:: UNICODE_STRING) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlDuplicateUnicodeString(flags, stringin, stringout).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlEqualPrefixSid<P0, P1>(sid1: P0, sid2: P1) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlEqualPrefixSid(sid1 : super::super::super::Win32::Foundation:: PSID, sid2 : super::super::super::Win32::Foundation:: PSID) -> super::super::super::Win32::Foundation:: BOOLEAN);
    RtlEqualPrefixSid(sid1.into_param().abi(), sid2.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlEqualSid<P0, P1>(sid1: P0, sid2: P1) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlEqualSid(sid1 : super::super::super::Win32::Foundation:: PSID, sid2 : super::super::super::Win32::Foundation:: PSID) -> super::super::super::Win32::Foundation:: BOOLEAN);
    RtlEqualSid(sid1.into_param().abi(), sid2.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn RtlFindUnicodePrefix(prefixtable: *const UNICODE_PREFIX_TABLE, fullname: *const super::super::super::Win32::Foundation::UNICODE_STRING, caseinsensitiveindex: u32) -> *mut UNICODE_PREFIX_TABLE_ENTRY {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn RtlFindUnicodePrefix(prefixtable : *const UNICODE_PREFIX_TABLE, fullname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, caseinsensitiveindex : u32) -> *mut UNICODE_PREFIX_TABLE_ENTRY);
    RtlFindUnicodePrefix(prefixtable, fullname, caseinsensitiveindex)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn RtlFreeHeap(heaphandle: *const ::core::ffi::c_void, flags: u32, baseaddress: ::core::option::Option<*const ::core::ffi::c_void>) -> u32 {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlFreeHeap(heaphandle : *const ::core::ffi::c_void, flags : u32, baseaddress : *const ::core::ffi::c_void) -> u32);
    RtlFreeHeap(heaphandle, flags, ::core::mem::transmute(baseaddress.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(feature = "Win32_System_Kernel")]
#[inline]
pub unsafe fn RtlFreeOemString(oemstring: ::core::option::Option<*mut super::super::super::Win32::System::Kernel::STRING>) {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlFreeOemString(oemstring : *mut super::super::super::Win32::System::Kernel:: STRING) -> ());
    RtlFreeOemString(::core::mem::transmute(oemstring.unwrap_or(::std::ptr::null_mut())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlFreeSid<P0>(sid: P0) -> *mut ::core::ffi::c_void
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlFreeSid(sid : super::super::super::Win32::Foundation:: PSID) -> *mut ::core::ffi::c_void);
    RtlFreeSid(sid.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlGenerate8dot3Name<P0>(name: *const super::super::super::Win32::Foundation::UNICODE_STRING, allowextendedcharacters: P0, context: *mut GENERATE_NAME_CONTEXT, name8dot3: *mut super::super::super::Win32::Foundation::UNICODE_STRING) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlGenerate8dot3Name(name : *const super::super::super::Win32::Foundation:: UNICODE_STRING, allowextendedcharacters : super::super::super::Win32::Foundation:: BOOLEAN, context : *mut GENERATE_NAME_CONTEXT, name8dot3 : *mut super::super::super::Win32::Foundation:: UNICODE_STRING) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlGenerate8dot3Name(name, allowextendedcharacters.into_param().abi(), context, name8dot3).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn RtlGetAce(acl: *const super::super::super::Win32::Security::ACL, aceindex: u32, ace: *mut *mut ::core::ffi::c_void) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlGetAce(acl : *const super::super::super::Win32::Security:: ACL, aceindex : u32, ace : *mut *mut ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlGetAce(acl, aceindex, ace).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlGetCompressionWorkSpaceSize(compressionformatandengine: u16, compressbufferworkspacesize: *mut u32, compressfragmentworkspacesize: *mut u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlGetCompressionWorkSpaceSize(compressionformatandengine : u16, compressbufferworkspacesize : *mut u32, compressfragmentworkspacesize : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlGetCompressionWorkSpaceSize(compressionformatandengine, compressbufferworkspacesize, compressfragmentworkspacesize).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn RtlGetDaclSecurityDescriptor<P0>(securitydescriptor: P0, daclpresent: *mut super::super::super::Win32::Foundation::BOOLEAN, dacl: *mut *mut super::super::super::Win32::Security::ACL, dacldefaulted: *mut super::super::super::Win32::Foundation::BOOLEAN) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlGetDaclSecurityDescriptor(securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, daclpresent : *mut super::super::super::Win32::Foundation:: BOOLEAN, dacl : *mut *mut super::super::super::Win32::Security:: ACL, dacldefaulted : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlGetDaclSecurityDescriptor(securitydescriptor.into_param().abi(), daclpresent, dacl, dacldefaulted).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn RtlGetGroupSecurityDescriptor<P0>(securitydescriptor: P0, group: *mut super::super::super::Win32::Foundation::PSID, groupdefaulted: *mut super::super::super::Win32::Foundation::BOOLEAN) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlGetGroupSecurityDescriptor(securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, group : *mut super::super::super::Win32::Foundation:: PSID, groupdefaulted : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlGetGroupSecurityDescriptor(securitydescriptor.into_param().abi(), group, groupdefaulted).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn RtlGetOwnerSecurityDescriptor<P0>(securitydescriptor: P0, owner: *mut super::super::super::Win32::Foundation::PSID, ownerdefaulted: *mut super::super::super::Win32::Foundation::BOOLEAN) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlGetOwnerSecurityDescriptor(securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, owner : *mut super::super::super::Win32::Foundation:: PSID, ownerdefaulted : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlGetOwnerSecurityDescriptor(securitydescriptor.into_param().abi(), owner, ownerdefaulted).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn RtlGetSaclSecurityDescriptor<P0>(securitydescriptor: P0, saclpresent: *mut super::super::super::Win32::Foundation::BOOLEAN, sacl: *mut *mut super::super::super::Win32::Security::ACL, sacldefaulted: *mut super::super::super::Win32::Foundation::BOOLEAN) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlGetSaclSecurityDescriptor(securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, saclpresent : *mut super::super::super::Win32::Foundation:: BOOLEAN, sacl : *mut *mut super::super::super::Win32::Security:: ACL, sacldefaulted : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlGetSaclSecurityDescriptor(securitydescriptor.into_param().abi(), saclpresent, sacl, sacldefaulted).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlIdentifierAuthoritySid<P0>(sid: P0) -> *mut SID_IDENTIFIER_AUTHORITY
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlIdentifierAuthoritySid(sid : super::super::super::Win32::Foundation:: PSID) -> *mut SID_IDENTIFIER_AUTHORITY);
    RtlIdentifierAuthoritySid(sid.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlIdnToAscii<P0>(flags: u32, sourcestring: P0, sourcestringlength: i32, destinationstring: ::windows_core::PWSTR, destinationstringlength: *mut i32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<::windows_core::PCWSTR>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlIdnToAscii(flags : u32, sourcestring : ::windows_core::PCWSTR, sourcestringlength : i32, destinationstring : ::windows_core::PWSTR, destinationstringlength : *mut i32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlIdnToAscii(flags, sourcestring.into_param().abi(), sourcestringlength, ::core::mem::transmute(destinationstring), destinationstringlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlIdnToNameprepUnicode<P0>(flags: u32, sourcestring: P0, sourcestringlength: i32, destinationstring: ::windows_core::PWSTR, destinationstringlength: *mut i32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<::windows_core::PCWSTR>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlIdnToNameprepUnicode(flags : u32, sourcestring : ::windows_core::PCWSTR, sourcestringlength : i32, destinationstring : ::windows_core::PWSTR, destinationstringlength : *mut i32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlIdnToNameprepUnicode(flags, sourcestring.into_param().abi(), sourcestringlength, ::core::mem::transmute(destinationstring), destinationstringlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlIdnToUnicode<P0>(flags: u32, sourcestring: P0, sourcestringlength: i32, destinationstring: ::windows_core::PWSTR, destinationstringlength: *mut i32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<::windows_core::PCWSTR>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlIdnToUnicode(flags : u32, sourcestring : ::windows_core::PCWSTR, sourcestringlength : i32, destinationstring : ::windows_core::PWSTR, destinationstringlength : *mut i32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlIdnToUnicode(flags, sourcestring.into_param().abi(), sourcestringlength, ::core::mem::transmute(destinationstring), destinationstringlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn RtlInitCodePageTable(tablebase: ::core::option::Option<&[u16; 2]>, codepagetable: *mut CPTABLEINFO) {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlInitCodePageTable(tablebase : *const u16, codepagetable : *mut CPTABLEINFO) -> ());
    RtlInitCodePageTable(::core::mem::transmute(tablebase.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr())), codepagetable)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlInitUnicodeStringEx<P0>(destinationstring: *mut super::super::super::Win32::Foundation::UNICODE_STRING, sourcestring: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<::windows_core::PCWSTR>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlInitUnicodeStringEx(destinationstring : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, sourcestring : ::windows_core::PCWSTR) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlInitUnicodeStringEx(destinationstring, sourcestring.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlInitializeSid(sid: super::super::super::Win32::Foundation::PSID, identifierauthority: *const SID_IDENTIFIER_AUTHORITY, subauthoritycount: u8) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlInitializeSid(sid : super::super::super::Win32::Foundation:: PSID, identifierauthority : *const SID_IDENTIFIER_AUTHORITY, subauthoritycount : u8) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlInitializeSid(sid, identifierauthority, subauthoritycount).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlInitializeSidEx(sid: super::super::super::Win32::Foundation::PSID, identifierauthority: *const SID_IDENTIFIER_AUTHORITY, subauthoritycount: u8) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "cdecl" fn RtlInitializeSidEx(sid : super::super::super::Win32::Foundation:: PSID, identifierauthority : *const SID_IDENTIFIER_AUTHORITY, subauthoritycount : u8) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlInitializeSidEx(sid, identifierauthority, subauthoritycount).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn RtlInitializeUnicodePrefix() -> UNICODE_PREFIX_TABLE {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn RtlInitializeUnicodePrefix(prefixtable : *mut UNICODE_PREFIX_TABLE) -> ());
    let mut result__ = ::std::mem::zeroed();
    RtlInitializeUnicodePrefix(&mut result__);
    ::std::mem::transmute(result__)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn RtlInsertUnicodePrefix(prefixtable: *const UNICODE_PREFIX_TABLE, prefix: *const super::super::super::Win32::Foundation::UNICODE_STRING, prefixtableentry: *mut UNICODE_PREFIX_TABLE_ENTRY) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn RtlInsertUnicodePrefix(prefixtable : *const UNICODE_PREFIX_TABLE, prefix : *const super::super::super::Win32::Foundation:: UNICODE_STRING, prefixtableentry : *mut UNICODE_PREFIX_TABLE_ENTRY) -> super::super::super::Win32::Foundation:: BOOLEAN);
    RtlInsertUnicodePrefix(prefixtable, prefix, prefixtableentry)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlIsCloudFilesPlaceholder(fileattributes: u32, reparsetag: u32) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlIsCloudFilesPlaceholder(fileattributes : u32, reparsetag : u32) -> super::super::super::Win32::Foundation:: BOOLEAN);
    RtlIsCloudFilesPlaceholder(fileattributes, reparsetag)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn RtlIsNameLegalDOS8Dot3(name: *const super::super::super::Win32::Foundation::UNICODE_STRING, oemname: ::core::option::Option<*mut super::super::super::Win32::System::Kernel::STRING>, namecontainsspaces: ::core::option::Option<*mut super::super::super::Win32::Foundation::BOOLEAN>) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlIsNameLegalDOS8Dot3(name : *const super::super::super::Win32::Foundation:: UNICODE_STRING, oemname : *mut super::super::super::Win32::System::Kernel:: STRING, namecontainsspaces : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: BOOLEAN);
    RtlIsNameLegalDOS8Dot3(name, ::core::mem::transmute(oemname.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(namecontainsspaces.unwrap_or(::std::ptr::null_mut())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlIsNonEmptyDirectoryReparsePointAllowed(reparsetag: u32) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlIsNonEmptyDirectoryReparsePointAllowed(reparsetag : u32) -> super::super::super::Win32::Foundation:: BOOLEAN);
    RtlIsNonEmptyDirectoryReparsePointAllowed(reparsetag)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlIsNormalizedString<P0>(normform: u32, sourcestring: P0, sourcestringlength: i32, normalized: *mut super::super::super::Win32::Foundation::BOOLEAN) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<::windows_core::PCWSTR>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlIsNormalizedString(normform : u32, sourcestring : ::windows_core::PCWSTR, sourcestringlength : i32, normalized : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlIsNormalizedString(normform, sourcestring.into_param().abi(), sourcestringlength, normalized).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlIsPartialPlaceholder(fileattributes: u32, reparsetag: u32) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlIsPartialPlaceholder(fileattributes : u32, reparsetag : u32) -> super::super::super::Win32::Foundation:: BOOLEAN);
    RtlIsPartialPlaceholder(fileattributes, reparsetag)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlIsPartialPlaceholderFileHandle<P0>(filehandle: P0, ispartialplaceholder: *mut super::super::super::Win32::Foundation::BOOLEAN) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlIsPartialPlaceholderFileHandle(filehandle : super::super::super::Win32::Foundation:: HANDLE, ispartialplaceholder : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlIsPartialPlaceholderFileHandle(filehandle.into_param().abi(), ispartialplaceholder).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn RtlIsPartialPlaceholderFileInfo(infobuffer: *const ::core::ffi::c_void, infoclass: super::super::super::Win32::System::WindowsProgramming::FILE_INFORMATION_CLASS, ispartialplaceholder: *mut super::super::super::Win32::Foundation::BOOLEAN) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlIsPartialPlaceholderFileInfo(infobuffer : *const ::core::ffi::c_void, infoclass : super::super::super::Win32::System::WindowsProgramming:: FILE_INFORMATION_CLASS, ispartialplaceholder : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlIsPartialPlaceholderFileInfo(infobuffer, infoclass, ispartialplaceholder).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn RtlIsSandboxedToken(context: ::core::option::Option<*const super::super::Foundation::SECURITY_SUBJECT_CONTEXT>, previousmode: i8) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn RtlIsSandboxedToken(context : *const super::super::Foundation:: SECURITY_SUBJECT_CONTEXT, previousmode : i8) -> super::super::super::Win32::Foundation:: BOOLEAN);
    RtlIsSandboxedToken(::core::mem::transmute(context.unwrap_or(::std::ptr::null())), previousmode)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlIsValidOemCharacter(char: ::windows_core::PWSTR) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn RtlIsValidOemCharacter(char : ::windows_core::PWSTR) -> super::super::super::Win32::Foundation:: BOOLEAN);
    RtlIsValidOemCharacter(::core::mem::transmute(char))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn RtlLengthRequiredSid(subauthoritycount: u32) -> u32 {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlLengthRequiredSid(subauthoritycount : u32) -> u32);
    RtlLengthRequiredSid(subauthoritycount)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlLengthSid<P0>(sid: P0) -> u32
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlLengthSid(sid : super::super::super::Win32::Foundation:: PSID) -> u32);
    RtlLengthSid(sid.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlMultiByteToUnicodeN(unicodestring: ::windows_core::PWSTR, maxbytesinunicodestring: u32, bytesinunicodestring: ::core::option::Option<*mut u32>, multibytestring: &[u8]) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlMultiByteToUnicodeN(unicodestring : ::windows_core::PWSTR, maxbytesinunicodestring : u32, bytesinunicodestring : *mut u32, multibytestring : ::windows_core::PCSTR, bytesinmultibytestring : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlMultiByteToUnicodeN(::core::mem::transmute(unicodestring), maxbytesinunicodestring, ::core::mem::transmute(bytesinunicodestring.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(multibytestring.as_ptr()), multibytestring.len() as _).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlMultiByteToUnicodeSize(bytesinunicodestring: *mut u32, multibytestring: &[u8]) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlMultiByteToUnicodeSize(bytesinunicodestring : *mut u32, multibytestring : ::windows_core::PCSTR, bytesinmultibytestring : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlMultiByteToUnicodeSize(bytesinunicodestring, ::core::mem::transmute(multibytestring.as_ptr()), multibytestring.len() as _).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn RtlNextUnicodePrefix<P0>(prefixtable: *const UNICODE_PREFIX_TABLE, restart: P0) -> *mut UNICODE_PREFIX_TABLE_ENTRY
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn RtlNextUnicodePrefix(prefixtable : *const UNICODE_PREFIX_TABLE, restart : super::super::super::Win32::Foundation:: BOOLEAN) -> *mut UNICODE_PREFIX_TABLE_ENTRY);
    RtlNextUnicodePrefix(prefixtable, restart.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlNormalizeString<P0>(normform: u32, sourcestring: P0, sourcestringlength: i32, destinationstring: ::windows_core::PWSTR, destinationstringlength: *mut i32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<::windows_core::PCWSTR>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlNormalizeString(normform : u32, sourcestring : ::windows_core::PCWSTR, sourcestringlength : i32, destinationstring : ::windows_core::PWSTR, destinationstringlength : *mut i32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlNormalizeString(normform, sourcestring.into_param().abi(), sourcestringlength, ::core::mem::transmute(destinationstring), destinationstringlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlNtStatusToDosError<P0>(status: P0) -> u32
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::NTSTATUS>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlNtStatusToDosError(status : super::super::super::Win32::Foundation:: NTSTATUS) -> u32);
    RtlNtStatusToDosError(status.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlNtStatusToDosErrorNoTeb<P0>(status: P0) -> u32
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::NTSTATUS>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlNtStatusToDosErrorNoTeb(status : super::super::super::Win32::Foundation:: NTSTATUS) -> u32);
    RtlNtStatusToDosErrorNoTeb(status.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn RtlOemStringToCountedUnicodeString<P0>(destinationstring: *mut super::super::super::Win32::Foundation::UNICODE_STRING, sourcestring: *const super::super::super::Win32::System::Kernel::STRING, allocatedestinationstring: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn RtlOemStringToCountedUnicodeString(destinationstring : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, sourcestring : *const super::super::super::Win32::System::Kernel:: STRING, allocatedestinationstring : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlOemStringToCountedUnicodeString(destinationstring, sourcestring, allocatedestinationstring.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn RtlOemStringToUnicodeString<P0>(destinationstring: *mut super::super::super::Win32::Foundation::UNICODE_STRING, sourcestring: *const super::super::super::Win32::System::Kernel::STRING, allocatedestinationstring: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlOemStringToUnicodeString(destinationstring : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, sourcestring : *const super::super::super::Win32::System::Kernel:: STRING, allocatedestinationstring : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlOemStringToUnicodeString(destinationstring, sourcestring, allocatedestinationstring.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlOemToUnicodeN(unicodestring: ::windows_core::PWSTR, maxbytesinunicodestring: u32, bytesinunicodestring: ::core::option::Option<*mut u32>, oemstring: &[u8]) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlOemToUnicodeN(unicodestring : ::windows_core::PWSTR, maxbytesinunicodestring : u32, bytesinunicodestring : *mut u32, oemstring : ::windows_core::PCSTR, bytesinoemstring : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlOemToUnicodeN(::core::mem::transmute(unicodestring), maxbytesinunicodestring, ::core::mem::transmute(bytesinunicodestring.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(oemstring.as_ptr()), oemstring.len() as _).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn RtlPrefixString<P0>(string1: *const super::super::super::Win32::System::Kernel::STRING, string2: *const super::super::super::Win32::System::Kernel::STRING, caseinsensitive: P0) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlPrefixString(string1 : *const super::super::super::Win32::System::Kernel:: STRING, string2 : *const super::super::super::Win32::System::Kernel:: STRING, caseinsensitive : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: BOOLEAN);
    RtlPrefixString(string1, string2, caseinsensitive.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlQueryPackageIdentity(tokenobject: *const ::core::ffi::c_void, packagefullname: ::windows_core::PWSTR, packagesize: *mut usize, appid: ::windows_core::PWSTR, appidsize: ::core::option::Option<*mut usize>, packaged: ::core::option::Option<*mut super::super::super::Win32::Foundation::BOOLEAN>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlQueryPackageIdentity(tokenobject : *const ::core::ffi::c_void, packagefullname : ::windows_core::PWSTR, packagesize : *mut usize, appid : ::windows_core::PWSTR, appidsize : *mut usize, packaged : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlQueryPackageIdentity(tokenobject, ::core::mem::transmute(packagefullname), packagesize, ::core::mem::transmute(appid), ::core::mem::transmute(appidsize.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(packaged.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlQueryPackageIdentityEx(tokenobject: *const ::core::ffi::c_void, packagefullname: ::windows_core::PWSTR, packagesize: *mut usize, appid: ::windows_core::PWSTR, appidsize: ::core::option::Option<*mut usize>, dynamicid: ::core::option::Option<*mut ::windows_core::GUID>, flags: ::core::option::Option<*mut u64>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlQueryPackageIdentityEx(tokenobject : *const ::core::ffi::c_void, packagefullname : ::windows_core::PWSTR, packagesize : *mut usize, appid : ::windows_core::PWSTR, appidsize : *mut usize, dynamicid : *mut ::windows_core::GUID, flags : *mut u64) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlQueryPackageIdentityEx(tokenobject, ::core::mem::transmute(packagefullname), packagesize, ::core::mem::transmute(appid), ::core::mem::transmute(appidsize.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(dynamicid.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(flags.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn RtlQueryProcessPlaceholderCompatibilityMode() -> u8 {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlQueryProcessPlaceholderCompatibilityMode() -> u8);
    RtlQueryProcessPlaceholderCompatibilityMode()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn RtlQueryThreadPlaceholderCompatibilityMode() -> u8 {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlQueryThreadPlaceholderCompatibilityMode() -> u8);
    RtlQueryThreadPlaceholderCompatibilityMode()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn RtlRandom(seed: *mut u32) -> u32 {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlRandom(seed : *mut u32) -> u32);
    RtlRandom(seed)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn RtlRandomEx(seed: *mut u32) -> u32 {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlRandomEx(seed : *mut u32) -> u32);
    RtlRandomEx(seed)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn RtlRemoveUnicodePrefix(prefixtable: *const UNICODE_PREFIX_TABLE, prefixtableentry: *const UNICODE_PREFIX_TABLE_ENTRY) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn RtlRemoveUnicodePrefix(prefixtable : *const UNICODE_PREFIX_TABLE, prefixtableentry : *const UNICODE_PREFIX_TABLE_ENTRY) -> ());
    RtlRemoveUnicodePrefix(prefixtable, prefixtableentry)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn RtlReplaceSidInSd<P0, P1>(securitydescriptor: super::super::super::Win32::Security::PSECURITY_DESCRIPTOR, oldsid: P0, newsid: P1, numchanges: *mut u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlReplaceSidInSd(securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, oldsid : super::super::super::Win32::Foundation:: PSID, newsid : super::super::super::Win32::Foundation:: PSID, numchanges : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlReplaceSidInSd(securitydescriptor, oldsid.into_param().abi(), newsid.into_param().abi(), numchanges).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlReserveChunk(compressionformat: u16, compressedbuffer: *mut *mut u8, endofcompressedbufferplus1: *const u8, chunkbuffer: *mut *mut u8, chunksize: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn RtlReserveChunk(compressionformat : u16, compressedbuffer : *mut *mut u8, endofcompressedbufferplus1 : *const u8, chunkbuffer : *mut *mut u8, chunksize : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlReserveChunk(compressionformat, compressedbuffer, endofcompressedbufferplus1, chunkbuffer, chunksize).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn RtlSecondsSince1970ToTime(elapsedseconds: u32) -> i64 {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlSecondsSince1970ToTime(elapsedseconds : u32, time : *mut i64) -> ());
    let mut result__ = ::std::mem::zeroed();
    RtlSecondsSince1970ToTime(elapsedseconds, &mut result__);
    ::std::mem::transmute(result__)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn RtlSecondsSince1980ToTime(elapsedseconds: u32) -> i64 {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlSecondsSince1980ToTime(elapsedseconds : u32, time : *mut i64) -> ());
    let mut result__ = ::std::mem::zeroed();
    RtlSecondsSince1980ToTime(elapsedseconds, &mut result__);
    ::std::mem::transmute(result__)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn RtlSelfRelativeToAbsoluteSD<P0>(selfrelativesecuritydescriptor: P0, absolutesecuritydescriptor: super::super::super::Win32::Security::PSECURITY_DESCRIPTOR, absolutesecuritydescriptorsize: *mut u32, dacl: ::core::option::Option<*mut super::super::super::Win32::Security::ACL>, daclsize: *mut u32, sacl: ::core::option::Option<*mut super::super::super::Win32::Security::ACL>, saclsize: *mut u32, owner: super::super::super::Win32::Foundation::PSID, ownersize: *mut u32, primarygroup: super::super::super::Win32::Foundation::PSID, primarygroupsize: *mut u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlSelfRelativeToAbsoluteSD(selfrelativesecuritydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, absolutesecuritydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, absolutesecuritydescriptorsize : *mut u32, dacl : *mut super::super::super::Win32::Security:: ACL, daclsize : *mut u32, sacl : *mut super::super::super::Win32::Security:: ACL, saclsize : *mut u32, owner : super::super::super::Win32::Foundation:: PSID, ownersize : *mut u32, primarygroup : super::super::super::Win32::Foundation:: PSID, primarygroupsize : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlSelfRelativeToAbsoluteSD(selfrelativesecuritydescriptor.into_param().abi(), absolutesecuritydescriptor, absolutesecuritydescriptorsize, ::core::mem::transmute(dacl.unwrap_or(::std::ptr::null_mut())), daclsize, ::core::mem::transmute(sacl.unwrap_or(::std::ptr::null_mut())), saclsize, owner, ownersize, primarygroup, primarygroupsize).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn RtlSetGroupSecurityDescriptor<P0, P1>(securitydescriptor: super::super::super::Win32::Security::PSECURITY_DESCRIPTOR, group: P0, groupdefaulted: P1) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlSetGroupSecurityDescriptor(securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, group : super::super::super::Win32::Foundation:: PSID, groupdefaulted : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlSetGroupSecurityDescriptor(securitydescriptor, group.into_param().abi(), groupdefaulted.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn RtlSetOwnerSecurityDescriptor<P0, P1>(securitydescriptor: super::super::super::Win32::Security::PSECURITY_DESCRIPTOR, owner: P0, ownerdefaulted: P1) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlSetOwnerSecurityDescriptor(securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, owner : super::super::super::Win32::Foundation:: PSID, ownerdefaulted : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlSetOwnerSecurityDescriptor(securitydescriptor, owner.into_param().abi(), ownerdefaulted.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn RtlSetProcessPlaceholderCompatibilityMode(mode: u8) -> u8 {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlSetProcessPlaceholderCompatibilityMode(mode : u8) -> u8);
    RtlSetProcessPlaceholderCompatibilityMode(mode)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn RtlSetThreadPlaceholderCompatibilityMode(mode: u8) -> u8 {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlSetThreadPlaceholderCompatibilityMode(mode : u8) -> u8);
    RtlSetThreadPlaceholderCompatibilityMode(mode)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlSubAuthorityCountSid<P0>(sid: P0) -> *mut u8
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlSubAuthorityCountSid(sid : super::super::super::Win32::Foundation:: PSID) -> *mut u8);
    RtlSubAuthorityCountSid(sid.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlSubAuthoritySid<P0>(sid: P0, subauthority: u32) -> *mut u32
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlSubAuthoritySid(sid : super::super::super::Win32::Foundation:: PSID, subauthority : u32) -> *mut u32);
    RtlSubAuthoritySid(sid.into_param().abi(), subauthority)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlTimeToSecondsSince1970(time: *const i64, elapsedseconds: *mut u32) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlTimeToSecondsSince1970(time : *const i64, elapsedseconds : *mut u32) -> super::super::super::Win32::Foundation:: BOOLEAN);
    RtlTimeToSecondsSince1970(time, elapsedseconds)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlTimeToSecondsSince1980(time: *const i64, elapsedseconds: *mut u32) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlTimeToSecondsSince1980(time : *const i64, elapsedseconds : *mut u32) -> super::super::super::Win32::Foundation:: BOOLEAN);
    RtlTimeToSecondsSince1980(time, elapsedseconds)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn RtlUnicodeStringToCountedOemString<P0>(destinationstring: *mut super::super::super::Win32::System::Kernel::STRING, sourcestring: *const super::super::super::Win32::Foundation::UNICODE_STRING, allocatedestinationstring: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlUnicodeStringToCountedOemString(destinationstring : *mut super::super::super::Win32::System::Kernel:: STRING, sourcestring : *const super::super::super::Win32::Foundation:: UNICODE_STRING, allocatedestinationstring : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlUnicodeStringToCountedOemString(destinationstring, sourcestring, allocatedestinationstring.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn RtlUnicodeStringToOemString<P0>(destinationstring: *mut super::super::super::Win32::System::Kernel::STRING, sourcestring: *const super::super::super::Win32::Foundation::UNICODE_STRING, allocatedestinationstring: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlUnicodeStringToOemString(destinationstring : *mut super::super::super::Win32::System::Kernel:: STRING, sourcestring : *const super::super::super::Win32::Foundation:: UNICODE_STRING, allocatedestinationstring : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlUnicodeStringToOemString(destinationstring, sourcestring, allocatedestinationstring.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlUnicodeToCustomCPN<P0>(customcp: *const CPTABLEINFO, customcpstring: &mut [u8], bytesincustomcpstring: ::core::option::Option<*mut u32>, unicodestring: P0, bytesinunicodestring: u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<::windows_core::PCWSTR>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlUnicodeToCustomCPN(customcp : *const CPTABLEINFO, customcpstring : ::windows_core::PSTR, maxbytesincustomcpstring : u32, bytesincustomcpstring : *mut u32, unicodestring : ::windows_core::PCWSTR, bytesinunicodestring : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlUnicodeToCustomCPN(customcp, ::core::mem::transmute(customcpstring.as_ptr()), customcpstring.len() as _, ::core::mem::transmute(bytesincustomcpstring.unwrap_or(::std::ptr::null_mut())), unicodestring.into_param().abi(), bytesinunicodestring).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlUnicodeToMultiByteN(multibytestring: &mut [u8], bytesinmultibytestring: ::core::option::Option<*mut u32>, unicodestring: *const u16, bytesinunicodestring: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlUnicodeToMultiByteN(multibytestring : ::windows_core::PSTR, maxbytesinmultibytestring : u32, bytesinmultibytestring : *mut u32, unicodestring : *const u16, bytesinunicodestring : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlUnicodeToMultiByteN(::core::mem::transmute(multibytestring.as_ptr()), multibytestring.len() as _, ::core::mem::transmute(bytesinmultibytestring.unwrap_or(::std::ptr::null_mut())), unicodestring, bytesinunicodestring).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlUnicodeToMultiByteSize(bytesinmultibytestring: *mut u32, unicodestring: *const u16, bytesinunicodestring: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlUnicodeToMultiByteSize(bytesinmultibytestring : *mut u32, unicodestring : *const u16, bytesinunicodestring : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlUnicodeToMultiByteSize(bytesinmultibytestring, unicodestring, bytesinunicodestring).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlUnicodeToOemN(oemstring: &mut [u8], bytesinoemstring: ::core::option::Option<*mut u32>, unicodestring: *const u16, bytesinunicodestring: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlUnicodeToOemN(oemstring : ::windows_core::PSTR, maxbytesinoemstring : u32, bytesinoemstring : *mut u32, unicodestring : *const u16, bytesinunicodestring : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlUnicodeToOemN(::core::mem::transmute(oemstring.as_ptr()), oemstring.len() as _, ::core::mem::transmute(bytesinoemstring.unwrap_or(::std::ptr::null_mut())), unicodestring, bytesinunicodestring).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn RtlUpcaseUnicodeStringToCountedOemString<P0>(destinationstring: *mut super::super::super::Win32::System::Kernel::STRING, sourcestring: *const super::super::super::Win32::Foundation::UNICODE_STRING, allocatedestinationstring: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlUpcaseUnicodeStringToCountedOemString(destinationstring : *mut super::super::super::Win32::System::Kernel:: STRING, sourcestring : *const super::super::super::Win32::Foundation:: UNICODE_STRING, allocatedestinationstring : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlUpcaseUnicodeStringToCountedOemString(destinationstring, sourcestring, allocatedestinationstring.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
#[inline]
pub unsafe fn RtlUpcaseUnicodeStringToOemString<P0>(destinationstring: *mut super::super::super::Win32::System::Kernel::STRING, sourcestring: *const super::super::super::Win32::Foundation::UNICODE_STRING, allocatedestinationstring: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlUpcaseUnicodeStringToOemString(destinationstring : *mut super::super::super::Win32::System::Kernel:: STRING, sourcestring : *const super::super::super::Win32::Foundation:: UNICODE_STRING, allocatedestinationstring : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlUpcaseUnicodeStringToOemString(destinationstring, sourcestring, allocatedestinationstring.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlUpcaseUnicodeToCustomCPN<P0>(customcp: *const CPTABLEINFO, customcpstring: &mut [u8], bytesincustomcpstring: ::core::option::Option<*mut u32>, unicodestring: P0, bytesinunicodestring: u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<::windows_core::PCWSTR>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlUpcaseUnicodeToCustomCPN(customcp : *const CPTABLEINFO, customcpstring : ::windows_core::PSTR, maxbytesincustomcpstring : u32, bytesincustomcpstring : *mut u32, unicodestring : ::windows_core::PCWSTR, bytesinunicodestring : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlUpcaseUnicodeToCustomCPN(customcp, ::core::mem::transmute(customcpstring.as_ptr()), customcpstring.len() as _, ::core::mem::transmute(bytesincustomcpstring.unwrap_or(::std::ptr::null_mut())), unicodestring.into_param().abi(), bytesinunicodestring).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlUpcaseUnicodeToMultiByteN(multibytestring: &mut [u8], bytesinmultibytestring: ::core::option::Option<*mut u32>, unicodestring: *const u16, bytesinunicodestring: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlUpcaseUnicodeToMultiByteN(multibytestring : ::windows_core::PSTR, maxbytesinmultibytestring : u32, bytesinmultibytestring : *mut u32, unicodestring : *const u16, bytesinunicodestring : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlUpcaseUnicodeToMultiByteN(::core::mem::transmute(multibytestring.as_ptr()), multibytestring.len() as _, ::core::mem::transmute(bytesinmultibytestring.unwrap_or(::std::ptr::null_mut())), unicodestring, bytesinunicodestring).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlUpcaseUnicodeToOemN(oemstring: &mut [u8], bytesinoemstring: ::core::option::Option<*mut u32>, unicodestring: *const u16, bytesinunicodestring: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlUpcaseUnicodeToOemN(oemstring : ::windows_core::PSTR, maxbytesinoemstring : u32, bytesinoemstring : *mut u32, unicodestring : *const u16, bytesinunicodestring : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlUpcaseUnicodeToOemN(::core::mem::transmute(oemstring.as_ptr()), oemstring.len() as _, ::core::mem::transmute(bytesinoemstring.unwrap_or(::std::ptr::null_mut())), unicodestring, bytesinunicodestring).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlValidSid<P0>(sid: P0) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn RtlValidSid(sid : super::super::super::Win32::Foundation:: PSID) -> super::super::super::Win32::Foundation:: BOOLEAN);
    RtlValidSid(sid.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlValidateUnicodeString(flags: u32, string: *const super::super::super::Win32::Foundation::UNICODE_STRING) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlValidateUnicodeString(flags : u32, string : *const super::super::super::Win32::Foundation:: UNICODE_STRING) -> super::super::super::Win32::Foundation:: NTSTATUS);
    RtlValidateUnicodeString(flags, string).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(feature = "Win32_System_Kernel")]
#[inline]
pub unsafe fn RtlxOemStringToUnicodeSize(oemstring: *const super::super::super::Win32::System::Kernel::STRING) -> u32 {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlxOemStringToUnicodeSize(oemstring : *const super::super::super::Win32::System::Kernel:: STRING) -> u32);
    RtlxOemStringToUnicodeSize(oemstring)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn RtlxUnicodeStringToOemSize(unicodestring: *const super::super::super::Win32::Foundation::UNICODE_STRING) -> u32 {
    ::windows_targets::link!("ntdll.dll" "system" fn RtlxUnicodeStringToOemSize(unicodestring : *const super::super::super::Win32::Foundation:: UNICODE_STRING) -> u32);
    RtlxUnicodeStringToOemSize(unicodestring)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeAccessCheckFromState<P0>(securitydescriptor: P0, primarytokeninformation: *const TOKEN_ACCESS_INFORMATION, clienttokeninformation: ::core::option::Option<*const TOKEN_ACCESS_INFORMATION>, desiredaccess: u32, previouslygrantedaccess: u32, privileges: ::core::option::Option<*mut *mut super::super::super::Win32::Security::PRIVILEGE_SET>, genericmapping: *const super::super::super::Win32::Security::GENERIC_MAPPING, accessmode: i8, grantedaccess: *mut u32, accessstatus: *mut i32) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeAccessCheckFromState(securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, primarytokeninformation : *const TOKEN_ACCESS_INFORMATION, clienttokeninformation : *const TOKEN_ACCESS_INFORMATION, desiredaccess : u32, previouslygrantedaccess : u32, privileges : *mut *mut super::super::super::Win32::Security:: PRIVILEGE_SET, genericmapping : *const super::super::super::Win32::Security:: GENERIC_MAPPING, accessmode : i8, grantedaccess : *mut u32, accessstatus : *mut i32) -> super::super::super::Win32::Foundation:: BOOLEAN);
    SeAccessCheckFromState(securitydescriptor.into_param().abi(), primarytokeninformation, ::core::mem::transmute(clienttokeninformation.unwrap_or(::std::ptr::null())), desiredaccess, previouslygrantedaccess, ::core::mem::transmute(privileges.unwrap_or(::std::ptr::null_mut())), genericmapping, accessmode, grantedaccess, accessstatus)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeAccessCheckFromStateEx<P0>(securitydescriptor: P0, primarytoken: *const ::core::ffi::c_void, clienttoken: ::core::option::Option<*const ::core::ffi::c_void>, desiredaccess: u32, previouslygrantedaccess: u32, privileges: ::core::option::Option<*mut *mut super::super::super::Win32::Security::PRIVILEGE_SET>, genericmapping: *const super::super::super::Win32::Security::GENERIC_MAPPING, accessmode: i8, grantedaccess: *mut u32, accessstatus: *mut i32) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeAccessCheckFromStateEx(securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, primarytoken : *const ::core::ffi::c_void, clienttoken : *const ::core::ffi::c_void, desiredaccess : u32, previouslygrantedaccess : u32, privileges : *mut *mut super::super::super::Win32::Security:: PRIVILEGE_SET, genericmapping : *const super::super::super::Win32::Security:: GENERIC_MAPPING, accessmode : i8, grantedaccess : *mut u32, accessstatus : *mut i32) -> super::super::super::Win32::Foundation:: BOOLEAN);
    SeAccessCheckFromStateEx(securitydescriptor.into_param().abi(), primarytoken, ::core::mem::transmute(clienttoken.unwrap_or(::std::ptr::null())), desiredaccess, previouslygrantedaccess, ::core::mem::transmute(privileges.unwrap_or(::std::ptr::null_mut())), genericmapping, accessmode, grantedaccess, accessstatus)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeAdjustAccessStateForAccessConstraints<P0>(objecttype: *const ::core::ffi::c_void, securitydescriptor: P0, accessstate: *mut super::super::Foundation::ACCESS_STATE)
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeAdjustAccessStateForAccessConstraints(objecttype : *const ::core::ffi::c_void, securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, accessstate : *mut super::super::Foundation:: ACCESS_STATE) -> ());
    SeAdjustAccessStateForAccessConstraints(objecttype, securitydescriptor.into_param().abi(), accessstate)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeAdjustAccessStateForTrustLabel<P0>(objecttype: *const ::core::ffi::c_void, securitydescriptor: P0, accessstate: *mut super::super::Foundation::ACCESS_STATE)
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeAdjustAccessStateForTrustLabel(objecttype : *const ::core::ffi::c_void, securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, accessstate : *mut super::super::Foundation:: ACCESS_STATE) -> ());
    SeAdjustAccessStateForTrustLabel(objecttype, securitydescriptor.into_param().abi(), accessstate)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeAdjustObjectSecurity<P0, P1>(objectname: *const super::super::super::Win32::Foundation::UNICODE_STRING, originaldescriptor: P0, proposeddescriptor: P1, subjectsecuritycontext: *const super::super::Foundation::SECURITY_SUBJECT_CONTEXT, adjusteddescriptor: *mut super::super::super::Win32::Security::PSECURITY_DESCRIPTOR, applyadjusteddescriptor: *mut super::super::super::Win32::Foundation::BOOLEAN) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeAdjustObjectSecurity(objectname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, originaldescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, proposeddescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, subjectsecuritycontext : *const super::super::Foundation:: SECURITY_SUBJECT_CONTEXT, adjusteddescriptor : *mut super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, applyadjusteddescriptor : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SeAdjustObjectSecurity(objectname, originaldescriptor.into_param().abi(), proposeddescriptor.into_param().abi(), subjectsecuritycontext, adjusteddescriptor, applyadjusteddescriptor).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeAppendPrivileges(accessstate: *mut super::super::Foundation::ACCESS_STATE, privileges: *const super::super::super::Win32::Security::PRIVILEGE_SET) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeAppendPrivileges(accessstate : *mut super::super::Foundation:: ACCESS_STATE, privileges : *const super::super::super::Win32::Security:: PRIVILEGE_SET) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SeAppendPrivileges(accessstate, privileges).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SeAuditFipsCryptoSelftests<P0>(bsuccess: P0, selftestcode: u32)
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeAuditFipsCryptoSelftests(bsuccess : super::super::super::Win32::Foundation:: BOOLEAN, selftestcode : u32) -> ());
    SeAuditFipsCryptoSelftests(bsuccess.into_param().abi(), selftestcode)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SeAuditHardLinkCreation<P0>(filename: *const super::super::super::Win32::Foundation::UNICODE_STRING, linkname: *const super::super::super::Win32::Foundation::UNICODE_STRING, bsuccess: P0)
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeAuditHardLinkCreation(filename : *const super::super::super::Win32::Foundation:: UNICODE_STRING, linkname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, bsuccess : super::super::super::Win32::Foundation:: BOOLEAN) -> ());
    SeAuditHardLinkCreation(filename, linkname, bsuccess.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SeAuditHardLinkCreationWithTransaction<P0>(filename: *const super::super::super::Win32::Foundation::UNICODE_STRING, linkname: *const super::super::super::Win32::Foundation::UNICODE_STRING, bsuccess: P0, transactionid: ::core::option::Option<*const ::windows_core::GUID>)
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeAuditHardLinkCreationWithTransaction(filename : *const super::super::super::Win32::Foundation:: UNICODE_STRING, linkname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, bsuccess : super::super::super::Win32::Foundation:: BOOLEAN, transactionid : *const ::windows_core::GUID) -> ());
    SeAuditHardLinkCreationWithTransaction(filename, linkname, bsuccess.into_param().abi(), ::core::mem::transmute(transactionid.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn SeAuditTransactionStateChange(transactionid: *const ::windows_core::GUID, resourcemanagerid: *const ::windows_core::GUID, newtransactionstate: u32) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeAuditTransactionStateChange(transactionid : *const ::windows_core::GUID, resourcemanagerid : *const ::windows_core::GUID, newtransactionstate : u32) -> ());
    SeAuditTransactionStateChange(transactionid, resourcemanagerid, newtransactionstate)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeAuditingAnyFileEventsWithContext<P0>(securitydescriptor: P0, subjectsecuritycontext: ::core::option::Option<*const super::super::Foundation::SECURITY_SUBJECT_CONTEXT>) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeAuditingAnyFileEventsWithContext(securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, subjectsecuritycontext : *const super::super::Foundation:: SECURITY_SUBJECT_CONTEXT) -> super::super::super::Win32::Foundation:: BOOLEAN);
    SeAuditingAnyFileEventsWithContext(securitydescriptor.into_param().abi(), ::core::mem::transmute(subjectsecuritycontext.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeAuditingAnyFileEventsWithContextEx<P0>(securitydescriptor: P0, subjectsecuritycontext: ::core::option::Option<*const super::super::Foundation::SECURITY_SUBJECT_CONTEXT>, stagingenabled: ::core::option::Option<*mut super::super::super::Win32::Foundation::BOOLEAN>) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeAuditingAnyFileEventsWithContextEx(securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, subjectsecuritycontext : *const super::super::Foundation:: SECURITY_SUBJECT_CONTEXT, stagingenabled : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: BOOLEAN);
    SeAuditingAnyFileEventsWithContextEx(securitydescriptor.into_param().abi(), ::core::mem::transmute(subjectsecuritycontext.unwrap_or(::std::ptr::null())), ::core::mem::transmute(stagingenabled.unwrap_or(::std::ptr::null_mut())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeAuditingFileEvents<P0, P1>(accessgranted: P0, securitydescriptor: P1) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeAuditingFileEvents(accessgranted : super::super::super::Win32::Foundation:: BOOLEAN, securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR) -> super::super::super::Win32::Foundation:: BOOLEAN);
    SeAuditingFileEvents(accessgranted.into_param().abi(), securitydescriptor.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeAuditingFileEventsWithContext<P0, P1>(accessgranted: P0, securitydescriptor: P1, subjectsecuritycontext: ::core::option::Option<*const super::super::Foundation::SECURITY_SUBJECT_CONTEXT>) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeAuditingFileEventsWithContext(accessgranted : super::super::super::Win32::Foundation:: BOOLEAN, securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, subjectsecuritycontext : *const super::super::Foundation:: SECURITY_SUBJECT_CONTEXT) -> super::super::super::Win32::Foundation:: BOOLEAN);
    SeAuditingFileEventsWithContext(accessgranted.into_param().abi(), securitydescriptor.into_param().abi(), ::core::mem::transmute(subjectsecuritycontext.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeAuditingFileEventsWithContextEx<P0, P1>(accessgranted: P0, securitydescriptor: P1, subjectsecuritycontext: ::core::option::Option<*const super::super::Foundation::SECURITY_SUBJECT_CONTEXT>, stagingenabled: ::core::option::Option<*mut super::super::super::Win32::Foundation::BOOLEAN>) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeAuditingFileEventsWithContextEx(accessgranted : super::super::super::Win32::Foundation:: BOOLEAN, securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, subjectsecuritycontext : *const super::super::Foundation:: SECURITY_SUBJECT_CONTEXT, stagingenabled : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: BOOLEAN);
    SeAuditingFileEventsWithContextEx(accessgranted.into_param().abi(), securitydescriptor.into_param().abi(), ::core::mem::transmute(subjectsecuritycontext.unwrap_or(::std::ptr::null())), ::core::mem::transmute(stagingenabled.unwrap_or(::std::ptr::null_mut())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeAuditingFileOrGlobalEvents<P0, P1>(accessgranted: P0, securitydescriptor: P1, subjectsecuritycontext: *const super::super::Foundation::SECURITY_SUBJECT_CONTEXT) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeAuditingFileOrGlobalEvents(accessgranted : super::super::super::Win32::Foundation:: BOOLEAN, securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, subjectsecuritycontext : *const super::super::Foundation:: SECURITY_SUBJECT_CONTEXT) -> super::super::super::Win32::Foundation:: BOOLEAN);
    SeAuditingFileOrGlobalEvents(accessgranted.into_param().abi(), securitydescriptor.into_param().abi(), subjectsecuritycontext)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeAuditingHardLinkEvents<P0, P1>(accessgranted: P0, securitydescriptor: P1) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeAuditingHardLinkEvents(accessgranted : super::super::super::Win32::Foundation:: BOOLEAN, securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR) -> super::super::super::Win32::Foundation:: BOOLEAN);
    SeAuditingHardLinkEvents(accessgranted.into_param().abi(), securitydescriptor.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeAuditingHardLinkEventsWithContext<P0, P1>(accessgranted: P0, securitydescriptor: P1, subjectsecuritycontext: ::core::option::Option<*const super::super::Foundation::SECURITY_SUBJECT_CONTEXT>) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeAuditingHardLinkEventsWithContext(accessgranted : super::super::super::Win32::Foundation:: BOOLEAN, securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, subjectsecuritycontext : *const super::super::Foundation:: SECURITY_SUBJECT_CONTEXT) -> super::super::super::Win32::Foundation:: BOOLEAN);
    SeAuditingHardLinkEventsWithContext(accessgranted.into_param().abi(), securitydescriptor.into_param().abi(), ::core::mem::transmute(subjectsecuritycontext.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeCaptureSubjectContextEx(thread: ::core::option::Option<*const super::super::Foundation::KTHREAD>, process: *const super::super::Foundation::KPROCESS) -> super::super::Foundation::SECURITY_SUBJECT_CONTEXT {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeCaptureSubjectContextEx(thread : *const super::super::Foundation:: KTHREAD, process : *const super::super::Foundation:: KPROCESS, subjectcontext : *mut super::super::Foundation:: SECURITY_SUBJECT_CONTEXT) -> ());
    let mut result__ = ::std::mem::zeroed();
    SeCaptureSubjectContextEx(::core::mem::transmute(thread.unwrap_or(::std::ptr::null())), process, &mut result__);
    ::std::mem::transmute(result__)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeCheckForCriticalAceRemoval<P0, P1>(currentdescriptor: P0, newdescriptor: P1, subjectsecuritycontext: *const super::super::Foundation::SECURITY_SUBJECT_CONTEXT) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeCheckForCriticalAceRemoval(currentdescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, newdescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, subjectsecuritycontext : *const super::super::Foundation:: SECURITY_SUBJECT_CONTEXT, aceremoved : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> ());
    let mut result__ = ::std::mem::zeroed();
    SeCheckForCriticalAceRemoval(currentdescriptor.into_param().abi(), newdescriptor.into_param().abi(), subjectsecuritycontext, &mut result__);
    ::std::mem::transmute(result__)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeCreateClientSecurity<P0>(clientthread: *const super::super::Foundation::KTHREAD, clientsecurityqos: *const super::super::super::Win32::Security::SECURITY_QUALITY_OF_SERVICE, remotesession: P0, clientcontext: *mut SECURITY_CLIENT_CONTEXT) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeCreateClientSecurity(clientthread : *const super::super::Foundation:: KTHREAD, clientsecurityqos : *const super::super::super::Win32::Security:: SECURITY_QUALITY_OF_SERVICE, remotesession : super::super::super::Win32::Foundation:: BOOLEAN, clientcontext : *mut SECURITY_CLIENT_CONTEXT) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SeCreateClientSecurity(clientthread, clientsecurityqos, remotesession.into_param().abi(), clientcontext).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeCreateClientSecurityFromSubjectContext<P0>(subjectcontext: *const super::super::Foundation::SECURITY_SUBJECT_CONTEXT, clientsecurityqos: *const super::super::super::Win32::Security::SECURITY_QUALITY_OF_SERVICE, serverisremote: P0, clientcontext: *mut SECURITY_CLIENT_CONTEXT) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeCreateClientSecurityFromSubjectContext(subjectcontext : *const super::super::Foundation:: SECURITY_SUBJECT_CONTEXT, clientsecurityqos : *const super::super::super::Win32::Security:: SECURITY_QUALITY_OF_SERVICE, serverisremote : super::super::super::Win32::Foundation:: BOOLEAN, clientcontext : *mut SECURITY_CLIENT_CONTEXT) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SeCreateClientSecurityFromSubjectContext(subjectcontext, clientsecurityqos, serverisremote.into_param().abi(), clientcontext).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeDeleteClientSecurity(clientcontext: *mut SECURITY_CLIENT_CONTEXT) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeDeleteClientSecurity(clientcontext : *mut SECURITY_CLIENT_CONTEXT) -> ());
    SeDeleteClientSecurity(clientcontext)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SeDeleteObjectAuditAlarm<P0>(object: *const ::core::ffi::c_void, handle: P0)
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeDeleteObjectAuditAlarm(object : *const ::core::ffi::c_void, handle : super::super::super::Win32::Foundation:: HANDLE) -> ());
    SeDeleteObjectAuditAlarm(object, handle.into_param().abi())
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SeDeleteObjectAuditAlarmWithTransaction<P0>(object: *const ::core::ffi::c_void, handle: P0, transactionid: ::core::option::Option<*const ::windows_core::GUID>)
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeDeleteObjectAuditAlarmWithTransaction(object : *const ::core::ffi::c_void, handle : super::super::super::Win32::Foundation:: HANDLE, transactionid : *const ::windows_core::GUID) -> ());
    SeDeleteObjectAuditAlarmWithTransaction(object, handle.into_param().abi(), ::core::mem::transmute(transactionid.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeExamineSacl<P0>(sacl: *const super::super::super::Win32::Security::ACL, resourcesacl: *const super::super::super::Win32::Security::ACL, token: *const ::core::ffi::c_void, desiredaccess: u32, accessgranted: P0, generateaudit: *mut super::super::super::Win32::Foundation::BOOLEAN, generatealarm: *mut super::super::super::Win32::Foundation::BOOLEAN)
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeExamineSacl(sacl : *const super::super::super::Win32::Security:: ACL, resourcesacl : *const super::super::super::Win32::Security:: ACL, token : *const ::core::ffi::c_void, desiredaccess : u32, accessgranted : super::super::super::Win32::Foundation:: BOOLEAN, generateaudit : *mut super::super::super::Win32::Foundation:: BOOLEAN, generatealarm : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> ());
    SeExamineSacl(sacl, resourcesacl, token, desiredaccess, accessgranted.into_param().abi(), generateaudit, generatealarm)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeFilterToken(existingtoken: *const ::core::ffi::c_void, flags: u32, sidstodisable: ::core::option::Option<*const TOKEN_GROUPS>, privilegestodelete: ::core::option::Option<*const TOKEN_PRIVILEGES>, restrictedsids: ::core::option::Option<*const TOKEN_GROUPS>, filteredtoken: *mut *mut ::core::ffi::c_void) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeFilterToken(existingtoken : *const ::core::ffi::c_void, flags : u32, sidstodisable : *const TOKEN_GROUPS, privilegestodelete : *const TOKEN_PRIVILEGES, restrictedsids : *const TOKEN_GROUPS, filteredtoken : *mut *mut ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SeFilterToken(existingtoken, flags, ::core::mem::transmute(sidstodisable.unwrap_or(::std::ptr::null())), ::core::mem::transmute(privilegestodelete.unwrap_or(::std::ptr::null())), ::core::mem::transmute(restrictedsids.unwrap_or(::std::ptr::null())), filteredtoken).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeFreePrivileges(privileges: *const super::super::super::Win32::Security::PRIVILEGE_SET) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeFreePrivileges(privileges : *const super::super::super::Win32::Security:: PRIVILEGE_SET) -> ());
    SeFreePrivileges(privileges)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeImpersonateClient(clientcontext: *const SECURITY_CLIENT_CONTEXT, serverthread: ::core::option::Option<*const super::super::Foundation::KTHREAD>) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeImpersonateClient(clientcontext : *const SECURITY_CLIENT_CONTEXT, serverthread : *const super::super::Foundation:: KTHREAD) -> ());
    SeImpersonateClient(clientcontext, ::core::mem::transmute(serverthread.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeImpersonateClientEx(clientcontext: *const SECURITY_CLIENT_CONTEXT, serverthread: ::core::option::Option<*const super::super::Foundation::KTHREAD>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeImpersonateClientEx(clientcontext : *const SECURITY_CLIENT_CONTEXT, serverthread : *const super::super::Foundation:: KTHREAD) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SeImpersonateClientEx(clientcontext, ::core::mem::transmute(serverthread.unwrap_or(::std::ptr::null()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn SeLocateProcessImageName(process: *mut super::super::Foundation::KPROCESS, pimagefilename: *mut *mut super::super::super::Win32::Foundation::UNICODE_STRING) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeLocateProcessImageName(process : *mut super::super::Foundation:: KPROCESS, pimagefilename : *mut *mut super::super::super::Win32::Foundation:: UNICODE_STRING) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SeLocateProcessImageName(process, pimagefilename).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SeMarkLogonSessionForTerminationNotification(logonid: *const super::super::super::Win32::Foundation::LUID) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeMarkLogonSessionForTerminationNotification(logonid : *const super::super::super::Win32::Foundation:: LUID) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SeMarkLogonSessionForTerminationNotification(logonid).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn SeMarkLogonSessionForTerminationNotificationEx(logonid: *const super::super::super::Win32::Foundation::LUID, pserversilo: *const super::super::Foundation::EJOB) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeMarkLogonSessionForTerminationNotificationEx(logonid : *const super::super::super::Win32::Foundation:: LUID, pserversilo : *const super::super::Foundation:: EJOB) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SeMarkLogonSessionForTerminationNotificationEx(logonid, pserversilo).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeOpenObjectAuditAlarm<P0, P1, P2>(objecttypename: *const super::super::super::Win32::Foundation::UNICODE_STRING, object: ::core::option::Option<*const ::core::ffi::c_void>, absoluteobjectname: ::core::option::Option<*const super::super::super::Win32::Foundation::UNICODE_STRING>, securitydescriptor: P0, accessstate: *const super::super::Foundation::ACCESS_STATE, objectcreated: P1, accessgranted: P2, accessmode: i8) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P2: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeOpenObjectAuditAlarm(objecttypename : *const super::super::super::Win32::Foundation:: UNICODE_STRING, object : *const ::core::ffi::c_void, absoluteobjectname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, accessstate : *const super::super::Foundation:: ACCESS_STATE, objectcreated : super::super::super::Win32::Foundation:: BOOLEAN, accessgranted : super::super::super::Win32::Foundation:: BOOLEAN, accessmode : i8, generateonclose : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> ());
    let mut result__ = ::std::mem::zeroed();
    SeOpenObjectAuditAlarm(objecttypename, ::core::mem::transmute(object.unwrap_or(::std::ptr::null())), ::core::mem::transmute(absoluteobjectname.unwrap_or(::std::ptr::null())), securitydescriptor.into_param().abi(), accessstate, objectcreated.into_param().abi(), accessgranted.into_param().abi(), accessmode, &mut result__);
    ::std::mem::transmute(result__)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeOpenObjectAuditAlarmWithTransaction<P0, P1, P2>(objecttypename: *const super::super::super::Win32::Foundation::UNICODE_STRING, object: ::core::option::Option<*const ::core::ffi::c_void>, absoluteobjectname: ::core::option::Option<*const super::super::super::Win32::Foundation::UNICODE_STRING>, securitydescriptor: P0, accessstate: *const super::super::Foundation::ACCESS_STATE, objectcreated: P1, accessgranted: P2, accessmode: i8, transactionid: ::core::option::Option<*const ::windows_core::GUID>) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P2: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeOpenObjectAuditAlarmWithTransaction(objecttypename : *const super::super::super::Win32::Foundation:: UNICODE_STRING, object : *const ::core::ffi::c_void, absoluteobjectname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, accessstate : *const super::super::Foundation:: ACCESS_STATE, objectcreated : super::super::super::Win32::Foundation:: BOOLEAN, accessgranted : super::super::super::Win32::Foundation:: BOOLEAN, accessmode : i8, transactionid : *const ::windows_core::GUID, generateonclose : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> ());
    let mut result__ = ::std::mem::zeroed();
    SeOpenObjectAuditAlarmWithTransaction(objecttypename, ::core::mem::transmute(object.unwrap_or(::std::ptr::null())), ::core::mem::transmute(absoluteobjectname.unwrap_or(::std::ptr::null())), securitydescriptor.into_param().abi(), accessstate, objectcreated.into_param().abi(), accessgranted.into_param().abi(), accessmode, ::core::mem::transmute(transactionid.unwrap_or(::std::ptr::null())), &mut result__);
    ::std::mem::transmute(result__)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeOpenObjectForDeleteAuditAlarm<P0, P1, P2>(objecttypename: *const super::super::super::Win32::Foundation::UNICODE_STRING, object: ::core::option::Option<*const ::core::ffi::c_void>, absoluteobjectname: ::core::option::Option<*const super::super::super::Win32::Foundation::UNICODE_STRING>, securitydescriptor: P0, accessstate: *const super::super::Foundation::ACCESS_STATE, objectcreated: P1, accessgranted: P2, accessmode: i8) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P2: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeOpenObjectForDeleteAuditAlarm(objecttypename : *const super::super::super::Win32::Foundation:: UNICODE_STRING, object : *const ::core::ffi::c_void, absoluteobjectname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, accessstate : *const super::super::Foundation:: ACCESS_STATE, objectcreated : super::super::super::Win32::Foundation:: BOOLEAN, accessgranted : super::super::super::Win32::Foundation:: BOOLEAN, accessmode : i8, generateonclose : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> ());
    let mut result__ = ::std::mem::zeroed();
    SeOpenObjectForDeleteAuditAlarm(objecttypename, ::core::mem::transmute(object.unwrap_or(::std::ptr::null())), ::core::mem::transmute(absoluteobjectname.unwrap_or(::std::ptr::null())), securitydescriptor.into_param().abi(), accessstate, objectcreated.into_param().abi(), accessgranted.into_param().abi(), accessmode, &mut result__);
    ::std::mem::transmute(result__)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeOpenObjectForDeleteAuditAlarmWithTransaction<P0, P1, P2>(objecttypename: *const super::super::super::Win32::Foundation::UNICODE_STRING, object: ::core::option::Option<*const ::core::ffi::c_void>, absoluteobjectname: ::core::option::Option<*const super::super::super::Win32::Foundation::UNICODE_STRING>, securitydescriptor: P0, accessstate: *const super::super::Foundation::ACCESS_STATE, objectcreated: P1, accessgranted: P2, accessmode: i8, transactionid: ::core::option::Option<*const ::windows_core::GUID>) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P2: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeOpenObjectForDeleteAuditAlarmWithTransaction(objecttypename : *const super::super::super::Win32::Foundation:: UNICODE_STRING, object : *const ::core::ffi::c_void, absoluteobjectname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, accessstate : *const super::super::Foundation:: ACCESS_STATE, objectcreated : super::super::super::Win32::Foundation:: BOOLEAN, accessgranted : super::super::super::Win32::Foundation:: BOOLEAN, accessmode : i8, transactionid : *const ::windows_core::GUID, generateonclose : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> ());
    let mut result__ = ::std::mem::zeroed();
    SeOpenObjectForDeleteAuditAlarmWithTransaction(objecttypename, ::core::mem::transmute(object.unwrap_or(::std::ptr::null())), ::core::mem::transmute(absoluteobjectname.unwrap_or(::std::ptr::null())), securitydescriptor.into_param().abi(), accessstate, objectcreated.into_param().abi(), accessgranted.into_param().abi(), accessmode, ::core::mem::transmute(transactionid.unwrap_or(::std::ptr::null())), &mut result__);
    ::std::mem::transmute(result__)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SePrivilegeCheck(requiredprivileges: *mut super::super::super::Win32::Security::PRIVILEGE_SET, subjectsecuritycontext: *const super::super::Foundation::SECURITY_SUBJECT_CONTEXT, accessmode: i8) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SePrivilegeCheck(requiredprivileges : *mut super::super::super::Win32::Security:: PRIVILEGE_SET, subjectsecuritycontext : *const super::super::Foundation:: SECURITY_SUBJECT_CONTEXT, accessmode : i8) -> super::super::super::Win32::Foundation:: BOOLEAN);
    SePrivilegeCheck(requiredprivileges, subjectsecuritycontext, accessmode)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SeQueryAuthenticationIdToken(token: *const ::core::ffi::c_void, authenticationid: *mut super::super::super::Win32::Foundation::LUID) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeQueryAuthenticationIdToken(token : *const ::core::ffi::c_void, authenticationid : *mut super::super::super::Win32::Foundation:: LUID) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SeQueryAuthenticationIdToken(token, authenticationid).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SeQueryInformationToken(token: *const ::core::ffi::c_void, tokeninformationclass: TOKEN_INFORMATION_CLASS, tokeninformation: *mut *mut ::core::ffi::c_void) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeQueryInformationToken(token : *const ::core::ffi::c_void, tokeninformationclass : TOKEN_INFORMATION_CLASS, tokeninformation : *mut *mut ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SeQueryInformationToken(token, tokeninformationclass, tokeninformation).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeQuerySecurityDescriptorInfo(securityinformation: *const u32, securitydescriptor: super::super::super::Win32::Security::PSECURITY_DESCRIPTOR, length: *mut u32, objectssecuritydescriptor: *mut super::super::super::Win32::Security::PSECURITY_DESCRIPTOR) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeQuerySecurityDescriptorInfo(securityinformation : *const u32, securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, length : *mut u32, objectssecuritydescriptor : *mut super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SeQuerySecurityDescriptorInfo(securityinformation, securitydescriptor, length, objectssecuritydescriptor).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
#[inline]
pub unsafe fn SeQueryServerSiloToken(token: *const ::core::ffi::c_void, pserversilo: *mut *mut super::super::Foundation::EJOB) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeQueryServerSiloToken(token : *const ::core::ffi::c_void, pserversilo : *mut *mut super::super::Foundation:: EJOB) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SeQueryServerSiloToken(token, pserversilo).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SeQuerySessionIdToken(token: *const ::core::ffi::c_void, sessionid: *mut u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeQuerySessionIdToken(token : *const ::core::ffi::c_void, sessionid : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SeQuerySessionIdToken(token, sessionid).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SeQuerySessionIdTokenEx(token: *const ::core::ffi::c_void, sessionid: *mut u32, isservicesession: *mut super::super::super::Win32::Foundation::BOOLEAN) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeQuerySessionIdTokenEx(token : *const ::core::ffi::c_void, sessionid : *mut u32, isservicesession : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SeQuerySessionIdTokenEx(token, sessionid, isservicesession).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SeRegisterLogonSessionTerminatedRoutine(callbackroutine: PSE_LOGON_SESSION_TERMINATED_ROUTINE) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeRegisterLogonSessionTerminatedRoutine(callbackroutine : PSE_LOGON_SESSION_TERMINATED_ROUTINE) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SeRegisterLogonSessionTerminatedRoutine(callbackroutine).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SeRegisterLogonSessionTerminatedRoutineEx(callbackroutine: PSE_LOGON_SESSION_TERMINATED_ROUTINE_EX, context: *const ::core::ffi::c_void) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeRegisterLogonSessionTerminatedRoutineEx(callbackroutine : PSE_LOGON_SESSION_TERMINATED_ROUTINE_EX, context : *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SeRegisterLogonSessionTerminatedRoutineEx(callbackroutine, context).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security_Authentication_Identity\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security_Authentication_Identity"))]
#[inline]
pub unsafe fn SeReportSecurityEventWithSubCategory<P0>(flags: u32, sourcename: *const super::super::super::Win32::Foundation::UNICODE_STRING, usersid: P0, auditparameters: *const super::super::super::Win32::Security::Authentication::Identity::SE_ADT_PARAMETER_ARRAY, auditsubcategoryid: u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeReportSecurityEventWithSubCategory(flags : u32, sourcename : *const super::super::super::Win32::Foundation:: UNICODE_STRING, usersid : super::super::super::Win32::Foundation:: PSID, auditparameters : *const super::super::super::Win32::Security::Authentication::Identity:: SE_ADT_PARAMETER_ARRAY, auditsubcategoryid : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SeReportSecurityEventWithSubCategory(flags, sourcename, usersid.into_param().abi(), auditparameters, auditsubcategoryid).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeSetAccessStateGenericMapping(accessstate: *mut super::super::Foundation::ACCESS_STATE, genericmapping: *const super::super::super::Win32::Security::GENERIC_MAPPING) {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeSetAccessStateGenericMapping(accessstate : *mut super::super::Foundation:: ACCESS_STATE, genericmapping : *const super::super::super::Win32::Security:: GENERIC_MAPPING) -> ());
    SeSetAccessStateGenericMapping(accessstate, genericmapping)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeSetSecurityDescriptorInfo<P0>(object: ::core::option::Option<*const ::core::ffi::c_void>, securityinformation: *const u32, modificationdescriptor: P0, objectssecuritydescriptor: *mut super::super::super::Win32::Security::PSECURITY_DESCRIPTOR, pooltype: super::super::Foundation::POOL_TYPE, genericmapping: *const super::super::super::Win32::Security::GENERIC_MAPPING) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeSetSecurityDescriptorInfo(object : *const ::core::ffi::c_void, securityinformation : *const u32, modificationdescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, objectssecuritydescriptor : *mut super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, pooltype : super::super::Foundation:: POOL_TYPE, genericmapping : *const super::super::super::Win32::Security:: GENERIC_MAPPING) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SeSetSecurityDescriptorInfo(::core::mem::transmute(object.unwrap_or(::std::ptr::null())), securityinformation, modificationdescriptor.into_param().abi(), objectssecuritydescriptor, pooltype, genericmapping).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeSetSecurityDescriptorInfoEx<P0>(object: ::core::option::Option<*const ::core::ffi::c_void>, securityinformation: *const u32, modificationdescriptor: P0, objectssecuritydescriptor: *mut super::super::super::Win32::Security::PSECURITY_DESCRIPTOR, autoinheritflags: u32, pooltype: super::super::Foundation::POOL_TYPE, genericmapping: *const super::super::super::Win32::Security::GENERIC_MAPPING) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeSetSecurityDescriptorInfoEx(object : *const ::core::ffi::c_void, securityinformation : *const u32, modificationdescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, objectssecuritydescriptor : *mut super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, autoinheritflags : u32, pooltype : super::super::Foundation:: POOL_TYPE, genericmapping : *const super::super::super::Win32::Security:: GENERIC_MAPPING) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SeSetSecurityDescriptorInfoEx(::core::mem::transmute(object.unwrap_or(::std::ptr::null())), securityinformation, modificationdescriptor.into_param().abi(), objectssecuritydescriptor, autoinheritflags, pooltype, genericmapping).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeShouldCheckForAccessRightsFromParent<P0>(objecttype: *const ::core::ffi::c_void, childdescriptor: P0, accessstate: *const super::super::Foundation::ACCESS_STATE) -> super::super::super::Win32::Foundation::BOOLEAN
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeShouldCheckForAccessRightsFromParent(objecttype : *const ::core::ffi::c_void, childdescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, accessstate : *const super::super::Foundation:: ACCESS_STATE) -> super::super::super::Win32::Foundation:: BOOLEAN);
    SeShouldCheckForAccessRightsFromParent(objecttype, childdescriptor.into_param().abi(), accessstate)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SeTokenFromAccessInformation(accessinformation: ::core::option::Option<*const TOKEN_ACCESS_INFORMATION>, token: ::core::option::Option<*mut ::core::ffi::c_void>, length: u32, requiredlength: *mut u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeTokenFromAccessInformation(accessinformation : *const TOKEN_ACCESS_INFORMATION, token : *mut ::core::ffi::c_void, length : u32, requiredlength : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SeTokenFromAccessInformation(::core::mem::transmute(accessinformation.unwrap_or(::std::ptr::null())), ::core::mem::transmute(token.unwrap_or(::std::ptr::null_mut())), length, requiredlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SeTokenIsAdmin(token: *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeTokenIsAdmin(token : *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: BOOLEAN);
    SeTokenIsAdmin(token)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SeTokenIsRestricted(token: *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeTokenIsRestricted(token : *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: BOOLEAN);
    SeTokenIsRestricted(token)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SeTokenIsWriteRestricted(token: *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeTokenIsWriteRestricted(token : *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: BOOLEAN);
    SeTokenIsWriteRestricted(token)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn SeTokenType(token: *const ::core::ffi::c_void) -> TOKEN_TYPE {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeTokenType(token : *const ::core::ffi::c_void) -> TOKEN_TYPE);
    SeTokenType(token)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SeUnregisterLogonSessionTerminatedRoutine(callbackroutine: PSE_LOGON_SESSION_TERMINATED_ROUTINE) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeUnregisterLogonSessionTerminatedRoutine(callbackroutine : PSE_LOGON_SESSION_TERMINATED_ROUTINE) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SeUnregisterLogonSessionTerminatedRoutine(callbackroutine).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SeUnregisterLogonSessionTerminatedRoutineEx(callbackroutine: PSE_LOGON_SESSION_TERMINATED_ROUTINE_EX, context: *const ::core::ffi::c_void) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntoskrnl.exe" "system" fn SeUnregisterLogonSessionTerminatedRoutineEx(callbackroutine : PSE_LOGON_SESSION_TERMINATED_ROUTINE_EX, context : *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SeUnregisterLogonSessionTerminatedRoutineEx(callbackroutine, context).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SecLookupAccountName(name: *const super::super::super::Win32::Foundation::UNICODE_STRING, sidsize: *mut u32, sid: super::super::super::Win32::Foundation::PSID, nameuse: *mut SID_NAME_USE, domainsize: *mut u32, referenceddomain: ::core::option::Option<*mut super::super::super::Win32::Foundation::UNICODE_STRING>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ksecdd.sys" "system" fn SecLookupAccountName(name : *const super::super::super::Win32::Foundation:: UNICODE_STRING, sidsize : *mut u32, sid : super::super::super::Win32::Foundation:: PSID, nameuse : *mut SID_NAME_USE, domainsize : *mut u32, referenceddomain : *mut super::super::super::Win32::Foundation:: UNICODE_STRING) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SecLookupAccountName(name, sidsize, sid, nameuse, domainsize, ::core::mem::transmute(referenceddomain.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SecLookupAccountSid<P0>(sid: P0, namesize: *mut u32, namebuffer: *mut super::super::super::Win32::Foundation::UNICODE_STRING, domainsize: *mut u32, domainbuffer: ::core::option::Option<*mut super::super::super::Win32::Foundation::UNICODE_STRING>, nameuse: *mut SID_NAME_USE) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
{
    ::windows_targets::link!("ksecdd.sys" "system" fn SecLookupAccountSid(sid : super::super::super::Win32::Foundation:: PSID, namesize : *mut u32, namebuffer : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, domainsize : *mut u32, domainbuffer : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, nameuse : *mut SID_NAME_USE) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SecLookupAccountSid(sid.into_param().abi(), namesize, namebuffer, domainsize, ::core::mem::transmute(domainbuffer.unwrap_or(::std::ptr::null_mut())), nameuse).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn SecLookupWellKnownSid(sidtype: super::super::super::Win32::Security::WELL_KNOWN_SID_TYPE, sid: super::super::super::Win32::Foundation::PSID, sidbuffersize: u32, sidsize: ::core::option::Option<*mut u32>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ksecdd.sys" "system" fn SecLookupWellKnownSid(sidtype : super::super::super::Win32::Security:: WELL_KNOWN_SID_TYPE, sid : super::super::super::Win32::Foundation:: PSID, sidbuffersize : u32, sidsize : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SecLookupWellKnownSid(sidtype, sid, sidbuffersize, ::core::mem::transmute(sidsize.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SecMakeSPN<P0>(serviceclass: *mut super::super::super::Win32::Foundation::UNICODE_STRING, servicename: *mut super::super::super::Win32::Foundation::UNICODE_STRING, instancename: *mut super::super::super::Win32::Foundation::UNICODE_STRING, instanceport: u16, referrer: *mut super::super::super::Win32::Foundation::UNICODE_STRING, spn: *mut super::super::super::Win32::Foundation::UNICODE_STRING, length: *mut u32, allocate: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ksecdd.sys" "system" fn SecMakeSPN(serviceclass : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, servicename : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, instancename : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, instanceport : u16, referrer : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, spn : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, length : *mut u32, allocate : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SecMakeSPN(serviceclass, servicename, instancename, instanceport, referrer, spn, length, allocate.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SecMakeSPNEx<P0>(serviceclass: *mut super::super::super::Win32::Foundation::UNICODE_STRING, servicename: *mut super::super::super::Win32::Foundation::UNICODE_STRING, instancename: *mut super::super::super::Win32::Foundation::UNICODE_STRING, instanceport: u16, referrer: *mut super::super::super::Win32::Foundation::UNICODE_STRING, targetinfo: *mut super::super::super::Win32::Foundation::UNICODE_STRING, spn: *mut super::super::super::Win32::Foundation::UNICODE_STRING, length: *mut u32, allocate: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ksecdd.sys" "system" fn SecMakeSPNEx(serviceclass : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, servicename : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, instancename : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, instanceport : u16, referrer : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, targetinfo : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, spn : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, length : *mut u32, allocate : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SecMakeSPNEx(serviceclass, servicename, instancename, instanceport, referrer, targetinfo, spn, length, allocate.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SecMakeSPNEx2<P0, P1>(serviceclass: *mut super::super::super::Win32::Foundation::UNICODE_STRING, servicename: *mut super::super::super::Win32::Foundation::UNICODE_STRING, instancename: *mut super::super::super::Win32::Foundation::UNICODE_STRING, instanceport: u16, referrer: *mut super::super::super::Win32::Foundation::UNICODE_STRING, intargetinfo: *mut super::super::super::Win32::Foundation::UNICODE_STRING, spn: *mut super::super::super::Win32::Foundation::UNICODE_STRING, totalsize: *mut u32, allocate: P0, istargetinfomarshaled: P1) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ksecdd.sys" "system" fn SecMakeSPNEx2(serviceclass : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, servicename : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, instancename : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, instanceport : u16, referrer : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, intargetinfo : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, spn : *mut super::super::super::Win32::Foundation:: UNICODE_STRING, totalsize : *mut u32, allocate : super::super::super::Win32::Foundation:: BOOLEAN, istargetinfomarshaled : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SecMakeSPNEx2(serviceclass, servicename, instancename, instanceport, referrer, intargetinfo, spn, totalsize, allocate.into_param().abi(), istargetinfomarshaled.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn SetContextAttributesW(phcontext: *const SecHandle, ulattribute: u32, pbuffer: *const ::core::ffi::c_void, cbbuffer: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn SetContextAttributesW(phcontext : *const SecHandle, ulattribute : u32, pbuffer : *const ::core::ffi::c_void, cbbuffer : u32) -> ::windows_core::HRESULT);
    SetContextAttributesW(phcontext, ulattribute, pbuffer, cbbuffer).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn SetCredentialsAttributesW(phcredential: *const SecHandle, ulattribute: u32, pbuffer: *const ::core::ffi::c_void, cbbuffer: u32) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn SetCredentialsAttributesW(phcredential : *const SecHandle, ulattribute : u32, pbuffer : *const ::core::ffi::c_void, cbbuffer : u32) -> ::windows_core::HRESULT);
    SetCredentialsAttributesW(phcredential, ulattribute, pbuffer, cbbuffer).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn SspiAcceptSecurityContextAsync(asynccontext: *mut SspiAsyncContext, phcredential: ::core::option::Option<*const SecHandle>, phcontext: ::core::option::Option<*const SecHandle>, pinput: ::core::option::Option<*const SecBufferDesc>, fcontextreq: u32, targetdatarep: u32, phnewcontext: ::core::option::Option<*const SecHandle>, poutput: ::core::option::Option<*const SecBufferDesc>, pfcontextattr: *const u32, ptsexpiry: ::core::option::Option<*const i64>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ksecdd.sys" "system" fn SspiAcceptSecurityContextAsync(asynccontext : *mut SspiAsyncContext, phcredential : *const SecHandle, phcontext : *const SecHandle, pinput : *const SecBufferDesc, fcontextreq : u32, targetdatarep : u32, phnewcontext : *const SecHandle, poutput : *const SecBufferDesc, pfcontextattr : *const u32, ptsexpiry : *const i64) -> ::windows_core::HRESULT);
    SspiAcceptSecurityContextAsync(asynccontext, ::core::mem::transmute(phcredential.unwrap_or(::std::ptr::null())), ::core::mem::transmute(phcontext.unwrap_or(::std::ptr::null())), ::core::mem::transmute(pinput.unwrap_or(::std::ptr::null())), fcontextreq, targetdatarep, ::core::mem::transmute(phnewcontext.unwrap_or(::std::ptr::null())), ::core::mem::transmute(poutput.unwrap_or(::std::ptr::null())), pfcontextattr, ::core::mem::transmute(ptsexpiry.unwrap_or(::std::ptr::null()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SspiAcquireCredentialsHandleAsyncW(asynccontext: *mut SspiAsyncContext, pszprincipal: ::core::option::Option<*const super::super::super::Win32::Foundation::UNICODE_STRING>, pszpackage: *const super::super::super::Win32::Foundation::UNICODE_STRING, fcredentialuse: u32, pvlogonid: ::core::option::Option<*const ::core::ffi::c_void>, pauthdata: ::core::option::Option<*const ::core::ffi::c_void>, pgetkeyfn: SEC_GET_KEY_FN, pvgetkeyargument: ::core::option::Option<*const ::core::ffi::c_void>, phcredential: *const SecHandle, ptsexpiry: ::core::option::Option<*const i64>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ksecdd.sys" "system" fn SspiAcquireCredentialsHandleAsyncW(asynccontext : *mut SspiAsyncContext, pszprincipal : *const super::super::super::Win32::Foundation:: UNICODE_STRING, pszpackage : *const super::super::super::Win32::Foundation:: UNICODE_STRING, fcredentialuse : u32, pvlogonid : *const ::core::ffi::c_void, pauthdata : *const ::core::ffi::c_void, pgetkeyfn : SEC_GET_KEY_FN, pvgetkeyargument : *const ::core::ffi::c_void, phcredential : *const SecHandle, ptsexpiry : *const i64) -> ::windows_core::HRESULT);
    SspiAcquireCredentialsHandleAsyncW(asynccontext, ::core::mem::transmute(pszprincipal.unwrap_or(::std::ptr::null())), pszpackage, fcredentialuse, ::core::mem::transmute(pvlogonid.unwrap_or(::std::ptr::null())), ::core::mem::transmute(pauthdata.unwrap_or(::std::ptr::null())), pgetkeyfn, ::core::mem::transmute(pvgetkeyargument.unwrap_or(::std::ptr::null())), phcredential, ::core::mem::transmute(ptsexpiry.unwrap_or(::std::ptr::null()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SspiCompareAuthIdentities(authidentity1: ::core::option::Option<*const ::core::ffi::c_void>, authidentity2: ::core::option::Option<*const ::core::ffi::c_void>, samesupplieduser: ::core::option::Option<*mut super::super::super::Win32::Foundation::BOOLEAN>, samesuppliedidentity: ::core::option::Option<*mut super::super::super::Win32::Foundation::BOOLEAN>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn SspiCompareAuthIdentities(authidentity1 : *const ::core::ffi::c_void, authidentity2 : *const ::core::ffi::c_void, samesupplieduser : *mut super::super::super::Win32::Foundation:: BOOLEAN, samesuppliedidentity : *mut super::super::super::Win32::Foundation:: BOOLEAN) -> ::windows_core::HRESULT);
    SspiCompareAuthIdentities(::core::mem::transmute(authidentity1.unwrap_or(::std::ptr::null())), ::core::mem::transmute(authidentity2.unwrap_or(::std::ptr::null())), ::core::mem::transmute(samesupplieduser.unwrap_or(::std::ptr::null_mut())), ::core::mem::transmute(samesuppliedidentity.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn SspiCopyAuthIdentity(authdata: *const ::core::ffi::c_void, authdatacopy: *mut *mut ::core::ffi::c_void) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn SspiCopyAuthIdentity(authdata : *const ::core::ffi::c_void, authdatacopy : *mut *mut ::core::ffi::c_void) -> ::windows_core::HRESULT);
    SspiCopyAuthIdentity(authdata, authdatacopy).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn SspiCreateAsyncContext() -> *mut SspiAsyncContext {
    ::windows_targets::link!("ksecdd.sys" "system" fn SspiCreateAsyncContext() -> *mut SspiAsyncContext);
    SspiCreateAsyncContext()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn SspiDeleteSecurityContextAsync(asynccontext: *mut SspiAsyncContext, phcontext: *const SecHandle) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ksecdd.sys" "system" fn SspiDeleteSecurityContextAsync(asynccontext : *mut SspiAsyncContext, phcontext : *const SecHandle) -> ::windows_core::HRESULT);
    SspiDeleteSecurityContextAsync(asynccontext, phcontext).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn SspiEncodeAuthIdentityAsStrings(pauthidentity: *const ::core::ffi::c_void, ppszusername: *mut ::windows_core::PCWSTR, ppszdomainname: *mut ::windows_core::PCWSTR, ppszpackedcredentialsstring: ::core::option::Option<*mut ::windows_core::PCWSTR>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn SspiEncodeAuthIdentityAsStrings(pauthidentity : *const ::core::ffi::c_void, ppszusername : *mut ::windows_core::PCWSTR, ppszdomainname : *mut ::windows_core::PCWSTR, ppszpackedcredentialsstring : *mut ::windows_core::PCWSTR) -> ::windows_core::HRESULT);
    SspiEncodeAuthIdentityAsStrings(pauthidentity, ppszusername, ppszdomainname, ::core::mem::transmute(ppszpackedcredentialsstring.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn SspiEncodeStringsAsAuthIdentity<P0, P1, P2>(pszusername: P0, pszdomainname: P1, pszpackedcredentialsstring: P2, ppauthidentity: *mut *mut ::core::ffi::c_void) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<::windows_core::PCWSTR>,
    P1: ::windows_core::IntoParam<::windows_core::PCWSTR>,
    P2: ::windows_core::IntoParam<::windows_core::PCWSTR>,
{
    ::windows_targets::link!("secur32.dll" "system" fn SspiEncodeStringsAsAuthIdentity(pszusername : ::windows_core::PCWSTR, pszdomainname : ::windows_core::PCWSTR, pszpackedcredentialsstring : ::windows_core::PCWSTR, ppauthidentity : *mut *mut ::core::ffi::c_void) -> ::windows_core::HRESULT);
    SspiEncodeStringsAsAuthIdentity(pszusername.into_param().abi(), pszdomainname.into_param().abi(), pszpackedcredentialsstring.into_param().abi(), ppauthidentity).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn SspiExcludePackage<P0>(authidentity: ::core::option::Option<*const ::core::ffi::c_void>, pszpackagename: P0, ppnewauthidentity: *mut *mut ::core::ffi::c_void) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<::windows_core::PCWSTR>,
{
    ::windows_targets::link!("secur32.dll" "system" fn SspiExcludePackage(authidentity : *const ::core::ffi::c_void, pszpackagename : ::windows_core::PCWSTR, ppnewauthidentity : *mut *mut ::core::ffi::c_void) -> ::windows_core::HRESULT);
    SspiExcludePackage(::core::mem::transmute(authidentity.unwrap_or(::std::ptr::null())), pszpackagename.into_param().abi(), ppnewauthidentity).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn SspiFreeAsyncContext(handle: ::core::option::Option<*const SspiAsyncContext>) {
    ::windows_targets::link!("ksecdd.sys" "system" fn SspiFreeAsyncContext(handle : *const SspiAsyncContext) -> ());
    SspiFreeAsyncContext(::core::mem::transmute(handle.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn SspiFreeAuthIdentity(authdata: ::core::option::Option<*const ::core::ffi::c_void>) {
    ::windows_targets::link!("secur32.dll" "system" fn SspiFreeAuthIdentity(authdata : *const ::core::ffi::c_void) -> ());
    SspiFreeAuthIdentity(::core::mem::transmute(authdata.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn SspiFreeCredentialsHandleAsync(asynccontext: *mut SspiAsyncContext, phcredential: *const SecHandle) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ksecdd.sys" "system" fn SspiFreeCredentialsHandleAsync(asynccontext : *mut SspiAsyncContext, phcredential : *const SecHandle) -> ::windows_core::HRESULT);
    SspiFreeCredentialsHandleAsync(asynccontext, phcredential).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn SspiGetAsyncCallStatus(handle: *const SspiAsyncContext) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ksecdd.sys" "system" fn SspiGetAsyncCallStatus(handle : *const SspiAsyncContext) -> ::windows_core::HRESULT);
    SspiGetAsyncCallStatus(handle).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn SspiGetTargetHostName<P0>(psztargetname: P0) -> ::windows_core::Result<::windows_core::PWSTR>
where
    P0: ::windows_core::IntoParam<::windows_core::PCWSTR>,
{
    ::windows_targets::link!("secur32.dll" "system" fn SspiGetTargetHostName(psztargetname : ::windows_core::PCWSTR, pszhostname : *mut ::windows_core::PWSTR) -> ::windows_core::HRESULT);
    let mut result__ = ::std::mem::zeroed();
    SspiGetTargetHostName(psztargetname.into_param().abi(), &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SspiInitializeSecurityContextAsyncW(asynccontext: *mut SspiAsyncContext, phcredential: ::core::option::Option<*const SecHandle>, phcontext: ::core::option::Option<*const SecHandle>, psztargetname: ::core::option::Option<*const super::super::super::Win32::Foundation::UNICODE_STRING>, fcontextreq: u32, reserved1: u32, targetdatarep: u32, pinput: ::core::option::Option<*const SecBufferDesc>, reserved2: u32, phnewcontext: ::core::option::Option<*const SecHandle>, poutput: ::core::option::Option<*const SecBufferDesc>, pfcontextattr: *const u32, ptsexpiry: ::core::option::Option<*const i64>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ksecdd.sys" "system" fn SspiInitializeSecurityContextAsyncW(asynccontext : *mut SspiAsyncContext, phcredential : *const SecHandle, phcontext : *const SecHandle, psztargetname : *const super::super::super::Win32::Foundation:: UNICODE_STRING, fcontextreq : u32, reserved1 : u32, targetdatarep : u32, pinput : *const SecBufferDesc, reserved2 : u32, phnewcontext : *const SecHandle, poutput : *const SecBufferDesc, pfcontextattr : *const u32, ptsexpiry : *const i64) -> ::windows_core::HRESULT);
    SspiInitializeSecurityContextAsyncW(
        asynccontext,
        ::core::mem::transmute(phcredential.unwrap_or(::std::ptr::null())),
        ::core::mem::transmute(phcontext.unwrap_or(::std::ptr::null())),
        ::core::mem::transmute(psztargetname.unwrap_or(::std::ptr::null())),
        fcontextreq,
        reserved1,
        targetdatarep,
        ::core::mem::transmute(pinput.unwrap_or(::std::ptr::null())),
        reserved2,
        ::core::mem::transmute(phnewcontext.unwrap_or(::std::ptr::null())),
        ::core::mem::transmute(poutput.unwrap_or(::std::ptr::null())),
        pfcontextattr,
        ::core::mem::transmute(ptsexpiry.unwrap_or(::std::ptr::null())),
    )
    .ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SspiIsPromptingNeeded(errororntstatus: u32) -> super::super::super::Win32::Foundation::BOOLEAN {
    ::windows_targets::link!("credui.dll" "system" fn SspiIsPromptingNeeded(errororntstatus : u32) -> super::super::super::Win32::Foundation:: BOOLEAN);
    SspiIsPromptingNeeded(errororntstatus)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn SspiLocalFree(databuffer: ::core::option::Option<*const ::core::ffi::c_void>) {
    ::windows_targets::link!("secur32.dll" "system" fn SspiLocalFree(databuffer : *const ::core::ffi::c_void) -> ());
    SspiLocalFree(::core::mem::transmute(databuffer.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn SspiMarshalAuthIdentity(authidentity: *const ::core::ffi::c_void, authidentitylength: *mut u32, authidentitybytearray: *mut *mut i8) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn SspiMarshalAuthIdentity(authidentity : *const ::core::ffi::c_void, authidentitylength : *mut u32, authidentitybytearray : *mut *mut i8) -> ::windows_core::HRESULT);
    SspiMarshalAuthIdentity(authidentity, authidentitylength, authidentitybytearray).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn SspiReinitAsyncContext(handle: *mut SspiAsyncContext) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ksecdd.sys" "system" fn SspiReinitAsyncContext(handle : *mut SspiAsyncContext) -> super::super::super::Win32::Foundation:: NTSTATUS);
    SspiReinitAsyncContext(handle).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn SspiSetAsyncNotifyCallback(context: *const SspiAsyncContext, callback: SspiAsyncNotifyCallback, callbackdata: ::core::option::Option<*const ::core::ffi::c_void>) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ksecdd.sys" "system" fn SspiSetAsyncNotifyCallback(context : *const SspiAsyncContext, callback : SspiAsyncNotifyCallback, callbackdata : *const ::core::ffi::c_void) -> ::windows_core::HRESULT);
    SspiSetAsyncNotifyCallback(context, callback, ::core::mem::transmute(callbackdata.unwrap_or(::std::ptr::null()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn SspiUnmarshalAuthIdentity(authidentitybytearray: &[u8], ppauthidentity: *mut *mut ::core::ffi::c_void) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn SspiUnmarshalAuthIdentity(authidentitylength : u32, authidentitybytearray : ::windows_core::PCSTR, ppauthidentity : *mut *mut ::core::ffi::c_void) -> ::windows_core::HRESULT);
    SspiUnmarshalAuthIdentity(authidentitybytearray.len() as _, ::core::mem::transmute(authidentitybytearray.as_ptr()), ppauthidentity).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn SspiValidateAuthIdentity(authdata: *const ::core::ffi::c_void) -> ::windows_core::Result<()> {
    ::windows_targets::link!("secur32.dll" "system" fn SspiValidateAuthIdentity(authdata : *const ::core::ffi::c_void) -> ::windows_core::HRESULT);
    SspiValidateAuthIdentity(authdata).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn SspiZeroAuthIdentity(authdata: ::core::option::Option<*const ::core::ffi::c_void>) {
    ::windows_targets::link!("secur32.dll" "system" fn SspiZeroAuthIdentity(authdata : *const ::core::ffi::c_void) -> ());
    SspiZeroAuthIdentity(::core::mem::transmute(authdata.unwrap_or(::std::ptr::null())))
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[inline]
pub unsafe fn VerifySignature(phcontext: *const SecHandle, pmessage: *const SecBufferDesc, messageseqno: u32) -> ::windows_core::Result<u32> {
    ::windows_targets::link!("secur32.dll" "system" fn VerifySignature(phcontext : *const SecHandle, pmessage : *const SecBufferDesc, messageseqno : u32, pfqop : *mut u32) -> ::windows_core::HRESULT);
    let mut result__ = ::std::mem::zeroed();
    VerifySignature(phcontext, pmessage, messageseqno, &mut result__).from_abi(result__)
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn ZwAllocateVirtualMemory<P0>(processhandle: P0, baseaddress: *mut *mut ::core::ffi::c_void, zerobits: usize, regionsize: *mut usize, allocationtype: u32, protect: u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwAllocateVirtualMemory(processhandle : super::super::super::Win32::Foundation:: HANDLE, baseaddress : *mut *mut ::core::ffi::c_void, zerobits : usize, regionsize : *mut usize, allocationtype : u32, protect : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwAllocateVirtualMemory(processhandle.into_param().abi(), baseaddress, zerobits, regionsize, allocationtype, protect).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_Memory\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Memory"))]
#[inline]
pub unsafe fn ZwAllocateVirtualMemoryEx<P0>(processhandle: P0, baseaddress: *mut *mut ::core::ffi::c_void, regionsize: *mut usize, allocationtype: u32, pageprotection: u32, extendedparameters: ::core::option::Option<&mut [super::super::super::Win32::System::Memory::MEM_EXTENDED_PARAMETER]>) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwAllocateVirtualMemoryEx(processhandle : super::super::super::Win32::Foundation:: HANDLE, baseaddress : *mut *mut ::core::ffi::c_void, regionsize : *mut usize, allocationtype : u32, pageprotection : u32, extendedparameters : *mut super::super::super::Win32::System::Memory:: MEM_EXTENDED_PARAMETER, extendedparametercount : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwAllocateVirtualMemoryEx(processhandle.into_param().abi(), baseaddress, regionsize, allocationtype, pageprotection, ::core::mem::transmute(extendedparameters.as_deref().map_or(::core::ptr::null(), |slice| slice.as_ptr())), extendedparameters.as_deref().map_or(0, |slice| slice.len() as _)).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn ZwCreateEvent<P0>(eventhandle: *mut super::super::super::Win32::Foundation::HANDLE, desiredaccess: u32, objectattributes: ::core::option::Option<*const super::super::super::Win32::System::WindowsProgramming::OBJECT_ATTRIBUTES>, eventtype: super::super::super::Win32::System::Kernel::EVENT_TYPE, initialstate: P0) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwCreateEvent(eventhandle : *mut super::super::super::Win32::Foundation:: HANDLE, desiredaccess : u32, objectattributes : *const super::super::super::Win32::System::WindowsProgramming:: OBJECT_ATTRIBUTES, eventtype : super::super::super::Win32::System::Kernel:: EVENT_TYPE, initialstate : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwCreateEvent(eventhandle, desiredaccess, ::core::mem::transmute(objectattributes.unwrap_or(::std::ptr::null())), eventtype, initialstate.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn ZwDeleteFile(objectattributes: *const super::super::super::Win32::System::WindowsProgramming::OBJECT_ATTRIBUTES) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn ZwDeleteFile(objectattributes : *const super::super::super::Win32::System::WindowsProgramming:: OBJECT_ATTRIBUTES) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwDeleteFile(objectattributes).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn ZwDuplicateObject<P0, P1, P2>(sourceprocesshandle: P0, sourcehandle: P1, targetprocesshandle: P2, targethandle: ::core::option::Option<*mut super::super::super::Win32::Foundation::HANDLE>, desiredaccess: u32, handleattributes: u32, options: u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P2: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwDuplicateObject(sourceprocesshandle : super::super::super::Win32::Foundation:: HANDLE, sourcehandle : super::super::super::Win32::Foundation:: HANDLE, targetprocesshandle : super::super::super::Win32::Foundation:: HANDLE, targethandle : *mut super::super::super::Win32::Foundation:: HANDLE, desiredaccess : u32, handleattributes : u32, options : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwDuplicateObject(sourceprocesshandle.into_param().abi(), sourcehandle.into_param().abi(), targetprocesshandle.into_param().abi(), ::core::mem::transmute(targethandle.unwrap_or(::std::ptr::null_mut())), desiredaccess, handleattributes, options).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn ZwDuplicateToken<P0, P1>(existingtokenhandle: P0, desiredaccess: u32, objectattributes: ::core::option::Option<*const super::super::super::Win32::System::WindowsProgramming::OBJECT_ATTRIBUTES>, effectiveonly: P1, tokentype: TOKEN_TYPE, newtokenhandle: *mut super::super::super::Win32::Foundation::HANDLE) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwDuplicateToken(existingtokenhandle : super::super::super::Win32::Foundation:: HANDLE, desiredaccess : u32, objectattributes : *const super::super::super::Win32::System::WindowsProgramming:: OBJECT_ATTRIBUTES, effectiveonly : super::super::super::Win32::Foundation:: BOOLEAN, tokentype : TOKEN_TYPE, newtokenhandle : *mut super::super::super::Win32::Foundation:: HANDLE) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwDuplicateToken(existingtokenhandle.into_param().abi(), desiredaccess, ::core::mem::transmute(objectattributes.unwrap_or(::std::ptr::null())), effectiveonly.into_param().abi(), tokentype, newtokenhandle).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn ZwFlushBuffersFile<P0>(filehandle: P0, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwFlushBuffersFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwFlushBuffersFile(filehandle.into_param().abi(), iostatusblock).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn ZwFlushBuffersFileEx<P0>(filehandle: P0, flags: u32, parameters: *const ::core::ffi::c_void, parameterssize: u32, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwFlushBuffersFileEx(filehandle : super::super::super::Win32::Foundation:: HANDLE, flags : u32, parameters : *const ::core::ffi::c_void, parameterssize : u32, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwFlushBuffersFileEx(filehandle.into_param().abi(), flags, parameters, parameterssize, iostatusblock).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn ZwFlushVirtualMemory<P0>(processhandle: P0, baseaddress: *mut *mut ::core::ffi::c_void, regionsize: *mut usize, iostatus: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwFlushVirtualMemory(processhandle : super::super::super::Win32::Foundation:: HANDLE, baseaddress : *mut *mut ::core::ffi::c_void, regionsize : *mut usize, iostatus : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwFlushVirtualMemory(processhandle.into_param().abi(), baseaddress, regionsize, iostatus).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn ZwFreeVirtualMemory<P0>(processhandle: P0, baseaddress: *mut *mut ::core::ffi::c_void, regionsize: *mut usize, freetype: u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwFreeVirtualMemory(processhandle : super::super::super::Win32::Foundation:: HANDLE, baseaddress : *mut *mut ::core::ffi::c_void, regionsize : *mut usize, freetype : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwFreeVirtualMemory(processhandle.into_param().abi(), baseaddress, regionsize, freetype).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn ZwFsControlFile<P0, P1>(filehandle: P0, event: P1, apcroutine: super::super::Foundation::PIO_APC_ROUTINE, apccontext: ::core::option::Option<*const ::core::ffi::c_void>, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, fscontrolcode: u32, inputbuffer: ::core::option::Option<*const ::core::ffi::c_void>, inputbufferlength: u32, outputbuffer: ::core::option::Option<*mut ::core::ffi::c_void>, outputbufferlength: u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwFsControlFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, event : super::super::super::Win32::Foundation:: HANDLE, apcroutine : super::super::Foundation:: PIO_APC_ROUTINE, apccontext : *const ::core::ffi::c_void, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, fscontrolcode : u32, inputbuffer : *const ::core::ffi::c_void, inputbufferlength : u32, outputbuffer : *mut ::core::ffi::c_void, outputbufferlength : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwFsControlFile(filehandle.into_param().abi(), event.into_param().abi(), apcroutine, ::core::mem::transmute(apccontext.unwrap_or(::std::ptr::null())), iostatusblock, fscontrolcode, ::core::mem::transmute(inputbuffer.unwrap_or(::std::ptr::null())), inputbufferlength, ::core::mem::transmute(outputbuffer.unwrap_or(::std::ptr::null_mut())), outputbufferlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn ZwLockFile<P0, P1, P2, P3>(filehandle: P0, event: P1, apcroutine: super::super::Foundation::PIO_APC_ROUTINE, apccontext: ::core::option::Option<*const ::core::ffi::c_void>, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, byteoffset: *const i64, length: *const i64, key: u32, failimmediately: P2, exclusivelock: P3) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P2: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P3: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwLockFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, event : super::super::super::Win32::Foundation:: HANDLE, apcroutine : super::super::Foundation:: PIO_APC_ROUTINE, apccontext : *const ::core::ffi::c_void, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, byteoffset : *const i64, length : *const i64, key : u32, failimmediately : super::super::super::Win32::Foundation:: BOOLEAN, exclusivelock : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwLockFile(filehandle.into_param().abi(), event.into_param().abi(), apcroutine, ::core::mem::transmute(apccontext.unwrap_or(::std::ptr::null())), iostatusblock, byteoffset, length, key, failimmediately.into_param().abi(), exclusivelock.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn ZwNotifyChangeKey<P0, P1, P2, P3>(keyhandle: P0, event: P1, apcroutine: super::super::Foundation::PIO_APC_ROUTINE, apccontext: ::core::option::Option<*const ::core::ffi::c_void>, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, completionfilter: u32, watchtree: P2, buffer: ::core::option::Option<*mut ::core::ffi::c_void>, buffersize: u32, asynchronous: P3) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P2: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P3: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwNotifyChangeKey(keyhandle : super::super::super::Win32::Foundation:: HANDLE, event : super::super::super::Win32::Foundation:: HANDLE, apcroutine : super::super::Foundation:: PIO_APC_ROUTINE, apccontext : *const ::core::ffi::c_void, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, completionfilter : u32, watchtree : super::super::super::Win32::Foundation:: BOOLEAN, buffer : *mut ::core::ffi::c_void, buffersize : u32, asynchronous : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwNotifyChangeKey(keyhandle.into_param().abi(), event.into_param().abi(), apcroutine, ::core::mem::transmute(apccontext.unwrap_or(::std::ptr::null())), iostatusblock, completionfilter, watchtree.into_param().abi(), ::core::mem::transmute(buffer.unwrap_or(::std::ptr::null_mut())), buffersize, asynchronous.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn ZwOpenDirectoryObject(directoryhandle: *mut super::super::super::Win32::Foundation::HANDLE, desiredaccess: u32, objectattributes: *const super::super::super::Win32::System::WindowsProgramming::OBJECT_ATTRIBUTES) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn ZwOpenDirectoryObject(directoryhandle : *mut super::super::super::Win32::Foundation:: HANDLE, desiredaccess : u32, objectattributes : *const super::super::super::Win32::System::WindowsProgramming:: OBJECT_ATTRIBUTES) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwOpenDirectoryObject(directoryhandle, desiredaccess, objectattributes).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn ZwOpenProcessTokenEx<P0>(processhandle: P0, desiredaccess: u32, handleattributes: u32, tokenhandle: *mut super::super::super::Win32::Foundation::HANDLE) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwOpenProcessTokenEx(processhandle : super::super::super::Win32::Foundation:: HANDLE, desiredaccess : u32, handleattributes : u32, tokenhandle : *mut super::super::super::Win32::Foundation:: HANDLE) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwOpenProcessTokenEx(processhandle.into_param().abi(), desiredaccess, handleattributes, tokenhandle).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn ZwOpenThreadTokenEx<P0, P1>(threadhandle: P0, desiredaccess: u32, openasself: P1, handleattributes: u32, tokenhandle: *mut super::super::super::Win32::Foundation::HANDLE) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwOpenThreadTokenEx(threadhandle : super::super::super::Win32::Foundation:: HANDLE, desiredaccess : u32, openasself : super::super::super::Win32::Foundation:: BOOLEAN, handleattributes : u32, tokenhandle : *mut super::super::super::Win32::Foundation:: HANDLE) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwOpenThreadTokenEx(threadhandle.into_param().abi(), desiredaccess, openasself.into_param().abi(), handleattributes, tokenhandle).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn ZwQueryDirectoryFile<P0, P1, P2, P3>(filehandle: P0, event: P1, apcroutine: super::super::Foundation::PIO_APC_ROUTINE, apccontext: ::core::option::Option<*const ::core::ffi::c_void>, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, fileinformation: *mut ::core::ffi::c_void, length: u32, fileinformationclass: super::super::super::Win32::System::WindowsProgramming::FILE_INFORMATION_CLASS, returnsingleentry: P2, filename: ::core::option::Option<*const super::super::super::Win32::Foundation::UNICODE_STRING>, restartscan: P3) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P2: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P3: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwQueryDirectoryFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, event : super::super::super::Win32::Foundation:: HANDLE, apcroutine : super::super::Foundation:: PIO_APC_ROUTINE, apccontext : *const ::core::ffi::c_void, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, fileinformation : *mut ::core::ffi::c_void, length : u32, fileinformationclass : super::super::super::Win32::System::WindowsProgramming:: FILE_INFORMATION_CLASS, returnsingleentry : super::super::super::Win32::Foundation:: BOOLEAN, filename : *const super::super::super::Win32::Foundation:: UNICODE_STRING, restartscan : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwQueryDirectoryFile(filehandle.into_param().abi(), event.into_param().abi(), apcroutine, ::core::mem::transmute(apccontext.unwrap_or(::std::ptr::null())), iostatusblock, fileinformation, length, fileinformationclass, returnsingleentry.into_param().abi(), ::core::mem::transmute(filename.unwrap_or(::std::ptr::null())), restartscan.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn ZwQueryDirectoryFileEx<P0, P1>(filehandle: P0, event: P1, apcroutine: super::super::Foundation::PIO_APC_ROUTINE, apccontext: ::core::option::Option<*const ::core::ffi::c_void>, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, fileinformation: *mut ::core::ffi::c_void, length: u32, fileinformationclass: super::super::super::Win32::System::WindowsProgramming::FILE_INFORMATION_CLASS, queryflags: u32, filename: ::core::option::Option<*const super::super::super::Win32::Foundation::UNICODE_STRING>) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwQueryDirectoryFileEx(filehandle : super::super::super::Win32::Foundation:: HANDLE, event : super::super::super::Win32::Foundation:: HANDLE, apcroutine : super::super::Foundation:: PIO_APC_ROUTINE, apccontext : *const ::core::ffi::c_void, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, fileinformation : *mut ::core::ffi::c_void, length : u32, fileinformationclass : super::super::super::Win32::System::WindowsProgramming:: FILE_INFORMATION_CLASS, queryflags : u32, filename : *const super::super::super::Win32::Foundation:: UNICODE_STRING) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwQueryDirectoryFileEx(filehandle.into_param().abi(), event.into_param().abi(), apcroutine, ::core::mem::transmute(apccontext.unwrap_or(::std::ptr::null())), iostatusblock, fileinformation, length, fileinformationclass, queryflags, ::core::mem::transmute(filename.unwrap_or(::std::ptr::null()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn ZwQueryEaFile<P0, P1, P2>(filehandle: P0, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, buffer: *mut ::core::ffi::c_void, length: u32, returnsingleentry: P1, ealist: ::core::option::Option<*const ::core::ffi::c_void>, ealistlength: u32, eaindex: ::core::option::Option<*const u32>, restartscan: P2) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P2: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwQueryEaFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, buffer : *mut ::core::ffi::c_void, length : u32, returnsingleentry : super::super::super::Win32::Foundation:: BOOLEAN, ealist : *const ::core::ffi::c_void, ealistlength : u32, eaindex : *const u32, restartscan : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwQueryEaFile(filehandle.into_param().abi(), iostatusblock, buffer, length, returnsingleentry.into_param().abi(), ::core::mem::transmute(ealist.unwrap_or(::std::ptr::null())), ealistlength, ::core::mem::transmute(eaindex.unwrap_or(::std::ptr::null())), restartscan.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn ZwQueryFullAttributesFile(objectattributes: *const super::super::super::Win32::System::WindowsProgramming::OBJECT_ATTRIBUTES, fileinformation: *mut FILE_NETWORK_OPEN_INFORMATION) -> ::windows_core::Result<()> {
    ::windows_targets::link!("ntdll.dll" "system" fn ZwQueryFullAttributesFile(objectattributes : *const super::super::super::Win32::System::WindowsProgramming:: OBJECT_ATTRIBUTES, fileinformation : *mut FILE_NETWORK_OPEN_INFORMATION) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwQueryFullAttributesFile(objectattributes, fileinformation).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn ZwQueryInformationToken<P0>(tokenhandle: P0, tokeninformationclass: TOKEN_INFORMATION_CLASS, tokeninformation: ::core::option::Option<*mut ::core::ffi::c_void>, tokeninformationlength: u32, returnlength: *mut u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwQueryInformationToken(tokenhandle : super::super::super::Win32::Foundation:: HANDLE, tokeninformationclass : TOKEN_INFORMATION_CLASS, tokeninformation : *mut ::core::ffi::c_void, tokeninformationlength : u32, returnlength : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwQueryInformationToken(tokenhandle.into_param().abi(), tokeninformationclass, ::core::mem::transmute(tokeninformation.unwrap_or(::std::ptr::null_mut())), tokeninformationlength, returnlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn ZwQueryObject<P0>(handle: P0, objectinformationclass: OBJECT_INFORMATION_CLASS, objectinformation: ::core::option::Option<*mut ::core::ffi::c_void>, objectinformationlength: u32, returnlength: ::core::option::Option<*mut u32>) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwQueryObject(handle : super::super::super::Win32::Foundation:: HANDLE, objectinformationclass : OBJECT_INFORMATION_CLASS, objectinformation : *mut ::core::ffi::c_void, objectinformationlength : u32, returnlength : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwQueryObject(handle.into_param().abi(), objectinformationclass, ::core::mem::transmute(objectinformation.unwrap_or(::std::ptr::null_mut())), objectinformationlength, ::core::mem::transmute(returnlength.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn ZwQueryQuotaInformationFile<P0, P1, P2, P3>(filehandle: P0, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, buffer: *mut ::core::ffi::c_void, length: u32, returnsingleentry: P1, sidlist: ::core::option::Option<*const ::core::ffi::c_void>, sidlistlength: u32, startsid: P2, restartscan: P3) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
    P2: ::windows_core::IntoParam<super::super::super::Win32::Foundation::PSID>,
    P3: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwQueryQuotaInformationFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, buffer : *mut ::core::ffi::c_void, length : u32, returnsingleentry : super::super::super::Win32::Foundation:: BOOLEAN, sidlist : *const ::core::ffi::c_void, sidlistlength : u32, startsid : super::super::super::Win32::Foundation:: PSID, restartscan : super::super::super::Win32::Foundation:: BOOLEAN) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwQueryQuotaInformationFile(filehandle.into_param().abi(), iostatusblock, buffer, length, returnsingleentry.into_param().abi(), ::core::mem::transmute(sidlist.unwrap_or(::std::ptr::null())), sidlistlength, startsid.into_param().abi(), restartscan.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn ZwQuerySecurityObject<P0>(handle: P0, securityinformation: u32, securitydescriptor: super::super::super::Win32::Security::PSECURITY_DESCRIPTOR, length: u32, lengthneeded: *mut u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwQuerySecurityObject(handle : super::super::super::Win32::Foundation:: HANDLE, securityinformation : u32, securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR, length : u32, lengthneeded : *mut u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwQuerySecurityObject(handle.into_param().abi(), securityinformation, securitydescriptor, length, lengthneeded).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn ZwQueryVirtualMemory<P0>(processhandle: P0, baseaddress: ::core::option::Option<*const ::core::ffi::c_void>, memoryinformationclass: MEMORY_INFORMATION_CLASS, memoryinformation: *mut ::core::ffi::c_void, memoryinformationlength: usize, returnlength: ::core::option::Option<*mut usize>) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwQueryVirtualMemory(processhandle : super::super::super::Win32::Foundation:: HANDLE, baseaddress : *const ::core::ffi::c_void, memoryinformationclass : MEMORY_INFORMATION_CLASS, memoryinformation : *mut ::core::ffi::c_void, memoryinformationlength : usize, returnlength : *mut usize) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwQueryVirtualMemory(processhandle.into_param().abi(), ::core::mem::transmute(baseaddress.unwrap_or(::std::ptr::null())), memoryinformationclass, memoryinformation, memoryinformationlength, ::core::mem::transmute(returnlength.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn ZwQueryVolumeInformationFile<P0>(filehandle: P0, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, fsinformation: *mut ::core::ffi::c_void, length: u32, fsinformationclass: FS_INFORMATION_CLASS) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwQueryVolumeInformationFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, fsinformation : *mut ::core::ffi::c_void, length : u32, fsinformationclass : FS_INFORMATION_CLASS) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwQueryVolumeInformationFile(filehandle.into_param().abi(), iostatusblock, fsinformation, length, fsinformationclass).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn ZwSetEaFile<P0>(filehandle: P0, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, buffer: *const ::core::ffi::c_void, length: u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwSetEaFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, buffer : *const ::core::ffi::c_void, length : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwSetEaFile(filehandle.into_param().abi(), iostatusblock, buffer, length).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn ZwSetEvent<P0>(eventhandle: P0, previousstate: ::core::option::Option<*mut i32>) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwSetEvent(eventhandle : super::super::super::Win32::Foundation:: HANDLE, previousstate : *mut i32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwSetEvent(eventhandle.into_param().abi(), ::core::mem::transmute(previousstate.unwrap_or(::std::ptr::null_mut()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn ZwSetInformationToken<P0>(tokenhandle: P0, tokeninformationclass: TOKEN_INFORMATION_CLASS, tokeninformation: *const ::core::ffi::c_void, tokeninformationlength: u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwSetInformationToken(tokenhandle : super::super::super::Win32::Foundation:: HANDLE, tokeninformationclass : TOKEN_INFORMATION_CLASS, tokeninformation : *const ::core::ffi::c_void, tokeninformationlength : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwSetInformationToken(tokenhandle.into_param().abi(), tokeninformationclass, tokeninformation, tokeninformationlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn ZwSetInformationVirtualMemory<P0>(processhandle: P0, vminformationclass: VIRTUAL_MEMORY_INFORMATION_CLASS, virtualaddresses: &[MEMORY_RANGE_ENTRY], vminformation: *const ::core::ffi::c_void, vminformationlength: u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwSetInformationVirtualMemory(processhandle : super::super::super::Win32::Foundation:: HANDLE, vminformationclass : VIRTUAL_MEMORY_INFORMATION_CLASS, numberofentries : usize, virtualaddresses : *const MEMORY_RANGE_ENTRY, vminformation : *const ::core::ffi::c_void, vminformationlength : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwSetInformationVirtualMemory(processhandle.into_param().abi(), vminformationclass, virtualaddresses.len() as _, ::core::mem::transmute(virtualaddresses.as_ptr()), vminformation, vminformationlength).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn ZwSetQuotaInformationFile<P0>(filehandle: P0, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, buffer: *const ::core::ffi::c_void, length: u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwSetQuotaInformationFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, buffer : *const ::core::ffi::c_void, length : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwSetQuotaInformationFile(filehandle.into_param().abi(), iostatusblock, buffer, length).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
#[inline]
pub unsafe fn ZwSetSecurityObject<P0, P1>(handle: P0, securityinformation: u32, securitydescriptor: P1) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Security::PSECURITY_DESCRIPTOR>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwSetSecurityObject(handle : super::super::super::Win32::Foundation:: HANDLE, securityinformation : u32, securitydescriptor : super::super::super::Win32::Security:: PSECURITY_DESCRIPTOR) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwSetSecurityObject(handle.into_param().abi(), securityinformation, securitydescriptor.into_param().abi()).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn ZwSetVolumeInformationFile<P0>(filehandle: P0, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, fsinformation: *const ::core::ffi::c_void, length: u32, fsinformationclass: FS_INFORMATION_CLASS) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwSetVolumeInformationFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, fsinformation : *const ::core::ffi::c_void, length : u32, fsinformationclass : FS_INFORMATION_CLASS) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwSetVolumeInformationFile(filehandle.into_param().abi(), iostatusblock, fsinformation, length, fsinformationclass).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_WindowsProgramming"))]
#[inline]
pub unsafe fn ZwUnlockFile<P0>(filehandle: P0, iostatusblock: *mut super::super::super::Win32::System::WindowsProgramming::IO_STATUS_BLOCK, byteoffset: *const i64, length: *const i64, key: u32) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwUnlockFile(filehandle : super::super::super::Win32::Foundation:: HANDLE, iostatusblock : *mut super::super::super::Win32::System::WindowsProgramming:: IO_STATUS_BLOCK, byteoffset : *const i64, length : *const i64, key : u32) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwUnlockFile(filehandle.into_param().abi(), iostatusblock, byteoffset, length, key).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
#[inline]
pub unsafe fn ZwWaitForSingleObject<P0, P1>(handle: P0, alertable: P1, timeout: ::core::option::Option<*const i64>) -> ::windows_core::Result<()>
where
    P0: ::windows_core::IntoParam<super::super::super::Win32::Foundation::HANDLE>,
    P1: ::windows_core::IntoParam<super::super::super::Win32::Foundation::BOOLEAN>,
{
    ::windows_targets::link!("ntdll.dll" "system" fn ZwWaitForSingleObject(handle : super::super::super::Win32::Foundation:: HANDLE, alertable : super::super::super::Win32::Foundation:: BOOLEAN, timeout : *const i64) -> super::super::super::Win32::Foundation:: NTSTATUS);
    ZwWaitForSingleObject(handle.into_param().abi(), alertable.into_param().abi(), ::core::mem::transmute(timeout.unwrap_or(::std::ptr::null()))).ok()
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_ALLOWED_ACE_TYPE: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_ALLOWED_CALLBACK_ACE_TYPE: u32 = 9u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE: u32 = 11u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_ALLOWED_COMPOUND_ACE_TYPE: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_ALLOWED_OBJECT_ACE_TYPE: u32 = 5u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_DENIED_ACE_TYPE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_DENIED_CALLBACK_ACE_TYPE: u32 = 10u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE: u32 = 12u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_DENIED_OBJECT_ACE_TYPE: u32 = 6u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_DS_OBJECT_TYPE_NAME_A: ::windows_core::PCSTR = ::windows_core::s!("Directory Service Object");
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_DS_OBJECT_TYPE_NAME_W: ::windows_core::PCWSTR = ::windows_core::w!("Directory Service Object");
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_DS_SOURCE_A: ::windows_core::PCSTR = ::windows_core::s!("DS");
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_DS_SOURCE_W: ::windows_core::PCWSTR = ::windows_core::w!("DS");
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_MAX_LEVEL: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_MAX_MS_ACE_TYPE: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_MAX_MS_OBJECT_ACE_TYPE: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_MAX_MS_V2_ACE_TYPE: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_MAX_MS_V3_ACE_TYPE: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_MAX_MS_V4_ACE_TYPE: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_MAX_MS_V5_ACE_TYPE: u32 = 21u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_MIN_MS_ACE_TYPE: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_MIN_MS_OBJECT_ACE_TYPE: u32 = 5u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_OBJECT_GUID: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_PROPERTY_GUID: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_PROPERTY_SET_GUID: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_REASON_DATA_MASK: u32 = 65535u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_REASON_EXDATA_MASK: u32 = 2130706432u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_REASON_STAGING_MASK: u32 = 2147483648u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ACCESS_REASON_TYPE_MASK: u32 = 16711680u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_ALLOCATE_MEMORY: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_ALLOW_CONTEXT_REPLAY: u32 = 4194304u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_ALLOW_MISSING_BINDINGS: u32 = 268435456u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_ALLOW_NON_USER_LOGONS: u32 = 2097152u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_ALLOW_NULL_SESSION: u32 = 1048576u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_CALL_LEVEL: u32 = 4096u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_CONFIDENTIALITY: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_CONNECTION: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_DATAGRAM: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_DELEGATE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_EXTENDED_ERROR: u32 = 32768u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_FRAGMENT_SUPPLIED: u32 = 8192u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_FRAGMENT_TO_FIT: u32 = 8388608u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_IDENTIFY: u32 = 524288u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_INTEGRITY: u32 = 131072u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_LICENSING: u32 = 262144u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_MESSAGES: u64 = 4294967296u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_MUTUAL_AUTH: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_NO_TOKEN: u32 = 16777216u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_PROXY_BINDINGS: u32 = 67108864u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_REPLAY_DETECT: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_SEQUENCE_DETECT: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_SESSION_TICKET: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_STREAM: u32 = 65536u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_USE_DCE_STYLE: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_REQ_USE_SESSION_KEY: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_ALLOCATED_MEMORY: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_ALLOW_CONTEXT_REPLAY: u32 = 4194304u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_ALLOW_NON_USER_LOGONS: u32 = 2097152u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_CALL_LEVEL: u32 = 8192u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_CONFIDENTIALITY: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_CONNECTION: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_DATAGRAM: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_DELEGATE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_EXTENDED_ERROR: u32 = 32768u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_FRAGMENT_ONLY: u32 = 8388608u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_IDENTIFY: u32 = 524288u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_INTEGRITY: u32 = 131072u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_LICENSING: u32 = 262144u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_MESSAGES: u64 = 4294967296u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_MUTUAL_AUTH: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_NO_ADDITIONAL_TOKEN: u32 = 33554432u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_NO_TOKEN: u32 = 16777216u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_NULL_SESSION: u32 = 1048576u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_REPLAY_DETECT: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_SEQUENCE_DETECT: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_SESSION_TICKET: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_STREAM: u32 = 65536u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_THIRD_LEG_FAILED: u32 = 16384u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_USED_DCE_STYLE: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ASC_RET_USE_SESSION_KEY: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_IN_FLAG_BEST_EFFORT: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_IN_FLAG_EOF_SPECIFIED: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_IN_FLAG_FILE_ATTRIBUTES_SPECIFIED: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_IN_FLAG_GEN_FLAGS_SPECIFIED: u32 = 32768u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_IN_FLAG_MARK_USN_SOURCE_INFO: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_IN_FLAG_OPERATION_MASK: u32 = 255u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_IN_FLAG_OP_FLAGS_SPECIFIED: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_IN_FLAG_REPARSE_POINT_SPECIFIED: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_IN_FLAG_SPARSE_SPECIFIED: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_IN_FLAG_SUPPRESS_DIR_CHANGE_NOTIFY: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_IN_FLAG_SUPPRESS_FILE_ATTRIBUTE_INHERITANCE: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_IN_FLAG_SUPPRESS_PARENT_TIMESTAMPS_UPDATE: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_IN_FLAG_TIMESTAMPS_SPECIFIED: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_IN_FLAG_VDL_SPECIFIED: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_IN_FLAG_WRITE_USN_CLOSE_RECORD: u32 = 4096u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_IN_OP_FLAG_CASE_SENSITIVE_FLAGS_SPECIFIED: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_OUT_FLAG_EOF_SET: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_OUT_FLAG_FILE_ATTRIBUTES_RETURNED: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_OUT_FLAG_FILE_ATTRIBUTES_SET: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_OUT_FLAG_FILE_ATTRIBUTE_INHERITANCE_SUPPRESSED: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_OUT_FLAG_OPERATION_MASK: u32 = 255u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_OUT_FLAG_OP_FLAGS_HONORED: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_OUT_FLAG_REPARSE_POINT_SET: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_OUT_FLAG_SPARSE_SET: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_OUT_FLAG_TIMESTAMPS_RETURNED: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_OUT_FLAG_TIMESTAMPS_SET: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_OUT_FLAG_USN_CLOSE_RECORD_WRITTEN: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_OUT_FLAG_USN_RETURNED: u32 = 4096u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_OUT_FLAG_USN_SOURCE_INFO_MARKED: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_OUT_FLAG_VDL_SET: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ATOMIC_CREATE_ECP_OUT_OP_FLAG_CASE_SENSITIVE_FLAGS_SET: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AUDIT_ALLOW_NO_PRIVILEGE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CACHE_MANAGER_CALLBACKS_EX_V1: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CACHE_USE_DIRECT_ACCESS_MAPPING: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CACHE_VALID_FLAGS: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CC_ACQUIRE_DONT_WAIT: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CC_ACQUIRE_SUPPORTS_ASYNC_LAZYWRITE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CC_AGGRESSIVE_UNMAP_BEHIND: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CC_DISABLE_DIRTY_PAGE_TRACKING: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CC_DISABLE_READ_AHEAD: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CC_DISABLE_UNMAP_BEHIND: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CC_DISABLE_WRITE_BEHIND: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CC_ENABLE_CPU_CACHE: u32 = 268435456u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CC_ENABLE_DISK_IO_ACCOUNTING: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CC_FLUSH_AND_PURGE_GATHER_DIRTY_BITS: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CC_FLUSH_AND_PURGE_NO_PURGE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CC_FLUSH_AND_PURGE_WRITEABLE_VIEWS_NOTSEEN: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CHECKSUM_TYPE_CRC32: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CHECKSUM_TYPE_CRC64: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CHECKSUM_TYPE_ECC: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CHECKSUM_TYPE_FIRST_UNUSED_TYPE: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CHECKSUM_TYPE_NONE: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CHECKSUM_TYPE_UNCHANGED: i32 = -1i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CLAIM_SECURITY_ATTRIBUTES_INFORMATION_VERSION: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CLAIM_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CLAIM_SECURITY_ATTRIBUTE_CUSTOM_FLAGS: u32 = 4294901760u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CLAIM_SECURITY_ATTRIBUTE_DISABLED: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CLAIM_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CLAIM_SECURITY_ATTRIBUTE_MANDATORY: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CLAIM_SECURITY_ATTRIBUTE_NON_INHERITABLE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_BOOLEAN: u32 = 6u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_FQBN: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_INT64: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_INVALID: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_SID: u32 = 5u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_STRING: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CLAIM_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CLAIM_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const COMPRESSION_ENGINE_HIBER: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const COMPRESSION_ENGINE_MASK: u32 = 65280u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const COMPRESSION_ENGINE_MAX: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const COMPRESSION_ENGINE_MAXIMUM: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const COMPRESSION_ENGINE_STANDARD: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const COMPRESSION_FORMAT_DEFAULT: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const COMPRESSION_FORMAT_LZNT1: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const COMPRESSION_FORMAT_MASK: u32 = 255u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const COMPRESSION_FORMAT_MAX: u32 = 5u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const COMPRESSION_FORMAT_NONE: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const COMPRESSION_FORMAT_XP10: u32 = 5u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const COMPRESSION_FORMAT_XPRESS: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const COMPRESSION_FORMAT_XPRESS_HUFF: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CONTAINER_INHERIT_ACE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CONTAINER_ROOT_INFO_FLAG_BIND_DO_NOT_MAP_NAME: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CONTAINER_ROOT_INFO_FLAG_BIND_EXCEPTION_ROOT: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CONTAINER_ROOT_INFO_FLAG_BIND_ROOT: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CONTAINER_ROOT_INFO_FLAG_BIND_TARGET_ROOT: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CONTAINER_ROOT_INFO_FLAG_LAYER_ROOT: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CONTAINER_ROOT_INFO_FLAG_SCRATCH_ROOT: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CONTAINER_ROOT_INFO_FLAG_UNION_LAYER_ROOT: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_EXCEPTION_ROOT: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_ROOT: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_TARGET_ROOT: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CONTAINER_ROOT_INFO_VALID_FLAGS: u32 = 1023u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CONTAINER_VOLUME_STATE_HOSTING_CONTAINER: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const COPYFILE_SIS_FLAGS: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const COPYFILE_SIS_LINK: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const COPYFILE_SIS_REPLACE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CREATE_REDIRECTION_FLAGS_SERVICED_FROM_LAYER: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CREATE_REDIRECTION_FLAGS_SERVICED_FROM_REGISTERED_LAYER: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CREATE_REDIRECTION_FLAGS_SERVICED_FROM_REMOTE_LAYER: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CREATE_REDIRECTION_FLAGS_SERVICED_FROM_SCRATCH: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CREATE_REDIRECTION_FLAGS_SERVICED_FROM_USER_MODE: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CRITICAL_ACE_FLAG: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CSV_INVALID_DEVICE_NUMBER: u32 = 4294967295u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CSV_MGMTLOCK_CHECK_VOLUME_REDIRECTED: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CSV_QUERY_MDS_PATH_FLAG_CSV_DIRECT_IO_ENABLED: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CSV_QUERY_MDS_PATH_FLAG_SMB_BYPASS_CSV_ENABLED: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CSV_QUERY_MDS_PATH_FLAG_STORAGE_ON_THIS_NODE_IS_CONNECTED: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CSV_QUERY_MDS_PATH_V2_VERSION_1: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CSV_SET_HANDLE_PROPERTIES_ECP_CONTEXT_FLAGS_VALID_ONLY_IF_CSV_COORDINATOR: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DAX_ALLOC_ALIGNMENT_FLAG_FALLBACK_SPECIFIED: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DAX_ALLOC_ALIGNMENT_FLAG_MANDATORY: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DD_MUP_DEVICE_NAME: ::windows_core::PCWSTR = ::windows_core::w!("\\Device\\Mup");
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DEVICE_RESET_KEEP_STACK: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DEVICE_RESET_RESERVED_0: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DEVICE_RESET_RESERVED_1: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_ACCESS_CONTROL_ASSISTANCE_OPS: i32 = 579i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_ACCOUNT_OPS: i32 = 548i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_ADMINS: i32 = 544i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_AUTHORIZATIONACCESS: i32 = 560i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_BACKUP_OPS: i32 = 551i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_CACHEABLE_PRINCIPALS_GROUP: i32 = 571i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_CERTSVC_DCOM_ACCESS_GROUP: i32 = 574i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_CRYPTO_OPERATORS: i32 = 569i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_DCOM_USERS: i32 = 562i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_DEFAULT_ACCOUNT: i32 = 581i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_DEVICE_OWNERS: i32 = 583i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_EVENT_LOG_READERS_GROUP: i32 = 573i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_GUESTS: i32 = 546i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_HYPER_V_ADMINS: i32 = 578i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_INCOMING_FOREST_TRUST_BUILDERS: i32 = 557i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_IUSERS: i32 = 568i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_LOGGING_USERS: i32 = 559i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_MONITORING_USERS: i32 = 558i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS: i32 = 556i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_NON_CACHEABLE_PRINCIPALS_GROUP: i32 = 572i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_POWER_USERS: i32 = 547i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_PREW2KCOMPACCESS: i32 = 554i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_PRINT_OPS: i32 = 550i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_RAS_SERVERS: i32 = 553i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_RDS_ENDPOINT_SERVERS: i32 = 576i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_RDS_MANAGEMENT_SERVERS: i32 = 577i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_RDS_REMOTE_ACCESS_SERVERS: i32 = 575i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS: i32 = 555i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_REMOTE_MANAGEMENT_USERS: i32 = 580i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_REPLICATOR: i32 = 552i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_STORAGE_REPLICA_ADMINS: i32 = 582i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_SYSTEM_OPS: i32 = 549i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_TS_LICENSE_SERVERS: i32 = 561i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_ALIAS_RID_USERS: i32 = 545i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_GROUP_RID_ADMINS: i32 = 512i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_GROUP_RID_AUTHORIZATION_DATA_CONTAINS_CLAIMS: i32 = 497i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_GROUP_RID_AUTHORIZATION_DATA_IS_COMPOUNDED: i32 = 496i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_GROUP_RID_CDC_RESERVED: i32 = 524i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_GROUP_RID_CERT_ADMINS: i32 = 517i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_GROUP_RID_CLONEABLE_CONTROLLERS: i32 = 522i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_GROUP_RID_COMPUTERS: i32 = 515i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_GROUP_RID_CONTROLLERS: i32 = 516i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_GROUP_RID_ENTERPRISE_ADMINS: i32 = 519i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_GROUP_RID_ENTERPRISE_KEY_ADMINS: i32 = 527i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_GROUP_RID_ENTERPRISE_READONLY_DOMAIN_CONTROLLERS: i32 = 498i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_GROUP_RID_GUESTS: i32 = 514i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_GROUP_RID_KEY_ADMINS: i32 = 526i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_GROUP_RID_POLICY_ADMINS: i32 = 520i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_GROUP_RID_PROTECTED_USERS: i32 = 525i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_GROUP_RID_READONLY_CONTROLLERS: i32 = 521i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_GROUP_RID_SCHEMA_ADMINS: i32 = 518i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_GROUP_RID_USERS: i32 = 513i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_USER_RID_ADMIN: i32 = 500i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_USER_RID_DEFAULT_ACCOUNT: i32 = 503i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_USER_RID_GUEST: i32 = 501i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_USER_RID_KRBTGT: i32 = 502i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_USER_RID_MAX: i32 = 999i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DOMAIN_USER_RID_WDAG_ACCOUNT: i32 = 504i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_BOOT_CRITICAL: u32 = 536870912u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_BUFFERED_IO: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_BUS_ENUMERATED_DEVICE: u32 = 4096u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_DAX_VOLUME: u32 = 268435456u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_DEVICE_HAS_NAME: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_DEVICE_INITIALIZING: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_DEVICE_IRP_REQUIRES_EXTENSION: u32 = 134217728u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_DEVICE_TO_BE_RESET: u32 = 67108864u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_DIRECT_IO: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_DISALLOW_EXECUTE: u32 = 8388608u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_EXCLUSIVE: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_FORCE_NEITHER_IO: u32 = 524288u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_LONG_TERM_REQUESTS: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_LOW_PRIORITY_FILESYSTEM: u32 = 65536u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_MAP_IO_BUFFER: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_NEVER_LAST_DEVICE: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_NOT_PURGE_DIRTY_PAGES: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_NOT_RETRY_PURGE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_POWER_INRUSH: u32 = 16384u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_POWER_PAGABLE: u32 = 8192u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_SHUTDOWN_REGISTERED: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_SUPPORTS_PERSISTENT_ACLS: u32 = 131072u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_SUPPORTS_TRANSACTIONS: u32 = 262144u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_SYSTEM_BOOT_PARTITION: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_SYSTEM_CRITICAL_PARTITION: u32 = 4194304u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_SYSTEM_SYSTEM_PARTITION: u32 = 2097152u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_VERIFY_VOLUME: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DO_VOLUME_DEVICE_OBJECT: u32 = 1048576u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DUPLICATE_EXTENTS_DATA_EX_ASYNC: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DUPLICATE_EXTENTS_DATA_EX_SOURCE_ATOMIC: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const EA_NAME_NETWORK_OPEN_ECP_INTEGRITY: ::windows_core::PCSTR = ::windows_core::s!("ECP{c584edbf-00df-4d28-00b8-8435baca8911e8}-INTEGRITY");
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const EA_NAME_NETWORK_OPEN_ECP_INTEGRITY_U: ::windows_core::PCWSTR = ::windows_core::w!("ECP{c584edbf-00df-4d28-00b8-8435baca8911e8}-INTEGRITY");
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const EA_NAME_NETWORK_OPEN_ECP_PRIVACY: ::windows_core::PCSTR = ::windows_core::s!("ECP{c584edbf-00df-4d28-00b8-8435baca8911e8}-PRIVACY");
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const EA_NAME_NETWORK_OPEN_ECP_PRIVACY_U: ::windows_core::PCWSTR = ::windows_core::w!("ECP{c584edbf-00df-4d28-00b8-8435baca8911e8}-PRIVACY");
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ECP_OPEN_PARAMETERS_FLAG_FAIL_ON_CASE_SENSITIVE_DIR: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ECP_OPEN_PARAMETERS_FLAG_IGNORE_DIR_CASE_SENSITIVITY: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ECP_OPEN_PARAMETERS_FLAG_OPEN_FOR_DELETE: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ECP_OPEN_PARAMETERS_FLAG_OPEN_FOR_READ: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ECP_OPEN_PARAMETERS_FLAG_OPEN_FOR_WRITE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ECP_TYPE_CLFS_CREATE_CONTAINER: ::windows_core::GUID = ::windows_core::GUID::from_u128(0x8650c9fe_0cec_8bf6_bd1e_835956541090);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ECP_TYPE_IO_STOP_ON_SYMLINK_FILTER_GUID: ::windows_core::GUID = ::windows_core::GUID::from_u128(0x940e5d56_1646_4d3c_87b6_577ec36a1466);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ECP_TYPE_OPEN_REPARSE_GUID: ::windows_core::GUID = ::windows_core::GUID::from_u128(0x323eb6a8_affd_4d95_8230_863bce09d37a);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const EFS_TRACKED_OFFSET_HEADER_FLAG: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ENCRYPTED_DATA_INFO_SPARSE_FILE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ENCRYPTION_FORMAT_DEFAULT: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const EVENT_INCREMENT: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FAILED_ACCESS_ACE_FLAG: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILESYSTEM_STATISTICS_TYPE_EXFAT: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILESYSTEM_STATISTICS_TYPE_FAT: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILESYSTEM_STATISTICS_TYPE_NTFS: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILESYSTEM_STATISTICS_TYPE_REFS: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_ACTION_ADDED: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_ACTION_ADDED_STREAM: u32 = 6u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_ACTION_ID_NOT_TUNNELLED: u32 = 10u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_ACTION_MODIFIED: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_ACTION_MODIFIED_STREAM: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_ACTION_REMOVED: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_ACTION_REMOVED_BY_DELETE: u32 = 9u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_ACTION_REMOVED_STREAM: u32 = 7u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_ACTION_RENAMED_NEW_NAME: u32 = 5u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_ACTION_RENAMED_OLD_NAME: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_ACTION_TUNNELLED_ID_COLLISION: u32 = 11u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_ANY_ACCESS: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_CASE_PRESERVED_NAMES: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_CASE_SENSITIVE_SEARCH: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_CLEANUP_FILE_DELETED: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_CLEANUP_FILE_REMAINS: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_CLEANUP_LINK_DELETED: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_CLEANUP_POSIX_STYLE_DELETE: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_CLEANUP_STREAM_DELETED: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_CLEANUP_UNKNOWN: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_CLEANUP_WRONG_DEVICE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_CLEAR_ENCRYPTION: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_CS_FLAG_CASE_SENSITIVE_DIR: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DAX_VOLUME: u32 = 536870912u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_8042_PORT: u32 = 39u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_ACPI: u32 = 50u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_BATTERY: u32 = 41u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_BEEP: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_BIOMETRIC: u32 = 68u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_BLUETOOTH: u32 = 65u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_BUS_EXTENDER: u32 = 42u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_CD_ROM: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_CD_ROM_FILE_SYSTEM: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_CHANGER: u32 = 48u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_CONSOLE: u32 = 80u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_CONTROLLER: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_CRYPT_PROVIDER: u32 = 63u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_DATALINK: u32 = 5u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_DEVAPI: u32 = 71u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_DFS: u32 = 6u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_DFS_FILE_SYSTEM: u32 = 53u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_DFS_VOLUME: u32 = 54u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_DISK: u32 = 7u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_DISK_FILE_SYSTEM: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_DVD: u32 = 51u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_EHSTOR: u32 = 70u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_EVENT_COLLECTOR: u32 = 95u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_FILE_SYSTEM: u32 = 9u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_FIPS: u32 = 58u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_FULLSCREEN_VIDEO: u32 = 52u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_GPIO: u32 = 72u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_HOLOGRAPHIC: u32 = 91u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_INFINIBAND: u32 = 59u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_INPORT_PORT: u32 = 10u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_KEYBOARD: u32 = 11u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_KS: u32 = 47u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_KSEC: u32 = 57u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_MAILSLOT: u32 = 12u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_MASS_STORAGE: u32 = 45u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_MIDI_IN: u32 = 13u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_MIDI_OUT: u32 = 14u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_MODEM: u32 = 43u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_MOUSE: u32 = 15u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_MT_COMPOSITE: u32 = 66u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_MT_TRANSPORT: u32 = 67u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_MULTI_UNC_PROVIDER: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_NAMED_PIPE: u32 = 17u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_NETWORK: u32 = 18u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_NETWORK_BROWSER: u32 = 19u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_NETWORK_FILE_SYSTEM: u32 = 20u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_NETWORK_REDIRECTOR: u32 = 40u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_NFP: u32 = 81u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_NULL: u32 = 21u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_NVDIMM: u32 = 90u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_PARALLEL_PORT: u32 = 22u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_PERSISTENT_MEMORY: u32 = 89u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_PHYSICAL_NETCARD: u32 = 23u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_PMI: u32 = 69u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_POINT_OF_SERVICE: u32 = 84u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_PRINTER: u32 = 24u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_PRM: u32 = 94u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_SCANNER: u32 = 25u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_SCREEN: u32 = 28u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_SDFXHCI: u32 = 92u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_SERENUM: u32 = 55u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_SERIAL_MOUSE_PORT: u32 = 26u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_SERIAL_PORT: u32 = 27u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_SMARTCARD: u32 = 49u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_SMB: u32 = 46u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_SOUND: u32 = 29u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_SOUNDWIRE: u32 = 97u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_STORAGE_REPLICATION: u32 = 85u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_STREAMS: u32 = 30u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_SYSENV: u32 = 82u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_TAPE: u32 = 31u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_TAPE_FILE_SYSTEM: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_TERMSRV: u32 = 56u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_TRANSPORT: u32 = 33u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_TRUST_ENV: u32 = 86u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_UCM: u32 = 87u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_UCMTCPCI: u32 = 88u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_UCMUCSI: u32 = 93u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_UNKNOWN: u32 = 34u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_USB4: u32 = 96u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_USBEX: u32 = 73u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_VDM: u32 = 44u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_VIDEO: u32 = 35u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_VIRTUAL_BLOCK: u32 = 83u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_VIRTUAL_DISK: u32 = 36u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_VMBUS: u32 = 62u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_WAVE_IN: u32 = 37u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_WAVE_OUT: u32 = 38u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DEVICE_WPD: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_EA_TYPE_ASCII: u32 = 65533u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_EA_TYPE_ASN1: u32 = 65501u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_EA_TYPE_BINARY: u32 = 65534u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_EA_TYPE_BITMAP: u32 = 65531u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_EA_TYPE_EA: u32 = 65518u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_EA_TYPE_FAMILY_IDS: u32 = 65281u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_EA_TYPE_ICON: u32 = 65529u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_EA_TYPE_METAFILE: u32 = 65530u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_EA_TYPE_MVMT: u32 = 65503u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_EA_TYPE_MVST: u32 = 65502u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_FILE_COMPRESSION: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_VISIBLE_OUTSIDE_TX: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_VISIBLE_TO_TX: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_WRITELOCKED: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_NON_RESIDENT: u64 = 137438953472u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_NOT_FOUND: u64 = 4096u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_TOO_SMALL: u64 = 68719476736u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_CLUSTERS_ALREADY_IN_USE: u64 = 32768u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_DENY_DEFRAG: u64 = 274877906944u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_IS_BASE_RECORD: u64 = 524288u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_BASE_RECORD: u64 = 8u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_EXIST: u64 = 4u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_IN_USE: u64 = 1u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_ORPHAN: u64 = 262144u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_REUSED: u64 = 2u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_INDEX_ENTRY_MISMATCH: u64 = 1099511627776u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_ARRAY_LENGTH_COUNT: u64 = 1048576u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_LCN: u64 = 4294967296u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_ORPHAN_RECOVERY_NAME: u64 = 2199023255552u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_PARENT: u64 = 8388608u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_RUN_LENGTH: u64 = 131072u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_VCN: u64 = 8589934592u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_LCN_NOT_EXIST: u64 = 65536u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_MULTIPLE_FILE_NAME_ATTRIBUTES: u64 = 4398046511104u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_NAME_CONFLICT: u64 = 17179869184u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_NOTHING_WRONG: u64 = 2048u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_NOT_IMPLEMENTED: u64 = 32u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_ORPHAN: u64 = 34359738368u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_ORPHAN_GENERATED: u64 = 512u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_OUT_OF_GENERIC_NAMES: u64 = 1073741824u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_OUT_OF_RESOURCE: u64 = 2147483648u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_BASE_RECORD: u64 = 134217728u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_EXIST: u64 = 67108864u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_INDEX: u64 = 268435456u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_IN_USE: u64 = 16777216u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_REUSED: u64 = 33554432u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_POTENTIAL_CROSSLINK: u64 = 8192u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_PREVIOUS_PARENT_STILL_VALID: u64 = 549755813888u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_RECURSIVELY_CORRUPTED: u64 = 256u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_REPAIRED: u64 = 1024u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_REPAIR_DISABLED: u64 = 128u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_SID_MISMATCH: u64 = 4194304u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_SID_VALID: u64 = 2097152u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_STALE_INFORMATION: u64 = 16384u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_SYSTEM_FILE: u64 = 16u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_UNABLE_TO_REPAIR: u64 = 64u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_INITIATE_REPAIR_HINT1_VALID_INDEX_ENTRY: u64 = 536870912u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_LAYOUT_NAME_ENTRY_DOS: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_LAYOUT_NAME_ENTRY_PRIMARY: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_LINK_FORCE_RESIZE_SOURCE_SR: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_LINK_FORCE_RESIZE_SR: u32 = 384u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_LINK_FORCE_RESIZE_TARGET_SR: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_LINK_IGNORE_READONLY_ATTRIBUTE: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_LINK_NO_DECREASE_AVAILABLE_SPACE: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_LINK_NO_INCREASE_AVAILABLE_SPACE: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_LINK_POSIX_SEMANTICS: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_LINK_PRESERVE_AVAILABLE_SPACE: u32 = 48u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_LINK_REPLACE_IF_EXISTS: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_LINK_SUPPRESS_STORAGE_RESERVE_INHERITANCE: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NAMED_STREAMS: u32 = 262144u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NAME_FLAGS_UNSPECIFIED: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NAME_FLAG_BOTH: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NAME_FLAG_DOS: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NAME_FLAG_HARDLINK: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NAME_FLAG_NTFS: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NEED_EA: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NOTIFY_CHANGE_ATTRIBUTES: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NOTIFY_CHANGE_CREATION: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NOTIFY_CHANGE_DIR_NAME: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NOTIFY_CHANGE_EA: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NOTIFY_CHANGE_FILE_NAME: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NOTIFY_CHANGE_LAST_ACCESS: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NOTIFY_CHANGE_LAST_WRITE: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NOTIFY_CHANGE_NAME: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NOTIFY_CHANGE_SECURITY: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NOTIFY_CHANGE_SIZE: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NOTIFY_CHANGE_STREAM_NAME: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NOTIFY_CHANGE_STREAM_SIZE: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NOTIFY_CHANGE_STREAM_WRITE: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NOTIFY_VALID_MASK: u32 = 4095u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_OPBATCH_BREAK_UNDERWAY: u32 = 9u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_OPLOCK_BROKEN_TO_LEVEL_2: u32 = 7u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_OPLOCK_BROKEN_TO_NONE: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PERSISTENT_ACLS: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PIPE_ACCEPT_REMOTE_CLIENTS: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PIPE_BYTE_STREAM_MODE: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PIPE_BYTE_STREAM_TYPE: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PIPE_CLIENT_END: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PIPE_CLOSING_STATE: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PIPE_COMPLETE_OPERATION: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PIPE_COMPUTER_NAME_LENGTH: u32 = 15u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PIPE_CONNECTED_STATE: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PIPE_DISCONNECTED_STATE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PIPE_FULL_DUPLEX: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PIPE_INBOUND: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PIPE_LISTENING_STATE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PIPE_MESSAGE_MODE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PIPE_MESSAGE_TYPE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PIPE_OUTBOUND: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PIPE_QUEUE_OPERATION: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PIPE_READ_DATA: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PIPE_REJECT_REMOTE_CLIENTS: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PIPE_SERVER_END: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PIPE_SYMLINK_FLAG_GLOBAL: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PIPE_SYMLINK_FLAG_RELATIVE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PIPE_TYPE_VALID_MASK: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PIPE_WRITE_SPACE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PREFETCH_TYPE_FOR_CREATE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PREFETCH_TYPE_FOR_CREATE_EX: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PREFETCH_TYPE_FOR_DIRENUM: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PREFETCH_TYPE_FOR_DIRENUM_EX: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PREFETCH_TYPE_MAX: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PROVIDER_COMPRESSION_LZX: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PROVIDER_COMPRESSION_MAXIMUM: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PROVIDER_COMPRESSION_XPRESS16K: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PROVIDER_COMPRESSION_XPRESS4K: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PROVIDER_COMPRESSION_XPRESS8K: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PROVIDER_CURRENT_VERSION: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PROVIDER_FLAG_COMPRESS_ON_WRITE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_PROVIDER_SINGLE_FILE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_READ_ACCESS: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_READ_ONLY_VOLUME: u32 = 524288u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_REGION_USAGE_HUGE_PAGE_ALIGNMENT: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_REGION_USAGE_LARGE_PAGE_ALIGNMENT: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_REGION_USAGE_OTHER_PAGE_ALIGNMENT: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_REGION_USAGE_QUERY_ALIGNMENT: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_REGION_USAGE_VALID_CACHED_DATA: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_REGION_USAGE_VALID_NONCACHED_DATA: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_RENAME_FORCE_RESIZE_SOURCE_SR: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_RENAME_FORCE_RESIZE_SR: u32 = 384u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_RENAME_FORCE_RESIZE_TARGET_SR: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_RENAME_IGNORE_READONLY_ATTRIBUTE: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_RENAME_NO_DECREASE_AVAILABLE_SPACE: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_RENAME_NO_INCREASE_AVAILABLE_SPACE: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_RENAME_POSIX_SEMANTICS: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_RENAME_PRESERVE_AVAILABLE_SPACE: u32 = 48u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_RENAME_REPLACE_IF_EXISTS: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_RENAME_SUPPRESS_PIN_STATE_INHERITANCE: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_RENAME_SUPPRESS_STORAGE_RESERVE_INHERITANCE: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_RETURNS_CLEANUP_RESULT_INFO: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SEQUENTIAL_WRITE_ONCE: u32 = 1048576u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SET_ENCRYPTION: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SPECIAL_ACCESS: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_STORAGE_TIER_DESCRIPTION_LENGTH: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_STORAGE_TIER_FLAG_NO_SEEK_PENALTY: u32 = 131072u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_STORAGE_TIER_FLAG_PARITY: u32 = 8388608u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_STORAGE_TIER_FLAG_READ_CACHE: u32 = 4194304u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_STORAGE_TIER_FLAG_SMR: u32 = 16777216u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_STORAGE_TIER_FLAG_WRITE_BACK_CACHE: u32 = 2097152u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_STORAGE_TIER_NAME_LENGTH: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SUPPORTS_BLOCK_REFCOUNTING: u32 = 134217728u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SUPPORTS_BYPASS_IO: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SUPPORTS_CASE_SENSITIVE_DIRS: u32 = 8192u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SUPPORTS_ENCRYPTION: u32 = 131072u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SUPPORTS_EXTENDED_ATTRIBUTES: u32 = 8388608u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SUPPORTS_GHOSTING: u32 = 1073741824u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SUPPORTS_HARD_LINKS: u32 = 4194304u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SUPPORTS_INTEGRITY_STREAMS: u32 = 67108864u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SUPPORTS_OBJECT_IDS: u32 = 65536u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SUPPORTS_OPEN_BY_FILE_ID: u32 = 16777216u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SUPPORTS_POSIX_UNLINK_RENAME: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SUPPORTS_REMOTE_STORAGE: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SUPPORTS_REPARSE_POINTS: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SUPPORTS_SPARSE_FILES: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SUPPORTS_SPARSE_VDL: u32 = 268435456u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SUPPORTS_STREAM_SNAPSHOTS: u32 = 4096u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SUPPORTS_TRANSACTIONS: u32 = 2097152u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SUPPORTS_USN_JOURNAL: u32 = 33554432u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_TYPE_NOTIFICATION_FLAG_USAGE_BEGIN: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_TYPE_NOTIFICATION_FLAG_USAGE_END: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_TYPE_NOTIFICATION_GUID_CRASHDUMP_FILE: ::windows_core::GUID = ::windows_core::GUID::from_u128(0x9d453eb7_d2a6_4dbd_a2e3_fbd0ed9109a9);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_TYPE_NOTIFICATION_GUID_HIBERNATION_FILE: ::windows_core::GUID = ::windows_core::GUID::from_u128(0xb7624d64_b9a3_4cf8_8011_5b86c940e7b7);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_TYPE_NOTIFICATION_GUID_PAGE_FILE: ::windows_core::GUID = ::windows_core::GUID::from_u128(0x0d0a64a1_38fc_4db8_9fe7_3f4352cd7c5c);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_UNICODE_ON_DISK: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_VC_CONTENT_INDEX_DISABLED: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_VC_LOG_QUOTA_LIMIT: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_VC_LOG_QUOTA_THRESHOLD: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_VC_LOG_VOLUME_LIMIT: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_VC_LOG_VOLUME_THRESHOLD: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_VC_QUOTAS_INCOMPLETE: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_VC_QUOTAS_REBUILDING: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_VC_QUOTA_ENFORCE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_VC_QUOTA_MASK: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_VC_QUOTA_NONE: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_VC_QUOTA_TRACK: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_VC_VALID_MASK: u32 = 1023u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_VOLUME_IS_COMPRESSED: u32 = 32768u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_VOLUME_QUOTAS: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_WRITE_ACCESS: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_ZERO_DATA_INFORMATION_FLAG_PRESERVE_CACHED_DATA: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FLAGS_DELAY_REASONS_BITMAP_SCANNED: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FLAGS_DELAY_REASONS_LOG_FILE_FULL: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FLAGS_END_OF_FILE_INFO_EX_EXTEND_PAGING: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FLAGS_END_OF_FILE_INFO_EX_NO_EXTRA_PAGING_EXTEND: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FLAGS_END_OF_FILE_INFO_EX_TIME_CONSTRAINED: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FLAG_USN_TRACK_MODIFIED_RANGES_ENABLE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FLUSH_FLAGS_FILE_DATA_ONLY: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FLUSH_FLAGS_FILE_DATA_SYNC_ONLY: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FLUSH_FLAGS_NO_SYNC: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FOREST_USER_RID_MAX: i32 = 499i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_ADD_OVERLAY: u32 = 623408u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_ADVANCE_FILE_ID: u32 = 590532u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_ALLOW_EXTENDED_DASD_IO: u32 = 589955u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_CLEAN_VOLUME_METADATA: u32 = 590716u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_CORRUPTION_HANDLING: u32 = 590432u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_CREATE_LCN_WEAK_REFERENCE: u32 = 590944u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_CREATE_OR_GET_OBJECT_ID: u32 = 590016u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_CREATE_USN_JOURNAL: u32 = 590055u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_CSC_INTERNAL: u32 = 590255u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_CSV_CONTROL: u32 = 590548u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_CSV_GET_VOLUME_NAME_FOR_VOLUME_MOUNT_POINT: u32 = 590420u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_CSV_GET_VOLUME_PATH_NAME: u32 = 590416u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_CSV_GET_VOLUME_PATH_NAMES_FOR_VOLUME_NAME: u32 = 590424u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_CSV_H_BREAKING_SYNC_TUNNEL_REQUEST: u32 = 590564u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_CSV_INTERNAL: u32 = 590444u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_CSV_MGMT_LOCK: u32 = 590524u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_CSV_QUERY_DOWN_LEVEL_FILE_SYSTEM_CHARACTERISTICS: u32 = 590528u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_CSV_QUERY_VETO_FILE_DIRECT_IO: u32 = 590540u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_CSV_SYNC_TUNNEL_REQUEST: u32 = 590536u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_CSV_TUNNEL_REQUEST: u32 = 590404u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_DELETE_CORRUPTED_REFS_CONTAINER: u32 = 590836u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_DELETE_EXTERNAL_BACKING: u32 = 590612u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_DELETE_LCN_WEAK_REFERENCE: u32 = 590948u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_DELETE_LCN_WEAK_REFERENCES: u32 = 590956u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_DELETE_OBJECT_ID: u32 = 589984u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_DELETE_REPARSE_POINT: u32 = 589996u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_DELETE_USN_JOURNAL: u32 = 590072u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_DFSR_SET_GHOST_HANDLE_STATE: u32 = 590264u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_DISABLE_LOCAL_BUFFERING: u32 = 590520u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_DISMOUNT_VOLUME: u32 = 589856u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_DUPLICATE_CLUSTER: u32 = 590940u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_DUPLICATE_EXTENTS_TO_FILE: u32 = 623428u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_DUPLICATE_EXTENTS_TO_FILE_EX: u32 = 623592u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_ENABLE_PER_IO_FLAGS: u32 = 590892u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_ENABLE_UPGRADE: u32 = 622800u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_ENCRYPTION_FSCTL_IO: u32 = 590043u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_ENCRYPTION_KEY_CONTROL: u32 = 590852u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_ENUM_EXTERNAL_BACKING: u32 = 590616u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_ENUM_OVERLAY: u32 = 590623u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_ENUM_USN_DATA: u32 = 590003u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_EXTEND_VOLUME: u32 = 590064u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_FILESYSTEM_GET_STATISTICS: u32 = 589920u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_FILESYSTEM_GET_STATISTICS_EX: u32 = 590732u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_FILE_LEVEL_TRIM: u32 = 623112u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_FILE_PREFETCH: u32 = 590112u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_FILE_TYPE_NOTIFICATION: u32 = 590340u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_FIND_FILES_BY_SID: u32 = 589967u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_GET_BOOT_AREA_INFO: u32 = 590384u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_GET_COMPRESSION: u32 = 589884u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_GET_EXTERNAL_BACKING: u32 = 590608u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_GET_FILTER_FILE_IDENTIFIER: u32 = 590788u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_GET_INTEGRITY_INFORMATION: u32 = 590460u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_GET_NTFS_FILE_RECORD: u32 = 589928u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_GET_NTFS_VOLUME_DATA: u32 = 589924u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_GET_OBJECT_ID: u32 = 589980u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_GET_REFS_VOLUME_DATA: u32 = 590552u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_GET_REPAIR: u32 = 590236u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_GET_REPARSE_POINT: u32 = 589992u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_GET_RETRIEVAL_POINTERS: u32 = 589939u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_GET_RETRIEVAL_POINTERS_AND_REFCOUNT: u32 = 590803u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_GET_RETRIEVAL_POINTER_BASE: u32 = 590388u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_GET_RETRIEVAL_POINTER_COUNT: u32 = 590891u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_GET_VOLUME_BITMAP: u32 = 589935u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_GET_WOF_VERSION: u32 = 590696u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_GHOST_FILE_EXTENTS: u32 = 623532u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_HCS_ASYNC_TUNNEL_REQUEST: u32 = 590704u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_HCS_SYNC_NO_WRITE_TUNNEL_REQUEST: u32 = 590776u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_HCS_SYNC_TUNNEL_REQUEST: u32 = 590700u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_INITIATE_FILE_METADATA_OPTIMIZATION: u32 = 590684u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_INITIATE_REPAIR: u32 = 590248u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_INTEGRITY_FLAG_CHECKSUM_ENFORCEMENT_OFF: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_INVALIDATE_VOLUMES: u32 = 589908u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_IS_CSV_FILE: u32 = 590408u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_IS_FILE_ON_CSV_VOLUME: u32 = 590428u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_IS_PATHNAME_VALID: u32 = 589868u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_IS_VOLUME_DIRTY: u32 = 589944u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_IS_VOLUME_MOUNTED: u32 = 589864u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_IS_VOLUME_OWNED_BYCSVFS: u32 = 590456u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_LMR_GET_LINK_TRACKING_INFORMATION: u32 = 1310952u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_LMR_QUERY_INFO: u32 = 590968u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_LMR_SET_LINK_TRACKING_INFORMATION: u32 = 1310956u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_LOCK_VOLUME: u32 = 589848u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_LOOKUP_STREAM_FROM_CLUSTER: u32 = 590332u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_MAILSLOT_PEEK: u32 = 802819u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_MAKE_MEDIA_COMPATIBLE: u32 = 622896u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_MANAGE_BYPASS_IO: u32 = 590920u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_MARK_AS_SYSTEM_HIVE: u32 = 589903u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_MARK_HANDLE: u32 = 590076u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_MARK_VOLUME_DIRTY: u32 = 589872u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_MOVE_FILE: u32 = 589940u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_NOTIFY_DATA_CHANGE: u32 = 590844u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_NOTIFY_STORAGE_SPACE_ALLOCATION: u32 = 590748u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_OFFLOAD_READ: u32 = 606820u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_OFFLOAD_WRITE: u32 = 623208u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_OPBATCH_ACK_CLOSE_PENDING: u32 = 589840u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_OPLOCK_BREAK_ACKNOWLEDGE: u32 = 589836u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_OPLOCK_BREAK_ACK_NO_2: u32 = 589904u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_OPLOCK_BREAK_NOTIFY: u32 = 589844u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_ASSIGN_EVENT: u32 = 1114112u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_CREATE_SYMLINK: u32 = 1114188u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_DELETE_SYMLINK: u32 = 1114192u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_DISABLE_IMPERSONATE: u32 = 1114180u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_DISCONNECT: u32 = 1114116u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_FLUSH: u32 = 1146944u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_GET_CONNECTION_ATTRIBUTE: u32 = 1114160u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_GET_HANDLE_ATTRIBUTE: u32 = 1114168u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_GET_PIPE_ATTRIBUTE: u32 = 1114152u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_IMPERSONATE: u32 = 1114140u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_INTERNAL_READ: u32 = 1138676u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_INTERNAL_READ_OVFLOW: u32 = 1138688u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_INTERNAL_TRANSCEIVE: u32 = 1171455u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_INTERNAL_WRITE: u32 = 1155064u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_LISTEN: u32 = 1114120u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_PEEK: u32 = 1130508u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_QUERY_CLIENT_PROCESS: u32 = 1114148u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_QUERY_CLIENT_PROCESS_V2: u32 = 1114196u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_QUERY_EVENT: u32 = 1114128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_SET_CLIENT_PROCESS: u32 = 1114144u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_SET_CONNECTION_ATTRIBUTE: u32 = 1114164u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_SET_HANDLE_ATTRIBUTE: u32 = 1114172u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_SET_PIPE_ATTRIBUTE: u32 = 1114156u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_SILO_ARRIVAL: u32 = 1146952u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_TRANSCEIVE: u32 = 1163287u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_PIPE_WAIT: u32 = 1114136u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_ALLOCATED_RANGES: u32 = 606415u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_ASYNC_DUPLICATE_EXTENTS_STATUS: u32 = 590896u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_BAD_RANGES: u32 = 590828u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_DEPENDENT_VOLUME: u32 = 590320u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_DIRECT_ACCESS_EXTENTS: u32 = 590747u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_DIRECT_IMAGE_ORIGINAL_BASE: u32 = 590756u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_EXTENT_READ_CACHE_INFO: u32 = 590711u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_FAT_BPB: u32 = 589912u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_FILE_LAYOUT: u32 = 590455u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_FILE_METADATA_OPTIMIZATION: u32 = 590688u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_FILE_REGIONS: u32 = 590468u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_FILE_SYSTEM_RECOGNITION: u32 = 590412u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_GHOSTED_FILE_EXTENTS: u32 = 590768u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_LCN_WEAK_REFERENCE: u32 = 590952u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_ON_DISK_VOLUME_INFO: u32 = 590140u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_PAGEFILE_ENCRYPTION: u32 = 590312u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_PERSISTENT_VOLUME_STATE: u32 = 590396u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_REFS_SMR_VOLUME_INFO: u32 = 590812u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_REFS_VOLUME_COUNTER_INFO: u32 = 590715u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_REGION_INFO: u32 = 590576u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_RETRIEVAL_POINTERS: u32 = 589883u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_SHARED_VIRTUAL_DISK_SUPPORT: u32 = 590592u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_SPARING_INFO: u32 = 590136u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_STORAGE_CLASSES: u32 = 590572u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_USN_JOURNAL: u32 = 590068u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_VOLUME_CONTAINER_STATE: u32 = 590736u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_QUERY_VOLUME_NUMA_INFO: u32 = 590804u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_READ_FILE_USN_DATA: u32 = 590059u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_READ_FROM_PLEX: u32 = 606494u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_READ_RAW_ENCRYPTED: u32 = 590051u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_READ_UNPRIVILEGED_USN_JOURNAL: u32 = 590763u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_READ_USN_JOURNAL: u32 = 590011u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_REARRANGE_FILE: u32 = 640032u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_RECALL_FILE: u32 = 590103u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_REFS_DEALLOCATE_RANGES: u32 = 590808u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_REFS_DEALLOCATE_RANGES_EX: u32 = 590924u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_REFS_QUERY_VOLUME_COMPRESSION_INFO: u32 = 590936u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_REFS_QUERY_VOLUME_DEDUP_INFO: u32 = 590964u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_REFS_SET_VOLUME_COMPRESSION_INFO: u32 = 590932u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_REFS_SET_VOLUME_DEDUP_INFO: u32 = 590960u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_REFS_STREAM_SNAPSHOT_MANAGEMENT: u32 = 590912u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_REMOVE_OVERLAY: u32 = 623412u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_REPAIR_COPIES: u32 = 639668u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_REQUEST_BATCH_OPLOCK: u32 = 589832u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_REQUEST_FILTER_OPLOCK: u32 = 589916u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_REQUEST_OPLOCK: u32 = 590400u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_REQUEST_OPLOCK_LEVEL_1: u32 = 589824u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_REQUEST_OPLOCK_LEVEL_2: u32 = 589828u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_RESET_VOLUME_ALLOCATION_HINTS: u32 = 590316u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_RKF_INTERNAL: u32 = 590511u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SCRUB_DATA: u32 = 590512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SCRUB_UNDISCOVERABLE_ID: u32 = 590840u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SD_GLOBAL_CHANGE: u32 = 590324u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SECURITY_ID_CHECK: u32 = 606391u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_BOOTLOADER_ACCESSED: u32 = 589903u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_CACHED_RUNS_STATE: u32 = 590928u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_COMPRESSION: u32 = 639040u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_DAX_ALLOC_ALIGNMENT_HINT: u32 = 590832u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_DEFECT_MANAGEMENT: u32 = 622900u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_ENCRYPTION: u32 = 590039u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_EXTERNAL_BACKING: u32 = 590604u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_INTEGRITY_INFORMATION: u32 = 639616u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_INTEGRITY_INFORMATION_EX: u32 = 590720u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_LAYER_ROOT: u32 = 590740u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_OBJECT_ID: u32 = 589976u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_OBJECT_ID_EXTENDED: u32 = 590012u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_PERSISTENT_VOLUME_STATE: u32 = 590392u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_PURGE_FAILURE_MODE: u32 = 590448u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_REFS_FILE_STRICTLY_SEQUENTIAL: u32 = 590820u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_REFS_SMR_VOLUME_GC_PARAMETERS: u32 = 590816u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_REPAIR: u32 = 590232u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_REPARSE_POINT: u32 = 589988u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_REPARSE_POINT_EX: u32 = 590860u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_SHORT_NAME_BEHAVIOR: u32 = 590260u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_SPARSE: u32 = 590020u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_VOLUME_COMPRESSION_STATE: u32 = 590144u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_ZERO_DATA: u32 = 622792u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SET_ZERO_ON_DEALLOCATION: u32 = 590228u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SHRINK_VOLUME: u32 = 590256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SHUFFLE_FILE: u32 = 639808u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SIS_COPYFILE: u32 = 590080u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SIS_LINK_FILES: u32 = 639236u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SMB_SHARE_FLUSH_AND_PURGE: u32 = 590908u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SPARSE_OVERALLOCATE: u32 = 590668u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SSDI_STORAGE_REQUEST: u32 = 590752u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_START_VIRTUALIZATION_INSTANCE: u32 = 590784u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_START_VIRTUALIZATION_INSTANCE_EX: u32 = 590848u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_STORAGE_QOS_CONTROL: u32 = 590672u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_STREAMS_ASSOCIATE_ID: u32 = 590792u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_STREAMS_QUERY_ID: u32 = 590796u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_STREAMS_QUERY_PARAMETERS: u32 = 590788u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SUSPEND_OVERLAY: u32 = 590724u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SVHDX_ASYNC_TUNNEL_REQUEST: u32 = 590692u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SVHDX_SET_INITIATOR_INFORMATION: u32 = 590600u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_SVHDX_SYNC_TUNNEL_REQUEST: u32 = 590596u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_TXFS_CREATE_MINIVERSION: u32 = 622972u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_TXFS_CREATE_SECONDARY_RM: u32 = 622952u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_TXFS_GET_METADATA_INFO: u32 = 606572u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_TXFS_GET_TRANSACTED_VERSION: u32 = 606576u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_TXFS_LIST_TRANSACTIONS: u32 = 606692u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_TXFS_LIST_TRANSACTION_LOCKED_FILES: u32 = 606688u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_TXFS_MODIFY_RM: u32 = 622916u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_TXFS_QUERY_RM_INFORMATION: u32 = 606536u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_TXFS_READ_BACKUP_INFORMATION: u32 = 606560u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_TXFS_READ_BACKUP_INFORMATION2: u32 = 590328u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_TXFS_ROLLFORWARD_REDO: u32 = 622928u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_TXFS_ROLLFORWARD_UNDO: u32 = 622932u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_TXFS_SAVEPOINT_INFORMATION: u32 = 622968u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_TXFS_SHUTDOWN_RM: u32 = 622940u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_TXFS_START_RM: u32 = 622936u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_TXFS_TRANSACTION_ACTIVE: u32 = 606604u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_TXFS_WRITE_BACKUP_INFORMATION: u32 = 622948u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_TXFS_WRITE_BACKUP_INFORMATION2: u32 = 590336u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_UNLOCK_VOLUME: u32 = 589852u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_UNMAP_SPACE: u32 = 590772u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_UPDATE_OVERLAY: u32 = 623416u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_USN_TRACK_MODIFIED_RANGES: u32 = 590580u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_VIRTUAL_STORAGE_PASSTHROUGH: u32 = 590884u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_VIRTUAL_STORAGE_QUERY_PROPERTY: u32 = 590728u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_VIRTUAL_STORAGE_SET_BEHAVIOR: u32 = 590856u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_WAIT_FOR_REPAIR: u32 = 590240u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_WRITE_RAW_ENCRYPTED: u32 = 590047u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_WRITE_USN_CLOSE_RECORD: u32 = 590063u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSCTL_WRITE_USN_REASON: u32 = 590544u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_ADD_TC_CASE_SENSITIVE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_ADD_TC_KEY_BY_SHORT_NAME: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_ALLOCATE_ECPLIST_FLAG_CHARGE_QUOTA: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_ALLOCATE_ECP_FLAG_CHARGE_QUOTA: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_ALLOCATE_ECP_FLAG_NONPAGED_POOL: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_AUXILIARY_FLAG_DEALLOCATE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_CC_FLUSH_ERROR_FLAG_NO_HARD_ERROR: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_CC_FLUSH_ERROR_FLAG_NO_LOG_ENTRY: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_DRIVER_BACKING_FLAG_USE_PAGE_FILE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_ECP_LOOKASIDE_FLAG_NONPAGED_POOL: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_FAT_LEGAL: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_FCB_HEADER_V0: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_FCB_HEADER_V1: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_FCB_HEADER_V2: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_FCB_HEADER_V3: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_FCB_HEADER_V4: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_FIND_TC_CASE_SENSITIVE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_FLAG2_BYPASSIO_STREAM_PAUSED: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_FLAG2_DO_MODIFIED_WRITE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_FLAG2_IS_PAGING_FILE: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_FLAG2_PURGE_WHEN_MAPPED: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_FLAG2_WRITABLE_USER_MAPPED_FILE: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_FLAG_ACQUIRE_MAIN_RSRC_EX: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_FLAG_ACQUIRE_MAIN_RSRC_SH: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_FLAG_ADVANCED_HEADER: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_FLAG_EOF_ADVANCE_ACTIVE: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_FLAG_FILE_LENGTH_CHANGED: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_FLAG_FILE_MODIFIED: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_FLAG_LIMIT_MODIFIED_PAGES: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_FLAG_USER_MAPPED_FILE: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_HPFS_LEGAL: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_NTFS_LEGAL: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_OLE_LEGAL: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_UNC_HARDENING_CAPABILITIES_INTEGRITY: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_UNC_HARDENING_CAPABILITIES_MUTUAL_AUTH: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_UNC_HARDENING_CAPABILITIES_PRIVACY: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_UNC_PROVIDER_FLAGS_CONTAINER_AWARE: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_UNC_PROVIDER_FLAGS_CSC_ENABLED: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_UNC_PROVIDER_FLAGS_DOMAIN_SVC_AWARE: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_UNC_PROVIDER_FLAGS_MAILSLOTS_SUPPORTED: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_UNC_REGISTRATION_CURRENT_VERSION: u32 = 513u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_UNC_REGISTRATION_VERSION_0200: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_UNC_REGISTRATION_VERSION_0201: u32 = 513u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_VIRTDISK_FULLY_ALLOCATED: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_VIRTDISK_NO_DRIVE_LETTER: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_VOLUME_BACKGROUND_FORMAT: u32 = 14u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_VOLUME_CHANGE_SIZE: u32 = 13u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_VOLUME_DISMOUNT: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_VOLUME_DISMOUNT_FAILED: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_VOLUME_FORCED_CLOSED: u32 = 10u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_VOLUME_INFO_MAKE_COMPAT: u32 = 11u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_VOLUME_LOCK: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_VOLUME_LOCK_FAILED: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_VOLUME_MOUNT: u32 = 6u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_VOLUME_NEEDS_CHKDSK: u32 = 7u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_VOLUME_PREPARING_EJECT: u32 = 12u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_VOLUME_UNLOCK: u32 = 5u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_VOLUME_WEARING_OUT: u32 = 9u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_VOLUME_WORM_NEAR_FULL: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSRTL_WILD_CHARACTER: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FS_FILTER_SECTION_SYNC_IMAGE_EXTENTS_ARE_NOT_RVA: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FS_FILTER_SECTION_SYNC_IN_FLAG_DONT_UPDATE_LAST_ACCESS: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FS_FILTER_SECTION_SYNC_IN_FLAG_DONT_UPDATE_LAST_WRITE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FS_FILTER_SECTION_SYNC_SUPPORTS_ASYNC_PARALLEL_IO: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FS_FILTER_SECTION_SYNC_SUPPORTS_DIRECT_MAP_DATA: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FS_FILTER_SECTION_SYNC_SUPPORTS_DIRECT_MAP_IMAGE: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GCR_ALLOW_LM: u32 = 4096u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GCR_ALLOW_NO_TARGET: u32 = 8192u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GCR_ALLOW_NTLM: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GCR_MACHINE_CREDENTIAL: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GCR_NTLM3_PARMS: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GCR_TARGET_INFO: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GCR_USE_OEM_SET: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GCR_USE_OWF_PASSWORD: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GCR_VSM_PROTECTED_PASSWORD: u32 = 16384u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GENERATE_CLIENT_CHALLENGE: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GET_VOLUME_BITMAP_FLAG_MASK_METADATA: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GUID_ECP_ATOMIC_CREATE: ::windows_core::GUID = ::windows_core::GUID::from_u128(0x4720bd83_52ac_4104_a130_d1ec6a8cc8e5);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GUID_ECP_CLOUDFILES_ATTRIBUTION: ::windows_core::GUID = ::windows_core::GUID::from_u128(0x2932ff52_8378_4fc1_8edb_6bdc8f602709);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GUID_ECP_CREATE_REDIRECTION: ::windows_core::GUID = ::windows_core::GUID::from_u128(0x188d6bd6_a126_4fa8_bdf2_1ccdf896f3e0);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GUID_ECP_CSV_DOWN_LEVEL_OPEN: ::windows_core::GUID = ::windows_core::GUID::from_u128(0x4248be44_647f_488f_8be5_a08aaf70f028);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GUID_ECP_CSV_QUERY_FILE_REVISION: ::windows_core::GUID = ::windows_core::GUID::from_u128(0x44aec90b_de65_4d46_8fbf_763f9d970b1d);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GUID_ECP_CSV_QUERY_FILE_REVISION_FILE_ID_128: ::windows_core::GUID = ::windows_core::GUID::from_u128(0x7a3a4aa1_aa74_4bc6_b070_ab56a38c1fed);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GUID_ECP_CSV_SET_HANDLE_PROPERTIES: ::windows_core::GUID = ::windows_core::GUID::from_u128(0x7a9fdd94_7b58_42bb_9740_3cb86983a615);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GUID_ECP_DUAL_OPLOCK_KEY: ::windows_core::GUID = ::windows_core::GUID::from_u128(0x41621a14_b08b_4df1_b676_a05ffdf01bea);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GUID_ECP_IO_DEVICE_HINT: ::windows_core::GUID = ::windows_core::GUID::from_u128(0xf315b732_ac6b_4d4d_be0c_b3126490e1a3);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GUID_ECP_NETWORK_APP_INSTANCE: ::windows_core::GUID = ::windows_core::GUID::from_u128(0x6aa6bc45_a7ef_4af7_9008_fa462e144d74);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GUID_ECP_NETWORK_APP_INSTANCE_VERSION: ::windows_core::GUID = ::windows_core::GUID::from_u128(0xb7d082b9_563b_4f07_a07b_524a8116a010);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GUID_ECP_NETWORK_OPEN_CONTEXT: ::windows_core::GUID = ::windows_core::GUID::from_u128(0xc584edbf_00df_4d28_b884_35baca8911e8);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GUID_ECP_NFS_OPEN: ::windows_core::GUID = ::windows_core::GUID::from_u128(0xf326d30c_e5f8_4fe7_ab74_f5a3196d92db);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GUID_ECP_OPEN_PARAMETERS: ::windows_core::GUID = ::windows_core::GUID::from_u128(0xcd0a93c3_3bb7_463d_accb_969d3435a5a5);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GUID_ECP_OPLOCK_KEY: ::windows_core::GUID = ::windows_core::GUID::from_u128(0x48850596_3050_4be7_9863_fec350ce8d7f);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GUID_ECP_PREFETCH_OPEN: ::windows_core::GUID = ::windows_core::GUID::from_u128(0xe1777b21_847e_4837_aa45_64161d280655);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GUID_ECP_QUERY_ON_CREATE: ::windows_core::GUID = ::windows_core::GUID::from_u128(0x1aca62e9_abb4_4ff2_bb5c_1c79025e417f);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GUID_ECP_RKF_BYPASS: ::windows_core::GUID = ::windows_core::GUID::from_u128(0x02378cc6_f73c_489c_8282_564d1a99131b);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GUID_ECP_SRV_OPEN: ::windows_core::GUID = ::windows_core::GUID::from_u128(0xbebfaebc_aabf_489d_9d2c_e9e361102853);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_CLASS_0: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_CLASS_1: u32 = 4096u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_CLASS_2: u32 = 8192u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_CLASS_3: u32 = 12288u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_CLASS_4: u32 = 16384u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_CLASS_5: u32 = 20480u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_CLASS_6: u32 = 24576u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_CLASS_7: u32 = 28672u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_CLASS_8: u32 = 32768u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_CLASS_MASK: u32 = 61440u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_CREATE_ALIGN_16: u32 = 65536u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_CREATE_ENABLE_EXECUTE: u32 = 262144u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_CREATE_ENABLE_TRACING: u32 = 131072u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_CREATE_HARDENED: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_CREATE_SEGMENT_HEAP: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_DISABLE_COALESCE_ON_FREE: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_FREE_CHECKING_ENABLED: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_GENERATE_EXCEPTIONS: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_GLOBAL_TAG: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_GROWABLE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_MAXIMUM_TAG: u32 = 4095u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_NO_SERIALIZE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_PSEUDO_TAG_FLAG: u32 = 32768u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_REALLOC_IN_PLACE_ONLY: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_SETTABLE_USER_FLAG1: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_SETTABLE_USER_FLAG2: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_SETTABLE_USER_FLAG3: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_SETTABLE_USER_FLAGS: u32 = 3584u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_SETTABLE_USER_VALUE: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_TAG_SHIFT: u32 = 18u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_TAIL_CHECKING_ENABLED: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HEAP_ZERO_MEMORY: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const INHERITED_ACE: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const INHERIT_ONLY_ACE: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const INVALID_PROCESSOR_INDEX: u32 = 4294967295u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IOCTL_LMR_ARE_FILE_OBJECTS_ON_SAME_SERVER: u32 = 1310960u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IOCTL_REDIR_QUERY_PATH: u32 = 1311119u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IOCTL_REDIR_QUERY_PATH_EX: u32 = 1311123u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IOCTL_VOLSNAP_FLUSH_AND_HOLD_WRITES: u32 = 5488640u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_CD_ROM_INCREMENT: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_CREATE_STREAM_FILE_LITE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_CREATE_STREAM_FILE_RAISE_ON_ERROR: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_DISK_INCREMENT: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_FILE_OBJECT_NON_PAGED_POOL_CHARGE: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_FILE_OBJECT_PAGED_POOL_CHARGE: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_IGNORE_READONLY_ATTRIBUTE: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_MAILSLOT_INCREMENT: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_MM_PAGING_FILE: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_NAMED_PIPE_INCREMENT: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_NETWORK_INCREMENT: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_NO_INCREMENT: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_OPEN_PAGING_FILE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_OPEN_TARGET_DIRECTORY: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ACRONIS_HSM_0: i32 = 96i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ACRONIS_HSM_1: i32 = 97i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ACRONIS_HSM_2: i32 = 98i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ACRONIS_HSM_3: i32 = 99i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ACRONIS_HSM_4: i32 = 100i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ACRONIS_HSM_5: i32 = 101i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ACRONIS_HSM_6: i32 = 102i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ACRONIS_HSM_7: i32 = 103i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ACRONIS_HSM_8: i32 = 104i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ACRONIS_HSM_9: i32 = 105i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ACRONIS_HSM_A: i32 = 106i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ACRONIS_HSM_B: i32 = 107i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ACRONIS_HSM_C: i32 = 108i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ACRONIS_HSM_D: i32 = 109i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ACRONIS_HSM_E: i32 = 110i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ACRONIS_HSM_F: i32 = 111i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ACTIVISION_HSM: i32 = 71i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ADA_HSM: i32 = 38i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ADOBE_HSM: i32 = 69i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_AF_UNIX: i32 = -2147483613i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ALERTBOOT: i32 = 536870988i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ALTIRIS_HSM: i32 = 25i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_APPEXECLINK: i32 = -2147483621i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_APPXSTRM: i32 = -1073741804i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ARCO_BACKUP: i32 = 59i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ARKIVIO: i32 = 12i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_AURISTOR_FS: i32 = 73i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_AUTN_HSM: i32 = 39i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_BRIDGEHEAD_HSM: i32 = 22i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_C2CSYSTEMS_HSM: i32 = 49i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_CARINGO_HSM: i32 = 52i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_CARROLL_HSM: i32 = 60i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_CITRIX_PM: i32 = 54i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_CLOUD: i32 = -1879048166i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_CLOUD_1: i32 = -1879044070i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_CLOUD_2: i32 = -1879039974i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_CLOUD_3: i32 = -1879035878i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_CLOUD_4: i32 = -1879031782i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_CLOUD_5: i32 = -1879027686i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_CLOUD_6: i32 = -1879023590i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_CLOUD_7: i32 = -1879019494i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_CLOUD_8: i32 = -1879015398i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_CLOUD_9: i32 = -1879011302i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_CLOUD_A: i32 = -1879007206i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_CLOUD_B: i32 = -1879003110i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_CLOUD_C: i32 = -1878999014i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_CLOUD_D: i32 = -1878994918i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_CLOUD_E: i32 = -1878990822i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_CLOUD_F: i32 = -1878986726i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_CLOUD_MASK: i32 = 61440i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_COMMVAULT: i32 = 14i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_COMMVAULT_HSM: i32 = 29i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_COMTRADE_HSM: i32 = 61i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_CSV: i32 = -2147483639i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_CTERA_HSM: i32 = 78i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_DATAFIRST_HSM: i32 = 48i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_DATAGLOBAL_HSM: i32 = 46i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_DATALESS_CIM: i32 = -1610612696i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_DATASTOR_SIS: i32 = 30i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_DEDUP: i32 = -2147483629i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_DFM: i32 = -2147483626i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_DFS: i32 = -2147483638i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_DFSR: i32 = -2147483630i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_DOR_HSM: i32 = 82i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_DOUBLE_TAKE_HSM: i32 = 34i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_DOUBLE_TAKE_SIS: i32 = 41i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_DRIVE_EXTENDER: i32 = -2147483643i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_DROPBOX_HSM: i32 = 68i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_EASEFILTER_HSM: i32 = 87i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_EASEVAULT_HSM: i32 = 62i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_EDSI_HSM: i32 = 31i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ELTAN_HSM: i32 = 43i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_EMC_HSM: i32 = 57i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ENIGMA_HSM: i32 = 17i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_FILE_PLACEHOLDER: i32 = -2147483627i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_FILTER_MANAGER: i32 = -2147483637i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_GLOBAL360_HSM: i32 = 24i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_GLOBAL_REPARSE: i32 = -1610612711i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_GOOGLE_HSM: i32 = 65i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_GRAU_DATASTORAGE_HSM: i32 = 28i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_HDS_HCP_HSM: i32 = 72i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_HDS_HSM: i32 = 63i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_HERMES_HSM: i32 = 26i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_HP_BACKUP: i32 = 67i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_HP_DATA_PROTECT: i32 = 70i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_HP_HSM: i32 = 32i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_HSAG_HSM: i32 = 37i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_HSM: i32 = -1073741820i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_HSM2: i32 = -2147483642i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_HUBSTOR_HSM: i32 = 85i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_IFSTEST_CONGRUENT: i32 = 9i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_IIS_CACHE: i32 = -1610612720i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_IMANAGE_HSM: i32 = 536870998i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_INTERCOPE_HSM: i32 = 19i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ITSTATION: i32 = 74i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_KOM_NETWORKS_HSM: i32 = 20i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_LX_BLK: i32 = -2147483610i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_LX_CHR: i32 = -2147483611i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_LX_FIFO: i32 = -2147483612i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_LX_SYMLINK: i32 = -1610612707i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_MAGINATICS_RDR: i32 = 64i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_MAXISCALE_HSM: i32 = 536870965i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_MEMORY_TECH_HSM: i32 = 21i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_MIMOSA_HSM: i32 = 36i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_MOONWALK_HSM: i32 = 10i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_MOUNT_POINT: i32 = -1610612733i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_MTALOS: i32 = 77i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_NEUSHIELD: i32 = 81i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_NEXSAN_HSM: i32 = 40i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_NFS: i32 = -2147483628i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_NIPPON_HSM: i32 = 79i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_NVIDIA_UNIONFS: i32 = 536870996i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ONEDRIVE: i32 = -2147483615i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_OPENAFS_DFS: i32 = 55i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_OSR_SAMPLE: i32 = 536870935i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_OVERTONE: i32 = 15i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_POINTSOFT_HSM: i32 = 27i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_PROJFS: i32 = -1879048164i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_PROJFS_TOMBSTONE: i32 = -1610612702i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_QI_TECH_HSM: i32 = 536870959i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_QUADDRA_HSM: i32 = 66i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_QUEST_HSM: i32 = 45i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_REDSTOR_HSM: i32 = 80i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_RESERVED_ONE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_RESERVED_RANGE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_RESERVED_TWO: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_RESERVED_ZERO: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_RIVERBED_HSM: i32 = 51i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_SER_HSM: i32 = 33i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_SHX_BACKUP: i32 = 83i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_SIS: i32 = -2147483641i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_SOLUTIONSOFT: i32 = 536870925i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_SONY_HSM: i32 = 42i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_SPHARSOFT: i32 = 75i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_STORAGE_SYNC: i32 = -2147483618i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_SYMANTEC_HSM: i32 = 18i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_SYMANTEC_HSM2: i32 = 16i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_SYMLINK: i32 = -1610612724i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_TSINGHUA_UNIVERSITY_RESEARCH: i32 = 11i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_UNHANDLED: i32 = -2147483616i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_UTIXO_HSM: i32 = 44i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_VALID_VALUES: u32 = 4026597375u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_VMWARE_PM: i32 = 58i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_WATERFORD: i32 = 50i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_WCI: i32 = -2147483624i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_WCI_1: i32 = -1879044072i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_WCI_LINK: i32 = -1610612697i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_WCI_LINK_1: i32 = -1610608601i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_WCI_TOMBSTONE: i32 = -1610612705i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_WIM: i32 = -2147483640i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_WISDATA_HSM: i32 = 35i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_WOF: i32 = -2147483625i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_REPARSE_TAG_ZLTI_HSM: i32 = 56i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const IO_STOP_ON_SYMLINK: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_ALLOCATE_MEMORY: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_CALL_LEVEL: u32 = 4096u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_CONFIDENTIALITY: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_CONFIDENTIALITY_ONLY: u32 = 1073741824u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_CONNECTION: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_DATAGRAM: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_DEFERRED_CRED_VALIDATION: u64 = 8589934592u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_DELEGATE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_EXTENDED_ERROR: u32 = 16384u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_FORWARD_CREDENTIALS: u32 = 4194304u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_FRAGMENT_SUPPLIED: u32 = 8192u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_FRAGMENT_TO_FIT: u32 = 2097152u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_IDENTIFY: u32 = 131072u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_INTEGRITY: u32 = 65536u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_MANUAL_CRED_VALIDATION: u32 = 524288u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_MESSAGES: u64 = 4294967296u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_MUTUAL_AUTH: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_NO_INTEGRITY: u32 = 8388608u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_NO_POST_HANDSHAKE_AUTH: u64 = 17179869184u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_NULL_SESSION: u32 = 262144u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_PROMPT_FOR_CREDS: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_REPLAY_DETECT: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_RESERVED1: u32 = 1048576u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_SEQUENCE_DETECT: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_STREAM: u32 = 32768u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_UNVERIFIED_TARGET_NAME: u32 = 536870912u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_USE_DCE_STYLE: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_USE_HTTP_STYLE: u32 = 16777216u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_USE_SESSION_KEY: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_REQ_USE_SUPPLIED_CREDS: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_ALLOCATED_MEMORY: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_CALL_LEVEL: u32 = 8192u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_CONFIDENTIALITY: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_CONFIDENTIALITY_ONLY: u32 = 1073741824u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_CONNECTION: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_DATAGRAM: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_DEFERRED_CRED_VALIDATION: u64 = 8589934592u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_DELEGATE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_EXTENDED_ERROR: u32 = 16384u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_FORWARD_CREDENTIALS: u32 = 4194304u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_FRAGMENT_ONLY: u32 = 2097152u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_IDENTIFY: u32 = 131072u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_INTEGRITY: u32 = 65536u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_INTERMEDIATE_RETURN: u32 = 4096u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_MANUAL_CRED_VALIDATION: u32 = 524288u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_MESSAGES: u64 = 4294967296u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_MUTUAL_AUTH: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_NO_ADDITIONAL_TOKEN: u32 = 33554432u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_NO_POST_HANDSHAKE_AUTH: u64 = 17179869184u64;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_NULL_SESSION: u32 = 262144u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_REAUTHENTICATION: u32 = 134217728u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_REPLAY_DETECT: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_RESERVED1: u32 = 1048576u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_SEQUENCE_DETECT: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_STREAM: u32 = 32768u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_USED_COLLECTED_CREDS: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_USED_DCE_STYLE: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_USED_HTTP_STYLE: u32 = 16777216u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_USED_SUPPLIED_CREDS: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISC_RET_USE_SESSION_KEY: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISSP_LEVEL: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ISSP_MODE: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const KDC_PROXY_SETTINGS_FLAGS_FORCEPROXY: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const KDC_PROXY_SETTINGS_V1: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOGON_CACHED_ACCOUNT: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOGON_EXTRA_SIDS: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOGON_GRACE_LOGON: u32 = 16777216u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOGON_GUEST: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOGON_LM_V2: u32 = 4096u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOGON_MANAGED_SERVICE: u32 = 524288u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOGON_NOENCRYPTION: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOGON_NO_ELEVATION: u32 = 262144u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOGON_NO_OPTIMIZED: u32 = 131072u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOGON_NTLMV2_ENABLED: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOGON_NTLM_V2: u32 = 8192u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOGON_NT_V2: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOGON_OPTIMIZED: u32 = 16384u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOGON_PKINIT: u32 = 65536u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOGON_PROFILE_PATH_RETURNED: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOGON_RESOURCE_GROUPS: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOGON_SERVER_TRUST_ACCOUNT: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOGON_SUBAUTH_SESSION_KEY: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOGON_USED_LM_PASSWORD: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOGON_WINLOGON: u32 = 32768u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_DATA: u32 = 16777216u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_INDEX: u32 = 33554432u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_MASK: u32 = 4278190080u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_SYSTEM: u32 = 50331648u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_DENY_DEFRAG_SET: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_FS_SYSTEM_FILE: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_PAGE_FILE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_TXF_SYSTEM_FILE: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LX_FILE_CASE_SENSITIVE_DIR: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LX_FILE_METADATA_DEVICE_ID_EA_NAME: ::windows_core::PCSTR = ::windows_core::s!("$LXDEV");
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LX_FILE_METADATA_GID_EA_NAME: ::windows_core::PCSTR = ::windows_core::s!("$LXGID");
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LX_FILE_METADATA_HAS_DEVICE_ID: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LX_FILE_METADATA_HAS_GID: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LX_FILE_METADATA_HAS_MODE: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LX_FILE_METADATA_HAS_UID: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LX_FILE_METADATA_MODE_EA_NAME: ::windows_core::PCSTR = ::windows_core::s!("$LXMOD");
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LX_FILE_METADATA_UID_EA_NAME: ::windows_core::PCSTR = ::windows_core::s!("$LXUID");
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MAP_DISABLE_PAGEFAULT_CLUSTERING: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MAP_HIGH_PRIORITY: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MAP_NO_READ: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MAP_WAIT: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MARK_HANDLE_CLOUD_SYNC: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MARK_HANDLE_DISABLE_FILE_METADATA_OPTIMIZATION: u32 = 4096u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MARK_HANDLE_ENABLE_CPU_CACHE: u32 = 268435456u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MARK_HANDLE_ENABLE_USN_SOURCE_ON_PAGING_IO: u32 = 8192u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MARK_HANDLE_FILTER_METADATA: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MARK_HANDLE_NOT_READ_COPY: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MARK_HANDLE_NOT_REALTIME: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MARK_HANDLE_NOT_TXF_SYSTEM_LOG: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MARK_HANDLE_PROTECT_CLUSTERS: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MARK_HANDLE_READ_COPY: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MARK_HANDLE_REALTIME: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MARK_HANDLE_RETURN_PURGE_FAILURE: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MARK_HANDLE_SKIP_COHERENCY_SYNC_DISALLOW_WRITES: u32 = 16384u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MARK_HANDLE_SUPPRESS_VOLUME_OPEN_FLUSH: u32 = 32768u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MARK_HANDLE_TXF_SYSTEM_LOG: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MAXIMUM_ENCRYPTION_VALUE: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MAXIMUM_LEADBYTES: u32 = 12u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MAX_UNICODE_STACK_BUFFER_LENGTH: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MCB_FLAG_RAISE_ON_ALLOCATION_FAILURE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const METHOD_BUFFERED: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const METHOD_DIRECT_FROM_HARDWARE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const METHOD_DIRECT_TO_HARDWARE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const METHOD_IN_DIRECT: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const METHOD_NEITHER: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const METHOD_OUT_DIRECT: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MM_FORCE_CLOSED_DATA: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MM_FORCE_CLOSED_IMAGE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MM_FORCE_CLOSED_LATER_OK: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MM_IS_FILE_SECTION_ACTIVE_DATA: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MM_IS_FILE_SECTION_ACTIVE_IMAGE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MM_IS_FILE_SECTION_ACTIVE_USER: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_ALLOW_FORCE_GUEST: u32 = 8192u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_ALLOW_MSVCHAPV2: u32 = 65536u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_ALLOW_SERVER_TRUST_ACCOUNT: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_ALLOW_WORKSTATION_TRUST_ACCOUNT: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_AV_FLAG_FORCE_GUEST: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_AV_FLAG_MIC_HANDSHAKE_MESSAGES: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_AV_FLAG_UNVERIFIED_TARGET: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_CHALLENGE_LENGTH: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_CHECK_LOGONHOURS_FOR_S4U: u32 = 262144u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_CLEARTEXT_PASSWORD_ALLOWED: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_CLEARTEXT_PASSWORD_SUPPLIED: u32 = 16384u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_CREDENTIAL_KEY_LENGTH: u32 = 20u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_CRED_CREDKEY_PRESENT: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_CRED_LM_PRESENT: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_CRED_NT_PRESENT: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_CRED_REMOVED: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_CRED_SHA_PRESENT: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_CRED_VERSION: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_CRED_VERSION_ARSO: u32 = 4294901763u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_CRED_VERSION_INVALID: u32 = 4294967295u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_CRED_VERSION_IUM: u32 = 4294901761u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_CRED_VERSION_REMOTE: u32 = 4294901762u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_CRED_VERSION_RESERVED_1: u32 = 4294967294u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_CRED_VERSION_V2: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_CRED_VERSION_V3: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_DISABLE_PERSONAL_FALLBACK: u32 = 4096u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_DONT_TRY_GUEST_ACCOUNT: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_INTERNET_DOMAIN: u32 = 524288u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_LANMAN_SESSION_KEY_LENGTH: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_MAX_AVL_SIZE: u32 = 64000u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_MAX_NTLM3_LIFE: u32 = 1800u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_MNS_LOGON: u32 = 16777216u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_NTLM3_OWF_LENGTH: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_NTLM3_RESPONSE_LENGTH: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_OWF_PASSWORD_LENGTH: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_PACKAGE_NAME: ::windows_core::PCSTR = ::windows_core::s!("MICROSOFT_AUTHENTICATION_PACKAGE_V1_0");
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_PACKAGE_NAMEW: ::windows_core::PCWSTR = ::windows_core::w!("MICROSOFT_AUTHENTICATION_PACKAGE_V1_0");
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_RETURN_PASSWORD_EXPIRY: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_RETURN_PROFILE_PATH: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_RETURN_USER_PARAMETERS: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_S4U2SELF: u32 = 131072u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_S4U_LOGON_FLAG_CHECK_LOGONHOURS: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_SHA_PASSWORD_LENGTH: u32 = 20u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_SUBAUTHENTICATION_DLL: u32 = 4278190080u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_SUBAUTHENTICATION_DLL_EX: u32 = 1048576u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_SUBAUTHENTICATION_DLL_IIS: u32 = 132u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_SUBAUTHENTICATION_DLL_RAS: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_SUBAUTHENTICATION_DLL_SHIFT: u32 = 24u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_SUBAUTHENTICATION_FLAGS: u32 = 4278190080u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_SUBAUTHENTICATION_KEY: ::windows_core::PCSTR = ::windows_core::s!("SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0");
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_SUBAUTHENTICATION_VALUE: ::windows_core::PCSTR = ::windows_core::s!("Auth");
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_TRY_GUEST_ACCOUNT_ONLY: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_TRY_SPECIFIED_DOMAIN_ONLY: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_UPDATE_LOGON_STATISTICS: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_USER_SESSION_KEY_LENGTH: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_USE_CLIENT_CHALLENGE: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MSV1_0_USE_DOMAIN_FOR_ROUTING_ONLY: u32 = 32768u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NETWORK_APP_INSTANCE_CSV_FLAGS_VALID_ONLY_IF_CSV_COORDINATOR: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NETWORK_OPEN_ECP_IN_FLAG_DISABLE_HANDLE_COLLAPSING: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NETWORK_OPEN_ECP_IN_FLAG_DISABLE_HANDLE_DURABILITY: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NETWORK_OPEN_ECP_IN_FLAG_DISABLE_OPLOCKS: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NETWORK_OPEN_ECP_IN_FLAG_FORCE_BUFFERED_SYNCHRONOUS_IO_HACK: u32 = 2147483648u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NETWORK_OPEN_ECP_IN_FLAG_FORCE_MAX_EOF_HACK: u32 = 1073741824u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NETWORK_OPEN_ECP_IN_FLAG_REQ_MUTUAL_AUTH: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NETWORK_OPEN_ECP_OUT_FLAG_RET_MUTUAL_AUTH: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NO_8DOT3_NAME_PRESENT: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NO_LONG_NAMES: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NO_PROPAGATE_INHERIT_ACE: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OBJECT_INHERIT_ACE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OFFLOAD_READ_FLAG_ALL_ZERO_BEYOND_CURRENT_RANGE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPEN_REPARSE_POINT_OVERRIDE_CREATE_OPTION: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPEN_REPARSE_POINT_REPARSE_ALWAYS: u32 = 126u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPEN_REPARSE_POINT_REPARSE_IF_CHILD_EXISTS: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPEN_REPARSE_POINT_REPARSE_IF_CHILD_NOT_EXISTS: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPEN_REPARSE_POINT_REPARSE_IF_DIRECTORY_FINAL_COMPONENT: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPEN_REPARSE_POINT_REPARSE_IF_DIRECTORY_FINAL_COMPONENT_ALWAYS: u32 = 72u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPEN_REPARSE_POINT_REPARSE_IF_FINAL_COMPONENT: u32 = 40u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPEN_REPARSE_POINT_REPARSE_IF_FINAL_COMPONENT_ALWAYS: u32 = 104u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPEN_REPARSE_POINT_REPARSE_IF_NON_DIRECTORY_FINAL_COMPONENT: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPEN_REPARSE_POINT_REPARSE_IF_NON_DIRECTORY_FINAL_COMPONENT_ALWAYS: u32 = 96u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPEN_REPARSE_POINT_REPARSE_IF_NON_DIRECTORY_NON_FINAL_COMPONENT: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPEN_REPARSE_POINT_REPARSE_IF_NON_DIRECTORY_NON_FINAL_COMPONENT_ALWAYS: u32 = 80u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPEN_REPARSE_POINT_REPARSE_IF_NON_FINAL_COMPONENT: u32 = 22u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPEN_REPARSE_POINT_RETURN_REPARSE_DATA_BUFFER: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPEN_REPARSE_POINT_TAG_ENCOUNTERED: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPEN_REPARSE_POINT_VERSION_EX: u32 = 2147483648u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPLOCK_FLAG_BACK_OUT_ATOMIC_OPLOCK: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPLOCK_FLAG_BREAKING_FOR_SHARING_VIOLATION: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPLOCK_FLAG_CLOSING_DELETE_ON_CLOSE: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPLOCK_FLAG_COMPLETE_IF_OPLOCKED: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPLOCK_FLAG_IGNORE_OPLOCK_KEYS: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPLOCK_FLAG_OPLOCK_KEY_CHECK_ONLY: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPLOCK_FLAG_PARENT_OBJECT: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPLOCK_FLAG_REMOVING_FILE_OR_LINK: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPLOCK_FSCTRL_FLAG_ALL_KEYS_MATCH: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPLOCK_LEVEL_CACHE_HANDLE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPLOCK_LEVEL_CACHE_READ: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPLOCK_LEVEL_CACHE_WRITE: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPLOCK_UPPER_FLAG_CHECK_NO_BREAK: u32 = 65536u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPLOCK_UPPER_FLAG_NOTIFY_REFRESH_READ: u32 = 131072u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PERSISTENT_VOLUME_STATE_BACKED_BY_WIM: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PERSISTENT_VOLUME_STATE_CHKDSK_RAN_ONCE: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PERSISTENT_VOLUME_STATE_CONTAINS_BACKING_WIM: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PERSISTENT_VOLUME_STATE_DAX_FORMATTED: u32 = 4096u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PERSISTENT_VOLUME_STATE_GLOBAL_METADATA_NO_SEEK_PENALTY: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PERSISTENT_VOLUME_STATE_LOCAL_METADATA_NO_SEEK_PENALTY: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PERSISTENT_VOLUME_STATE_MODIFIED_BY_CHKDSK: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PERSISTENT_VOLUME_STATE_NO_HEAT_GATHERING: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PERSISTENT_VOLUME_STATE_NO_WRITE_AUTO_TIERING: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PERSISTENT_VOLUME_STATE_REALLOCATE_ALL_DATA_WRITES: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PERSISTENT_VOLUME_STATE_SHORT_NAME_CREATION_DISABLED: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PERSISTENT_VOLUME_STATE_TXF_DISABLED: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PERSISTENT_VOLUME_STATE_VOLUME_SCRUB_DISABLED: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PIN_CALLER_TRACKS_DIRTY_DATA: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PIN_EXCLUSIVE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PIN_HIGH_PRIORITY: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PIN_IF_BCB: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PIN_NO_READ: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PIN_VERIFY_REQUIRED: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PIN_WAIT: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const POLICY_AUDIT_SUBCATEGORY_COUNT: u32 = 59u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PO_CB_AC_STATUS: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PO_CB_BUTTON_COLLISION: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PO_CB_LID_SWITCH_STATE: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PO_CB_PROCESSOR_POWER_POLICY: u32 = 5u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PO_CB_SYSTEM_POWER_POLICY: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PO_CB_SYSTEM_STATE_LOCK: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PROJFS_PROTOCOL_VERSION: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PSMP_MAXIMUM_SYSAPP_CLAIM_VALUES: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PSMP_MINIMUM_SYSAPP_CLAIM_VALUES: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const PURGE_WITH_ACTIVE_VIEWS: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_DEPENDENT_VOLUME_REQUEST_FLAG_GUEST_VOLUMES: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_DEPENDENT_VOLUME_REQUEST_FLAG_HOST_VOLUMES: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_DIRECT_ACCESS_DATA_EXTENTS: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_DIRECT_ACCESS_IMAGE_EXTENTS: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_INCLUDE_EXTENTS: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_INCLUDE_EXTRA_INFO: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_INCLUDE_FILES_WITH_DSC_ATTRIBUTE: u32 = 4096u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_INCLUDE_FULL_PATH_IN_NAMES: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_INCLUDE_NAMES: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_INCLUDE_ONLY_FILES_WITH_SPECIFIC_ATTRIBUTES: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAMS: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAMS_WITH_NO_CLUSTERS_ALLOCATED: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_DATA_ATTRIBUTE: u32 = 8192u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_DSC_ATTRIBUTE: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_EA_ATTRIBUTE: u32 = 32768u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_EFS_ATTRIBUTE: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_REPARSE_ATTRIBUTE: u32 = 16384u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_TXF_ATTRIBUTE: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_REPARSE_DATA_INVALID: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_REPARSE_TAG_INVALID: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_RESTART: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_SINGLE_INSTANCED: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_STORAGE_CLASSES_FLAGS_MEASURE_READ: u32 = 1073741824u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_STORAGE_CLASSES_FLAGS_MEASURE_WRITE: u32 = 2147483648u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_STORAGE_CLASSES_FLAGS_NO_DEFRAG_VOLUME: u32 = 536870912u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QoCFileEaInformation: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QoCFileLxInformation: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QoCFileStatInformation: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_SMR_VOLUME_GC_PARAMETERS_VERSION_V1: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_SMR_VOLUME_INFO_OUTPUT_VERSION_V0: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_SMR_VOLUME_INFO_OUTPUT_VERSION_V1: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REMOTE_PROTOCOL_FLAG_INTEGRITY: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REMOTE_PROTOCOL_FLAG_LOOPBACK: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REMOTE_PROTOCOL_FLAG_MUTUAL_AUTH: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REMOTE_PROTOCOL_FLAG_OFFLINE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REMOTE_PROTOCOL_FLAG_PERSISTENT_HANDLE: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REMOTE_PROTOCOL_FLAG_PRIVACY: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REMOVED_8DOT3_NAME: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REPARSE_DATA_EX_FLAG_GIVEN_TAG_OR_NONE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REQUEST_OPLOCK_CURRENT_VERSION: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REQUEST_OPLOCK_INPUT_FLAG_ACK: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REQUEST_OPLOCK_INPUT_FLAG_COMPLETE_ACK_ON_CLOSE: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REQUEST_OPLOCK_INPUT_FLAG_REQUEST: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REQUEST_OPLOCK_OUTPUT_FLAG_ACK_REQUIRED: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REQUEST_OPLOCK_OUTPUT_FLAG_MODES_PROVIDED: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RETURN_NON_NT_USER_SESSION_KEY: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RETURN_PRIMARY_LOGON_DOMAINNAME: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RETURN_PRIMARY_USERNAME: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RETURN_RESERVED_PARAMETER: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RPI_SMB2_SERVERCAP_DFS: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RPI_SMB2_SERVERCAP_DIRECTORY_LEASING: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RPI_SMB2_SERVERCAP_ENCRYPTION_AWARE: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RPI_SMB2_SERVERCAP_LARGEMTU: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RPI_SMB2_SERVERCAP_LEASING: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RPI_SMB2_SERVERCAP_MULTICHANNEL: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RPI_SMB2_SERVERCAP_PERSISTENT_HANDLES: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RPI_SMB2_SHARECAP_ACCESS_BASED_DIRECTORY_ENUM: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RPI_SMB2_SHARECAP_ASYMMETRIC_SCALEOUT: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RPI_SMB2_SHARECAP_CLUSTER: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RPI_SMB2_SHARECAP_CONTINUOUS_AVAILABILITY: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RPI_SMB2_SHARECAP_DFS: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RPI_SMB2_SHARECAP_ENCRYPTED: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RPI_SMB2_SHARECAP_IDENTITY_REMOTING: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RPI_SMB2_SHARECAP_SCALEOUT: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RPI_SMB2_SHARECAP_TIMEWARP: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RPI_SMB2_SHAREFLAG_COMPRESS_DATA: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RPI_SMB2_SHAREFLAG_ENCRYPT_DATA: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RPI_SMB2_SHARETYPE_DISK: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RPI_SMB2_SHARETYPE_PIPE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RPI_SMB2_SHARETYPE_PRINT: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RTL_HEAP_MEMORY_LIMIT_CURRENT_VERSION: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RTL_SYSTEM_VOLUME_INFORMATION_FOLDER: ::windows_core::PCWSTR = ::windows_core::w!("System Volume Information");
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SCRUB_DATA_INPUT_FLAG_IGNORE_REDUNDANCY: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SCRUB_DATA_INPUT_FLAG_OPLOCK_NOT_ACQUIRED: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SCRUB_DATA_INPUT_FLAG_RESUME: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SCRUB_DATA_INPUT_FLAG_SCRUB_BY_OBJECT_ID: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SCRUB_DATA_INPUT_FLAG_SKIP_DATA: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SCRUB_DATA_INPUT_FLAG_SKIP_IN_SYNC: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SCRUB_DATA_INPUT_FLAG_SKIP_NON_INTEGRITY_DATA: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SCRUB_DATA_OUTPUT_FLAG_INCOMPLETE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SCRUB_DATA_OUTPUT_FLAG_NON_USER_DATA_RANGE: u32 = 65536u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SCRUB_DATA_OUTPUT_FLAG_PARITY_EXTENT_DATA_RETURNED: u32 = 131072u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SCRUB_DATA_OUTPUT_FLAG_RESUME_CONTEXT_LENGTH_SPECIFIED: u32 = 262144u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SD_GLOBAL_CHANGE_TYPE_ENUM_SDS: u32 = 131072u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SD_GLOBAL_CHANGE_TYPE_MACHINE_SID: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SD_GLOBAL_CHANGE_TYPE_QUERY_STATS: u32 = 65536u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_ALERT: u32 = 17u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_APPLICATION_PROTOCOLS: u32 = 18u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_ATTRMASK: u32 = 4026531840u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_CERTIFICATE_REQUEST_CONTEXT: u32 = 29u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_CHANGE_PASS_RESPONSE: u32 = 15u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_CHANNEL_BINDINGS: u32 = 14u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_DATA: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_DTLS_MTU: u32 = 24u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_EMPTY: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_EXTRA: u32 = 5u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_FLAGS: u32 = 27u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_MECHLIST: u32 = 11u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_MECHLIST_SIGNATURE: u32 = 12u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_MISSING: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_NEGOTIATION_INFO: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_PADDING: u32 = 9u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_PKG_PARAMS: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_PRESHARED_KEY: u32 = 22u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_PRESHARED_KEY_IDENTITY: u32 = 23u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_READONLY: u32 = 2147483648u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_READONLY_WITH_CHECKSUM: u32 = 268435456u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_RESERVED: u32 = 1610612736u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_SEND_GENERIC_TLS_EXTENSION: u32 = 25u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_SRTP_MASTER_KEY_IDENTIFIER: u32 = 20u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_SRTP_PROTECTION_PROFILES: u32 = 19u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_STREAM: u32 = 10u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_STREAM_HEADER: u32 = 7u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_STREAM_TRAILER: u32 = 6u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_SUBSCRIBE_GENERIC_TLS_EXTENSION: u32 = 26u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_TARGET: u32 = 13u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_TARGET_HOST: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_TOKEN: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_TOKEN_BINDING: u32 = 21u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_TRAFFIC_SECRETS: u32 = 28u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECBUFFER_VERSION: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_ACCESS_TOKEN: u32 = 18u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_APPLICATION_PROTOCOL: u32 = 35u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_AUTHENTICATION_ID: u32 = 20u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_AUTHORITY: u32 = 6u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_CLIENT_SPECIFIED_TARGET: u32 = 27u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_CONTEXT_DELETED: u32 = 33u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_CREDENTIAL_NAME: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_DATAGRAM_SIZES: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_DCE_INFO: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_DTLS_MTU: u32 = 34u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_ENDPOINT_BINDINGS: u32 = 26u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_FLAGS: u32 = 14u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_IS_LOOPBACK: u32 = 37u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_KEY_INFO: u32 = 5u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_LAST_CLIENT_TOKEN_STATUS: u32 = 30u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_LIFESPAN: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_LOGOFF_TIME: u32 = 21u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_NAMES: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_NATIVE_NAMES: u32 = 13u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_NEGOTIATED_TLS_EXTENSIONS: u32 = 36u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_NEGOTIATION_INFO: u32 = 12u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_NEGO_INFO_FLAG_NO_KERBEROS: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_NEGO_INFO_FLAG_NO_NTLM: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_NEGO_KEYS: u32 = 22u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_NEGO_PKG_INFO: u32 = 31u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_NEGO_STATUS: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_PACKAGE_INFO: u32 = 10u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_PASSWORD_EXPIRY: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_PROMPTING_NEEDED: u32 = 24u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_PROTO_INFO: u32 = 7u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_SESSION_KEY: u32 = 9u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_SIZES: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_STREAM_SIZES: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_SUBJECT_SECURITY_ATTRIBUTES: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_TARGET: u32 = 19u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_TARGET_INFORMATION: u32 = 17u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_UNIQUE_BINDINGS: u32 = 25u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_USER_FLAGS: u32 = 11u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ATTR_USE_VALIDATED: u32 = 15u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_CALLFLAGS_APPCONTAINER: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_CALLFLAGS_APPCONTAINER_AUTHCAPABLE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_CALLFLAGS_APPCONTAINER_UPNCAPABLE: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_CALLFLAGS_FORCE_SUPPLIED: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_CONTEXT_EXPORT_DELETE_OLD: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_CONTEXT_EXPORT_RESET_NEW: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_CONTEXT_EXPORT_TO_KERNEL: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_CRED_ATTR_CERT: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_CRED_ATTR_KDC_PROXY_SETTINGS: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_CRED_ATTR_NAMES: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_CRED_ATTR_PAC_BYPASS: u32 = 5u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_CRED_ATTR_SSI_PROVIDER: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_CRED_AUTOLOGON_RESTRICTED: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_CRED_BOTH: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_CRED_DEFAULT: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_CRED_INBOUND: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_CRED_OUTBOUND: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_CRED_PROCESS_POLICY_ONLY: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_CRED_RESERVED: u32 = 4026531840u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_ACCEPT_WIN32_NAME: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_APPCONTAINER_CHECKS: u32 = 8388608u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_APPCONTAINER_PASSTHROUGH: u32 = 4194304u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_APPLY_LOOPBACK: u32 = 33554432u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_ASCII_BUFFERS: u32 = 16384u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_CLIENT_ONLY: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_CONNECTION: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_CREDENTIAL_ISOLATION_ENABLED: u32 = 16777216u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_DATAGRAM: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_DELEGATION: u32 = 131072u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_EXTENDED_ERROR: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_FRAGMENT: u32 = 32768u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_GSS_COMPATIBLE: u32 = 4096u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_IMPERSONATION: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_INTEGRITY: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_LOGON: u32 = 8192u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_MULTI_REQUIRED: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_MUTUAL_AUTH: u32 = 65536u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_NEGOTIABLE: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_NEGOTIABLE2: u32 = 2097152u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_NEGO_EXTENDER: u32 = 1048576u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_PRIVACY: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_READONLY_WITH_CHECKSUM: u32 = 262144u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_RESTRICTED_TOKENS: u32 = 524288u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_STREAM: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_FLAG_TOKEN_ONLY: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECPKG_ID_NONE: u32 = 65535u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECQOP_WRAP_NO_ENCRYPT: u32 = 2147483649u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECQOP_WRAP_OOB_DATA: u32 = 1073741824u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_ANONYMOUS_LOGON_RID: i32 = 7i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_APPPOOL_ID_BASE_RID: i32 = 82i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_APPPOOL_ID_RID_COUNT: i32 = 6i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_APP_PACKAGE_BASE_RID: i32 = 2i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_APP_PACKAGE_RID_COUNT: i32 = 8i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_AUTHENTICATED_USER_RID: i32 = 11i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_AUTHENTICATION_AUTHORITY_ASSERTED_RID: i32 = 1i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_AUTHENTICATION_AUTHORITY_RID_COUNT: i32 = 1i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_AUTHENTICATION_FRESH_KEY_AUTH_RID: i32 = 3i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_AUTHENTICATION_KEY_PROPERTY_ATTESTATION_RID: i32 = 6i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_AUTHENTICATION_KEY_PROPERTY_MFA_RID: i32 = 5i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_AUTHENTICATION_KEY_TRUST_RID: i32 = 4i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_AUTHENTICATION_SERVICE_ASSERTED_RID: i32 = 2i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_BATCH_RID: i32 = 3i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_BUILTIN_APP_PACKAGE_RID_COUNT: i32 = 2i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_BUILTIN_CAPABILITY_RID_COUNT: i32 = 2i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_BUILTIN_DOMAIN_RID: i32 = 32i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_BUILTIN_PACKAGE_ANY_PACKAGE: i32 = 1i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_BUILTIN_PACKAGE_ANY_RESTRICTED_PACKAGE: i32 = 2i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CAPABILITY_APPOINTMENTS: i32 = 11i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CAPABILITY_APP_RID: i32 = 1024i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CAPABILITY_APP_SILO_RID: i32 = 65536i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CAPABILITY_BASE_RID: i32 = 3i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CAPABILITY_CONTACTS: i32 = 12i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CAPABILITY_DOCUMENTS_LIBRARY: i32 = 7i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CAPABILITY_ENTERPRISE_AUTHENTICATION: i32 = 8i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CAPABILITY_INTERNET_CLIENT: i32 = 1i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CAPABILITY_INTERNET_CLIENT_SERVER: i32 = 2i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CAPABILITY_INTERNET_EXPLORER: i32 = 4096i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CAPABILITY_MUSIC_LIBRARY: i32 = 6i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CAPABILITY_PICTURES_LIBRARY: i32 = 4i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CAPABILITY_PRIVATE_NETWORK_CLIENT_SERVER: i32 = 3i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CAPABILITY_REMOVABLE_STORAGE: i32 = 10i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CAPABILITY_RID_COUNT: i32 = 5i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CAPABILITY_SHARED_USER_CERTIFICATES: i32 = 9i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CAPABILITY_VIDEOS_LIBRARY: i32 = 5i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CCG_ID_BASE_RID: i32 = 95i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CHILD_PACKAGE_RID_COUNT: i32 = 12i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_BASE_RID: i32 = 85i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_RID_COUNT: i32 = 6i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_COM_ID_BASE_RID: i32 = 89i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CREATOR_GROUP_RID: i32 = 1i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CREATOR_GROUP_SERVER_RID: i32 = 3i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CREATOR_OWNER_RID: i32 = 0i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CREATOR_OWNER_RIGHTS_RID: i32 = 4i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CREATOR_OWNER_SERVER_RID: i32 = 2i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CRED_TYPE_BASE_RID: i32 = 65i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CRED_TYPE_RID_COUNT: i32 = 2i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_CRED_TYPE_THIS_ORG_CERT_RID: i32 = 1i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_DASHOST_ID_BASE_RID: i32 = 92i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_DASHOST_ID_RID_COUNT: i32 = 6i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_DIALUP_RID: i32 = 1i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_ENTERPRISE_CONTROLLERS_RID: i32 = 9i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_ENTERPRISE_READONLY_CONTROLLERS_RID: i32 = 22i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_INSTALLER_CAPABILITY_RID_COUNT: u32 = 10u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_INSTALLER_GROUP_CAPABILITY_BASE: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_INSTALLER_GROUP_CAPABILITY_RID_COUNT: u32 = 9u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_INTERACTIVE_RID: i32 = 4i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_IUSER_RID: i32 = 17i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_LOCAL_ACCOUNT_AND_ADMIN_RID: i32 = 114i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_LOCAL_ACCOUNT_RID: i32 = 113i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_LOCAL_LOGON_RID: i32 = 1i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_LOCAL_RID: i32 = 0i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_LOCAL_SERVICE_RID: i32 = 19i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_LOCAL_SYSTEM_RID: i32 = 18i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_LOGON_IDS_RID: i32 = 5i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_LOGON_IDS_RID_COUNT: i32 = 3i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_MANDATORY_HIGH_RID: i32 = 12288i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_MANDATORY_LOW_RID: i32 = 4096i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_MANDATORY_MAXIMUM_USER_RID: i32 = 16384i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_MANDATORY_MEDIUM_PLUS_RID: u32 = 8448u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_MANDATORY_MEDIUM_RID: i32 = 8192i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_MANDATORY_PROTECTED_PROCESS_RID: i32 = 20480i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_MANDATORY_SYSTEM_RID: i32 = 16384i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_MANDATORY_UNTRUSTED_RID: i32 = 0i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_MAX_ALWAYS_FILTERED: i32 = 999i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_MAX_BASE_RID: i32 = 111i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_MIN_BASE_RID: i32 = 80i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_MIN_NEVER_FILTERED: i32 = 1000i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_NATIVE_DREP: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_NETWORK_DREP: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_NETWORK_RID: i32 = 2i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_NETWORK_SERVICE_RID: i32 = 20i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_NFS_ID_BASE_RID: i32 = 88i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_NT_NON_UNIQUE: i32 = 21i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT: i32 = 3i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_NULL_RID: i32 = 0i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_OTHER_ORGANIZATION_RID: i32 = 1000i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_PACKAGE_BASE_RID: i32 = 64i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_PACKAGE_DIGEST_RID: i32 = 21i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_PACKAGE_NTLM_RID: i32 = 10i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_PACKAGE_RID_COUNT: i32 = 2i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_PACKAGE_SCHANNEL_RID: i32 = 14i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_PARENT_PACKAGE_RID_COUNT: i32 = 8i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_PRINCIPAL_SELF_RID: i32 = 10i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_PROCESS_PROTECTION_LEVEL_ANTIMALWARE_RID: i32 = 1536i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_PROCESS_PROTECTION_LEVEL_APP_RID: i32 = 2048i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_PROCESS_PROTECTION_LEVEL_AUTHENTICODE_RID: i32 = 1024i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_PROCESS_PROTECTION_LEVEL_NONE_RID: i32 = 0i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_PROCESS_PROTECTION_LEVEL_WINDOWS_RID: i32 = 4096i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_PROCESS_PROTECTION_LEVEL_WINTCB_RID: i32 = 8192i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_PROCESS_PROTECTION_TYPE_FULL_RID: i32 = 1024i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_PROCESS_PROTECTION_TYPE_LITE_RID: i32 = 512i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_PROCESS_PROTECTION_TYPE_NONE_RID: i32 = 0i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_PROCESS_TRUST_AUTHORITY_RID_COUNT: i32 = 2i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_PROXY_RID: i32 = 8i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_RDV_GFX_BASE_RID: i32 = 91i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_REMOTE_LOGON_RID: i32 = 14i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_RESERVED_ID_BASE_RID: i32 = 81i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_RESTRICTED_CODE_RID: i32 = 12i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_SERVER_LOGON_RID: i32 = 9i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_SERVICE_ID_BASE_RID: i32 = 80i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_SERVICE_ID_RID_COUNT: i32 = 6i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_SERVICE_RID: i32 = 6i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_2: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_3: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_4: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_5: u32 = 5u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_TASK_ID_BASE_RID: i32 = 87i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_TERMINAL_SERVER_RID: i32 = 13i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_THIS_ORGANIZATION_RID: i32 = 15i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_TRUSTED_INSTALLER_RID1: u32 = 956008885u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_TRUSTED_INSTALLER_RID2: u32 = 3418522649u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_TRUSTED_INSTALLER_RID3: u32 = 1831038044u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_TRUSTED_INSTALLER_RID4: u32 = 1853292631u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_TRUSTED_INSTALLER_RID5: u32 = 2271478464u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_UMFD_BASE_RID: i32 = 96i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_USERMANAGER_ID_BASE_RID: i32 = 93i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_USERMANAGER_ID_RID_COUNT: i32 = 6i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_USERMODEDRIVERHOST_ID_BASE_RID: i32 = 84i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_USERMODEDRIVERHOST_ID_RID_COUNT: i32 = 6i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_VIRTUALACCOUNT_ID_RID_COUNT: i32 = 6i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_VIRTUALSERVER_ID_BASE_RID: i32 = 83i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_VIRTUALSERVER_ID_RID_COUNT: i32 = 6i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_WINDOWSMOBILE_ID_BASE_RID: i32 = 112i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_WINDOW_MANAGER_BASE_RID: i32 = 90i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_WINRM_ID_BASE_RID: i32 = 94i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_WINRM_ID_RID_COUNT: i32 = 6i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_WMIHOST_ID_BASE_RID: i32 = 86i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_WMIHOST_ID_RID_COUNT: i32 = 6i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_WORLD_RID: i32 = 0i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SECURITY_WRITE_RESTRICTED_CODE_RID: i32 = 33i32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEC_WINNT_AUTH_IDENTITY_ANSI: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEC_WINNT_AUTH_IDENTITY_MARSHALLED: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEC_WINNT_AUTH_IDENTITY_ONLY: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEC_WINNT_AUTH_IDENTITY_UNICODE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEC_WINNT_AUTH_IDENTITY_VERSION: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEC_WINNT_AUTH_IDENTITY_VERSION_2: u32 = 513u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEF_AI_USE_EXTRA_PARAMS: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEF_AVOID_OWNER_CHECK: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEF_AVOID_OWNER_RESTRICTION: u32 = 4096u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEF_AVOID_PRIVILEGE_CHECK: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEF_DACL_AUTO_INHERIT: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEF_DEFAULT_GROUP_FROM_PARENT: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEF_DEFAULT_OWNER_FROM_PARENT: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEF_FORCE_USER_MODE: u32 = 8192u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEF_MACL_NO_EXECUTE_UP: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEF_MACL_NO_READ_UP: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEF_MACL_NO_WRITE_UP: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEF_NORMALIZE_OUTPUT_DESCRIPTOR: u32 = 16384u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEF_SACL_AUTO_INHERIT: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEGMENT_HEAP_FLG_USE_PAGE_HEAP: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEGMENT_HEAP_PARAMETERS_VERSION: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEGMENT_HEAP_PARAMS_VALID_FLAGS: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SEMAPHORE_INCREMENT: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SET_PURGE_FAILURE_MODE_DISABLED: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SET_PURGE_FAILURE_MODE_ENABLED: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SET_REPAIR_DISABLED_AND_BUGCHECK_ON_CORRUPT: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SET_REPAIR_ENABLED: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SET_REPAIR_VALID_MASK: u32 = 25u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SET_REPAIR_WARN_ABOUT_DATA_LOSS: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_ACCESS_CHECK_FLAG_NO_LEARNING_MODE_LOGGING: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_ACCESS_CHECK_VALID_FLAGS: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_ADT_OBJECT_ONLY: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_ADT_PARAMETERS_SELF_RELATIVE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_ADT_PARAMETERS_SEND_TO_LSA: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_ADT_PARAMETER_EXTENSIBLE_AUDIT: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_ADT_PARAMETER_GENERIC_AUDIT: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_ADT_PARAMETER_WRITE_SYNCHRONOUS: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_BACKUP_PRIVILEGES_CHECKED: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_DACL_AUTO_INHERITED: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_DACL_AUTO_INHERIT_REQ: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_DACL_DEFAULTED: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_DACL_PRESENT: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_DACL_PROTECTED: u32 = 4096u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_DACL_UNTRUSTED: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_GROUP_DEFAULTED: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_MAX_AUDIT_PARAMETERS: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_MAX_GENERIC_AUDIT_PARAMETERS: u32 = 28u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_OWNER_DEFAULTED: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_RM_CONTROL_VALID: u32 = 16384u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_SACL_AUTO_INHERITED: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_SACL_AUTO_INHERIT_REQ: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_SACL_DEFAULTED: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_SACL_PRESENT: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_SACL_PROTECTED: u32 = 8192u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_ACCESS_FILTER_ACE: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_LABEL_ACE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_OWNER_ACE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_SECURITY_DESCRIPTOR_VALID_FLAGS: u32 = 7u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_SELF_RELATIVE: u32 = 32768u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SE_SERVER_SECURITY: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SHUFFLE_FILE_FLAG_SKIP_INITIALIZING_NEW_CLUSTERS: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SID_HASH_SIZE: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SID_MAX_SUB_AUTHORITIES: u32 = 15u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SID_RECOMMENDED_SUB_AUTHORITIES: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SID_REVISION: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SMB_CCF_APP_INSTANCE_EA_NAME: ::windows_core::PCSTR = ::windows_core::s!("ClusteredApplicationInstance");
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SPACES_TRACKED_OFFSET_HEADER_FLAG: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SPECIAL_ENCRYPTED_OPEN: u32 = 262144u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SRV_OPEN_ECP_CONTEXT_VERSION_2: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const STREAMS_ASSOCIATE_ID_CLEAR: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const STREAMS_ASSOCIATE_ID_SET: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const STREAMS_INVALID_ID: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const STREAM_CLEAR_ENCRYPTION: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const STREAM_EXTENT_ENTRY_ALL_EXTENTS: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const STREAM_EXTENT_ENTRY_AS_RETRIEVAL_POINTERS: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const STREAM_LAYOUT_ENTRY_HAS_INFORMATION: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const STREAM_LAYOUT_ENTRY_IMMOVABLE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const STREAM_LAYOUT_ENTRY_NO_CLUSTERS_ALLOCATED: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const STREAM_LAYOUT_ENTRY_PINNED: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const STREAM_LAYOUT_ENTRY_RESIDENT: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const STREAM_SET_ENCRYPTION: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SUCCESSFUL_ACCESS_ACE_FLAG: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SUPPORTED_FS_FEATURES_BYPASS_IO: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SUPPORTED_FS_FEATURES_OFFLOAD_READ: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SUPPORTED_FS_FEATURES_OFFLOAD_WRITE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SUPPORTED_FS_FEATURES_QUERY_OPEN: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYMLINK_DIRECTORY: u32 = 2147483648u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYMLINK_FILE: u32 = 1073741824u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYMLINK_FLAG_RELATIVE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYMLINK_RESERVED_MASK: u32 = 4026531840u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYSTEM_ACCESS_FILTER_ACE_TYPE: u32 = 21u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYSTEM_ACCESS_FILTER_NOCONSTRAINT_MASK: u32 = 4294967295u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYSTEM_ACCESS_FILTER_VALID_MASK: u32 = 16777215u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYSTEM_ALARM_ACE_TYPE: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYSTEM_ALARM_CALLBACK_ACE_TYPE: u32 = 14u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYSTEM_ALARM_OBJECT_ACE_TYPE: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYSTEM_AUDIT_ACE_TYPE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYSTEM_AUDIT_CALLBACK_ACE_TYPE: u32 = 13u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE: u32 = 15u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYSTEM_AUDIT_OBJECT_ACE_TYPE: u32 = 7u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYSTEM_MANDATORY_LABEL_ACE_TYPE: u32 = 17u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYSTEM_MANDATORY_LABEL_NO_READ_UP: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYSTEM_MANDATORY_LABEL_NO_WRITE_UP: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYSTEM_PAGE_PRIORITY_BITS: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYSTEM_PROCESS_TRUST_LABEL_ACE_TYPE: u32 = 20u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYSTEM_PROCESS_TRUST_LABEL_VALID_MASK: u32 = 16777215u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYSTEM_PROCESS_TRUST_NOCONSTRAINT_MASK: u32 = 4294967295u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYSTEM_RESOURCE_ATTRIBUTE_ACE_TYPE: u32 = 18u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SYSTEM_SCOPED_POLICY_ID_ACE_TYPE: u32 = 19u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SZ_ALG_MAX_SIZE: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_ADJUST_DEFAULT: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_ADJUST_GROUPS: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_ADJUST_PRIVILEGES: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_ADJUST_SESSIONID: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_ASSIGN_PRIMARY: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_AUDIT_NO_CHILD_PROCESS: u32 = 2097152u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_AUDIT_REDIRECTION_TRUST: u32 = 8388608u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_DO_NOT_USE_GLOBAL_ATTRIBS_FOR_QUERY: u32 = 131072u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_DUPLICATE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_ENFORCE_REDIRECTION_TRUST: u32 = 4194304u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_HAS_BACKUP_PRIVILEGE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_HAS_IMPERSONATE_PRIVILEGE: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_HAS_OWN_CLAIM_ATTRIBUTES: u32 = 32768u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_HAS_RESTORE_PRIVILEGE: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_HAS_TRAVERSE_PRIVILEGE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_IMPERSONATE: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_IS_FILTERED: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_IS_RESTRICTED: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_LEARNING_MODE_LOGGING: u32 = 16777216u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_LOWBOX: u32 = 16384u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_MANDATORY_POLICY_NO_WRITE_UP: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_MANDATORY_POLICY_OFF: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_NOT_LOW: u32 = 8192u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_NO_CHILD_PROCESS: u32 = 524288u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_NO_CHILD_PROCESS_UNLESS_SECURE: u32 = 1048576u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_PERMISSIVE_LEARNING_MODE: u32 = 50331648u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_PRIVATE_NAMESPACE: u32 = 65536u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_QUERY: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_QUERY_SOURCE: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_SANDBOX_INERT: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_SESSION_NOT_REFERENCED: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_SOURCE_LENGTH: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_UIACCESS: u32 = 4096u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_VIRTUALIZE_ALLOWED: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_VIRTUALIZE_ENABLED: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TOKEN_WRITE_RESTRICTED: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TRUST_PROTECTED_FILTER_ACE_FLAG: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_CREATED: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_DELETED: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_LOGGING_MODE_FULL: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_LOGGING_MODE_SIMPLE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START: u32 = 32768u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_RM_FLAG_ENFORCE_MINIMUM_SIZE: u32 = 4096u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_RM_FLAG_GROW_LOG: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_RM_FLAG_LOGGING_MODE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_RM_FLAG_PREFER_AVAILABILITY: u32 = 131072u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_RM_FLAG_PREFER_CONSISTENCY: u32 = 65536u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_RM_FLAG_PRESERVE_CHANGES: u32 = 8192u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_RM_FLAG_RENAME_RM: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_RM_FLAG_RESET_RM_AT_NEXT_START: u32 = 16384u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_RM_FLAG_SHRINK_LOG: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_RM_STATE_ACTIVE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_RM_STATE_NOT_STARTED: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_RM_STATE_SHUTTING_DOWN: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_RM_STATE_STARTING: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_REDO_LSN: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_VIRTUAL_CLOCK: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_SAVEPOINT_CLEAR: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_SAVEPOINT_CLEAR_ALL: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_SAVEPOINT_ROLLBACK: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_SAVEPOINT_SET: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_START_RM_FLAG_LOGGING_MODE: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_START_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MAX: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MIN: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_START_RM_FLAG_LOG_CONTAINER_SIZE: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN: u32 = 128u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_START_RM_FLAG_PREFER_AVAILABILITY: u32 = 8192u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_START_RM_FLAG_PREFER_CONSISTENCY: u32 = 4096u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_START_RM_FLAG_PRESERVE_CHANGES: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_START_RM_FLAG_RECOVER_BEST_EFFORT: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_TRANSACTED_VERSION_NONTRANSACTED: u32 = 4294967294u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_TRANSACTED_VERSION_UNCOMMITTED: u32 = 4294967295u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_TRANSACTION_STATE_ACTIVE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_TRANSACTION_STATE_NONE: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_TRANSACTION_STATE_NOTACTIVE: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TXFS_TRANSACTION_STATE_PREPARED: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const UNDERSTANDS_LONG_NAMES: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const UNINITIALIZE_CACHE_MAPS: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USE_PRIMARY_PASSWORD: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_DELETE_FLAG_DELETE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_DELETE_FLAG_NOTIFY: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_DELETE_VALID_FLAGS: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_PAGE_SIZE: u32 = 4096u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_BASIC_INFO_CHANGE: u32 = 32768u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_CLOSE: u32 = 2147483648u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_COMPRESSION_CHANGE: u32 = 131072u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_DATA_EXTEND: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_DATA_OVERWRITE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_DATA_TRUNCATION: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_DESIRED_STORAGE_CLASS_CHANGE: u32 = 16777216u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_EA_CHANGE: u32 = 1024u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_ENCRYPTION_CHANGE: u32 = 262144u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_FILE_CREATE: u32 = 256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_FILE_DELETE: u32 = 512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_HARD_LINK_CHANGE: u32 = 65536u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_INDEXABLE_CHANGE: u32 = 16384u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_INTEGRITY_CHANGE: u32 = 8388608u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_NAMED_DATA_EXTEND: u32 = 32u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_NAMED_DATA_OVERWRITE: u32 = 16u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_NAMED_DATA_TRUNCATION: u32 = 64u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_OBJECT_ID_CHANGE: u32 = 524288u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_RENAME_NEW_NAME: u32 = 8192u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_RENAME_OLD_NAME: u32 = 4096u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_REPARSE_POINT_CHANGE: u32 = 1048576u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_SECURITY_CHANGE: u32 = 2048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_STREAM_CHANGE: u32 = 2097152u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_REASON_TRANSACTED_CHANGE: u32 = 4194304u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_SOURCE_AUXILIARY_DATA: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_SOURCE_CLIENT_REPLICATION_MANAGEMENT: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_SOURCE_DATA_MANAGEMENT: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const USN_SOURCE_REPLICATION_MANAGEMENT: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const VACB_MAPPING_GRANULARITY: u32 = 262144u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const VACB_OFFSET_SHIFT: u32 = 18u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const VALID_INHERIT_FLAGS: u32 = 31u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const VOLSNAPCONTROLTYPE: u32 = 83u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const VOLUME_IS_DIRTY: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const VOLUME_SESSION_OPEN: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const VOLUME_UPGRADE_SCHEDULED: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WCIFS_REDIRECTION_FLAGS_CREATE_SERVICED_FROM_LAYER: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WCIFS_REDIRECTION_FLAGS_CREATE_SERVICED_FROM_REGISTERED_LAYER: u32 = 4u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WCIFS_REDIRECTION_FLAGS_CREATE_SERVICED_FROM_REMOTE_LAYER: u32 = 8u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WCIFS_REDIRECTION_FLAGS_CREATE_SERVICED_FROM_SCRATCH: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WIM_BOOT_NOT_OS_WIM: u32 = 0u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WIM_BOOT_OS_WIM: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WIM_PROVIDER_CURRENT_VERSION: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WIM_PROVIDER_EXTERNAL_FLAG_NOT_ACTIVE: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WIM_PROVIDER_EXTERNAL_FLAG_SUSPENDED: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WIM_PROVIDER_HASH_SIZE: u32 = 20u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_CRED_MANAGER: u32 = 4294901760u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_10NET: u32 = 327680u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_3IN1: u32 = 2555904u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_9P: u32 = 4718592u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_9TILES: u32 = 589824u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_APPLETALK: u32 = 1245184u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_AS400: u32 = 720896u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_AURISTOR_FS: u32 = 4587520u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_AVID: u32 = 1703936u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_AVID1: u32 = 3801088u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_BMC: u32 = 1572864u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_BWNFS: u32 = 1048576u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_CLEARCASE: u32 = 1441792u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_COGENT: u32 = 1114112u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_CSC: u32 = 2490368u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_DAV: u32 = 3014656u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_DCE: u32 = 1638400u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_DECORB: u32 = 2097152u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_DFS: u32 = 3866624u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_DISTINCT: u32 = 2293760u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_DOCUSHARE: u32 = 4521984u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_DOCUSPACE: u32 = 1769472u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_DRIVEONWEB: u32 = 4063232u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_EXIFS: u32 = 2949120u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_EXTENDNET: u32 = 2686976u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_FARALLON: u32 = 1179648u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_FJ_REDIR: u32 = 2228224u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_FOXBAT: u32 = 2818048u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_FRONTIER: u32 = 1507328u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_FTP_NFS: u32 = 786432u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_GOOGLE: u32 = 4390912u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_HOB_NFS: u32 = 3276800u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_IBMAL: u32 = 3407872u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_INTERGRAPH: u32 = 1310720u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_KNOWARE: u32 = 3080192u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_KWNP: u32 = 3932160u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_LANMAN: u32 = 131072u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_LANSTEP: u32 = 524288u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_LANTASTIC: u32 = 655360u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_LIFENET: u32 = 917504u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_LOCK: u32 = 3473408u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_LOCUS: u32 = 393216u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_MANGOSOFT: u32 = 1835008u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_MASFAX: u32 = 3211264u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_MFILES: u32 = 4259840u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_MSNET: u32 = 65536u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_MS_NFS: u32 = 4325376u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_NDFS: u32 = 4456448u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_NETWARE: u32 = 196608u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_OBJECT_DIRE: u32 = 3145728u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_OPENAFS: u32 = 3735552u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_PATHWORKS: u32 = 851968u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_POWERLAN: u32 = 983040u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_PROTSTOR: u32 = 2162688u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_QUINCY: u32 = 3670016u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_RDR2SAMPLE: u32 = 2424832u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_RIVERFRONT1: u32 = 1966080u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_RIVERFRONT2: u32 = 2031616u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_RSFX: u32 = 4194304u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_SECUREAGENT: u32 = 4653056u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_SERNET: u32 = 1900544u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_SHIVA: u32 = 3342336u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_SMB: u32 = 131072u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_SRT: u32 = 3604480u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_STAC: u32 = 2752512u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_SUN_PC_NFS: u32 = 458752u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_SYMFONET: u32 = 1376256u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_TERMSRV: u32 = 3538944u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_TWINS: u32 = 2359296u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_VINES: u32 = 262144u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_VMWARE: u32 = 4128768u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_YAHOO: u32 = 2883584u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WNNC_NET_ZENWORKS: u32 = 3997696u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WOF_CURRENT_VERSION: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WOF_PROVIDER_CLOUD: u32 = 3u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WOF_PROVIDER_FILE: u32 = 2u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const WOF_PROVIDER_WIM: u32 = 1u32;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct ACCESS_REASON_TYPE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AccessReasonNone: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AccessReasonAllowedAce: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(65536i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AccessReasonDeniedAce: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(131072i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AccessReasonAllowedParentAce: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(196608i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AccessReasonDeniedParentAce: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(262144i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AccessReasonNotGrantedByCape: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(327680i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AccessReasonNotGrantedByParentCape: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(393216i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AccessReasonNotGrantedToAppContainer: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(458752i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AccessReasonMissingPrivilege: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(1048576i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AccessReasonFromPrivilege: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(2097152i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AccessReasonIntegrityLevel: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(3145728i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AccessReasonOwnership: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(4194304i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AccessReasonNullDacl: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(5242880i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AccessReasonEmptyDacl: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(6291456i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AccessReasonNoSD: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(7340032i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AccessReasonNoGrant: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(8388608i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AccessReasonTrustLabel: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(9437184i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AccessReasonFilterAce: ACCESS_REASON_TYPE = ACCESS_REASON_TYPE(10485760i32);
impl ::core::marker::Copy for ACCESS_REASON_TYPE {}
impl ::core::clone::Clone for ACCESS_REASON_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for ACCESS_REASON_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for ACCESS_REASON_TYPE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for ACCESS_REASON_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ACCESS_REASON_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct AUDIT_EVENT_TYPE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AuditEventObjectAccess: AUDIT_EVENT_TYPE = AUDIT_EVENT_TYPE(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AuditEventDirectoryServiceAccess: AUDIT_EVENT_TYPE = AUDIT_EVENT_TYPE(1i32);
impl ::core::marker::Copy for AUDIT_EVENT_TYPE {}
impl ::core::clone::Clone for AUDIT_EVENT_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for AUDIT_EVENT_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for AUDIT_EVENT_TYPE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for AUDIT_EVENT_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("AUDIT_EVENT_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct CSVFS_DISK_CONNECTIVITY(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvFsDiskConnectivityNone: CSVFS_DISK_CONNECTIVITY = CSVFS_DISK_CONNECTIVITY(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvFsDiskConnectivityMdsNodeOnly: CSVFS_DISK_CONNECTIVITY = CSVFS_DISK_CONNECTIVITY(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvFsDiskConnectivitySubsetOfNodes: CSVFS_DISK_CONNECTIVITY = CSVFS_DISK_CONNECTIVITY(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvFsDiskConnectivityAllNodes: CSVFS_DISK_CONNECTIVITY = CSVFS_DISK_CONNECTIVITY(3i32);
impl ::core::marker::Copy for CSVFS_DISK_CONNECTIVITY {}
impl ::core::clone::Clone for CSVFS_DISK_CONNECTIVITY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CSVFS_DISK_CONNECTIVITY {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for CSVFS_DISK_CONNECTIVITY {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for CSVFS_DISK_CONNECTIVITY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CSVFS_DISK_CONNECTIVITY").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct CSV_CONTROL_OP(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvControlStartRedirectFile: CSV_CONTROL_OP = CSV_CONTROL_OP(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvControlStopRedirectFile: CSV_CONTROL_OP = CSV_CONTROL_OP(3i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvControlQueryRedirectState: CSV_CONTROL_OP = CSV_CONTROL_OP(4i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvControlQueryFileRevision: CSV_CONTROL_OP = CSV_CONTROL_OP(6i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvControlQueryMdsPath: CSV_CONTROL_OP = CSV_CONTROL_OP(8i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvControlQueryFileRevisionFileId128: CSV_CONTROL_OP = CSV_CONTROL_OP(9i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvControlQueryVolumeRedirectState: CSV_CONTROL_OP = CSV_CONTROL_OP(10i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvControlEnableUSNRangeModificationTracking: CSV_CONTROL_OP = CSV_CONTROL_OP(13i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvControlMarkHandleLocalVolumeMount: CSV_CONTROL_OP = CSV_CONTROL_OP(14i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvControlUnmarkHandleLocalVolumeMount: CSV_CONTROL_OP = CSV_CONTROL_OP(15i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvControlGetCsvFsMdsPathV2: CSV_CONTROL_OP = CSV_CONTROL_OP(18i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvControlDisableCaching: CSV_CONTROL_OP = CSV_CONTROL_OP(19i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvControlEnableCaching: CSV_CONTROL_OP = CSV_CONTROL_OP(20i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvControlStartForceDFO: CSV_CONTROL_OP = CSV_CONTROL_OP(21i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvControlStopForceDFO: CSV_CONTROL_OP = CSV_CONTROL_OP(22i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvControlQueryMdsPathNoPause: CSV_CONTROL_OP = CSV_CONTROL_OP(23i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvControlSetVolumeId: CSV_CONTROL_OP = CSV_CONTROL_OP(24i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvControlQueryVolumeId: CSV_CONTROL_OP = CSV_CONTROL_OP(25i32);
impl ::core::marker::Copy for CSV_CONTROL_OP {}
impl ::core::clone::Clone for CSV_CONTROL_OP {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CSV_CONTROL_OP {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for CSV_CONTROL_OP {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for CSV_CONTROL_OP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CSV_CONTROL_OP").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct CSV_DOWN_LEVEL_FILE_TYPE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvDownLevelFileObject: CSV_DOWN_LEVEL_FILE_TYPE = CSV_DOWN_LEVEL_FILE_TYPE(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CsvCsvFsInternalFileObject: CSV_DOWN_LEVEL_FILE_TYPE = CSV_DOWN_LEVEL_FILE_TYPE(1i32);
impl ::core::marker::Copy for CSV_DOWN_LEVEL_FILE_TYPE {}
impl ::core::clone::Clone for CSV_DOWN_LEVEL_FILE_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for CSV_DOWN_LEVEL_FILE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for CSV_DOWN_LEVEL_FILE_TYPE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for CSV_DOWN_LEVEL_FILE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("CSV_DOWN_LEVEL_FILE_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DUPLICATE_EXTENTS_STATE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileSnapStateInactive: DUPLICATE_EXTENTS_STATE = DUPLICATE_EXTENTS_STATE(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileSnapStateSource: DUPLICATE_EXTENTS_STATE = DUPLICATE_EXTENTS_STATE(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileSnapStateTarget: DUPLICATE_EXTENTS_STATE = DUPLICATE_EXTENTS_STATE(2i32);
impl ::core::marker::Copy for DUPLICATE_EXTENTS_STATE {}
impl ::core::clone::Clone for DUPLICATE_EXTENTS_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DUPLICATE_EXTENTS_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for DUPLICATE_EXTENTS_STATE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for DUPLICATE_EXTENTS_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DUPLICATE_EXTENTS_STATE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct FAST_IO_POSSIBLE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FastIoIsNotPossible: FAST_IO_POSSIBLE = FAST_IO_POSSIBLE(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FastIoIsPossible: FAST_IO_POSSIBLE = FAST_IO_POSSIBLE(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FastIoIsQuestionable: FAST_IO_POSSIBLE = FAST_IO_POSSIBLE(2i32);
impl ::core::marker::Copy for FAST_IO_POSSIBLE {}
impl ::core::clone::Clone for FAST_IO_POSSIBLE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FAST_IO_POSSIBLE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for FAST_IO_POSSIBLE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for FAST_IO_POSSIBLE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FAST_IO_POSSIBLE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct FILE_DISPOSITION_INFORMATION_EX_FLAGS(pub u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DISPOSITION_DO_NOT_DELETE: FILE_DISPOSITION_INFORMATION_EX_FLAGS = FILE_DISPOSITION_INFORMATION_EX_FLAGS(0u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DISPOSITION_DELETE: FILE_DISPOSITION_INFORMATION_EX_FLAGS = FILE_DISPOSITION_INFORMATION_EX_FLAGS(1u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DISPOSITION_POSIX_SEMANTICS: FILE_DISPOSITION_INFORMATION_EX_FLAGS = FILE_DISPOSITION_INFORMATION_EX_FLAGS(2u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DISPOSITION_FORCE_IMAGE_SECTION_CHECK: FILE_DISPOSITION_INFORMATION_EX_FLAGS = FILE_DISPOSITION_INFORMATION_EX_FLAGS(4u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DISPOSITION_ON_CLOSE: FILE_DISPOSITION_INFORMATION_EX_FLAGS = FILE_DISPOSITION_INFORMATION_EX_FLAGS(8u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DISPOSITION_IGNORE_READONLY_ATTRIBUTE: FILE_DISPOSITION_INFORMATION_EX_FLAGS = FILE_DISPOSITION_INFORMATION_EX_FLAGS(16u32);
impl ::core::marker::Copy for FILE_DISPOSITION_INFORMATION_EX_FLAGS {}
impl ::core::clone::Clone for FILE_DISPOSITION_INFORMATION_EX_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FILE_DISPOSITION_INFORMATION_EX_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for FILE_DISPOSITION_INFORMATION_EX_FLAGS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for FILE_DISPOSITION_INFORMATION_EX_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FILE_DISPOSITION_INFORMATION_EX_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct FILE_KNOWN_FOLDER_TYPE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const KnownFolderNone: FILE_KNOWN_FOLDER_TYPE = FILE_KNOWN_FOLDER_TYPE(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const KnownFolderDesktop: FILE_KNOWN_FOLDER_TYPE = FILE_KNOWN_FOLDER_TYPE(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const KnownFolderDocuments: FILE_KNOWN_FOLDER_TYPE = FILE_KNOWN_FOLDER_TYPE(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const KnownFolderDownloads: FILE_KNOWN_FOLDER_TYPE = FILE_KNOWN_FOLDER_TYPE(3i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const KnownFolderMusic: FILE_KNOWN_FOLDER_TYPE = FILE_KNOWN_FOLDER_TYPE(4i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const KnownFolderPictures: FILE_KNOWN_FOLDER_TYPE = FILE_KNOWN_FOLDER_TYPE(5i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const KnownFolderVideos: FILE_KNOWN_FOLDER_TYPE = FILE_KNOWN_FOLDER_TYPE(6i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const KnownFolderOther: FILE_KNOWN_FOLDER_TYPE = FILE_KNOWN_FOLDER_TYPE(7i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const KnownFolderMax: FILE_KNOWN_FOLDER_TYPE = FILE_KNOWN_FOLDER_TYPE(7i32);
impl ::core::marker::Copy for FILE_KNOWN_FOLDER_TYPE {}
impl ::core::clone::Clone for FILE_KNOWN_FOLDER_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FILE_KNOWN_FOLDER_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for FILE_KNOWN_FOLDER_TYPE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for FILE_KNOWN_FOLDER_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FILE_KNOWN_FOLDER_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct FILE_STORAGE_TIER_CLASS(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileStorageTierClassUnspecified: FILE_STORAGE_TIER_CLASS = FILE_STORAGE_TIER_CLASS(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileStorageTierClassCapacity: FILE_STORAGE_TIER_CLASS = FILE_STORAGE_TIER_CLASS(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileStorageTierClassPerformance: FILE_STORAGE_TIER_CLASS = FILE_STORAGE_TIER_CLASS(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileStorageTierClassMax: FILE_STORAGE_TIER_CLASS = FILE_STORAGE_TIER_CLASS(3i32);
impl ::core::marker::Copy for FILE_STORAGE_TIER_CLASS {}
impl ::core::clone::Clone for FILE_STORAGE_TIER_CLASS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FILE_STORAGE_TIER_CLASS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for FILE_STORAGE_TIER_CLASS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for FILE_STORAGE_TIER_CLASS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FILE_STORAGE_TIER_CLASS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct FILE_STORAGE_TIER_MEDIA_TYPE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileStorageTierMediaTypeUnspecified: FILE_STORAGE_TIER_MEDIA_TYPE = FILE_STORAGE_TIER_MEDIA_TYPE(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileStorageTierMediaTypeDisk: FILE_STORAGE_TIER_MEDIA_TYPE = FILE_STORAGE_TIER_MEDIA_TYPE(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileStorageTierMediaTypeSsd: FILE_STORAGE_TIER_MEDIA_TYPE = FILE_STORAGE_TIER_MEDIA_TYPE(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileStorageTierMediaTypeScm: FILE_STORAGE_TIER_MEDIA_TYPE = FILE_STORAGE_TIER_MEDIA_TYPE(4i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileStorageTierMediaTypeMax: FILE_STORAGE_TIER_MEDIA_TYPE = FILE_STORAGE_TIER_MEDIA_TYPE(5i32);
impl ::core::marker::Copy for FILE_STORAGE_TIER_MEDIA_TYPE {}
impl ::core::clone::Clone for FILE_STORAGE_TIER_MEDIA_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FILE_STORAGE_TIER_MEDIA_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for FILE_STORAGE_TIER_MEDIA_TYPE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for FILE_STORAGE_TIER_MEDIA_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FILE_STORAGE_TIER_MEDIA_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct FSRTL_CHANGE_BACKING_TYPE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ChangeDataControlArea: FSRTL_CHANGE_BACKING_TYPE = FSRTL_CHANGE_BACKING_TYPE(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ChangeImageControlArea: FSRTL_CHANGE_BACKING_TYPE = FSRTL_CHANGE_BACKING_TYPE(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ChangeSharedCacheMap: FSRTL_CHANGE_BACKING_TYPE = FSRTL_CHANGE_BACKING_TYPE(2i32);
impl ::core::marker::Copy for FSRTL_CHANGE_BACKING_TYPE {}
impl ::core::clone::Clone for FSRTL_CHANGE_BACKING_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FSRTL_CHANGE_BACKING_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for FSRTL_CHANGE_BACKING_TYPE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for FSRTL_CHANGE_BACKING_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FSRTL_CHANGE_BACKING_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct FSRTL_COMPARISON_RESULT(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LessThan: FSRTL_COMPARISON_RESULT = FSRTL_COMPARISON_RESULT(-1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const EqualTo: FSRTL_COMPARISON_RESULT = FSRTL_COMPARISON_RESULT(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const GreaterThan: FSRTL_COMPARISON_RESULT = FSRTL_COMPARISON_RESULT(1i32);
impl ::core::marker::Copy for FSRTL_COMPARISON_RESULT {}
impl ::core::clone::Clone for FSRTL_COMPARISON_RESULT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FSRTL_COMPARISON_RESULT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for FSRTL_COMPARISON_RESULT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for FSRTL_COMPARISON_RESULT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FSRTL_COMPARISON_RESULT").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct FS_BPIO_INFLAGS(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSBPIO_INFL_None: FS_BPIO_INFLAGS = FS_BPIO_INFLAGS(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSBPIO_INFL_SKIP_STORAGE_STACK_QUERY: FS_BPIO_INFLAGS = FS_BPIO_INFLAGS(1i32);
impl ::core::marker::Copy for FS_BPIO_INFLAGS {}
impl ::core::clone::Clone for FS_BPIO_INFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FS_BPIO_INFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for FS_BPIO_INFLAGS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for FS_BPIO_INFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FS_BPIO_INFLAGS").field(&self.0).finish()
    }
}
impl FS_BPIO_INFLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for FS_BPIO_INFLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for FS_BPIO_INFLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for FS_BPIO_INFLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for FS_BPIO_INFLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for FS_BPIO_INFLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct FS_BPIO_OPERATIONS(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FS_BPIO_OP_ENABLE: FS_BPIO_OPERATIONS = FS_BPIO_OPERATIONS(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FS_BPIO_OP_DISABLE: FS_BPIO_OPERATIONS = FS_BPIO_OPERATIONS(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FS_BPIO_OP_QUERY: FS_BPIO_OPERATIONS = FS_BPIO_OPERATIONS(3i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FS_BPIO_OP_VOLUME_STACK_PAUSE: FS_BPIO_OPERATIONS = FS_BPIO_OPERATIONS(4i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FS_BPIO_OP_VOLUME_STACK_RESUME: FS_BPIO_OPERATIONS = FS_BPIO_OPERATIONS(5i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FS_BPIO_OP_STREAM_PAUSE: FS_BPIO_OPERATIONS = FS_BPIO_OPERATIONS(6i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FS_BPIO_OP_STREAM_RESUME: FS_BPIO_OPERATIONS = FS_BPIO_OPERATIONS(7i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FS_BPIO_OP_GET_INFO: FS_BPIO_OPERATIONS = FS_BPIO_OPERATIONS(8i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FS_BPIO_OP_MAX_OPERATION: FS_BPIO_OPERATIONS = FS_BPIO_OPERATIONS(9i32);
impl ::core::marker::Copy for FS_BPIO_OPERATIONS {}
impl ::core::clone::Clone for FS_BPIO_OPERATIONS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FS_BPIO_OPERATIONS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for FS_BPIO_OPERATIONS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for FS_BPIO_OPERATIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FS_BPIO_OPERATIONS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct FS_BPIO_OUTFLAGS(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSBPIO_OUTFL_None: FS_BPIO_OUTFLAGS = FS_BPIO_OUTFLAGS(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSBPIO_OUTFL_VOLUME_STACK_BYPASS_PAUSED: FS_BPIO_OUTFLAGS = FS_BPIO_OUTFLAGS(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSBPIO_OUTFL_STREAM_BYPASS_PAUSED: FS_BPIO_OUTFLAGS = FS_BPIO_OUTFLAGS(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSBPIO_OUTFL_FILTER_ATTACH_BLOCKED: FS_BPIO_OUTFLAGS = FS_BPIO_OUTFLAGS(4i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FSBPIO_OUTFL_COMPATIBLE_STORAGE_DRIVER: FS_BPIO_OUTFLAGS = FS_BPIO_OUTFLAGS(8i32);
impl ::core::marker::Copy for FS_BPIO_OUTFLAGS {}
impl ::core::clone::Clone for FS_BPIO_OUTFLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FS_BPIO_OUTFLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for FS_BPIO_OUTFLAGS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for FS_BPIO_OUTFLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FS_BPIO_OUTFLAGS").field(&self.0).finish()
    }
}
impl FS_BPIO_OUTFLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for FS_BPIO_OUTFLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for FS_BPIO_OUTFLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for FS_BPIO_OUTFLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for FS_BPIO_OUTFLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for FS_BPIO_OUTFLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct FS_FILTER_SECTION_SYNC_TYPE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SyncTypeOther: FS_FILTER_SECTION_SYNC_TYPE = FS_FILTER_SECTION_SYNC_TYPE(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SyncTypeCreateSection: FS_FILTER_SECTION_SYNC_TYPE = FS_FILTER_SECTION_SYNC_TYPE(1i32);
impl ::core::marker::Copy for FS_FILTER_SECTION_SYNC_TYPE {}
impl ::core::clone::Clone for FS_FILTER_SECTION_SYNC_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FS_FILTER_SECTION_SYNC_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for FS_FILTER_SECTION_SYNC_TYPE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for FS_FILTER_SECTION_SYNC_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FS_FILTER_SECTION_SYNC_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct FS_FILTER_STREAM_FO_NOTIFICATION_TYPE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NotifyTypeCreate: FS_FILTER_STREAM_FO_NOTIFICATION_TYPE = FS_FILTER_STREAM_FO_NOTIFICATION_TYPE(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NotifyTypeRetired: FS_FILTER_STREAM_FO_NOTIFICATION_TYPE = FS_FILTER_STREAM_FO_NOTIFICATION_TYPE(1i32);
impl ::core::marker::Copy for FS_FILTER_STREAM_FO_NOTIFICATION_TYPE {}
impl ::core::clone::Clone for FS_FILTER_STREAM_FO_NOTIFICATION_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FS_FILTER_STREAM_FO_NOTIFICATION_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for FS_FILTER_STREAM_FO_NOTIFICATION_TYPE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for FS_FILTER_STREAM_FO_NOTIFICATION_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FS_FILTER_STREAM_FO_NOTIFICATION_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct FS_INFORMATION_CLASS(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileFsVolumeInformation: FS_INFORMATION_CLASS = FS_INFORMATION_CLASS(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileFsLabelInformation: FS_INFORMATION_CLASS = FS_INFORMATION_CLASS(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileFsSizeInformation: FS_INFORMATION_CLASS = FS_INFORMATION_CLASS(3i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileFsDeviceInformation: FS_INFORMATION_CLASS = FS_INFORMATION_CLASS(4i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileFsAttributeInformation: FS_INFORMATION_CLASS = FS_INFORMATION_CLASS(5i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileFsControlInformation: FS_INFORMATION_CLASS = FS_INFORMATION_CLASS(6i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileFsFullSizeInformation: FS_INFORMATION_CLASS = FS_INFORMATION_CLASS(7i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileFsObjectIdInformation: FS_INFORMATION_CLASS = FS_INFORMATION_CLASS(8i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileFsDriverPathInformation: FS_INFORMATION_CLASS = FS_INFORMATION_CLASS(9i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileFsVolumeFlagsInformation: FS_INFORMATION_CLASS = FS_INFORMATION_CLASS(10i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileFsSectorSizeInformation: FS_INFORMATION_CLASS = FS_INFORMATION_CLASS(11i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileFsDataCopyInformation: FS_INFORMATION_CLASS = FS_INFORMATION_CLASS(12i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileFsMetadataSizeInformation: FS_INFORMATION_CLASS = FS_INFORMATION_CLASS(13i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileFsFullSizeInformationEx: FS_INFORMATION_CLASS = FS_INFORMATION_CLASS(14i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FileFsMaximumInformation: FS_INFORMATION_CLASS = FS_INFORMATION_CLASS(15i32);
impl ::core::marker::Copy for FS_INFORMATION_CLASS {}
impl ::core::clone::Clone for FS_INFORMATION_CLASS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for FS_INFORMATION_CLASS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for FS_INFORMATION_CLASS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for FS_INFORMATION_CLASS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("FS_INFORMATION_CLASS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct HEAP_MEMORY_INFO_CLASS(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const HeapMemoryBasicInformation: HEAP_MEMORY_INFO_CLASS = HEAP_MEMORY_INFO_CLASS(0i32);
impl ::core::marker::Copy for HEAP_MEMORY_INFO_CLASS {}
impl ::core::clone::Clone for HEAP_MEMORY_INFO_CLASS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for HEAP_MEMORY_INFO_CLASS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for HEAP_MEMORY_INFO_CLASS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for HEAP_MEMORY_INFO_CLASS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("HEAP_MEMORY_INFO_CLASS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct LINK_TRACKING_INFORMATION_TYPE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NtfsLinkTrackingInformation: LINK_TRACKING_INFORMATION_TYPE = LINK_TRACKING_INFORMATION_TYPE(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DfsLinkTrackingInformation: LINK_TRACKING_INFORMATION_TYPE = LINK_TRACKING_INFORMATION_TYPE(1i32);
impl ::core::marker::Copy for LINK_TRACKING_INFORMATION_TYPE {}
impl ::core::clone::Clone for LINK_TRACKING_INFORMATION_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for LINK_TRACKING_INFORMATION_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for LINK_TRACKING_INFORMATION_TYPE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for LINK_TRACKING_INFORMATION_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("LINK_TRACKING_INFORMATION_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct LMR_QUERY_INFO_CLASS(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LMRQuerySessionInfo: LMR_QUERY_INFO_CLASS = LMR_QUERY_INFO_CLASS(1i32);
impl ::core::marker::Copy for LMR_QUERY_INFO_CLASS {}
impl ::core::clone::Clone for LMR_QUERY_INFO_CLASS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for LMR_QUERY_INFO_CLASS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for LMR_QUERY_INFO_CLASS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for LMR_QUERY_INFO_CLASS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("LMR_QUERY_INFO_CLASS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MANDATORY_LEVEL(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MandatoryLevelUntrusted: MANDATORY_LEVEL = MANDATORY_LEVEL(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MandatoryLevelLow: MANDATORY_LEVEL = MANDATORY_LEVEL(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MandatoryLevelMedium: MANDATORY_LEVEL = MANDATORY_LEVEL(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MandatoryLevelHigh: MANDATORY_LEVEL = MANDATORY_LEVEL(3i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MandatoryLevelSystem: MANDATORY_LEVEL = MANDATORY_LEVEL(4i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MandatoryLevelSecureProcess: MANDATORY_LEVEL = MANDATORY_LEVEL(5i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MandatoryLevelCount: MANDATORY_LEVEL = MANDATORY_LEVEL(6i32);
impl ::core::marker::Copy for MANDATORY_LEVEL {}
impl ::core::clone::Clone for MANDATORY_LEVEL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MANDATORY_LEVEL {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for MANDATORY_LEVEL {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for MANDATORY_LEVEL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MANDATORY_LEVEL").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MEMORY_INFORMATION_CLASS(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MemoryBasicInformation: MEMORY_INFORMATION_CLASS = MEMORY_INFORMATION_CLASS(0i32);
impl ::core::marker::Copy for MEMORY_INFORMATION_CLASS {}
impl ::core::clone::Clone for MEMORY_INFORMATION_CLASS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MEMORY_INFORMATION_CLASS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for MEMORY_INFORMATION_CLASS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for MEMORY_INFORMATION_CLASS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MEMORY_INFORMATION_CLASS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MMFLUSH_TYPE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MmFlushForDelete: MMFLUSH_TYPE = MMFLUSH_TYPE(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MmFlushForWrite: MMFLUSH_TYPE = MMFLUSH_TYPE(1i32);
impl ::core::marker::Copy for MMFLUSH_TYPE {}
impl ::core::clone::Clone for MMFLUSH_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MMFLUSH_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for MMFLUSH_TYPE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for MMFLUSH_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MMFLUSH_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MSV1_0_AVID(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsvAvEOL: MSV1_0_AVID = MSV1_0_AVID(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsvAvNbComputerName: MSV1_0_AVID = MSV1_0_AVID(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsvAvNbDomainName: MSV1_0_AVID = MSV1_0_AVID(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsvAvDnsComputerName: MSV1_0_AVID = MSV1_0_AVID(3i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsvAvDnsDomainName: MSV1_0_AVID = MSV1_0_AVID(4i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsvAvDnsTreeName: MSV1_0_AVID = MSV1_0_AVID(5i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsvAvFlags: MSV1_0_AVID = MSV1_0_AVID(6i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsvAvTimestamp: MSV1_0_AVID = MSV1_0_AVID(7i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsvAvRestrictions: MSV1_0_AVID = MSV1_0_AVID(8i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsvAvTargetName: MSV1_0_AVID = MSV1_0_AVID(9i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsvAvChannelBindings: MSV1_0_AVID = MSV1_0_AVID(10i32);
impl ::core::marker::Copy for MSV1_0_AVID {}
impl ::core::clone::Clone for MSV1_0_AVID {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MSV1_0_AVID {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for MSV1_0_AVID {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for MSV1_0_AVID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MSV1_0_AVID").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MSV1_0_CREDENTIAL_KEY_TYPE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const InvalidCredKey: MSV1_0_CREDENTIAL_KEY_TYPE = MSV1_0_CREDENTIAL_KEY_TYPE(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DeprecatedIUMCredKey: MSV1_0_CREDENTIAL_KEY_TYPE = MSV1_0_CREDENTIAL_KEY_TYPE(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const DomainUserCredKey: MSV1_0_CREDENTIAL_KEY_TYPE = MSV1_0_CREDENTIAL_KEY_TYPE(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LocalUserCredKey: MSV1_0_CREDENTIAL_KEY_TYPE = MSV1_0_CREDENTIAL_KEY_TYPE(3i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ExternallySuppliedCredKey: MSV1_0_CREDENTIAL_KEY_TYPE = MSV1_0_CREDENTIAL_KEY_TYPE(4i32);
impl ::core::marker::Copy for MSV1_0_CREDENTIAL_KEY_TYPE {}
impl ::core::clone::Clone for MSV1_0_CREDENTIAL_KEY_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MSV1_0_CREDENTIAL_KEY_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for MSV1_0_CREDENTIAL_KEY_TYPE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for MSV1_0_CREDENTIAL_KEY_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MSV1_0_CREDENTIAL_KEY_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MSV1_0_LOGON_SUBMIT_TYPE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0InteractiveLogon: MSV1_0_LOGON_SUBMIT_TYPE = MSV1_0_LOGON_SUBMIT_TYPE(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0Lm20Logon: MSV1_0_LOGON_SUBMIT_TYPE = MSV1_0_LOGON_SUBMIT_TYPE(3i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0NetworkLogon: MSV1_0_LOGON_SUBMIT_TYPE = MSV1_0_LOGON_SUBMIT_TYPE(4i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0SubAuthLogon: MSV1_0_LOGON_SUBMIT_TYPE = MSV1_0_LOGON_SUBMIT_TYPE(5i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0WorkstationUnlockLogon: MSV1_0_LOGON_SUBMIT_TYPE = MSV1_0_LOGON_SUBMIT_TYPE(7i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0S4ULogon: MSV1_0_LOGON_SUBMIT_TYPE = MSV1_0_LOGON_SUBMIT_TYPE(12i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0VirtualLogon: MSV1_0_LOGON_SUBMIT_TYPE = MSV1_0_LOGON_SUBMIT_TYPE(82i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0NoElevationLogon: MSV1_0_LOGON_SUBMIT_TYPE = MSV1_0_LOGON_SUBMIT_TYPE(83i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0LuidLogon: MSV1_0_LOGON_SUBMIT_TYPE = MSV1_0_LOGON_SUBMIT_TYPE(84i32);
impl ::core::marker::Copy for MSV1_0_LOGON_SUBMIT_TYPE {}
impl ::core::clone::Clone for MSV1_0_LOGON_SUBMIT_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MSV1_0_LOGON_SUBMIT_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for MSV1_0_LOGON_SUBMIT_TYPE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for MSV1_0_LOGON_SUBMIT_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MSV1_0_LOGON_SUBMIT_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MSV1_0_PROFILE_BUFFER_TYPE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0InteractiveProfile: MSV1_0_PROFILE_BUFFER_TYPE = MSV1_0_PROFILE_BUFFER_TYPE(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0Lm20LogonProfile: MSV1_0_PROFILE_BUFFER_TYPE = MSV1_0_PROFILE_BUFFER_TYPE(3i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0SmartCardProfile: MSV1_0_PROFILE_BUFFER_TYPE = MSV1_0_PROFILE_BUFFER_TYPE(4i32);
impl ::core::marker::Copy for MSV1_0_PROFILE_BUFFER_TYPE {}
impl ::core::clone::Clone for MSV1_0_PROFILE_BUFFER_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MSV1_0_PROFILE_BUFFER_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for MSV1_0_PROFILE_BUFFER_TYPE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for MSV1_0_PROFILE_BUFFER_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MSV1_0_PROFILE_BUFFER_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct MSV1_0_PROTOCOL_MESSAGE_TYPE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0Lm20ChallengeRequest: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0Lm20GetChallengeResponse: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0EnumerateUsers: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0GetUserInfo: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(3i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0ReLogonUsers: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(4i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0ChangePassword: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(5i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0ChangeCachedPassword: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(6i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0GenericPassthrough: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(7i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0CacheLogon: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(8i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0SubAuth: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(9i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0DeriveCredential: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(10i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0CacheLookup: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(11i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0SetProcessOption: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(12i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0ConfigLocalAliases: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(13i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0ClearCachedCredentials: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(14i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0LookupToken: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(15i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0ValidateAuth: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(16i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0CacheLookupEx: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(17i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0GetCredentialKey: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(18i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0SetThreadOption: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(19i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0DecryptDpapiMasterKey: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(20i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0GetStrongCredentialKey: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(21i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0TransferCred: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(22i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0ProvisionTbal: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(23i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MsV1_0DeleteTbalSecrets: MSV1_0_PROTOCOL_MESSAGE_TYPE = MSV1_0_PROTOCOL_MESSAGE_TYPE(24i32);
impl ::core::marker::Copy for MSV1_0_PROTOCOL_MESSAGE_TYPE {}
impl ::core::clone::Clone for MSV1_0_PROTOCOL_MESSAGE_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for MSV1_0_PROTOCOL_MESSAGE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for MSV1_0_PROTOCOL_MESSAGE_TYPE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for MSV1_0_PROTOCOL_MESSAGE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("MSV1_0_PROTOCOL_MESSAGE_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct NETWORK_OPEN_INTEGRITY_QUALIFIER(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NetworkOpenIntegrityAny: NETWORK_OPEN_INTEGRITY_QUALIFIER = NETWORK_OPEN_INTEGRITY_QUALIFIER(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NetworkOpenIntegrityNone: NETWORK_OPEN_INTEGRITY_QUALIFIER = NETWORK_OPEN_INTEGRITY_QUALIFIER(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NetworkOpenIntegritySigned: NETWORK_OPEN_INTEGRITY_QUALIFIER = NETWORK_OPEN_INTEGRITY_QUALIFIER(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NetworkOpenIntegrityEncrypted: NETWORK_OPEN_INTEGRITY_QUALIFIER = NETWORK_OPEN_INTEGRITY_QUALIFIER(3i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NetworkOpenIntegrityMaximum: NETWORK_OPEN_INTEGRITY_QUALIFIER = NETWORK_OPEN_INTEGRITY_QUALIFIER(4i32);
impl ::core::marker::Copy for NETWORK_OPEN_INTEGRITY_QUALIFIER {}
impl ::core::clone::Clone for NETWORK_OPEN_INTEGRITY_QUALIFIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for NETWORK_OPEN_INTEGRITY_QUALIFIER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for NETWORK_OPEN_INTEGRITY_QUALIFIER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for NETWORK_OPEN_INTEGRITY_QUALIFIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("NETWORK_OPEN_INTEGRITY_QUALIFIER").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct NETWORK_OPEN_LOCATION_QUALIFIER(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NetworkOpenLocationAny: NETWORK_OPEN_LOCATION_QUALIFIER = NETWORK_OPEN_LOCATION_QUALIFIER(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NetworkOpenLocationRemote: NETWORK_OPEN_LOCATION_QUALIFIER = NETWORK_OPEN_LOCATION_QUALIFIER(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NetworkOpenLocationLoopback: NETWORK_OPEN_LOCATION_QUALIFIER = NETWORK_OPEN_LOCATION_QUALIFIER(2i32);
impl ::core::marker::Copy for NETWORK_OPEN_LOCATION_QUALIFIER {}
impl ::core::clone::Clone for NETWORK_OPEN_LOCATION_QUALIFIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for NETWORK_OPEN_LOCATION_QUALIFIER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for NETWORK_OPEN_LOCATION_QUALIFIER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for NETWORK_OPEN_LOCATION_QUALIFIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("NETWORK_OPEN_LOCATION_QUALIFIER").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct NTCREATEFILE_CREATE_DISPOSITION(pub u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SUPERSEDE: NTCREATEFILE_CREATE_DISPOSITION = NTCREATEFILE_CREATE_DISPOSITION(0u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_CREATE: NTCREATEFILE_CREATE_DISPOSITION = NTCREATEFILE_CREATE_DISPOSITION(2u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_OPEN: NTCREATEFILE_CREATE_DISPOSITION = NTCREATEFILE_CREATE_DISPOSITION(1u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_OPEN_IF: NTCREATEFILE_CREATE_DISPOSITION = NTCREATEFILE_CREATE_DISPOSITION(3u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_OVERWRITE: NTCREATEFILE_CREATE_DISPOSITION = NTCREATEFILE_CREATE_DISPOSITION(4u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_OVERWRITE_IF: NTCREATEFILE_CREATE_DISPOSITION = NTCREATEFILE_CREATE_DISPOSITION(5u32);
impl ::core::marker::Copy for NTCREATEFILE_CREATE_DISPOSITION {}
impl ::core::clone::Clone for NTCREATEFILE_CREATE_DISPOSITION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for NTCREATEFILE_CREATE_DISPOSITION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for NTCREATEFILE_CREATE_DISPOSITION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for NTCREATEFILE_CREATE_DISPOSITION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("NTCREATEFILE_CREATE_DISPOSITION").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct NTCREATEFILE_CREATE_OPTIONS(pub u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DIRECTORY_FILE: NTCREATEFILE_CREATE_OPTIONS = NTCREATEFILE_CREATE_OPTIONS(1u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NON_DIRECTORY_FILE: NTCREATEFILE_CREATE_OPTIONS = NTCREATEFILE_CREATE_OPTIONS(64u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_WRITE_THROUGH: NTCREATEFILE_CREATE_OPTIONS = NTCREATEFILE_CREATE_OPTIONS(2u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SEQUENTIAL_ONLY: NTCREATEFILE_CREATE_OPTIONS = NTCREATEFILE_CREATE_OPTIONS(4u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_RANDOM_ACCESS: NTCREATEFILE_CREATE_OPTIONS = NTCREATEFILE_CREATE_OPTIONS(2048u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NO_INTERMEDIATE_BUFFERING: NTCREATEFILE_CREATE_OPTIONS = NTCREATEFILE_CREATE_OPTIONS(8u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SYNCHRONOUS_IO_ALERT: NTCREATEFILE_CREATE_OPTIONS = NTCREATEFILE_CREATE_OPTIONS(16u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SYNCHRONOUS_IO_NONALERT: NTCREATEFILE_CREATE_OPTIONS = NTCREATEFILE_CREATE_OPTIONS(32u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_CREATE_TREE_CONNECTION: NTCREATEFILE_CREATE_OPTIONS = NTCREATEFILE_CREATE_OPTIONS(128u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NO_EA_KNOWLEDGE: NTCREATEFILE_CREATE_OPTIONS = NTCREATEFILE_CREATE_OPTIONS(512u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_OPEN_REPARSE_POINT: NTCREATEFILE_CREATE_OPTIONS = NTCREATEFILE_CREATE_OPTIONS(2097152u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DELETE_ON_CLOSE: NTCREATEFILE_CREATE_OPTIONS = NTCREATEFILE_CREATE_OPTIONS(4096u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_OPEN_BY_FILE_ID: NTCREATEFILE_CREATE_OPTIONS = NTCREATEFILE_CREATE_OPTIONS(8192u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_OPEN_FOR_BACKUP_INTENT: NTCREATEFILE_CREATE_OPTIONS = NTCREATEFILE_CREATE_OPTIONS(16384u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_RESERVE_OPFILTER: NTCREATEFILE_CREATE_OPTIONS = NTCREATEFILE_CREATE_OPTIONS(1048576u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_OPEN_REQUIRING_OPLOCK: NTCREATEFILE_CREATE_OPTIONS = NTCREATEFILE_CREATE_OPTIONS(65536u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_COMPLETE_IF_OPLOCKED: NTCREATEFILE_CREATE_OPTIONS = NTCREATEFILE_CREATE_OPTIONS(256u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_OPEN_FOR_FREE_SPACE_QUERY: NTCREATEFILE_CREATE_OPTIONS = NTCREATEFILE_CREATE_OPTIONS(8388608u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_CONTAINS_EXTENDED_CREATE_INFORMATION: NTCREATEFILE_CREATE_OPTIONS = NTCREATEFILE_CREATE_OPTIONS(268435456u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_NO_COMPRESSION: NTCREATEFILE_CREATE_OPTIONS = NTCREATEFILE_CREATE_OPTIONS(32768u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_DISALLOW_EXCLUSIVE: NTCREATEFILE_CREATE_OPTIONS = NTCREATEFILE_CREATE_OPTIONS(131072u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_SESSION_AWARE: NTCREATEFILE_CREATE_OPTIONS = NTCREATEFILE_CREATE_OPTIONS(262144u32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const FILE_OPEN_NO_RECALL: NTCREATEFILE_CREATE_OPTIONS = NTCREATEFILE_CREATE_OPTIONS(4194304u32);
impl ::core::marker::Copy for NTCREATEFILE_CREATE_OPTIONS {}
impl ::core::clone::Clone for NTCREATEFILE_CREATE_OPTIONS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for NTCREATEFILE_CREATE_OPTIONS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for NTCREATEFILE_CREATE_OPTIONS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for NTCREATEFILE_CREATE_OPTIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("NTCREATEFILE_CREATE_OPTIONS").field(&self.0).finish()
    }
}
impl NTCREATEFILE_CREATE_OPTIONS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for NTCREATEFILE_CREATE_OPTIONS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for NTCREATEFILE_CREATE_OPTIONS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for NTCREATEFILE_CREATE_OPTIONS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for NTCREATEFILE_CREATE_OPTIONS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for NTCREATEFILE_CREATE_OPTIONS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct OBJECT_INFORMATION_CLASS(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ObjectBasicInformation: OBJECT_INFORMATION_CLASS = OBJECT_INFORMATION_CLASS(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ObjectTypeInformation: OBJECT_INFORMATION_CLASS = OBJECT_INFORMATION_CLASS(2i32);
impl ::core::marker::Copy for OBJECT_INFORMATION_CLASS {}
impl ::core::clone::Clone for OBJECT_INFORMATION_CLASS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for OBJECT_INFORMATION_CLASS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for OBJECT_INFORMATION_CLASS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for OBJECT_INFORMATION_CLASS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OBJECT_INFORMATION_CLASS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct OPLOCK_NOTIFY_REASON(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPLOCK_NOTIFY_BREAK_WAIT_INTERIM_TIMEOUT: OPLOCK_NOTIFY_REASON = OPLOCK_NOTIFY_REASON(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const OPLOCK_NOTIFY_BREAK_WAIT_TERMINATED: OPLOCK_NOTIFY_REASON = OPLOCK_NOTIFY_REASON(1i32);
impl ::core::marker::Copy for OPLOCK_NOTIFY_REASON {}
impl ::core::clone::Clone for OPLOCK_NOTIFY_REASON {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for OPLOCK_NOTIFY_REASON {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for OPLOCK_NOTIFY_REASON {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for OPLOCK_NOTIFY_REASON {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OPLOCK_NOTIFY_REASON").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct QUERY_FILE_LAYOUT_FILTER_TYPE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_FILTER_TYPE_NONE: QUERY_FILE_LAYOUT_FILTER_TYPE = QUERY_FILE_LAYOUT_FILTER_TYPE(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_FILTER_TYPE_CLUSTERS: QUERY_FILE_LAYOUT_FILTER_TYPE = QUERY_FILE_LAYOUT_FILTER_TYPE(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_FILTER_TYPE_FILEID: QUERY_FILE_LAYOUT_FILTER_TYPE = QUERY_FILE_LAYOUT_FILTER_TYPE(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_FILTER_TYPE_STORAGE_RESERVE_ID: QUERY_FILE_LAYOUT_FILTER_TYPE = QUERY_FILE_LAYOUT_FILTER_TYPE(3i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const QUERY_FILE_LAYOUT_NUM_FILTER_TYPES: QUERY_FILE_LAYOUT_FILTER_TYPE = QUERY_FILE_LAYOUT_FILTER_TYPE(4i32);
impl ::core::marker::Copy for QUERY_FILE_LAYOUT_FILTER_TYPE {}
impl ::core::clone::Clone for QUERY_FILE_LAYOUT_FILTER_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for QUERY_FILE_LAYOUT_FILTER_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for QUERY_FILE_LAYOUT_FILTER_TYPE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for QUERY_FILE_LAYOUT_FILTER_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("QUERY_FILE_LAYOUT_FILTER_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct REFS_COMPRESSION_FORMATS(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_COMPRESSION_FORMAT_UNCOMPRESSED: REFS_COMPRESSION_FORMATS = REFS_COMPRESSION_FORMATS(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_COMPRESSION_FORMAT_LZ4: REFS_COMPRESSION_FORMATS = REFS_COMPRESSION_FORMATS(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_COMPRESSION_FORMAT_ZSTD: REFS_COMPRESSION_FORMATS = REFS_COMPRESSION_FORMATS(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_COMPRESSION_FORMAT_MAX: REFS_COMPRESSION_FORMATS = REFS_COMPRESSION_FORMATS(3i32);
impl ::core::marker::Copy for REFS_COMPRESSION_FORMATS {}
impl ::core::clone::Clone for REFS_COMPRESSION_FORMATS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for REFS_COMPRESSION_FORMATS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for REFS_COMPRESSION_FORMATS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for REFS_COMPRESSION_FORMATS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("REFS_COMPRESSION_FORMATS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct REFS_DEALLOCATE_RANGES_ALLOCATOR(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_DEALLOCATE_RANGES_ALLOCATOR_NONE: REFS_DEALLOCATE_RANGES_ALLOCATOR = REFS_DEALLOCATE_RANGES_ALLOCATOR(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_DEALLOCATE_RANGES_ALLOCATOR_SAA: REFS_DEALLOCATE_RANGES_ALLOCATOR = REFS_DEALLOCATE_RANGES_ALLOCATOR(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_DEALLOCATE_RANGES_ALLOCATOR_CAA: REFS_DEALLOCATE_RANGES_ALLOCATOR = REFS_DEALLOCATE_RANGES_ALLOCATOR(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_DEALLOCATE_RANGES_ALLOCATOR_MAA: REFS_DEALLOCATE_RANGES_ALLOCATOR = REFS_DEALLOCATE_RANGES_ALLOCATOR(3i32);
impl ::core::marker::Copy for REFS_DEALLOCATE_RANGES_ALLOCATOR {}
impl ::core::clone::Clone for REFS_DEALLOCATE_RANGES_ALLOCATOR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for REFS_DEALLOCATE_RANGES_ALLOCATOR {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for REFS_DEALLOCATE_RANGES_ALLOCATOR {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for REFS_DEALLOCATE_RANGES_ALLOCATOR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("REFS_DEALLOCATE_RANGES_ALLOCATOR").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct REFS_SET_VOLUME_COMPRESSION_INFO_FLAGS(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_SET_VOLUME_COMPRESSION_INFO_FLAG_COMPRESS_SYNC: REFS_SET_VOLUME_COMPRESSION_INFO_FLAGS = REFS_SET_VOLUME_COMPRESSION_INFO_FLAGS(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_SET_VOLUME_COMPRESSION_INFO_FLAG_MAX: REFS_SET_VOLUME_COMPRESSION_INFO_FLAGS = REFS_SET_VOLUME_COMPRESSION_INFO_FLAGS(1i32);
impl ::core::marker::Copy for REFS_SET_VOLUME_COMPRESSION_INFO_FLAGS {}
impl ::core::clone::Clone for REFS_SET_VOLUME_COMPRESSION_INFO_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for REFS_SET_VOLUME_COMPRESSION_INFO_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for REFS_SET_VOLUME_COMPRESSION_INFO_FLAGS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for REFS_SET_VOLUME_COMPRESSION_INFO_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("REFS_SET_VOLUME_COMPRESSION_INFO_FLAGS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct REFS_SMR_VOLUME_GC_ACTION(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SmrGcActionStart: REFS_SMR_VOLUME_GC_ACTION = REFS_SMR_VOLUME_GC_ACTION(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SmrGcActionStartFullSpeed: REFS_SMR_VOLUME_GC_ACTION = REFS_SMR_VOLUME_GC_ACTION(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SmrGcActionPause: REFS_SMR_VOLUME_GC_ACTION = REFS_SMR_VOLUME_GC_ACTION(3i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SmrGcActionStop: REFS_SMR_VOLUME_GC_ACTION = REFS_SMR_VOLUME_GC_ACTION(4i32);
impl ::core::marker::Copy for REFS_SMR_VOLUME_GC_ACTION {}
impl ::core::clone::Clone for REFS_SMR_VOLUME_GC_ACTION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for REFS_SMR_VOLUME_GC_ACTION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for REFS_SMR_VOLUME_GC_ACTION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for REFS_SMR_VOLUME_GC_ACTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("REFS_SMR_VOLUME_GC_ACTION").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct REFS_SMR_VOLUME_GC_METHOD(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SmrGcMethodCompaction: REFS_SMR_VOLUME_GC_METHOD = REFS_SMR_VOLUME_GC_METHOD(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SmrGcMethodCompression: REFS_SMR_VOLUME_GC_METHOD = REFS_SMR_VOLUME_GC_METHOD(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SmrGcMethodRotation: REFS_SMR_VOLUME_GC_METHOD = REFS_SMR_VOLUME_GC_METHOD(3i32);
impl ::core::marker::Copy for REFS_SMR_VOLUME_GC_METHOD {}
impl ::core::clone::Clone for REFS_SMR_VOLUME_GC_METHOD {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for REFS_SMR_VOLUME_GC_METHOD {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for REFS_SMR_VOLUME_GC_METHOD {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for REFS_SMR_VOLUME_GC_METHOD {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("REFS_SMR_VOLUME_GC_METHOD").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct REFS_SMR_VOLUME_GC_STATE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SmrGcStateInactive: REFS_SMR_VOLUME_GC_STATE = REFS_SMR_VOLUME_GC_STATE(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SmrGcStatePaused: REFS_SMR_VOLUME_GC_STATE = REFS_SMR_VOLUME_GC_STATE(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SmrGcStateActive: REFS_SMR_VOLUME_GC_STATE = REFS_SMR_VOLUME_GC_STATE(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SmrGcStateActiveFullSpeed: REFS_SMR_VOLUME_GC_STATE = REFS_SMR_VOLUME_GC_STATE(3i32);
impl ::core::marker::Copy for REFS_SMR_VOLUME_GC_STATE {}
impl ::core::clone::Clone for REFS_SMR_VOLUME_GC_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for REFS_SMR_VOLUME_GC_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for REFS_SMR_VOLUME_GC_STATE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for REFS_SMR_VOLUME_GC_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("REFS_SMR_VOLUME_GC_STATE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct REFS_STREAM_SNAPSHOT_OPERATION(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_STREAM_SNAPSHOT_OPERATION_INVALID: REFS_STREAM_SNAPSHOT_OPERATION = REFS_STREAM_SNAPSHOT_OPERATION(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_STREAM_SNAPSHOT_OPERATION_CREATE: REFS_STREAM_SNAPSHOT_OPERATION = REFS_STREAM_SNAPSHOT_OPERATION(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_STREAM_SNAPSHOT_OPERATION_LIST: REFS_STREAM_SNAPSHOT_OPERATION = REFS_STREAM_SNAPSHOT_OPERATION(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_STREAM_SNAPSHOT_OPERATION_QUERY_DELTAS: REFS_STREAM_SNAPSHOT_OPERATION = REFS_STREAM_SNAPSHOT_OPERATION(3i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_STREAM_SNAPSHOT_OPERATION_REVERT: REFS_STREAM_SNAPSHOT_OPERATION = REFS_STREAM_SNAPSHOT_OPERATION(4i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_STREAM_SNAPSHOT_OPERATION_SET_SHADOW_BTREE: REFS_STREAM_SNAPSHOT_OPERATION = REFS_STREAM_SNAPSHOT_OPERATION(5i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_STREAM_SNAPSHOT_OPERATION_CLEAR_SHADOW_BTREE: REFS_STREAM_SNAPSHOT_OPERATION = REFS_STREAM_SNAPSHOT_OPERATION(6i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_STREAM_SNAPSHOT_OPERATION_MAX: REFS_STREAM_SNAPSHOT_OPERATION = REFS_STREAM_SNAPSHOT_OPERATION(6i32);
impl ::core::marker::Copy for REFS_STREAM_SNAPSHOT_OPERATION {}
impl ::core::clone::Clone for REFS_STREAM_SNAPSHOT_OPERATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for REFS_STREAM_SNAPSHOT_OPERATION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for REFS_STREAM_SNAPSHOT_OPERATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for REFS_STREAM_SNAPSHOT_OPERATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("REFS_STREAM_SNAPSHOT_OPERATION").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct RTL_MEMORY_TYPE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MemoryTypePaged: RTL_MEMORY_TYPE = RTL_MEMORY_TYPE(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MemoryTypeNonPaged: RTL_MEMORY_TYPE = RTL_MEMORY_TYPE(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MemoryType64KPage: RTL_MEMORY_TYPE = RTL_MEMORY_TYPE(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MemoryTypeLargePage: RTL_MEMORY_TYPE = RTL_MEMORY_TYPE(3i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MemoryTypeHugePage: RTL_MEMORY_TYPE = RTL_MEMORY_TYPE(4i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MemoryTypeCustom: RTL_MEMORY_TYPE = RTL_MEMORY_TYPE(5i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MemoryTypeMax: RTL_MEMORY_TYPE = RTL_MEMORY_TYPE(6i32);
impl ::core::marker::Copy for RTL_MEMORY_TYPE {}
impl ::core::clone::Clone for RTL_MEMORY_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for RTL_MEMORY_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for RTL_MEMORY_TYPE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for RTL_MEMORY_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("RTL_MEMORY_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct SECPKG_CRED_CLASS(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SecPkgCredClass_None: SECPKG_CRED_CLASS = SECPKG_CRED_CLASS(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SecPkgCredClass_Ephemeral: SECPKG_CRED_CLASS = SECPKG_CRED_CLASS(10i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SecPkgCredClass_PersistedGeneric: SECPKG_CRED_CLASS = SECPKG_CRED_CLASS(20i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SecPkgCredClass_PersistedSpecific: SECPKG_CRED_CLASS = SECPKG_CRED_CLASS(30i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SecPkgCredClass_Explicit: SECPKG_CRED_CLASS = SECPKG_CRED_CLASS(40i32);
impl ::core::marker::Copy for SECPKG_CRED_CLASS {}
impl ::core::clone::Clone for SECPKG_CRED_CLASS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SECPKG_CRED_CLASS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for SECPKG_CRED_CLASS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for SECPKG_CRED_CLASS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SECPKG_CRED_CLASS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct SECURITY_LOGON_TYPE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const UndefinedLogonType: SECURITY_LOGON_TYPE = SECURITY_LOGON_TYPE(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const Interactive: SECURITY_LOGON_TYPE = SECURITY_LOGON_TYPE(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const Network: SECURITY_LOGON_TYPE = SECURITY_LOGON_TYPE(3i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const Batch: SECURITY_LOGON_TYPE = SECURITY_LOGON_TYPE(4i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const Service: SECURITY_LOGON_TYPE = SECURITY_LOGON_TYPE(5i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const Proxy: SECURITY_LOGON_TYPE = SECURITY_LOGON_TYPE(6i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const Unlock: SECURITY_LOGON_TYPE = SECURITY_LOGON_TYPE(7i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NetworkCleartext: SECURITY_LOGON_TYPE = SECURITY_LOGON_TYPE(8i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const NewCredentials: SECURITY_LOGON_TYPE = SECURITY_LOGON_TYPE(9i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const RemoteInteractive: SECURITY_LOGON_TYPE = SECURITY_LOGON_TYPE(10i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CachedInteractive: SECURITY_LOGON_TYPE = SECURITY_LOGON_TYPE(11i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CachedRemoteInteractive: SECURITY_LOGON_TYPE = SECURITY_LOGON_TYPE(12i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const CachedUnlock: SECURITY_LOGON_TYPE = SECURITY_LOGON_TYPE(13i32);
impl ::core::marker::Copy for SECURITY_LOGON_TYPE {}
impl ::core::clone::Clone for SECURITY_LOGON_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SECURITY_LOGON_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for SECURITY_LOGON_TYPE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for SECURITY_LOGON_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SECURITY_LOGON_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SecApplicationProtocolNegotiationExt_None: SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT = SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SecApplicationProtocolNegotiationExt_NPN: SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT = SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SecApplicationProtocolNegotiationExt_ALPN: SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT = SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT(2i32);
impl ::core::marker::Copy for SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT {}
impl ::core::clone::Clone for SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct SEC_TRAFFIC_SECRET_TYPE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SecTrafficSecret_None: SEC_TRAFFIC_SECRET_TYPE = SEC_TRAFFIC_SECRET_TYPE(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SecTrafficSecret_Client: SEC_TRAFFIC_SECRET_TYPE = SEC_TRAFFIC_SECRET_TYPE(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SecTrafficSecret_Server: SEC_TRAFFIC_SECRET_TYPE = SEC_TRAFFIC_SECRET_TYPE(2i32);
impl ::core::marker::Copy for SEC_TRAFFIC_SECRET_TYPE {}
impl ::core::clone::Clone for SEC_TRAFFIC_SECRET_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SEC_TRAFFIC_SECRET_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for SEC_TRAFFIC_SECRET_TYPE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for SEC_TRAFFIC_SECRET_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SEC_TRAFFIC_SECRET_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct SE_AUDIT_OPERATION(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AuditPrivilegeObject: SE_AUDIT_OPERATION = SE_AUDIT_OPERATION(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AuditPrivilegeService: SE_AUDIT_OPERATION = SE_AUDIT_OPERATION(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AuditAccessCheck: SE_AUDIT_OPERATION = SE_AUDIT_OPERATION(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AuditOpenObject: SE_AUDIT_OPERATION = SE_AUDIT_OPERATION(3i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AuditOpenObjectWithTransaction: SE_AUDIT_OPERATION = SE_AUDIT_OPERATION(4i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AuditCloseObject: SE_AUDIT_OPERATION = SE_AUDIT_OPERATION(5i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AuditDeleteObject: SE_AUDIT_OPERATION = SE_AUDIT_OPERATION(6i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AuditOpenObjectForDelete: SE_AUDIT_OPERATION = SE_AUDIT_OPERATION(7i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AuditOpenObjectForDeleteWithTransaction: SE_AUDIT_OPERATION = SE_AUDIT_OPERATION(8i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AuditCloseNonObject: SE_AUDIT_OPERATION = SE_AUDIT_OPERATION(9i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AuditOpenNonObject: SE_AUDIT_OPERATION = SE_AUDIT_OPERATION(10i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AuditObjectReference: SE_AUDIT_OPERATION = SE_AUDIT_OPERATION(11i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const AuditHandleCreation: SE_AUDIT_OPERATION = SE_AUDIT_OPERATION(12i32);
impl ::core::marker::Copy for SE_AUDIT_OPERATION {}
impl ::core::clone::Clone for SE_AUDIT_OPERATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SE_AUDIT_OPERATION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for SE_AUDIT_OPERATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for SE_AUDIT_OPERATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SE_AUDIT_OPERATION").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct SHRINK_VOLUME_REQUEST_TYPES(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ShrinkPrepare: SHRINK_VOLUME_REQUEST_TYPES = SHRINK_VOLUME_REQUEST_TYPES(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ShrinkCommit: SHRINK_VOLUME_REQUEST_TYPES = SHRINK_VOLUME_REQUEST_TYPES(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const ShrinkAbort: SHRINK_VOLUME_REQUEST_TYPES = SHRINK_VOLUME_REQUEST_TYPES(3i32);
impl ::core::marker::Copy for SHRINK_VOLUME_REQUEST_TYPES {}
impl ::core::clone::Clone for SHRINK_VOLUME_REQUEST_TYPES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SHRINK_VOLUME_REQUEST_TYPES {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for SHRINK_VOLUME_REQUEST_TYPES {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for SHRINK_VOLUME_REQUEST_TYPES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SHRINK_VOLUME_REQUEST_TYPES").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct SID_NAME_USE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SidTypeUser: SID_NAME_USE = SID_NAME_USE(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SidTypeGroup: SID_NAME_USE = SID_NAME_USE(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SidTypeDomain: SID_NAME_USE = SID_NAME_USE(3i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SidTypeAlias: SID_NAME_USE = SID_NAME_USE(4i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SidTypeWellKnownGroup: SID_NAME_USE = SID_NAME_USE(5i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SidTypeDeletedAccount: SID_NAME_USE = SID_NAME_USE(6i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SidTypeInvalid: SID_NAME_USE = SID_NAME_USE(7i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SidTypeUnknown: SID_NAME_USE = SID_NAME_USE(8i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SidTypeComputer: SID_NAME_USE = SID_NAME_USE(9i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SidTypeLabel: SID_NAME_USE = SID_NAME_USE(10i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SidTypeLogonSession: SID_NAME_USE = SID_NAME_USE(11i32);
impl ::core::marker::Copy for SID_NAME_USE {}
impl ::core::clone::Clone for SID_NAME_USE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SID_NAME_USE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for SID_NAME_USE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for SID_NAME_USE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SID_NAME_USE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct SRV_INSTANCE_TYPE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SrvInstanceTypeUndefined: SRV_INSTANCE_TYPE = SRV_INSTANCE_TYPE(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SrvInstanceTypePrimary: SRV_INSTANCE_TYPE = SRV_INSTANCE_TYPE(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SrvInstanceTypeCsv: SRV_INSTANCE_TYPE = SRV_INSTANCE_TYPE(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SrvInstanceTypeSBL: SRV_INSTANCE_TYPE = SRV_INSTANCE_TYPE(3i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SrvInstanceTypeSR: SRV_INSTANCE_TYPE = SRV_INSTANCE_TYPE(4i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SrvInstanceTypeVSMB: SRV_INSTANCE_TYPE = SRV_INSTANCE_TYPE(5i32);
impl ::core::marker::Copy for SRV_INSTANCE_TYPE {}
impl ::core::clone::Clone for SRV_INSTANCE_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SRV_INSTANCE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for SRV_INSTANCE_TYPE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for SRV_INSTANCE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SRV_INSTANCE_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct STORAGE_RESERVE_ID(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const StorageReserveIdNone: STORAGE_RESERVE_ID = STORAGE_RESERVE_ID(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const StorageReserveIdHard: STORAGE_RESERVE_ID = STORAGE_RESERVE_ID(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const StorageReserveIdSoft: STORAGE_RESERVE_ID = STORAGE_RESERVE_ID(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const StorageReserveIdUpdateScratch: STORAGE_RESERVE_ID = STORAGE_RESERVE_ID(3i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const StorageReserveIdMax: STORAGE_RESERVE_ID = STORAGE_RESERVE_ID(4i32);
impl ::core::marker::Copy for STORAGE_RESERVE_ID {}
impl ::core::clone::Clone for STORAGE_RESERVE_ID {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for STORAGE_RESERVE_ID {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for STORAGE_RESERVE_ID {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for STORAGE_RESERVE_ID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("STORAGE_RESERVE_ID").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct SharedVirtualDiskHandleState(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SharedVirtualDiskHandleStateNone: SharedVirtualDiskHandleState = SharedVirtualDiskHandleState(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SharedVirtualDiskHandleStateFileShared: SharedVirtualDiskHandleState = SharedVirtualDiskHandleState(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SharedVirtualDiskHandleStateHandleShared: SharedVirtualDiskHandleState = SharedVirtualDiskHandleState(3i32);
impl ::core::marker::Copy for SharedVirtualDiskHandleState {}
impl ::core::clone::Clone for SharedVirtualDiskHandleState {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SharedVirtualDiskHandleState {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for SharedVirtualDiskHandleState {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for SharedVirtualDiskHandleState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SharedVirtualDiskHandleState").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct SharedVirtualDiskSupportType(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SharedVirtualDisksUnsupported: SharedVirtualDiskSupportType = SharedVirtualDiskSupportType(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SharedVirtualDisksSupported: SharedVirtualDiskSupportType = SharedVirtualDiskSupportType(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SharedVirtualDiskSnapshotsSupported: SharedVirtualDiskSupportType = SharedVirtualDiskSupportType(3i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const SharedVirtualDiskCDPSnapshotsSupported: SharedVirtualDiskSupportType = SharedVirtualDiskSupportType(7i32);
impl ::core::marker::Copy for SharedVirtualDiskSupportType {}
impl ::core::clone::Clone for SharedVirtualDiskSupportType {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for SharedVirtualDiskSupportType {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for SharedVirtualDiskSupportType {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for SharedVirtualDiskSupportType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("SharedVirtualDiskSupportType").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct TOKEN_ELEVATION_TYPE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenElevationTypeDefault: TOKEN_ELEVATION_TYPE = TOKEN_ELEVATION_TYPE(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenElevationTypeFull: TOKEN_ELEVATION_TYPE = TOKEN_ELEVATION_TYPE(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenElevationTypeLimited: TOKEN_ELEVATION_TYPE = TOKEN_ELEVATION_TYPE(3i32);
impl ::core::marker::Copy for TOKEN_ELEVATION_TYPE {}
impl ::core::clone::Clone for TOKEN_ELEVATION_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for TOKEN_ELEVATION_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for TOKEN_ELEVATION_TYPE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for TOKEN_ELEVATION_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("TOKEN_ELEVATION_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct TOKEN_INFORMATION_CLASS(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenUser: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenGroups: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenPrivileges: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(3i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenOwner: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(4i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenPrimaryGroup: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(5i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenDefaultDacl: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(6i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenSource: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(7i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenType: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(8i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenImpersonationLevel: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(9i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenStatistics: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(10i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenRestrictedSids: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(11i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenSessionId: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(12i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenGroupsAndPrivileges: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(13i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenSessionReference: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(14i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenSandBoxInert: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(15i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenAuditPolicy: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(16i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenOrigin: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(17i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenElevationType: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(18i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenLinkedToken: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(19i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenElevation: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(20i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenHasRestrictions: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(21i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenAccessInformation: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(22i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenVirtualizationAllowed: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(23i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenVirtualizationEnabled: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(24i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenIntegrityLevel: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(25i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenUIAccess: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(26i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenMandatoryPolicy: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(27i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenLogonSid: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(28i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenIsAppContainer: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(29i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenCapabilities: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(30i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenAppContainerSid: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(31i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenAppContainerNumber: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(32i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenUserClaimAttributes: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(33i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenDeviceClaimAttributes: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(34i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenRestrictedUserClaimAttributes: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(35i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenRestrictedDeviceClaimAttributes: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(36i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenDeviceGroups: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(37i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenRestrictedDeviceGroups: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(38i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenSecurityAttributes: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(39i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenIsRestricted: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(40i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenProcessTrustLevel: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(41i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenPrivateNameSpace: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(42i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenSingletonAttributes: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(43i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenBnoIsolation: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(44i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenChildProcessFlags: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(45i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenIsLessPrivilegedAppContainer: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(46i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenIsSandboxed: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(47i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenIsAppSilo: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(48i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const MaxTokenInfoClass: TOKEN_INFORMATION_CLASS = TOKEN_INFORMATION_CLASS(49i32);
impl ::core::marker::Copy for TOKEN_INFORMATION_CLASS {}
impl ::core::clone::Clone for TOKEN_INFORMATION_CLASS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for TOKEN_INFORMATION_CLASS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for TOKEN_INFORMATION_CLASS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for TOKEN_INFORMATION_CLASS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("TOKEN_INFORMATION_CLASS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct TOKEN_TYPE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenPrimary: TOKEN_TYPE = TOKEN_TYPE(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const TokenImpersonation: TOKEN_TYPE = TOKEN_TYPE(2i32);
impl ::core::marker::Copy for TOKEN_TYPE {}
impl ::core::clone::Clone for TOKEN_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for TOKEN_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for TOKEN_TYPE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for TOKEN_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("TOKEN_TYPE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct VIRTUAL_MEMORY_INFORMATION_CLASS(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const VmPrefetchInformation: VIRTUAL_MEMORY_INFORMATION_CLASS = VIRTUAL_MEMORY_INFORMATION_CLASS(0i32);
impl ::core::marker::Copy for VIRTUAL_MEMORY_INFORMATION_CLASS {}
impl ::core::clone::Clone for VIRTUAL_MEMORY_INFORMATION_CLASS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for VIRTUAL_MEMORY_INFORMATION_CLASS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for VIRTUAL_MEMORY_INFORMATION_CLASS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for VIRTUAL_MEMORY_INFORMATION_CLASS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VIRTUAL_MEMORY_INFORMATION_CLASS").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct VIRTUAL_STORAGE_BEHAVIOR_CODE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const VirtualStorageBehaviorUndefined: VIRTUAL_STORAGE_BEHAVIOR_CODE = VIRTUAL_STORAGE_BEHAVIOR_CODE(0i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const VirtualStorageBehaviorCacheWriteThrough: VIRTUAL_STORAGE_BEHAVIOR_CODE = VIRTUAL_STORAGE_BEHAVIOR_CODE(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const VirtualStorageBehaviorCacheWriteBack: VIRTUAL_STORAGE_BEHAVIOR_CODE = VIRTUAL_STORAGE_BEHAVIOR_CODE(2i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const VirtualStorageBehaviorStopIoProcessing: VIRTUAL_STORAGE_BEHAVIOR_CODE = VIRTUAL_STORAGE_BEHAVIOR_CODE(3i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const VirtualStorageBehaviorRestartIoProcessing: VIRTUAL_STORAGE_BEHAVIOR_CODE = VIRTUAL_STORAGE_BEHAVIOR_CODE(4i32);
impl ::core::marker::Copy for VIRTUAL_STORAGE_BEHAVIOR_CODE {}
impl ::core::clone::Clone for VIRTUAL_STORAGE_BEHAVIOR_CODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for VIRTUAL_STORAGE_BEHAVIOR_CODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for VIRTUAL_STORAGE_BEHAVIOR_CODE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for VIRTUAL_STORAGE_BEHAVIOR_CODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("VIRTUAL_STORAGE_BEHAVIOR_CODE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct _LCN_WEAK_REFERENCE_STATE(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LCN_WEAK_REFERENCE_VALID: _LCN_WEAK_REFERENCE_STATE = _LCN_WEAK_REFERENCE_STATE(1i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const LCN_CHECKSUM_VALID: _LCN_WEAK_REFERENCE_STATE = _LCN_WEAK_REFERENCE_STATE(2i32);
impl ::core::marker::Copy for _LCN_WEAK_REFERENCE_STATE {}
impl ::core::clone::Clone for _LCN_WEAK_REFERENCE_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _LCN_WEAK_REFERENCE_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for _LCN_WEAK_REFERENCE_STATE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for _LCN_WEAK_REFERENCE_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_LCN_WEAK_REFERENCE_STATE").field(&self.0).finish()
    }
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct _REFS_STREAM_EXTENT_PROPERTIES(pub i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_STREAM_EXTENT_PROPERTY_VALID: _REFS_STREAM_EXTENT_PROPERTIES = _REFS_STREAM_EXTENT_PROPERTIES(16i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_STREAM_EXTENT_PROPERTY_STREAM_RESERVED: _REFS_STREAM_EXTENT_PROPERTIES = _REFS_STREAM_EXTENT_PROPERTIES(32i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_STREAM_EXTENT_PROPERTY_CRC32: _REFS_STREAM_EXTENT_PROPERTIES = _REFS_STREAM_EXTENT_PROPERTIES(128i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_STREAM_EXTENT_PROPERTY_CRC64: _REFS_STREAM_EXTENT_PROPERTIES = _REFS_STREAM_EXTENT_PROPERTIES(256i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_STREAM_EXTENT_PROPERTY_GHOSTED: _REFS_STREAM_EXTENT_PROPERTIES = _REFS_STREAM_EXTENT_PROPERTIES(512i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_STREAM_EXTENT_PROPERTY_READONLY: _REFS_STREAM_EXTENT_PROPERTIES = _REFS_STREAM_EXTENT_PROPERTIES(1024i32);
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub const REFS_STREAM_EXTENT_PROPERTY_SPARSE: _REFS_STREAM_EXTENT_PROPERTIES = _REFS_STREAM_EXTENT_PROPERTIES(8i32);
impl ::core::marker::Copy for _REFS_STREAM_EXTENT_PROPERTIES {}
impl ::core::clone::Clone for _REFS_STREAM_EXTENT_PROPERTIES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for _REFS_STREAM_EXTENT_PROPERTIES {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows_core::TypeKind for _REFS_STREAM_EXTENT_PROPERTIES {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::fmt::Debug for _REFS_STREAM_EXTENT_PROPERTIES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("_REFS_STREAM_EXTENT_PROPERTIES").field(&self.0).finish()
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct ACCESS_ALLOWED_ACE {
    pub Header: ACE_HEADER,
    pub Mask: u32,
    pub SidStart: u32,
}
impl ::core::marker::Copy for ACCESS_ALLOWED_ACE {}
impl ::core::clone::Clone for ACCESS_ALLOWED_ACE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for ACCESS_ALLOWED_ACE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ACCESS_ALLOWED_ACE").field("Header", &self.Header).field("Mask", &self.Mask).field("SidStart", &self.SidStart).finish()
    }
}
impl ::windows_core::TypeKind for ACCESS_ALLOWED_ACE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for ACCESS_ALLOWED_ACE {
    fn eq(&self, other: &Self) -> bool {
        self.Header == other.Header && self.Mask == other.Mask && self.SidStart == other.SidStart
    }
}
impl ::core::cmp::Eq for ACCESS_ALLOWED_ACE {}
impl ::core::default::Default for ACCESS_ALLOWED_ACE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct ACCESS_DENIED_ACE {
    pub Header: ACE_HEADER,
    pub Mask: u32,
    pub SidStart: u32,
}
impl ::core::marker::Copy for ACCESS_DENIED_ACE {}
impl ::core::clone::Clone for ACCESS_DENIED_ACE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for ACCESS_DENIED_ACE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ACCESS_DENIED_ACE").field("Header", &self.Header).field("Mask", &self.Mask).field("SidStart", &self.SidStart).finish()
    }
}
impl ::windows_core::TypeKind for ACCESS_DENIED_ACE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for ACCESS_DENIED_ACE {
    fn eq(&self, other: &Self) -> bool {
        self.Header == other.Header && self.Mask == other.Mask && self.SidStart == other.SidStart
    }
}
impl ::core::cmp::Eq for ACCESS_DENIED_ACE {}
impl ::core::default::Default for ACCESS_DENIED_ACE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct ACCESS_REASONS {
    pub Data: [u32; 32],
}
impl ::core::marker::Copy for ACCESS_REASONS {}
impl ::core::clone::Clone for ACCESS_REASONS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for ACCESS_REASONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ACCESS_REASONS").field("Data", &self.Data).finish()
    }
}
impl ::windows_core::TypeKind for ACCESS_REASONS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for ACCESS_REASONS {
    fn eq(&self, other: &Self) -> bool {
        self.Data == other.Data
    }
}
impl ::core::cmp::Eq for ACCESS_REASONS {}
impl ::core::default::Default for ACCESS_REASONS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct ACE_HEADER {
    pub AceType: u8,
    pub AceFlags: u8,
    pub AceSize: u16,
}
impl ::core::marker::Copy for ACE_HEADER {}
impl ::core::clone::Clone for ACE_HEADER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for ACE_HEADER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ACE_HEADER").field("AceType", &self.AceType).field("AceFlags", &self.AceFlags).field("AceSize", &self.AceSize).finish()
    }
}
impl ::windows_core::TypeKind for ACE_HEADER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for ACE_HEADER {
    fn eq(&self, other: &Self) -> bool {
        self.AceType == other.AceType && self.AceFlags == other.AceFlags && self.AceSize == other.AceSize
    }
}
impl ::core::cmp::Eq for ACE_HEADER {}
impl ::core::default::Default for ACE_HEADER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct ASYNC_DUPLICATE_EXTENTS_STATUS {
    pub Version: u32,
    pub State: DUPLICATE_EXTENTS_STATE,
    pub SourceFileOffset: u64,
    pub TargetFileOffset: u64,
    pub ByteCount: u64,
    pub BytesDuplicated: u64,
}
impl ::core::marker::Copy for ASYNC_DUPLICATE_EXTENTS_STATUS {}
impl ::core::clone::Clone for ASYNC_DUPLICATE_EXTENTS_STATUS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for ASYNC_DUPLICATE_EXTENTS_STATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ASYNC_DUPLICATE_EXTENTS_STATUS").field("Version", &self.Version).field("State", &self.State).field("SourceFileOffset", &self.SourceFileOffset).field("TargetFileOffset", &self.TargetFileOffset).field("ByteCount", &self.ByteCount).field("BytesDuplicated", &self.BytesDuplicated).finish()
    }
}
impl ::windows_core::TypeKind for ASYNC_DUPLICATE_EXTENTS_STATUS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for ASYNC_DUPLICATE_EXTENTS_STATUS {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.State == other.State && self.SourceFileOffset == other.SourceFileOffset && self.TargetFileOffset == other.TargetFileOffset && self.ByteCount == other.ByteCount && self.BytesDuplicated == other.BytesDuplicated
    }
}
impl ::core::cmp::Eq for ASYNC_DUPLICATE_EXTENTS_STATUS {}
impl ::core::default::Default for ASYNC_DUPLICATE_EXTENTS_STATUS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct ATOMIC_CREATE_ECP_CONTEXT {
    pub Size: u16,
    pub InFlags: u16,
    pub OutFlags: u16,
    pub ReparseBufferLength: u16,
    pub ReparseBuffer: *mut REPARSE_DATA_BUFFER,
    pub FileSize: i64,
    pub ValidDataLength: i64,
    pub FileTimestamps: *mut FILE_TIMESTAMPS,
    pub FileAttributes: u32,
    pub UsnSourceInfo: u32,
    pub Usn: i64,
    pub SuppressFileAttributeInheritanceMask: u32,
    pub InOpFlags: u32,
    pub OutOpFlags: u32,
    pub InGenFlags: u32,
    pub OutGenFlags: u32,
    pub CaseSensitiveFlagsMask: u32,
    pub InCaseSensitiveFlags: u32,
    pub OutCaseSensitiveFlags: u32,
}
impl ::core::marker::Copy for ATOMIC_CREATE_ECP_CONTEXT {}
impl ::core::clone::Clone for ATOMIC_CREATE_ECP_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for ATOMIC_CREATE_ECP_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ATOMIC_CREATE_ECP_CONTEXT")
            .field("Size", &self.Size)
            .field("InFlags", &self.InFlags)
            .field("OutFlags", &self.OutFlags)
            .field("ReparseBufferLength", &self.ReparseBufferLength)
            .field("ReparseBuffer", &self.ReparseBuffer)
            .field("FileSize", &self.FileSize)
            .field("ValidDataLength", &self.ValidDataLength)
            .field("FileTimestamps", &self.FileTimestamps)
            .field("FileAttributes", &self.FileAttributes)
            .field("UsnSourceInfo", &self.UsnSourceInfo)
            .field("Usn", &self.Usn)
            .field("SuppressFileAttributeInheritanceMask", &self.SuppressFileAttributeInheritanceMask)
            .field("InOpFlags", &self.InOpFlags)
            .field("OutOpFlags", &self.OutOpFlags)
            .field("InGenFlags", &self.InGenFlags)
            .field("OutGenFlags", &self.OutGenFlags)
            .field("CaseSensitiveFlagsMask", &self.CaseSensitiveFlagsMask)
            .field("InCaseSensitiveFlags", &self.InCaseSensitiveFlags)
            .field("OutCaseSensitiveFlags", &self.OutCaseSensitiveFlags)
            .finish()
    }
}
impl ::windows_core::TypeKind for ATOMIC_CREATE_ECP_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for ATOMIC_CREATE_ECP_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.InFlags == other.InFlags
            && self.OutFlags == other.OutFlags
            && self.ReparseBufferLength == other.ReparseBufferLength
            && self.ReparseBuffer == other.ReparseBuffer
            && self.FileSize == other.FileSize
            && self.ValidDataLength == other.ValidDataLength
            && self.FileTimestamps == other.FileTimestamps
            && self.FileAttributes == other.FileAttributes
            && self.UsnSourceInfo == other.UsnSourceInfo
            && self.Usn == other.Usn
            && self.SuppressFileAttributeInheritanceMask == other.SuppressFileAttributeInheritanceMask
            && self.InOpFlags == other.InOpFlags
            && self.OutOpFlags == other.OutOpFlags
            && self.InGenFlags == other.InGenFlags
            && self.OutGenFlags == other.OutGenFlags
            && self.CaseSensitiveFlagsMask == other.CaseSensitiveFlagsMask
            && self.InCaseSensitiveFlags == other.InCaseSensitiveFlags
            && self.OutCaseSensitiveFlags == other.OutCaseSensitiveFlags
    }
}
impl ::core::cmp::Eq for ATOMIC_CREATE_ECP_CONTEXT {}
impl ::core::default::Default for ATOMIC_CREATE_ECP_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct BASE_MCB {
    pub MaximumPairCount: u32,
    pub PairCount: u32,
    pub PoolType: u16,
    pub Flags: u16,
    pub Mapping: *mut ::core::ffi::c_void,
}
impl ::core::marker::Copy for BASE_MCB {}
impl ::core::clone::Clone for BASE_MCB {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for BASE_MCB {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BASE_MCB").field("MaximumPairCount", &self.MaximumPairCount).field("PairCount", &self.PairCount).field("PoolType", &self.PoolType).field("Flags", &self.Flags).field("Mapping", &self.Mapping).finish()
    }
}
impl ::windows_core::TypeKind for BASE_MCB {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for BASE_MCB {
    fn eq(&self, other: &Self) -> bool {
        self.MaximumPairCount == other.MaximumPairCount && self.PairCount == other.PairCount && self.PoolType == other.PoolType && self.Flags == other.Flags && self.Mapping == other.Mapping
    }
}
impl ::core::cmp::Eq for BASE_MCB {}
impl ::core::default::Default for BASE_MCB {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct BOOT_AREA_INFO {
    pub BootSectorCount: u32,
    pub BootSectors: [BOOT_AREA_INFO_0; 2],
}
impl ::core::marker::Copy for BOOT_AREA_INFO {}
impl ::core::clone::Clone for BOOT_AREA_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for BOOT_AREA_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BOOT_AREA_INFO").field("BootSectorCount", &self.BootSectorCount).field("BootSectors", &self.BootSectors).finish()
    }
}
impl ::windows_core::TypeKind for BOOT_AREA_INFO {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for BOOT_AREA_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.BootSectorCount == other.BootSectorCount && self.BootSectors == other.BootSectors
    }
}
impl ::core::cmp::Eq for BOOT_AREA_INFO {}
impl ::core::default::Default for BOOT_AREA_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct BOOT_AREA_INFO_0 {
    pub Offset: i64,
}
impl ::core::marker::Copy for BOOT_AREA_INFO_0 {}
impl ::core::clone::Clone for BOOT_AREA_INFO_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for BOOT_AREA_INFO_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BOOT_AREA_INFO_0").field("Offset", &self.Offset).finish()
    }
}
impl ::windows_core::TypeKind for BOOT_AREA_INFO_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for BOOT_AREA_INFO_0 {
    fn eq(&self, other: &Self) -> bool {
        self.Offset == other.Offset
    }
}
impl ::core::cmp::Eq for BOOT_AREA_INFO_0 {}
impl ::core::default::Default for BOOT_AREA_INFO_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct BULK_SECURITY_TEST_DATA {
    pub DesiredAccess: u32,
    pub SecurityIds: [u32; 1],
}
impl ::core::marker::Copy for BULK_SECURITY_TEST_DATA {}
impl ::core::clone::Clone for BULK_SECURITY_TEST_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for BULK_SECURITY_TEST_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BULK_SECURITY_TEST_DATA").field("DesiredAccess", &self.DesiredAccess).field("SecurityIds", &self.SecurityIds).finish()
    }
}
impl ::windows_core::TypeKind for BULK_SECURITY_TEST_DATA {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for BULK_SECURITY_TEST_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.DesiredAccess == other.DesiredAccess && self.SecurityIds == other.SecurityIds
    }
}
impl ::core::cmp::Eq for BULK_SECURITY_TEST_DATA {}
impl ::core::default::Default for BULK_SECURITY_TEST_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct CACHE_MANAGER_CALLBACKS {
    pub AcquireForLazyWrite: PACQUIRE_FOR_LAZY_WRITE,
    pub ReleaseFromLazyWrite: PRELEASE_FROM_LAZY_WRITE,
    pub AcquireForReadAhead: PACQUIRE_FOR_READ_AHEAD,
    pub ReleaseFromReadAhead: PRELEASE_FROM_READ_AHEAD,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for CACHE_MANAGER_CALLBACKS {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for CACHE_MANAGER_CALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for CACHE_MANAGER_CALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CACHE_MANAGER_CALLBACKS").finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for CACHE_MANAGER_CALLBACKS {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for CACHE_MANAGER_CALLBACKS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct CACHE_MANAGER_CALLBACKS_EX {
    pub Version: u16,
    pub Size: u16,
    pub Functions: CACHE_MANAGER_CALLBACK_FUNCTIONS,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for CACHE_MANAGER_CALLBACKS_EX {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for CACHE_MANAGER_CALLBACKS_EX {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for CACHE_MANAGER_CALLBACKS_EX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CACHE_MANAGER_CALLBACKS_EX").field("Version", &self.Version).field("Size", &self.Size).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for CACHE_MANAGER_CALLBACKS_EX {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for CACHE_MANAGER_CALLBACKS_EX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct CACHE_MANAGER_CALLBACK_FUNCTIONS {
    pub AcquireForLazyWriteEx: PACQUIRE_FOR_LAZY_WRITE_EX,
    pub ReleaseFromLazyWrite: PRELEASE_FROM_LAZY_WRITE,
    pub AcquireForReadAhead: PACQUIRE_FOR_READ_AHEAD,
    pub ReleaseFromReadAhead: PRELEASE_FROM_READ_AHEAD,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for CACHE_MANAGER_CALLBACK_FUNCTIONS {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for CACHE_MANAGER_CALLBACK_FUNCTIONS {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for CACHE_MANAGER_CALLBACK_FUNCTIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CACHE_MANAGER_CALLBACK_FUNCTIONS").finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for CACHE_MANAGER_CALLBACK_FUNCTIONS {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for CACHE_MANAGER_CALLBACK_FUNCTIONS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
pub struct CACHE_UNINITIALIZE_EVENT {
    pub Next: *mut CACHE_UNINITIALIZE_EVENT,
    pub Event: super::super::Foundation::KEVENT,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::marker::Copy for CACHE_UNINITIALIZE_EVENT {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::clone::Clone for CACHE_UNINITIALIZE_EVENT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::windows_core::TypeKind for CACHE_UNINITIALIZE_EVENT {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::default::Default for CACHE_UNINITIALIZE_EVENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
pub struct CC_ASYNC_READ_CONTEXT {
    pub CompletionRoutine: PASYNC_READ_COMPLETION_CALLBACK,
    pub Context: *mut ::core::ffi::c_void,
    pub Mdl: *mut super::super::super::Win32::Graphics::DirectDraw::MDL,
    pub RequestorMode: i8,
    pub NestingLevel: u32,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl ::core::marker::Copy for CC_ASYNC_READ_CONTEXT {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl ::core::clone::Clone for CC_ASYNC_READ_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl ::core::fmt::Debug for CC_ASYNC_READ_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CC_ASYNC_READ_CONTEXT").field("Context", &self.Context).field("Mdl", &self.Mdl).field("RequestorMode", &self.RequestorMode).field("NestingLevel", &self.NestingLevel).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl ::windows_core::TypeKind for CC_ASYNC_READ_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw"))]
impl ::core::default::Default for CC_ASYNC_READ_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct CC_ERROR_CALLBACK_CONTEXT {
    pub NodeByteSize: i16,
    pub ErrorCode: super::super::super::Win32::Foundation::NTSTATUS,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for CC_ERROR_CALLBACK_CONTEXT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for CC_ERROR_CALLBACK_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for CC_ERROR_CALLBACK_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CC_ERROR_CALLBACK_CONTEXT").field("NodeByteSize", &self.NodeByteSize).field("ErrorCode", &self.ErrorCode).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for CC_ERROR_CALLBACK_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for CC_ERROR_CALLBACK_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.NodeByteSize == other.NodeByteSize && self.ErrorCode == other.ErrorCode
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for CC_ERROR_CALLBACK_CONTEXT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for CC_ERROR_CALLBACK_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CC_FILE_SIZES {
    pub AllocationSize: i64,
    pub FileSize: i64,
    pub ValidDataLength: i64,
}
impl ::core::marker::Copy for CC_FILE_SIZES {}
impl ::core::clone::Clone for CC_FILE_SIZES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CC_FILE_SIZES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CC_FILE_SIZES").field("AllocationSize", &self.AllocationSize).field("FileSize", &self.FileSize).field("ValidDataLength", &self.ValidDataLength).finish()
    }
}
impl ::windows_core::TypeKind for CC_FILE_SIZES {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for CC_FILE_SIZES {
    fn eq(&self, other: &Self) -> bool {
        self.AllocationSize == other.AllocationSize && self.FileSize == other.FileSize && self.ValidDataLength == other.ValidDataLength
    }
}
impl ::core::cmp::Eq for CC_FILE_SIZES {}
impl ::core::default::Default for CC_FILE_SIZES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CLAIM_SECURITY_ATTRIBUTES_INFORMATION {
    pub Version: u16,
    pub Reserved: u16,
    pub AttributeCount: u32,
    pub Attribute: CLAIM_SECURITY_ATTRIBUTES_INFORMATION_0,
}
impl ::core::marker::Copy for CLAIM_SECURITY_ATTRIBUTES_INFORMATION {}
impl ::core::clone::Clone for CLAIM_SECURITY_ATTRIBUTES_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for CLAIM_SECURITY_ATTRIBUTES_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for CLAIM_SECURITY_ATTRIBUTES_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub union CLAIM_SECURITY_ATTRIBUTES_INFORMATION_0 {
    pub pAttributeV1: *mut CLAIM_SECURITY_ATTRIBUTE_V1,
}
impl ::core::marker::Copy for CLAIM_SECURITY_ATTRIBUTES_INFORMATION_0 {}
impl ::core::clone::Clone for CLAIM_SECURITY_ATTRIBUTES_INFORMATION_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for CLAIM_SECURITY_ATTRIBUTES_INFORMATION_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for CLAIM_SECURITY_ATTRIBUTES_INFORMATION_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
    pub Version: u64,
    pub Name: ::windows_core::PWSTR,
}
impl ::core::marker::Copy for CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {}
impl ::core::clone::Clone for CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE").field("Version", &self.Version).field("Name", &self.Name).finish()
    }
}
impl ::windows_core::TypeKind for CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Name == other.Name
    }
}
impl ::core::cmp::Eq for CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {}
impl ::core::default::Default for CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
    pub pValue: *mut ::core::ffi::c_void,
    pub ValueLength: u32,
}
impl ::core::marker::Copy for CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {}
impl ::core::clone::Clone for CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE").field("pValue", &self.pValue).field("ValueLength", &self.ValueLength).finish()
    }
}
impl ::windows_core::TypeKind for CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
    fn eq(&self, other: &Self) -> bool {
        self.pValue == other.pValue && self.ValueLength == other.ValueLength
    }
}
impl ::core::cmp::Eq for CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {}
impl ::core::default::Default for CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 {
    pub Name: u32,
    pub ValueType: u16,
    pub Reserved: u16,
    pub Flags: u32,
    pub ValueCount: u32,
    pub Values: CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1_0,
}
impl ::core::marker::Copy for CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 {}
impl ::core::clone::Clone for CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub union CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1_0 {
    pub pInt64: [u32; 1],
    pub pUint64: [u32; 1],
    pub ppString: [u32; 1],
    pub pFqbn: [u32; 1],
    pub pOctetString: [u32; 1],
}
impl ::core::marker::Copy for CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1_0 {}
impl ::core::clone::Clone for CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CLAIM_SECURITY_ATTRIBUTE_V1 {
    pub Name: ::windows_core::PWSTR,
    pub ValueType: u16,
    pub Reserved: u16,
    pub Flags: u32,
    pub ValueCount: u32,
    pub Values: CLAIM_SECURITY_ATTRIBUTE_V1_0,
}
impl ::core::marker::Copy for CLAIM_SECURITY_ATTRIBUTE_V1 {}
impl ::core::clone::Clone for CLAIM_SECURITY_ATTRIBUTE_V1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for CLAIM_SECURITY_ATTRIBUTE_V1 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for CLAIM_SECURITY_ATTRIBUTE_V1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub union CLAIM_SECURITY_ATTRIBUTE_V1_0 {
    pub pInt64: *mut i64,
    pub pUint64: *mut u64,
    pub ppString: *mut ::windows_core::PWSTR,
    pub pFqbn: *mut CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE,
    pub pOctetString: *mut CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE,
}
impl ::core::marker::Copy for CLAIM_SECURITY_ATTRIBUTE_V1_0 {}
impl ::core::clone::Clone for CLAIM_SECURITY_ATTRIBUTE_V1_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for CLAIM_SECURITY_ATTRIBUTE_V1_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for CLAIM_SECURITY_ATTRIBUTE_V1_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CLUSTER_RANGE {
    pub StartingCluster: i64,
    pub ClusterCount: i64,
}
impl ::core::marker::Copy for CLUSTER_RANGE {}
impl ::core::clone::Clone for CLUSTER_RANGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CLUSTER_RANGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CLUSTER_RANGE").field("StartingCluster", &self.StartingCluster).field("ClusterCount", &self.ClusterCount).finish()
    }
}
impl ::windows_core::TypeKind for CLUSTER_RANGE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for CLUSTER_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.StartingCluster == other.StartingCluster && self.ClusterCount == other.ClusterCount
    }
}
impl ::core::cmp::Eq for CLUSTER_RANGE {}
impl ::core::default::Default for CLUSTER_RANGE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct COMPRESSED_DATA_INFO {
    pub CompressionFormatAndEngine: u16,
    pub CompressionUnitShift: u8,
    pub ChunkShift: u8,
    pub ClusterShift: u8,
    pub Reserved: u8,
    pub NumberOfChunks: u16,
    pub CompressedChunkSizes: [u32; 1],
}
impl ::core::marker::Copy for COMPRESSED_DATA_INFO {}
impl ::core::clone::Clone for COMPRESSED_DATA_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for COMPRESSED_DATA_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("COMPRESSED_DATA_INFO").field("CompressionFormatAndEngine", &self.CompressionFormatAndEngine).field("CompressionUnitShift", &self.CompressionUnitShift).field("ChunkShift", &self.ChunkShift).field("ClusterShift", &self.ClusterShift).field("Reserved", &self.Reserved).field("NumberOfChunks", &self.NumberOfChunks).field("CompressedChunkSizes", &self.CompressedChunkSizes).finish()
    }
}
impl ::windows_core::TypeKind for COMPRESSED_DATA_INFO {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for COMPRESSED_DATA_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.CompressionFormatAndEngine == other.CompressionFormatAndEngine && self.CompressionUnitShift == other.CompressionUnitShift && self.ChunkShift == other.ChunkShift && self.ClusterShift == other.ClusterShift && self.Reserved == other.Reserved && self.NumberOfChunks == other.NumberOfChunks && self.CompressedChunkSizes == other.CompressedChunkSizes
    }
}
impl ::core::cmp::Eq for COMPRESSED_DATA_INFO {}
impl ::core::default::Default for COMPRESSED_DATA_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CONTAINER_ROOT_INFO_INPUT {
    pub Flags: u32,
}
impl ::core::marker::Copy for CONTAINER_ROOT_INFO_INPUT {}
impl ::core::clone::Clone for CONTAINER_ROOT_INFO_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CONTAINER_ROOT_INFO_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CONTAINER_ROOT_INFO_INPUT").field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for CONTAINER_ROOT_INFO_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for CONTAINER_ROOT_INFO_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for CONTAINER_ROOT_INFO_INPUT {}
impl ::core::default::Default for CONTAINER_ROOT_INFO_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CONTAINER_ROOT_INFO_OUTPUT {
    pub ContainerRootIdLength: u16,
    pub ContainerRootId: [u8; 1],
}
impl ::core::marker::Copy for CONTAINER_ROOT_INFO_OUTPUT {}
impl ::core::clone::Clone for CONTAINER_ROOT_INFO_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CONTAINER_ROOT_INFO_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CONTAINER_ROOT_INFO_OUTPUT").field("ContainerRootIdLength", &self.ContainerRootIdLength).field("ContainerRootId", &self.ContainerRootId).finish()
    }
}
impl ::windows_core::TypeKind for CONTAINER_ROOT_INFO_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for CONTAINER_ROOT_INFO_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.ContainerRootIdLength == other.ContainerRootIdLength && self.ContainerRootId == other.ContainerRootId
    }
}
impl ::core::cmp::Eq for CONTAINER_ROOT_INFO_OUTPUT {}
impl ::core::default::Default for CONTAINER_ROOT_INFO_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CONTAINER_VOLUME_STATE {
    pub Flags: u32,
}
impl ::core::marker::Copy for CONTAINER_VOLUME_STATE {}
impl ::core::clone::Clone for CONTAINER_VOLUME_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CONTAINER_VOLUME_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CONTAINER_VOLUME_STATE").field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for CONTAINER_VOLUME_STATE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for CONTAINER_VOLUME_STATE {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for CONTAINER_VOLUME_STATE {}
impl ::core::default::Default for CONTAINER_VOLUME_STATE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub struct COPY_INFORMATION {
    pub SourceFileObject: *mut super::super::Foundation::FILE_OBJECT,
    pub SourceFileOffset: i64,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::marker::Copy for COPY_INFORMATION {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::clone::Clone for COPY_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::fmt::Debug for COPY_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("COPY_INFORMATION").field("SourceFileObject", &self.SourceFileObject).field("SourceFileOffset", &self.SourceFileOffset).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::windows_core::TypeKind for COPY_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::cmp::PartialEq for COPY_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.SourceFileObject == other.SourceFileObject && self.SourceFileOffset == other.SourceFileOffset
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::cmp::Eq for COPY_INFORMATION {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::default::Default for COPY_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CPTABLEINFO {
    pub CodePage: u16,
    pub MaximumCharacterSize: u16,
    pub DefaultChar: u16,
    pub UniDefaultChar: u16,
    pub TransDefaultChar: u16,
    pub TransUniDefaultChar: u16,
    pub DBCSCodePage: u16,
    pub LeadByte: [u8; 12],
    pub MultiByteTable: *mut u16,
    pub WideCharTable: *mut ::core::ffi::c_void,
    pub DBCSRanges: *mut u16,
    pub DBCSOffsets: *mut u16,
}
impl ::core::marker::Copy for CPTABLEINFO {}
impl ::core::clone::Clone for CPTABLEINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CPTABLEINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CPTABLEINFO")
            .field("CodePage", &self.CodePage)
            .field("MaximumCharacterSize", &self.MaximumCharacterSize)
            .field("DefaultChar", &self.DefaultChar)
            .field("UniDefaultChar", &self.UniDefaultChar)
            .field("TransDefaultChar", &self.TransDefaultChar)
            .field("TransUniDefaultChar", &self.TransUniDefaultChar)
            .field("DBCSCodePage", &self.DBCSCodePage)
            .field("LeadByte", &self.LeadByte)
            .field("MultiByteTable", &self.MultiByteTable)
            .field("WideCharTable", &self.WideCharTable)
            .field("DBCSRanges", &self.DBCSRanges)
            .field("DBCSOffsets", &self.DBCSOffsets)
            .finish()
    }
}
impl ::windows_core::TypeKind for CPTABLEINFO {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for CPTABLEINFO {
    fn eq(&self, other: &Self) -> bool {
        self.CodePage == other.CodePage && self.MaximumCharacterSize == other.MaximumCharacterSize && self.DefaultChar == other.DefaultChar && self.UniDefaultChar == other.UniDefaultChar && self.TransDefaultChar == other.TransDefaultChar && self.TransUniDefaultChar == other.TransUniDefaultChar && self.DBCSCodePage == other.DBCSCodePage && self.LeadByte == other.LeadByte && self.MultiByteTable == other.MultiByteTable && self.WideCharTable == other.WideCharTable && self.DBCSRanges == other.DBCSRanges && self.DBCSOffsets == other.DBCSOffsets
    }
}
impl ::core::cmp::Eq for CPTABLEINFO {}
impl ::core::default::Default for CPTABLEINFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CREATE_REDIRECTION_ECP_CONTEXT {
    pub Size: u16,
    pub Flags: u16,
    pub FileId: FILE_ID_128,
    pub VolumeGuid: ::windows_core::GUID,
}
impl ::core::marker::Copy for CREATE_REDIRECTION_ECP_CONTEXT {}
impl ::core::clone::Clone for CREATE_REDIRECTION_ECP_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CREATE_REDIRECTION_ECP_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CREATE_REDIRECTION_ECP_CONTEXT").field("Size", &self.Size).field("Flags", &self.Flags).field("FileId", &self.FileId).field("VolumeGuid", &self.VolumeGuid).finish()
    }
}
impl ::windows_core::TypeKind for CREATE_REDIRECTION_ECP_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for CREATE_REDIRECTION_ECP_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.Flags == other.Flags && self.FileId == other.FileId && self.VolumeGuid == other.VolumeGuid
    }
}
impl ::core::cmp::Eq for CREATE_REDIRECTION_ECP_CONTEXT {}
impl ::core::default::Default for CREATE_REDIRECTION_ECP_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CREATE_USN_JOURNAL_DATA {
    pub MaximumSize: u64,
    pub AllocationDelta: u64,
}
impl ::core::marker::Copy for CREATE_USN_JOURNAL_DATA {}
impl ::core::clone::Clone for CREATE_USN_JOURNAL_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CREATE_USN_JOURNAL_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CREATE_USN_JOURNAL_DATA").field("MaximumSize", &self.MaximumSize).field("AllocationDelta", &self.AllocationDelta).finish()
    }
}
impl ::windows_core::TypeKind for CREATE_USN_JOURNAL_DATA {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for CREATE_USN_JOURNAL_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.MaximumSize == other.MaximumSize && self.AllocationDelta == other.AllocationDelta
    }
}
impl ::core::cmp::Eq for CREATE_USN_JOURNAL_DATA {}
impl ::core::default::Default for CREATE_USN_JOURNAL_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CSV_CONTROL_PARAM {
    pub Operation: CSV_CONTROL_OP,
    pub Unused: i64,
}
impl ::core::marker::Copy for CSV_CONTROL_PARAM {}
impl ::core::clone::Clone for CSV_CONTROL_PARAM {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CSV_CONTROL_PARAM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CSV_CONTROL_PARAM").field("Operation", &self.Operation).field("Unused", &self.Unused).finish()
    }
}
impl ::windows_core::TypeKind for CSV_CONTROL_PARAM {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for CSV_CONTROL_PARAM {
    fn eq(&self, other: &Self) -> bool {
        self.Operation == other.Operation && self.Unused == other.Unused
    }
}
impl ::core::cmp::Eq for CSV_CONTROL_PARAM {}
impl ::core::default::Default for CSV_CONTROL_PARAM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct CSV_DOWN_LEVEL_OPEN_ECP_CONTEXT {
    pub Version: u32,
    pub IsResume: super::super::super::Win32::Foundation::BOOLEAN,
    pub FileType: CSV_DOWN_LEVEL_FILE_TYPE,
    pub SourceNodeId: u32,
    pub DestinationNodeId: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for CSV_DOWN_LEVEL_OPEN_ECP_CONTEXT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for CSV_DOWN_LEVEL_OPEN_ECP_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for CSV_DOWN_LEVEL_OPEN_ECP_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CSV_DOWN_LEVEL_OPEN_ECP_CONTEXT").field("Version", &self.Version).field("IsResume", &self.IsResume).field("FileType", &self.FileType).field("SourceNodeId", &self.SourceNodeId).field("DestinationNodeId", &self.DestinationNodeId).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for CSV_DOWN_LEVEL_OPEN_ECP_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for CSV_DOWN_LEVEL_OPEN_ECP_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.IsResume == other.IsResume && self.FileType == other.FileType && self.SourceNodeId == other.SourceNodeId && self.DestinationNodeId == other.DestinationNodeId
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for CSV_DOWN_LEVEL_OPEN_ECP_CONTEXT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for CSV_DOWN_LEVEL_OPEN_ECP_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct CSV_IS_OWNED_BY_CSVFS {
    pub OwnedByCSVFS: super::super::super::Win32::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for CSV_IS_OWNED_BY_CSVFS {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for CSV_IS_OWNED_BY_CSVFS {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for CSV_IS_OWNED_BY_CSVFS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CSV_IS_OWNED_BY_CSVFS").field("OwnedByCSVFS", &self.OwnedByCSVFS).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for CSV_IS_OWNED_BY_CSVFS {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for CSV_IS_OWNED_BY_CSVFS {
    fn eq(&self, other: &Self) -> bool {
        self.OwnedByCSVFS == other.OwnedByCSVFS
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for CSV_IS_OWNED_BY_CSVFS {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for CSV_IS_OWNED_BY_CSVFS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CSV_MGMT_LOCK {
    pub Flags: u32,
}
impl ::core::marker::Copy for CSV_MGMT_LOCK {}
impl ::core::clone::Clone for CSV_MGMT_LOCK {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CSV_MGMT_LOCK {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CSV_MGMT_LOCK").field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for CSV_MGMT_LOCK {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for CSV_MGMT_LOCK {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for CSV_MGMT_LOCK {}
impl ::core::default::Default for CSV_MGMT_LOCK {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CSV_NAMESPACE_INFO {
    pub Version: u32,
    pub DeviceNumber: u32,
    pub StartingOffset: i64,
    pub SectorSize: u32,
}
impl ::core::marker::Copy for CSV_NAMESPACE_INFO {}
impl ::core::clone::Clone for CSV_NAMESPACE_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CSV_NAMESPACE_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CSV_NAMESPACE_INFO").field("Version", &self.Version).field("DeviceNumber", &self.DeviceNumber).field("StartingOffset", &self.StartingOffset).field("SectorSize", &self.SectorSize).finish()
    }
}
impl ::windows_core::TypeKind for CSV_NAMESPACE_INFO {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for CSV_NAMESPACE_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.DeviceNumber == other.DeviceNumber && self.StartingOffset == other.StartingOffset && self.SectorSize == other.SectorSize
    }
}
impl ::core::cmp::Eq for CSV_NAMESPACE_INFO {}
impl ::core::default::Default for CSV_NAMESPACE_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CSV_QUERY_FILE_REVISION {
    pub FileId: i64,
    pub FileRevision: [i64; 3],
}
impl ::core::marker::Copy for CSV_QUERY_FILE_REVISION {}
impl ::core::clone::Clone for CSV_QUERY_FILE_REVISION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CSV_QUERY_FILE_REVISION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CSV_QUERY_FILE_REVISION").field("FileId", &self.FileId).field("FileRevision", &self.FileRevision).finish()
    }
}
impl ::windows_core::TypeKind for CSV_QUERY_FILE_REVISION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for CSV_QUERY_FILE_REVISION {
    fn eq(&self, other: &Self) -> bool {
        self.FileId == other.FileId && self.FileRevision == other.FileRevision
    }
}
impl ::core::cmp::Eq for CSV_QUERY_FILE_REVISION {}
impl ::core::default::Default for CSV_QUERY_FILE_REVISION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CSV_QUERY_FILE_REVISION_ECP_CONTEXT {
    pub FileId: i64,
    pub FileRevision: [i64; 3],
}
impl ::core::marker::Copy for CSV_QUERY_FILE_REVISION_ECP_CONTEXT {}
impl ::core::clone::Clone for CSV_QUERY_FILE_REVISION_ECP_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CSV_QUERY_FILE_REVISION_ECP_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CSV_QUERY_FILE_REVISION_ECP_CONTEXT").field("FileId", &self.FileId).field("FileRevision", &self.FileRevision).finish()
    }
}
impl ::windows_core::TypeKind for CSV_QUERY_FILE_REVISION_ECP_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for CSV_QUERY_FILE_REVISION_ECP_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.FileId == other.FileId && self.FileRevision == other.FileRevision
    }
}
impl ::core::cmp::Eq for CSV_QUERY_FILE_REVISION_ECP_CONTEXT {}
impl ::core::default::Default for CSV_QUERY_FILE_REVISION_ECP_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CSV_QUERY_FILE_REVISION_ECP_CONTEXT_FILE_ID_128 {
    pub FileId: FILE_ID_128,
    pub FileRevision: [i64; 3],
}
impl ::core::marker::Copy for CSV_QUERY_FILE_REVISION_ECP_CONTEXT_FILE_ID_128 {}
impl ::core::clone::Clone for CSV_QUERY_FILE_REVISION_ECP_CONTEXT_FILE_ID_128 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CSV_QUERY_FILE_REVISION_ECP_CONTEXT_FILE_ID_128 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CSV_QUERY_FILE_REVISION_ECP_CONTEXT_FILE_ID_128").field("FileId", &self.FileId).field("FileRevision", &self.FileRevision).finish()
    }
}
impl ::windows_core::TypeKind for CSV_QUERY_FILE_REVISION_ECP_CONTEXT_FILE_ID_128 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for CSV_QUERY_FILE_REVISION_ECP_CONTEXT_FILE_ID_128 {
    fn eq(&self, other: &Self) -> bool {
        self.FileId == other.FileId && self.FileRevision == other.FileRevision
    }
}
impl ::core::cmp::Eq for CSV_QUERY_FILE_REVISION_ECP_CONTEXT_FILE_ID_128 {}
impl ::core::default::Default for CSV_QUERY_FILE_REVISION_ECP_CONTEXT_FILE_ID_128 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CSV_QUERY_FILE_REVISION_FILE_ID_128 {
    pub FileId: FILE_ID_128,
    pub FileRevision: [i64; 3],
}
impl ::core::marker::Copy for CSV_QUERY_FILE_REVISION_FILE_ID_128 {}
impl ::core::clone::Clone for CSV_QUERY_FILE_REVISION_FILE_ID_128 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CSV_QUERY_FILE_REVISION_FILE_ID_128 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CSV_QUERY_FILE_REVISION_FILE_ID_128").field("FileId", &self.FileId).field("FileRevision", &self.FileRevision).finish()
    }
}
impl ::windows_core::TypeKind for CSV_QUERY_FILE_REVISION_FILE_ID_128 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for CSV_QUERY_FILE_REVISION_FILE_ID_128 {
    fn eq(&self, other: &Self) -> bool {
        self.FileId == other.FileId && self.FileRevision == other.FileRevision
    }
}
impl ::core::cmp::Eq for CSV_QUERY_FILE_REVISION_FILE_ID_128 {}
impl ::core::default::Default for CSV_QUERY_FILE_REVISION_FILE_ID_128 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CSV_QUERY_MDS_PATH {
    pub MdsNodeId: u32,
    pub DsNodeId: u32,
    pub PathLength: u32,
    pub Path: [u16; 1],
}
impl ::core::marker::Copy for CSV_QUERY_MDS_PATH {}
impl ::core::clone::Clone for CSV_QUERY_MDS_PATH {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CSV_QUERY_MDS_PATH {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CSV_QUERY_MDS_PATH").field("MdsNodeId", &self.MdsNodeId).field("DsNodeId", &self.DsNodeId).field("PathLength", &self.PathLength).field("Path", &self.Path).finish()
    }
}
impl ::windows_core::TypeKind for CSV_QUERY_MDS_PATH {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for CSV_QUERY_MDS_PATH {
    fn eq(&self, other: &Self) -> bool {
        self.MdsNodeId == other.MdsNodeId && self.DsNodeId == other.DsNodeId && self.PathLength == other.PathLength && self.Path == other.Path
    }
}
impl ::core::cmp::Eq for CSV_QUERY_MDS_PATH {}
impl ::core::default::Default for CSV_QUERY_MDS_PATH {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CSV_QUERY_MDS_PATH_V2 {
    pub Version: i64,
    pub RequiredSize: u32,
    pub MdsNodeId: u32,
    pub DsNodeId: u32,
    pub Flags: u32,
    pub DiskConnectivity: CSVFS_DISK_CONNECTIVITY,
    pub VolumeId: ::windows_core::GUID,
    pub IpAddressOffset: u32,
    pub IpAddressLength: u32,
    pub PathOffset: u32,
    pub PathLength: u32,
}
impl ::core::marker::Copy for CSV_QUERY_MDS_PATH_V2 {}
impl ::core::clone::Clone for CSV_QUERY_MDS_PATH_V2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CSV_QUERY_MDS_PATH_V2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CSV_QUERY_MDS_PATH_V2").field("Version", &self.Version).field("RequiredSize", &self.RequiredSize).field("MdsNodeId", &self.MdsNodeId).field("DsNodeId", &self.DsNodeId).field("Flags", &self.Flags).field("DiskConnectivity", &self.DiskConnectivity).field("VolumeId", &self.VolumeId).field("IpAddressOffset", &self.IpAddressOffset).field("IpAddressLength", &self.IpAddressLength).field("PathOffset", &self.PathOffset).field("PathLength", &self.PathLength).finish()
    }
}
impl ::windows_core::TypeKind for CSV_QUERY_MDS_PATH_V2 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for CSV_QUERY_MDS_PATH_V2 {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.RequiredSize == other.RequiredSize && self.MdsNodeId == other.MdsNodeId && self.DsNodeId == other.DsNodeId && self.Flags == other.Flags && self.DiskConnectivity == other.DiskConnectivity && self.VolumeId == other.VolumeId && self.IpAddressOffset == other.IpAddressOffset && self.IpAddressLength == other.IpAddressLength && self.PathOffset == other.PathOffset && self.PathLength == other.PathLength
    }
}
impl ::core::cmp::Eq for CSV_QUERY_MDS_PATH_V2 {}
impl ::core::default::Default for CSV_QUERY_MDS_PATH_V2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct CSV_QUERY_REDIRECT_STATE {
    pub MdsNodeId: u32,
    pub DsNodeId: u32,
    pub FileRedirected: super::super::super::Win32::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for CSV_QUERY_REDIRECT_STATE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for CSV_QUERY_REDIRECT_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for CSV_QUERY_REDIRECT_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CSV_QUERY_REDIRECT_STATE").field("MdsNodeId", &self.MdsNodeId).field("DsNodeId", &self.DsNodeId).field("FileRedirected", &self.FileRedirected).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for CSV_QUERY_REDIRECT_STATE {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for CSV_QUERY_REDIRECT_STATE {
    fn eq(&self, other: &Self) -> bool {
        self.MdsNodeId == other.MdsNodeId && self.DsNodeId == other.DsNodeId && self.FileRedirected == other.FileRedirected
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for CSV_QUERY_REDIRECT_STATE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for CSV_QUERY_REDIRECT_STATE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT {
    pub VetoedFromAltitudeIntegral: u64,
    pub VetoedFromAltitudeDecimal: u64,
    pub Reason: [u16; 256],
}
impl ::core::marker::Copy for CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT {}
impl ::core::clone::Clone for CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT").field("VetoedFromAltitudeIntegral", &self.VetoedFromAltitudeIntegral).field("VetoedFromAltitudeDecimal", &self.VetoedFromAltitudeDecimal).field("Reason", &self.Reason).finish()
    }
}
impl ::windows_core::TypeKind for CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.VetoedFromAltitudeIntegral == other.VetoedFromAltitudeIntegral && self.VetoedFromAltitudeDecimal == other.VetoedFromAltitudeDecimal && self.Reason == other.Reason
    }
}
impl ::core::cmp::Eq for CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT {}
impl ::core::default::Default for CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CSV_QUERY_VOLUME_ID {
    pub VolumeId: ::windows_core::GUID,
}
impl ::core::marker::Copy for CSV_QUERY_VOLUME_ID {}
impl ::core::clone::Clone for CSV_QUERY_VOLUME_ID {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CSV_QUERY_VOLUME_ID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CSV_QUERY_VOLUME_ID").field("VolumeId", &self.VolumeId).finish()
    }
}
impl ::windows_core::TypeKind for CSV_QUERY_VOLUME_ID {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for CSV_QUERY_VOLUME_ID {
    fn eq(&self, other: &Self) -> bool {
        self.VolumeId == other.VolumeId
    }
}
impl ::core::cmp::Eq for CSV_QUERY_VOLUME_ID {}
impl ::core::default::Default for CSV_QUERY_VOLUME_ID {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct CSV_QUERY_VOLUME_REDIRECT_STATE {
    pub MdsNodeId: u32,
    pub DsNodeId: u32,
    pub IsDiskConnected: super::super::super::Win32::Foundation::BOOLEAN,
    pub ClusterEnableDirectIo: super::super::super::Win32::Foundation::BOOLEAN,
    pub DiskConnectivity: CSVFS_DISK_CONNECTIVITY,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for CSV_QUERY_VOLUME_REDIRECT_STATE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for CSV_QUERY_VOLUME_REDIRECT_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for CSV_QUERY_VOLUME_REDIRECT_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CSV_QUERY_VOLUME_REDIRECT_STATE").field("MdsNodeId", &self.MdsNodeId).field("DsNodeId", &self.DsNodeId).field("IsDiskConnected", &self.IsDiskConnected).field("ClusterEnableDirectIo", &self.ClusterEnableDirectIo).field("DiskConnectivity", &self.DiskConnectivity).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for CSV_QUERY_VOLUME_REDIRECT_STATE {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for CSV_QUERY_VOLUME_REDIRECT_STATE {
    fn eq(&self, other: &Self) -> bool {
        self.MdsNodeId == other.MdsNodeId && self.DsNodeId == other.DsNodeId && self.IsDiskConnected == other.IsDiskConnected && self.ClusterEnableDirectIo == other.ClusterEnableDirectIo && self.DiskConnectivity == other.DiskConnectivity
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for CSV_QUERY_VOLUME_REDIRECT_STATE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for CSV_QUERY_VOLUME_REDIRECT_STATE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CSV_SET_HANDLE_PROPERTIES_ECP_CONTEXT {
    pub Size: usize,
    pub PauseTimeoutInSeconds: u32,
    pub Flags: u32,
}
impl ::core::marker::Copy for CSV_SET_HANDLE_PROPERTIES_ECP_CONTEXT {}
impl ::core::clone::Clone for CSV_SET_HANDLE_PROPERTIES_ECP_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CSV_SET_HANDLE_PROPERTIES_ECP_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CSV_SET_HANDLE_PROPERTIES_ECP_CONTEXT").field("Size", &self.Size).field("PauseTimeoutInSeconds", &self.PauseTimeoutInSeconds).field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for CSV_SET_HANDLE_PROPERTIES_ECP_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for CSV_SET_HANDLE_PROPERTIES_ECP_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.PauseTimeoutInSeconds == other.PauseTimeoutInSeconds && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for CSV_SET_HANDLE_PROPERTIES_ECP_CONTEXT {}
impl ::core::default::Default for CSV_SET_HANDLE_PROPERTIES_ECP_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct CSV_SET_VOLUME_ID {
    pub VolumeId: ::windows_core::GUID,
}
impl ::core::marker::Copy for CSV_SET_VOLUME_ID {}
impl ::core::clone::Clone for CSV_SET_VOLUME_ID {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for CSV_SET_VOLUME_ID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("CSV_SET_VOLUME_ID").field("VolumeId", &self.VolumeId).finish()
    }
}
impl ::windows_core::TypeKind for CSV_SET_VOLUME_ID {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for CSV_SET_VOLUME_ID {
    fn eq(&self, other: &Self) -> bool {
        self.VolumeId == other.VolumeId
    }
}
impl ::core::cmp::Eq for CSV_SET_VOLUME_ID {}
impl ::core::default::Default for CSV_SET_VOLUME_ID {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct DECRYPTION_STATUS_BUFFER {
    pub NoEncryptedStreams: super::super::super::Win32::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DECRYPTION_STATUS_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DECRYPTION_STATUS_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DECRYPTION_STATUS_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DECRYPTION_STATUS_BUFFER").field("NoEncryptedStreams", &self.NoEncryptedStreams).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for DECRYPTION_STATUS_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DECRYPTION_STATUS_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.NoEncryptedStreams == other.NoEncryptedStreams
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DECRYPTION_STATUS_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DECRYPTION_STATUS_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct DELETE_USN_JOURNAL_DATA {
    pub UsnJournalID: u64,
    pub DeleteFlags: u32,
}
impl ::core::marker::Copy for DELETE_USN_JOURNAL_DATA {}
impl ::core::clone::Clone for DELETE_USN_JOURNAL_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DELETE_USN_JOURNAL_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DELETE_USN_JOURNAL_DATA").field("UsnJournalID", &self.UsnJournalID).field("DeleteFlags", &self.DeleteFlags).finish()
    }
}
impl ::windows_core::TypeKind for DELETE_USN_JOURNAL_DATA {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for DELETE_USN_JOURNAL_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.UsnJournalID == other.UsnJournalID && self.DeleteFlags == other.DeleteFlags
    }
}
impl ::core::cmp::Eq for DELETE_USN_JOURNAL_DATA {}
impl ::core::default::Default for DELETE_USN_JOURNAL_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct DUAL_OPLOCK_KEY_ECP_CONTEXT {
    pub ParentOplockKey: ::windows_core::GUID,
    pub TargetOplockKey: ::windows_core::GUID,
    pub ParentOplockKeySet: super::super::super::Win32::Foundation::BOOLEAN,
    pub TargetOplockKeySet: super::super::super::Win32::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DUAL_OPLOCK_KEY_ECP_CONTEXT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DUAL_OPLOCK_KEY_ECP_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DUAL_OPLOCK_KEY_ECP_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DUAL_OPLOCK_KEY_ECP_CONTEXT").field("ParentOplockKey", &self.ParentOplockKey).field("TargetOplockKey", &self.TargetOplockKey).field("ParentOplockKeySet", &self.ParentOplockKeySet).field("TargetOplockKeySet", &self.TargetOplockKeySet).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for DUAL_OPLOCK_KEY_ECP_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DUAL_OPLOCK_KEY_ECP_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.ParentOplockKey == other.ParentOplockKey && self.TargetOplockKey == other.TargetOplockKey && self.ParentOplockKeySet == other.ParentOplockKeySet && self.TargetOplockKeySet == other.TargetOplockKeySet
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DUAL_OPLOCK_KEY_ECP_CONTEXT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DUAL_OPLOCK_KEY_ECP_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct DUPLICATE_CLUSTER_DATA {
    pub SourceLcn: i64,
    pub TargetFileOffset: i64,
    pub DuplicationLimit: u32,
    pub Reserved: u32,
}
impl ::core::marker::Copy for DUPLICATE_CLUSTER_DATA {}
impl ::core::clone::Clone for DUPLICATE_CLUSTER_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for DUPLICATE_CLUSTER_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DUPLICATE_CLUSTER_DATA").field("SourceLcn", &self.SourceLcn).field("TargetFileOffset", &self.TargetFileOffset).field("DuplicationLimit", &self.DuplicationLimit).field("Reserved", &self.Reserved).finish()
    }
}
impl ::windows_core::TypeKind for DUPLICATE_CLUSTER_DATA {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for DUPLICATE_CLUSTER_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.SourceLcn == other.SourceLcn && self.TargetFileOffset == other.TargetFileOffset && self.DuplicationLimit == other.DuplicationLimit && self.Reserved == other.Reserved
    }
}
impl ::core::cmp::Eq for DUPLICATE_CLUSTER_DATA {}
impl ::core::default::Default for DUPLICATE_CLUSTER_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct DUPLICATE_EXTENTS_DATA {
    pub FileHandle: super::super::super::Win32::Foundation::HANDLE,
    pub SourceFileOffset: i64,
    pub TargetFileOffset: i64,
    pub ByteCount: i64,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DUPLICATE_EXTENTS_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DUPLICATE_EXTENTS_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DUPLICATE_EXTENTS_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DUPLICATE_EXTENTS_DATA").field("FileHandle", &self.FileHandle).field("SourceFileOffset", &self.SourceFileOffset).field("TargetFileOffset", &self.TargetFileOffset).field("ByteCount", &self.ByteCount).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for DUPLICATE_EXTENTS_DATA {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DUPLICATE_EXTENTS_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.FileHandle == other.FileHandle && self.SourceFileOffset == other.SourceFileOffset && self.TargetFileOffset == other.TargetFileOffset && self.ByteCount == other.ByteCount
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DUPLICATE_EXTENTS_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DUPLICATE_EXTENTS_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct DUPLICATE_EXTENTS_DATA_EX {
    pub Size: usize,
    pub FileHandle: super::super::super::Win32::Foundation::HANDLE,
    pub SourceFileOffset: i64,
    pub TargetFileOffset: i64,
    pub ByteCount: i64,
    pub Flags: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for DUPLICATE_EXTENTS_DATA_EX {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for DUPLICATE_EXTENTS_DATA_EX {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for DUPLICATE_EXTENTS_DATA_EX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("DUPLICATE_EXTENTS_DATA_EX").field("Size", &self.Size).field("FileHandle", &self.FileHandle).field("SourceFileOffset", &self.SourceFileOffset).field("TargetFileOffset", &self.TargetFileOffset).field("ByteCount", &self.ByteCount).field("Flags", &self.Flags).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for DUPLICATE_EXTENTS_DATA_EX {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for DUPLICATE_EXTENTS_DATA_EX {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.FileHandle == other.FileHandle && self.SourceFileOffset == other.SourceFileOffset && self.TargetFileOffset == other.TargetFileOffset && self.ByteCount == other.ByteCount && self.Flags == other.Flags
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for DUPLICATE_EXTENTS_DATA_EX {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for DUPLICATE_EXTENTS_DATA_EX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct ECP_HEADER(pub u8);
impl ::core::marker::Copy for ECP_HEADER {}
impl ::core::clone::Clone for ECP_HEADER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for ECP_HEADER {
    type TypeKind = ::windows_core::CopyType;
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct ECP_OPEN_PARAMETERS {
    pub Size: u16,
    pub Reserved: u16,
    pub Flags: u32,
}
impl ::core::marker::Copy for ECP_OPEN_PARAMETERS {}
impl ::core::clone::Clone for ECP_OPEN_PARAMETERS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for ECP_OPEN_PARAMETERS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ECP_OPEN_PARAMETERS").field("Size", &self.Size).field("Reserved", &self.Reserved).field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for ECP_OPEN_PARAMETERS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for ECP_OPEN_PARAMETERS {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.Reserved == other.Reserved && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for ECP_OPEN_PARAMETERS {}
impl ::core::default::Default for ECP_OPEN_PARAMETERS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct ENCRYPTED_DATA_INFO {
    pub StartingFileOffset: u64,
    pub OutputBufferOffset: u32,
    pub BytesWithinFileSize: u32,
    pub BytesWithinValidDataLength: u32,
    pub CompressionFormat: u16,
    pub DataUnitShift: u8,
    pub ChunkShift: u8,
    pub ClusterShift: u8,
    pub EncryptionFormat: u8,
    pub NumberOfDataBlocks: u16,
    pub DataBlockSize: [u32; 1],
}
impl ::core::marker::Copy for ENCRYPTED_DATA_INFO {}
impl ::core::clone::Clone for ENCRYPTED_DATA_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for ENCRYPTED_DATA_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ENCRYPTED_DATA_INFO")
            .field("StartingFileOffset", &self.StartingFileOffset)
            .field("OutputBufferOffset", &self.OutputBufferOffset)
            .field("BytesWithinFileSize", &self.BytesWithinFileSize)
            .field("BytesWithinValidDataLength", &self.BytesWithinValidDataLength)
            .field("CompressionFormat", &self.CompressionFormat)
            .field("DataUnitShift", &self.DataUnitShift)
            .field("ChunkShift", &self.ChunkShift)
            .field("ClusterShift", &self.ClusterShift)
            .field("EncryptionFormat", &self.EncryptionFormat)
            .field("NumberOfDataBlocks", &self.NumberOfDataBlocks)
            .field("DataBlockSize", &self.DataBlockSize)
            .finish()
    }
}
impl ::windows_core::TypeKind for ENCRYPTED_DATA_INFO {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for ENCRYPTED_DATA_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.StartingFileOffset == other.StartingFileOffset && self.OutputBufferOffset == other.OutputBufferOffset && self.BytesWithinFileSize == other.BytesWithinFileSize && self.BytesWithinValidDataLength == other.BytesWithinValidDataLength && self.CompressionFormat == other.CompressionFormat && self.DataUnitShift == other.DataUnitShift && self.ChunkShift == other.ChunkShift && self.ClusterShift == other.ClusterShift && self.EncryptionFormat == other.EncryptionFormat && self.NumberOfDataBlocks == other.NumberOfDataBlocks && self.DataBlockSize == other.DataBlockSize
    }
}
impl ::core::cmp::Eq for ENCRYPTED_DATA_INFO {}
impl ::core::default::Default for ENCRYPTED_DATA_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct ENCRYPTION_BUFFER {
    pub EncryptionOperation: u32,
    pub Private: [u8; 1],
}
impl ::core::marker::Copy for ENCRYPTION_BUFFER {}
impl ::core::clone::Clone for ENCRYPTION_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for ENCRYPTION_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ENCRYPTION_BUFFER").field("EncryptionOperation", &self.EncryptionOperation).field("Private", &self.Private).finish()
    }
}
impl ::windows_core::TypeKind for ENCRYPTION_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for ENCRYPTION_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.EncryptionOperation == other.EncryptionOperation && self.Private == other.Private
    }
}
impl ::core::cmp::Eq for ENCRYPTION_BUFFER {}
impl ::core::default::Default for ENCRYPTION_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct ENCRYPTION_KEY_CTRL_INPUT {
    pub HeaderSize: u32,
    pub StructureSize: u32,
    pub KeyOffset: u16,
    pub KeySize: u16,
    pub DplLock: u32,
    pub DplUserId: u64,
    pub DplCredentialId: u64,
}
impl ::core::marker::Copy for ENCRYPTION_KEY_CTRL_INPUT {}
impl ::core::clone::Clone for ENCRYPTION_KEY_CTRL_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for ENCRYPTION_KEY_CTRL_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ENCRYPTION_KEY_CTRL_INPUT").field("HeaderSize", &self.HeaderSize).field("StructureSize", &self.StructureSize).field("KeyOffset", &self.KeyOffset).field("KeySize", &self.KeySize).field("DplLock", &self.DplLock).field("DplUserId", &self.DplUserId).field("DplCredentialId", &self.DplCredentialId).finish()
    }
}
impl ::windows_core::TypeKind for ENCRYPTION_KEY_CTRL_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for ENCRYPTION_KEY_CTRL_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.HeaderSize == other.HeaderSize && self.StructureSize == other.StructureSize && self.KeyOffset == other.KeyOffset && self.KeySize == other.KeySize && self.DplLock == other.DplLock && self.DplUserId == other.DplUserId && self.DplCredentialId == other.DplCredentialId
    }
}
impl ::core::cmp::Eq for ENCRYPTION_KEY_CTRL_INPUT {}
impl ::core::default::Default for ENCRYPTION_KEY_CTRL_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
pub struct EOF_WAIT_BLOCK {
    pub EofWaitLinks: super::super::super::Win32::System::Kernel::LIST_ENTRY,
    pub Event: super::super::Foundation::KEVENT,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::marker::Copy for EOF_WAIT_BLOCK {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::clone::Clone for EOF_WAIT_BLOCK {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::windows_core::TypeKind for EOF_WAIT_BLOCK {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::default::Default for EOF_WAIT_BLOCK {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct EXFAT_STATISTICS {
    pub CreateHits: u32,
    pub SuccessfulCreates: u32,
    pub FailedCreates: u32,
    pub NonCachedReads: u32,
    pub NonCachedReadBytes: u32,
    pub NonCachedWrites: u32,
    pub NonCachedWriteBytes: u32,
    pub NonCachedDiskReads: u32,
    pub NonCachedDiskWrites: u32,
}
impl ::core::marker::Copy for EXFAT_STATISTICS {}
impl ::core::clone::Clone for EXFAT_STATISTICS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for EXFAT_STATISTICS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("EXFAT_STATISTICS")
            .field("CreateHits", &self.CreateHits)
            .field("SuccessfulCreates", &self.SuccessfulCreates)
            .field("FailedCreates", &self.FailedCreates)
            .field("NonCachedReads", &self.NonCachedReads)
            .field("NonCachedReadBytes", &self.NonCachedReadBytes)
            .field("NonCachedWrites", &self.NonCachedWrites)
            .field("NonCachedWriteBytes", &self.NonCachedWriteBytes)
            .field("NonCachedDiskReads", &self.NonCachedDiskReads)
            .field("NonCachedDiskWrites", &self.NonCachedDiskWrites)
            .finish()
    }
}
impl ::windows_core::TypeKind for EXFAT_STATISTICS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for EXFAT_STATISTICS {
    fn eq(&self, other: &Self) -> bool {
        self.CreateHits == other.CreateHits && self.SuccessfulCreates == other.SuccessfulCreates && self.FailedCreates == other.FailedCreates && self.NonCachedReads == other.NonCachedReads && self.NonCachedReadBytes == other.NonCachedReadBytes && self.NonCachedWrites == other.NonCachedWrites && self.NonCachedWriteBytes == other.NonCachedWriteBytes && self.NonCachedDiskReads == other.NonCachedDiskReads && self.NonCachedDiskWrites == other.NonCachedDiskWrites
    }
}
impl ::core::cmp::Eq for EXFAT_STATISTICS {}
impl ::core::default::Default for EXFAT_STATISTICS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct EXTENDED_ENCRYPTED_DATA_INFO {
    pub ExtendedCode: u32,
    pub Length: u32,
    pub Flags: u32,
    pub Reserved: u32,
}
impl ::core::marker::Copy for EXTENDED_ENCRYPTED_DATA_INFO {}
impl ::core::clone::Clone for EXTENDED_ENCRYPTED_DATA_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for EXTENDED_ENCRYPTED_DATA_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("EXTENDED_ENCRYPTED_DATA_INFO").field("ExtendedCode", &self.ExtendedCode).field("Length", &self.Length).field("Flags", &self.Flags).field("Reserved", &self.Reserved).finish()
    }
}
impl ::windows_core::TypeKind for EXTENDED_ENCRYPTED_DATA_INFO {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for EXTENDED_ENCRYPTED_DATA_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.ExtendedCode == other.ExtendedCode && self.Length == other.Length && self.Flags == other.Flags && self.Reserved == other.Reserved
    }
}
impl ::core::cmp::Eq for EXTENDED_ENCRYPTED_DATA_INFO {}
impl ::core::default::Default for EXTENDED_ENCRYPTED_DATA_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct EXTENT_READ_CACHE_INFO_BUFFER {
    pub AllocatedCache: i64,
    pub PopulatedCache: i64,
    pub InErrorCache: i64,
}
impl ::core::marker::Copy for EXTENT_READ_CACHE_INFO_BUFFER {}
impl ::core::clone::Clone for EXTENT_READ_CACHE_INFO_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for EXTENT_READ_CACHE_INFO_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("EXTENT_READ_CACHE_INFO_BUFFER").field("AllocatedCache", &self.AllocatedCache).field("PopulatedCache", &self.PopulatedCache).field("InErrorCache", &self.InErrorCache).finish()
    }
}
impl ::windows_core::TypeKind for EXTENT_READ_CACHE_INFO_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for EXTENT_READ_CACHE_INFO_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.AllocatedCache == other.AllocatedCache && self.PopulatedCache == other.PopulatedCache && self.InErrorCache == other.InErrorCache
    }
}
impl ::core::cmp::Eq for EXTENT_READ_CACHE_INFO_BUFFER {}
impl ::core::default::Default for EXTENT_READ_CACHE_INFO_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FAT_STATISTICS {
    pub CreateHits: u32,
    pub SuccessfulCreates: u32,
    pub FailedCreates: u32,
    pub NonCachedReads: u32,
    pub NonCachedReadBytes: u32,
    pub NonCachedWrites: u32,
    pub NonCachedWriteBytes: u32,
    pub NonCachedDiskReads: u32,
    pub NonCachedDiskWrites: u32,
}
impl ::core::marker::Copy for FAT_STATISTICS {}
impl ::core::clone::Clone for FAT_STATISTICS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FAT_STATISTICS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FAT_STATISTICS")
            .field("CreateHits", &self.CreateHits)
            .field("SuccessfulCreates", &self.SuccessfulCreates)
            .field("FailedCreates", &self.FailedCreates)
            .field("NonCachedReads", &self.NonCachedReads)
            .field("NonCachedReadBytes", &self.NonCachedReadBytes)
            .field("NonCachedWrites", &self.NonCachedWrites)
            .field("NonCachedWriteBytes", &self.NonCachedWriteBytes)
            .field("NonCachedDiskReads", &self.NonCachedDiskReads)
            .field("NonCachedDiskWrites", &self.NonCachedDiskWrites)
            .finish()
    }
}
impl ::windows_core::TypeKind for FAT_STATISTICS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FAT_STATISTICS {
    fn eq(&self, other: &Self) -> bool {
        self.CreateHits == other.CreateHits && self.SuccessfulCreates == other.SuccessfulCreates && self.FailedCreates == other.FailedCreates && self.NonCachedReads == other.NonCachedReads && self.NonCachedReadBytes == other.NonCachedReadBytes && self.NonCachedWrites == other.NonCachedWrites && self.NonCachedWriteBytes == other.NonCachedWriteBytes && self.NonCachedDiskReads == other.NonCachedDiskReads && self.NonCachedDiskWrites == other.NonCachedDiskWrites
    }
}
impl ::core::cmp::Eq for FAT_STATISTICS {}
impl ::core::default::Default for FAT_STATISTICS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILESYSTEM_STATISTICS {
    pub FileSystemType: u16,
    pub Version: u16,
    pub SizeOfCompleteStructure: u32,
    pub UserFileReads: u32,
    pub UserFileReadBytes: u32,
    pub UserDiskReads: u32,
    pub UserFileWrites: u32,
    pub UserFileWriteBytes: u32,
    pub UserDiskWrites: u32,
    pub MetaDataReads: u32,
    pub MetaDataReadBytes: u32,
    pub MetaDataDiskReads: u32,
    pub MetaDataWrites: u32,
    pub MetaDataWriteBytes: u32,
    pub MetaDataDiskWrites: u32,
}
impl ::core::marker::Copy for FILESYSTEM_STATISTICS {}
impl ::core::clone::Clone for FILESYSTEM_STATISTICS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILESYSTEM_STATISTICS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILESYSTEM_STATISTICS")
            .field("FileSystemType", &self.FileSystemType)
            .field("Version", &self.Version)
            .field("SizeOfCompleteStructure", &self.SizeOfCompleteStructure)
            .field("UserFileReads", &self.UserFileReads)
            .field("UserFileReadBytes", &self.UserFileReadBytes)
            .field("UserDiskReads", &self.UserDiskReads)
            .field("UserFileWrites", &self.UserFileWrites)
            .field("UserFileWriteBytes", &self.UserFileWriteBytes)
            .field("UserDiskWrites", &self.UserDiskWrites)
            .field("MetaDataReads", &self.MetaDataReads)
            .field("MetaDataReadBytes", &self.MetaDataReadBytes)
            .field("MetaDataDiskReads", &self.MetaDataDiskReads)
            .field("MetaDataWrites", &self.MetaDataWrites)
            .field("MetaDataWriteBytes", &self.MetaDataWriteBytes)
            .field("MetaDataDiskWrites", &self.MetaDataDiskWrites)
            .finish()
    }
}
impl ::windows_core::TypeKind for FILESYSTEM_STATISTICS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILESYSTEM_STATISTICS {
    fn eq(&self, other: &Self) -> bool {
        self.FileSystemType == other.FileSystemType && self.Version == other.Version && self.SizeOfCompleteStructure == other.SizeOfCompleteStructure && self.UserFileReads == other.UserFileReads && self.UserFileReadBytes == other.UserFileReadBytes && self.UserDiskReads == other.UserDiskReads && self.UserFileWrites == other.UserFileWrites && self.UserFileWriteBytes == other.UserFileWriteBytes && self.UserDiskWrites == other.UserDiskWrites && self.MetaDataReads == other.MetaDataReads && self.MetaDataReadBytes == other.MetaDataReadBytes && self.MetaDataDiskReads == other.MetaDataDiskReads && self.MetaDataWrites == other.MetaDataWrites && self.MetaDataWriteBytes == other.MetaDataWriteBytes && self.MetaDataDiskWrites == other.MetaDataDiskWrites
    }
}
impl ::core::cmp::Eq for FILESYSTEM_STATISTICS {}
impl ::core::default::Default for FILESYSTEM_STATISTICS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILESYSTEM_STATISTICS_EX {
    pub FileSystemType: u16,
    pub Version: u16,
    pub SizeOfCompleteStructure: u32,
    pub UserFileReads: u64,
    pub UserFileReadBytes: u64,
    pub UserDiskReads: u64,
    pub UserFileWrites: u64,
    pub UserFileWriteBytes: u64,
    pub UserDiskWrites: u64,
    pub MetaDataReads: u64,
    pub MetaDataReadBytes: u64,
    pub MetaDataDiskReads: u64,
    pub MetaDataWrites: u64,
    pub MetaDataWriteBytes: u64,
    pub MetaDataDiskWrites: u64,
}
impl ::core::marker::Copy for FILESYSTEM_STATISTICS_EX {}
impl ::core::clone::Clone for FILESYSTEM_STATISTICS_EX {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILESYSTEM_STATISTICS_EX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILESYSTEM_STATISTICS_EX")
            .field("FileSystemType", &self.FileSystemType)
            .field("Version", &self.Version)
            .field("SizeOfCompleteStructure", &self.SizeOfCompleteStructure)
            .field("UserFileReads", &self.UserFileReads)
            .field("UserFileReadBytes", &self.UserFileReadBytes)
            .field("UserDiskReads", &self.UserDiskReads)
            .field("UserFileWrites", &self.UserFileWrites)
            .field("UserFileWriteBytes", &self.UserFileWriteBytes)
            .field("UserDiskWrites", &self.UserDiskWrites)
            .field("MetaDataReads", &self.MetaDataReads)
            .field("MetaDataReadBytes", &self.MetaDataReadBytes)
            .field("MetaDataDiskReads", &self.MetaDataDiskReads)
            .field("MetaDataWrites", &self.MetaDataWrites)
            .field("MetaDataWriteBytes", &self.MetaDataWriteBytes)
            .field("MetaDataDiskWrites", &self.MetaDataDiskWrites)
            .finish()
    }
}
impl ::windows_core::TypeKind for FILESYSTEM_STATISTICS_EX {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILESYSTEM_STATISTICS_EX {
    fn eq(&self, other: &Self) -> bool {
        self.FileSystemType == other.FileSystemType && self.Version == other.Version && self.SizeOfCompleteStructure == other.SizeOfCompleteStructure && self.UserFileReads == other.UserFileReads && self.UserFileReadBytes == other.UserFileReadBytes && self.UserDiskReads == other.UserDiskReads && self.UserFileWrites == other.UserFileWrites && self.UserFileWriteBytes == other.UserFileWriteBytes && self.UserDiskWrites == other.UserDiskWrites && self.MetaDataReads == other.MetaDataReads && self.MetaDataReadBytes == other.MetaDataReadBytes && self.MetaDataDiskReads == other.MetaDataDiskReads && self.MetaDataWrites == other.MetaDataWrites && self.MetaDataWriteBytes == other.MetaDataWriteBytes && self.MetaDataDiskWrites == other.MetaDataDiskWrites
    }
}
impl ::core::cmp::Eq for FILESYSTEM_STATISTICS_EX {}
impl ::core::default::Default for FILESYSTEM_STATISTICS_EX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_ACCESS_INFORMATION {
    pub AccessFlags: u32,
}
impl ::core::marker::Copy for FILE_ACCESS_INFORMATION {}
impl ::core::clone::Clone for FILE_ACCESS_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_ACCESS_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_ACCESS_INFORMATION").field("AccessFlags", &self.AccessFlags).finish()
    }
}
impl ::windows_core::TypeKind for FILE_ACCESS_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_ACCESS_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.AccessFlags == other.AccessFlags
    }
}
impl ::core::cmp::Eq for FILE_ACCESS_INFORMATION {}
impl ::core::default::Default for FILE_ACCESS_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_ALIGNMENT_INFORMATION {
    pub AlignmentRequirement: u32,
}
impl ::core::marker::Copy for FILE_ALIGNMENT_INFORMATION {}
impl ::core::clone::Clone for FILE_ALIGNMENT_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_ALIGNMENT_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_ALIGNMENT_INFORMATION").field("AlignmentRequirement", &self.AlignmentRequirement).finish()
    }
}
impl ::windows_core::TypeKind for FILE_ALIGNMENT_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_ALIGNMENT_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.AlignmentRequirement == other.AlignmentRequirement
    }
}
impl ::core::cmp::Eq for FILE_ALIGNMENT_INFORMATION {}
impl ::core::default::Default for FILE_ALIGNMENT_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_ALLOCATED_RANGE_BUFFER {
    pub FileOffset: i64,
    pub Length: i64,
}
impl ::core::marker::Copy for FILE_ALLOCATED_RANGE_BUFFER {}
impl ::core::clone::Clone for FILE_ALLOCATED_RANGE_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_ALLOCATED_RANGE_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_ALLOCATED_RANGE_BUFFER").field("FileOffset", &self.FileOffset).field("Length", &self.Length).finish()
    }
}
impl ::windows_core::TypeKind for FILE_ALLOCATED_RANGE_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_ALLOCATED_RANGE_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.FileOffset == other.FileOffset && self.Length == other.Length
    }
}
impl ::core::cmp::Eq for FILE_ALLOCATED_RANGE_BUFFER {}
impl ::core::default::Default for FILE_ALLOCATED_RANGE_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_ALLOCATION_INFORMATION {
    pub AllocationSize: i64,
}
impl ::core::marker::Copy for FILE_ALLOCATION_INFORMATION {}
impl ::core::clone::Clone for FILE_ALLOCATION_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_ALLOCATION_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_ALLOCATION_INFORMATION").field("AllocationSize", &self.AllocationSize).finish()
    }
}
impl ::windows_core::TypeKind for FILE_ALLOCATION_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_ALLOCATION_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.AllocationSize == other.AllocationSize
    }
}
impl ::core::cmp::Eq for FILE_ALLOCATION_INFORMATION {}
impl ::core::default::Default for FILE_ALLOCATION_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct FILE_ALL_INFORMATION {
    pub BasicInformation: FILE_BASIC_INFORMATION,
    pub StandardInformation: FILE_STANDARD_INFORMATION,
    pub InternalInformation: FILE_INTERNAL_INFORMATION,
    pub EaInformation: FILE_EA_INFORMATION,
    pub AccessInformation: FILE_ACCESS_INFORMATION,
    pub PositionInformation: FILE_POSITION_INFORMATION,
    pub ModeInformation: FILE_MODE_INFORMATION,
    pub AlignmentInformation: FILE_ALIGNMENT_INFORMATION,
    pub NameInformation: FILE_NAME_INFORMATION,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FILE_ALL_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FILE_ALL_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for FILE_ALL_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_ALL_INFORMATION")
            .field("BasicInformation", &self.BasicInformation)
            .field("StandardInformation", &self.StandardInformation)
            .field("InternalInformation", &self.InternalInformation)
            .field("EaInformation", &self.EaInformation)
            .field("AccessInformation", &self.AccessInformation)
            .field("PositionInformation", &self.PositionInformation)
            .field("ModeInformation", &self.ModeInformation)
            .field("AlignmentInformation", &self.AlignmentInformation)
            .field("NameInformation", &self.NameInformation)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FILE_ALL_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for FILE_ALL_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.BasicInformation == other.BasicInformation && self.StandardInformation == other.StandardInformation && self.InternalInformation == other.InternalInformation && self.EaInformation == other.EaInformation && self.AccessInformation == other.AccessInformation && self.PositionInformation == other.PositionInformation && self.ModeInformation == other.ModeInformation && self.AlignmentInformation == other.AlignmentInformation && self.NameInformation == other.NameInformation
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for FILE_ALL_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FILE_ALL_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_BASIC_INFORMATION {
    pub CreationTime: i64,
    pub LastAccessTime: i64,
    pub LastWriteTime: i64,
    pub ChangeTime: i64,
    pub FileAttributes: u32,
}
impl ::core::marker::Copy for FILE_BASIC_INFORMATION {}
impl ::core::clone::Clone for FILE_BASIC_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_BASIC_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_BASIC_INFORMATION").field("CreationTime", &self.CreationTime).field("LastAccessTime", &self.LastAccessTime).field("LastWriteTime", &self.LastWriteTime).field("ChangeTime", &self.ChangeTime).field("FileAttributes", &self.FileAttributes).finish()
    }
}
impl ::windows_core::TypeKind for FILE_BASIC_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_BASIC_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.CreationTime == other.CreationTime && self.LastAccessTime == other.LastAccessTime && self.LastWriteTime == other.LastWriteTime && self.ChangeTime == other.ChangeTime && self.FileAttributes == other.FileAttributes
    }
}
impl ::core::cmp::Eq for FILE_BASIC_INFORMATION {}
impl ::core::default::Default for FILE_BASIC_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_BOTH_DIR_INFORMATION {
    pub NextEntryOffset: u32,
    pub FileIndex: u32,
    pub CreationTime: i64,
    pub LastAccessTime: i64,
    pub LastWriteTime: i64,
    pub ChangeTime: i64,
    pub EndOfFile: i64,
    pub AllocationSize: i64,
    pub FileAttributes: u32,
    pub FileNameLength: u32,
    pub EaSize: u32,
    pub ShortNameLength: i8,
    pub ShortName: [u16; 12],
    pub FileName: [u16; 1],
}
impl ::core::marker::Copy for FILE_BOTH_DIR_INFORMATION {}
impl ::core::clone::Clone for FILE_BOTH_DIR_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_BOTH_DIR_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_BOTH_DIR_INFORMATION")
            .field("NextEntryOffset", &self.NextEntryOffset)
            .field("FileIndex", &self.FileIndex)
            .field("CreationTime", &self.CreationTime)
            .field("LastAccessTime", &self.LastAccessTime)
            .field("LastWriteTime", &self.LastWriteTime)
            .field("ChangeTime", &self.ChangeTime)
            .field("EndOfFile", &self.EndOfFile)
            .field("AllocationSize", &self.AllocationSize)
            .field("FileAttributes", &self.FileAttributes)
            .field("FileNameLength", &self.FileNameLength)
            .field("EaSize", &self.EaSize)
            .field("ShortNameLength", &self.ShortNameLength)
            .field("ShortName", &self.ShortName)
            .field("FileName", &self.FileName)
            .finish()
    }
}
impl ::windows_core::TypeKind for FILE_BOTH_DIR_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_BOTH_DIR_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NextEntryOffset == other.NextEntryOffset && self.FileIndex == other.FileIndex && self.CreationTime == other.CreationTime && self.LastAccessTime == other.LastAccessTime && self.LastWriteTime == other.LastWriteTime && self.ChangeTime == other.ChangeTime && self.EndOfFile == other.EndOfFile && self.AllocationSize == other.AllocationSize && self.FileAttributes == other.FileAttributes && self.FileNameLength == other.FileNameLength && self.EaSize == other.EaSize && self.ShortNameLength == other.ShortNameLength && self.ShortName == other.ShortName && self.FileName == other.FileName
    }
}
impl ::core::cmp::Eq for FILE_BOTH_DIR_INFORMATION {}
impl ::core::default::Default for FILE_BOTH_DIR_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_CASE_SENSITIVE_INFORMATION {
    pub Flags: u32,
}
impl ::core::marker::Copy for FILE_CASE_SENSITIVE_INFORMATION {}
impl ::core::clone::Clone for FILE_CASE_SENSITIVE_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_CASE_SENSITIVE_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_CASE_SENSITIVE_INFORMATION").field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for FILE_CASE_SENSITIVE_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_CASE_SENSITIVE_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for FILE_CASE_SENSITIVE_INFORMATION {}
impl ::core::default::Default for FILE_CASE_SENSITIVE_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct FILE_COMPLETION_INFORMATION {
    pub Port: super::super::super::Win32::Foundation::HANDLE,
    pub Key: *mut ::core::ffi::c_void,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FILE_COMPLETION_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FILE_COMPLETION_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for FILE_COMPLETION_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_COMPLETION_INFORMATION").field("Port", &self.Port).field("Key", &self.Key).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FILE_COMPLETION_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for FILE_COMPLETION_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.Port == other.Port && self.Key == other.Key
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for FILE_COMPLETION_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FILE_COMPLETION_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_COMPRESSION_INFORMATION {
    pub CompressedFileSize: i64,
    pub CompressionFormat: u16,
    pub CompressionUnitShift: u8,
    pub ChunkShift: u8,
    pub ClusterShift: u8,
    pub Reserved: [u8; 3],
}
impl ::core::marker::Copy for FILE_COMPRESSION_INFORMATION {}
impl ::core::clone::Clone for FILE_COMPRESSION_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_COMPRESSION_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_COMPRESSION_INFORMATION").field("CompressedFileSize", &self.CompressedFileSize).field("CompressionFormat", &self.CompressionFormat).field("CompressionUnitShift", &self.CompressionUnitShift).field("ChunkShift", &self.ChunkShift).field("ClusterShift", &self.ClusterShift).field("Reserved", &self.Reserved).finish()
    }
}
impl ::windows_core::TypeKind for FILE_COMPRESSION_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_COMPRESSION_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.CompressedFileSize == other.CompressedFileSize && self.CompressionFormat == other.CompressionFormat && self.CompressionUnitShift == other.CompressionUnitShift && self.ChunkShift == other.ChunkShift && self.ClusterShift == other.ClusterShift && self.Reserved == other.Reserved
    }
}
impl ::core::cmp::Eq for FILE_COMPRESSION_INFORMATION {}
impl ::core::default::Default for FILE_COMPRESSION_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_DESIRED_STORAGE_CLASS_INFORMATION {
    pub Class: FILE_STORAGE_TIER_CLASS,
    pub Flags: u32,
}
impl ::core::marker::Copy for FILE_DESIRED_STORAGE_CLASS_INFORMATION {}
impl ::core::clone::Clone for FILE_DESIRED_STORAGE_CLASS_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_DESIRED_STORAGE_CLASS_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_DESIRED_STORAGE_CLASS_INFORMATION").field("Class", &self.Class).field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for FILE_DESIRED_STORAGE_CLASS_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_DESIRED_STORAGE_CLASS_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.Class == other.Class && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for FILE_DESIRED_STORAGE_CLASS_INFORMATION {}
impl ::core::default::Default for FILE_DESIRED_STORAGE_CLASS_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_DIRECTORY_INFORMATION {
    pub NextEntryOffset: u32,
    pub FileIndex: u32,
    pub CreationTime: i64,
    pub LastAccessTime: i64,
    pub LastWriteTime: i64,
    pub ChangeTime: i64,
    pub EndOfFile: i64,
    pub AllocationSize: i64,
    pub FileAttributes: u32,
    pub FileNameLength: u32,
    pub FileName: [u16; 1],
}
impl ::core::marker::Copy for FILE_DIRECTORY_INFORMATION {}
impl ::core::clone::Clone for FILE_DIRECTORY_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_DIRECTORY_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_DIRECTORY_INFORMATION")
            .field("NextEntryOffset", &self.NextEntryOffset)
            .field("FileIndex", &self.FileIndex)
            .field("CreationTime", &self.CreationTime)
            .field("LastAccessTime", &self.LastAccessTime)
            .field("LastWriteTime", &self.LastWriteTime)
            .field("ChangeTime", &self.ChangeTime)
            .field("EndOfFile", &self.EndOfFile)
            .field("AllocationSize", &self.AllocationSize)
            .field("FileAttributes", &self.FileAttributes)
            .field("FileNameLength", &self.FileNameLength)
            .field("FileName", &self.FileName)
            .finish()
    }
}
impl ::windows_core::TypeKind for FILE_DIRECTORY_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_DIRECTORY_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NextEntryOffset == other.NextEntryOffset && self.FileIndex == other.FileIndex && self.CreationTime == other.CreationTime && self.LastAccessTime == other.LastAccessTime && self.LastWriteTime == other.LastWriteTime && self.ChangeTime == other.ChangeTime && self.EndOfFile == other.EndOfFile && self.AllocationSize == other.AllocationSize && self.FileAttributes == other.FileAttributes && self.FileNameLength == other.FileNameLength && self.FileName == other.FileName
    }
}
impl ::core::cmp::Eq for FILE_DIRECTORY_INFORMATION {}
impl ::core::default::Default for FILE_DIRECTORY_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct FILE_DISPOSITION_INFORMATION {
    pub DeleteFile: super::super::super::Win32::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FILE_DISPOSITION_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FILE_DISPOSITION_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for FILE_DISPOSITION_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_DISPOSITION_INFORMATION").field("DeleteFile", &self.DeleteFile).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FILE_DISPOSITION_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for FILE_DISPOSITION_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.DeleteFile == other.DeleteFile
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for FILE_DISPOSITION_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FILE_DISPOSITION_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_DISPOSITION_INFORMATION_EX {
    pub Flags: FILE_DISPOSITION_INFORMATION_EX_FLAGS,
}
impl ::core::marker::Copy for FILE_DISPOSITION_INFORMATION_EX {}
impl ::core::clone::Clone for FILE_DISPOSITION_INFORMATION_EX {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_DISPOSITION_INFORMATION_EX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_DISPOSITION_INFORMATION_EX").field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for FILE_DISPOSITION_INFORMATION_EX {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_DISPOSITION_INFORMATION_EX {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for FILE_DISPOSITION_INFORMATION_EX {}
impl ::core::default::Default for FILE_DISPOSITION_INFORMATION_EX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_EA_INFORMATION {
    pub EaSize: u32,
}
impl ::core::marker::Copy for FILE_EA_INFORMATION {}
impl ::core::clone::Clone for FILE_EA_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_EA_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_EA_INFORMATION").field("EaSize", &self.EaSize).finish()
    }
}
impl ::windows_core::TypeKind for FILE_EA_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_EA_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.EaSize == other.EaSize
    }
}
impl ::core::cmp::Eq for FILE_EA_INFORMATION {}
impl ::core::default::Default for FILE_EA_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_END_OF_FILE_INFORMATION_EX {
    pub EndOfFile: i64,
    pub PagingFileSizeInMM: i64,
    pub PagingFileMaxSize: i64,
    pub Flags: u32,
}
impl ::core::marker::Copy for FILE_END_OF_FILE_INFORMATION_EX {}
impl ::core::clone::Clone for FILE_END_OF_FILE_INFORMATION_EX {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_END_OF_FILE_INFORMATION_EX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_END_OF_FILE_INFORMATION_EX").field("EndOfFile", &self.EndOfFile).field("PagingFileSizeInMM", &self.PagingFileSizeInMM).field("PagingFileMaxSize", &self.PagingFileMaxSize).field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for FILE_END_OF_FILE_INFORMATION_EX {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_END_OF_FILE_INFORMATION_EX {
    fn eq(&self, other: &Self) -> bool {
        self.EndOfFile == other.EndOfFile && self.PagingFileSizeInMM == other.PagingFileSizeInMM && self.PagingFileMaxSize == other.PagingFileMaxSize && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for FILE_END_OF_FILE_INFORMATION_EX {}
impl ::core::default::Default for FILE_END_OF_FILE_INFORMATION_EX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_FS_ATTRIBUTE_INFORMATION {
    pub FileSystemAttributes: u32,
    pub MaximumComponentNameLength: i32,
    pub FileSystemNameLength: u32,
    pub FileSystemName: [u16; 1],
}
impl ::core::marker::Copy for FILE_FS_ATTRIBUTE_INFORMATION {}
impl ::core::clone::Clone for FILE_FS_ATTRIBUTE_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_FS_ATTRIBUTE_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_FS_ATTRIBUTE_INFORMATION").field("FileSystemAttributes", &self.FileSystemAttributes).field("MaximumComponentNameLength", &self.MaximumComponentNameLength).field("FileSystemNameLength", &self.FileSystemNameLength).field("FileSystemName", &self.FileSystemName).finish()
    }
}
impl ::windows_core::TypeKind for FILE_FS_ATTRIBUTE_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_FS_ATTRIBUTE_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.FileSystemAttributes == other.FileSystemAttributes && self.MaximumComponentNameLength == other.MaximumComponentNameLength && self.FileSystemNameLength == other.FileSystemNameLength && self.FileSystemName == other.FileSystemName
    }
}
impl ::core::cmp::Eq for FILE_FS_ATTRIBUTE_INFORMATION {}
impl ::core::default::Default for FILE_FS_ATTRIBUTE_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_FS_CONTROL_INFORMATION {
    pub FreeSpaceStartFiltering: i64,
    pub FreeSpaceThreshold: i64,
    pub FreeSpaceStopFiltering: i64,
    pub DefaultQuotaThreshold: i64,
    pub DefaultQuotaLimit: i64,
    pub FileSystemControlFlags: u32,
}
impl ::core::marker::Copy for FILE_FS_CONTROL_INFORMATION {}
impl ::core::clone::Clone for FILE_FS_CONTROL_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_FS_CONTROL_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_FS_CONTROL_INFORMATION").field("FreeSpaceStartFiltering", &self.FreeSpaceStartFiltering).field("FreeSpaceThreshold", &self.FreeSpaceThreshold).field("FreeSpaceStopFiltering", &self.FreeSpaceStopFiltering).field("DefaultQuotaThreshold", &self.DefaultQuotaThreshold).field("DefaultQuotaLimit", &self.DefaultQuotaLimit).field("FileSystemControlFlags", &self.FileSystemControlFlags).finish()
    }
}
impl ::windows_core::TypeKind for FILE_FS_CONTROL_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_FS_CONTROL_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.FreeSpaceStartFiltering == other.FreeSpaceStartFiltering && self.FreeSpaceThreshold == other.FreeSpaceThreshold && self.FreeSpaceStopFiltering == other.FreeSpaceStopFiltering && self.DefaultQuotaThreshold == other.DefaultQuotaThreshold && self.DefaultQuotaLimit == other.DefaultQuotaLimit && self.FileSystemControlFlags == other.FileSystemControlFlags
    }
}
impl ::core::cmp::Eq for FILE_FS_CONTROL_INFORMATION {}
impl ::core::default::Default for FILE_FS_CONTROL_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_FS_DATA_COPY_INFORMATION {
    pub NumberOfCopies: u32,
}
impl ::core::marker::Copy for FILE_FS_DATA_COPY_INFORMATION {}
impl ::core::clone::Clone for FILE_FS_DATA_COPY_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_FS_DATA_COPY_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_FS_DATA_COPY_INFORMATION").field("NumberOfCopies", &self.NumberOfCopies).finish()
    }
}
impl ::windows_core::TypeKind for FILE_FS_DATA_COPY_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_FS_DATA_COPY_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NumberOfCopies == other.NumberOfCopies
    }
}
impl ::core::cmp::Eq for FILE_FS_DATA_COPY_INFORMATION {}
impl ::core::default::Default for FILE_FS_DATA_COPY_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct FILE_FS_DRIVER_PATH_INFORMATION {
    pub DriverInPath: super::super::super::Win32::Foundation::BOOLEAN,
    pub DriverNameLength: u32,
    pub DriverName: [u16; 1],
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FILE_FS_DRIVER_PATH_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FILE_FS_DRIVER_PATH_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for FILE_FS_DRIVER_PATH_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_FS_DRIVER_PATH_INFORMATION").field("DriverInPath", &self.DriverInPath).field("DriverNameLength", &self.DriverNameLength).field("DriverName", &self.DriverName).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FILE_FS_DRIVER_PATH_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for FILE_FS_DRIVER_PATH_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.DriverInPath == other.DriverInPath && self.DriverNameLength == other.DriverNameLength && self.DriverName == other.DriverName
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for FILE_FS_DRIVER_PATH_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FILE_FS_DRIVER_PATH_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_FS_PERSISTENT_VOLUME_INFORMATION {
    pub VolumeFlags: u32,
    pub FlagMask: u32,
    pub Version: u32,
    pub Reserved: u32,
}
impl ::core::marker::Copy for FILE_FS_PERSISTENT_VOLUME_INFORMATION {}
impl ::core::clone::Clone for FILE_FS_PERSISTENT_VOLUME_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_FS_PERSISTENT_VOLUME_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_FS_PERSISTENT_VOLUME_INFORMATION").field("VolumeFlags", &self.VolumeFlags).field("FlagMask", &self.FlagMask).field("Version", &self.Version).field("Reserved", &self.Reserved).finish()
    }
}
impl ::windows_core::TypeKind for FILE_FS_PERSISTENT_VOLUME_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_FS_PERSISTENT_VOLUME_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.VolumeFlags == other.VolumeFlags && self.FlagMask == other.FlagMask && self.Version == other.Version && self.Reserved == other.Reserved
    }
}
impl ::core::cmp::Eq for FILE_FS_PERSISTENT_VOLUME_INFORMATION {}
impl ::core::default::Default for FILE_FS_PERSISTENT_VOLUME_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_FS_SECTOR_SIZE_INFORMATION {
    pub LogicalBytesPerSector: u32,
    pub PhysicalBytesPerSectorForAtomicity: u32,
    pub PhysicalBytesPerSectorForPerformance: u32,
    pub FileSystemEffectivePhysicalBytesPerSectorForAtomicity: u32,
    pub Flags: u32,
    pub ByteOffsetForSectorAlignment: u32,
    pub ByteOffsetForPartitionAlignment: u32,
}
impl ::core::marker::Copy for FILE_FS_SECTOR_SIZE_INFORMATION {}
impl ::core::clone::Clone for FILE_FS_SECTOR_SIZE_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_FS_SECTOR_SIZE_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_FS_SECTOR_SIZE_INFORMATION")
            .field("LogicalBytesPerSector", &self.LogicalBytesPerSector)
            .field("PhysicalBytesPerSectorForAtomicity", &self.PhysicalBytesPerSectorForAtomicity)
            .field("PhysicalBytesPerSectorForPerformance", &self.PhysicalBytesPerSectorForPerformance)
            .field("FileSystemEffectivePhysicalBytesPerSectorForAtomicity", &self.FileSystemEffectivePhysicalBytesPerSectorForAtomicity)
            .field("Flags", &self.Flags)
            .field("ByteOffsetForSectorAlignment", &self.ByteOffsetForSectorAlignment)
            .field("ByteOffsetForPartitionAlignment", &self.ByteOffsetForPartitionAlignment)
            .finish()
    }
}
impl ::windows_core::TypeKind for FILE_FS_SECTOR_SIZE_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_FS_SECTOR_SIZE_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.LogicalBytesPerSector == other.LogicalBytesPerSector && self.PhysicalBytesPerSectorForAtomicity == other.PhysicalBytesPerSectorForAtomicity && self.PhysicalBytesPerSectorForPerformance == other.PhysicalBytesPerSectorForPerformance && self.FileSystemEffectivePhysicalBytesPerSectorForAtomicity == other.FileSystemEffectivePhysicalBytesPerSectorForAtomicity && self.Flags == other.Flags && self.ByteOffsetForSectorAlignment == other.ByteOffsetForSectorAlignment && self.ByteOffsetForPartitionAlignment == other.ByteOffsetForPartitionAlignment
    }
}
impl ::core::cmp::Eq for FILE_FS_SECTOR_SIZE_INFORMATION {}
impl ::core::default::Default for FILE_FS_SECTOR_SIZE_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_FS_VOLUME_FLAGS_INFORMATION {
    pub Flags: u32,
}
impl ::core::marker::Copy for FILE_FS_VOLUME_FLAGS_INFORMATION {}
impl ::core::clone::Clone for FILE_FS_VOLUME_FLAGS_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_FS_VOLUME_FLAGS_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_FS_VOLUME_FLAGS_INFORMATION").field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for FILE_FS_VOLUME_FLAGS_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_FS_VOLUME_FLAGS_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for FILE_FS_VOLUME_FLAGS_INFORMATION {}
impl ::core::default::Default for FILE_FS_VOLUME_FLAGS_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_FULL_DIR_INFORMATION {
    pub NextEntryOffset: u32,
    pub FileIndex: u32,
    pub CreationTime: i64,
    pub LastAccessTime: i64,
    pub LastWriteTime: i64,
    pub ChangeTime: i64,
    pub EndOfFile: i64,
    pub AllocationSize: i64,
    pub FileAttributes: u32,
    pub FileNameLength: u32,
    pub EaSize: u32,
    pub FileName: [u16; 1],
}
impl ::core::marker::Copy for FILE_FULL_DIR_INFORMATION {}
impl ::core::clone::Clone for FILE_FULL_DIR_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_FULL_DIR_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_FULL_DIR_INFORMATION")
            .field("NextEntryOffset", &self.NextEntryOffset)
            .field("FileIndex", &self.FileIndex)
            .field("CreationTime", &self.CreationTime)
            .field("LastAccessTime", &self.LastAccessTime)
            .field("LastWriteTime", &self.LastWriteTime)
            .field("ChangeTime", &self.ChangeTime)
            .field("EndOfFile", &self.EndOfFile)
            .field("AllocationSize", &self.AllocationSize)
            .field("FileAttributes", &self.FileAttributes)
            .field("FileNameLength", &self.FileNameLength)
            .field("EaSize", &self.EaSize)
            .field("FileName", &self.FileName)
            .finish()
    }
}
impl ::windows_core::TypeKind for FILE_FULL_DIR_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_FULL_DIR_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NextEntryOffset == other.NextEntryOffset && self.FileIndex == other.FileIndex && self.CreationTime == other.CreationTime && self.LastAccessTime == other.LastAccessTime && self.LastWriteTime == other.LastWriteTime && self.ChangeTime == other.ChangeTime && self.EndOfFile == other.EndOfFile && self.AllocationSize == other.AllocationSize && self.FileAttributes == other.FileAttributes && self.FileNameLength == other.FileNameLength && self.EaSize == other.EaSize && self.FileName == other.FileName
    }
}
impl ::core::cmp::Eq for FILE_FULL_DIR_INFORMATION {}
impl ::core::default::Default for FILE_FULL_DIR_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_FULL_EA_INFORMATION {
    pub NextEntryOffset: u32,
    pub Flags: u8,
    pub EaNameLength: u8,
    pub EaValueLength: u16,
    pub EaName: [u8; 1],
}
impl ::core::marker::Copy for FILE_FULL_EA_INFORMATION {}
impl ::core::clone::Clone for FILE_FULL_EA_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_FULL_EA_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_FULL_EA_INFORMATION").field("NextEntryOffset", &self.NextEntryOffset).field("Flags", &self.Flags).field("EaNameLength", &self.EaNameLength).field("EaValueLength", &self.EaValueLength).field("EaName", &self.EaName).finish()
    }
}
impl ::windows_core::TypeKind for FILE_FULL_EA_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_FULL_EA_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NextEntryOffset == other.NextEntryOffset && self.Flags == other.Flags && self.EaNameLength == other.EaNameLength && self.EaValueLength == other.EaValueLength && self.EaName == other.EaName
    }
}
impl ::core::cmp::Eq for FILE_FULL_EA_INFORMATION {}
impl ::core::default::Default for FILE_FULL_EA_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_GET_EA_INFORMATION {
    pub NextEntryOffset: u32,
    pub EaNameLength: u8,
    pub EaName: [u8; 1],
}
impl ::core::marker::Copy for FILE_GET_EA_INFORMATION {}
impl ::core::clone::Clone for FILE_GET_EA_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_GET_EA_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_GET_EA_INFORMATION").field("NextEntryOffset", &self.NextEntryOffset).field("EaNameLength", &self.EaNameLength).field("EaName", &self.EaName).finish()
    }
}
impl ::windows_core::TypeKind for FILE_GET_EA_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_GET_EA_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NextEntryOffset == other.NextEntryOffset && self.EaNameLength == other.EaNameLength && self.EaName == other.EaName
    }
}
impl ::core::cmp::Eq for FILE_GET_EA_INFORMATION {}
impl ::core::default::Default for FILE_GET_EA_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Security\"`*"]
#[cfg(feature = "Win32_Security")]
pub struct FILE_GET_QUOTA_INFORMATION {
    pub NextEntryOffset: u32,
    pub SidLength: u32,
    pub Sid: super::super::super::Win32::Security::SID,
}
#[cfg(feature = "Win32_Security")]
impl ::core::marker::Copy for FILE_GET_QUOTA_INFORMATION {}
#[cfg(feature = "Win32_Security")]
impl ::core::clone::Clone for FILE_GET_QUOTA_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Security")]
impl ::core::fmt::Debug for FILE_GET_QUOTA_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_GET_QUOTA_INFORMATION").field("NextEntryOffset", &self.NextEntryOffset).field("SidLength", &self.SidLength).field("Sid", &self.Sid).finish()
    }
}
#[cfg(feature = "Win32_Security")]
impl ::windows_core::TypeKind for FILE_GET_QUOTA_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Security")]
impl ::core::cmp::PartialEq for FILE_GET_QUOTA_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NextEntryOffset == other.NextEntryOffset && self.SidLength == other.SidLength && self.Sid == other.Sid
    }
}
#[cfg(feature = "Win32_Security")]
impl ::core::cmp::Eq for FILE_GET_QUOTA_INFORMATION {}
#[cfg(feature = "Win32_Security")]
impl ::core::default::Default for FILE_GET_QUOTA_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_ID_128 {
    pub Identifier: [u8; 16],
}
impl ::core::marker::Copy for FILE_ID_128 {}
impl ::core::clone::Clone for FILE_ID_128 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_ID_128 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_ID_128").field("Identifier", &self.Identifier).finish()
    }
}
impl ::windows_core::TypeKind for FILE_ID_128 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_ID_128 {
    fn eq(&self, other: &Self) -> bool {
        self.Identifier == other.Identifier
    }
}
impl ::core::cmp::Eq for FILE_ID_128 {}
impl ::core::default::Default for FILE_ID_128 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_ID_BOTH_DIR_INFORMATION {
    pub NextEntryOffset: u32,
    pub FileIndex: u32,
    pub CreationTime: i64,
    pub LastAccessTime: i64,
    pub LastWriteTime: i64,
    pub ChangeTime: i64,
    pub EndOfFile: i64,
    pub AllocationSize: i64,
    pub FileAttributes: u32,
    pub FileNameLength: u32,
    pub EaSize: u32,
    pub ShortNameLength: i8,
    pub ShortName: [u16; 12],
    pub FileId: i64,
    pub FileName: [u16; 1],
}
impl ::core::marker::Copy for FILE_ID_BOTH_DIR_INFORMATION {}
impl ::core::clone::Clone for FILE_ID_BOTH_DIR_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_ID_BOTH_DIR_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_ID_BOTH_DIR_INFORMATION")
            .field("NextEntryOffset", &self.NextEntryOffset)
            .field("FileIndex", &self.FileIndex)
            .field("CreationTime", &self.CreationTime)
            .field("LastAccessTime", &self.LastAccessTime)
            .field("LastWriteTime", &self.LastWriteTime)
            .field("ChangeTime", &self.ChangeTime)
            .field("EndOfFile", &self.EndOfFile)
            .field("AllocationSize", &self.AllocationSize)
            .field("FileAttributes", &self.FileAttributes)
            .field("FileNameLength", &self.FileNameLength)
            .field("EaSize", &self.EaSize)
            .field("ShortNameLength", &self.ShortNameLength)
            .field("ShortName", &self.ShortName)
            .field("FileId", &self.FileId)
            .field("FileName", &self.FileName)
            .finish()
    }
}
impl ::windows_core::TypeKind for FILE_ID_BOTH_DIR_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_ID_BOTH_DIR_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NextEntryOffset == other.NextEntryOffset && self.FileIndex == other.FileIndex && self.CreationTime == other.CreationTime && self.LastAccessTime == other.LastAccessTime && self.LastWriteTime == other.LastWriteTime && self.ChangeTime == other.ChangeTime && self.EndOfFile == other.EndOfFile && self.AllocationSize == other.AllocationSize && self.FileAttributes == other.FileAttributes && self.FileNameLength == other.FileNameLength && self.EaSize == other.EaSize && self.ShortNameLength == other.ShortNameLength && self.ShortName == other.ShortName && self.FileId == other.FileId && self.FileName == other.FileName
    }
}
impl ::core::cmp::Eq for FILE_ID_BOTH_DIR_INFORMATION {}
impl ::core::default::Default for FILE_ID_BOTH_DIR_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_ID_EXTD_BOTH_DIR_INFORMATION {
    pub NextEntryOffset: u32,
    pub FileIndex: u32,
    pub CreationTime: i64,
    pub LastAccessTime: i64,
    pub LastWriteTime: i64,
    pub ChangeTime: i64,
    pub EndOfFile: i64,
    pub AllocationSize: i64,
    pub FileAttributes: u32,
    pub FileNameLength: u32,
    pub EaSize: u32,
    pub ReparsePointTag: u32,
    pub FileId: FILE_ID_128,
    pub ShortNameLength: i8,
    pub ShortName: [u16; 12],
    pub FileName: [u16; 1],
}
impl ::core::marker::Copy for FILE_ID_EXTD_BOTH_DIR_INFORMATION {}
impl ::core::clone::Clone for FILE_ID_EXTD_BOTH_DIR_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_ID_EXTD_BOTH_DIR_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_ID_EXTD_BOTH_DIR_INFORMATION")
            .field("NextEntryOffset", &self.NextEntryOffset)
            .field("FileIndex", &self.FileIndex)
            .field("CreationTime", &self.CreationTime)
            .field("LastAccessTime", &self.LastAccessTime)
            .field("LastWriteTime", &self.LastWriteTime)
            .field("ChangeTime", &self.ChangeTime)
            .field("EndOfFile", &self.EndOfFile)
            .field("AllocationSize", &self.AllocationSize)
            .field("FileAttributes", &self.FileAttributes)
            .field("FileNameLength", &self.FileNameLength)
            .field("EaSize", &self.EaSize)
            .field("ReparsePointTag", &self.ReparsePointTag)
            .field("FileId", &self.FileId)
            .field("ShortNameLength", &self.ShortNameLength)
            .field("ShortName", &self.ShortName)
            .field("FileName", &self.FileName)
            .finish()
    }
}
impl ::windows_core::TypeKind for FILE_ID_EXTD_BOTH_DIR_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_ID_EXTD_BOTH_DIR_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NextEntryOffset == other.NextEntryOffset && self.FileIndex == other.FileIndex && self.CreationTime == other.CreationTime && self.LastAccessTime == other.LastAccessTime && self.LastWriteTime == other.LastWriteTime && self.ChangeTime == other.ChangeTime && self.EndOfFile == other.EndOfFile && self.AllocationSize == other.AllocationSize && self.FileAttributes == other.FileAttributes && self.FileNameLength == other.FileNameLength && self.EaSize == other.EaSize && self.ReparsePointTag == other.ReparsePointTag && self.FileId == other.FileId && self.ShortNameLength == other.ShortNameLength && self.ShortName == other.ShortName && self.FileName == other.FileName
    }
}
impl ::core::cmp::Eq for FILE_ID_EXTD_BOTH_DIR_INFORMATION {}
impl ::core::default::Default for FILE_ID_EXTD_BOTH_DIR_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_ID_EXTD_DIR_INFORMATION {
    pub NextEntryOffset: u32,
    pub FileIndex: u32,
    pub CreationTime: i64,
    pub LastAccessTime: i64,
    pub LastWriteTime: i64,
    pub ChangeTime: i64,
    pub EndOfFile: i64,
    pub AllocationSize: i64,
    pub FileAttributes: u32,
    pub FileNameLength: u32,
    pub EaSize: u32,
    pub ReparsePointTag: u32,
    pub FileId: FILE_ID_128,
    pub FileName: [u16; 1],
}
impl ::core::marker::Copy for FILE_ID_EXTD_DIR_INFORMATION {}
impl ::core::clone::Clone for FILE_ID_EXTD_DIR_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_ID_EXTD_DIR_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_ID_EXTD_DIR_INFORMATION")
            .field("NextEntryOffset", &self.NextEntryOffset)
            .field("FileIndex", &self.FileIndex)
            .field("CreationTime", &self.CreationTime)
            .field("LastAccessTime", &self.LastAccessTime)
            .field("LastWriteTime", &self.LastWriteTime)
            .field("ChangeTime", &self.ChangeTime)
            .field("EndOfFile", &self.EndOfFile)
            .field("AllocationSize", &self.AllocationSize)
            .field("FileAttributes", &self.FileAttributes)
            .field("FileNameLength", &self.FileNameLength)
            .field("EaSize", &self.EaSize)
            .field("ReparsePointTag", &self.ReparsePointTag)
            .field("FileId", &self.FileId)
            .field("FileName", &self.FileName)
            .finish()
    }
}
impl ::windows_core::TypeKind for FILE_ID_EXTD_DIR_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_ID_EXTD_DIR_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NextEntryOffset == other.NextEntryOffset && self.FileIndex == other.FileIndex && self.CreationTime == other.CreationTime && self.LastAccessTime == other.LastAccessTime && self.LastWriteTime == other.LastWriteTime && self.ChangeTime == other.ChangeTime && self.EndOfFile == other.EndOfFile && self.AllocationSize == other.AllocationSize && self.FileAttributes == other.FileAttributes && self.FileNameLength == other.FileNameLength && self.EaSize == other.EaSize && self.ReparsePointTag == other.ReparsePointTag && self.FileId == other.FileId && self.FileName == other.FileName
    }
}
impl ::core::cmp::Eq for FILE_ID_EXTD_DIR_INFORMATION {}
impl ::core::default::Default for FILE_ID_EXTD_DIR_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_ID_FULL_DIR_INFORMATION {
    pub NextEntryOffset: u32,
    pub FileIndex: u32,
    pub CreationTime: i64,
    pub LastAccessTime: i64,
    pub LastWriteTime: i64,
    pub ChangeTime: i64,
    pub EndOfFile: i64,
    pub AllocationSize: i64,
    pub FileAttributes: u32,
    pub FileNameLength: u32,
    pub EaSize: u32,
    pub FileId: i64,
    pub FileName: [u16; 1],
}
impl ::core::marker::Copy for FILE_ID_FULL_DIR_INFORMATION {}
impl ::core::clone::Clone for FILE_ID_FULL_DIR_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_ID_FULL_DIR_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_ID_FULL_DIR_INFORMATION")
            .field("NextEntryOffset", &self.NextEntryOffset)
            .field("FileIndex", &self.FileIndex)
            .field("CreationTime", &self.CreationTime)
            .field("LastAccessTime", &self.LastAccessTime)
            .field("LastWriteTime", &self.LastWriteTime)
            .field("ChangeTime", &self.ChangeTime)
            .field("EndOfFile", &self.EndOfFile)
            .field("AllocationSize", &self.AllocationSize)
            .field("FileAttributes", &self.FileAttributes)
            .field("FileNameLength", &self.FileNameLength)
            .field("EaSize", &self.EaSize)
            .field("FileId", &self.FileId)
            .field("FileName", &self.FileName)
            .finish()
    }
}
impl ::windows_core::TypeKind for FILE_ID_FULL_DIR_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_ID_FULL_DIR_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NextEntryOffset == other.NextEntryOffset && self.FileIndex == other.FileIndex && self.CreationTime == other.CreationTime && self.LastAccessTime == other.LastAccessTime && self.LastWriteTime == other.LastWriteTime && self.ChangeTime == other.ChangeTime && self.EndOfFile == other.EndOfFile && self.AllocationSize == other.AllocationSize && self.FileAttributes == other.FileAttributes && self.FileNameLength == other.FileNameLength && self.EaSize == other.EaSize && self.FileId == other.FileId && self.FileName == other.FileName
    }
}
impl ::core::cmp::Eq for FILE_ID_FULL_DIR_INFORMATION {}
impl ::core::default::Default for FILE_ID_FULL_DIR_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_ID_GLOBAL_TX_DIR_INFORMATION {
    pub NextEntryOffset: u32,
    pub FileIndex: u32,
    pub CreationTime: i64,
    pub LastAccessTime: i64,
    pub LastWriteTime: i64,
    pub ChangeTime: i64,
    pub EndOfFile: i64,
    pub AllocationSize: i64,
    pub FileAttributes: u32,
    pub FileNameLength: u32,
    pub FileId: i64,
    pub LockingTransactionId: ::windows_core::GUID,
    pub TxInfoFlags: u32,
    pub FileName: [u16; 1],
}
impl ::core::marker::Copy for FILE_ID_GLOBAL_TX_DIR_INFORMATION {}
impl ::core::clone::Clone for FILE_ID_GLOBAL_TX_DIR_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_ID_GLOBAL_TX_DIR_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_ID_GLOBAL_TX_DIR_INFORMATION")
            .field("NextEntryOffset", &self.NextEntryOffset)
            .field("FileIndex", &self.FileIndex)
            .field("CreationTime", &self.CreationTime)
            .field("LastAccessTime", &self.LastAccessTime)
            .field("LastWriteTime", &self.LastWriteTime)
            .field("ChangeTime", &self.ChangeTime)
            .field("EndOfFile", &self.EndOfFile)
            .field("AllocationSize", &self.AllocationSize)
            .field("FileAttributes", &self.FileAttributes)
            .field("FileNameLength", &self.FileNameLength)
            .field("FileId", &self.FileId)
            .field("LockingTransactionId", &self.LockingTransactionId)
            .field("TxInfoFlags", &self.TxInfoFlags)
            .field("FileName", &self.FileName)
            .finish()
    }
}
impl ::windows_core::TypeKind for FILE_ID_GLOBAL_TX_DIR_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_ID_GLOBAL_TX_DIR_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NextEntryOffset == other.NextEntryOffset && self.FileIndex == other.FileIndex && self.CreationTime == other.CreationTime && self.LastAccessTime == other.LastAccessTime && self.LastWriteTime == other.LastWriteTime && self.ChangeTime == other.ChangeTime && self.EndOfFile == other.EndOfFile && self.AllocationSize == other.AllocationSize && self.FileAttributes == other.FileAttributes && self.FileNameLength == other.FileNameLength && self.FileId == other.FileId && self.LockingTransactionId == other.LockingTransactionId && self.TxInfoFlags == other.TxInfoFlags && self.FileName == other.FileName
    }
}
impl ::core::cmp::Eq for FILE_ID_GLOBAL_TX_DIR_INFORMATION {}
impl ::core::default::Default for FILE_ID_GLOBAL_TX_DIR_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_ID_INFORMATION {
    pub VolumeSerialNumber: u64,
    pub FileId: FILE_ID_128,
}
impl ::core::marker::Copy for FILE_ID_INFORMATION {}
impl ::core::clone::Clone for FILE_ID_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_ID_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_ID_INFORMATION").field("VolumeSerialNumber", &self.VolumeSerialNumber).field("FileId", &self.FileId).finish()
    }
}
impl ::windows_core::TypeKind for FILE_ID_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_ID_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.VolumeSerialNumber == other.VolumeSerialNumber && self.FileId == other.FileId
    }
}
impl ::core::cmp::Eq for FILE_ID_INFORMATION {}
impl ::core::default::Default for FILE_ID_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(feature = "Win32_System_WindowsProgramming")]
pub struct FILE_INFORMATION_DEFINITION {
    pub Class: super::super::super::Win32::System::WindowsProgramming::FILE_INFORMATION_CLASS,
    pub NextEntryOffset: u32,
    pub FileNameLengthOffset: u32,
    pub FileNameOffset: u32,
}
#[cfg(feature = "Win32_System_WindowsProgramming")]
impl ::core::marker::Copy for FILE_INFORMATION_DEFINITION {}
#[cfg(feature = "Win32_System_WindowsProgramming")]
impl ::core::clone::Clone for FILE_INFORMATION_DEFINITION {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_System_WindowsProgramming")]
impl ::core::fmt::Debug for FILE_INFORMATION_DEFINITION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_INFORMATION_DEFINITION").field("Class", &self.Class).field("NextEntryOffset", &self.NextEntryOffset).field("FileNameLengthOffset", &self.FileNameLengthOffset).field("FileNameOffset", &self.FileNameOffset).finish()
    }
}
#[cfg(feature = "Win32_System_WindowsProgramming")]
impl ::windows_core::TypeKind for FILE_INFORMATION_DEFINITION {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_System_WindowsProgramming")]
impl ::core::cmp::PartialEq for FILE_INFORMATION_DEFINITION {
    fn eq(&self, other: &Self) -> bool {
        self.Class == other.Class && self.NextEntryOffset == other.NextEntryOffset && self.FileNameLengthOffset == other.FileNameLengthOffset && self.FileNameOffset == other.FileNameOffset
    }
}
#[cfg(feature = "Win32_System_WindowsProgramming")]
impl ::core::cmp::Eq for FILE_INFORMATION_DEFINITION {}
#[cfg(feature = "Win32_System_WindowsProgramming")]
impl ::core::default::Default for FILE_INFORMATION_DEFINITION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct FILE_INITIATE_REPAIR_OUTPUT_BUFFER {
    pub Hint1: u64,
    pub Hint2: u64,
    pub Clsn: u64,
    pub Status: super::super::super::Win32::Foundation::NTSTATUS,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FILE_INITIATE_REPAIR_OUTPUT_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FILE_INITIATE_REPAIR_OUTPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for FILE_INITIATE_REPAIR_OUTPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_INITIATE_REPAIR_OUTPUT_BUFFER").field("Hint1", &self.Hint1).field("Hint2", &self.Hint2).field("Clsn", &self.Clsn).field("Status", &self.Status).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FILE_INITIATE_REPAIR_OUTPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for FILE_INITIATE_REPAIR_OUTPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.Hint1 == other.Hint1 && self.Hint2 == other.Hint2 && self.Clsn == other.Clsn && self.Status == other.Status
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for FILE_INITIATE_REPAIR_OUTPUT_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FILE_INITIATE_REPAIR_OUTPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_INTERNAL_INFORMATION {
    pub IndexNumber: i64,
}
impl ::core::marker::Copy for FILE_INTERNAL_INFORMATION {}
impl ::core::clone::Clone for FILE_INTERNAL_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_INTERNAL_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_INTERNAL_INFORMATION").field("IndexNumber", &self.IndexNumber).finish()
    }
}
impl ::windows_core::TypeKind for FILE_INTERNAL_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_INTERNAL_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.IndexNumber == other.IndexNumber
    }
}
impl ::core::cmp::Eq for FILE_INTERNAL_INFORMATION {}
impl ::core::default::Default for FILE_INTERNAL_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_KNOWN_FOLDER_INFORMATION {
    pub Type: FILE_KNOWN_FOLDER_TYPE,
}
impl ::core::marker::Copy for FILE_KNOWN_FOLDER_INFORMATION {}
impl ::core::clone::Clone for FILE_KNOWN_FOLDER_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_KNOWN_FOLDER_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_KNOWN_FOLDER_INFORMATION").field("Type", &self.Type).finish()
    }
}
impl ::windows_core::TypeKind for FILE_KNOWN_FOLDER_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_KNOWN_FOLDER_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type
    }
}
impl ::core::cmp::Eq for FILE_KNOWN_FOLDER_INFORMATION {}
impl ::core::default::Default for FILE_KNOWN_FOLDER_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_LAYOUT_ENTRY {
    pub Version: u32,
    pub NextFileOffset: u32,
    pub Flags: u32,
    pub FileAttributes: u32,
    pub FileReferenceNumber: u64,
    pub FirstNameOffset: u32,
    pub FirstStreamOffset: u32,
    pub ExtraInfoOffset: u32,
    pub ExtraInfoLength: u32,
}
impl ::core::marker::Copy for FILE_LAYOUT_ENTRY {}
impl ::core::clone::Clone for FILE_LAYOUT_ENTRY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_LAYOUT_ENTRY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_LAYOUT_ENTRY").field("Version", &self.Version).field("NextFileOffset", &self.NextFileOffset).field("Flags", &self.Flags).field("FileAttributes", &self.FileAttributes).field("FileReferenceNumber", &self.FileReferenceNumber).field("FirstNameOffset", &self.FirstNameOffset).field("FirstStreamOffset", &self.FirstStreamOffset).field("ExtraInfoOffset", &self.ExtraInfoOffset).field("ExtraInfoLength", &self.ExtraInfoLength).finish()
    }
}
impl ::windows_core::TypeKind for FILE_LAYOUT_ENTRY {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_LAYOUT_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.NextFileOffset == other.NextFileOffset && self.Flags == other.Flags && self.FileAttributes == other.FileAttributes && self.FileReferenceNumber == other.FileReferenceNumber && self.FirstNameOffset == other.FirstNameOffset && self.FirstStreamOffset == other.FirstStreamOffset && self.ExtraInfoOffset == other.ExtraInfoOffset && self.ExtraInfoLength == other.ExtraInfoLength
    }
}
impl ::core::cmp::Eq for FILE_LAYOUT_ENTRY {}
impl ::core::default::Default for FILE_LAYOUT_ENTRY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_LAYOUT_INFO_ENTRY {
    pub BasicInformation: FILE_LAYOUT_INFO_ENTRY_0,
    pub OwnerId: u32,
    pub SecurityId: u32,
    pub Usn: i64,
    pub StorageReserveId: STORAGE_RESERVE_ID,
}
impl ::core::marker::Copy for FILE_LAYOUT_INFO_ENTRY {}
impl ::core::clone::Clone for FILE_LAYOUT_INFO_ENTRY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_LAYOUT_INFO_ENTRY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_LAYOUT_INFO_ENTRY").field("BasicInformation", &self.BasicInformation).field("OwnerId", &self.OwnerId).field("SecurityId", &self.SecurityId).field("Usn", &self.Usn).field("StorageReserveId", &self.StorageReserveId).finish()
    }
}
impl ::windows_core::TypeKind for FILE_LAYOUT_INFO_ENTRY {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_LAYOUT_INFO_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.BasicInformation == other.BasicInformation && self.OwnerId == other.OwnerId && self.SecurityId == other.SecurityId && self.Usn == other.Usn && self.StorageReserveId == other.StorageReserveId
    }
}
impl ::core::cmp::Eq for FILE_LAYOUT_INFO_ENTRY {}
impl ::core::default::Default for FILE_LAYOUT_INFO_ENTRY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_LAYOUT_INFO_ENTRY_0 {
    pub CreationTime: i64,
    pub LastAccessTime: i64,
    pub LastWriteTime: i64,
    pub ChangeTime: i64,
    pub FileAttributes: u32,
}
impl ::core::marker::Copy for FILE_LAYOUT_INFO_ENTRY_0 {}
impl ::core::clone::Clone for FILE_LAYOUT_INFO_ENTRY_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_LAYOUT_INFO_ENTRY_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_LAYOUT_INFO_ENTRY_0").field("CreationTime", &self.CreationTime).field("LastAccessTime", &self.LastAccessTime).field("LastWriteTime", &self.LastWriteTime).field("ChangeTime", &self.ChangeTime).field("FileAttributes", &self.FileAttributes).finish()
    }
}
impl ::windows_core::TypeKind for FILE_LAYOUT_INFO_ENTRY_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_LAYOUT_INFO_ENTRY_0 {
    fn eq(&self, other: &Self) -> bool {
        self.CreationTime == other.CreationTime && self.LastAccessTime == other.LastAccessTime && self.LastWriteTime == other.LastWriteTime && self.ChangeTime == other.ChangeTime && self.FileAttributes == other.FileAttributes
    }
}
impl ::core::cmp::Eq for FILE_LAYOUT_INFO_ENTRY_0 {}
impl ::core::default::Default for FILE_LAYOUT_INFO_ENTRY_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_LAYOUT_NAME_ENTRY {
    pub NextNameOffset: u32,
    pub Flags: u32,
    pub ParentFileReferenceNumber: u64,
    pub FileNameLength: u32,
    pub Reserved: u32,
    pub FileName: [u16; 1],
}
impl ::core::marker::Copy for FILE_LAYOUT_NAME_ENTRY {}
impl ::core::clone::Clone for FILE_LAYOUT_NAME_ENTRY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_LAYOUT_NAME_ENTRY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_LAYOUT_NAME_ENTRY").field("NextNameOffset", &self.NextNameOffset).field("Flags", &self.Flags).field("ParentFileReferenceNumber", &self.ParentFileReferenceNumber).field("FileNameLength", &self.FileNameLength).field("Reserved", &self.Reserved).field("FileName", &self.FileName).finish()
    }
}
impl ::windows_core::TypeKind for FILE_LAYOUT_NAME_ENTRY {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_LAYOUT_NAME_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.NextNameOffset == other.NextNameOffset && self.Flags == other.Flags && self.ParentFileReferenceNumber == other.ParentFileReferenceNumber && self.FileNameLength == other.FileNameLength && self.Reserved == other.Reserved && self.FileName == other.FileName
    }
}
impl ::core::cmp::Eq for FILE_LAYOUT_NAME_ENTRY {}
impl ::core::default::Default for FILE_LAYOUT_NAME_ENTRY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_LEVEL_TRIM {
    pub Key: u32,
    pub NumRanges: u32,
    pub Ranges: [FILE_LEVEL_TRIM_RANGE; 1],
}
impl ::core::marker::Copy for FILE_LEVEL_TRIM {}
impl ::core::clone::Clone for FILE_LEVEL_TRIM {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_LEVEL_TRIM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_LEVEL_TRIM").field("Key", &self.Key).field("NumRanges", &self.NumRanges).field("Ranges", &self.Ranges).finish()
    }
}
impl ::windows_core::TypeKind for FILE_LEVEL_TRIM {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_LEVEL_TRIM {
    fn eq(&self, other: &Self) -> bool {
        self.Key == other.Key && self.NumRanges == other.NumRanges && self.Ranges == other.Ranges
    }
}
impl ::core::cmp::Eq for FILE_LEVEL_TRIM {}
impl ::core::default::Default for FILE_LEVEL_TRIM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_LEVEL_TRIM_OUTPUT {
    pub NumRangesProcessed: u32,
}
impl ::core::marker::Copy for FILE_LEVEL_TRIM_OUTPUT {}
impl ::core::clone::Clone for FILE_LEVEL_TRIM_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_LEVEL_TRIM_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_LEVEL_TRIM_OUTPUT").field("NumRangesProcessed", &self.NumRangesProcessed).finish()
    }
}
impl ::windows_core::TypeKind for FILE_LEVEL_TRIM_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_LEVEL_TRIM_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.NumRangesProcessed == other.NumRangesProcessed
    }
}
impl ::core::cmp::Eq for FILE_LEVEL_TRIM_OUTPUT {}
impl ::core::default::Default for FILE_LEVEL_TRIM_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_LEVEL_TRIM_RANGE {
    pub Offset: u64,
    pub Length: u64,
}
impl ::core::marker::Copy for FILE_LEVEL_TRIM_RANGE {}
impl ::core::clone::Clone for FILE_LEVEL_TRIM_RANGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_LEVEL_TRIM_RANGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_LEVEL_TRIM_RANGE").field("Offset", &self.Offset).field("Length", &self.Length).finish()
    }
}
impl ::windows_core::TypeKind for FILE_LEVEL_TRIM_RANGE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_LEVEL_TRIM_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.Offset == other.Offset && self.Length == other.Length
    }
}
impl ::core::cmp::Eq for FILE_LEVEL_TRIM_RANGE {}
impl ::core::default::Default for FILE_LEVEL_TRIM_RANGE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_LINKS_FULL_ID_INFORMATION {
    pub BytesNeeded: u32,
    pub EntriesReturned: u32,
    pub Entry: FILE_LINK_ENTRY_FULL_ID_INFORMATION,
}
impl ::core::marker::Copy for FILE_LINKS_FULL_ID_INFORMATION {}
impl ::core::clone::Clone for FILE_LINKS_FULL_ID_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_LINKS_FULL_ID_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_LINKS_FULL_ID_INFORMATION").field("BytesNeeded", &self.BytesNeeded).field("EntriesReturned", &self.EntriesReturned).field("Entry", &self.Entry).finish()
    }
}
impl ::windows_core::TypeKind for FILE_LINKS_FULL_ID_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_LINKS_FULL_ID_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.BytesNeeded == other.BytesNeeded && self.EntriesReturned == other.EntriesReturned && self.Entry == other.Entry
    }
}
impl ::core::cmp::Eq for FILE_LINKS_FULL_ID_INFORMATION {}
impl ::core::default::Default for FILE_LINKS_FULL_ID_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_LINKS_INFORMATION {
    pub BytesNeeded: u32,
    pub EntriesReturned: u32,
    pub Entry: FILE_LINK_ENTRY_INFORMATION,
}
impl ::core::marker::Copy for FILE_LINKS_INFORMATION {}
impl ::core::clone::Clone for FILE_LINKS_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_LINKS_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_LINKS_INFORMATION").field("BytesNeeded", &self.BytesNeeded).field("EntriesReturned", &self.EntriesReturned).field("Entry", &self.Entry).finish()
    }
}
impl ::windows_core::TypeKind for FILE_LINKS_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_LINKS_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.BytesNeeded == other.BytesNeeded && self.EntriesReturned == other.EntriesReturned && self.Entry == other.Entry
    }
}
impl ::core::cmp::Eq for FILE_LINKS_INFORMATION {}
impl ::core::default::Default for FILE_LINKS_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_LINK_ENTRY_FULL_ID_INFORMATION {
    pub NextEntryOffset: u32,
    pub ParentFileId: FILE_ID_128,
    pub FileNameLength: u32,
    pub FileName: [u16; 1],
}
impl ::core::marker::Copy for FILE_LINK_ENTRY_FULL_ID_INFORMATION {}
impl ::core::clone::Clone for FILE_LINK_ENTRY_FULL_ID_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_LINK_ENTRY_FULL_ID_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_LINK_ENTRY_FULL_ID_INFORMATION").field("NextEntryOffset", &self.NextEntryOffset).field("ParentFileId", &self.ParentFileId).field("FileNameLength", &self.FileNameLength).field("FileName", &self.FileName).finish()
    }
}
impl ::windows_core::TypeKind for FILE_LINK_ENTRY_FULL_ID_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_LINK_ENTRY_FULL_ID_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NextEntryOffset == other.NextEntryOffset && self.ParentFileId == other.ParentFileId && self.FileNameLength == other.FileNameLength && self.FileName == other.FileName
    }
}
impl ::core::cmp::Eq for FILE_LINK_ENTRY_FULL_ID_INFORMATION {}
impl ::core::default::Default for FILE_LINK_ENTRY_FULL_ID_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_LINK_ENTRY_INFORMATION {
    pub NextEntryOffset: u32,
    pub ParentFileId: i64,
    pub FileNameLength: u32,
    pub FileName: [u16; 1],
}
impl ::core::marker::Copy for FILE_LINK_ENTRY_INFORMATION {}
impl ::core::clone::Clone for FILE_LINK_ENTRY_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_LINK_ENTRY_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_LINK_ENTRY_INFORMATION").field("NextEntryOffset", &self.NextEntryOffset).field("ParentFileId", &self.ParentFileId).field("FileNameLength", &self.FileNameLength).field("FileName", &self.FileName).finish()
    }
}
impl ::windows_core::TypeKind for FILE_LINK_ENTRY_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_LINK_ENTRY_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NextEntryOffset == other.NextEntryOffset && self.ParentFileId == other.ParentFileId && self.FileNameLength == other.FileNameLength && self.FileName == other.FileName
    }
}
impl ::core::cmp::Eq for FILE_LINK_ENTRY_INFORMATION {}
impl ::core::default::Default for FILE_LINK_ENTRY_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct FILE_LINK_INFORMATION {
    pub Anonymous: FILE_LINK_INFORMATION_0,
    pub RootDirectory: super::super::super::Win32::Foundation::HANDLE,
    pub FileNameLength: u32,
    pub FileName: [u16; 1],
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FILE_LINK_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FILE_LINK_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FILE_LINK_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FILE_LINK_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub union FILE_LINK_INFORMATION_0 {
    pub ReplaceIfExists: super::super::super::Win32::Foundation::BOOLEAN,
    pub Flags: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FILE_LINK_INFORMATION_0 {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FILE_LINK_INFORMATION_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FILE_LINK_INFORMATION_0 {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FILE_LINK_INFORMATION_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub struct FILE_LOCK {
    pub CompleteLockIrpRoutine: PCOMPLETE_LOCK_IRP_ROUTINE,
    pub UnlockRoutine: PUNLOCK_ROUTINE,
    pub FastIoIsQuestionable: super::super::super::Win32::Foundation::BOOLEAN,
    pub SpareC: [super::super::super::Win32::Foundation::BOOLEAN; 3],
    pub LockInformation: *mut ::core::ffi::c_void,
    pub LastReturnedLockInfo: FILE_LOCK_INFO,
    pub LastReturnedLock: *mut ::core::ffi::c_void,
    pub LockRequestsInProgress: i32,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::marker::Copy for FILE_LOCK {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::clone::Clone for FILE_LOCK {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::fmt::Debug for FILE_LOCK {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_LOCK").field("FastIoIsQuestionable", &self.FastIoIsQuestionable).field("SpareC", &self.SpareC).field("LockInformation", &self.LockInformation).field("LastReturnedLockInfo", &self.LastReturnedLockInfo).field("LastReturnedLock", &self.LastReturnedLock).field("LockRequestsInProgress", &self.LockRequestsInProgress).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::windows_core::TypeKind for FILE_LOCK {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::default::Default for FILE_LOCK {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub struct FILE_LOCK_INFO {
    pub StartingByte: i64,
    pub Length: i64,
    pub ExclusiveLock: super::super::super::Win32::Foundation::BOOLEAN,
    pub Key: u32,
    pub FileObject: *mut super::super::Foundation::FILE_OBJECT,
    pub ProcessId: *mut ::core::ffi::c_void,
    pub EndingByte: i64,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::marker::Copy for FILE_LOCK_INFO {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::clone::Clone for FILE_LOCK_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::fmt::Debug for FILE_LOCK_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_LOCK_INFO").field("StartingByte", &self.StartingByte).field("Length", &self.Length).field("ExclusiveLock", &self.ExclusiveLock).field("Key", &self.Key).field("FileObject", &self.FileObject).field("ProcessId", &self.ProcessId).field("EndingByte", &self.EndingByte).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::windows_core::TypeKind for FILE_LOCK_INFO {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::cmp::PartialEq for FILE_LOCK_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.StartingByte == other.StartingByte && self.Length == other.Length && self.ExclusiveLock == other.ExclusiveLock && self.Key == other.Key && self.FileObject == other.FileObject && self.ProcessId == other.ProcessId && self.EndingByte == other.EndingByte
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::cmp::Eq for FILE_LOCK_INFO {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::default::Default for FILE_LOCK_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_MAILSLOT_QUERY_INFORMATION {
    pub MaximumMessageSize: u32,
    pub MailslotQuota: u32,
    pub NextMessageSize: u32,
    pub MessagesAvailable: u32,
    pub ReadTimeout: i64,
}
impl ::core::marker::Copy for FILE_MAILSLOT_QUERY_INFORMATION {}
impl ::core::clone::Clone for FILE_MAILSLOT_QUERY_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_MAILSLOT_QUERY_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_MAILSLOT_QUERY_INFORMATION").field("MaximumMessageSize", &self.MaximumMessageSize).field("MailslotQuota", &self.MailslotQuota).field("NextMessageSize", &self.NextMessageSize).field("MessagesAvailable", &self.MessagesAvailable).field("ReadTimeout", &self.ReadTimeout).finish()
    }
}
impl ::windows_core::TypeKind for FILE_MAILSLOT_QUERY_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_MAILSLOT_QUERY_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.MaximumMessageSize == other.MaximumMessageSize && self.MailslotQuota == other.MailslotQuota && self.NextMessageSize == other.NextMessageSize && self.MessagesAvailable == other.MessagesAvailable && self.ReadTimeout == other.ReadTimeout
    }
}
impl ::core::cmp::Eq for FILE_MAILSLOT_QUERY_INFORMATION {}
impl ::core::default::Default for FILE_MAILSLOT_QUERY_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_MAILSLOT_SET_INFORMATION {
    pub ReadTimeout: *mut i64,
}
impl ::core::marker::Copy for FILE_MAILSLOT_SET_INFORMATION {}
impl ::core::clone::Clone for FILE_MAILSLOT_SET_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_MAILSLOT_SET_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_MAILSLOT_SET_INFORMATION").field("ReadTimeout", &self.ReadTimeout).finish()
    }
}
impl ::windows_core::TypeKind for FILE_MAILSLOT_SET_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_MAILSLOT_SET_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.ReadTimeout == other.ReadTimeout
    }
}
impl ::core::cmp::Eq for FILE_MAILSLOT_SET_INFORMATION {}
impl ::core::default::Default for FILE_MAILSLOT_SET_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct FILE_MAKE_COMPATIBLE_BUFFER {
    pub CloseDisc: super::super::super::Win32::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FILE_MAKE_COMPATIBLE_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FILE_MAKE_COMPATIBLE_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for FILE_MAKE_COMPATIBLE_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_MAKE_COMPATIBLE_BUFFER").field("CloseDisc", &self.CloseDisc).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FILE_MAKE_COMPATIBLE_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for FILE_MAKE_COMPATIBLE_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.CloseDisc == other.CloseDisc
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for FILE_MAKE_COMPATIBLE_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FILE_MAKE_COMPATIBLE_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_MODE_INFORMATION {
    pub Mode: u32,
}
impl ::core::marker::Copy for FILE_MODE_INFORMATION {}
impl ::core::clone::Clone for FILE_MODE_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_MODE_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_MODE_INFORMATION").field("Mode", &self.Mode).finish()
    }
}
impl ::windows_core::TypeKind for FILE_MODE_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_MODE_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.Mode == other.Mode
    }
}
impl ::core::cmp::Eq for FILE_MODE_INFORMATION {}
impl ::core::default::Default for FILE_MODE_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct FILE_MOVE_CLUSTER_INFORMATION {
    pub ClusterCount: u32,
    pub RootDirectory: super::super::super::Win32::Foundation::HANDLE,
    pub FileNameLength: u32,
    pub FileName: [u16; 1],
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FILE_MOVE_CLUSTER_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FILE_MOVE_CLUSTER_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for FILE_MOVE_CLUSTER_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_MOVE_CLUSTER_INFORMATION").field("ClusterCount", &self.ClusterCount).field("RootDirectory", &self.RootDirectory).field("FileNameLength", &self.FileNameLength).field("FileName", &self.FileName).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FILE_MOVE_CLUSTER_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for FILE_MOVE_CLUSTER_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.ClusterCount == other.ClusterCount && self.RootDirectory == other.RootDirectory && self.FileNameLength == other.FileNameLength && self.FileName == other.FileName
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for FILE_MOVE_CLUSTER_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FILE_MOVE_CLUSTER_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_NAMES_INFORMATION {
    pub NextEntryOffset: u32,
    pub FileIndex: u32,
    pub FileNameLength: u32,
    pub FileName: [u16; 1],
}
impl ::core::marker::Copy for FILE_NAMES_INFORMATION {}
impl ::core::clone::Clone for FILE_NAMES_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_NAMES_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_NAMES_INFORMATION").field("NextEntryOffset", &self.NextEntryOffset).field("FileIndex", &self.FileIndex).field("FileNameLength", &self.FileNameLength).field("FileName", &self.FileName).finish()
    }
}
impl ::windows_core::TypeKind for FILE_NAMES_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_NAMES_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NextEntryOffset == other.NextEntryOffset && self.FileIndex == other.FileIndex && self.FileNameLength == other.FileNameLength && self.FileName == other.FileName
    }
}
impl ::core::cmp::Eq for FILE_NAMES_INFORMATION {}
impl ::core::default::Default for FILE_NAMES_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_NAME_INFORMATION {
    pub FileNameLength: u32,
    pub FileName: [u16; 1],
}
impl ::core::marker::Copy for FILE_NAME_INFORMATION {}
impl ::core::clone::Clone for FILE_NAME_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_NAME_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_NAME_INFORMATION").field("FileNameLength", &self.FileNameLength).field("FileName", &self.FileName).finish()
    }
}
impl ::windows_core::TypeKind for FILE_NAME_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_NAME_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.FileNameLength == other.FileNameLength && self.FileName == other.FileName
    }
}
impl ::core::cmp::Eq for FILE_NAME_INFORMATION {}
impl ::core::default::Default for FILE_NAME_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_NETWORK_OPEN_INFORMATION {
    pub CreationTime: i64,
    pub LastAccessTime: i64,
    pub LastWriteTime: i64,
    pub ChangeTime: i64,
    pub AllocationSize: i64,
    pub EndOfFile: i64,
    pub FileAttributes: u32,
}
impl ::core::marker::Copy for FILE_NETWORK_OPEN_INFORMATION {}
impl ::core::clone::Clone for FILE_NETWORK_OPEN_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_NETWORK_OPEN_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_NETWORK_OPEN_INFORMATION").field("CreationTime", &self.CreationTime).field("LastAccessTime", &self.LastAccessTime).field("LastWriteTime", &self.LastWriteTime).field("ChangeTime", &self.ChangeTime).field("AllocationSize", &self.AllocationSize).field("EndOfFile", &self.EndOfFile).field("FileAttributes", &self.FileAttributes).finish()
    }
}
impl ::windows_core::TypeKind for FILE_NETWORK_OPEN_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_NETWORK_OPEN_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.CreationTime == other.CreationTime && self.LastAccessTime == other.LastAccessTime && self.LastWriteTime == other.LastWriteTime && self.ChangeTime == other.ChangeTime && self.AllocationSize == other.AllocationSize && self.EndOfFile == other.EndOfFile && self.FileAttributes == other.FileAttributes
    }
}
impl ::core::cmp::Eq for FILE_NETWORK_OPEN_INFORMATION {}
impl ::core::default::Default for FILE_NETWORK_OPEN_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_NETWORK_PHYSICAL_NAME_INFORMATION {
    pub FileNameLength: u32,
    pub FileName: [u16; 1],
}
impl ::core::marker::Copy for FILE_NETWORK_PHYSICAL_NAME_INFORMATION {}
impl ::core::clone::Clone for FILE_NETWORK_PHYSICAL_NAME_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_NETWORK_PHYSICAL_NAME_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_NETWORK_PHYSICAL_NAME_INFORMATION").field("FileNameLength", &self.FileNameLength).field("FileName", &self.FileName).finish()
    }
}
impl ::windows_core::TypeKind for FILE_NETWORK_PHYSICAL_NAME_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_NETWORK_PHYSICAL_NAME_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.FileNameLength == other.FileNameLength && self.FileName == other.FileName
    }
}
impl ::core::cmp::Eq for FILE_NETWORK_PHYSICAL_NAME_INFORMATION {}
impl ::core::default::Default for FILE_NETWORK_PHYSICAL_NAME_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_NOTIFY_EXTENDED_INFORMATION {
    pub NextEntryOffset: u32,
    pub Action: u32,
    pub CreationTime: i64,
    pub LastModificationTime: i64,
    pub LastChangeTime: i64,
    pub LastAccessTime: i64,
    pub AllocatedLength: i64,
    pub FileSize: i64,
    pub FileAttributes: u32,
    pub Anonymous: FILE_NOTIFY_EXTENDED_INFORMATION_0,
    pub FileId: i64,
    pub ParentFileId: i64,
    pub FileNameLength: u32,
    pub FileName: [u16; 1],
}
impl ::core::marker::Copy for FILE_NOTIFY_EXTENDED_INFORMATION {}
impl ::core::clone::Clone for FILE_NOTIFY_EXTENDED_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for FILE_NOTIFY_EXTENDED_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for FILE_NOTIFY_EXTENDED_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub union FILE_NOTIFY_EXTENDED_INFORMATION_0 {
    pub ReparsePointTag: u32,
    pub EaSize: u32,
}
impl ::core::marker::Copy for FILE_NOTIFY_EXTENDED_INFORMATION_0 {}
impl ::core::clone::Clone for FILE_NOTIFY_EXTENDED_INFORMATION_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for FILE_NOTIFY_EXTENDED_INFORMATION_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for FILE_NOTIFY_EXTENDED_INFORMATION_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_NOTIFY_FULL_INFORMATION {
    pub NextEntryOffset: u32,
    pub Action: u32,
    pub CreationTime: i64,
    pub LastModificationTime: i64,
    pub LastChangeTime: i64,
    pub LastAccessTime: i64,
    pub AllocatedLength: i64,
    pub FileSize: i64,
    pub FileAttributes: u32,
    pub Anonymous: FILE_NOTIFY_FULL_INFORMATION_0,
    pub FileId: i64,
    pub ParentFileId: i64,
    pub FileNameLength: u16,
    pub FileNameFlags: u8,
    pub Reserved: u8,
    pub FileName: [u16; 1],
}
impl ::core::marker::Copy for FILE_NOTIFY_FULL_INFORMATION {}
impl ::core::clone::Clone for FILE_NOTIFY_FULL_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for FILE_NOTIFY_FULL_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for FILE_NOTIFY_FULL_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub union FILE_NOTIFY_FULL_INFORMATION_0 {
    pub ReparsePointTag: u32,
    pub EaSize: u32,
}
impl ::core::marker::Copy for FILE_NOTIFY_FULL_INFORMATION_0 {}
impl ::core::clone::Clone for FILE_NOTIFY_FULL_INFORMATION_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for FILE_NOTIFY_FULL_INFORMATION_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for FILE_NOTIFY_FULL_INFORMATION_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_NOTIFY_INFORMATION {
    pub NextEntryOffset: u32,
    pub Action: u32,
    pub FileNameLength: u32,
    pub FileName: [u16; 1],
}
impl ::core::marker::Copy for FILE_NOTIFY_INFORMATION {}
impl ::core::clone::Clone for FILE_NOTIFY_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_NOTIFY_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_NOTIFY_INFORMATION").field("NextEntryOffset", &self.NextEntryOffset).field("Action", &self.Action).field("FileNameLength", &self.FileNameLength).field("FileName", &self.FileName).finish()
    }
}
impl ::windows_core::TypeKind for FILE_NOTIFY_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_NOTIFY_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NextEntryOffset == other.NextEntryOffset && self.Action == other.Action && self.FileNameLength == other.FileNameLength && self.FileName == other.FileName
    }
}
impl ::core::cmp::Eq for FILE_NOTIFY_INFORMATION {}
impl ::core::default::Default for FILE_NOTIFY_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_OBJECTID_BUFFER {
    pub ObjectId: [u8; 16],
    pub Anonymous: FILE_OBJECTID_BUFFER_0,
}
impl ::core::marker::Copy for FILE_OBJECTID_BUFFER {}
impl ::core::clone::Clone for FILE_OBJECTID_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for FILE_OBJECTID_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for FILE_OBJECTID_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub union FILE_OBJECTID_BUFFER_0 {
    pub Anonymous: FILE_OBJECTID_BUFFER_0_0,
    pub ExtendedInfo: [u8; 48],
}
impl ::core::marker::Copy for FILE_OBJECTID_BUFFER_0 {}
impl ::core::clone::Clone for FILE_OBJECTID_BUFFER_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for FILE_OBJECTID_BUFFER_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for FILE_OBJECTID_BUFFER_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_OBJECTID_BUFFER_0_0 {
    pub BirthVolumeId: [u8; 16],
    pub BirthObjectId: [u8; 16],
    pub DomainId: [u8; 16],
}
impl ::core::marker::Copy for FILE_OBJECTID_BUFFER_0_0 {}
impl ::core::clone::Clone for FILE_OBJECTID_BUFFER_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_OBJECTID_BUFFER_0_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_OBJECTID_BUFFER_0_0").field("BirthVolumeId", &self.BirthVolumeId).field("BirthObjectId", &self.BirthObjectId).field("DomainId", &self.DomainId).finish()
    }
}
impl ::windows_core::TypeKind for FILE_OBJECTID_BUFFER_0_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_OBJECTID_BUFFER_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.BirthVolumeId == other.BirthVolumeId && self.BirthObjectId == other.BirthObjectId && self.DomainId == other.DomainId
    }
}
impl ::core::cmp::Eq for FILE_OBJECTID_BUFFER_0_0 {}
impl ::core::default::Default for FILE_OBJECTID_BUFFER_0_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_OBJECTID_INFORMATION {
    pub FileReference: i64,
    pub ObjectId: [u8; 16],
    pub Anonymous: FILE_OBJECTID_INFORMATION_0,
}
impl ::core::marker::Copy for FILE_OBJECTID_INFORMATION {}
impl ::core::clone::Clone for FILE_OBJECTID_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for FILE_OBJECTID_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for FILE_OBJECTID_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub union FILE_OBJECTID_INFORMATION_0 {
    pub Anonymous: FILE_OBJECTID_INFORMATION_0_0,
    pub ExtendedInfo: [u8; 48],
}
impl ::core::marker::Copy for FILE_OBJECTID_INFORMATION_0 {}
impl ::core::clone::Clone for FILE_OBJECTID_INFORMATION_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for FILE_OBJECTID_INFORMATION_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for FILE_OBJECTID_INFORMATION_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_OBJECTID_INFORMATION_0_0 {
    pub BirthVolumeId: [u8; 16],
    pub BirthObjectId: [u8; 16],
    pub DomainId: [u8; 16],
}
impl ::core::marker::Copy for FILE_OBJECTID_INFORMATION_0_0 {}
impl ::core::clone::Clone for FILE_OBJECTID_INFORMATION_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_OBJECTID_INFORMATION_0_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_OBJECTID_INFORMATION_0_0").field("BirthVolumeId", &self.BirthVolumeId).field("BirthObjectId", &self.BirthObjectId).field("DomainId", &self.DomainId).finish()
    }
}
impl ::windows_core::TypeKind for FILE_OBJECTID_INFORMATION_0_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_OBJECTID_INFORMATION_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.BirthVolumeId == other.BirthVolumeId && self.BirthObjectId == other.BirthObjectId && self.DomainId == other.DomainId
    }
}
impl ::core::cmp::Eq for FILE_OBJECTID_INFORMATION_0_0 {}
impl ::core::default::Default for FILE_OBJECTID_INFORMATION_0_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct FILE_PIPE_ASSIGN_EVENT_BUFFER {
    pub EventHandle: super::super::super::Win32::Foundation::HANDLE,
    pub KeyValue: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FILE_PIPE_ASSIGN_EVENT_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FILE_PIPE_ASSIGN_EVENT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for FILE_PIPE_ASSIGN_EVENT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_PIPE_ASSIGN_EVENT_BUFFER").field("EventHandle", &self.EventHandle).field("KeyValue", &self.KeyValue).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FILE_PIPE_ASSIGN_EVENT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for FILE_PIPE_ASSIGN_EVENT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.EventHandle == other.EventHandle && self.KeyValue == other.KeyValue
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for FILE_PIPE_ASSIGN_EVENT_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FILE_PIPE_ASSIGN_EVENT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_PIPE_CLIENT_PROCESS_BUFFER {
    pub ClientSession: *mut ::core::ffi::c_void,
    pub ClientProcess: *mut ::core::ffi::c_void,
}
impl ::core::marker::Copy for FILE_PIPE_CLIENT_PROCESS_BUFFER {}
impl ::core::clone::Clone for FILE_PIPE_CLIENT_PROCESS_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_PIPE_CLIENT_PROCESS_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_PIPE_CLIENT_PROCESS_BUFFER").field("ClientSession", &self.ClientSession).field("ClientProcess", &self.ClientProcess).finish()
    }
}
impl ::windows_core::TypeKind for FILE_PIPE_CLIENT_PROCESS_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_PIPE_CLIENT_PROCESS_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.ClientSession == other.ClientSession && self.ClientProcess == other.ClientProcess
    }
}
impl ::core::cmp::Eq for FILE_PIPE_CLIENT_PROCESS_BUFFER {}
impl ::core::default::Default for FILE_PIPE_CLIENT_PROCESS_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_PIPE_CLIENT_PROCESS_BUFFER_EX {
    pub ClientSession: *mut ::core::ffi::c_void,
    pub ClientProcess: *mut ::core::ffi::c_void,
    pub ClientComputerNameLength: u16,
    pub ClientComputerBuffer: [u16; 16],
}
impl ::core::marker::Copy for FILE_PIPE_CLIENT_PROCESS_BUFFER_EX {}
impl ::core::clone::Clone for FILE_PIPE_CLIENT_PROCESS_BUFFER_EX {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_PIPE_CLIENT_PROCESS_BUFFER_EX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_PIPE_CLIENT_PROCESS_BUFFER_EX").field("ClientSession", &self.ClientSession).field("ClientProcess", &self.ClientProcess).field("ClientComputerNameLength", &self.ClientComputerNameLength).field("ClientComputerBuffer", &self.ClientComputerBuffer).finish()
    }
}
impl ::windows_core::TypeKind for FILE_PIPE_CLIENT_PROCESS_BUFFER_EX {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_PIPE_CLIENT_PROCESS_BUFFER_EX {
    fn eq(&self, other: &Self) -> bool {
        self.ClientSession == other.ClientSession && self.ClientProcess == other.ClientProcess && self.ClientComputerNameLength == other.ClientComputerNameLength && self.ClientComputerBuffer == other.ClientComputerBuffer
    }
}
impl ::core::cmp::Eq for FILE_PIPE_CLIENT_PROCESS_BUFFER_EX {}
impl ::core::default::Default for FILE_PIPE_CLIENT_PROCESS_BUFFER_EX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_PIPE_CLIENT_PROCESS_BUFFER_V2 {
    pub ClientSession: u64,
    pub ClientProcess: *mut ::core::ffi::c_void,
}
impl ::core::marker::Copy for FILE_PIPE_CLIENT_PROCESS_BUFFER_V2 {}
impl ::core::clone::Clone for FILE_PIPE_CLIENT_PROCESS_BUFFER_V2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_PIPE_CLIENT_PROCESS_BUFFER_V2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_PIPE_CLIENT_PROCESS_BUFFER_V2").field("ClientSession", &self.ClientSession).field("ClientProcess", &self.ClientProcess).finish()
    }
}
impl ::windows_core::TypeKind for FILE_PIPE_CLIENT_PROCESS_BUFFER_V2 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_PIPE_CLIENT_PROCESS_BUFFER_V2 {
    fn eq(&self, other: &Self) -> bool {
        self.ClientSession == other.ClientSession && self.ClientProcess == other.ClientProcess
    }
}
impl ::core::cmp::Eq for FILE_PIPE_CLIENT_PROCESS_BUFFER_V2 {}
impl ::core::default::Default for FILE_PIPE_CLIENT_PROCESS_BUFFER_V2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_PIPE_CREATE_SYMLINK_INPUT {
    pub NameOffset: u16,
    pub NameLength: u16,
    pub SubstituteNameOffset: u16,
    pub SubstituteNameLength: u16,
    pub Flags: u32,
}
impl ::core::marker::Copy for FILE_PIPE_CREATE_SYMLINK_INPUT {}
impl ::core::clone::Clone for FILE_PIPE_CREATE_SYMLINK_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_PIPE_CREATE_SYMLINK_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_PIPE_CREATE_SYMLINK_INPUT").field("NameOffset", &self.NameOffset).field("NameLength", &self.NameLength).field("SubstituteNameOffset", &self.SubstituteNameOffset).field("SubstituteNameLength", &self.SubstituteNameLength).field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for FILE_PIPE_CREATE_SYMLINK_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_PIPE_CREATE_SYMLINK_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.NameOffset == other.NameOffset && self.NameLength == other.NameLength && self.SubstituteNameOffset == other.SubstituteNameOffset && self.SubstituteNameLength == other.SubstituteNameLength && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for FILE_PIPE_CREATE_SYMLINK_INPUT {}
impl ::core::default::Default for FILE_PIPE_CREATE_SYMLINK_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_PIPE_DELETE_SYMLINK_INPUT {
    pub NameOffset: u16,
    pub NameLength: u16,
}
impl ::core::marker::Copy for FILE_PIPE_DELETE_SYMLINK_INPUT {}
impl ::core::clone::Clone for FILE_PIPE_DELETE_SYMLINK_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_PIPE_DELETE_SYMLINK_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_PIPE_DELETE_SYMLINK_INPUT").field("NameOffset", &self.NameOffset).field("NameLength", &self.NameLength).finish()
    }
}
impl ::windows_core::TypeKind for FILE_PIPE_DELETE_SYMLINK_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_PIPE_DELETE_SYMLINK_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.NameOffset == other.NameOffset && self.NameLength == other.NameLength
    }
}
impl ::core::cmp::Eq for FILE_PIPE_DELETE_SYMLINK_INPUT {}
impl ::core::default::Default for FILE_PIPE_DELETE_SYMLINK_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_PIPE_EVENT_BUFFER {
    pub NamedPipeState: u32,
    pub EntryType: u32,
    pub ByteCount: u32,
    pub KeyValue: u32,
    pub NumberRequests: u32,
}
impl ::core::marker::Copy for FILE_PIPE_EVENT_BUFFER {}
impl ::core::clone::Clone for FILE_PIPE_EVENT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_PIPE_EVENT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_PIPE_EVENT_BUFFER").field("NamedPipeState", &self.NamedPipeState).field("EntryType", &self.EntryType).field("ByteCount", &self.ByteCount).field("KeyValue", &self.KeyValue).field("NumberRequests", &self.NumberRequests).finish()
    }
}
impl ::windows_core::TypeKind for FILE_PIPE_EVENT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_PIPE_EVENT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.NamedPipeState == other.NamedPipeState && self.EntryType == other.EntryType && self.ByteCount == other.ByteCount && self.KeyValue == other.KeyValue && self.NumberRequests == other.NumberRequests
    }
}
impl ::core::cmp::Eq for FILE_PIPE_EVENT_BUFFER {}
impl ::core::default::Default for FILE_PIPE_EVENT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_PIPE_INFORMATION {
    pub ReadMode: u32,
    pub CompletionMode: u32,
}
impl ::core::marker::Copy for FILE_PIPE_INFORMATION {}
impl ::core::clone::Clone for FILE_PIPE_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_PIPE_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_PIPE_INFORMATION").field("ReadMode", &self.ReadMode).field("CompletionMode", &self.CompletionMode).finish()
    }
}
impl ::windows_core::TypeKind for FILE_PIPE_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_PIPE_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.ReadMode == other.ReadMode && self.CompletionMode == other.CompletionMode
    }
}
impl ::core::cmp::Eq for FILE_PIPE_INFORMATION {}
impl ::core::default::Default for FILE_PIPE_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_PIPE_LOCAL_INFORMATION {
    pub NamedPipeType: u32,
    pub NamedPipeConfiguration: u32,
    pub MaximumInstances: u32,
    pub CurrentInstances: u32,
    pub InboundQuota: u32,
    pub ReadDataAvailable: u32,
    pub OutboundQuota: u32,
    pub WriteQuotaAvailable: u32,
    pub NamedPipeState: u32,
    pub NamedPipeEnd: u32,
}
impl ::core::marker::Copy for FILE_PIPE_LOCAL_INFORMATION {}
impl ::core::clone::Clone for FILE_PIPE_LOCAL_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_PIPE_LOCAL_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_PIPE_LOCAL_INFORMATION")
            .field("NamedPipeType", &self.NamedPipeType)
            .field("NamedPipeConfiguration", &self.NamedPipeConfiguration)
            .field("MaximumInstances", &self.MaximumInstances)
            .field("CurrentInstances", &self.CurrentInstances)
            .field("InboundQuota", &self.InboundQuota)
            .field("ReadDataAvailable", &self.ReadDataAvailable)
            .field("OutboundQuota", &self.OutboundQuota)
            .field("WriteQuotaAvailable", &self.WriteQuotaAvailable)
            .field("NamedPipeState", &self.NamedPipeState)
            .field("NamedPipeEnd", &self.NamedPipeEnd)
            .finish()
    }
}
impl ::windows_core::TypeKind for FILE_PIPE_LOCAL_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_PIPE_LOCAL_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NamedPipeType == other.NamedPipeType && self.NamedPipeConfiguration == other.NamedPipeConfiguration && self.MaximumInstances == other.MaximumInstances && self.CurrentInstances == other.CurrentInstances && self.InboundQuota == other.InboundQuota && self.ReadDataAvailable == other.ReadDataAvailable && self.OutboundQuota == other.OutboundQuota && self.WriteQuotaAvailable == other.WriteQuotaAvailable && self.NamedPipeState == other.NamedPipeState && self.NamedPipeEnd == other.NamedPipeEnd
    }
}
impl ::core::cmp::Eq for FILE_PIPE_LOCAL_INFORMATION {}
impl ::core::default::Default for FILE_PIPE_LOCAL_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_PIPE_PEEK_BUFFER {
    pub NamedPipeState: u32,
    pub ReadDataAvailable: u32,
    pub NumberOfMessages: u32,
    pub MessageLength: u32,
    pub Data: [u8; 1],
}
impl ::core::marker::Copy for FILE_PIPE_PEEK_BUFFER {}
impl ::core::clone::Clone for FILE_PIPE_PEEK_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_PIPE_PEEK_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_PIPE_PEEK_BUFFER").field("NamedPipeState", &self.NamedPipeState).field("ReadDataAvailable", &self.ReadDataAvailable).field("NumberOfMessages", &self.NumberOfMessages).field("MessageLength", &self.MessageLength).field("Data", &self.Data).finish()
    }
}
impl ::windows_core::TypeKind for FILE_PIPE_PEEK_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_PIPE_PEEK_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.NamedPipeState == other.NamedPipeState && self.ReadDataAvailable == other.ReadDataAvailable && self.NumberOfMessages == other.NumberOfMessages && self.MessageLength == other.MessageLength && self.Data == other.Data
    }
}
impl ::core::cmp::Eq for FILE_PIPE_PEEK_BUFFER {}
impl ::core::default::Default for FILE_PIPE_PEEK_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_PIPE_REMOTE_INFORMATION {
    pub CollectDataTime: i64,
    pub MaximumCollectionCount: u32,
}
impl ::core::marker::Copy for FILE_PIPE_REMOTE_INFORMATION {}
impl ::core::clone::Clone for FILE_PIPE_REMOTE_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_PIPE_REMOTE_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_PIPE_REMOTE_INFORMATION").field("CollectDataTime", &self.CollectDataTime).field("MaximumCollectionCount", &self.MaximumCollectionCount).finish()
    }
}
impl ::windows_core::TypeKind for FILE_PIPE_REMOTE_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_PIPE_REMOTE_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.CollectDataTime == other.CollectDataTime && self.MaximumCollectionCount == other.MaximumCollectionCount
    }
}
impl ::core::cmp::Eq for FILE_PIPE_REMOTE_INFORMATION {}
impl ::core::default::Default for FILE_PIPE_REMOTE_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct FILE_PIPE_SILO_ARRIVAL_INPUT {
    pub JobHandle: super::super::super::Win32::Foundation::HANDLE,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FILE_PIPE_SILO_ARRIVAL_INPUT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FILE_PIPE_SILO_ARRIVAL_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for FILE_PIPE_SILO_ARRIVAL_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_PIPE_SILO_ARRIVAL_INPUT").field("JobHandle", &self.JobHandle).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FILE_PIPE_SILO_ARRIVAL_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for FILE_PIPE_SILO_ARRIVAL_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.JobHandle == other.JobHandle
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for FILE_PIPE_SILO_ARRIVAL_INPUT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FILE_PIPE_SILO_ARRIVAL_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct FILE_PIPE_WAIT_FOR_BUFFER {
    pub Timeout: i64,
    pub NameLength: u32,
    pub TimeoutSpecified: super::super::super::Win32::Foundation::BOOLEAN,
    pub Name: [u16; 1],
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FILE_PIPE_WAIT_FOR_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FILE_PIPE_WAIT_FOR_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for FILE_PIPE_WAIT_FOR_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_PIPE_WAIT_FOR_BUFFER").field("Timeout", &self.Timeout).field("NameLength", &self.NameLength).field("TimeoutSpecified", &self.TimeoutSpecified).field("Name", &self.Name).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FILE_PIPE_WAIT_FOR_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for FILE_PIPE_WAIT_FOR_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.Timeout == other.Timeout && self.NameLength == other.NameLength && self.TimeoutSpecified == other.TimeoutSpecified && self.Name == other.Name
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for FILE_PIPE_WAIT_FOR_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FILE_PIPE_WAIT_FOR_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_POSITION_INFORMATION {
    pub CurrentByteOffset: i64,
}
impl ::core::marker::Copy for FILE_POSITION_INFORMATION {}
impl ::core::clone::Clone for FILE_POSITION_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_POSITION_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_POSITION_INFORMATION").field("CurrentByteOffset", &self.CurrentByteOffset).finish()
    }
}
impl ::windows_core::TypeKind for FILE_POSITION_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_POSITION_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.CurrentByteOffset == other.CurrentByteOffset
    }
}
impl ::core::cmp::Eq for FILE_POSITION_INFORMATION {}
impl ::core::default::Default for FILE_POSITION_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_PREFETCH {
    pub Type: u32,
    pub Count: u32,
    pub Prefetch: [u64; 1],
}
impl ::core::marker::Copy for FILE_PREFETCH {}
impl ::core::clone::Clone for FILE_PREFETCH {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_PREFETCH {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_PREFETCH").field("Type", &self.Type).field("Count", &self.Count).field("Prefetch", &self.Prefetch).finish()
    }
}
impl ::windows_core::TypeKind for FILE_PREFETCH {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_PREFETCH {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type && self.Count == other.Count && self.Prefetch == other.Prefetch
    }
}
impl ::core::cmp::Eq for FILE_PREFETCH {}
impl ::core::default::Default for FILE_PREFETCH {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_PREFETCH_EX {
    pub Type: u32,
    pub Count: u32,
    pub Context: *mut ::core::ffi::c_void,
    pub Prefetch: [u64; 1],
}
impl ::core::marker::Copy for FILE_PREFETCH_EX {}
impl ::core::clone::Clone for FILE_PREFETCH_EX {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_PREFETCH_EX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_PREFETCH_EX").field("Type", &self.Type).field("Count", &self.Count).field("Context", &self.Context).field("Prefetch", &self.Prefetch).finish()
    }
}
impl ::windows_core::TypeKind for FILE_PREFETCH_EX {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_PREFETCH_EX {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type && self.Count == other.Count && self.Context == other.Context && self.Prefetch == other.Prefetch
    }
}
impl ::core::cmp::Eq for FILE_PREFETCH_EX {}
impl ::core::default::Default for FILE_PREFETCH_EX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_PROVIDER_EXTERNAL_INFO_V0 {
    pub Version: u32,
    pub Algorithm: u32,
}
impl ::core::marker::Copy for FILE_PROVIDER_EXTERNAL_INFO_V0 {}
impl ::core::clone::Clone for FILE_PROVIDER_EXTERNAL_INFO_V0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_PROVIDER_EXTERNAL_INFO_V0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_PROVIDER_EXTERNAL_INFO_V0").field("Version", &self.Version).field("Algorithm", &self.Algorithm).finish()
    }
}
impl ::windows_core::TypeKind for FILE_PROVIDER_EXTERNAL_INFO_V0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_PROVIDER_EXTERNAL_INFO_V0 {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Algorithm == other.Algorithm
    }
}
impl ::core::cmp::Eq for FILE_PROVIDER_EXTERNAL_INFO_V0 {}
impl ::core::default::Default for FILE_PROVIDER_EXTERNAL_INFO_V0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_PROVIDER_EXTERNAL_INFO_V1 {
    pub Version: u32,
    pub Algorithm: u32,
    pub Flags: u32,
}
impl ::core::marker::Copy for FILE_PROVIDER_EXTERNAL_INFO_V1 {}
impl ::core::clone::Clone for FILE_PROVIDER_EXTERNAL_INFO_V1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_PROVIDER_EXTERNAL_INFO_V1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_PROVIDER_EXTERNAL_INFO_V1").field("Version", &self.Version).field("Algorithm", &self.Algorithm).field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for FILE_PROVIDER_EXTERNAL_INFO_V1 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_PROVIDER_EXTERNAL_INFO_V1 {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Algorithm == other.Algorithm && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for FILE_PROVIDER_EXTERNAL_INFO_V1 {}
impl ::core::default::Default for FILE_PROVIDER_EXTERNAL_INFO_V1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_QUERY_ON_DISK_VOL_INFO_BUFFER {
    pub DirectoryCount: i64,
    pub FileCount: i64,
    pub FsFormatMajVersion: u16,
    pub FsFormatMinVersion: u16,
    pub FsFormatName: [u16; 12],
    pub FormatTime: i64,
    pub LastUpdateTime: i64,
    pub CopyrightInfo: [u16; 34],
    pub AbstractInfo: [u16; 34],
    pub FormattingImplementationInfo: [u16; 34],
    pub LastModifyingImplementationInfo: [u16; 34],
}
impl ::core::marker::Copy for FILE_QUERY_ON_DISK_VOL_INFO_BUFFER {}
impl ::core::clone::Clone for FILE_QUERY_ON_DISK_VOL_INFO_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_QUERY_ON_DISK_VOL_INFO_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_QUERY_ON_DISK_VOL_INFO_BUFFER")
            .field("DirectoryCount", &self.DirectoryCount)
            .field("FileCount", &self.FileCount)
            .field("FsFormatMajVersion", &self.FsFormatMajVersion)
            .field("FsFormatMinVersion", &self.FsFormatMinVersion)
            .field("FsFormatName", &self.FsFormatName)
            .field("FormatTime", &self.FormatTime)
            .field("LastUpdateTime", &self.LastUpdateTime)
            .field("CopyrightInfo", &self.CopyrightInfo)
            .field("AbstractInfo", &self.AbstractInfo)
            .field("FormattingImplementationInfo", &self.FormattingImplementationInfo)
            .field("LastModifyingImplementationInfo", &self.LastModifyingImplementationInfo)
            .finish()
    }
}
impl ::windows_core::TypeKind for FILE_QUERY_ON_DISK_VOL_INFO_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_QUERY_ON_DISK_VOL_INFO_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.DirectoryCount == other.DirectoryCount && self.FileCount == other.FileCount && self.FsFormatMajVersion == other.FsFormatMajVersion && self.FsFormatMinVersion == other.FsFormatMinVersion && self.FsFormatName == other.FsFormatName && self.FormatTime == other.FormatTime && self.LastUpdateTime == other.LastUpdateTime && self.CopyrightInfo == other.CopyrightInfo && self.AbstractInfo == other.AbstractInfo && self.FormattingImplementationInfo == other.FormattingImplementationInfo && self.LastModifyingImplementationInfo == other.LastModifyingImplementationInfo
    }
}
impl ::core::cmp::Eq for FILE_QUERY_ON_DISK_VOL_INFO_BUFFER {}
impl ::core::default::Default for FILE_QUERY_ON_DISK_VOL_INFO_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct FILE_QUERY_SPARING_BUFFER {
    pub SparingUnitBytes: u32,
    pub SoftwareSparing: super::super::super::Win32::Foundation::BOOLEAN,
    pub TotalSpareBlocks: u32,
    pub FreeSpareBlocks: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FILE_QUERY_SPARING_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FILE_QUERY_SPARING_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for FILE_QUERY_SPARING_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_QUERY_SPARING_BUFFER").field("SparingUnitBytes", &self.SparingUnitBytes).field("SoftwareSparing", &self.SoftwareSparing).field("TotalSpareBlocks", &self.TotalSpareBlocks).field("FreeSpareBlocks", &self.FreeSpareBlocks).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FILE_QUERY_SPARING_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for FILE_QUERY_SPARING_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.SparingUnitBytes == other.SparingUnitBytes && self.SoftwareSparing == other.SoftwareSparing && self.TotalSpareBlocks == other.TotalSpareBlocks && self.FreeSpareBlocks == other.FreeSpareBlocks
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for FILE_QUERY_SPARING_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FILE_QUERY_SPARING_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Security\"`*"]
#[cfg(feature = "Win32_Security")]
pub struct FILE_QUOTA_INFORMATION {
    pub NextEntryOffset: u32,
    pub SidLength: u32,
    pub ChangeTime: i64,
    pub QuotaUsed: i64,
    pub QuotaThreshold: i64,
    pub QuotaLimit: i64,
    pub Sid: super::super::super::Win32::Security::SID,
}
#[cfg(feature = "Win32_Security")]
impl ::core::marker::Copy for FILE_QUOTA_INFORMATION {}
#[cfg(feature = "Win32_Security")]
impl ::core::clone::Clone for FILE_QUOTA_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Security")]
impl ::core::fmt::Debug for FILE_QUOTA_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_QUOTA_INFORMATION").field("NextEntryOffset", &self.NextEntryOffset).field("SidLength", &self.SidLength).field("ChangeTime", &self.ChangeTime).field("QuotaUsed", &self.QuotaUsed).field("QuotaThreshold", &self.QuotaThreshold).field("QuotaLimit", &self.QuotaLimit).field("Sid", &self.Sid).finish()
    }
}
#[cfg(feature = "Win32_Security")]
impl ::windows_core::TypeKind for FILE_QUOTA_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Security")]
impl ::core::cmp::PartialEq for FILE_QUOTA_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NextEntryOffset == other.NextEntryOffset && self.SidLength == other.SidLength && self.ChangeTime == other.ChangeTime && self.QuotaUsed == other.QuotaUsed && self.QuotaThreshold == other.QuotaThreshold && self.QuotaLimit == other.QuotaLimit && self.Sid == other.Sid
    }
}
#[cfg(feature = "Win32_Security")]
impl ::core::cmp::Eq for FILE_QUOTA_INFORMATION {}
#[cfg(feature = "Win32_Security")]
impl ::core::default::Default for FILE_QUOTA_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_REFERENCE_RANGE {
    pub StartingFileReferenceNumber: u64,
    pub EndingFileReferenceNumber: u64,
}
impl ::core::marker::Copy for FILE_REFERENCE_RANGE {}
impl ::core::clone::Clone for FILE_REFERENCE_RANGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_REFERENCE_RANGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_REFERENCE_RANGE").field("StartingFileReferenceNumber", &self.StartingFileReferenceNumber).field("EndingFileReferenceNumber", &self.EndingFileReferenceNumber).finish()
    }
}
impl ::windows_core::TypeKind for FILE_REFERENCE_RANGE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_REFERENCE_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.StartingFileReferenceNumber == other.StartingFileReferenceNumber && self.EndingFileReferenceNumber == other.EndingFileReferenceNumber
    }
}
impl ::core::cmp::Eq for FILE_REFERENCE_RANGE {}
impl ::core::default::Default for FILE_REFERENCE_RANGE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_REGION_INFO {
    pub FileOffset: i64,
    pub Length: i64,
    pub Usage: u32,
    pub Reserved: u32,
}
impl ::core::marker::Copy for FILE_REGION_INFO {}
impl ::core::clone::Clone for FILE_REGION_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_REGION_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_REGION_INFO").field("FileOffset", &self.FileOffset).field("Length", &self.Length).field("Usage", &self.Usage).field("Reserved", &self.Reserved).finish()
    }
}
impl ::windows_core::TypeKind for FILE_REGION_INFO {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_REGION_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.FileOffset == other.FileOffset && self.Length == other.Length && self.Usage == other.Usage && self.Reserved == other.Reserved
    }
}
impl ::core::cmp::Eq for FILE_REGION_INFO {}
impl ::core::default::Default for FILE_REGION_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_REGION_INPUT {
    pub FileOffset: i64,
    pub Length: i64,
    pub DesiredUsage: u32,
}
impl ::core::marker::Copy for FILE_REGION_INPUT {}
impl ::core::clone::Clone for FILE_REGION_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_REGION_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_REGION_INPUT").field("FileOffset", &self.FileOffset).field("Length", &self.Length).field("DesiredUsage", &self.DesiredUsage).finish()
    }
}
impl ::windows_core::TypeKind for FILE_REGION_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_REGION_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.FileOffset == other.FileOffset && self.Length == other.Length && self.DesiredUsage == other.DesiredUsage
    }
}
impl ::core::cmp::Eq for FILE_REGION_INPUT {}
impl ::core::default::Default for FILE_REGION_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_REGION_OUTPUT {
    pub Flags: u32,
    pub TotalRegionEntryCount: u32,
    pub RegionEntryCount: u32,
    pub Reserved: u32,
    pub Region: [FILE_REGION_INFO; 1],
}
impl ::core::marker::Copy for FILE_REGION_OUTPUT {}
impl ::core::clone::Clone for FILE_REGION_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_REGION_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_REGION_OUTPUT").field("Flags", &self.Flags).field("TotalRegionEntryCount", &self.TotalRegionEntryCount).field("RegionEntryCount", &self.RegionEntryCount).field("Reserved", &self.Reserved).field("Region", &self.Region).finish()
    }
}
impl ::windows_core::TypeKind for FILE_REGION_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_REGION_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags && self.TotalRegionEntryCount == other.TotalRegionEntryCount && self.RegionEntryCount == other.RegionEntryCount && self.Reserved == other.Reserved && self.Region == other.Region
    }
}
impl ::core::cmp::Eq for FILE_REGION_OUTPUT {}
impl ::core::default::Default for FILE_REGION_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_REMOTE_PROTOCOL_INFORMATION {
    pub StructureVersion: u16,
    pub StructureSize: u16,
    pub Protocol: u32,
    pub ProtocolMajorVersion: u16,
    pub ProtocolMinorVersion: u16,
    pub ProtocolRevision: u16,
    pub Reserved: u16,
    pub Flags: u32,
    pub GenericReserved: FILE_REMOTE_PROTOCOL_INFORMATION_0,
    pub ProtocolSpecific: FILE_REMOTE_PROTOCOL_INFORMATION_1,
}
impl ::core::marker::Copy for FILE_REMOTE_PROTOCOL_INFORMATION {}
impl ::core::clone::Clone for FILE_REMOTE_PROTOCOL_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for FILE_REMOTE_PROTOCOL_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for FILE_REMOTE_PROTOCOL_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_REMOTE_PROTOCOL_INFORMATION_0 {
    pub Reserved: [u32; 8],
}
impl ::core::marker::Copy for FILE_REMOTE_PROTOCOL_INFORMATION_0 {}
impl ::core::clone::Clone for FILE_REMOTE_PROTOCOL_INFORMATION_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_REMOTE_PROTOCOL_INFORMATION_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_REMOTE_PROTOCOL_INFORMATION_0").field("Reserved", &self.Reserved).finish()
    }
}
impl ::windows_core::TypeKind for FILE_REMOTE_PROTOCOL_INFORMATION_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_REMOTE_PROTOCOL_INFORMATION_0 {
    fn eq(&self, other: &Self) -> bool {
        self.Reserved == other.Reserved
    }
}
impl ::core::cmp::Eq for FILE_REMOTE_PROTOCOL_INFORMATION_0 {}
impl ::core::default::Default for FILE_REMOTE_PROTOCOL_INFORMATION_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub union FILE_REMOTE_PROTOCOL_INFORMATION_1 {
    pub Smb2: FILE_REMOTE_PROTOCOL_INFORMATION_1_0,
    pub Reserved: [u32; 16],
}
impl ::core::marker::Copy for FILE_REMOTE_PROTOCOL_INFORMATION_1 {}
impl ::core::clone::Clone for FILE_REMOTE_PROTOCOL_INFORMATION_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for FILE_REMOTE_PROTOCOL_INFORMATION_1 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for FILE_REMOTE_PROTOCOL_INFORMATION_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_REMOTE_PROTOCOL_INFORMATION_1_0 {
    pub Server: FILE_REMOTE_PROTOCOL_INFORMATION_1_0_0,
    pub Share: FILE_REMOTE_PROTOCOL_INFORMATION_1_0_1,
}
impl ::core::marker::Copy for FILE_REMOTE_PROTOCOL_INFORMATION_1_0 {}
impl ::core::clone::Clone for FILE_REMOTE_PROTOCOL_INFORMATION_1_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_REMOTE_PROTOCOL_INFORMATION_1_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_REMOTE_PROTOCOL_INFORMATION_1_0").field("Server", &self.Server).field("Share", &self.Share).finish()
    }
}
impl ::windows_core::TypeKind for FILE_REMOTE_PROTOCOL_INFORMATION_1_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_REMOTE_PROTOCOL_INFORMATION_1_0 {
    fn eq(&self, other: &Self) -> bool {
        self.Server == other.Server && self.Share == other.Share
    }
}
impl ::core::cmp::Eq for FILE_REMOTE_PROTOCOL_INFORMATION_1_0 {}
impl ::core::default::Default for FILE_REMOTE_PROTOCOL_INFORMATION_1_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_REMOTE_PROTOCOL_INFORMATION_1_0_0 {
    pub Capabilities: u32,
}
impl ::core::marker::Copy for FILE_REMOTE_PROTOCOL_INFORMATION_1_0_0 {}
impl ::core::clone::Clone for FILE_REMOTE_PROTOCOL_INFORMATION_1_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_REMOTE_PROTOCOL_INFORMATION_1_0_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_REMOTE_PROTOCOL_INFORMATION_1_0_0").field("Capabilities", &self.Capabilities).finish()
    }
}
impl ::windows_core::TypeKind for FILE_REMOTE_PROTOCOL_INFORMATION_1_0_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_REMOTE_PROTOCOL_INFORMATION_1_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.Capabilities == other.Capabilities
    }
}
impl ::core::cmp::Eq for FILE_REMOTE_PROTOCOL_INFORMATION_1_0_0 {}
impl ::core::default::Default for FILE_REMOTE_PROTOCOL_INFORMATION_1_0_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_REMOTE_PROTOCOL_INFORMATION_1_0_1 {
    pub Capabilities: u32,
    pub ShareFlags: u32,
    pub ShareType: u8,
    pub Reserved0: [u8; 3],
    pub Reserved1: u32,
}
impl ::core::marker::Copy for FILE_REMOTE_PROTOCOL_INFORMATION_1_0_1 {}
impl ::core::clone::Clone for FILE_REMOTE_PROTOCOL_INFORMATION_1_0_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_REMOTE_PROTOCOL_INFORMATION_1_0_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_REMOTE_PROTOCOL_INFORMATION_1_0_1").field("Capabilities", &self.Capabilities).field("ShareFlags", &self.ShareFlags).field("ShareType", &self.ShareType).field("Reserved0", &self.Reserved0).field("Reserved1", &self.Reserved1).finish()
    }
}
impl ::windows_core::TypeKind for FILE_REMOTE_PROTOCOL_INFORMATION_1_0_1 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_REMOTE_PROTOCOL_INFORMATION_1_0_1 {
    fn eq(&self, other: &Self) -> bool {
        self.Capabilities == other.Capabilities && self.ShareFlags == other.ShareFlags && self.ShareType == other.ShareType && self.Reserved0 == other.Reserved0 && self.Reserved1 == other.Reserved1
    }
}
impl ::core::cmp::Eq for FILE_REMOTE_PROTOCOL_INFORMATION_1_0_1 {}
impl ::core::default::Default for FILE_REMOTE_PROTOCOL_INFORMATION_1_0_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct FILE_RENAME_INFORMATION {
    pub Anonymous: FILE_RENAME_INFORMATION_0,
    pub RootDirectory: super::super::super::Win32::Foundation::HANDLE,
    pub FileNameLength: u32,
    pub FileName: [u16; 1],
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FILE_RENAME_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FILE_RENAME_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FILE_RENAME_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FILE_RENAME_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub union FILE_RENAME_INFORMATION_0 {
    pub ReplaceIfExists: super::super::super::Win32::Foundation::BOOLEAN,
    pub Flags: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FILE_RENAME_INFORMATION_0 {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FILE_RENAME_INFORMATION_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FILE_RENAME_INFORMATION_0 {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FILE_RENAME_INFORMATION_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_REPARSE_POINT_INFORMATION {
    pub FileReference: i64,
    pub Tag: u32,
}
impl ::core::marker::Copy for FILE_REPARSE_POINT_INFORMATION {}
impl ::core::clone::Clone for FILE_REPARSE_POINT_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_REPARSE_POINT_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_REPARSE_POINT_INFORMATION").field("FileReference", &self.FileReference).field("Tag", &self.Tag).finish()
    }
}
impl ::windows_core::TypeKind for FILE_REPARSE_POINT_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_REPARSE_POINT_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.FileReference == other.FileReference && self.Tag == other.Tag
    }
}
impl ::core::cmp::Eq for FILE_REPARSE_POINT_INFORMATION {}
impl ::core::default::Default for FILE_REPARSE_POINT_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct FILE_SET_DEFECT_MGMT_BUFFER {
    pub Disable: super::super::super::Win32::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FILE_SET_DEFECT_MGMT_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FILE_SET_DEFECT_MGMT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for FILE_SET_DEFECT_MGMT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_SET_DEFECT_MGMT_BUFFER").field("Disable", &self.Disable).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FILE_SET_DEFECT_MGMT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for FILE_SET_DEFECT_MGMT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.Disable == other.Disable
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for FILE_SET_DEFECT_MGMT_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FILE_SET_DEFECT_MGMT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct FILE_SET_SPARSE_BUFFER {
    pub SetSparse: super::super::super::Win32::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FILE_SET_SPARSE_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FILE_SET_SPARSE_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for FILE_SET_SPARSE_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_SET_SPARSE_BUFFER").field("SetSparse", &self.SetSparse).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FILE_SET_SPARSE_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for FILE_SET_SPARSE_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.SetSparse == other.SetSparse
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for FILE_SET_SPARSE_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FILE_SET_SPARSE_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct FILE_STANDARD_INFORMATION {
    pub AllocationSize: i64,
    pub EndOfFile: i64,
    pub NumberOfLinks: u32,
    pub DeletePending: super::super::super::Win32::Foundation::BOOLEAN,
    pub Directory: super::super::super::Win32::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FILE_STANDARD_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FILE_STANDARD_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for FILE_STANDARD_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_STANDARD_INFORMATION").field("AllocationSize", &self.AllocationSize).field("EndOfFile", &self.EndOfFile).field("NumberOfLinks", &self.NumberOfLinks).field("DeletePending", &self.DeletePending).field("Directory", &self.Directory).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FILE_STANDARD_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for FILE_STANDARD_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.AllocationSize == other.AllocationSize && self.EndOfFile == other.EndOfFile && self.NumberOfLinks == other.NumberOfLinks && self.DeletePending == other.DeletePending && self.Directory == other.Directory
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for FILE_STANDARD_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FILE_STANDARD_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct FILE_STANDARD_LINK_INFORMATION {
    pub NumberOfAccessibleLinks: u32,
    pub TotalNumberOfLinks: u32,
    pub DeletePending: super::super::super::Win32::Foundation::BOOLEAN,
    pub Directory: super::super::super::Win32::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FILE_STANDARD_LINK_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FILE_STANDARD_LINK_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for FILE_STANDARD_LINK_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_STANDARD_LINK_INFORMATION").field("NumberOfAccessibleLinks", &self.NumberOfAccessibleLinks).field("TotalNumberOfLinks", &self.TotalNumberOfLinks).field("DeletePending", &self.DeletePending).field("Directory", &self.Directory).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FILE_STANDARD_LINK_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for FILE_STANDARD_LINK_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NumberOfAccessibleLinks == other.NumberOfAccessibleLinks && self.TotalNumberOfLinks == other.TotalNumberOfLinks && self.DeletePending == other.DeletePending && self.Directory == other.Directory
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for FILE_STANDARD_LINK_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FILE_STANDARD_LINK_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_STAT_INFORMATION {
    pub FileId: i64,
    pub CreationTime: i64,
    pub LastAccessTime: i64,
    pub LastWriteTime: i64,
    pub ChangeTime: i64,
    pub AllocationSize: i64,
    pub EndOfFile: i64,
    pub FileAttributes: u32,
    pub ReparseTag: u32,
    pub NumberOfLinks: u32,
    pub EffectiveAccess: u32,
}
impl ::core::marker::Copy for FILE_STAT_INFORMATION {}
impl ::core::clone::Clone for FILE_STAT_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_STAT_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_STAT_INFORMATION")
            .field("FileId", &self.FileId)
            .field("CreationTime", &self.CreationTime)
            .field("LastAccessTime", &self.LastAccessTime)
            .field("LastWriteTime", &self.LastWriteTime)
            .field("ChangeTime", &self.ChangeTime)
            .field("AllocationSize", &self.AllocationSize)
            .field("EndOfFile", &self.EndOfFile)
            .field("FileAttributes", &self.FileAttributes)
            .field("ReparseTag", &self.ReparseTag)
            .field("NumberOfLinks", &self.NumberOfLinks)
            .field("EffectiveAccess", &self.EffectiveAccess)
            .finish()
    }
}
impl ::windows_core::TypeKind for FILE_STAT_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_STAT_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.FileId == other.FileId && self.CreationTime == other.CreationTime && self.LastAccessTime == other.LastAccessTime && self.LastWriteTime == other.LastWriteTime && self.ChangeTime == other.ChangeTime && self.AllocationSize == other.AllocationSize && self.EndOfFile == other.EndOfFile && self.FileAttributes == other.FileAttributes && self.ReparseTag == other.ReparseTag && self.NumberOfLinks == other.NumberOfLinks && self.EffectiveAccess == other.EffectiveAccess
    }
}
impl ::core::cmp::Eq for FILE_STAT_INFORMATION {}
impl ::core::default::Default for FILE_STAT_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_STAT_LX_INFORMATION {
    pub FileId: i64,
    pub CreationTime: i64,
    pub LastAccessTime: i64,
    pub LastWriteTime: i64,
    pub ChangeTime: i64,
    pub AllocationSize: i64,
    pub EndOfFile: i64,
    pub FileAttributes: u32,
    pub ReparseTag: u32,
    pub NumberOfLinks: u32,
    pub EffectiveAccess: u32,
    pub LxFlags: u32,
    pub LxUid: u32,
    pub LxGid: u32,
    pub LxMode: u32,
    pub LxDeviceIdMajor: u32,
    pub LxDeviceIdMinor: u32,
}
impl ::core::marker::Copy for FILE_STAT_LX_INFORMATION {}
impl ::core::clone::Clone for FILE_STAT_LX_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_STAT_LX_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_STAT_LX_INFORMATION")
            .field("FileId", &self.FileId)
            .field("CreationTime", &self.CreationTime)
            .field("LastAccessTime", &self.LastAccessTime)
            .field("LastWriteTime", &self.LastWriteTime)
            .field("ChangeTime", &self.ChangeTime)
            .field("AllocationSize", &self.AllocationSize)
            .field("EndOfFile", &self.EndOfFile)
            .field("FileAttributes", &self.FileAttributes)
            .field("ReparseTag", &self.ReparseTag)
            .field("NumberOfLinks", &self.NumberOfLinks)
            .field("EffectiveAccess", &self.EffectiveAccess)
            .field("LxFlags", &self.LxFlags)
            .field("LxUid", &self.LxUid)
            .field("LxGid", &self.LxGid)
            .field("LxMode", &self.LxMode)
            .field("LxDeviceIdMajor", &self.LxDeviceIdMajor)
            .field("LxDeviceIdMinor", &self.LxDeviceIdMinor)
            .finish()
    }
}
impl ::windows_core::TypeKind for FILE_STAT_LX_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_STAT_LX_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.FileId == other.FileId && self.CreationTime == other.CreationTime && self.LastAccessTime == other.LastAccessTime && self.LastWriteTime == other.LastWriteTime && self.ChangeTime == other.ChangeTime && self.AllocationSize == other.AllocationSize && self.EndOfFile == other.EndOfFile && self.FileAttributes == other.FileAttributes && self.ReparseTag == other.ReparseTag && self.NumberOfLinks == other.NumberOfLinks && self.EffectiveAccess == other.EffectiveAccess && self.LxFlags == other.LxFlags && self.LxUid == other.LxUid && self.LxGid == other.LxGid && self.LxMode == other.LxMode && self.LxDeviceIdMajor == other.LxDeviceIdMajor && self.LxDeviceIdMinor == other.LxDeviceIdMinor
    }
}
impl ::core::cmp::Eq for FILE_STAT_LX_INFORMATION {}
impl ::core::default::Default for FILE_STAT_LX_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_STORAGE_RESERVE_ID_INFORMATION {
    pub StorageReserveId: STORAGE_RESERVE_ID,
}
impl ::core::marker::Copy for FILE_STORAGE_RESERVE_ID_INFORMATION {}
impl ::core::clone::Clone for FILE_STORAGE_RESERVE_ID_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_STORAGE_RESERVE_ID_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_STORAGE_RESERVE_ID_INFORMATION").field("StorageReserveId", &self.StorageReserveId).finish()
    }
}
impl ::windows_core::TypeKind for FILE_STORAGE_RESERVE_ID_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_STORAGE_RESERVE_ID_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.StorageReserveId == other.StorageReserveId
    }
}
impl ::core::cmp::Eq for FILE_STORAGE_RESERVE_ID_INFORMATION {}
impl ::core::default::Default for FILE_STORAGE_RESERVE_ID_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_STORAGE_TIER {
    pub Id: ::windows_core::GUID,
    pub Name: [u16; 256],
    pub Description: [u16; 256],
    pub Flags: u64,
    pub ProvisionedCapacity: u64,
    pub MediaType: FILE_STORAGE_TIER_MEDIA_TYPE,
    pub Class: FILE_STORAGE_TIER_CLASS,
}
impl ::core::marker::Copy for FILE_STORAGE_TIER {}
impl ::core::clone::Clone for FILE_STORAGE_TIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_STORAGE_TIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_STORAGE_TIER").field("Id", &self.Id).field("Name", &self.Name).field("Description", &self.Description).field("Flags", &self.Flags).field("ProvisionedCapacity", &self.ProvisionedCapacity).field("MediaType", &self.MediaType).field("Class", &self.Class).finish()
    }
}
impl ::windows_core::TypeKind for FILE_STORAGE_TIER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_STORAGE_TIER {
    fn eq(&self, other: &Self) -> bool {
        self.Id == other.Id && self.Name == other.Name && self.Description == other.Description && self.Flags == other.Flags && self.ProvisionedCapacity == other.ProvisionedCapacity && self.MediaType == other.MediaType && self.Class == other.Class
    }
}
impl ::core::cmp::Eq for FILE_STORAGE_TIER {}
impl ::core::default::Default for FILE_STORAGE_TIER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_STORAGE_TIER_REGION {
    pub TierId: ::windows_core::GUID,
    pub Offset: u64,
    pub Length: u64,
}
impl ::core::marker::Copy for FILE_STORAGE_TIER_REGION {}
impl ::core::clone::Clone for FILE_STORAGE_TIER_REGION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_STORAGE_TIER_REGION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_STORAGE_TIER_REGION").field("TierId", &self.TierId).field("Offset", &self.Offset).field("Length", &self.Length).finish()
    }
}
impl ::windows_core::TypeKind for FILE_STORAGE_TIER_REGION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_STORAGE_TIER_REGION {
    fn eq(&self, other: &Self) -> bool {
        self.TierId == other.TierId && self.Offset == other.Offset && self.Length == other.Length
    }
}
impl ::core::cmp::Eq for FILE_STORAGE_TIER_REGION {}
impl ::core::default::Default for FILE_STORAGE_TIER_REGION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_STREAM_INFORMATION {
    pub NextEntryOffset: u32,
    pub StreamNameLength: u32,
    pub StreamSize: i64,
    pub StreamAllocationSize: i64,
    pub StreamName: [u16; 1],
}
impl ::core::marker::Copy for FILE_STREAM_INFORMATION {}
impl ::core::clone::Clone for FILE_STREAM_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_STREAM_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_STREAM_INFORMATION").field("NextEntryOffset", &self.NextEntryOffset).field("StreamNameLength", &self.StreamNameLength).field("StreamSize", &self.StreamSize).field("StreamAllocationSize", &self.StreamAllocationSize).field("StreamName", &self.StreamName).finish()
    }
}
impl ::windows_core::TypeKind for FILE_STREAM_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_STREAM_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.NextEntryOffset == other.NextEntryOffset && self.StreamNameLength == other.StreamNameLength && self.StreamSize == other.StreamSize && self.StreamAllocationSize == other.StreamAllocationSize && self.StreamName == other.StreamName
    }
}
impl ::core::cmp::Eq for FILE_STREAM_INFORMATION {}
impl ::core::default::Default for FILE_STREAM_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_SYSTEM_RECOGNITION_INFORMATION {
    pub FileSystem: [u8; 9],
}
impl ::core::marker::Copy for FILE_SYSTEM_RECOGNITION_INFORMATION {}
impl ::core::clone::Clone for FILE_SYSTEM_RECOGNITION_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_SYSTEM_RECOGNITION_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_SYSTEM_RECOGNITION_INFORMATION").field("FileSystem", &self.FileSystem).finish()
    }
}
impl ::windows_core::TypeKind for FILE_SYSTEM_RECOGNITION_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_SYSTEM_RECOGNITION_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.FileSystem == other.FileSystem
    }
}
impl ::core::cmp::Eq for FILE_SYSTEM_RECOGNITION_INFORMATION {}
impl ::core::default::Default for FILE_SYSTEM_RECOGNITION_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_TIMESTAMPS {
    pub CreationTime: i64,
    pub LastAccessTime: i64,
    pub LastWriteTime: i64,
    pub ChangeTime: i64,
}
impl ::core::marker::Copy for FILE_TIMESTAMPS {}
impl ::core::clone::Clone for FILE_TIMESTAMPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_TIMESTAMPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_TIMESTAMPS").field("CreationTime", &self.CreationTime).field("LastAccessTime", &self.LastAccessTime).field("LastWriteTime", &self.LastWriteTime).field("ChangeTime", &self.ChangeTime).finish()
    }
}
impl ::windows_core::TypeKind for FILE_TIMESTAMPS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_TIMESTAMPS {
    fn eq(&self, other: &Self) -> bool {
        self.CreationTime == other.CreationTime && self.LastAccessTime == other.LastAccessTime && self.LastWriteTime == other.LastWriteTime && self.ChangeTime == other.ChangeTime
    }
}
impl ::core::cmp::Eq for FILE_TIMESTAMPS {}
impl ::core::default::Default for FILE_TIMESTAMPS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct FILE_TRACKING_INFORMATION {
    pub DestinationFile: super::super::super::Win32::Foundation::HANDLE,
    pub ObjectInformationLength: u32,
    pub ObjectInformation: [u8; 1],
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FILE_TRACKING_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FILE_TRACKING_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for FILE_TRACKING_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_TRACKING_INFORMATION").field("DestinationFile", &self.DestinationFile).field("ObjectInformationLength", &self.ObjectInformationLength).field("ObjectInformation", &self.ObjectInformation).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FILE_TRACKING_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for FILE_TRACKING_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.DestinationFile == other.DestinationFile && self.ObjectInformationLength == other.ObjectInformationLength && self.ObjectInformation == other.ObjectInformation
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for FILE_TRACKING_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FILE_TRACKING_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_TYPE_NOTIFICATION_INPUT {
    pub Flags: u32,
    pub NumFileTypeIDs: u32,
    pub FileTypeID: [::windows_core::GUID; 1],
}
impl ::core::marker::Copy for FILE_TYPE_NOTIFICATION_INPUT {}
impl ::core::clone::Clone for FILE_TYPE_NOTIFICATION_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_TYPE_NOTIFICATION_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_TYPE_NOTIFICATION_INPUT").field("Flags", &self.Flags).field("NumFileTypeIDs", &self.NumFileTypeIDs).field("FileTypeID", &self.FileTypeID).finish()
    }
}
impl ::windows_core::TypeKind for FILE_TYPE_NOTIFICATION_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_TYPE_NOTIFICATION_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags && self.NumFileTypeIDs == other.NumFileTypeIDs && self.FileTypeID == other.FileTypeID
    }
}
impl ::core::cmp::Eq for FILE_TYPE_NOTIFICATION_INPUT {}
impl ::core::default::Default for FILE_TYPE_NOTIFICATION_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_VOLUME_NAME_INFORMATION {
    pub DeviceNameLength: u32,
    pub DeviceName: [u16; 1],
}
impl ::core::marker::Copy for FILE_VOLUME_NAME_INFORMATION {}
impl ::core::clone::Clone for FILE_VOLUME_NAME_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_VOLUME_NAME_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_VOLUME_NAME_INFORMATION").field("DeviceNameLength", &self.DeviceNameLength).field("DeviceName", &self.DeviceName).finish()
    }
}
impl ::windows_core::TypeKind for FILE_VOLUME_NAME_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_VOLUME_NAME_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.DeviceNameLength == other.DeviceNameLength && self.DeviceName == other.DeviceName
    }
}
impl ::core::cmp::Eq for FILE_VOLUME_NAME_INFORMATION {}
impl ::core::default::Default for FILE_VOLUME_NAME_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_ZERO_DATA_INFORMATION {
    pub FileOffset: i64,
    pub BeyondFinalZero: i64,
}
impl ::core::marker::Copy for FILE_ZERO_DATA_INFORMATION {}
impl ::core::clone::Clone for FILE_ZERO_DATA_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_ZERO_DATA_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_ZERO_DATA_INFORMATION").field("FileOffset", &self.FileOffset).field("BeyondFinalZero", &self.BeyondFinalZero).finish()
    }
}
impl ::windows_core::TypeKind for FILE_ZERO_DATA_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_ZERO_DATA_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.FileOffset == other.FileOffset && self.BeyondFinalZero == other.BeyondFinalZero
    }
}
impl ::core::cmp::Eq for FILE_ZERO_DATA_INFORMATION {}
impl ::core::default::Default for FILE_ZERO_DATA_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FILE_ZERO_DATA_INFORMATION_EX {
    pub FileOffset: i64,
    pub BeyondFinalZero: i64,
    pub Flags: u32,
}
impl ::core::marker::Copy for FILE_ZERO_DATA_INFORMATION_EX {}
impl ::core::clone::Clone for FILE_ZERO_DATA_INFORMATION_EX {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FILE_ZERO_DATA_INFORMATION_EX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FILE_ZERO_DATA_INFORMATION_EX").field("FileOffset", &self.FileOffset).field("BeyondFinalZero", &self.BeyondFinalZero).field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for FILE_ZERO_DATA_INFORMATION_EX {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FILE_ZERO_DATA_INFORMATION_EX {
    fn eq(&self, other: &Self) -> bool {
        self.FileOffset == other.FileOffset && self.BeyondFinalZero == other.BeyondFinalZero && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for FILE_ZERO_DATA_INFORMATION_EX {}
impl ::core::default::Default for FILE_ZERO_DATA_INFORMATION_EX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Security\"`*"]
#[cfg(feature = "Win32_Security")]
pub struct FIND_BY_SID_DATA {
    pub Restart: u32,
    pub Sid: super::super::super::Win32::Security::SID,
}
#[cfg(feature = "Win32_Security")]
impl ::core::marker::Copy for FIND_BY_SID_DATA {}
#[cfg(feature = "Win32_Security")]
impl ::core::clone::Clone for FIND_BY_SID_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Security")]
impl ::core::fmt::Debug for FIND_BY_SID_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FIND_BY_SID_DATA").field("Restart", &self.Restart).field("Sid", &self.Sid).finish()
    }
}
#[cfg(feature = "Win32_Security")]
impl ::windows_core::TypeKind for FIND_BY_SID_DATA {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Security")]
impl ::core::cmp::PartialEq for FIND_BY_SID_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Restart == other.Restart && self.Sid == other.Sid
    }
}
#[cfg(feature = "Win32_Security")]
impl ::core::cmp::Eq for FIND_BY_SID_DATA {}
#[cfg(feature = "Win32_Security")]
impl ::core::default::Default for FIND_BY_SID_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FIND_BY_SID_OUTPUT {
    pub NextEntryOffset: u32,
    pub FileIndex: u32,
    pub FileNameLength: u32,
    pub FileName: [u16; 1],
}
impl ::core::marker::Copy for FIND_BY_SID_OUTPUT {}
impl ::core::clone::Clone for FIND_BY_SID_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FIND_BY_SID_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FIND_BY_SID_OUTPUT").field("NextEntryOffset", &self.NextEntryOffset).field("FileIndex", &self.FileIndex).field("FileNameLength", &self.FileNameLength).field("FileName", &self.FileName).finish()
    }
}
impl ::windows_core::TypeKind for FIND_BY_SID_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FIND_BY_SID_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.NextEntryOffset == other.NextEntryOffset && self.FileIndex == other.FileIndex && self.FileNameLength == other.FileNameLength && self.FileName == other.FileName
    }
}
impl ::core::cmp::Eq for FIND_BY_SID_OUTPUT {}
impl ::core::default::Default for FIND_BY_SID_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FSCTL_GET_INTEGRITY_INFORMATION_BUFFER {
    pub ChecksumAlgorithm: u16,
    pub Reserved: u16,
    pub Flags: u32,
    pub ChecksumChunkSizeInBytes: u32,
    pub ClusterSizeInBytes: u32,
}
impl ::core::marker::Copy for FSCTL_GET_INTEGRITY_INFORMATION_BUFFER {}
impl ::core::clone::Clone for FSCTL_GET_INTEGRITY_INFORMATION_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FSCTL_GET_INTEGRITY_INFORMATION_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSCTL_GET_INTEGRITY_INFORMATION_BUFFER").field("ChecksumAlgorithm", &self.ChecksumAlgorithm).field("Reserved", &self.Reserved).field("Flags", &self.Flags).field("ChecksumChunkSizeInBytes", &self.ChecksumChunkSizeInBytes).field("ClusterSizeInBytes", &self.ClusterSizeInBytes).finish()
    }
}
impl ::windows_core::TypeKind for FSCTL_GET_INTEGRITY_INFORMATION_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FSCTL_GET_INTEGRITY_INFORMATION_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.ChecksumAlgorithm == other.ChecksumAlgorithm && self.Reserved == other.Reserved && self.Flags == other.Flags && self.ChecksumChunkSizeInBytes == other.ChecksumChunkSizeInBytes && self.ClusterSizeInBytes == other.ClusterSizeInBytes
    }
}
impl ::core::cmp::Eq for FSCTL_GET_INTEGRITY_INFORMATION_BUFFER {}
impl ::core::default::Default for FSCTL_GET_INTEGRITY_INFORMATION_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FSCTL_GHOST_FILE_EXTENTS_INPUT_BUFFER {
    pub FileOffset: i64,
    pub ByteCount: i64,
    pub RecallOwnerGuid: ::windows_core::GUID,
    pub RecallMetadataBufferSize: u32,
    pub RecallMetadataBuffer: [u8; 1],
}
impl ::core::marker::Copy for FSCTL_GHOST_FILE_EXTENTS_INPUT_BUFFER {}
impl ::core::clone::Clone for FSCTL_GHOST_FILE_EXTENTS_INPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FSCTL_GHOST_FILE_EXTENTS_INPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSCTL_GHOST_FILE_EXTENTS_INPUT_BUFFER").field("FileOffset", &self.FileOffset).field("ByteCount", &self.ByteCount).field("RecallOwnerGuid", &self.RecallOwnerGuid).field("RecallMetadataBufferSize", &self.RecallMetadataBufferSize).field("RecallMetadataBuffer", &self.RecallMetadataBuffer).finish()
    }
}
impl ::windows_core::TypeKind for FSCTL_GHOST_FILE_EXTENTS_INPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FSCTL_GHOST_FILE_EXTENTS_INPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.FileOffset == other.FileOffset && self.ByteCount == other.ByteCount && self.RecallOwnerGuid == other.RecallOwnerGuid && self.RecallMetadataBufferSize == other.RecallMetadataBufferSize && self.RecallMetadataBuffer == other.RecallMetadataBuffer
    }
}
impl ::core::cmp::Eq for FSCTL_GHOST_FILE_EXTENTS_INPUT_BUFFER {}
impl ::core::default::Default for FSCTL_GHOST_FILE_EXTENTS_INPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FSCTL_OFFLOAD_READ_INPUT {
    pub Size: u32,
    pub Flags: u32,
    pub TokenTimeToLive: u32,
    pub Reserved: u32,
    pub FileOffset: u64,
    pub CopyLength: u64,
}
impl ::core::marker::Copy for FSCTL_OFFLOAD_READ_INPUT {}
impl ::core::clone::Clone for FSCTL_OFFLOAD_READ_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FSCTL_OFFLOAD_READ_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSCTL_OFFLOAD_READ_INPUT").field("Size", &self.Size).field("Flags", &self.Flags).field("TokenTimeToLive", &self.TokenTimeToLive).field("Reserved", &self.Reserved).field("FileOffset", &self.FileOffset).field("CopyLength", &self.CopyLength).finish()
    }
}
impl ::windows_core::TypeKind for FSCTL_OFFLOAD_READ_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FSCTL_OFFLOAD_READ_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.Flags == other.Flags && self.TokenTimeToLive == other.TokenTimeToLive && self.Reserved == other.Reserved && self.FileOffset == other.FileOffset && self.CopyLength == other.CopyLength
    }
}
impl ::core::cmp::Eq for FSCTL_OFFLOAD_READ_INPUT {}
impl ::core::default::Default for FSCTL_OFFLOAD_READ_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FSCTL_OFFLOAD_READ_OUTPUT {
    pub Size: u32,
    pub Flags: u32,
    pub TransferLength: u64,
    pub Token: [u8; 512],
}
impl ::core::marker::Copy for FSCTL_OFFLOAD_READ_OUTPUT {}
impl ::core::clone::Clone for FSCTL_OFFLOAD_READ_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FSCTL_OFFLOAD_READ_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSCTL_OFFLOAD_READ_OUTPUT").field("Size", &self.Size).field("Flags", &self.Flags).field("TransferLength", &self.TransferLength).field("Token", &self.Token).finish()
    }
}
impl ::windows_core::TypeKind for FSCTL_OFFLOAD_READ_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FSCTL_OFFLOAD_READ_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.Flags == other.Flags && self.TransferLength == other.TransferLength && self.Token == other.Token
    }
}
impl ::core::cmp::Eq for FSCTL_OFFLOAD_READ_OUTPUT {}
impl ::core::default::Default for FSCTL_OFFLOAD_READ_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FSCTL_OFFLOAD_WRITE_INPUT {
    pub Size: u32,
    pub Flags: u32,
    pub FileOffset: u64,
    pub CopyLength: u64,
    pub TransferOffset: u64,
    pub Token: [u8; 512],
}
impl ::core::marker::Copy for FSCTL_OFFLOAD_WRITE_INPUT {}
impl ::core::clone::Clone for FSCTL_OFFLOAD_WRITE_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FSCTL_OFFLOAD_WRITE_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSCTL_OFFLOAD_WRITE_INPUT").field("Size", &self.Size).field("Flags", &self.Flags).field("FileOffset", &self.FileOffset).field("CopyLength", &self.CopyLength).field("TransferOffset", &self.TransferOffset).field("Token", &self.Token).finish()
    }
}
impl ::windows_core::TypeKind for FSCTL_OFFLOAD_WRITE_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FSCTL_OFFLOAD_WRITE_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.Flags == other.Flags && self.FileOffset == other.FileOffset && self.CopyLength == other.CopyLength && self.TransferOffset == other.TransferOffset && self.Token == other.Token
    }
}
impl ::core::cmp::Eq for FSCTL_OFFLOAD_WRITE_INPUT {}
impl ::core::default::Default for FSCTL_OFFLOAD_WRITE_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FSCTL_OFFLOAD_WRITE_OUTPUT {
    pub Size: u32,
    pub Flags: u32,
    pub LengthWritten: u64,
}
impl ::core::marker::Copy for FSCTL_OFFLOAD_WRITE_OUTPUT {}
impl ::core::clone::Clone for FSCTL_OFFLOAD_WRITE_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FSCTL_OFFLOAD_WRITE_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSCTL_OFFLOAD_WRITE_OUTPUT").field("Size", &self.Size).field("Flags", &self.Flags).field("LengthWritten", &self.LengthWritten).finish()
    }
}
impl ::windows_core::TypeKind for FSCTL_OFFLOAD_WRITE_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FSCTL_OFFLOAD_WRITE_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.Flags == other.Flags && self.LengthWritten == other.LengthWritten
    }
}
impl ::core::cmp::Eq for FSCTL_OFFLOAD_WRITE_OUTPUT {}
impl ::core::default::Default for FSCTL_OFFLOAD_WRITE_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FSCTL_QUERY_FAT_BPB_BUFFER {
    pub First0x24BytesOfBootSector: [u8; 36],
}
impl ::core::marker::Copy for FSCTL_QUERY_FAT_BPB_BUFFER {}
impl ::core::clone::Clone for FSCTL_QUERY_FAT_BPB_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FSCTL_QUERY_FAT_BPB_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSCTL_QUERY_FAT_BPB_BUFFER").field("First0x24BytesOfBootSector", &self.First0x24BytesOfBootSector).finish()
    }
}
impl ::windows_core::TypeKind for FSCTL_QUERY_FAT_BPB_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FSCTL_QUERY_FAT_BPB_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.First0x24BytesOfBootSector == other.First0x24BytesOfBootSector
    }
}
impl ::core::cmp::Eq for FSCTL_QUERY_FAT_BPB_BUFFER {}
impl ::core::default::Default for FSCTL_QUERY_FAT_BPB_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FSCTL_QUERY_GHOSTED_FILE_EXTENTS_INPUT_RANGE {
    pub FileOffset: i64,
    pub ByteCount: i64,
}
impl ::core::marker::Copy for FSCTL_QUERY_GHOSTED_FILE_EXTENTS_INPUT_RANGE {}
impl ::core::clone::Clone for FSCTL_QUERY_GHOSTED_FILE_EXTENTS_INPUT_RANGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FSCTL_QUERY_GHOSTED_FILE_EXTENTS_INPUT_RANGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSCTL_QUERY_GHOSTED_FILE_EXTENTS_INPUT_RANGE").field("FileOffset", &self.FileOffset).field("ByteCount", &self.ByteCount).finish()
    }
}
impl ::windows_core::TypeKind for FSCTL_QUERY_GHOSTED_FILE_EXTENTS_INPUT_RANGE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FSCTL_QUERY_GHOSTED_FILE_EXTENTS_INPUT_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.FileOffset == other.FileOffset && self.ByteCount == other.ByteCount
    }
}
impl ::core::cmp::Eq for FSCTL_QUERY_GHOSTED_FILE_EXTENTS_INPUT_RANGE {}
impl ::core::default::Default for FSCTL_QUERY_GHOSTED_FILE_EXTENTS_INPUT_RANGE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FSCTL_QUERY_GHOSTED_FILE_EXTENTS_OUTPUT {
    pub ExtentCount: u32,
    pub TotalExtentCount: u32,
    pub Extents: [u8; 1],
}
impl ::core::marker::Copy for FSCTL_QUERY_GHOSTED_FILE_EXTENTS_OUTPUT {}
impl ::core::clone::Clone for FSCTL_QUERY_GHOSTED_FILE_EXTENTS_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FSCTL_QUERY_GHOSTED_FILE_EXTENTS_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSCTL_QUERY_GHOSTED_FILE_EXTENTS_OUTPUT").field("ExtentCount", &self.ExtentCount).field("TotalExtentCount", &self.TotalExtentCount).field("Extents", &self.Extents).finish()
    }
}
impl ::windows_core::TypeKind for FSCTL_QUERY_GHOSTED_FILE_EXTENTS_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FSCTL_QUERY_GHOSTED_FILE_EXTENTS_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.ExtentCount == other.ExtentCount && self.TotalExtentCount == other.TotalExtentCount && self.Extents == other.Extents
    }
}
impl ::core::cmp::Eq for FSCTL_QUERY_GHOSTED_FILE_EXTENTS_OUTPUT {}
impl ::core::default::Default for FSCTL_QUERY_GHOSTED_FILE_EXTENTS_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FSCTL_QUERY_REGION_INFO_INPUT {
    pub Version: u32,
    pub Size: u32,
    pub Flags: u32,
    pub NumberOfTierIds: u32,
    pub TierIds: [::windows_core::GUID; 1],
}
impl ::core::marker::Copy for FSCTL_QUERY_REGION_INFO_INPUT {}
impl ::core::clone::Clone for FSCTL_QUERY_REGION_INFO_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FSCTL_QUERY_REGION_INFO_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSCTL_QUERY_REGION_INFO_INPUT").field("Version", &self.Version).field("Size", &self.Size).field("Flags", &self.Flags).field("NumberOfTierIds", &self.NumberOfTierIds).field("TierIds", &self.TierIds).finish()
    }
}
impl ::windows_core::TypeKind for FSCTL_QUERY_REGION_INFO_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FSCTL_QUERY_REGION_INFO_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Size == other.Size && self.Flags == other.Flags && self.NumberOfTierIds == other.NumberOfTierIds && self.TierIds == other.TierIds
    }
}
impl ::core::cmp::Eq for FSCTL_QUERY_REGION_INFO_INPUT {}
impl ::core::default::Default for FSCTL_QUERY_REGION_INFO_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FSCTL_QUERY_REGION_INFO_OUTPUT {
    pub Version: u32,
    pub Size: u32,
    pub Flags: u32,
    pub Reserved: u32,
    pub Alignment: u64,
    pub TotalNumberOfRegions: u32,
    pub NumberOfRegionsReturned: u32,
    pub Regions: [FILE_STORAGE_TIER_REGION; 1],
}
impl ::core::marker::Copy for FSCTL_QUERY_REGION_INFO_OUTPUT {}
impl ::core::clone::Clone for FSCTL_QUERY_REGION_INFO_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FSCTL_QUERY_REGION_INFO_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSCTL_QUERY_REGION_INFO_OUTPUT").field("Version", &self.Version).field("Size", &self.Size).field("Flags", &self.Flags).field("Reserved", &self.Reserved).field("Alignment", &self.Alignment).field("TotalNumberOfRegions", &self.TotalNumberOfRegions).field("NumberOfRegionsReturned", &self.NumberOfRegionsReturned).field("Regions", &self.Regions).finish()
    }
}
impl ::windows_core::TypeKind for FSCTL_QUERY_REGION_INFO_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FSCTL_QUERY_REGION_INFO_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Size == other.Size && self.Flags == other.Flags && self.Reserved == other.Reserved && self.Alignment == other.Alignment && self.TotalNumberOfRegions == other.TotalNumberOfRegions && self.NumberOfRegionsReturned == other.NumberOfRegionsReturned && self.Regions == other.Regions
    }
}
impl ::core::cmp::Eq for FSCTL_QUERY_REGION_INFO_OUTPUT {}
impl ::core::default::Default for FSCTL_QUERY_REGION_INFO_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FSCTL_QUERY_STORAGE_CLASSES_OUTPUT {
    pub Version: u32,
    pub Size: u32,
    pub Flags: u32,
    pub TotalNumberOfTiers: u32,
    pub NumberOfTiersReturned: u32,
    pub Tiers: [FILE_STORAGE_TIER; 1],
}
impl ::core::marker::Copy for FSCTL_QUERY_STORAGE_CLASSES_OUTPUT {}
impl ::core::clone::Clone for FSCTL_QUERY_STORAGE_CLASSES_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FSCTL_QUERY_STORAGE_CLASSES_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSCTL_QUERY_STORAGE_CLASSES_OUTPUT").field("Version", &self.Version).field("Size", &self.Size).field("Flags", &self.Flags).field("TotalNumberOfTiers", &self.TotalNumberOfTiers).field("NumberOfTiersReturned", &self.NumberOfTiersReturned).field("Tiers", &self.Tiers).finish()
    }
}
impl ::windows_core::TypeKind for FSCTL_QUERY_STORAGE_CLASSES_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FSCTL_QUERY_STORAGE_CLASSES_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Size == other.Size && self.Flags == other.Flags && self.TotalNumberOfTiers == other.TotalNumberOfTiers && self.NumberOfTiersReturned == other.NumberOfTiersReturned && self.Tiers == other.Tiers
    }
}
impl ::core::cmp::Eq for FSCTL_QUERY_STORAGE_CLASSES_OUTPUT {}
impl ::core::default::Default for FSCTL_QUERY_STORAGE_CLASSES_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FSCTL_QUERY_VOLUME_NUMA_INFO_OUTPUT {
    pub NumaNode: u32,
}
impl ::core::marker::Copy for FSCTL_QUERY_VOLUME_NUMA_INFO_OUTPUT {}
impl ::core::clone::Clone for FSCTL_QUERY_VOLUME_NUMA_INFO_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FSCTL_QUERY_VOLUME_NUMA_INFO_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSCTL_QUERY_VOLUME_NUMA_INFO_OUTPUT").field("NumaNode", &self.NumaNode).finish()
    }
}
impl ::windows_core::TypeKind for FSCTL_QUERY_VOLUME_NUMA_INFO_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FSCTL_QUERY_VOLUME_NUMA_INFO_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.NumaNode == other.NumaNode
    }
}
impl ::core::cmp::Eq for FSCTL_QUERY_VOLUME_NUMA_INFO_OUTPUT {}
impl ::core::default::Default for FSCTL_QUERY_VOLUME_NUMA_INFO_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FSCTL_SET_INTEGRITY_INFORMATION_BUFFER {
    pub ChecksumAlgorithm: u16,
    pub Reserved: u16,
    pub Flags: u32,
}
impl ::core::marker::Copy for FSCTL_SET_INTEGRITY_INFORMATION_BUFFER {}
impl ::core::clone::Clone for FSCTL_SET_INTEGRITY_INFORMATION_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FSCTL_SET_INTEGRITY_INFORMATION_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSCTL_SET_INTEGRITY_INFORMATION_BUFFER").field("ChecksumAlgorithm", &self.ChecksumAlgorithm).field("Reserved", &self.Reserved).field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for FSCTL_SET_INTEGRITY_INFORMATION_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FSCTL_SET_INTEGRITY_INFORMATION_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.ChecksumAlgorithm == other.ChecksumAlgorithm && self.Reserved == other.Reserved && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for FSCTL_SET_INTEGRITY_INFORMATION_BUFFER {}
impl ::core::default::Default for FSCTL_SET_INTEGRITY_INFORMATION_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX {
    pub EnableIntegrity: u8,
    pub KeepIntegrityStateUnchanged: u8,
    pub Reserved: u16,
    pub Flags: u32,
    pub Version: u8,
    pub Reserved2: [u8; 7],
}
impl ::core::marker::Copy for FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX {}
impl ::core::clone::Clone for FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX").field("EnableIntegrity", &self.EnableIntegrity).field("KeepIntegrityStateUnchanged", &self.KeepIntegrityStateUnchanged).field("Reserved", &self.Reserved).field("Flags", &self.Flags).field("Version", &self.Version).field("Reserved2", &self.Reserved2).finish()
    }
}
impl ::windows_core::TypeKind for FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX {
    fn eq(&self, other: &Self) -> bool {
        self.EnableIntegrity == other.EnableIntegrity && self.KeepIntegrityStateUnchanged == other.KeepIntegrityStateUnchanged && self.Reserved == other.Reserved && self.Flags == other.Flags && self.Version == other.Version && self.Reserved2 == other.Reserved2
    }
}
impl ::core::cmp::Eq for FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX {}
impl ::core::default::Default for FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FSCTL_UNMAP_SPACE_INPUT_BUFFER {
    pub BytesToUnmap: i64,
}
impl ::core::marker::Copy for FSCTL_UNMAP_SPACE_INPUT_BUFFER {}
impl ::core::clone::Clone for FSCTL_UNMAP_SPACE_INPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FSCTL_UNMAP_SPACE_INPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSCTL_UNMAP_SPACE_INPUT_BUFFER").field("BytesToUnmap", &self.BytesToUnmap).finish()
    }
}
impl ::windows_core::TypeKind for FSCTL_UNMAP_SPACE_INPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FSCTL_UNMAP_SPACE_INPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.BytesToUnmap == other.BytesToUnmap
    }
}
impl ::core::cmp::Eq for FSCTL_UNMAP_SPACE_INPUT_BUFFER {}
impl ::core::default::Default for FSCTL_UNMAP_SPACE_INPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FSCTL_UNMAP_SPACE_OUTPUT {
    pub BytesUnmapped: i64,
}
impl ::core::marker::Copy for FSCTL_UNMAP_SPACE_OUTPUT {}
impl ::core::clone::Clone for FSCTL_UNMAP_SPACE_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FSCTL_UNMAP_SPACE_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSCTL_UNMAP_SPACE_OUTPUT").field("BytesUnmapped", &self.BytesUnmapped).finish()
    }
}
impl ::windows_core::TypeKind for FSCTL_UNMAP_SPACE_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FSCTL_UNMAP_SPACE_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.BytesUnmapped == other.BytesUnmapped
    }
}
impl ::core::cmp::Eq for FSCTL_UNMAP_SPACE_OUTPUT {}
impl ::core::default::Default for FSCTL_UNMAP_SPACE_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
pub struct FSRTL_ADVANCED_FCB_HEADER {
    pub Base: FSRTL_COMMON_FCB_HEADER,
    pub FastMutex: *mut super::super::Foundation::FAST_MUTEX,
    pub FilterContexts: super::super::super::Win32::System::Kernel::LIST_ENTRY,
    pub PushLock: usize,
    pub FileContextSupportPointer: *mut *mut ::core::ffi::c_void,
    pub Anonymous: FSRTL_ADVANCED_FCB_HEADER_0,
    pub AePushLock: *mut ::core::ffi::c_void,
    pub BypassIoOpenCount: u32,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::marker::Copy for FSRTL_ADVANCED_FCB_HEADER {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::clone::Clone for FSRTL_ADVANCED_FCB_HEADER {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::windows_core::TypeKind for FSRTL_ADVANCED_FCB_HEADER {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::default::Default for FSRTL_ADVANCED_FCB_HEADER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
pub union FSRTL_ADVANCED_FCB_HEADER_0 {
    pub Oplock: *mut ::core::ffi::c_void,
    pub ReservedForRemote: *mut ::core::ffi::c_void,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::marker::Copy for FSRTL_ADVANCED_FCB_HEADER_0 {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::clone::Clone for FSRTL_ADVANCED_FCB_HEADER_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::windows_core::TypeKind for FSRTL_ADVANCED_FCB_HEADER_0 {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::default::Default for FSRTL_ADVANCED_FCB_HEADER_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Graphics_DirectDraw\"`*"]
#[cfg(feature = "Win32_Graphics_DirectDraw")]
pub struct FSRTL_AUXILIARY_BUFFER {
    pub Buffer: *mut ::core::ffi::c_void,
    pub Length: u32,
    pub Flags: u32,
    pub Mdl: *mut super::super::super::Win32::Graphics::DirectDraw::MDL,
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl ::core::marker::Copy for FSRTL_AUXILIARY_BUFFER {}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl ::core::clone::Clone for FSRTL_AUXILIARY_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl ::core::fmt::Debug for FSRTL_AUXILIARY_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSRTL_AUXILIARY_BUFFER").field("Buffer", &self.Buffer).field("Length", &self.Length).field("Flags", &self.Flags).field("Mdl", &self.Mdl).finish()
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl ::windows_core::TypeKind for FSRTL_AUXILIARY_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl ::core::cmp::PartialEq for FSRTL_AUXILIARY_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.Buffer == other.Buffer && self.Length == other.Length && self.Flags == other.Flags && self.Mdl == other.Mdl
    }
}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl ::core::cmp::Eq for FSRTL_AUXILIARY_BUFFER {}
#[cfg(feature = "Win32_Graphics_DirectDraw")]
impl ::core::default::Default for FSRTL_AUXILIARY_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
pub struct FSRTL_COMMON_FCB_HEADER {
    pub NodeTypeCode: i16,
    pub NodeByteSize: i16,
    pub Flags: u8,
    pub IsFastIoPossible: u8,
    pub Flags2: u8,
    pub _bitfield: u8,
    pub Resource: *mut super::super::Foundation::ERESOURCE,
    pub PagingIoResource: *mut super::super::Foundation::ERESOURCE,
    pub AllocationSize: i64,
    pub FileSize: i64,
    pub ValidDataLength: i64,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::marker::Copy for FSRTL_COMMON_FCB_HEADER {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::clone::Clone for FSRTL_COMMON_FCB_HEADER {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::fmt::Debug for FSRTL_COMMON_FCB_HEADER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSRTL_COMMON_FCB_HEADER")
            .field("NodeTypeCode", &self.NodeTypeCode)
            .field("NodeByteSize", &self.NodeByteSize)
            .field("Flags", &self.Flags)
            .field("IsFastIoPossible", &self.IsFastIoPossible)
            .field("Flags2", &self.Flags2)
            .field("_bitfield", &self._bitfield)
            .field("Resource", &self.Resource)
            .field("PagingIoResource", &self.PagingIoResource)
            .field("AllocationSize", &self.AllocationSize)
            .field("FileSize", &self.FileSize)
            .field("ValidDataLength", &self.ValidDataLength)
            .finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::windows_core::TypeKind for FSRTL_COMMON_FCB_HEADER {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::cmp::PartialEq for FSRTL_COMMON_FCB_HEADER {
    fn eq(&self, other: &Self) -> bool {
        self.NodeTypeCode == other.NodeTypeCode && self.NodeByteSize == other.NodeByteSize && self.Flags == other.Flags && self.IsFastIoPossible == other.IsFastIoPossible && self.Flags2 == other.Flags2 && self._bitfield == other._bitfield && self.Resource == other.Resource && self.PagingIoResource == other.PagingIoResource && self.AllocationSize == other.AllocationSize && self.FileSize == other.FileSize && self.ValidDataLength == other.ValidDataLength
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::cmp::Eq for FSRTL_COMMON_FCB_HEADER {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::default::Default for FSRTL_COMMON_FCB_HEADER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FSRTL_MUP_PROVIDER_INFO_LEVEL_1 {
    pub ProviderId: u32,
}
impl ::core::marker::Copy for FSRTL_MUP_PROVIDER_INFO_LEVEL_1 {}
impl ::core::clone::Clone for FSRTL_MUP_PROVIDER_INFO_LEVEL_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FSRTL_MUP_PROVIDER_INFO_LEVEL_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSRTL_MUP_PROVIDER_INFO_LEVEL_1").field("ProviderId", &self.ProviderId).finish()
    }
}
impl ::windows_core::TypeKind for FSRTL_MUP_PROVIDER_INFO_LEVEL_1 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FSRTL_MUP_PROVIDER_INFO_LEVEL_1 {
    fn eq(&self, other: &Self) -> bool {
        self.ProviderId == other.ProviderId
    }
}
impl ::core::cmp::Eq for FSRTL_MUP_PROVIDER_INFO_LEVEL_1 {}
impl ::core::default::Default for FSRTL_MUP_PROVIDER_INFO_LEVEL_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct FSRTL_MUP_PROVIDER_INFO_LEVEL_2 {
    pub ProviderId: u32,
    pub ProviderName: super::super::super::Win32::Foundation::UNICODE_STRING,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FSRTL_MUP_PROVIDER_INFO_LEVEL_2 {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FSRTL_MUP_PROVIDER_INFO_LEVEL_2 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for FSRTL_MUP_PROVIDER_INFO_LEVEL_2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSRTL_MUP_PROVIDER_INFO_LEVEL_2").field("ProviderId", &self.ProviderId).field("ProviderName", &self.ProviderName).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FSRTL_MUP_PROVIDER_INFO_LEVEL_2 {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for FSRTL_MUP_PROVIDER_INFO_LEVEL_2 {
    fn eq(&self, other: &Self) -> bool {
        self.ProviderId == other.ProviderId && self.ProviderName == other.ProviderName
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for FSRTL_MUP_PROVIDER_INFO_LEVEL_2 {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FSRTL_MUP_PROVIDER_INFO_LEVEL_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(feature = "Win32_System_Kernel")]
pub struct FSRTL_PER_FILEOBJECT_CONTEXT {
    pub Links: super::super::super::Win32::System::Kernel::LIST_ENTRY,
    pub OwnerId: *mut ::core::ffi::c_void,
    pub InstanceId: *mut ::core::ffi::c_void,
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::core::marker::Copy for FSRTL_PER_FILEOBJECT_CONTEXT {}
#[cfg(feature = "Win32_System_Kernel")]
impl ::core::clone::Clone for FSRTL_PER_FILEOBJECT_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::core::fmt::Debug for FSRTL_PER_FILEOBJECT_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSRTL_PER_FILEOBJECT_CONTEXT").field("Links", &self.Links).field("OwnerId", &self.OwnerId).field("InstanceId", &self.InstanceId).finish()
    }
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::windows_core::TypeKind for FSRTL_PER_FILEOBJECT_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::core::cmp::PartialEq for FSRTL_PER_FILEOBJECT_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.Links == other.Links && self.OwnerId == other.OwnerId && self.InstanceId == other.InstanceId
    }
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::core::cmp::Eq for FSRTL_PER_FILEOBJECT_CONTEXT {}
#[cfg(feature = "Win32_System_Kernel")]
impl ::core::default::Default for FSRTL_PER_FILEOBJECT_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
pub struct FSRTL_PER_FILE_CONTEXT {
    pub Links: super::super::super::Win32::System::Kernel::LIST_ENTRY,
    pub OwnerId: *mut ::core::ffi::c_void,
    pub InstanceId: *mut ::core::ffi::c_void,
    pub FreeCallback: super::super::Foundation::PFREE_FUNCTION,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::marker::Copy for FSRTL_PER_FILE_CONTEXT {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::clone::Clone for FSRTL_PER_FILE_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::fmt::Debug for FSRTL_PER_FILE_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSRTL_PER_FILE_CONTEXT").field("Links", &self.Links).field("OwnerId", &self.OwnerId).field("InstanceId", &self.InstanceId).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::windows_core::TypeKind for FSRTL_PER_FILE_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::default::Default for FSRTL_PER_FILE_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
pub struct FSRTL_PER_STREAM_CONTEXT {
    pub Links: super::super::super::Win32::System::Kernel::LIST_ENTRY,
    pub OwnerId: *mut ::core::ffi::c_void,
    pub InstanceId: *mut ::core::ffi::c_void,
    pub FreeCallback: super::super::Foundation::PFREE_FUNCTION,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::marker::Copy for FSRTL_PER_STREAM_CONTEXT {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::clone::Clone for FSRTL_PER_STREAM_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::fmt::Debug for FSRTL_PER_STREAM_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSRTL_PER_STREAM_CONTEXT").field("Links", &self.Links).field("OwnerId", &self.OwnerId).field("InstanceId", &self.InstanceId).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::windows_core::TypeKind for FSRTL_PER_STREAM_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::default::Default for FSRTL_PER_STREAM_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FSRTL_UNC_PROVIDER_REGISTRATION {
    pub Size: u16,
    pub Version: u16,
    pub Anonymous1: FSRTL_UNC_PROVIDER_REGISTRATION_0,
    pub Anonymous2: FSRTL_UNC_PROVIDER_REGISTRATION_1,
}
impl ::core::marker::Copy for FSRTL_UNC_PROVIDER_REGISTRATION {}
impl ::core::clone::Clone for FSRTL_UNC_PROVIDER_REGISTRATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for FSRTL_UNC_PROVIDER_REGISTRATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for FSRTL_UNC_PROVIDER_REGISTRATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub union FSRTL_UNC_PROVIDER_REGISTRATION_0 {
    pub ProviderFlags: u32,
    pub Anonymous: FSRTL_UNC_PROVIDER_REGISTRATION_0_0,
}
impl ::core::marker::Copy for FSRTL_UNC_PROVIDER_REGISTRATION_0 {}
impl ::core::clone::Clone for FSRTL_UNC_PROVIDER_REGISTRATION_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for FSRTL_UNC_PROVIDER_REGISTRATION_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for FSRTL_UNC_PROVIDER_REGISTRATION_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FSRTL_UNC_PROVIDER_REGISTRATION_0_0 {
    pub _bitfield: u32,
}
impl ::core::marker::Copy for FSRTL_UNC_PROVIDER_REGISTRATION_0_0 {}
impl ::core::clone::Clone for FSRTL_UNC_PROVIDER_REGISTRATION_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FSRTL_UNC_PROVIDER_REGISTRATION_0_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSRTL_UNC_PROVIDER_REGISTRATION_0_0").field("_bitfield", &self._bitfield).finish()
    }
}
impl ::windows_core::TypeKind for FSRTL_UNC_PROVIDER_REGISTRATION_0_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FSRTL_UNC_PROVIDER_REGISTRATION_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::core::cmp::Eq for FSRTL_UNC_PROVIDER_REGISTRATION_0_0 {}
impl ::core::default::Default for FSRTL_UNC_PROVIDER_REGISTRATION_0_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub union FSRTL_UNC_PROVIDER_REGISTRATION_1 {
    pub HardeningCapabilities: u32,
    pub Anonymous: FSRTL_UNC_PROVIDER_REGISTRATION_1_0,
}
impl ::core::marker::Copy for FSRTL_UNC_PROVIDER_REGISTRATION_1 {}
impl ::core::clone::Clone for FSRTL_UNC_PROVIDER_REGISTRATION_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for FSRTL_UNC_PROVIDER_REGISTRATION_1 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for FSRTL_UNC_PROVIDER_REGISTRATION_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FSRTL_UNC_PROVIDER_REGISTRATION_1_0 {
    pub _bitfield: u32,
}
impl ::core::marker::Copy for FSRTL_UNC_PROVIDER_REGISTRATION_1_0 {}
impl ::core::clone::Clone for FSRTL_UNC_PROVIDER_REGISTRATION_1_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FSRTL_UNC_PROVIDER_REGISTRATION_1_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FSRTL_UNC_PROVIDER_REGISTRATION_1_0").field("_bitfield", &self._bitfield).finish()
    }
}
impl ::windows_core::TypeKind for FSRTL_UNC_PROVIDER_REGISTRATION_1_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FSRTL_UNC_PROVIDER_REGISTRATION_1_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::core::cmp::Eq for FSRTL_UNC_PROVIDER_REGISTRATION_1_0 {}
impl ::core::default::Default for FSRTL_UNC_PROVIDER_REGISTRATION_1_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FS_BPIO_INFO {
    pub ActiveBypassIoCount: u32,
    pub StorageDriverNameLen: u16,
    pub StorageDriverName: [u16; 32],
}
impl ::core::marker::Copy for FS_BPIO_INFO {}
impl ::core::clone::Clone for FS_BPIO_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FS_BPIO_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FS_BPIO_INFO").field("ActiveBypassIoCount", &self.ActiveBypassIoCount).field("StorageDriverNameLen", &self.StorageDriverNameLen).field("StorageDriverName", &self.StorageDriverName).finish()
    }
}
impl ::windows_core::TypeKind for FS_BPIO_INFO {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FS_BPIO_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.ActiveBypassIoCount == other.ActiveBypassIoCount && self.StorageDriverNameLen == other.StorageDriverNameLen && self.StorageDriverName == other.StorageDriverName
    }
}
impl ::core::cmp::Eq for FS_BPIO_INFO {}
impl ::core::default::Default for FS_BPIO_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FS_BPIO_INPUT {
    pub Operation: FS_BPIO_OPERATIONS,
    pub InFlags: FS_BPIO_INFLAGS,
    pub Reserved1: u64,
    pub Reserved2: u64,
}
impl ::core::marker::Copy for FS_BPIO_INPUT {}
impl ::core::clone::Clone for FS_BPIO_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FS_BPIO_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FS_BPIO_INPUT").field("Operation", &self.Operation).field("InFlags", &self.InFlags).field("Reserved1", &self.Reserved1).field("Reserved2", &self.Reserved2).finish()
    }
}
impl ::windows_core::TypeKind for FS_BPIO_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FS_BPIO_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Operation == other.Operation && self.InFlags == other.InFlags && self.Reserved1 == other.Reserved1 && self.Reserved2 == other.Reserved2
    }
}
impl ::core::cmp::Eq for FS_BPIO_INPUT {}
impl ::core::default::Default for FS_BPIO_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct FS_BPIO_OUTPUT {
    pub Operation: FS_BPIO_OPERATIONS,
    pub OutFlags: FS_BPIO_OUTFLAGS,
    pub Reserved1: u64,
    pub Reserved2: u64,
    pub Anonymous: FS_BPIO_OUTPUT_0,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FS_BPIO_OUTPUT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FS_BPIO_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FS_BPIO_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FS_BPIO_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub union FS_BPIO_OUTPUT_0 {
    pub Enable: FS_BPIO_RESULTS,
    pub Query: FS_BPIO_RESULTS,
    pub VolumeStackResume: FS_BPIO_RESULTS,
    pub StreamResume: FS_BPIO_RESULTS,
    pub GetInfo: FS_BPIO_INFO,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FS_BPIO_OUTPUT_0 {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FS_BPIO_OUTPUT_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FS_BPIO_OUTPUT_0 {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FS_BPIO_OUTPUT_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct FS_BPIO_RESULTS {
    pub OpStatus: super::super::super::Win32::Foundation::NTSTATUS,
    pub FailingDriverNameLen: u16,
    pub FailingDriverName: [u16; 32],
    pub FailureReasonLen: u16,
    pub FailureReason: [u16; 128],
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for FS_BPIO_RESULTS {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for FS_BPIO_RESULTS {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for FS_BPIO_RESULTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FS_BPIO_RESULTS").field("OpStatus", &self.OpStatus).field("FailingDriverNameLen", &self.FailingDriverNameLen).field("FailingDriverName", &self.FailingDriverName).field("FailureReasonLen", &self.FailureReasonLen).field("FailureReason", &self.FailureReason).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for FS_BPIO_RESULTS {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for FS_BPIO_RESULTS {
    fn eq(&self, other: &Self) -> bool {
        self.OpStatus == other.OpStatus && self.FailingDriverNameLen == other.FailingDriverNameLen && self.FailingDriverName == other.FailingDriverName && self.FailureReasonLen == other.FailureReasonLen && self.FailureReason == other.FailureReason
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for FS_BPIO_RESULTS {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for FS_BPIO_RESULTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub struct FS_FILTER_CALLBACKS {
    pub SizeOfFsFilterCallbacks: u32,
    pub Reserved: u32,
    pub PreAcquireForSectionSynchronization: PFS_FILTER_CALLBACK,
    pub PostAcquireForSectionSynchronization: PFS_FILTER_COMPLETION_CALLBACK,
    pub PreReleaseForSectionSynchronization: PFS_FILTER_CALLBACK,
    pub PostReleaseForSectionSynchronization: PFS_FILTER_COMPLETION_CALLBACK,
    pub PreAcquireForCcFlush: PFS_FILTER_CALLBACK,
    pub PostAcquireForCcFlush: PFS_FILTER_COMPLETION_CALLBACK,
    pub PreReleaseForCcFlush: PFS_FILTER_CALLBACK,
    pub PostReleaseForCcFlush: PFS_FILTER_COMPLETION_CALLBACK,
    pub PreAcquireForModifiedPageWriter: PFS_FILTER_CALLBACK,
    pub PostAcquireForModifiedPageWriter: PFS_FILTER_COMPLETION_CALLBACK,
    pub PreReleaseForModifiedPageWriter: PFS_FILTER_CALLBACK,
    pub PostReleaseForModifiedPageWriter: PFS_FILTER_COMPLETION_CALLBACK,
    pub PreQueryOpen: PFS_FILTER_CALLBACK,
    pub PostQueryOpen: PFS_FILTER_COMPLETION_CALLBACK,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::marker::Copy for FS_FILTER_CALLBACKS {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::clone::Clone for FS_FILTER_CALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::fmt::Debug for FS_FILTER_CALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FS_FILTER_CALLBACKS").field("SizeOfFsFilterCallbacks", &self.SizeOfFsFilterCallbacks).field("Reserved", &self.Reserved).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::windows_core::TypeKind for FS_FILTER_CALLBACKS {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::default::Default for FS_FILTER_CALLBACKS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub struct FS_FILTER_CALLBACK_DATA {
    pub SizeOfFsFilterCallbackData: u32,
    pub Operation: u8,
    pub Reserved: u8,
    pub DeviceObject: *mut super::super::Foundation::DEVICE_OBJECT,
    pub FileObject: *mut super::super::Foundation::FILE_OBJECT,
    pub Parameters: FS_FILTER_PARAMETERS,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::marker::Copy for FS_FILTER_CALLBACK_DATA {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::clone::Clone for FS_FILTER_CALLBACK_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::windows_core::TypeKind for FS_FILTER_CALLBACK_DATA {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::default::Default for FS_FILTER_CALLBACK_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub union FS_FILTER_PARAMETERS {
    pub AcquireForModifiedPageWriter: FS_FILTER_PARAMETERS_0,
    pub ReleaseForModifiedPageWriter: FS_FILTER_PARAMETERS_4,
    pub AcquireForSectionSynchronization: FS_FILTER_PARAMETERS_1,
    pub QueryOpen: FS_FILTER_PARAMETERS_3,
    pub Others: FS_FILTER_PARAMETERS_2,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::marker::Copy for FS_FILTER_PARAMETERS {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::clone::Clone for FS_FILTER_PARAMETERS {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::windows_core::TypeKind for FS_FILTER_PARAMETERS {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::default::Default for FS_FILTER_PARAMETERS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub struct FS_FILTER_PARAMETERS_0 {
    pub EndingOffset: *mut i64,
    pub ResourceToRelease: *mut *mut super::super::Foundation::ERESOURCE,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::marker::Copy for FS_FILTER_PARAMETERS_0 {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::clone::Clone for FS_FILTER_PARAMETERS_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::fmt::Debug for FS_FILTER_PARAMETERS_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FS_FILTER_PARAMETERS_0").field("EndingOffset", &self.EndingOffset).field("ResourceToRelease", &self.ResourceToRelease).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::windows_core::TypeKind for FS_FILTER_PARAMETERS_0 {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::cmp::PartialEq for FS_FILTER_PARAMETERS_0 {
    fn eq(&self, other: &Self) -> bool {
        self.EndingOffset == other.EndingOffset && self.ResourceToRelease == other.ResourceToRelease
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::cmp::Eq for FS_FILTER_PARAMETERS_0 {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::default::Default for FS_FILTER_PARAMETERS_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub struct FS_FILTER_PARAMETERS_1 {
    pub SyncType: FS_FILTER_SECTION_SYNC_TYPE,
    pub PageProtection: u32,
    pub OutputInformation: *mut FS_FILTER_SECTION_SYNC_OUTPUT,
    pub Flags: u32,
    pub AllocationAttributes: u32,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::marker::Copy for FS_FILTER_PARAMETERS_1 {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::clone::Clone for FS_FILTER_PARAMETERS_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::fmt::Debug for FS_FILTER_PARAMETERS_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FS_FILTER_PARAMETERS_1").field("SyncType", &self.SyncType).field("PageProtection", &self.PageProtection).field("OutputInformation", &self.OutputInformation).field("Flags", &self.Flags).field("AllocationAttributes", &self.AllocationAttributes).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::windows_core::TypeKind for FS_FILTER_PARAMETERS_1 {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::cmp::PartialEq for FS_FILTER_PARAMETERS_1 {
    fn eq(&self, other: &Self) -> bool {
        self.SyncType == other.SyncType && self.PageProtection == other.PageProtection && self.OutputInformation == other.OutputInformation && self.Flags == other.Flags && self.AllocationAttributes == other.AllocationAttributes
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::cmp::Eq for FS_FILTER_PARAMETERS_1 {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::default::Default for FS_FILTER_PARAMETERS_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub struct FS_FILTER_PARAMETERS_2 {
    pub Argument1: *mut ::core::ffi::c_void,
    pub Argument2: *mut ::core::ffi::c_void,
    pub Argument3: *mut ::core::ffi::c_void,
    pub Argument4: *mut ::core::ffi::c_void,
    pub Argument5: *mut ::core::ffi::c_void,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::marker::Copy for FS_FILTER_PARAMETERS_2 {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::clone::Clone for FS_FILTER_PARAMETERS_2 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::fmt::Debug for FS_FILTER_PARAMETERS_2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FS_FILTER_PARAMETERS_2").field("Argument1", &self.Argument1).field("Argument2", &self.Argument2).field("Argument3", &self.Argument3).field("Argument4", &self.Argument4).field("Argument5", &self.Argument5).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::windows_core::TypeKind for FS_FILTER_PARAMETERS_2 {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::cmp::PartialEq for FS_FILTER_PARAMETERS_2 {
    fn eq(&self, other: &Self) -> bool {
        self.Argument1 == other.Argument1 && self.Argument2 == other.Argument2 && self.Argument3 == other.Argument3 && self.Argument4 == other.Argument4 && self.Argument5 == other.Argument5
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::cmp::Eq for FS_FILTER_PARAMETERS_2 {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::default::Default for FS_FILTER_PARAMETERS_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub struct FS_FILTER_PARAMETERS_3 {
    pub Irp: *mut super::super::Foundation::IRP,
    pub FileInformation: *mut ::core::ffi::c_void,
    pub Length: *mut u32,
    pub FileInformationClass: super::super::super::Win32::System::WindowsProgramming::FILE_INFORMATION_CLASS,
    pub CompletionStatus: super::super::super::Win32::Foundation::NTSTATUS,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::marker::Copy for FS_FILTER_PARAMETERS_3 {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::clone::Clone for FS_FILTER_PARAMETERS_3 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::fmt::Debug for FS_FILTER_PARAMETERS_3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FS_FILTER_PARAMETERS_3").field("Irp", &self.Irp).field("FileInformation", &self.FileInformation).field("Length", &self.Length).field("FileInformationClass", &self.FileInformationClass).field("CompletionStatus", &self.CompletionStatus).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::windows_core::TypeKind for FS_FILTER_PARAMETERS_3 {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::cmp::PartialEq for FS_FILTER_PARAMETERS_3 {
    fn eq(&self, other: &Self) -> bool {
        self.Irp == other.Irp && self.FileInformation == other.FileInformation && self.Length == other.Length && self.FileInformationClass == other.FileInformationClass && self.CompletionStatus == other.CompletionStatus
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::cmp::Eq for FS_FILTER_PARAMETERS_3 {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::default::Default for FS_FILTER_PARAMETERS_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub struct FS_FILTER_PARAMETERS_4 {
    pub ResourceToRelease: *mut super::super::Foundation::ERESOURCE,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::marker::Copy for FS_FILTER_PARAMETERS_4 {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::clone::Clone for FS_FILTER_PARAMETERS_4 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::fmt::Debug for FS_FILTER_PARAMETERS_4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FS_FILTER_PARAMETERS_4").field("ResourceToRelease", &self.ResourceToRelease).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::windows_core::TypeKind for FS_FILTER_PARAMETERS_4 {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::cmp::PartialEq for FS_FILTER_PARAMETERS_4 {
    fn eq(&self, other: &Self) -> bool {
        self.ResourceToRelease == other.ResourceToRelease
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::cmp::Eq for FS_FILTER_PARAMETERS_4 {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::default::Default for FS_FILTER_PARAMETERS_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct FS_FILTER_SECTION_SYNC_OUTPUT {
    pub StructureSize: u32,
    pub SizeReturned: u32,
    pub Flags: u32,
    pub DesiredReadAlignment: u32,
}
impl ::core::marker::Copy for FS_FILTER_SECTION_SYNC_OUTPUT {}
impl ::core::clone::Clone for FS_FILTER_SECTION_SYNC_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for FS_FILTER_SECTION_SYNC_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FS_FILTER_SECTION_SYNC_OUTPUT").field("StructureSize", &self.StructureSize).field("SizeReturned", &self.SizeReturned).field("Flags", &self.Flags).field("DesiredReadAlignment", &self.DesiredReadAlignment).finish()
    }
}
impl ::windows_core::TypeKind for FS_FILTER_SECTION_SYNC_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for FS_FILTER_SECTION_SYNC_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.StructureSize == other.StructureSize && self.SizeReturned == other.SizeReturned && self.Flags == other.Flags && self.DesiredReadAlignment == other.DesiredReadAlignment
    }
}
impl ::core::cmp::Eq for FS_FILTER_SECTION_SYNC_OUTPUT {}
impl ::core::default::Default for FS_FILTER_SECTION_SYNC_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct GENERATE_NAME_CONTEXT {
    pub Checksum: u16,
    pub ChecksumInserted: super::super::super::Win32::Foundation::BOOLEAN,
    pub NameLength: u8,
    pub NameBuffer: [u16; 8],
    pub ExtensionLength: u32,
    pub ExtensionBuffer: [u16; 4],
    pub LastIndexValue: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for GENERATE_NAME_CONTEXT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for GENERATE_NAME_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for GENERATE_NAME_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("GENERATE_NAME_CONTEXT").field("Checksum", &self.Checksum).field("ChecksumInserted", &self.ChecksumInserted).field("NameLength", &self.NameLength).field("NameBuffer", &self.NameBuffer).field("ExtensionLength", &self.ExtensionLength).field("ExtensionBuffer", &self.ExtensionBuffer).field("LastIndexValue", &self.LastIndexValue).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for GENERATE_NAME_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for GENERATE_NAME_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.Checksum == other.Checksum && self.ChecksumInserted == other.ChecksumInserted && self.NameLength == other.NameLength && self.NameBuffer == other.NameBuffer && self.ExtensionLength == other.ExtensionLength && self.ExtensionBuffer == other.ExtensionBuffer && self.LastIndexValue == other.LastIndexValue
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for GENERATE_NAME_CONTEXT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for GENERATE_NAME_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct GET_FILTER_FILE_IDENTIFIER_INPUT {
    pub AltitudeLength: u16,
    pub Altitude: [u16; 1],
}
impl ::core::marker::Copy for GET_FILTER_FILE_IDENTIFIER_INPUT {}
impl ::core::clone::Clone for GET_FILTER_FILE_IDENTIFIER_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for GET_FILTER_FILE_IDENTIFIER_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("GET_FILTER_FILE_IDENTIFIER_INPUT").field("AltitudeLength", &self.AltitudeLength).field("Altitude", &self.Altitude).finish()
    }
}
impl ::windows_core::TypeKind for GET_FILTER_FILE_IDENTIFIER_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for GET_FILTER_FILE_IDENTIFIER_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.AltitudeLength == other.AltitudeLength && self.Altitude == other.Altitude
    }
}
impl ::core::cmp::Eq for GET_FILTER_FILE_IDENTIFIER_INPUT {}
impl ::core::default::Default for GET_FILTER_FILE_IDENTIFIER_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct GET_FILTER_FILE_IDENTIFIER_OUTPUT {
    pub FilterFileIdentifierLength: u16,
    pub FilterFileIdentifier: [u8; 1],
}
impl ::core::marker::Copy for GET_FILTER_FILE_IDENTIFIER_OUTPUT {}
impl ::core::clone::Clone for GET_FILTER_FILE_IDENTIFIER_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for GET_FILTER_FILE_IDENTIFIER_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("GET_FILTER_FILE_IDENTIFIER_OUTPUT").field("FilterFileIdentifierLength", &self.FilterFileIdentifierLength).field("FilterFileIdentifier", &self.FilterFileIdentifier).finish()
    }
}
impl ::windows_core::TypeKind for GET_FILTER_FILE_IDENTIFIER_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for GET_FILTER_FILE_IDENTIFIER_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.FilterFileIdentifierLength == other.FilterFileIdentifierLength && self.FilterFileIdentifier == other.FilterFileIdentifier
    }
}
impl ::core::cmp::Eq for GET_FILTER_FILE_IDENTIFIER_OUTPUT {}
impl ::core::default::Default for GET_FILTER_FILE_IDENTIFIER_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct GHOSTED_FILE_EXTENT {
    pub FileOffset: i64,
    pub ByteCount: i64,
    pub RecallOwnerGuid: ::windows_core::GUID,
    pub NextEntryOffset: u32,
    pub RecallMetadataBufferSize: u32,
    pub RecallMetadataBuffer: [u8; 1],
}
impl ::core::marker::Copy for GHOSTED_FILE_EXTENT {}
impl ::core::clone::Clone for GHOSTED_FILE_EXTENT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for GHOSTED_FILE_EXTENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("GHOSTED_FILE_EXTENT").field("FileOffset", &self.FileOffset).field("ByteCount", &self.ByteCount).field("RecallOwnerGuid", &self.RecallOwnerGuid).field("NextEntryOffset", &self.NextEntryOffset).field("RecallMetadataBufferSize", &self.RecallMetadataBufferSize).field("RecallMetadataBuffer", &self.RecallMetadataBuffer).finish()
    }
}
impl ::windows_core::TypeKind for GHOSTED_FILE_EXTENT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for GHOSTED_FILE_EXTENT {
    fn eq(&self, other: &Self) -> bool {
        self.FileOffset == other.FileOffset && self.ByteCount == other.ByteCount && self.RecallOwnerGuid == other.RecallOwnerGuid && self.NextEntryOffset == other.NextEntryOffset && self.RecallMetadataBufferSize == other.RecallMetadataBufferSize && self.RecallMetadataBuffer == other.RecallMetadataBuffer
    }
}
impl ::core::cmp::Eq for GHOSTED_FILE_EXTENT {}
impl ::core::default::Default for GHOSTED_FILE_EXTENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub struct IO_CREATE_STREAM_FILE_OPTIONS {
    pub Size: u16,
    pub Flags: u16,
    pub TargetDeviceObject: *mut super::super::Foundation::DEVICE_OBJECT,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::marker::Copy for IO_CREATE_STREAM_FILE_OPTIONS {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::clone::Clone for IO_CREATE_STREAM_FILE_OPTIONS {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::fmt::Debug for IO_CREATE_STREAM_FILE_OPTIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("IO_CREATE_STREAM_FILE_OPTIONS").field("Size", &self.Size).field("Flags", &self.Flags).field("TargetDeviceObject", &self.TargetDeviceObject).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::windows_core::TypeKind for IO_CREATE_STREAM_FILE_OPTIONS {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::cmp::PartialEq for IO_CREATE_STREAM_FILE_OPTIONS {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.Flags == other.Flags && self.TargetDeviceObject == other.TargetDeviceObject
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::cmp::Eq for IO_CREATE_STREAM_FILE_OPTIONS {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::default::Default for IO_CREATE_STREAM_FILE_OPTIONS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub struct IO_DEVICE_HINT_ECP_CONTEXT {
    pub TargetDevice: *mut super::super::Foundation::DEVICE_OBJECT,
    pub RemainingName: super::super::super::Win32::Foundation::UNICODE_STRING,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::marker::Copy for IO_DEVICE_HINT_ECP_CONTEXT {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::clone::Clone for IO_DEVICE_HINT_ECP_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::fmt::Debug for IO_DEVICE_HINT_ECP_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("IO_DEVICE_HINT_ECP_CONTEXT").field("TargetDevice", &self.TargetDevice).field("RemainingName", &self.RemainingName).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::windows_core::TypeKind for IO_DEVICE_HINT_ECP_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::cmp::PartialEq for IO_DEVICE_HINT_ECP_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.TargetDevice == other.TargetDevice && self.RemainingName == other.RemainingName
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::cmp::Eq for IO_DEVICE_HINT_ECP_CONTEXT {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::default::Default for IO_DEVICE_HINT_ECP_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct IO_IRP_EXT_TRACK_OFFSET_HEADER {
    pub Validation: u16,
    pub Flags: u16,
    pub TrackedOffsetCallback: PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK,
}
impl ::core::marker::Copy for IO_IRP_EXT_TRACK_OFFSET_HEADER {}
impl ::core::clone::Clone for IO_IRP_EXT_TRACK_OFFSET_HEADER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for IO_IRP_EXT_TRACK_OFFSET_HEADER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("IO_IRP_EXT_TRACK_OFFSET_HEADER").field("Validation", &self.Validation).field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for IO_IRP_EXT_TRACK_OFFSET_HEADER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for IO_IRP_EXT_TRACK_OFFSET_HEADER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`*"]
#[cfg(feature = "Wdk_Foundation")]
pub struct IO_PRIORITY_INFO {
    pub Size: u32,
    pub ThreadPriority: u32,
    pub PagePriority: u32,
    pub IoPriority: super::super::Foundation::IO_PRIORITY_HINT,
}
#[cfg(feature = "Wdk_Foundation")]
impl ::core::marker::Copy for IO_PRIORITY_INFO {}
#[cfg(feature = "Wdk_Foundation")]
impl ::core::clone::Clone for IO_PRIORITY_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Wdk_Foundation")]
impl ::core::fmt::Debug for IO_PRIORITY_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("IO_PRIORITY_INFO").field("Size", &self.Size).field("ThreadPriority", &self.ThreadPriority).field("PagePriority", &self.PagePriority).field("IoPriority", &self.IoPriority).finish()
    }
}
#[cfg(feature = "Wdk_Foundation")]
impl ::windows_core::TypeKind for IO_PRIORITY_INFO {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Wdk_Foundation")]
impl ::core::cmp::PartialEq for IO_PRIORITY_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.ThreadPriority == other.ThreadPriority && self.PagePriority == other.PagePriority && self.IoPriority == other.IoPriority
    }
}
#[cfg(feature = "Wdk_Foundation")]
impl ::core::cmp::Eq for IO_PRIORITY_INFO {}
#[cfg(feature = "Wdk_Foundation")]
impl ::core::default::Default for IO_PRIORITY_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct IO_STOP_ON_SYMLINK_FILTER_ECP_v0 {
    pub Out: IO_STOP_ON_SYMLINK_FILTER_ECP_v0_0,
}
impl ::core::marker::Copy for IO_STOP_ON_SYMLINK_FILTER_ECP_v0 {}
impl ::core::clone::Clone for IO_STOP_ON_SYMLINK_FILTER_ECP_v0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for IO_STOP_ON_SYMLINK_FILTER_ECP_v0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("IO_STOP_ON_SYMLINK_FILTER_ECP_v0").field("Out", &self.Out).finish()
    }
}
impl ::windows_core::TypeKind for IO_STOP_ON_SYMLINK_FILTER_ECP_v0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for IO_STOP_ON_SYMLINK_FILTER_ECP_v0 {
    fn eq(&self, other: &Self) -> bool {
        self.Out == other.Out
    }
}
impl ::core::cmp::Eq for IO_STOP_ON_SYMLINK_FILTER_ECP_v0 {}
impl ::core::default::Default for IO_STOP_ON_SYMLINK_FILTER_ECP_v0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct IO_STOP_ON_SYMLINK_FILTER_ECP_v0_0 {
    pub ReparseCount: u32,
    pub RemainingPathLength: u32,
}
impl ::core::marker::Copy for IO_STOP_ON_SYMLINK_FILTER_ECP_v0_0 {}
impl ::core::clone::Clone for IO_STOP_ON_SYMLINK_FILTER_ECP_v0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for IO_STOP_ON_SYMLINK_FILTER_ECP_v0_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("IO_STOP_ON_SYMLINK_FILTER_ECP_v0_0").field("ReparseCount", &self.ReparseCount).field("RemainingPathLength", &self.RemainingPathLength).finish()
    }
}
impl ::windows_core::TypeKind for IO_STOP_ON_SYMLINK_FILTER_ECP_v0_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for IO_STOP_ON_SYMLINK_FILTER_ECP_v0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.ReparseCount == other.ReparseCount && self.RemainingPathLength == other.RemainingPathLength
    }
}
impl ::core::cmp::Eq for IO_STOP_ON_SYMLINK_FILTER_ECP_v0_0 {}
impl ::core::default::Default for IO_STOP_ON_SYMLINK_FILTER_ECP_v0_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
pub struct KAPC_STATE {
    pub ApcListHead: [super::super::super::Win32::System::Kernel::LIST_ENTRY; 2],
    pub Process: *mut super::super::Foundation::KPROCESS,
    pub Anonymous1: KAPC_STATE_0,
    pub KernelApcPending: super::super::super::Win32::Foundation::BOOLEAN,
    pub Anonymous2: KAPC_STATE_1,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::marker::Copy for KAPC_STATE {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::clone::Clone for KAPC_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::windows_core::TypeKind for KAPC_STATE {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::default::Default for KAPC_STATE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
pub union KAPC_STATE_0 {
    pub InProgressFlags: u8,
    pub Anonymous: KAPC_STATE_0_0,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::marker::Copy for KAPC_STATE_0 {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::clone::Clone for KAPC_STATE_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::windows_core::TypeKind for KAPC_STATE_0 {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::default::Default for KAPC_STATE_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
pub struct KAPC_STATE_0_0 {
    pub _bitfield: u8,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::marker::Copy for KAPC_STATE_0_0 {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::clone::Clone for KAPC_STATE_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::fmt::Debug for KAPC_STATE_0_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("KAPC_STATE_0_0").field("_bitfield", &self._bitfield).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::windows_core::TypeKind for KAPC_STATE_0_0 {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::cmp::PartialEq for KAPC_STATE_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::cmp::Eq for KAPC_STATE_0_0 {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::default::Default for KAPC_STATE_0_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
pub union KAPC_STATE_1 {
    pub UserApcPendingAll: super::super::super::Win32::Foundation::BOOLEAN,
    pub Anonymous: KAPC_STATE_1_0,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::marker::Copy for KAPC_STATE_1 {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::clone::Clone for KAPC_STATE_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::windows_core::TypeKind for KAPC_STATE_1 {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::default::Default for KAPC_STATE_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
pub struct KAPC_STATE_1_0 {
    pub _bitfield: u8,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::marker::Copy for KAPC_STATE_1_0 {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::clone::Clone for KAPC_STATE_1_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::fmt::Debug for KAPC_STATE_1_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("KAPC_STATE_1_0").field("_bitfield", &self._bitfield).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::windows_core::TypeKind for KAPC_STATE_1_0 {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::cmp::PartialEq for KAPC_STATE_1_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::cmp::Eq for KAPC_STATE_1_0 {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::default::Default for KAPC_STATE_1_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
pub struct LARGE_MCB {
    pub GuardedMutex: *mut super::super::Foundation::FAST_MUTEX,
    pub BaseMcb: BASE_MCB,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::marker::Copy for LARGE_MCB {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::clone::Clone for LARGE_MCB {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::fmt::Debug for LARGE_MCB {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("LARGE_MCB").field("GuardedMutex", &self.GuardedMutex).field("BaseMcb", &self.BaseMcb).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::windows_core::TypeKind for LARGE_MCB {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::cmp::PartialEq for LARGE_MCB {
    fn eq(&self, other: &Self) -> bool {
        self.GuardedMutex == other.GuardedMutex && self.BaseMcb == other.BaseMcb
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::cmp::Eq for LARGE_MCB {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::default::Default for LARGE_MCB {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct LCN_WEAK_REFERENCE_BUFFER {
    pub Lcn: i64,
    pub LengthInClusters: i64,
    pub ReferenceCount: u32,
    pub State: u16,
}
impl ::core::marker::Copy for LCN_WEAK_REFERENCE_BUFFER {}
impl ::core::clone::Clone for LCN_WEAK_REFERENCE_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for LCN_WEAK_REFERENCE_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("LCN_WEAK_REFERENCE_BUFFER").field("Lcn", &self.Lcn).field("LengthInClusters", &self.LengthInClusters).field("ReferenceCount", &self.ReferenceCount).field("State", &self.State).finish()
    }
}
impl ::windows_core::TypeKind for LCN_WEAK_REFERENCE_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for LCN_WEAK_REFERENCE_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.Lcn == other.Lcn && self.LengthInClusters == other.LengthInClusters && self.ReferenceCount == other.ReferenceCount && self.State == other.State
    }
}
impl ::core::cmp::Eq for LCN_WEAK_REFERENCE_BUFFER {}
impl ::core::default::Default for LCN_WEAK_REFERENCE_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct LCN_WEAK_REFERENCE_CREATE_INPUT_BUFFER {
    pub Offset: i64,
    pub Length: i64,
    pub Flags: u32,
    pub Reserved: u32,
}
impl ::core::marker::Copy for LCN_WEAK_REFERENCE_CREATE_INPUT_BUFFER {}
impl ::core::clone::Clone for LCN_WEAK_REFERENCE_CREATE_INPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for LCN_WEAK_REFERENCE_CREATE_INPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("LCN_WEAK_REFERENCE_CREATE_INPUT_BUFFER").field("Offset", &self.Offset).field("Length", &self.Length).field("Flags", &self.Flags).field("Reserved", &self.Reserved).finish()
    }
}
impl ::windows_core::TypeKind for LCN_WEAK_REFERENCE_CREATE_INPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for LCN_WEAK_REFERENCE_CREATE_INPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.Offset == other.Offset && self.Length == other.Length && self.Flags == other.Flags && self.Reserved == other.Reserved
    }
}
impl ::core::cmp::Eq for LCN_WEAK_REFERENCE_CREATE_INPUT_BUFFER {}
impl ::core::default::Default for LCN_WEAK_REFERENCE_CREATE_INPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct LINK_TRACKING_INFORMATION {
    pub Type: LINK_TRACKING_INFORMATION_TYPE,
    pub VolumeId: [u8; 16],
}
impl ::core::marker::Copy for LINK_TRACKING_INFORMATION {}
impl ::core::clone::Clone for LINK_TRACKING_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for LINK_TRACKING_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("LINK_TRACKING_INFORMATION").field("Type", &self.Type).field("VolumeId", &self.VolumeId).finish()
    }
}
impl ::windows_core::TypeKind for LINK_TRACKING_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for LINK_TRACKING_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type && self.VolumeId == other.VolumeId
    }
}
impl ::core::cmp::Eq for LINK_TRACKING_INFORMATION {}
impl ::core::default::Default for LINK_TRACKING_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct LMR_QUERY_INFO_PARAM {
    pub Operation: LMR_QUERY_INFO_CLASS,
}
impl ::core::marker::Copy for LMR_QUERY_INFO_PARAM {}
impl ::core::clone::Clone for LMR_QUERY_INFO_PARAM {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for LMR_QUERY_INFO_PARAM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("LMR_QUERY_INFO_PARAM").field("Operation", &self.Operation).finish()
    }
}
impl ::windows_core::TypeKind for LMR_QUERY_INFO_PARAM {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for LMR_QUERY_INFO_PARAM {
    fn eq(&self, other: &Self) -> bool {
        self.Operation == other.Operation
    }
}
impl ::core::cmp::Eq for LMR_QUERY_INFO_PARAM {}
impl ::core::default::Default for LMR_QUERY_INFO_PARAM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct LMR_QUERY_SESSION_INFO {
    pub SessionId: u64,
}
impl ::core::marker::Copy for LMR_QUERY_SESSION_INFO {}
impl ::core::clone::Clone for LMR_QUERY_SESSION_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for LMR_QUERY_SESSION_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("LMR_QUERY_SESSION_INFO").field("SessionId", &self.SessionId).finish()
    }
}
impl ::windows_core::TypeKind for LMR_QUERY_SESSION_INFO {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for LMR_QUERY_SESSION_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.SessionId == other.SessionId
    }
}
impl ::core::cmp::Eq for LMR_QUERY_SESSION_INFO {}
impl ::core::default::Default for LMR_QUERY_SESSION_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct LOOKUP_STREAM_FROM_CLUSTER_ENTRY {
    pub OffsetToNext: u32,
    pub Flags: u32,
    pub Reserved: i64,
    pub Cluster: i64,
    pub FileName: [u16; 1],
}
impl ::core::marker::Copy for LOOKUP_STREAM_FROM_CLUSTER_ENTRY {}
impl ::core::clone::Clone for LOOKUP_STREAM_FROM_CLUSTER_ENTRY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for LOOKUP_STREAM_FROM_CLUSTER_ENTRY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("LOOKUP_STREAM_FROM_CLUSTER_ENTRY").field("OffsetToNext", &self.OffsetToNext).field("Flags", &self.Flags).field("Reserved", &self.Reserved).field("Cluster", &self.Cluster).field("FileName", &self.FileName).finish()
    }
}
impl ::windows_core::TypeKind for LOOKUP_STREAM_FROM_CLUSTER_ENTRY {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for LOOKUP_STREAM_FROM_CLUSTER_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.OffsetToNext == other.OffsetToNext && self.Flags == other.Flags && self.Reserved == other.Reserved && self.Cluster == other.Cluster && self.FileName == other.FileName
    }
}
impl ::core::cmp::Eq for LOOKUP_STREAM_FROM_CLUSTER_ENTRY {}
impl ::core::default::Default for LOOKUP_STREAM_FROM_CLUSTER_ENTRY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct LOOKUP_STREAM_FROM_CLUSTER_INPUT {
    pub Flags: u32,
    pub NumberOfClusters: u32,
    pub Cluster: [i64; 1],
}
impl ::core::marker::Copy for LOOKUP_STREAM_FROM_CLUSTER_INPUT {}
impl ::core::clone::Clone for LOOKUP_STREAM_FROM_CLUSTER_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for LOOKUP_STREAM_FROM_CLUSTER_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("LOOKUP_STREAM_FROM_CLUSTER_INPUT").field("Flags", &self.Flags).field("NumberOfClusters", &self.NumberOfClusters).field("Cluster", &self.Cluster).finish()
    }
}
impl ::windows_core::TypeKind for LOOKUP_STREAM_FROM_CLUSTER_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for LOOKUP_STREAM_FROM_CLUSTER_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags && self.NumberOfClusters == other.NumberOfClusters && self.Cluster == other.Cluster
    }
}
impl ::core::cmp::Eq for LOOKUP_STREAM_FROM_CLUSTER_INPUT {}
impl ::core::default::Default for LOOKUP_STREAM_FROM_CLUSTER_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct LOOKUP_STREAM_FROM_CLUSTER_OUTPUT {
    pub Offset: u32,
    pub NumberOfMatches: u32,
    pub BufferSizeRequired: u32,
}
impl ::core::marker::Copy for LOOKUP_STREAM_FROM_CLUSTER_OUTPUT {}
impl ::core::clone::Clone for LOOKUP_STREAM_FROM_CLUSTER_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for LOOKUP_STREAM_FROM_CLUSTER_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("LOOKUP_STREAM_FROM_CLUSTER_OUTPUT").field("Offset", &self.Offset).field("NumberOfMatches", &self.NumberOfMatches).field("BufferSizeRequired", &self.BufferSizeRequired).finish()
    }
}
impl ::windows_core::TypeKind for LOOKUP_STREAM_FROM_CLUSTER_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for LOOKUP_STREAM_FROM_CLUSTER_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Offset == other.Offset && self.NumberOfMatches == other.NumberOfMatches && self.BufferSizeRequired == other.BufferSizeRequired
    }
}
impl ::core::cmp::Eq for LOOKUP_STREAM_FROM_CLUSTER_OUTPUT {}
impl ::core::default::Default for LOOKUP_STREAM_FROM_CLUSTER_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct MARK_HANDLE_INFO {
    pub Anonymous: MARK_HANDLE_INFO_0,
    pub VolumeHandle: super::super::super::Win32::Foundation::HANDLE,
    pub HandleInfo: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for MARK_HANDLE_INFO {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for MARK_HANDLE_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for MARK_HANDLE_INFO {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MARK_HANDLE_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub union MARK_HANDLE_INFO_0 {
    pub UsnSourceInfo: u32,
    pub CopyNumber: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for MARK_HANDLE_INFO_0 {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for MARK_HANDLE_INFO_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for MARK_HANDLE_INFO_0 {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MARK_HANDLE_INFO_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
pub struct MCB {
    pub DummyFieldThatSizesThisStructureCorrectly: LARGE_MCB,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::marker::Copy for MCB {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::clone::Clone for MCB {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::fmt::Debug for MCB {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MCB").field("DummyFieldThatSizesThisStructureCorrectly", &self.DummyFieldThatSizesThisStructureCorrectly).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::windows_core::TypeKind for MCB {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::cmp::PartialEq for MCB {
    fn eq(&self, other: &Self) -> bool {
        self.DummyFieldThatSizesThisStructureCorrectly == other.DummyFieldThatSizesThisStructureCorrectly
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::cmp::Eq for MCB {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::default::Default for MCB {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct MEMORY_BASIC_INFORMATION {
    pub BaseAddress: *mut ::core::ffi::c_void,
    pub AllocationBase: *mut ::core::ffi::c_void,
    pub AllocationProtect: u32,
    pub RegionSize: usize,
    pub State: u32,
    pub Protect: u32,
    pub Type: u32,
}
impl ::core::marker::Copy for MEMORY_BASIC_INFORMATION {}
impl ::core::clone::Clone for MEMORY_BASIC_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MEMORY_BASIC_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MEMORY_BASIC_INFORMATION").field("BaseAddress", &self.BaseAddress).field("AllocationBase", &self.AllocationBase).field("AllocationProtect", &self.AllocationProtect).field("RegionSize", &self.RegionSize).field("State", &self.State).field("Protect", &self.Protect).field("Type", &self.Type).finish()
    }
}
impl ::windows_core::TypeKind for MEMORY_BASIC_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for MEMORY_BASIC_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.BaseAddress == other.BaseAddress && self.AllocationBase == other.AllocationBase && self.AllocationProtect == other.AllocationProtect && self.RegionSize == other.RegionSize && self.State == other.State && self.Protect == other.Protect && self.Type == other.Type
    }
}
impl ::core::cmp::Eq for MEMORY_BASIC_INFORMATION {}
impl ::core::default::Default for MEMORY_BASIC_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct MEMORY_RANGE_ENTRY {
    pub VirtualAddress: *mut ::core::ffi::c_void,
    pub NumberOfBytes: usize,
}
impl ::core::marker::Copy for MEMORY_RANGE_ENTRY {}
impl ::core::clone::Clone for MEMORY_RANGE_ENTRY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MEMORY_RANGE_ENTRY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MEMORY_RANGE_ENTRY").field("VirtualAddress", &self.VirtualAddress).field("NumberOfBytes", &self.NumberOfBytes).finish()
    }
}
impl ::windows_core::TypeKind for MEMORY_RANGE_ENTRY {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for MEMORY_RANGE_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.VirtualAddress == other.VirtualAddress && self.NumberOfBytes == other.NumberOfBytes
    }
}
impl ::core::cmp::Eq for MEMORY_RANGE_ENTRY {}
impl ::core::default::Default for MEMORY_RANGE_ENTRY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct MFT_ENUM_DATA {
    pub StartFileReferenceNumber: u64,
    pub LowUsn: i64,
    pub HighUsn: i64,
    pub MinMajorVersion: u16,
    pub MaxMajorVersion: u16,
}
impl ::core::marker::Copy for MFT_ENUM_DATA {}
impl ::core::clone::Clone for MFT_ENUM_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFT_ENUM_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFT_ENUM_DATA").field("StartFileReferenceNumber", &self.StartFileReferenceNumber).field("LowUsn", &self.LowUsn).field("HighUsn", &self.HighUsn).field("MinMajorVersion", &self.MinMajorVersion).field("MaxMajorVersion", &self.MaxMajorVersion).finish()
    }
}
impl ::windows_core::TypeKind for MFT_ENUM_DATA {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for MFT_ENUM_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.StartFileReferenceNumber == other.StartFileReferenceNumber && self.LowUsn == other.LowUsn && self.HighUsn == other.HighUsn && self.MinMajorVersion == other.MinMajorVersion && self.MaxMajorVersion == other.MaxMajorVersion
    }
}
impl ::core::cmp::Eq for MFT_ENUM_DATA {}
impl ::core::default::Default for MFT_ENUM_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct MFT_ENUM_DATA_V0 {
    pub StartFileReferenceNumber: u64,
    pub LowUsn: i64,
    pub HighUsn: i64,
}
impl ::core::marker::Copy for MFT_ENUM_DATA_V0 {}
impl ::core::clone::Clone for MFT_ENUM_DATA_V0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MFT_ENUM_DATA_V0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MFT_ENUM_DATA_V0").field("StartFileReferenceNumber", &self.StartFileReferenceNumber).field("LowUsn", &self.LowUsn).field("HighUsn", &self.HighUsn).finish()
    }
}
impl ::windows_core::TypeKind for MFT_ENUM_DATA_V0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for MFT_ENUM_DATA_V0 {
    fn eq(&self, other: &Self) -> bool {
        self.StartFileReferenceNumber == other.StartFileReferenceNumber && self.LowUsn == other.LowUsn && self.HighUsn == other.HighUsn
    }
}
impl ::core::cmp::Eq for MFT_ENUM_DATA_V0 {}
impl ::core::default::Default for MFT_ENUM_DATA_V0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub union MM_PREFETCH_FLAGS {
    pub Flags: MM_PREFETCH_FLAGS_0,
    pub AllFlags: u32,
}
impl ::core::marker::Copy for MM_PREFETCH_FLAGS {}
impl ::core::clone::Clone for MM_PREFETCH_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for MM_PREFETCH_FLAGS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for MM_PREFETCH_FLAGS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct MM_PREFETCH_FLAGS_0 {
    pub _bitfield: u32,
}
impl ::core::marker::Copy for MM_PREFETCH_FLAGS_0 {}
impl ::core::clone::Clone for MM_PREFETCH_FLAGS_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MM_PREFETCH_FLAGS_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MM_PREFETCH_FLAGS_0").field("_bitfield", &self._bitfield).finish()
    }
}
impl ::windows_core::TypeKind for MM_PREFETCH_FLAGS_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for MM_PREFETCH_FLAGS_0 {
    fn eq(&self, other: &Self) -> bool {
        self._bitfield == other._bitfield
    }
}
impl ::core::cmp::Eq for MM_PREFETCH_FLAGS_0 {}
impl ::core::default::Default for MM_PREFETCH_FLAGS_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct MOVE_FILE_DATA {
    pub FileHandle: super::super::super::Win32::Foundation::HANDLE,
    pub StartingVcn: i64,
    pub StartingLcn: i64,
    pub ClusterCount: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for MOVE_FILE_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for MOVE_FILE_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for MOVE_FILE_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MOVE_FILE_DATA").field("FileHandle", &self.FileHandle).field("StartingVcn", &self.StartingVcn).field("StartingLcn", &self.StartingLcn).field("ClusterCount", &self.ClusterCount).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for MOVE_FILE_DATA {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for MOVE_FILE_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.FileHandle == other.FileHandle && self.StartingVcn == other.StartingVcn && self.StartingLcn == other.StartingLcn && self.ClusterCount == other.ClusterCount
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for MOVE_FILE_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MOVE_FILE_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct MOVE_FILE_RECORD_DATA {
    pub FileHandle: super::super::super::Win32::Foundation::HANDLE,
    pub SourceFileRecord: i64,
    pub TargetFileRecord: i64,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for MOVE_FILE_RECORD_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for MOVE_FILE_RECORD_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for MOVE_FILE_RECORD_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MOVE_FILE_RECORD_DATA").field("FileHandle", &self.FileHandle).field("SourceFileRecord", &self.SourceFileRecord).field("TargetFileRecord", &self.TargetFileRecord).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for MOVE_FILE_RECORD_DATA {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for MOVE_FILE_RECORD_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.FileHandle == other.FileHandle && self.SourceFileRecord == other.SourceFileRecord && self.TargetFileRecord == other.TargetFileRecord
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for MOVE_FILE_RECORD_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MOVE_FILE_RECORD_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct MSV1_0_AV_PAIR {
    pub AvId: u16,
    pub AvLen: u16,
}
impl ::core::marker::Copy for MSV1_0_AV_PAIR {}
impl ::core::clone::Clone for MSV1_0_AV_PAIR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MSV1_0_AV_PAIR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MSV1_0_AV_PAIR").field("AvId", &self.AvId).field("AvLen", &self.AvLen).finish()
    }
}
impl ::windows_core::TypeKind for MSV1_0_AV_PAIR {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for MSV1_0_AV_PAIR {
    fn eq(&self, other: &Self) -> bool {
        self.AvId == other.AvId && self.AvLen == other.AvLen
    }
}
impl ::core::cmp::Eq for MSV1_0_AV_PAIR {}
impl ::core::default::Default for MSV1_0_AV_PAIR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct MSV1_0_CREDENTIAL_KEY {
    pub Data: [u8; 20],
}
impl ::core::marker::Copy for MSV1_0_CREDENTIAL_KEY {}
impl ::core::clone::Clone for MSV1_0_CREDENTIAL_KEY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MSV1_0_CREDENTIAL_KEY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MSV1_0_CREDENTIAL_KEY").field("Data", &self.Data).finish()
    }
}
impl ::windows_core::TypeKind for MSV1_0_CREDENTIAL_KEY {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for MSV1_0_CREDENTIAL_KEY {
    fn eq(&self, other: &Self) -> bool {
        self.Data == other.Data
    }
}
impl ::core::cmp::Eq for MSV1_0_CREDENTIAL_KEY {}
impl ::core::default::Default for MSV1_0_CREDENTIAL_KEY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct MSV1_0_ENUMUSERS_REQUEST {
    pub MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
}
impl ::core::marker::Copy for MSV1_0_ENUMUSERS_REQUEST {}
impl ::core::clone::Clone for MSV1_0_ENUMUSERS_REQUEST {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MSV1_0_ENUMUSERS_REQUEST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MSV1_0_ENUMUSERS_REQUEST").field("MessageType", &self.MessageType).finish()
    }
}
impl ::windows_core::TypeKind for MSV1_0_ENUMUSERS_REQUEST {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for MSV1_0_ENUMUSERS_REQUEST {
    fn eq(&self, other: &Self) -> bool {
        self.MessageType == other.MessageType
    }
}
impl ::core::cmp::Eq for MSV1_0_ENUMUSERS_REQUEST {}
impl ::core::default::Default for MSV1_0_ENUMUSERS_REQUEST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct MSV1_0_ENUMUSERS_RESPONSE {
    pub MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
    pub NumberOfLoggedOnUsers: u32,
    pub LogonIds: *mut super::super::super::Win32::Foundation::LUID,
    pub EnumHandles: *mut u32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for MSV1_0_ENUMUSERS_RESPONSE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for MSV1_0_ENUMUSERS_RESPONSE {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for MSV1_0_ENUMUSERS_RESPONSE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MSV1_0_ENUMUSERS_RESPONSE").field("MessageType", &self.MessageType).field("NumberOfLoggedOnUsers", &self.NumberOfLoggedOnUsers).field("LogonIds", &self.LogonIds).field("EnumHandles", &self.EnumHandles).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for MSV1_0_ENUMUSERS_RESPONSE {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for MSV1_0_ENUMUSERS_RESPONSE {
    fn eq(&self, other: &Self) -> bool {
        self.MessageType == other.MessageType && self.NumberOfLoggedOnUsers == other.NumberOfLoggedOnUsers && self.LogonIds == other.LogonIds && self.EnumHandles == other.EnumHandles
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for MSV1_0_ENUMUSERS_RESPONSE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MSV1_0_ENUMUSERS_RESPONSE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct MSV1_0_GETCHALLENRESP_REQUEST {
    pub MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
    pub ParameterControl: u32,
    pub LogonId: super::super::super::Win32::Foundation::LUID,
    pub Password: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub ChallengeToClient: [u8; 8],
    pub UserName: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub LogonDomainName: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub ServerName: super::super::super::Win32::Foundation::UNICODE_STRING,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for MSV1_0_GETCHALLENRESP_REQUEST {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for MSV1_0_GETCHALLENRESP_REQUEST {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for MSV1_0_GETCHALLENRESP_REQUEST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MSV1_0_GETCHALLENRESP_REQUEST").field("MessageType", &self.MessageType).field("ParameterControl", &self.ParameterControl).field("LogonId", &self.LogonId).field("Password", &self.Password).field("ChallengeToClient", &self.ChallengeToClient).field("UserName", &self.UserName).field("LogonDomainName", &self.LogonDomainName).field("ServerName", &self.ServerName).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for MSV1_0_GETCHALLENRESP_REQUEST {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for MSV1_0_GETCHALLENRESP_REQUEST {
    fn eq(&self, other: &Self) -> bool {
        self.MessageType == other.MessageType && self.ParameterControl == other.ParameterControl && self.LogonId == other.LogonId && self.Password == other.Password && self.ChallengeToClient == other.ChallengeToClient && self.UserName == other.UserName && self.LogonDomainName == other.LogonDomainName && self.ServerName == other.ServerName
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for MSV1_0_GETCHALLENRESP_REQUEST {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MSV1_0_GETCHALLENRESP_REQUEST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct MSV1_0_GETCHALLENRESP_REQUEST_V1 {
    pub MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
    pub ParameterControl: u32,
    pub LogonId: super::super::super::Win32::Foundation::LUID,
    pub Password: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub ChallengeToClient: [u8; 8],
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for MSV1_0_GETCHALLENRESP_REQUEST_V1 {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for MSV1_0_GETCHALLENRESP_REQUEST_V1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for MSV1_0_GETCHALLENRESP_REQUEST_V1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MSV1_0_GETCHALLENRESP_REQUEST_V1").field("MessageType", &self.MessageType).field("ParameterControl", &self.ParameterControl).field("LogonId", &self.LogonId).field("Password", &self.Password).field("ChallengeToClient", &self.ChallengeToClient).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for MSV1_0_GETCHALLENRESP_REQUEST_V1 {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for MSV1_0_GETCHALLENRESP_REQUEST_V1 {
    fn eq(&self, other: &Self) -> bool {
        self.MessageType == other.MessageType && self.ParameterControl == other.ParameterControl && self.LogonId == other.LogonId && self.Password == other.Password && self.ChallengeToClient == other.ChallengeToClient
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for MSV1_0_GETCHALLENRESP_REQUEST_V1 {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MSV1_0_GETCHALLENRESP_REQUEST_V1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
pub struct MSV1_0_GETCHALLENRESP_RESPONSE {
    pub MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
    pub CaseSensitiveChallengeResponse: super::super::super::Win32::System::Kernel::STRING,
    pub CaseInsensitiveChallengeResponse: super::super::super::Win32::System::Kernel::STRING,
    pub UserName: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub LogonDomainName: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub UserSessionKey: [u8; 16],
    pub LanmanSessionKey: [u8; 8],
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::marker::Copy for MSV1_0_GETCHALLENRESP_RESPONSE {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::clone::Clone for MSV1_0_GETCHALLENRESP_RESPONSE {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::fmt::Debug for MSV1_0_GETCHALLENRESP_RESPONSE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MSV1_0_GETCHALLENRESP_RESPONSE").field("MessageType", &self.MessageType).field("CaseSensitiveChallengeResponse", &self.CaseSensitiveChallengeResponse).field("CaseInsensitiveChallengeResponse", &self.CaseInsensitiveChallengeResponse).field("UserName", &self.UserName).field("LogonDomainName", &self.LogonDomainName).field("UserSessionKey", &self.UserSessionKey).field("LanmanSessionKey", &self.LanmanSessionKey).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::windows_core::TypeKind for MSV1_0_GETCHALLENRESP_RESPONSE {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::cmp::PartialEq for MSV1_0_GETCHALLENRESP_RESPONSE {
    fn eq(&self, other: &Self) -> bool {
        self.MessageType == other.MessageType && self.CaseSensitiveChallengeResponse == other.CaseSensitiveChallengeResponse && self.CaseInsensitiveChallengeResponse == other.CaseInsensitiveChallengeResponse && self.UserName == other.UserName && self.LogonDomainName == other.LogonDomainName && self.UserSessionKey == other.UserSessionKey && self.LanmanSessionKey == other.LanmanSessionKey
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::cmp::Eq for MSV1_0_GETCHALLENRESP_RESPONSE {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::default::Default for MSV1_0_GETCHALLENRESP_RESPONSE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct MSV1_0_GETUSERINFO_REQUEST {
    pub MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
    pub LogonId: super::super::super::Win32::Foundation::LUID,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for MSV1_0_GETUSERINFO_REQUEST {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for MSV1_0_GETUSERINFO_REQUEST {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for MSV1_0_GETUSERINFO_REQUEST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MSV1_0_GETUSERINFO_REQUEST").field("MessageType", &self.MessageType).field("LogonId", &self.LogonId).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for MSV1_0_GETUSERINFO_REQUEST {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for MSV1_0_GETUSERINFO_REQUEST {
    fn eq(&self, other: &Self) -> bool {
        self.MessageType == other.MessageType && self.LogonId == other.LogonId
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for MSV1_0_GETUSERINFO_REQUEST {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MSV1_0_GETUSERINFO_REQUEST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct MSV1_0_GETUSERINFO_RESPONSE {
    pub MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
    pub UserSid: super::super::super::Win32::Foundation::PSID,
    pub UserName: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub LogonDomainName: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub LogonServer: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub LogonType: SECURITY_LOGON_TYPE,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for MSV1_0_GETUSERINFO_RESPONSE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for MSV1_0_GETUSERINFO_RESPONSE {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for MSV1_0_GETUSERINFO_RESPONSE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MSV1_0_GETUSERINFO_RESPONSE").field("MessageType", &self.MessageType).field("UserSid", &self.UserSid).field("UserName", &self.UserName).field("LogonDomainName", &self.LogonDomainName).field("LogonServer", &self.LogonServer).field("LogonType", &self.LogonType).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for MSV1_0_GETUSERINFO_RESPONSE {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for MSV1_0_GETUSERINFO_RESPONSE {
    fn eq(&self, other: &Self) -> bool {
        self.MessageType == other.MessageType && self.UserSid == other.UserSid && self.UserName == other.UserName && self.LogonDomainName == other.LogonDomainName && self.LogonServer == other.LogonServer && self.LogonType == other.LogonType
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for MSV1_0_GETUSERINFO_RESPONSE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MSV1_0_GETUSERINFO_RESPONSE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct MSV1_0_INTERACTIVE_LOGON {
    pub MessageType: MSV1_0_LOGON_SUBMIT_TYPE,
    pub LogonDomainName: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub UserName: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub Password: super::super::super::Win32::Foundation::UNICODE_STRING,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for MSV1_0_INTERACTIVE_LOGON {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for MSV1_0_INTERACTIVE_LOGON {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for MSV1_0_INTERACTIVE_LOGON {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MSV1_0_INTERACTIVE_LOGON").field("MessageType", &self.MessageType).field("LogonDomainName", &self.LogonDomainName).field("UserName", &self.UserName).field("Password", &self.Password).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for MSV1_0_INTERACTIVE_LOGON {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for MSV1_0_INTERACTIVE_LOGON {
    fn eq(&self, other: &Self) -> bool {
        self.MessageType == other.MessageType && self.LogonDomainName == other.LogonDomainName && self.UserName == other.UserName && self.Password == other.Password
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for MSV1_0_INTERACTIVE_LOGON {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MSV1_0_INTERACTIVE_LOGON {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct MSV1_0_INTERACTIVE_PROFILE {
    pub MessageType: MSV1_0_PROFILE_BUFFER_TYPE,
    pub LogonCount: u16,
    pub BadPasswordCount: u16,
    pub LogonTime: i64,
    pub LogoffTime: i64,
    pub KickOffTime: i64,
    pub PasswordLastSet: i64,
    pub PasswordCanChange: i64,
    pub PasswordMustChange: i64,
    pub LogonScript: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub HomeDirectory: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub FullName: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub ProfilePath: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub HomeDirectoryDrive: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub LogonServer: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub UserFlags: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for MSV1_0_INTERACTIVE_PROFILE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for MSV1_0_INTERACTIVE_PROFILE {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for MSV1_0_INTERACTIVE_PROFILE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MSV1_0_INTERACTIVE_PROFILE")
            .field("MessageType", &self.MessageType)
            .field("LogonCount", &self.LogonCount)
            .field("BadPasswordCount", &self.BadPasswordCount)
            .field("LogonTime", &self.LogonTime)
            .field("LogoffTime", &self.LogoffTime)
            .field("KickOffTime", &self.KickOffTime)
            .field("PasswordLastSet", &self.PasswordLastSet)
            .field("PasswordCanChange", &self.PasswordCanChange)
            .field("PasswordMustChange", &self.PasswordMustChange)
            .field("LogonScript", &self.LogonScript)
            .field("HomeDirectory", &self.HomeDirectory)
            .field("FullName", &self.FullName)
            .field("ProfilePath", &self.ProfilePath)
            .field("HomeDirectoryDrive", &self.HomeDirectoryDrive)
            .field("LogonServer", &self.LogonServer)
            .field("UserFlags", &self.UserFlags)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for MSV1_0_INTERACTIVE_PROFILE {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for MSV1_0_INTERACTIVE_PROFILE {
    fn eq(&self, other: &Self) -> bool {
        self.MessageType == other.MessageType && self.LogonCount == other.LogonCount && self.BadPasswordCount == other.BadPasswordCount && self.LogonTime == other.LogonTime && self.LogoffTime == other.LogoffTime && self.KickOffTime == other.KickOffTime && self.PasswordLastSet == other.PasswordLastSet && self.PasswordCanChange == other.PasswordCanChange && self.PasswordMustChange == other.PasswordMustChange && self.LogonScript == other.LogonScript && self.HomeDirectory == other.HomeDirectory && self.FullName == other.FullName && self.ProfilePath == other.ProfilePath && self.HomeDirectoryDrive == other.HomeDirectoryDrive && self.LogonServer == other.LogonServer && self.UserFlags == other.UserFlags
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for MSV1_0_INTERACTIVE_PROFILE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MSV1_0_INTERACTIVE_PROFILE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct MSV1_0_IUM_SUPPLEMENTAL_CREDENTIAL {
    pub Version: u32,
    pub EncryptedCredsSize: u32,
    pub EncryptedCreds: [u8; 1],
}
impl ::core::marker::Copy for MSV1_0_IUM_SUPPLEMENTAL_CREDENTIAL {}
impl ::core::clone::Clone for MSV1_0_IUM_SUPPLEMENTAL_CREDENTIAL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MSV1_0_IUM_SUPPLEMENTAL_CREDENTIAL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MSV1_0_IUM_SUPPLEMENTAL_CREDENTIAL").field("Version", &self.Version).field("EncryptedCredsSize", &self.EncryptedCredsSize).field("EncryptedCreds", &self.EncryptedCreds).finish()
    }
}
impl ::windows_core::TypeKind for MSV1_0_IUM_SUPPLEMENTAL_CREDENTIAL {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for MSV1_0_IUM_SUPPLEMENTAL_CREDENTIAL {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.EncryptedCredsSize == other.EncryptedCredsSize && self.EncryptedCreds == other.EncryptedCreds
    }
}
impl ::core::cmp::Eq for MSV1_0_IUM_SUPPLEMENTAL_CREDENTIAL {}
impl ::core::default::Default for MSV1_0_IUM_SUPPLEMENTAL_CREDENTIAL {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct MSV1_0_LM20_CHALLENGE_REQUEST {
    pub MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
}
impl ::core::marker::Copy for MSV1_0_LM20_CHALLENGE_REQUEST {}
impl ::core::clone::Clone for MSV1_0_LM20_CHALLENGE_REQUEST {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MSV1_0_LM20_CHALLENGE_REQUEST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MSV1_0_LM20_CHALLENGE_REQUEST").field("MessageType", &self.MessageType).finish()
    }
}
impl ::windows_core::TypeKind for MSV1_0_LM20_CHALLENGE_REQUEST {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for MSV1_0_LM20_CHALLENGE_REQUEST {
    fn eq(&self, other: &Self) -> bool {
        self.MessageType == other.MessageType
    }
}
impl ::core::cmp::Eq for MSV1_0_LM20_CHALLENGE_REQUEST {}
impl ::core::default::Default for MSV1_0_LM20_CHALLENGE_REQUEST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct MSV1_0_LM20_CHALLENGE_RESPONSE {
    pub MessageType: MSV1_0_PROTOCOL_MESSAGE_TYPE,
    pub ChallengeToClient: [u8; 8],
}
impl ::core::marker::Copy for MSV1_0_LM20_CHALLENGE_RESPONSE {}
impl ::core::clone::Clone for MSV1_0_LM20_CHALLENGE_RESPONSE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MSV1_0_LM20_CHALLENGE_RESPONSE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MSV1_0_LM20_CHALLENGE_RESPONSE").field("MessageType", &self.MessageType).field("ChallengeToClient", &self.ChallengeToClient).finish()
    }
}
impl ::windows_core::TypeKind for MSV1_0_LM20_CHALLENGE_RESPONSE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for MSV1_0_LM20_CHALLENGE_RESPONSE {
    fn eq(&self, other: &Self) -> bool {
        self.MessageType == other.MessageType && self.ChallengeToClient == other.ChallengeToClient
    }
}
impl ::core::cmp::Eq for MSV1_0_LM20_CHALLENGE_RESPONSE {}
impl ::core::default::Default for MSV1_0_LM20_CHALLENGE_RESPONSE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
pub struct MSV1_0_LM20_LOGON {
    pub MessageType: MSV1_0_LOGON_SUBMIT_TYPE,
    pub LogonDomainName: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub UserName: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub Workstation: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub ChallengeToClient: [u8; 8],
    pub CaseSensitiveChallengeResponse: super::super::super::Win32::System::Kernel::STRING,
    pub CaseInsensitiveChallengeResponse: super::super::super::Win32::System::Kernel::STRING,
    pub ParameterControl: u32,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::marker::Copy for MSV1_0_LM20_LOGON {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::clone::Clone for MSV1_0_LM20_LOGON {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::fmt::Debug for MSV1_0_LM20_LOGON {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MSV1_0_LM20_LOGON").field("MessageType", &self.MessageType).field("LogonDomainName", &self.LogonDomainName).field("UserName", &self.UserName).field("Workstation", &self.Workstation).field("ChallengeToClient", &self.ChallengeToClient).field("CaseSensitiveChallengeResponse", &self.CaseSensitiveChallengeResponse).field("CaseInsensitiveChallengeResponse", &self.CaseInsensitiveChallengeResponse).field("ParameterControl", &self.ParameterControl).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::windows_core::TypeKind for MSV1_0_LM20_LOGON {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::cmp::PartialEq for MSV1_0_LM20_LOGON {
    fn eq(&self, other: &Self) -> bool {
        self.MessageType == other.MessageType && self.LogonDomainName == other.LogonDomainName && self.UserName == other.UserName && self.Workstation == other.Workstation && self.ChallengeToClient == other.ChallengeToClient && self.CaseSensitiveChallengeResponse == other.CaseSensitiveChallengeResponse && self.CaseInsensitiveChallengeResponse == other.CaseInsensitiveChallengeResponse && self.ParameterControl == other.ParameterControl
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::cmp::Eq for MSV1_0_LM20_LOGON {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::default::Default for MSV1_0_LM20_LOGON {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct MSV1_0_LM20_LOGON_PROFILE {
    pub MessageType: MSV1_0_PROFILE_BUFFER_TYPE,
    pub KickOffTime: i64,
    pub LogoffTime: i64,
    pub UserFlags: u32,
    pub UserSessionKey: [u8; 16],
    pub LogonDomainName: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub LanmanSessionKey: [u8; 8],
    pub LogonServer: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub UserParameters: super::super::super::Win32::Foundation::UNICODE_STRING,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for MSV1_0_LM20_LOGON_PROFILE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for MSV1_0_LM20_LOGON_PROFILE {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for MSV1_0_LM20_LOGON_PROFILE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MSV1_0_LM20_LOGON_PROFILE").field("MessageType", &self.MessageType).field("KickOffTime", &self.KickOffTime).field("LogoffTime", &self.LogoffTime).field("UserFlags", &self.UserFlags).field("UserSessionKey", &self.UserSessionKey).field("LogonDomainName", &self.LogonDomainName).field("LanmanSessionKey", &self.LanmanSessionKey).field("LogonServer", &self.LogonServer).field("UserParameters", &self.UserParameters).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for MSV1_0_LM20_LOGON_PROFILE {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for MSV1_0_LM20_LOGON_PROFILE {
    fn eq(&self, other: &Self) -> bool {
        self.MessageType == other.MessageType && self.KickOffTime == other.KickOffTime && self.LogoffTime == other.LogoffTime && self.UserFlags == other.UserFlags && self.UserSessionKey == other.UserSessionKey && self.LogonDomainName == other.LogonDomainName && self.LanmanSessionKey == other.LanmanSessionKey && self.LogonServer == other.LogonServer && self.UserParameters == other.UserParameters
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for MSV1_0_LM20_LOGON_PROFILE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MSV1_0_LM20_LOGON_PROFILE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct MSV1_0_NTLM3_RESPONSE {
    pub Response: [u8; 16],
    pub RespType: u8,
    pub HiRespType: u8,
    pub Flags: u16,
    pub MsgWord: u32,
    pub TimeStamp: u64,
    pub ChallengeFromClient: [u8; 8],
    pub AvPairsOff: u32,
    pub Buffer: [u8; 1],
}
impl ::core::marker::Copy for MSV1_0_NTLM3_RESPONSE {}
impl ::core::clone::Clone for MSV1_0_NTLM3_RESPONSE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MSV1_0_NTLM3_RESPONSE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MSV1_0_NTLM3_RESPONSE").field("Response", &self.Response).field("RespType", &self.RespType).field("HiRespType", &self.HiRespType).field("Flags", &self.Flags).field("MsgWord", &self.MsgWord).field("TimeStamp", &self.TimeStamp).field("ChallengeFromClient", &self.ChallengeFromClient).field("AvPairsOff", &self.AvPairsOff).field("Buffer", &self.Buffer).finish()
    }
}
impl ::windows_core::TypeKind for MSV1_0_NTLM3_RESPONSE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for MSV1_0_NTLM3_RESPONSE {
    fn eq(&self, other: &Self) -> bool {
        self.Response == other.Response && self.RespType == other.RespType && self.HiRespType == other.HiRespType && self.Flags == other.Flags && self.MsgWord == other.MsgWord && self.TimeStamp == other.TimeStamp && self.ChallengeFromClient == other.ChallengeFromClient && self.AvPairsOff == other.AvPairsOff && self.Buffer == other.Buffer
    }
}
impl ::core::cmp::Eq for MSV1_0_NTLM3_RESPONSE {}
impl ::core::default::Default for MSV1_0_NTLM3_RESPONSE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed(1))]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct MSV1_0_REMOTE_SUPPLEMENTAL_CREDENTIAL {
    pub Version: u32,
    pub Flags: u32,
    pub CredentialKey: MSV1_0_CREDENTIAL_KEY,
    pub CredentialKeyType: MSV1_0_CREDENTIAL_KEY_TYPE,
    pub EncryptedCredsSize: u32,
    pub EncryptedCreds: [u8; 1],
}
impl ::core::marker::Copy for MSV1_0_REMOTE_SUPPLEMENTAL_CREDENTIAL {}
impl ::core::clone::Clone for MSV1_0_REMOTE_SUPPLEMENTAL_CREDENTIAL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for MSV1_0_REMOTE_SUPPLEMENTAL_CREDENTIAL {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for MSV1_0_REMOTE_SUPPLEMENTAL_CREDENTIAL {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct MSV1_0_S4U_LOGON {
    pub MessageType: MSV1_0_LOGON_SUBMIT_TYPE,
    pub Flags: u32,
    pub UserPrincipalName: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub DomainName: super::super::super::Win32::Foundation::UNICODE_STRING,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for MSV1_0_S4U_LOGON {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for MSV1_0_S4U_LOGON {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for MSV1_0_S4U_LOGON {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MSV1_0_S4U_LOGON").field("MessageType", &self.MessageType).field("Flags", &self.Flags).field("UserPrincipalName", &self.UserPrincipalName).field("DomainName", &self.DomainName).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for MSV1_0_S4U_LOGON {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for MSV1_0_S4U_LOGON {
    fn eq(&self, other: &Self) -> bool {
        self.MessageType == other.MessageType && self.Flags == other.Flags && self.UserPrincipalName == other.UserPrincipalName && self.DomainName == other.DomainName
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for MSV1_0_S4U_LOGON {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for MSV1_0_S4U_LOGON {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
pub struct MSV1_0_SUBAUTH_LOGON {
    pub MessageType: MSV1_0_LOGON_SUBMIT_TYPE,
    pub LogonDomainName: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub UserName: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub Workstation: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub ChallengeToClient: [u8; 8],
    pub AuthenticationInfo1: super::super::super::Win32::System::Kernel::STRING,
    pub AuthenticationInfo2: super::super::super::Win32::System::Kernel::STRING,
    pub ParameterControl: u32,
    pub SubAuthPackageId: u32,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::marker::Copy for MSV1_0_SUBAUTH_LOGON {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::clone::Clone for MSV1_0_SUBAUTH_LOGON {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::fmt::Debug for MSV1_0_SUBAUTH_LOGON {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MSV1_0_SUBAUTH_LOGON").field("MessageType", &self.MessageType).field("LogonDomainName", &self.LogonDomainName).field("UserName", &self.UserName).field("Workstation", &self.Workstation).field("ChallengeToClient", &self.ChallengeToClient).field("AuthenticationInfo1", &self.AuthenticationInfo1).field("AuthenticationInfo2", &self.AuthenticationInfo2).field("ParameterControl", &self.ParameterControl).field("SubAuthPackageId", &self.SubAuthPackageId).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::windows_core::TypeKind for MSV1_0_SUBAUTH_LOGON {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::cmp::PartialEq for MSV1_0_SUBAUTH_LOGON {
    fn eq(&self, other: &Self) -> bool {
        self.MessageType == other.MessageType && self.LogonDomainName == other.LogonDomainName && self.UserName == other.UserName && self.Workstation == other.Workstation && self.ChallengeToClient == other.ChallengeToClient && self.AuthenticationInfo1 == other.AuthenticationInfo1 && self.AuthenticationInfo2 == other.AuthenticationInfo2 && self.ParameterControl == other.ParameterControl && self.SubAuthPackageId == other.SubAuthPackageId
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::cmp::Eq for MSV1_0_SUBAUTH_LOGON {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::default::Default for MSV1_0_SUBAUTH_LOGON {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct MSV1_0_SUPPLEMENTAL_CREDENTIAL {
    pub Version: u32,
    pub Flags: u32,
    pub LmPassword: [u8; 16],
    pub NtPassword: [u8; 16],
}
impl ::core::marker::Copy for MSV1_0_SUPPLEMENTAL_CREDENTIAL {}
impl ::core::clone::Clone for MSV1_0_SUPPLEMENTAL_CREDENTIAL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MSV1_0_SUPPLEMENTAL_CREDENTIAL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MSV1_0_SUPPLEMENTAL_CREDENTIAL").field("Version", &self.Version).field("Flags", &self.Flags).field("LmPassword", &self.LmPassword).field("NtPassword", &self.NtPassword).finish()
    }
}
impl ::windows_core::TypeKind for MSV1_0_SUPPLEMENTAL_CREDENTIAL {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for MSV1_0_SUPPLEMENTAL_CREDENTIAL {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Flags == other.Flags && self.LmPassword == other.LmPassword && self.NtPassword == other.NtPassword
    }
}
impl ::core::cmp::Eq for MSV1_0_SUPPLEMENTAL_CREDENTIAL {}
impl ::core::default::Default for MSV1_0_SUPPLEMENTAL_CREDENTIAL {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct MSV1_0_SUPPLEMENTAL_CREDENTIAL_V2 {
    pub Version: u32,
    pub Flags: u32,
    pub NtPassword: [u8; 16],
    pub CredentialKey: MSV1_0_CREDENTIAL_KEY,
}
impl ::core::marker::Copy for MSV1_0_SUPPLEMENTAL_CREDENTIAL_V2 {}
impl ::core::clone::Clone for MSV1_0_SUPPLEMENTAL_CREDENTIAL_V2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MSV1_0_SUPPLEMENTAL_CREDENTIAL_V2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MSV1_0_SUPPLEMENTAL_CREDENTIAL_V2").field("Version", &self.Version).field("Flags", &self.Flags).field("NtPassword", &self.NtPassword).field("CredentialKey", &self.CredentialKey).finish()
    }
}
impl ::windows_core::TypeKind for MSV1_0_SUPPLEMENTAL_CREDENTIAL_V2 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for MSV1_0_SUPPLEMENTAL_CREDENTIAL_V2 {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Flags == other.Flags && self.NtPassword == other.NtPassword && self.CredentialKey == other.CredentialKey
    }
}
impl ::core::cmp::Eq for MSV1_0_SUPPLEMENTAL_CREDENTIAL_V2 {}
impl ::core::default::Default for MSV1_0_SUPPLEMENTAL_CREDENTIAL_V2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct MSV1_0_SUPPLEMENTAL_CREDENTIAL_V3 {
    pub Version: u32,
    pub Flags: u32,
    pub CredentialKeyType: MSV1_0_CREDENTIAL_KEY_TYPE,
    pub NtPassword: [u8; 16],
    pub CredentialKey: MSV1_0_CREDENTIAL_KEY,
    pub ShaPassword: [u8; 20],
}
impl ::core::marker::Copy for MSV1_0_SUPPLEMENTAL_CREDENTIAL_V3 {}
impl ::core::clone::Clone for MSV1_0_SUPPLEMENTAL_CREDENTIAL_V3 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for MSV1_0_SUPPLEMENTAL_CREDENTIAL_V3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("MSV1_0_SUPPLEMENTAL_CREDENTIAL_V3").field("Version", &self.Version).field("Flags", &self.Flags).field("CredentialKeyType", &self.CredentialKeyType).field("NtPassword", &self.NtPassword).field("CredentialKey", &self.CredentialKey).field("ShaPassword", &self.ShaPassword).finish()
    }
}
impl ::windows_core::TypeKind for MSV1_0_SUPPLEMENTAL_CREDENTIAL_V3 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for MSV1_0_SUPPLEMENTAL_CREDENTIAL_V3 {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Flags == other.Flags && self.CredentialKeyType == other.CredentialKeyType && self.NtPassword == other.NtPassword && self.CredentialKey == other.CredentialKey && self.ShaPassword == other.ShaPassword
    }
}
impl ::core::cmp::Eq for MSV1_0_SUPPLEMENTAL_CREDENTIAL_V3 {}
impl ::core::default::Default for MSV1_0_SUPPLEMENTAL_CREDENTIAL_V3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NETWORK_APP_INSTANCE_EA {
    pub AppInstanceID: ::windows_core::GUID,
    pub CsvFlags: u32,
}
impl ::core::marker::Copy for NETWORK_APP_INSTANCE_EA {}
impl ::core::clone::Clone for NETWORK_APP_INSTANCE_EA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NETWORK_APP_INSTANCE_EA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NETWORK_APP_INSTANCE_EA").field("AppInstanceID", &self.AppInstanceID).field("CsvFlags", &self.CsvFlags).finish()
    }
}
impl ::windows_core::TypeKind for NETWORK_APP_INSTANCE_EA {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NETWORK_APP_INSTANCE_EA {
    fn eq(&self, other: &Self) -> bool {
        self.AppInstanceID == other.AppInstanceID && self.CsvFlags == other.CsvFlags
    }
}
impl ::core::cmp::Eq for NETWORK_APP_INSTANCE_EA {}
impl ::core::default::Default for NETWORK_APP_INSTANCE_EA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NETWORK_APP_INSTANCE_ECP_CONTEXT {
    pub Size: u16,
    pub Reserved: u16,
    pub AppInstanceID: ::windows_core::GUID,
}
impl ::core::marker::Copy for NETWORK_APP_INSTANCE_ECP_CONTEXT {}
impl ::core::clone::Clone for NETWORK_APP_INSTANCE_ECP_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NETWORK_APP_INSTANCE_ECP_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NETWORK_APP_INSTANCE_ECP_CONTEXT").field("Size", &self.Size).field("Reserved", &self.Reserved).field("AppInstanceID", &self.AppInstanceID).finish()
    }
}
impl ::windows_core::TypeKind for NETWORK_APP_INSTANCE_ECP_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NETWORK_APP_INSTANCE_ECP_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.Reserved == other.Reserved && self.AppInstanceID == other.AppInstanceID
    }
}
impl ::core::cmp::Eq for NETWORK_APP_INSTANCE_ECP_CONTEXT {}
impl ::core::default::Default for NETWORK_APP_INSTANCE_ECP_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NETWORK_APP_INSTANCE_VERSION_ECP_CONTEXT {
    pub Size: u16,
    pub Reserved: u16,
    pub VersionHigh: u64,
    pub VersionLow: u64,
}
impl ::core::marker::Copy for NETWORK_APP_INSTANCE_VERSION_ECP_CONTEXT {}
impl ::core::clone::Clone for NETWORK_APP_INSTANCE_VERSION_ECP_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NETWORK_APP_INSTANCE_VERSION_ECP_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NETWORK_APP_INSTANCE_VERSION_ECP_CONTEXT").field("Size", &self.Size).field("Reserved", &self.Reserved).field("VersionHigh", &self.VersionHigh).field("VersionLow", &self.VersionLow).finish()
    }
}
impl ::windows_core::TypeKind for NETWORK_APP_INSTANCE_VERSION_ECP_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NETWORK_APP_INSTANCE_VERSION_ECP_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.Reserved == other.Reserved && self.VersionHigh == other.VersionHigh && self.VersionLow == other.VersionLow
    }
}
impl ::core::cmp::Eq for NETWORK_APP_INSTANCE_VERSION_ECP_CONTEXT {}
impl ::core::default::Default for NETWORK_APP_INSTANCE_VERSION_ECP_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NETWORK_OPEN_ECP_CONTEXT {
    pub Size: u16,
    pub Reserved: u16,
    pub Anonymous: NETWORK_OPEN_ECP_CONTEXT_0,
}
impl ::core::marker::Copy for NETWORK_OPEN_ECP_CONTEXT {}
impl ::core::clone::Clone for NETWORK_OPEN_ECP_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NETWORK_OPEN_ECP_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NETWORK_OPEN_ECP_CONTEXT").field("Size", &self.Size).field("Reserved", &self.Reserved).field("Anonymous", &self.Anonymous).finish()
    }
}
impl ::windows_core::TypeKind for NETWORK_OPEN_ECP_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NETWORK_OPEN_ECP_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.Reserved == other.Reserved && self.Anonymous == other.Anonymous
    }
}
impl ::core::cmp::Eq for NETWORK_OPEN_ECP_CONTEXT {}
impl ::core::default::Default for NETWORK_OPEN_ECP_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NETWORK_OPEN_ECP_CONTEXT_0 {
    pub r#in: NETWORK_OPEN_ECP_CONTEXT_0_0,
    pub out: NETWORK_OPEN_ECP_CONTEXT_0_1,
}
impl ::core::marker::Copy for NETWORK_OPEN_ECP_CONTEXT_0 {}
impl ::core::clone::Clone for NETWORK_OPEN_ECP_CONTEXT_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NETWORK_OPEN_ECP_CONTEXT_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NETWORK_OPEN_ECP_CONTEXT_0").field("in", &self.r#in).field("out", &self.out).finish()
    }
}
impl ::windows_core::TypeKind for NETWORK_OPEN_ECP_CONTEXT_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NETWORK_OPEN_ECP_CONTEXT_0 {
    fn eq(&self, other: &Self) -> bool {
        self.r#in == other.r#in && self.out == other.out
    }
}
impl ::core::cmp::Eq for NETWORK_OPEN_ECP_CONTEXT_0 {}
impl ::core::default::Default for NETWORK_OPEN_ECP_CONTEXT_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NETWORK_OPEN_ECP_CONTEXT_0_0 {
    pub Location: NETWORK_OPEN_LOCATION_QUALIFIER,
    pub Integrity: NETWORK_OPEN_INTEGRITY_QUALIFIER,
    pub Flags: u32,
}
impl ::core::marker::Copy for NETWORK_OPEN_ECP_CONTEXT_0_0 {}
impl ::core::clone::Clone for NETWORK_OPEN_ECP_CONTEXT_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NETWORK_OPEN_ECP_CONTEXT_0_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NETWORK_OPEN_ECP_CONTEXT_0_0").field("Location", &self.Location).field("Integrity", &self.Integrity).field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for NETWORK_OPEN_ECP_CONTEXT_0_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NETWORK_OPEN_ECP_CONTEXT_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.Location == other.Location && self.Integrity == other.Integrity && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for NETWORK_OPEN_ECP_CONTEXT_0_0 {}
impl ::core::default::Default for NETWORK_OPEN_ECP_CONTEXT_0_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NETWORK_OPEN_ECP_CONTEXT_0_1 {
    pub Location: NETWORK_OPEN_LOCATION_QUALIFIER,
    pub Integrity: NETWORK_OPEN_INTEGRITY_QUALIFIER,
    pub Flags: u32,
}
impl ::core::marker::Copy for NETWORK_OPEN_ECP_CONTEXT_0_1 {}
impl ::core::clone::Clone for NETWORK_OPEN_ECP_CONTEXT_0_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NETWORK_OPEN_ECP_CONTEXT_0_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NETWORK_OPEN_ECP_CONTEXT_0_1").field("Location", &self.Location).field("Integrity", &self.Integrity).field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for NETWORK_OPEN_ECP_CONTEXT_0_1 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NETWORK_OPEN_ECP_CONTEXT_0_1 {
    fn eq(&self, other: &Self) -> bool {
        self.Location == other.Location && self.Integrity == other.Integrity && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for NETWORK_OPEN_ECP_CONTEXT_0_1 {}
impl ::core::default::Default for NETWORK_OPEN_ECP_CONTEXT_0_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NETWORK_OPEN_ECP_CONTEXT_V0 {
    pub Size: u16,
    pub Reserved: u16,
    pub Anonymous: NETWORK_OPEN_ECP_CONTEXT_V0_0,
}
impl ::core::marker::Copy for NETWORK_OPEN_ECP_CONTEXT_V0 {}
impl ::core::clone::Clone for NETWORK_OPEN_ECP_CONTEXT_V0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NETWORK_OPEN_ECP_CONTEXT_V0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NETWORK_OPEN_ECP_CONTEXT_V0").field("Size", &self.Size).field("Reserved", &self.Reserved).field("Anonymous", &self.Anonymous).finish()
    }
}
impl ::windows_core::TypeKind for NETWORK_OPEN_ECP_CONTEXT_V0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NETWORK_OPEN_ECP_CONTEXT_V0 {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.Reserved == other.Reserved && self.Anonymous == other.Anonymous
    }
}
impl ::core::cmp::Eq for NETWORK_OPEN_ECP_CONTEXT_V0 {}
impl ::core::default::Default for NETWORK_OPEN_ECP_CONTEXT_V0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NETWORK_OPEN_ECP_CONTEXT_V0_0 {
    pub r#in: NETWORK_OPEN_ECP_CONTEXT_V0_0_0,
    pub out: NETWORK_OPEN_ECP_CONTEXT_V0_0_1,
}
impl ::core::marker::Copy for NETWORK_OPEN_ECP_CONTEXT_V0_0 {}
impl ::core::clone::Clone for NETWORK_OPEN_ECP_CONTEXT_V0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NETWORK_OPEN_ECP_CONTEXT_V0_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NETWORK_OPEN_ECP_CONTEXT_V0_0").field("in", &self.r#in).field("out", &self.out).finish()
    }
}
impl ::windows_core::TypeKind for NETWORK_OPEN_ECP_CONTEXT_V0_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NETWORK_OPEN_ECP_CONTEXT_V0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.r#in == other.r#in && self.out == other.out
    }
}
impl ::core::cmp::Eq for NETWORK_OPEN_ECP_CONTEXT_V0_0 {}
impl ::core::default::Default for NETWORK_OPEN_ECP_CONTEXT_V0_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NETWORK_OPEN_ECP_CONTEXT_V0_0_0 {
    pub Location: NETWORK_OPEN_LOCATION_QUALIFIER,
    pub Integrity: NETWORK_OPEN_INTEGRITY_QUALIFIER,
}
impl ::core::marker::Copy for NETWORK_OPEN_ECP_CONTEXT_V0_0_0 {}
impl ::core::clone::Clone for NETWORK_OPEN_ECP_CONTEXT_V0_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NETWORK_OPEN_ECP_CONTEXT_V0_0_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NETWORK_OPEN_ECP_CONTEXT_V0_0_0").field("Location", &self.Location).field("Integrity", &self.Integrity).finish()
    }
}
impl ::windows_core::TypeKind for NETWORK_OPEN_ECP_CONTEXT_V0_0_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NETWORK_OPEN_ECP_CONTEXT_V0_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.Location == other.Location && self.Integrity == other.Integrity
    }
}
impl ::core::cmp::Eq for NETWORK_OPEN_ECP_CONTEXT_V0_0_0 {}
impl ::core::default::Default for NETWORK_OPEN_ECP_CONTEXT_V0_0_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NETWORK_OPEN_ECP_CONTEXT_V0_0_1 {
    pub Location: NETWORK_OPEN_LOCATION_QUALIFIER,
    pub Integrity: NETWORK_OPEN_INTEGRITY_QUALIFIER,
}
impl ::core::marker::Copy for NETWORK_OPEN_ECP_CONTEXT_V0_0_1 {}
impl ::core::clone::Clone for NETWORK_OPEN_ECP_CONTEXT_V0_0_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NETWORK_OPEN_ECP_CONTEXT_V0_0_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NETWORK_OPEN_ECP_CONTEXT_V0_0_1").field("Location", &self.Location).field("Integrity", &self.Integrity).finish()
    }
}
impl ::windows_core::TypeKind for NETWORK_OPEN_ECP_CONTEXT_V0_0_1 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NETWORK_OPEN_ECP_CONTEXT_V0_0_1 {
    fn eq(&self, other: &Self) -> bool {
        self.Location == other.Location && self.Integrity == other.Integrity
    }
}
impl ::core::cmp::Eq for NETWORK_OPEN_ECP_CONTEXT_V0_0_1 {}
impl ::core::default::Default for NETWORK_OPEN_ECP_CONTEXT_V0_0_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct NFS_OPEN_ECP_CONTEXT {
    pub ExportAlias: *mut super::super::super::Win32::Foundation::UNICODE_STRING,
    pub ClientSocketAddress: *mut SOCKADDR_STORAGE,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for NFS_OPEN_ECP_CONTEXT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for NFS_OPEN_ECP_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for NFS_OPEN_ECP_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NFS_OPEN_ECP_CONTEXT").field("ExportAlias", &self.ExportAlias).field("ClientSocketAddress", &self.ClientSocketAddress).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for NFS_OPEN_ECP_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for NFS_OPEN_ECP_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.ExportAlias == other.ExportAlias && self.ClientSocketAddress == other.ClientSocketAddress
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for NFS_OPEN_ECP_CONTEXT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for NFS_OPEN_ECP_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NLSTABLEINFO {
    pub OemTableInfo: CPTABLEINFO,
    pub AnsiTableInfo: CPTABLEINFO,
    pub UpperCaseTable: *mut u16,
    pub LowerCaseTable: *mut u16,
}
impl ::core::marker::Copy for NLSTABLEINFO {}
impl ::core::clone::Clone for NLSTABLEINFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NLSTABLEINFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NLSTABLEINFO").field("OemTableInfo", &self.OemTableInfo).field("AnsiTableInfo", &self.AnsiTableInfo).field("UpperCaseTable", &self.UpperCaseTable).field("LowerCaseTable", &self.LowerCaseTable).finish()
    }
}
impl ::windows_core::TypeKind for NLSTABLEINFO {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NLSTABLEINFO {
    fn eq(&self, other: &Self) -> bool {
        self.OemTableInfo == other.OemTableInfo && self.AnsiTableInfo == other.AnsiTableInfo && self.UpperCaseTable == other.UpperCaseTable && self.LowerCaseTable == other.LowerCaseTable
    }
}
impl ::core::cmp::Eq for NLSTABLEINFO {}
impl ::core::default::Default for NLSTABLEINFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NTFS_EXTENDED_VOLUME_DATA {
    pub ByteCount: u32,
    pub MajorVersion: u16,
    pub MinorVersion: u16,
    pub BytesPerPhysicalSector: u32,
    pub LfsMajorVersion: u16,
    pub LfsMinorVersion: u16,
    pub MaxDeviceTrimExtentCount: u32,
    pub MaxDeviceTrimByteCount: u32,
    pub MaxVolumeTrimExtentCount: u32,
    pub MaxVolumeTrimByteCount: u32,
}
impl ::core::marker::Copy for NTFS_EXTENDED_VOLUME_DATA {}
impl ::core::clone::Clone for NTFS_EXTENDED_VOLUME_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NTFS_EXTENDED_VOLUME_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NTFS_EXTENDED_VOLUME_DATA")
            .field("ByteCount", &self.ByteCount)
            .field("MajorVersion", &self.MajorVersion)
            .field("MinorVersion", &self.MinorVersion)
            .field("BytesPerPhysicalSector", &self.BytesPerPhysicalSector)
            .field("LfsMajorVersion", &self.LfsMajorVersion)
            .field("LfsMinorVersion", &self.LfsMinorVersion)
            .field("MaxDeviceTrimExtentCount", &self.MaxDeviceTrimExtentCount)
            .field("MaxDeviceTrimByteCount", &self.MaxDeviceTrimByteCount)
            .field("MaxVolumeTrimExtentCount", &self.MaxVolumeTrimExtentCount)
            .field("MaxVolumeTrimByteCount", &self.MaxVolumeTrimByteCount)
            .finish()
    }
}
impl ::windows_core::TypeKind for NTFS_EXTENDED_VOLUME_DATA {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NTFS_EXTENDED_VOLUME_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.ByteCount == other.ByteCount && self.MajorVersion == other.MajorVersion && self.MinorVersion == other.MinorVersion && self.BytesPerPhysicalSector == other.BytesPerPhysicalSector && self.LfsMajorVersion == other.LfsMajorVersion && self.LfsMinorVersion == other.LfsMinorVersion && self.MaxDeviceTrimExtentCount == other.MaxDeviceTrimExtentCount && self.MaxDeviceTrimByteCount == other.MaxDeviceTrimByteCount && self.MaxVolumeTrimExtentCount == other.MaxVolumeTrimExtentCount && self.MaxVolumeTrimByteCount == other.MaxVolumeTrimByteCount
    }
}
impl ::core::cmp::Eq for NTFS_EXTENDED_VOLUME_DATA {}
impl ::core::default::Default for NTFS_EXTENDED_VOLUME_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NTFS_FILE_RECORD_INPUT_BUFFER {
    pub FileReferenceNumber: i64,
}
impl ::core::marker::Copy for NTFS_FILE_RECORD_INPUT_BUFFER {}
impl ::core::clone::Clone for NTFS_FILE_RECORD_INPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NTFS_FILE_RECORD_INPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NTFS_FILE_RECORD_INPUT_BUFFER").field("FileReferenceNumber", &self.FileReferenceNumber).finish()
    }
}
impl ::windows_core::TypeKind for NTFS_FILE_RECORD_INPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NTFS_FILE_RECORD_INPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.FileReferenceNumber == other.FileReferenceNumber
    }
}
impl ::core::cmp::Eq for NTFS_FILE_RECORD_INPUT_BUFFER {}
impl ::core::default::Default for NTFS_FILE_RECORD_INPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NTFS_FILE_RECORD_OUTPUT_BUFFER {
    pub FileReferenceNumber: i64,
    pub FileRecordLength: u32,
    pub FileRecordBuffer: [u8; 1],
}
impl ::core::marker::Copy for NTFS_FILE_RECORD_OUTPUT_BUFFER {}
impl ::core::clone::Clone for NTFS_FILE_RECORD_OUTPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NTFS_FILE_RECORD_OUTPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NTFS_FILE_RECORD_OUTPUT_BUFFER").field("FileReferenceNumber", &self.FileReferenceNumber).field("FileRecordLength", &self.FileRecordLength).field("FileRecordBuffer", &self.FileRecordBuffer).finish()
    }
}
impl ::windows_core::TypeKind for NTFS_FILE_RECORD_OUTPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NTFS_FILE_RECORD_OUTPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.FileReferenceNumber == other.FileReferenceNumber && self.FileRecordLength == other.FileRecordLength && self.FileRecordBuffer == other.FileRecordBuffer
    }
}
impl ::core::cmp::Eq for NTFS_FILE_RECORD_OUTPUT_BUFFER {}
impl ::core::default::Default for NTFS_FILE_RECORD_OUTPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NTFS_STATISTICS {
    pub LogFileFullExceptions: u32,
    pub OtherExceptions: u32,
    pub MftReads: u32,
    pub MftReadBytes: u32,
    pub MftWrites: u32,
    pub MftWriteBytes: u32,
    pub MftWritesUserLevel: NTFS_STATISTICS_4,
    pub MftWritesFlushForLogFileFull: u16,
    pub MftWritesLazyWriter: u16,
    pub MftWritesUserRequest: u16,
    pub Mft2Writes: u32,
    pub Mft2WriteBytes: u32,
    pub Mft2WritesUserLevel: NTFS_STATISTICS_2,
    pub Mft2WritesFlushForLogFileFull: u16,
    pub Mft2WritesLazyWriter: u16,
    pub Mft2WritesUserRequest: u16,
    pub RootIndexReads: u32,
    pub RootIndexReadBytes: u32,
    pub RootIndexWrites: u32,
    pub RootIndexWriteBytes: u32,
    pub BitmapReads: u32,
    pub BitmapReadBytes: u32,
    pub BitmapWrites: u32,
    pub BitmapWriteBytes: u32,
    pub BitmapWritesFlushForLogFileFull: u16,
    pub BitmapWritesLazyWriter: u16,
    pub BitmapWritesUserRequest: u16,
    pub BitmapWritesUserLevel: NTFS_STATISTICS_1,
    pub MftBitmapReads: u32,
    pub MftBitmapReadBytes: u32,
    pub MftBitmapWrites: u32,
    pub MftBitmapWriteBytes: u32,
    pub MftBitmapWritesFlushForLogFileFull: u16,
    pub MftBitmapWritesLazyWriter: u16,
    pub MftBitmapWritesUserRequest: u16,
    pub MftBitmapWritesUserLevel: NTFS_STATISTICS_3,
    pub UserIndexReads: u32,
    pub UserIndexReadBytes: u32,
    pub UserIndexWrites: u32,
    pub UserIndexWriteBytes: u32,
    pub LogFileReads: u32,
    pub LogFileReadBytes: u32,
    pub LogFileWrites: u32,
    pub LogFileWriteBytes: u32,
    pub Allocate: NTFS_STATISTICS_0,
    pub DiskResourcesExhausted: u32,
}
impl ::core::marker::Copy for NTFS_STATISTICS {}
impl ::core::clone::Clone for NTFS_STATISTICS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NTFS_STATISTICS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NTFS_STATISTICS")
            .field("LogFileFullExceptions", &self.LogFileFullExceptions)
            .field("OtherExceptions", &self.OtherExceptions)
            .field("MftReads", &self.MftReads)
            .field("MftReadBytes", &self.MftReadBytes)
            .field("MftWrites", &self.MftWrites)
            .field("MftWriteBytes", &self.MftWriteBytes)
            .field("MftWritesUserLevel", &self.MftWritesUserLevel)
            .field("MftWritesFlushForLogFileFull", &self.MftWritesFlushForLogFileFull)
            .field("MftWritesLazyWriter", &self.MftWritesLazyWriter)
            .field("MftWritesUserRequest", &self.MftWritesUserRequest)
            .field("Mft2Writes", &self.Mft2Writes)
            .field("Mft2WriteBytes", &self.Mft2WriteBytes)
            .field("Mft2WritesUserLevel", &self.Mft2WritesUserLevel)
            .field("Mft2WritesFlushForLogFileFull", &self.Mft2WritesFlushForLogFileFull)
            .field("Mft2WritesLazyWriter", &self.Mft2WritesLazyWriter)
            .field("Mft2WritesUserRequest", &self.Mft2WritesUserRequest)
            .field("RootIndexReads", &self.RootIndexReads)
            .field("RootIndexReadBytes", &self.RootIndexReadBytes)
            .field("RootIndexWrites", &self.RootIndexWrites)
            .field("RootIndexWriteBytes", &self.RootIndexWriteBytes)
            .field("BitmapReads", &self.BitmapReads)
            .field("BitmapReadBytes", &self.BitmapReadBytes)
            .field("BitmapWrites", &self.BitmapWrites)
            .field("BitmapWriteBytes", &self.BitmapWriteBytes)
            .field("BitmapWritesFlushForLogFileFull", &self.BitmapWritesFlushForLogFileFull)
            .field("BitmapWritesLazyWriter", &self.BitmapWritesLazyWriter)
            .field("BitmapWritesUserRequest", &self.BitmapWritesUserRequest)
            .field("BitmapWritesUserLevel", &self.BitmapWritesUserLevel)
            .field("MftBitmapReads", &self.MftBitmapReads)
            .field("MftBitmapReadBytes", &self.MftBitmapReadBytes)
            .field("MftBitmapWrites", &self.MftBitmapWrites)
            .field("MftBitmapWriteBytes", &self.MftBitmapWriteBytes)
            .field("MftBitmapWritesFlushForLogFileFull", &self.MftBitmapWritesFlushForLogFileFull)
            .field("MftBitmapWritesLazyWriter", &self.MftBitmapWritesLazyWriter)
            .field("MftBitmapWritesUserRequest", &self.MftBitmapWritesUserRequest)
            .field("MftBitmapWritesUserLevel", &self.MftBitmapWritesUserLevel)
            .field("UserIndexReads", &self.UserIndexReads)
            .field("UserIndexReadBytes", &self.UserIndexReadBytes)
            .field("UserIndexWrites", &self.UserIndexWrites)
            .field("UserIndexWriteBytes", &self.UserIndexWriteBytes)
            .field("LogFileReads", &self.LogFileReads)
            .field("LogFileReadBytes", &self.LogFileReadBytes)
            .field("LogFileWrites", &self.LogFileWrites)
            .field("LogFileWriteBytes", &self.LogFileWriteBytes)
            .field("Allocate", &self.Allocate)
            .field("DiskResourcesExhausted", &self.DiskResourcesExhausted)
            .finish()
    }
}
impl ::windows_core::TypeKind for NTFS_STATISTICS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NTFS_STATISTICS {
    fn eq(&self, other: &Self) -> bool {
        self.LogFileFullExceptions == other.LogFileFullExceptions
            && self.OtherExceptions == other.OtherExceptions
            && self.MftReads == other.MftReads
            && self.MftReadBytes == other.MftReadBytes
            && self.MftWrites == other.MftWrites
            && self.MftWriteBytes == other.MftWriteBytes
            && self.MftWritesUserLevel == other.MftWritesUserLevel
            && self.MftWritesFlushForLogFileFull == other.MftWritesFlushForLogFileFull
            && self.MftWritesLazyWriter == other.MftWritesLazyWriter
            && self.MftWritesUserRequest == other.MftWritesUserRequest
            && self.Mft2Writes == other.Mft2Writes
            && self.Mft2WriteBytes == other.Mft2WriteBytes
            && self.Mft2WritesUserLevel == other.Mft2WritesUserLevel
            && self.Mft2WritesFlushForLogFileFull == other.Mft2WritesFlushForLogFileFull
            && self.Mft2WritesLazyWriter == other.Mft2WritesLazyWriter
            && self.Mft2WritesUserRequest == other.Mft2WritesUserRequest
            && self.RootIndexReads == other.RootIndexReads
            && self.RootIndexReadBytes == other.RootIndexReadBytes
            && self.RootIndexWrites == other.RootIndexWrites
            && self.RootIndexWriteBytes == other.RootIndexWriteBytes
            && self.BitmapReads == other.BitmapReads
            && self.BitmapReadBytes == other.BitmapReadBytes
            && self.BitmapWrites == other.BitmapWrites
            && self.BitmapWriteBytes == other.BitmapWriteBytes
            && self.BitmapWritesFlushForLogFileFull == other.BitmapWritesFlushForLogFileFull
            && self.BitmapWritesLazyWriter == other.BitmapWritesLazyWriter
            && self.BitmapWritesUserRequest == other.BitmapWritesUserRequest
            && self.BitmapWritesUserLevel == other.BitmapWritesUserLevel
            && self.MftBitmapReads == other.MftBitmapReads
            && self.MftBitmapReadBytes == other.MftBitmapReadBytes
            && self.MftBitmapWrites == other.MftBitmapWrites
            && self.MftBitmapWriteBytes == other.MftBitmapWriteBytes
            && self.MftBitmapWritesFlushForLogFileFull == other.MftBitmapWritesFlushForLogFileFull
            && self.MftBitmapWritesLazyWriter == other.MftBitmapWritesLazyWriter
            && self.MftBitmapWritesUserRequest == other.MftBitmapWritesUserRequest
            && self.MftBitmapWritesUserLevel == other.MftBitmapWritesUserLevel
            && self.UserIndexReads == other.UserIndexReads
            && self.UserIndexReadBytes == other.UserIndexReadBytes
            && self.UserIndexWrites == other.UserIndexWrites
            && self.UserIndexWriteBytes == other.UserIndexWriteBytes
            && self.LogFileReads == other.LogFileReads
            && self.LogFileReadBytes == other.LogFileReadBytes
            && self.LogFileWrites == other.LogFileWrites
            && self.LogFileWriteBytes == other.LogFileWriteBytes
            && self.Allocate == other.Allocate
            && self.DiskResourcesExhausted == other.DiskResourcesExhausted
    }
}
impl ::core::cmp::Eq for NTFS_STATISTICS {}
impl ::core::default::Default for NTFS_STATISTICS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NTFS_STATISTICS_0 {
    pub Calls: u32,
    pub Clusters: u32,
    pub Hints: u32,
    pub RunsReturned: u32,
    pub HintsHonored: u32,
    pub HintsClusters: u32,
    pub Cache: u32,
    pub CacheClusters: u32,
    pub CacheMiss: u32,
    pub CacheMissClusters: u32,
}
impl ::core::marker::Copy for NTFS_STATISTICS_0 {}
impl ::core::clone::Clone for NTFS_STATISTICS_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NTFS_STATISTICS_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NTFS_STATISTICS_0").field("Calls", &self.Calls).field("Clusters", &self.Clusters).field("Hints", &self.Hints).field("RunsReturned", &self.RunsReturned).field("HintsHonored", &self.HintsHonored).field("HintsClusters", &self.HintsClusters).field("Cache", &self.Cache).field("CacheClusters", &self.CacheClusters).field("CacheMiss", &self.CacheMiss).field("CacheMissClusters", &self.CacheMissClusters).finish()
    }
}
impl ::windows_core::TypeKind for NTFS_STATISTICS_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NTFS_STATISTICS_0 {
    fn eq(&self, other: &Self) -> bool {
        self.Calls == other.Calls && self.Clusters == other.Clusters && self.Hints == other.Hints && self.RunsReturned == other.RunsReturned && self.HintsHonored == other.HintsHonored && self.HintsClusters == other.HintsClusters && self.Cache == other.Cache && self.CacheClusters == other.CacheClusters && self.CacheMiss == other.CacheMiss && self.CacheMissClusters == other.CacheMissClusters
    }
}
impl ::core::cmp::Eq for NTFS_STATISTICS_0 {}
impl ::core::default::Default for NTFS_STATISTICS_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NTFS_STATISTICS_1 {
    pub Write: u16,
    pub Create: u16,
    pub SetInfo: u16,
}
impl ::core::marker::Copy for NTFS_STATISTICS_1 {}
impl ::core::clone::Clone for NTFS_STATISTICS_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NTFS_STATISTICS_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NTFS_STATISTICS_1").field("Write", &self.Write).field("Create", &self.Create).field("SetInfo", &self.SetInfo).finish()
    }
}
impl ::windows_core::TypeKind for NTFS_STATISTICS_1 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NTFS_STATISTICS_1 {
    fn eq(&self, other: &Self) -> bool {
        self.Write == other.Write && self.Create == other.Create && self.SetInfo == other.SetInfo
    }
}
impl ::core::cmp::Eq for NTFS_STATISTICS_1 {}
impl ::core::default::Default for NTFS_STATISTICS_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NTFS_STATISTICS_2 {
    pub Write: u16,
    pub Create: u16,
    pub SetInfo: u16,
    pub Flush: u16,
}
impl ::core::marker::Copy for NTFS_STATISTICS_2 {}
impl ::core::clone::Clone for NTFS_STATISTICS_2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NTFS_STATISTICS_2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NTFS_STATISTICS_2").field("Write", &self.Write).field("Create", &self.Create).field("SetInfo", &self.SetInfo).field("Flush", &self.Flush).finish()
    }
}
impl ::windows_core::TypeKind for NTFS_STATISTICS_2 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NTFS_STATISTICS_2 {
    fn eq(&self, other: &Self) -> bool {
        self.Write == other.Write && self.Create == other.Create && self.SetInfo == other.SetInfo && self.Flush == other.Flush
    }
}
impl ::core::cmp::Eq for NTFS_STATISTICS_2 {}
impl ::core::default::Default for NTFS_STATISTICS_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NTFS_STATISTICS_3 {
    pub Write: u16,
    pub Create: u16,
    pub SetInfo: u16,
    pub Flush: u16,
}
impl ::core::marker::Copy for NTFS_STATISTICS_3 {}
impl ::core::clone::Clone for NTFS_STATISTICS_3 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NTFS_STATISTICS_3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NTFS_STATISTICS_3").field("Write", &self.Write).field("Create", &self.Create).field("SetInfo", &self.SetInfo).field("Flush", &self.Flush).finish()
    }
}
impl ::windows_core::TypeKind for NTFS_STATISTICS_3 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NTFS_STATISTICS_3 {
    fn eq(&self, other: &Self) -> bool {
        self.Write == other.Write && self.Create == other.Create && self.SetInfo == other.SetInfo && self.Flush == other.Flush
    }
}
impl ::core::cmp::Eq for NTFS_STATISTICS_3 {}
impl ::core::default::Default for NTFS_STATISTICS_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NTFS_STATISTICS_4 {
    pub Write: u16,
    pub Create: u16,
    pub SetInfo: u16,
    pub Flush: u16,
}
impl ::core::marker::Copy for NTFS_STATISTICS_4 {}
impl ::core::clone::Clone for NTFS_STATISTICS_4 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NTFS_STATISTICS_4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NTFS_STATISTICS_4").field("Write", &self.Write).field("Create", &self.Create).field("SetInfo", &self.SetInfo).field("Flush", &self.Flush).finish()
    }
}
impl ::windows_core::TypeKind for NTFS_STATISTICS_4 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NTFS_STATISTICS_4 {
    fn eq(&self, other: &Self) -> bool {
        self.Write == other.Write && self.Create == other.Create && self.SetInfo == other.SetInfo && self.Flush == other.Flush
    }
}
impl ::core::cmp::Eq for NTFS_STATISTICS_4 {}
impl ::core::default::Default for NTFS_STATISTICS_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NTFS_STATISTICS_EX {
    pub LogFileFullExceptions: u32,
    pub OtherExceptions: u32,
    pub MftReads: u64,
    pub MftReadBytes: u64,
    pub MftWrites: u64,
    pub MftWriteBytes: u64,
    pub MftWritesUserLevel: NTFS_STATISTICS_EX_4,
    pub MftWritesFlushForLogFileFull: u32,
    pub MftWritesLazyWriter: u32,
    pub MftWritesUserRequest: u32,
    pub Mft2Writes: u64,
    pub Mft2WriteBytes: u64,
    pub Mft2WritesUserLevel: NTFS_STATISTICS_EX_2,
    pub Mft2WritesFlushForLogFileFull: u32,
    pub Mft2WritesLazyWriter: u32,
    pub Mft2WritesUserRequest: u32,
    pub RootIndexReads: u64,
    pub RootIndexReadBytes: u64,
    pub RootIndexWrites: u64,
    pub RootIndexWriteBytes: u64,
    pub BitmapReads: u64,
    pub BitmapReadBytes: u64,
    pub BitmapWrites: u64,
    pub BitmapWriteBytes: u64,
    pub BitmapWritesFlushForLogFileFull: u32,
    pub BitmapWritesLazyWriter: u32,
    pub BitmapWritesUserRequest: u32,
    pub BitmapWritesUserLevel: NTFS_STATISTICS_EX_1,
    pub MftBitmapReads: u64,
    pub MftBitmapReadBytes: u64,
    pub MftBitmapWrites: u64,
    pub MftBitmapWriteBytes: u64,
    pub MftBitmapWritesFlushForLogFileFull: u32,
    pub MftBitmapWritesLazyWriter: u32,
    pub MftBitmapWritesUserRequest: u32,
    pub MftBitmapWritesUserLevel: NTFS_STATISTICS_EX_3,
    pub UserIndexReads: u64,
    pub UserIndexReadBytes: u64,
    pub UserIndexWrites: u64,
    pub UserIndexWriteBytes: u64,
    pub LogFileReads: u64,
    pub LogFileReadBytes: u64,
    pub LogFileWrites: u64,
    pub LogFileWriteBytes: u64,
    pub Allocate: NTFS_STATISTICS_EX_0,
    pub DiskResourcesExhausted: u32,
    pub VolumeTrimCount: u64,
    pub VolumeTrimTime: u64,
    pub VolumeTrimByteCount: u64,
    pub FileLevelTrimCount: u64,
    pub FileLevelTrimTime: u64,
    pub FileLevelTrimByteCount: u64,
    pub VolumeTrimSkippedCount: u64,
    pub VolumeTrimSkippedByteCount: u64,
    pub NtfsFillStatInfoFromMftRecordCalledCount: u64,
    pub NtfsFillStatInfoFromMftRecordBailedBecauseOfAttributeListCount: u64,
    pub NtfsFillStatInfoFromMftRecordBailedBecauseOfNonResReparsePointCount: u64,
}
impl ::core::marker::Copy for NTFS_STATISTICS_EX {}
impl ::core::clone::Clone for NTFS_STATISTICS_EX {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NTFS_STATISTICS_EX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NTFS_STATISTICS_EX")
            .field("LogFileFullExceptions", &self.LogFileFullExceptions)
            .field("OtherExceptions", &self.OtherExceptions)
            .field("MftReads", &self.MftReads)
            .field("MftReadBytes", &self.MftReadBytes)
            .field("MftWrites", &self.MftWrites)
            .field("MftWriteBytes", &self.MftWriteBytes)
            .field("MftWritesUserLevel", &self.MftWritesUserLevel)
            .field("MftWritesFlushForLogFileFull", &self.MftWritesFlushForLogFileFull)
            .field("MftWritesLazyWriter", &self.MftWritesLazyWriter)
            .field("MftWritesUserRequest", &self.MftWritesUserRequest)
            .field("Mft2Writes", &self.Mft2Writes)
            .field("Mft2WriteBytes", &self.Mft2WriteBytes)
            .field("Mft2WritesUserLevel", &self.Mft2WritesUserLevel)
            .field("Mft2WritesFlushForLogFileFull", &self.Mft2WritesFlushForLogFileFull)
            .field("Mft2WritesLazyWriter", &self.Mft2WritesLazyWriter)
            .field("Mft2WritesUserRequest", &self.Mft2WritesUserRequest)
            .field("RootIndexReads", &self.RootIndexReads)
            .field("RootIndexReadBytes", &self.RootIndexReadBytes)
            .field("RootIndexWrites", &self.RootIndexWrites)
            .field("RootIndexWriteBytes", &self.RootIndexWriteBytes)
            .field("BitmapReads", &self.BitmapReads)
            .field("BitmapReadBytes", &self.BitmapReadBytes)
            .field("BitmapWrites", &self.BitmapWrites)
            .field("BitmapWriteBytes", &self.BitmapWriteBytes)
            .field("BitmapWritesFlushForLogFileFull", &self.BitmapWritesFlushForLogFileFull)
            .field("BitmapWritesLazyWriter", &self.BitmapWritesLazyWriter)
            .field("BitmapWritesUserRequest", &self.BitmapWritesUserRequest)
            .field("BitmapWritesUserLevel", &self.BitmapWritesUserLevel)
            .field("MftBitmapReads", &self.MftBitmapReads)
            .field("MftBitmapReadBytes", &self.MftBitmapReadBytes)
            .field("MftBitmapWrites", &self.MftBitmapWrites)
            .field("MftBitmapWriteBytes", &self.MftBitmapWriteBytes)
            .field("MftBitmapWritesFlushForLogFileFull", &self.MftBitmapWritesFlushForLogFileFull)
            .field("MftBitmapWritesLazyWriter", &self.MftBitmapWritesLazyWriter)
            .field("MftBitmapWritesUserRequest", &self.MftBitmapWritesUserRequest)
            .field("MftBitmapWritesUserLevel", &self.MftBitmapWritesUserLevel)
            .field("UserIndexReads", &self.UserIndexReads)
            .field("UserIndexReadBytes", &self.UserIndexReadBytes)
            .field("UserIndexWrites", &self.UserIndexWrites)
            .field("UserIndexWriteBytes", &self.UserIndexWriteBytes)
            .field("LogFileReads", &self.LogFileReads)
            .field("LogFileReadBytes", &self.LogFileReadBytes)
            .field("LogFileWrites", &self.LogFileWrites)
            .field("LogFileWriteBytes", &self.LogFileWriteBytes)
            .field("Allocate", &self.Allocate)
            .field("DiskResourcesExhausted", &self.DiskResourcesExhausted)
            .field("VolumeTrimCount", &self.VolumeTrimCount)
            .field("VolumeTrimTime", &self.VolumeTrimTime)
            .field("VolumeTrimByteCount", &self.VolumeTrimByteCount)
            .field("FileLevelTrimCount", &self.FileLevelTrimCount)
            .field("FileLevelTrimTime", &self.FileLevelTrimTime)
            .field("FileLevelTrimByteCount", &self.FileLevelTrimByteCount)
            .field("VolumeTrimSkippedCount", &self.VolumeTrimSkippedCount)
            .field("VolumeTrimSkippedByteCount", &self.VolumeTrimSkippedByteCount)
            .field("NtfsFillStatInfoFromMftRecordCalledCount", &self.NtfsFillStatInfoFromMftRecordCalledCount)
            .field("NtfsFillStatInfoFromMftRecordBailedBecauseOfAttributeListCount", &self.NtfsFillStatInfoFromMftRecordBailedBecauseOfAttributeListCount)
            .field("NtfsFillStatInfoFromMftRecordBailedBecauseOfNonResReparsePointCount", &self.NtfsFillStatInfoFromMftRecordBailedBecauseOfNonResReparsePointCount)
            .finish()
    }
}
impl ::windows_core::TypeKind for NTFS_STATISTICS_EX {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NTFS_STATISTICS_EX {
    fn eq(&self, other: &Self) -> bool {
        self.LogFileFullExceptions == other.LogFileFullExceptions
            && self.OtherExceptions == other.OtherExceptions
            && self.MftReads == other.MftReads
            && self.MftReadBytes == other.MftReadBytes
            && self.MftWrites == other.MftWrites
            && self.MftWriteBytes == other.MftWriteBytes
            && self.MftWritesUserLevel == other.MftWritesUserLevel
            && self.MftWritesFlushForLogFileFull == other.MftWritesFlushForLogFileFull
            && self.MftWritesLazyWriter == other.MftWritesLazyWriter
            && self.MftWritesUserRequest == other.MftWritesUserRequest
            && self.Mft2Writes == other.Mft2Writes
            && self.Mft2WriteBytes == other.Mft2WriteBytes
            && self.Mft2WritesUserLevel == other.Mft2WritesUserLevel
            && self.Mft2WritesFlushForLogFileFull == other.Mft2WritesFlushForLogFileFull
            && self.Mft2WritesLazyWriter == other.Mft2WritesLazyWriter
            && self.Mft2WritesUserRequest == other.Mft2WritesUserRequest
            && self.RootIndexReads == other.RootIndexReads
            && self.RootIndexReadBytes == other.RootIndexReadBytes
            && self.RootIndexWrites == other.RootIndexWrites
            && self.RootIndexWriteBytes == other.RootIndexWriteBytes
            && self.BitmapReads == other.BitmapReads
            && self.BitmapReadBytes == other.BitmapReadBytes
            && self.BitmapWrites == other.BitmapWrites
            && self.BitmapWriteBytes == other.BitmapWriteBytes
            && self.BitmapWritesFlushForLogFileFull == other.BitmapWritesFlushForLogFileFull
            && self.BitmapWritesLazyWriter == other.BitmapWritesLazyWriter
            && self.BitmapWritesUserRequest == other.BitmapWritesUserRequest
            && self.BitmapWritesUserLevel == other.BitmapWritesUserLevel
            && self.MftBitmapReads == other.MftBitmapReads
            && self.MftBitmapReadBytes == other.MftBitmapReadBytes
            && self.MftBitmapWrites == other.MftBitmapWrites
            && self.MftBitmapWriteBytes == other.MftBitmapWriteBytes
            && self.MftBitmapWritesFlushForLogFileFull == other.MftBitmapWritesFlushForLogFileFull
            && self.MftBitmapWritesLazyWriter == other.MftBitmapWritesLazyWriter
            && self.MftBitmapWritesUserRequest == other.MftBitmapWritesUserRequest
            && self.MftBitmapWritesUserLevel == other.MftBitmapWritesUserLevel
            && self.UserIndexReads == other.UserIndexReads
            && self.UserIndexReadBytes == other.UserIndexReadBytes
            && self.UserIndexWrites == other.UserIndexWrites
            && self.UserIndexWriteBytes == other.UserIndexWriteBytes
            && self.LogFileReads == other.LogFileReads
            && self.LogFileReadBytes == other.LogFileReadBytes
            && self.LogFileWrites == other.LogFileWrites
            && self.LogFileWriteBytes == other.LogFileWriteBytes
            && self.Allocate == other.Allocate
            && self.DiskResourcesExhausted == other.DiskResourcesExhausted
            && self.VolumeTrimCount == other.VolumeTrimCount
            && self.VolumeTrimTime == other.VolumeTrimTime
            && self.VolumeTrimByteCount == other.VolumeTrimByteCount
            && self.FileLevelTrimCount == other.FileLevelTrimCount
            && self.FileLevelTrimTime == other.FileLevelTrimTime
            && self.FileLevelTrimByteCount == other.FileLevelTrimByteCount
            && self.VolumeTrimSkippedCount == other.VolumeTrimSkippedCount
            && self.VolumeTrimSkippedByteCount == other.VolumeTrimSkippedByteCount
            && self.NtfsFillStatInfoFromMftRecordCalledCount == other.NtfsFillStatInfoFromMftRecordCalledCount
            && self.NtfsFillStatInfoFromMftRecordBailedBecauseOfAttributeListCount == other.NtfsFillStatInfoFromMftRecordBailedBecauseOfAttributeListCount
            && self.NtfsFillStatInfoFromMftRecordBailedBecauseOfNonResReparsePointCount == other.NtfsFillStatInfoFromMftRecordBailedBecauseOfNonResReparsePointCount
    }
}
impl ::core::cmp::Eq for NTFS_STATISTICS_EX {}
impl ::core::default::Default for NTFS_STATISTICS_EX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NTFS_STATISTICS_EX_0 {
    pub Calls: u32,
    pub RunsReturned: u32,
    pub Hints: u32,
    pub HintsHonored: u32,
    pub Cache: u32,
    pub CacheMiss: u32,
    pub Clusters: u64,
    pub HintsClusters: u64,
    pub CacheClusters: u64,
    pub CacheMissClusters: u64,
}
impl ::core::marker::Copy for NTFS_STATISTICS_EX_0 {}
impl ::core::clone::Clone for NTFS_STATISTICS_EX_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NTFS_STATISTICS_EX_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NTFS_STATISTICS_EX_0").field("Calls", &self.Calls).field("RunsReturned", &self.RunsReturned).field("Hints", &self.Hints).field("HintsHonored", &self.HintsHonored).field("Cache", &self.Cache).field("CacheMiss", &self.CacheMiss).field("Clusters", &self.Clusters).field("HintsClusters", &self.HintsClusters).field("CacheClusters", &self.CacheClusters).field("CacheMissClusters", &self.CacheMissClusters).finish()
    }
}
impl ::windows_core::TypeKind for NTFS_STATISTICS_EX_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NTFS_STATISTICS_EX_0 {
    fn eq(&self, other: &Self) -> bool {
        self.Calls == other.Calls && self.RunsReturned == other.RunsReturned && self.Hints == other.Hints && self.HintsHonored == other.HintsHonored && self.Cache == other.Cache && self.CacheMiss == other.CacheMiss && self.Clusters == other.Clusters && self.HintsClusters == other.HintsClusters && self.CacheClusters == other.CacheClusters && self.CacheMissClusters == other.CacheMissClusters
    }
}
impl ::core::cmp::Eq for NTFS_STATISTICS_EX_0 {}
impl ::core::default::Default for NTFS_STATISTICS_EX_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NTFS_STATISTICS_EX_1 {
    pub Write: u32,
    pub Create: u32,
    pub SetInfo: u32,
    pub Flush: u32,
}
impl ::core::marker::Copy for NTFS_STATISTICS_EX_1 {}
impl ::core::clone::Clone for NTFS_STATISTICS_EX_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NTFS_STATISTICS_EX_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NTFS_STATISTICS_EX_1").field("Write", &self.Write).field("Create", &self.Create).field("SetInfo", &self.SetInfo).field("Flush", &self.Flush).finish()
    }
}
impl ::windows_core::TypeKind for NTFS_STATISTICS_EX_1 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NTFS_STATISTICS_EX_1 {
    fn eq(&self, other: &Self) -> bool {
        self.Write == other.Write && self.Create == other.Create && self.SetInfo == other.SetInfo && self.Flush == other.Flush
    }
}
impl ::core::cmp::Eq for NTFS_STATISTICS_EX_1 {}
impl ::core::default::Default for NTFS_STATISTICS_EX_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NTFS_STATISTICS_EX_2 {
    pub Write: u32,
    pub Create: u32,
    pub SetInfo: u32,
    pub Flush: u32,
}
impl ::core::marker::Copy for NTFS_STATISTICS_EX_2 {}
impl ::core::clone::Clone for NTFS_STATISTICS_EX_2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NTFS_STATISTICS_EX_2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NTFS_STATISTICS_EX_2").field("Write", &self.Write).field("Create", &self.Create).field("SetInfo", &self.SetInfo).field("Flush", &self.Flush).finish()
    }
}
impl ::windows_core::TypeKind for NTFS_STATISTICS_EX_2 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NTFS_STATISTICS_EX_2 {
    fn eq(&self, other: &Self) -> bool {
        self.Write == other.Write && self.Create == other.Create && self.SetInfo == other.SetInfo && self.Flush == other.Flush
    }
}
impl ::core::cmp::Eq for NTFS_STATISTICS_EX_2 {}
impl ::core::default::Default for NTFS_STATISTICS_EX_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NTFS_STATISTICS_EX_3 {
    pub Write: u32,
    pub Create: u32,
    pub SetInfo: u32,
    pub Flush: u32,
}
impl ::core::marker::Copy for NTFS_STATISTICS_EX_3 {}
impl ::core::clone::Clone for NTFS_STATISTICS_EX_3 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NTFS_STATISTICS_EX_3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NTFS_STATISTICS_EX_3").field("Write", &self.Write).field("Create", &self.Create).field("SetInfo", &self.SetInfo).field("Flush", &self.Flush).finish()
    }
}
impl ::windows_core::TypeKind for NTFS_STATISTICS_EX_3 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NTFS_STATISTICS_EX_3 {
    fn eq(&self, other: &Self) -> bool {
        self.Write == other.Write && self.Create == other.Create && self.SetInfo == other.SetInfo && self.Flush == other.Flush
    }
}
impl ::core::cmp::Eq for NTFS_STATISTICS_EX_3 {}
impl ::core::default::Default for NTFS_STATISTICS_EX_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NTFS_STATISTICS_EX_4 {
    pub Write: u32,
    pub Create: u32,
    pub SetInfo: u32,
    pub Flush: u32,
}
impl ::core::marker::Copy for NTFS_STATISTICS_EX_4 {}
impl ::core::clone::Clone for NTFS_STATISTICS_EX_4 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NTFS_STATISTICS_EX_4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NTFS_STATISTICS_EX_4").field("Write", &self.Write).field("Create", &self.Create).field("SetInfo", &self.SetInfo).field("Flush", &self.Flush).finish()
    }
}
impl ::windows_core::TypeKind for NTFS_STATISTICS_EX_4 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NTFS_STATISTICS_EX_4 {
    fn eq(&self, other: &Self) -> bool {
        self.Write == other.Write && self.Create == other.Create && self.SetInfo == other.SetInfo && self.Flush == other.Flush
    }
}
impl ::core::cmp::Eq for NTFS_STATISTICS_EX_4 {}
impl ::core::default::Default for NTFS_STATISTICS_EX_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct NTFS_VOLUME_DATA_BUFFER {
    pub VolumeSerialNumber: i64,
    pub NumberSectors: i64,
    pub TotalClusters: i64,
    pub FreeClusters: i64,
    pub TotalReserved: i64,
    pub BytesPerSector: u32,
    pub BytesPerCluster: u32,
    pub BytesPerFileRecordSegment: u32,
    pub ClustersPerFileRecordSegment: u32,
    pub MftValidDataLength: i64,
    pub MftStartLcn: i64,
    pub Mft2StartLcn: i64,
    pub MftZoneStart: i64,
    pub MftZoneEnd: i64,
}
impl ::core::marker::Copy for NTFS_VOLUME_DATA_BUFFER {}
impl ::core::clone::Clone for NTFS_VOLUME_DATA_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for NTFS_VOLUME_DATA_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("NTFS_VOLUME_DATA_BUFFER")
            .field("VolumeSerialNumber", &self.VolumeSerialNumber)
            .field("NumberSectors", &self.NumberSectors)
            .field("TotalClusters", &self.TotalClusters)
            .field("FreeClusters", &self.FreeClusters)
            .field("TotalReserved", &self.TotalReserved)
            .field("BytesPerSector", &self.BytesPerSector)
            .field("BytesPerCluster", &self.BytesPerCluster)
            .field("BytesPerFileRecordSegment", &self.BytesPerFileRecordSegment)
            .field("ClustersPerFileRecordSegment", &self.ClustersPerFileRecordSegment)
            .field("MftValidDataLength", &self.MftValidDataLength)
            .field("MftStartLcn", &self.MftStartLcn)
            .field("Mft2StartLcn", &self.Mft2StartLcn)
            .field("MftZoneStart", &self.MftZoneStart)
            .field("MftZoneEnd", &self.MftZoneEnd)
            .finish()
    }
}
impl ::windows_core::TypeKind for NTFS_VOLUME_DATA_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for NTFS_VOLUME_DATA_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.VolumeSerialNumber == other.VolumeSerialNumber && self.NumberSectors == other.NumberSectors && self.TotalClusters == other.TotalClusters && self.FreeClusters == other.FreeClusters && self.TotalReserved == other.TotalReserved && self.BytesPerSector == other.BytesPerSector && self.BytesPerCluster == other.BytesPerCluster && self.BytesPerFileRecordSegment == other.BytesPerFileRecordSegment && self.ClustersPerFileRecordSegment == other.ClustersPerFileRecordSegment && self.MftValidDataLength == other.MftValidDataLength && self.MftStartLcn == other.MftStartLcn && self.Mft2StartLcn == other.Mft2StartLcn && self.MftZoneStart == other.MftZoneStart && self.MftZoneEnd == other.MftZoneEnd
    }
}
impl ::core::cmp::Eq for NTFS_VOLUME_DATA_BUFFER {}
impl ::core::default::Default for NTFS_VOLUME_DATA_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct OBJECT_TYPE_LIST {
    pub Level: u16,
    pub Sbz: u16,
    pub ObjectType: *mut ::windows_core::GUID,
}
impl ::core::marker::Copy for OBJECT_TYPE_LIST {}
impl ::core::clone::Clone for OBJECT_TYPE_LIST {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for OBJECT_TYPE_LIST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("OBJECT_TYPE_LIST").field("Level", &self.Level).field("Sbz", &self.Sbz).field("ObjectType", &self.ObjectType).finish()
    }
}
impl ::windows_core::TypeKind for OBJECT_TYPE_LIST {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for OBJECT_TYPE_LIST {
    fn eq(&self, other: &Self) -> bool {
        self.Level == other.Level && self.Sbz == other.Sbz && self.ObjectType == other.ObjectType
    }
}
impl ::core::cmp::Eq for OBJECT_TYPE_LIST {}
impl ::core::default::Default for OBJECT_TYPE_LIST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(feature = "Win32_System_Kernel")]
pub struct OPEN_REPARSE_LIST {
    pub OpenReparseList: super::super::super::Win32::System::Kernel::LIST_ENTRY,
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::core::marker::Copy for OPEN_REPARSE_LIST {}
#[cfg(feature = "Win32_System_Kernel")]
impl ::core::clone::Clone for OPEN_REPARSE_LIST {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::core::fmt::Debug for OPEN_REPARSE_LIST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("OPEN_REPARSE_LIST").field("OpenReparseList", &self.OpenReparseList).finish()
    }
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::windows_core::TypeKind for OPEN_REPARSE_LIST {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::core::cmp::PartialEq for OPEN_REPARSE_LIST {
    fn eq(&self, other: &Self) -> bool {
        self.OpenReparseList == other.OpenReparseList
    }
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::core::cmp::Eq for OPEN_REPARSE_LIST {}
#[cfg(feature = "Win32_System_Kernel")]
impl ::core::default::Default for OPEN_REPARSE_LIST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(feature = "Win32_System_Kernel")]
pub struct OPEN_REPARSE_LIST_ENTRY {
    pub OpenReparseListEntry: super::super::super::Win32::System::Kernel::LIST_ENTRY,
    pub ReparseTag: u32,
    pub Flags: u32,
    pub ReparseGuid: ::windows_core::GUID,
    pub Size: u16,
    pub RemainingLength: u16,
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::core::marker::Copy for OPEN_REPARSE_LIST_ENTRY {}
#[cfg(feature = "Win32_System_Kernel")]
impl ::core::clone::Clone for OPEN_REPARSE_LIST_ENTRY {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::core::fmt::Debug for OPEN_REPARSE_LIST_ENTRY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("OPEN_REPARSE_LIST_ENTRY").field("OpenReparseListEntry", &self.OpenReparseListEntry).field("ReparseTag", &self.ReparseTag).field("Flags", &self.Flags).field("ReparseGuid", &self.ReparseGuid).field("Size", &self.Size).field("RemainingLength", &self.RemainingLength).finish()
    }
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::windows_core::TypeKind for OPEN_REPARSE_LIST_ENTRY {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::core::cmp::PartialEq for OPEN_REPARSE_LIST_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.OpenReparseListEntry == other.OpenReparseListEntry && self.ReparseTag == other.ReparseTag && self.Flags == other.Flags && self.ReparseGuid == other.ReparseGuid && self.Size == other.Size && self.RemainingLength == other.RemainingLength
    }
}
#[cfg(feature = "Win32_System_Kernel")]
impl ::core::cmp::Eq for OPEN_REPARSE_LIST_ENTRY {}
#[cfg(feature = "Win32_System_Kernel")]
impl ::core::default::Default for OPEN_REPARSE_LIST_ENTRY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct OPLOCK_KEY_CONTEXT {
    pub Version: u16,
    pub Flags: u16,
    pub ParentOplockKey: ::windows_core::GUID,
    pub TargetOplockKey: ::windows_core::GUID,
    pub Reserved: u32,
}
impl ::core::marker::Copy for OPLOCK_KEY_CONTEXT {}
impl ::core::clone::Clone for OPLOCK_KEY_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for OPLOCK_KEY_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("OPLOCK_KEY_CONTEXT").field("Version", &self.Version).field("Flags", &self.Flags).field("ParentOplockKey", &self.ParentOplockKey).field("TargetOplockKey", &self.TargetOplockKey).field("Reserved", &self.Reserved).finish()
    }
}
impl ::windows_core::TypeKind for OPLOCK_KEY_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for OPLOCK_KEY_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Flags == other.Flags && self.ParentOplockKey == other.ParentOplockKey && self.TargetOplockKey == other.TargetOplockKey && self.Reserved == other.Reserved
    }
}
impl ::core::cmp::Eq for OPLOCK_KEY_CONTEXT {}
impl ::core::default::Default for OPLOCK_KEY_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct OPLOCK_KEY_ECP_CONTEXT {
    pub OplockKey: ::windows_core::GUID,
    pub Reserved: u32,
}
impl ::core::marker::Copy for OPLOCK_KEY_ECP_CONTEXT {}
impl ::core::clone::Clone for OPLOCK_KEY_ECP_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for OPLOCK_KEY_ECP_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("OPLOCK_KEY_ECP_CONTEXT").field("OplockKey", &self.OplockKey).field("Reserved", &self.Reserved).finish()
    }
}
impl ::windows_core::TypeKind for OPLOCK_KEY_ECP_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for OPLOCK_KEY_ECP_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.OplockKey == other.OplockKey && self.Reserved == other.Reserved
    }
}
impl ::core::cmp::Eq for OPLOCK_KEY_ECP_CONTEXT {}
impl ::core::default::Default for OPLOCK_KEY_ECP_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub struct OPLOCK_NOTIFY_PARAMS {
    pub NotifyReason: OPLOCK_NOTIFY_REASON,
    pub NotifyContext: *mut ::core::ffi::c_void,
    pub Irp: *mut super::super::Foundation::IRP,
    pub Status: super::super::super::Win32::Foundation::NTSTATUS,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::marker::Copy for OPLOCK_NOTIFY_PARAMS {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::clone::Clone for OPLOCK_NOTIFY_PARAMS {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::fmt::Debug for OPLOCK_NOTIFY_PARAMS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("OPLOCK_NOTIFY_PARAMS").field("NotifyReason", &self.NotifyReason).field("NotifyContext", &self.NotifyContext).field("Irp", &self.Irp).field("Status", &self.Status).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::windows_core::TypeKind for OPLOCK_NOTIFY_PARAMS {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::cmp::PartialEq for OPLOCK_NOTIFY_PARAMS {
    fn eq(&self, other: &Self) -> bool {
        self.NotifyReason == other.NotifyReason && self.NotifyContext == other.NotifyContext && self.Irp == other.Irp && self.Status == other.Status
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::cmp::Eq for OPLOCK_NOTIFY_PARAMS {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::default::Default for OPLOCK_NOTIFY_PARAMS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct PATHNAME_BUFFER {
    pub PathNameLength: u32,
    pub Name: [u16; 1],
}
impl ::core::marker::Copy for PATHNAME_BUFFER {}
impl ::core::clone::Clone for PATHNAME_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for PATHNAME_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PATHNAME_BUFFER").field("PathNameLength", &self.PathNameLength).field("Name", &self.Name).finish()
    }
}
impl ::windows_core::TypeKind for PATHNAME_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for PATHNAME_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.PathNameLength == other.PathNameLength && self.Name == other.Name
    }
}
impl ::core::cmp::Eq for PATHNAME_BUFFER {}
impl ::core::default::Default for PATHNAME_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct PHYSICAL_EXTENTS_DESCRIPTOR {
    pub NumberOfRuns: u32,
    pub NumberOfValidRuns: u32,
    pub Run: [PHYSICAL_MEMORY_RUN; 1],
}
impl ::core::marker::Copy for PHYSICAL_EXTENTS_DESCRIPTOR {}
impl ::core::clone::Clone for PHYSICAL_EXTENTS_DESCRIPTOR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for PHYSICAL_EXTENTS_DESCRIPTOR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PHYSICAL_EXTENTS_DESCRIPTOR").field("NumberOfRuns", &self.NumberOfRuns).field("NumberOfValidRuns", &self.NumberOfValidRuns).field("Run", &self.Run).finish()
    }
}
impl ::windows_core::TypeKind for PHYSICAL_EXTENTS_DESCRIPTOR {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for PHYSICAL_EXTENTS_DESCRIPTOR {
    fn eq(&self, other: &Self) -> bool {
        self.NumberOfRuns == other.NumberOfRuns && self.NumberOfValidRuns == other.NumberOfValidRuns && self.Run == other.Run
    }
}
impl ::core::cmp::Eq for PHYSICAL_EXTENTS_DESCRIPTOR {}
impl ::core::default::Default for PHYSICAL_EXTENTS_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct PHYSICAL_MEMORY_DESCRIPTOR {
    pub NumberOfRuns: u32,
    pub NumberOfPages: u32,
    pub Run: [PHYSICAL_MEMORY_RUN; 1],
}
impl ::core::marker::Copy for PHYSICAL_MEMORY_DESCRIPTOR {}
impl ::core::clone::Clone for PHYSICAL_MEMORY_DESCRIPTOR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for PHYSICAL_MEMORY_DESCRIPTOR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PHYSICAL_MEMORY_DESCRIPTOR").field("NumberOfRuns", &self.NumberOfRuns).field("NumberOfPages", &self.NumberOfPages).field("Run", &self.Run).finish()
    }
}
impl ::windows_core::TypeKind for PHYSICAL_MEMORY_DESCRIPTOR {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for PHYSICAL_MEMORY_DESCRIPTOR {
    fn eq(&self, other: &Self) -> bool {
        self.NumberOfRuns == other.NumberOfRuns && self.NumberOfPages == other.NumberOfPages && self.Run == other.Run
    }
}
impl ::core::cmp::Eq for PHYSICAL_MEMORY_DESCRIPTOR {}
impl ::core::default::Default for PHYSICAL_MEMORY_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct PHYSICAL_MEMORY_RUN {
    pub BasePage: u32,
    pub PageCount: u32,
}
impl ::core::marker::Copy for PHYSICAL_MEMORY_RUN {}
impl ::core::clone::Clone for PHYSICAL_MEMORY_RUN {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for PHYSICAL_MEMORY_RUN {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PHYSICAL_MEMORY_RUN").field("BasePage", &self.BasePage).field("PageCount", &self.PageCount).finish()
    }
}
impl ::windows_core::TypeKind for PHYSICAL_MEMORY_RUN {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for PHYSICAL_MEMORY_RUN {
    fn eq(&self, other: &Self) -> bool {
        self.BasePage == other.BasePage && self.PageCount == other.PageCount
    }
}
impl ::core::cmp::Eq for PHYSICAL_MEMORY_RUN {}
impl ::core::default::Default for PHYSICAL_MEMORY_RUN {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct PLEX_READ_DATA_REQUEST {
    pub ByteOffset: i64,
    pub ByteLength: u32,
    pub PlexNumber: u32,
}
impl ::core::marker::Copy for PLEX_READ_DATA_REQUEST {}
impl ::core::clone::Clone for PLEX_READ_DATA_REQUEST {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for PLEX_READ_DATA_REQUEST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PLEX_READ_DATA_REQUEST").field("ByteOffset", &self.ByteOffset).field("ByteLength", &self.ByteLength).field("PlexNumber", &self.PlexNumber).finish()
    }
}
impl ::windows_core::TypeKind for PLEX_READ_DATA_REQUEST {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for PLEX_READ_DATA_REQUEST {
    fn eq(&self, other: &Self) -> bool {
        self.ByteOffset == other.ByteOffset && self.ByteLength == other.ByteLength && self.PlexNumber == other.PlexNumber
    }
}
impl ::core::cmp::Eq for PLEX_READ_DATA_REQUEST {}
impl ::core::default::Default for PLEX_READ_DATA_REQUEST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct PREFETCH_OPEN_ECP_CONTEXT {
    pub Context: *mut ::core::ffi::c_void,
}
impl ::core::marker::Copy for PREFETCH_OPEN_ECP_CONTEXT {}
impl ::core::clone::Clone for PREFETCH_OPEN_ECP_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for PREFETCH_OPEN_ECP_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PREFETCH_OPEN_ECP_CONTEXT").field("Context", &self.Context).finish()
    }
}
impl ::windows_core::TypeKind for PREFETCH_OPEN_ECP_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for PREFETCH_OPEN_ECP_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.Context == other.Context
    }
}
impl ::core::cmp::Eq for PREFETCH_OPEN_ECP_CONTEXT {}
impl ::core::default::Default for PREFETCH_OPEN_ECP_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
pub struct PREFIX_TABLE {
    pub NodeTypeCode: i16,
    pub NameLength: i16,
    pub NextPrefixTree: *mut PREFIX_TABLE_ENTRY,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::marker::Copy for PREFIX_TABLE {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::clone::Clone for PREFIX_TABLE {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::fmt::Debug for PREFIX_TABLE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PREFIX_TABLE").field("NodeTypeCode", &self.NodeTypeCode).field("NameLength", &self.NameLength).field("NextPrefixTree", &self.NextPrefixTree).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::windows_core::TypeKind for PREFIX_TABLE {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::cmp::PartialEq for PREFIX_TABLE {
    fn eq(&self, other: &Self) -> bool {
        self.NodeTypeCode == other.NodeTypeCode && self.NameLength == other.NameLength && self.NextPrefixTree == other.NextPrefixTree
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::cmp::Eq for PREFIX_TABLE {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::default::Default for PREFIX_TABLE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
pub struct PREFIX_TABLE_ENTRY {
    pub NodeTypeCode: i16,
    pub NameLength: i16,
    pub NextPrefixTree: *mut PREFIX_TABLE_ENTRY,
    pub Links: super::super::Foundation::RTL_SPLAY_LINKS,
    pub Prefix: *mut super::super::super::Win32::System::Kernel::STRING,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::marker::Copy for PREFIX_TABLE_ENTRY {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::clone::Clone for PREFIX_TABLE_ENTRY {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::fmt::Debug for PREFIX_TABLE_ENTRY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PREFIX_TABLE_ENTRY").field("NodeTypeCode", &self.NodeTypeCode).field("NameLength", &self.NameLength).field("NextPrefixTree", &self.NextPrefixTree).field("Links", &self.Links).field("Prefix", &self.Prefix).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::windows_core::TypeKind for PREFIX_TABLE_ENTRY {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::cmp::PartialEq for PREFIX_TABLE_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.NodeTypeCode == other.NodeTypeCode && self.NameLength == other.NameLength && self.NextPrefixTree == other.NextPrefixTree && self.Links == other.Links && self.Prefix == other.Prefix
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::cmp::Eq for PREFIX_TABLE_ENTRY {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::default::Default for PREFIX_TABLE_ENTRY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct PUBLIC_BCB {
    pub NodeTypeCode: i16,
    pub NodeByteSize: i16,
    pub MappedLength: u32,
    pub MappedFileOffset: i64,
}
impl ::core::marker::Copy for PUBLIC_BCB {}
impl ::core::clone::Clone for PUBLIC_BCB {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for PUBLIC_BCB {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PUBLIC_BCB").field("NodeTypeCode", &self.NodeTypeCode).field("NodeByteSize", &self.NodeByteSize).field("MappedLength", &self.MappedLength).field("MappedFileOffset", &self.MappedFileOffset).finish()
    }
}
impl ::windows_core::TypeKind for PUBLIC_BCB {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for PUBLIC_BCB {
    fn eq(&self, other: &Self) -> bool {
        self.NodeTypeCode == other.NodeTypeCode && self.NodeByteSize == other.NodeByteSize && self.MappedLength == other.MappedLength && self.MappedFileOffset == other.MappedFileOffset
    }
}
impl ::core::cmp::Eq for PUBLIC_BCB {}
impl ::core::default::Default for PUBLIC_BCB {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct PUBLIC_OBJECT_BASIC_INFORMATION {
    pub Attributes: u32,
    pub GrantedAccess: u32,
    pub HandleCount: u32,
    pub PointerCount: u32,
    pub Reserved: [u32; 10],
}
impl ::core::marker::Copy for PUBLIC_OBJECT_BASIC_INFORMATION {}
impl ::core::clone::Clone for PUBLIC_OBJECT_BASIC_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for PUBLIC_OBJECT_BASIC_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PUBLIC_OBJECT_BASIC_INFORMATION").field("Attributes", &self.Attributes).field("GrantedAccess", &self.GrantedAccess).field("HandleCount", &self.HandleCount).field("PointerCount", &self.PointerCount).field("Reserved", &self.Reserved).finish()
    }
}
impl ::windows_core::TypeKind for PUBLIC_OBJECT_BASIC_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for PUBLIC_OBJECT_BASIC_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.Attributes == other.Attributes && self.GrantedAccess == other.GrantedAccess && self.HandleCount == other.HandleCount && self.PointerCount == other.PointerCount && self.Reserved == other.Reserved
    }
}
impl ::core::cmp::Eq for PUBLIC_OBJECT_BASIC_INFORMATION {}
impl ::core::default::Default for PUBLIC_OBJECT_BASIC_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct PUBLIC_OBJECT_TYPE_INFORMATION {
    pub TypeName: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub Reserved: [u32; 22],
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for PUBLIC_OBJECT_TYPE_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for PUBLIC_OBJECT_TYPE_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for PUBLIC_OBJECT_TYPE_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("PUBLIC_OBJECT_TYPE_INFORMATION").field("TypeName", &self.TypeName).field("Reserved", &self.Reserved).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for PUBLIC_OBJECT_TYPE_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for PUBLIC_OBJECT_TYPE_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.TypeName == other.TypeName && self.Reserved == other.Reserved
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for PUBLIC_OBJECT_TYPE_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for PUBLIC_OBJECT_TYPE_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct QUERY_BAD_RANGES_INPUT {
    pub Flags: u32,
    pub NumRanges: u32,
    pub Ranges: [QUERY_BAD_RANGES_INPUT_RANGE; 1],
}
impl ::core::marker::Copy for QUERY_BAD_RANGES_INPUT {}
impl ::core::clone::Clone for QUERY_BAD_RANGES_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for QUERY_BAD_RANGES_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("QUERY_BAD_RANGES_INPUT").field("Flags", &self.Flags).field("NumRanges", &self.NumRanges).field("Ranges", &self.Ranges).finish()
    }
}
impl ::windows_core::TypeKind for QUERY_BAD_RANGES_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for QUERY_BAD_RANGES_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags && self.NumRanges == other.NumRanges && self.Ranges == other.Ranges
    }
}
impl ::core::cmp::Eq for QUERY_BAD_RANGES_INPUT {}
impl ::core::default::Default for QUERY_BAD_RANGES_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct QUERY_BAD_RANGES_INPUT_RANGE {
    pub StartOffset: u64,
    pub LengthInBytes: u64,
}
impl ::core::marker::Copy for QUERY_BAD_RANGES_INPUT_RANGE {}
impl ::core::clone::Clone for QUERY_BAD_RANGES_INPUT_RANGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for QUERY_BAD_RANGES_INPUT_RANGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("QUERY_BAD_RANGES_INPUT_RANGE").field("StartOffset", &self.StartOffset).field("LengthInBytes", &self.LengthInBytes).finish()
    }
}
impl ::windows_core::TypeKind for QUERY_BAD_RANGES_INPUT_RANGE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for QUERY_BAD_RANGES_INPUT_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.StartOffset == other.StartOffset && self.LengthInBytes == other.LengthInBytes
    }
}
impl ::core::cmp::Eq for QUERY_BAD_RANGES_INPUT_RANGE {}
impl ::core::default::Default for QUERY_BAD_RANGES_INPUT_RANGE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct QUERY_BAD_RANGES_OUTPUT {
    pub Flags: u32,
    pub NumBadRanges: u32,
    pub NextOffsetToLookUp: u64,
    pub BadRanges: [QUERY_BAD_RANGES_OUTPUT_RANGE; 1],
}
impl ::core::marker::Copy for QUERY_BAD_RANGES_OUTPUT {}
impl ::core::clone::Clone for QUERY_BAD_RANGES_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for QUERY_BAD_RANGES_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("QUERY_BAD_RANGES_OUTPUT").field("Flags", &self.Flags).field("NumBadRanges", &self.NumBadRanges).field("NextOffsetToLookUp", &self.NextOffsetToLookUp).field("BadRanges", &self.BadRanges).finish()
    }
}
impl ::windows_core::TypeKind for QUERY_BAD_RANGES_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for QUERY_BAD_RANGES_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags && self.NumBadRanges == other.NumBadRanges && self.NextOffsetToLookUp == other.NextOffsetToLookUp && self.BadRanges == other.BadRanges
    }
}
impl ::core::cmp::Eq for QUERY_BAD_RANGES_OUTPUT {}
impl ::core::default::Default for QUERY_BAD_RANGES_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct QUERY_BAD_RANGES_OUTPUT_RANGE {
    pub Flags: u32,
    pub Reserved: u32,
    pub StartOffset: u64,
    pub LengthInBytes: u64,
}
impl ::core::marker::Copy for QUERY_BAD_RANGES_OUTPUT_RANGE {}
impl ::core::clone::Clone for QUERY_BAD_RANGES_OUTPUT_RANGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for QUERY_BAD_RANGES_OUTPUT_RANGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("QUERY_BAD_RANGES_OUTPUT_RANGE").field("Flags", &self.Flags).field("Reserved", &self.Reserved).field("StartOffset", &self.StartOffset).field("LengthInBytes", &self.LengthInBytes).finish()
    }
}
impl ::windows_core::TypeKind for QUERY_BAD_RANGES_OUTPUT_RANGE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for QUERY_BAD_RANGES_OUTPUT_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags && self.Reserved == other.Reserved && self.StartOffset == other.StartOffset && self.LengthInBytes == other.LengthInBytes
    }
}
impl ::core::cmp::Eq for QUERY_BAD_RANGES_OUTPUT_RANGE {}
impl ::core::default::Default for QUERY_BAD_RANGES_OUTPUT_RANGE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct QUERY_DIRECT_ACCESS_EXTENTS {
    pub FileOffset: i64,
    pub Length: i64,
    pub Flags: u32,
    pub Reserved: u32,
}
impl ::core::marker::Copy for QUERY_DIRECT_ACCESS_EXTENTS {}
impl ::core::clone::Clone for QUERY_DIRECT_ACCESS_EXTENTS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for QUERY_DIRECT_ACCESS_EXTENTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("QUERY_DIRECT_ACCESS_EXTENTS").field("FileOffset", &self.FileOffset).field("Length", &self.Length).field("Flags", &self.Flags).field("Reserved", &self.Reserved).finish()
    }
}
impl ::windows_core::TypeKind for QUERY_DIRECT_ACCESS_EXTENTS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for QUERY_DIRECT_ACCESS_EXTENTS {
    fn eq(&self, other: &Self) -> bool {
        self.FileOffset == other.FileOffset && self.Length == other.Length && self.Flags == other.Flags && self.Reserved == other.Reserved
    }
}
impl ::core::cmp::Eq for QUERY_DIRECT_ACCESS_EXTENTS {}
impl ::core::default::Default for QUERY_DIRECT_ACCESS_EXTENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct QUERY_FILE_LAYOUT_INPUT {
    pub Anonymous: QUERY_FILE_LAYOUT_INPUT_0,
    pub Flags: u32,
    pub FilterType: QUERY_FILE_LAYOUT_FILTER_TYPE,
    pub Reserved: u32,
    pub Filter: QUERY_FILE_LAYOUT_INPUT_1,
}
impl ::core::marker::Copy for QUERY_FILE_LAYOUT_INPUT {}
impl ::core::clone::Clone for QUERY_FILE_LAYOUT_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for QUERY_FILE_LAYOUT_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for QUERY_FILE_LAYOUT_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub union QUERY_FILE_LAYOUT_INPUT_0 {
    pub FilterEntryCount: u32,
    pub NumberOfPairs: u32,
}
impl ::core::marker::Copy for QUERY_FILE_LAYOUT_INPUT_0 {}
impl ::core::clone::Clone for QUERY_FILE_LAYOUT_INPUT_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for QUERY_FILE_LAYOUT_INPUT_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for QUERY_FILE_LAYOUT_INPUT_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub union QUERY_FILE_LAYOUT_INPUT_1 {
    pub ClusterRanges: [CLUSTER_RANGE; 1],
    pub FileReferenceRanges: [FILE_REFERENCE_RANGE; 1],
    pub StorageReserveIds: [STORAGE_RESERVE_ID; 1],
}
impl ::core::marker::Copy for QUERY_FILE_LAYOUT_INPUT_1 {}
impl ::core::clone::Clone for QUERY_FILE_LAYOUT_INPUT_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for QUERY_FILE_LAYOUT_INPUT_1 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for QUERY_FILE_LAYOUT_INPUT_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct QUERY_FILE_LAYOUT_OUTPUT {
    pub FileEntryCount: u32,
    pub FirstFileOffset: u32,
    pub Flags: u32,
    pub Reserved: u32,
}
impl ::core::marker::Copy for QUERY_FILE_LAYOUT_OUTPUT {}
impl ::core::clone::Clone for QUERY_FILE_LAYOUT_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for QUERY_FILE_LAYOUT_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("QUERY_FILE_LAYOUT_OUTPUT").field("FileEntryCount", &self.FileEntryCount).field("FirstFileOffset", &self.FirstFileOffset).field("Flags", &self.Flags).field("Reserved", &self.Reserved).finish()
    }
}
impl ::windows_core::TypeKind for QUERY_FILE_LAYOUT_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for QUERY_FILE_LAYOUT_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.FileEntryCount == other.FileEntryCount && self.FirstFileOffset == other.FirstFileOffset && self.Flags == other.Flags && self.Reserved == other.Reserved
    }
}
impl ::core::cmp::Eq for QUERY_FILE_LAYOUT_OUTPUT {}
impl ::core::default::Default for QUERY_FILE_LAYOUT_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct QUERY_ON_CREATE_EA_INFORMATION {
    pub EaBufferSize: u32,
    pub EaBuffer: *mut FILE_FULL_EA_INFORMATION,
}
impl ::core::marker::Copy for QUERY_ON_CREATE_EA_INFORMATION {}
impl ::core::clone::Clone for QUERY_ON_CREATE_EA_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for QUERY_ON_CREATE_EA_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("QUERY_ON_CREATE_EA_INFORMATION").field("EaBufferSize", &self.EaBufferSize).field("EaBuffer", &self.EaBuffer).finish()
    }
}
impl ::windows_core::TypeKind for QUERY_ON_CREATE_EA_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for QUERY_ON_CREATE_EA_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.EaBufferSize == other.EaBufferSize && self.EaBuffer == other.EaBuffer
    }
}
impl ::core::cmp::Eq for QUERY_ON_CREATE_EA_INFORMATION {}
impl ::core::default::Default for QUERY_ON_CREATE_EA_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct QUERY_ON_CREATE_ECP_CONTEXT {
    pub RequestedClasses: u32,
    pub ClassesProcessed: u32,
    pub ClassesWithErrors: u32,
    pub ClassesWithNoData: u32,
    pub StatInformation: QUERY_ON_CREATE_FILE_STAT_INFORMATION,
    pub LxInformation: QUERY_ON_CREATE_FILE_LX_INFORMATION,
    pub EaInformation: QUERY_ON_CREATE_EA_INFORMATION,
}
impl ::core::marker::Copy for QUERY_ON_CREATE_ECP_CONTEXT {}
impl ::core::clone::Clone for QUERY_ON_CREATE_ECP_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for QUERY_ON_CREATE_ECP_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("QUERY_ON_CREATE_ECP_CONTEXT").field("RequestedClasses", &self.RequestedClasses).field("ClassesProcessed", &self.ClassesProcessed).field("ClassesWithErrors", &self.ClassesWithErrors).field("ClassesWithNoData", &self.ClassesWithNoData).field("StatInformation", &self.StatInformation).field("LxInformation", &self.LxInformation).field("EaInformation", &self.EaInformation).finish()
    }
}
impl ::windows_core::TypeKind for QUERY_ON_CREATE_ECP_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for QUERY_ON_CREATE_ECP_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.RequestedClasses == other.RequestedClasses && self.ClassesProcessed == other.ClassesProcessed && self.ClassesWithErrors == other.ClassesWithErrors && self.ClassesWithNoData == other.ClassesWithNoData && self.StatInformation == other.StatInformation && self.LxInformation == other.LxInformation && self.EaInformation == other.EaInformation
    }
}
impl ::core::cmp::Eq for QUERY_ON_CREATE_ECP_CONTEXT {}
impl ::core::default::Default for QUERY_ON_CREATE_ECP_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct QUERY_ON_CREATE_FILE_LX_INFORMATION {
    pub EffectiveAccess: u32,
    pub LxFlags: u32,
    pub LxUid: u32,
    pub LxGid: u32,
    pub LxMode: u32,
    pub LxDeviceIdMajor: u32,
    pub LxDeviceIdMinor: u32,
}
impl ::core::marker::Copy for QUERY_ON_CREATE_FILE_LX_INFORMATION {}
impl ::core::clone::Clone for QUERY_ON_CREATE_FILE_LX_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for QUERY_ON_CREATE_FILE_LX_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("QUERY_ON_CREATE_FILE_LX_INFORMATION").field("EffectiveAccess", &self.EffectiveAccess).field("LxFlags", &self.LxFlags).field("LxUid", &self.LxUid).field("LxGid", &self.LxGid).field("LxMode", &self.LxMode).field("LxDeviceIdMajor", &self.LxDeviceIdMajor).field("LxDeviceIdMinor", &self.LxDeviceIdMinor).finish()
    }
}
impl ::windows_core::TypeKind for QUERY_ON_CREATE_FILE_LX_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for QUERY_ON_CREATE_FILE_LX_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.EffectiveAccess == other.EffectiveAccess && self.LxFlags == other.LxFlags && self.LxUid == other.LxUid && self.LxGid == other.LxGid && self.LxMode == other.LxMode && self.LxDeviceIdMajor == other.LxDeviceIdMajor && self.LxDeviceIdMinor == other.LxDeviceIdMinor
    }
}
impl ::core::cmp::Eq for QUERY_ON_CREATE_FILE_LX_INFORMATION {}
impl ::core::default::Default for QUERY_ON_CREATE_FILE_LX_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct QUERY_ON_CREATE_FILE_STAT_INFORMATION {
    pub FileId: i64,
    pub CreationTime: i64,
    pub LastAccessTime: i64,
    pub LastWriteTime: i64,
    pub ChangeTime: i64,
    pub AllocationSize: i64,
    pub EndOfFile: i64,
    pub FileAttributes: u32,
    pub ReparseTag: u32,
    pub NumberOfLinks: u32,
}
impl ::core::marker::Copy for QUERY_ON_CREATE_FILE_STAT_INFORMATION {}
impl ::core::clone::Clone for QUERY_ON_CREATE_FILE_STAT_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for QUERY_ON_CREATE_FILE_STAT_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("QUERY_ON_CREATE_FILE_STAT_INFORMATION").field("FileId", &self.FileId).field("CreationTime", &self.CreationTime).field("LastAccessTime", &self.LastAccessTime).field("LastWriteTime", &self.LastWriteTime).field("ChangeTime", &self.ChangeTime).field("AllocationSize", &self.AllocationSize).field("EndOfFile", &self.EndOfFile).field("FileAttributes", &self.FileAttributes).field("ReparseTag", &self.ReparseTag).field("NumberOfLinks", &self.NumberOfLinks).finish()
    }
}
impl ::windows_core::TypeKind for QUERY_ON_CREATE_FILE_STAT_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for QUERY_ON_CREATE_FILE_STAT_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.FileId == other.FileId && self.CreationTime == other.CreationTime && self.LastAccessTime == other.LastAccessTime && self.LastWriteTime == other.LastWriteTime && self.ChangeTime == other.ChangeTime && self.AllocationSize == other.AllocationSize && self.EndOfFile == other.EndOfFile && self.FileAttributes == other.FileAttributes && self.ReparseTag == other.ReparseTag && self.NumberOfLinks == other.NumberOfLinks
    }
}
impl ::core::cmp::Eq for QUERY_ON_CREATE_FILE_STAT_INFORMATION {}
impl ::core::default::Default for QUERY_ON_CREATE_FILE_STAT_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
pub struct QUERY_PATH_REQUEST {
    pub PathNameLength: u32,
    pub SecurityContext: *mut super::super::Foundation::IO_SECURITY_CONTEXT,
    pub FilePathName: [u16; 1],
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::marker::Copy for QUERY_PATH_REQUEST {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::clone::Clone for QUERY_PATH_REQUEST {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::fmt::Debug for QUERY_PATH_REQUEST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("QUERY_PATH_REQUEST").field("PathNameLength", &self.PathNameLength).field("SecurityContext", &self.SecurityContext).field("FilePathName", &self.FilePathName).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::windows_core::TypeKind for QUERY_PATH_REQUEST {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::cmp::PartialEq for QUERY_PATH_REQUEST {
    fn eq(&self, other: &Self) -> bool {
        self.PathNameLength == other.PathNameLength && self.SecurityContext == other.SecurityContext && self.FilePathName == other.FilePathName
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::cmp::Eq for QUERY_PATH_REQUEST {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::default::Default for QUERY_PATH_REQUEST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
pub struct QUERY_PATH_REQUEST_EX {
    pub pSecurityContext: *mut super::super::Foundation::IO_SECURITY_CONTEXT,
    pub EaLength: u32,
    pub pEaBuffer: *mut ::core::ffi::c_void,
    pub PathName: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub DomainServiceName: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub EcpList: *mut super::super::Foundation::ECP_LIST,
    pub Silo: *mut super::super::Foundation::EJOB,
    pub Reserved: usize,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::marker::Copy for QUERY_PATH_REQUEST_EX {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::clone::Clone for QUERY_PATH_REQUEST_EX {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::fmt::Debug for QUERY_PATH_REQUEST_EX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("QUERY_PATH_REQUEST_EX").field("pSecurityContext", &self.pSecurityContext).field("EaLength", &self.EaLength).field("pEaBuffer", &self.pEaBuffer).field("PathName", &self.PathName).field("DomainServiceName", &self.DomainServiceName).field("EcpList", &self.EcpList).field("Silo", &self.Silo).field("Reserved", &self.Reserved).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::windows_core::TypeKind for QUERY_PATH_REQUEST_EX {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::cmp::PartialEq for QUERY_PATH_REQUEST_EX {
    fn eq(&self, other: &Self) -> bool {
        self.pSecurityContext == other.pSecurityContext && self.EaLength == other.EaLength && self.pEaBuffer == other.pEaBuffer && self.PathName == other.PathName && self.DomainServiceName == other.DomainServiceName && self.EcpList == other.EcpList && self.Silo == other.Silo && self.Reserved == other.Reserved
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::cmp::Eq for QUERY_PATH_REQUEST_EX {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::default::Default for QUERY_PATH_REQUEST_EX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct QUERY_PATH_RESPONSE {
    pub LengthAccepted: u32,
}
impl ::core::marker::Copy for QUERY_PATH_RESPONSE {}
impl ::core::clone::Clone for QUERY_PATH_RESPONSE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for QUERY_PATH_RESPONSE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("QUERY_PATH_RESPONSE").field("LengthAccepted", &self.LengthAccepted).finish()
    }
}
impl ::windows_core::TypeKind for QUERY_PATH_RESPONSE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for QUERY_PATH_RESPONSE {
    fn eq(&self, other: &Self) -> bool {
        self.LengthAccepted == other.LengthAccepted
    }
}
impl ::core::cmp::Eq for QUERY_PATH_RESPONSE {}
impl ::core::default::Default for QUERY_PATH_RESPONSE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct READ_AHEAD_PARAMETERS {
    pub NodeByteSize: i16,
    pub Granularity: u32,
    pub PipelinedRequestSize: u32,
    pub ReadAheadGrowthPercentage: u32,
}
impl ::core::marker::Copy for READ_AHEAD_PARAMETERS {}
impl ::core::clone::Clone for READ_AHEAD_PARAMETERS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for READ_AHEAD_PARAMETERS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("READ_AHEAD_PARAMETERS").field("NodeByteSize", &self.NodeByteSize).field("Granularity", &self.Granularity).field("PipelinedRequestSize", &self.PipelinedRequestSize).field("ReadAheadGrowthPercentage", &self.ReadAheadGrowthPercentage).finish()
    }
}
impl ::windows_core::TypeKind for READ_AHEAD_PARAMETERS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for READ_AHEAD_PARAMETERS {
    fn eq(&self, other: &Self) -> bool {
        self.NodeByteSize == other.NodeByteSize && self.Granularity == other.Granularity && self.PipelinedRequestSize == other.PipelinedRequestSize && self.ReadAheadGrowthPercentage == other.ReadAheadGrowthPercentage
    }
}
impl ::core::cmp::Eq for READ_AHEAD_PARAMETERS {}
impl ::core::default::Default for READ_AHEAD_PARAMETERS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct READ_FILE_USN_DATA {
    pub MinMajorVersion: u16,
    pub MaxMajorVersion: u16,
}
impl ::core::marker::Copy for READ_FILE_USN_DATA {}
impl ::core::clone::Clone for READ_FILE_USN_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for READ_FILE_USN_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("READ_FILE_USN_DATA").field("MinMajorVersion", &self.MinMajorVersion).field("MaxMajorVersion", &self.MaxMajorVersion).finish()
    }
}
impl ::windows_core::TypeKind for READ_FILE_USN_DATA {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for READ_FILE_USN_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.MinMajorVersion == other.MinMajorVersion && self.MaxMajorVersion == other.MaxMajorVersion
    }
}
impl ::core::cmp::Eq for READ_FILE_USN_DATA {}
impl ::core::default::Default for READ_FILE_USN_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_Storage_FileSystem\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_Storage_FileSystem", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub struct READ_LIST {
    pub FileObject: *mut super::super::Foundation::FILE_OBJECT,
    pub NumberOfEntries: u32,
    pub IsImage: u32,
    pub List: [super::super::super::Win32::Storage::FileSystem::FILE_SEGMENT_ELEMENT; 1],
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_Storage_FileSystem", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::marker::Copy for READ_LIST {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_Storage_FileSystem", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::clone::Clone for READ_LIST {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_Storage_FileSystem", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::windows_core::TypeKind for READ_LIST {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_Storage_FileSystem", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
impl ::core::default::Default for READ_LIST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct READ_USN_JOURNAL_DATA {
    pub StartUsn: i64,
    pub ReasonMask: u32,
    pub ReturnOnlyOnClose: u32,
    pub Timeout: u64,
    pub BytesToWaitFor: u64,
    pub UsnJournalID: u64,
    pub MinMajorVersion: u16,
    pub MaxMajorVersion: u16,
}
impl ::core::marker::Copy for READ_USN_JOURNAL_DATA {}
impl ::core::clone::Clone for READ_USN_JOURNAL_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for READ_USN_JOURNAL_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("READ_USN_JOURNAL_DATA").field("StartUsn", &self.StartUsn).field("ReasonMask", &self.ReasonMask).field("ReturnOnlyOnClose", &self.ReturnOnlyOnClose).field("Timeout", &self.Timeout).field("BytesToWaitFor", &self.BytesToWaitFor).field("UsnJournalID", &self.UsnJournalID).field("MinMajorVersion", &self.MinMajorVersion).field("MaxMajorVersion", &self.MaxMajorVersion).finish()
    }
}
impl ::windows_core::TypeKind for READ_USN_JOURNAL_DATA {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for READ_USN_JOURNAL_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.StartUsn == other.StartUsn && self.ReasonMask == other.ReasonMask && self.ReturnOnlyOnClose == other.ReturnOnlyOnClose && self.Timeout == other.Timeout && self.BytesToWaitFor == other.BytesToWaitFor && self.UsnJournalID == other.UsnJournalID && self.MinMajorVersion == other.MinMajorVersion && self.MaxMajorVersion == other.MaxMajorVersion
    }
}
impl ::core::cmp::Eq for READ_USN_JOURNAL_DATA {}
impl ::core::default::Default for READ_USN_JOURNAL_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct READ_USN_JOURNAL_DATA_V0 {
    pub StartUsn: i64,
    pub ReasonMask: u32,
    pub ReturnOnlyOnClose: u32,
    pub Timeout: u64,
    pub BytesToWaitFor: u64,
    pub UsnJournalID: u64,
}
impl ::core::marker::Copy for READ_USN_JOURNAL_DATA_V0 {}
impl ::core::clone::Clone for READ_USN_JOURNAL_DATA_V0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for READ_USN_JOURNAL_DATA_V0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("READ_USN_JOURNAL_DATA_V0").field("StartUsn", &self.StartUsn).field("ReasonMask", &self.ReasonMask).field("ReturnOnlyOnClose", &self.ReturnOnlyOnClose).field("Timeout", &self.Timeout).field("BytesToWaitFor", &self.BytesToWaitFor).field("UsnJournalID", &self.UsnJournalID).finish()
    }
}
impl ::windows_core::TypeKind for READ_USN_JOURNAL_DATA_V0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for READ_USN_JOURNAL_DATA_V0 {
    fn eq(&self, other: &Self) -> bool {
        self.StartUsn == other.StartUsn && self.ReasonMask == other.ReasonMask && self.ReturnOnlyOnClose == other.ReturnOnlyOnClose && self.Timeout == other.Timeout && self.BytesToWaitFor == other.BytesToWaitFor && self.UsnJournalID == other.UsnJournalID
    }
}
impl ::core::cmp::Eq for READ_USN_JOURNAL_DATA_V0 {}
impl ::core::default::Default for READ_USN_JOURNAL_DATA_V0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct REARRANGE_FILE_DATA {
    pub SourceStartingOffset: u64,
    pub TargetOffset: u64,
    pub SourceFileHandle: super::super::super::Win32::Foundation::HANDLE,
    pub Length: u32,
    pub Flags: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for REARRANGE_FILE_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for REARRANGE_FILE_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for REARRANGE_FILE_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REARRANGE_FILE_DATA").field("SourceStartingOffset", &self.SourceStartingOffset).field("TargetOffset", &self.TargetOffset).field("SourceFileHandle", &self.SourceFileHandle).field("Length", &self.Length).field("Flags", &self.Flags).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for REARRANGE_FILE_DATA {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for REARRANGE_FILE_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.SourceStartingOffset == other.SourceStartingOffset && self.TargetOffset == other.TargetOffset && self.SourceFileHandle == other.SourceFileHandle && self.Length == other.Length && self.Flags == other.Flags
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for REARRANGE_FILE_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for REARRANGE_FILE_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REFS_DEALLOCATE_RANGES_INPUT_BUFFER {
    pub RangeCount: u32,
    pub Ranges: [REFS_DEALLOCATE_RANGES_RANGE; 1],
}
impl ::core::marker::Copy for REFS_DEALLOCATE_RANGES_INPUT_BUFFER {}
impl ::core::clone::Clone for REFS_DEALLOCATE_RANGES_INPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REFS_DEALLOCATE_RANGES_INPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REFS_DEALLOCATE_RANGES_INPUT_BUFFER").field("RangeCount", &self.RangeCount).field("Ranges", &self.Ranges).finish()
    }
}
impl ::windows_core::TypeKind for REFS_DEALLOCATE_RANGES_INPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REFS_DEALLOCATE_RANGES_INPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.RangeCount == other.RangeCount && self.Ranges == other.Ranges
    }
}
impl ::core::cmp::Eq for REFS_DEALLOCATE_RANGES_INPUT_BUFFER {}
impl ::core::default::Default for REFS_DEALLOCATE_RANGES_INPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REFS_DEALLOCATE_RANGES_INPUT_BUFFER_EX {
    pub RangeCount: u32,
    pub Allocator: REFS_DEALLOCATE_RANGES_ALLOCATOR,
    pub StreamReserveUpdateCount: i64,
    pub OffsetToRanges: u32,
    pub OffsetToLeakCounts: u32,
    pub Reserved: [u64; 2],
}
impl ::core::marker::Copy for REFS_DEALLOCATE_RANGES_INPUT_BUFFER_EX {}
impl ::core::clone::Clone for REFS_DEALLOCATE_RANGES_INPUT_BUFFER_EX {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REFS_DEALLOCATE_RANGES_INPUT_BUFFER_EX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REFS_DEALLOCATE_RANGES_INPUT_BUFFER_EX").field("RangeCount", &self.RangeCount).field("Allocator", &self.Allocator).field("StreamReserveUpdateCount", &self.StreamReserveUpdateCount).field("OffsetToRanges", &self.OffsetToRanges).field("OffsetToLeakCounts", &self.OffsetToLeakCounts).field("Reserved", &self.Reserved).finish()
    }
}
impl ::windows_core::TypeKind for REFS_DEALLOCATE_RANGES_INPUT_BUFFER_EX {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REFS_DEALLOCATE_RANGES_INPUT_BUFFER_EX {
    fn eq(&self, other: &Self) -> bool {
        self.RangeCount == other.RangeCount && self.Allocator == other.Allocator && self.StreamReserveUpdateCount == other.StreamReserveUpdateCount && self.OffsetToRanges == other.OffsetToRanges && self.OffsetToLeakCounts == other.OffsetToLeakCounts && self.Reserved == other.Reserved
    }
}
impl ::core::cmp::Eq for REFS_DEALLOCATE_RANGES_INPUT_BUFFER_EX {}
impl ::core::default::Default for REFS_DEALLOCATE_RANGES_INPUT_BUFFER_EX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REFS_DEALLOCATE_RANGES_RANGE {
    pub StartOfRange: u64,
    pub CountOfRange: u64,
}
impl ::core::marker::Copy for REFS_DEALLOCATE_RANGES_RANGE {}
impl ::core::clone::Clone for REFS_DEALLOCATE_RANGES_RANGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REFS_DEALLOCATE_RANGES_RANGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REFS_DEALLOCATE_RANGES_RANGE").field("StartOfRange", &self.StartOfRange).field("CountOfRange", &self.CountOfRange).finish()
    }
}
impl ::windows_core::TypeKind for REFS_DEALLOCATE_RANGES_RANGE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REFS_DEALLOCATE_RANGES_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.StartOfRange == other.StartOfRange && self.CountOfRange == other.CountOfRange
    }
}
impl ::core::cmp::Eq for REFS_DEALLOCATE_RANGES_RANGE {}
impl ::core::default::Default for REFS_DEALLOCATE_RANGES_RANGE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REFS_QUERY_VOLUME_COMPRESSION_INFO_OUTPUT_BUFFER {
    pub DefaultCompressionFormat: REFS_COMPRESSION_FORMATS,
    pub DefaultCompressionLevel: i16,
    pub DefaultCompressionChunkSizeBytes: u32,
    pub VolumeClusterSizeBytes: u32,
    pub TotalVolumeClusters: u64,
    pub TotalAllocatedClusters: u64,
    pub TotalCompressibleClustersAllocated: u64,
    pub TotalCompressibleClustersInUse: u64,
    pub TotalCompressedClusters: u64,
    pub Reserved: [u64; 6],
}
impl ::core::marker::Copy for REFS_QUERY_VOLUME_COMPRESSION_INFO_OUTPUT_BUFFER {}
impl ::core::clone::Clone for REFS_QUERY_VOLUME_COMPRESSION_INFO_OUTPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REFS_QUERY_VOLUME_COMPRESSION_INFO_OUTPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REFS_QUERY_VOLUME_COMPRESSION_INFO_OUTPUT_BUFFER")
            .field("DefaultCompressionFormat", &self.DefaultCompressionFormat)
            .field("DefaultCompressionLevel", &self.DefaultCompressionLevel)
            .field("DefaultCompressionChunkSizeBytes", &self.DefaultCompressionChunkSizeBytes)
            .field("VolumeClusterSizeBytes", &self.VolumeClusterSizeBytes)
            .field("TotalVolumeClusters", &self.TotalVolumeClusters)
            .field("TotalAllocatedClusters", &self.TotalAllocatedClusters)
            .field("TotalCompressibleClustersAllocated", &self.TotalCompressibleClustersAllocated)
            .field("TotalCompressibleClustersInUse", &self.TotalCompressibleClustersInUse)
            .field("TotalCompressedClusters", &self.TotalCompressedClusters)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
impl ::windows_core::TypeKind for REFS_QUERY_VOLUME_COMPRESSION_INFO_OUTPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REFS_QUERY_VOLUME_COMPRESSION_INFO_OUTPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.DefaultCompressionFormat == other.DefaultCompressionFormat && self.DefaultCompressionLevel == other.DefaultCompressionLevel && self.DefaultCompressionChunkSizeBytes == other.DefaultCompressionChunkSizeBytes && self.VolumeClusterSizeBytes == other.VolumeClusterSizeBytes && self.TotalVolumeClusters == other.TotalVolumeClusters && self.TotalAllocatedClusters == other.TotalAllocatedClusters && self.TotalCompressibleClustersAllocated == other.TotalCompressibleClustersAllocated && self.TotalCompressibleClustersInUse == other.TotalCompressibleClustersInUse && self.TotalCompressedClusters == other.TotalCompressedClusters && self.Reserved == other.Reserved
    }
}
impl ::core::cmp::Eq for REFS_QUERY_VOLUME_COMPRESSION_INFO_OUTPUT_BUFFER {}
impl ::core::default::Default for REFS_QUERY_VOLUME_COMPRESSION_INFO_OUTPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct REFS_QUERY_VOLUME_DEDUP_INFO_OUTPUT_BUFFER {
    pub Enabled: super::super::super::Win32::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for REFS_QUERY_VOLUME_DEDUP_INFO_OUTPUT_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for REFS_QUERY_VOLUME_DEDUP_INFO_OUTPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for REFS_QUERY_VOLUME_DEDUP_INFO_OUTPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REFS_QUERY_VOLUME_DEDUP_INFO_OUTPUT_BUFFER").field("Enabled", &self.Enabled).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for REFS_QUERY_VOLUME_DEDUP_INFO_OUTPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for REFS_QUERY_VOLUME_DEDUP_INFO_OUTPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.Enabled == other.Enabled
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for REFS_QUERY_VOLUME_DEDUP_INFO_OUTPUT_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for REFS_QUERY_VOLUME_DEDUP_INFO_OUTPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REFS_REMOVE_HARDLINK_BACKPOINTER {
    pub ParentDirectory: u64,
    pub Reserved: u64,
    pub FileName: [u16; 1],
}
impl ::core::marker::Copy for REFS_REMOVE_HARDLINK_BACKPOINTER {}
impl ::core::clone::Clone for REFS_REMOVE_HARDLINK_BACKPOINTER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REFS_REMOVE_HARDLINK_BACKPOINTER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REFS_REMOVE_HARDLINK_BACKPOINTER").field("ParentDirectory", &self.ParentDirectory).field("Reserved", &self.Reserved).field("FileName", &self.FileName).finish()
    }
}
impl ::windows_core::TypeKind for REFS_REMOVE_HARDLINK_BACKPOINTER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REFS_REMOVE_HARDLINK_BACKPOINTER {
    fn eq(&self, other: &Self) -> bool {
        self.ParentDirectory == other.ParentDirectory && self.Reserved == other.Reserved && self.FileName == other.FileName
    }
}
impl ::core::cmp::Eq for REFS_REMOVE_HARDLINK_BACKPOINTER {}
impl ::core::default::Default for REFS_REMOVE_HARDLINK_BACKPOINTER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REFS_SET_VOLUME_COMPRESSION_INFO_INPUT_BUFFER {
    pub CompressionFormat: REFS_COMPRESSION_FORMATS,
    pub CompressionLevel: i16,
    pub CompressionChunkSizeBytes: u32,
    pub Flags: REFS_SET_VOLUME_COMPRESSION_INFO_FLAGS,
    pub Reserved: [u64; 8],
}
impl ::core::marker::Copy for REFS_SET_VOLUME_COMPRESSION_INFO_INPUT_BUFFER {}
impl ::core::clone::Clone for REFS_SET_VOLUME_COMPRESSION_INFO_INPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REFS_SET_VOLUME_COMPRESSION_INFO_INPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REFS_SET_VOLUME_COMPRESSION_INFO_INPUT_BUFFER").field("CompressionFormat", &self.CompressionFormat).field("CompressionLevel", &self.CompressionLevel).field("CompressionChunkSizeBytes", &self.CompressionChunkSizeBytes).field("Flags", &self.Flags).field("Reserved", &self.Reserved).finish()
    }
}
impl ::windows_core::TypeKind for REFS_SET_VOLUME_COMPRESSION_INFO_INPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REFS_SET_VOLUME_COMPRESSION_INFO_INPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.CompressionFormat == other.CompressionFormat && self.CompressionLevel == other.CompressionLevel && self.CompressionChunkSizeBytes == other.CompressionChunkSizeBytes && self.Flags == other.Flags && self.Reserved == other.Reserved
    }
}
impl ::core::cmp::Eq for REFS_SET_VOLUME_COMPRESSION_INFO_INPUT_BUFFER {}
impl ::core::default::Default for REFS_SET_VOLUME_COMPRESSION_INFO_INPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct REFS_SET_VOLUME_DEDUP_INFO_INPUT_BUFFER {
    pub Enable: super::super::super::Win32::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for REFS_SET_VOLUME_DEDUP_INFO_INPUT_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for REFS_SET_VOLUME_DEDUP_INFO_INPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for REFS_SET_VOLUME_DEDUP_INFO_INPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REFS_SET_VOLUME_DEDUP_INFO_INPUT_BUFFER").field("Enable", &self.Enable).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for REFS_SET_VOLUME_DEDUP_INFO_INPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for REFS_SET_VOLUME_DEDUP_INFO_INPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.Enable == other.Enable
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for REFS_SET_VOLUME_DEDUP_INFO_INPUT_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for REFS_SET_VOLUME_DEDUP_INFO_INPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REFS_SMR_VOLUME_GC_PARAMETERS {
    pub Version: u32,
    pub Flags: u32,
    pub Action: REFS_SMR_VOLUME_GC_ACTION,
    pub Method: REFS_SMR_VOLUME_GC_METHOD,
    pub IoGranularity: u32,
    pub CompressionFormat: u32,
    pub Unused: [u64; 8],
}
impl ::core::marker::Copy for REFS_SMR_VOLUME_GC_PARAMETERS {}
impl ::core::clone::Clone for REFS_SMR_VOLUME_GC_PARAMETERS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REFS_SMR_VOLUME_GC_PARAMETERS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REFS_SMR_VOLUME_GC_PARAMETERS").field("Version", &self.Version).field("Flags", &self.Flags).field("Action", &self.Action).field("Method", &self.Method).field("IoGranularity", &self.IoGranularity).field("CompressionFormat", &self.CompressionFormat).field("Unused", &self.Unused).finish()
    }
}
impl ::windows_core::TypeKind for REFS_SMR_VOLUME_GC_PARAMETERS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REFS_SMR_VOLUME_GC_PARAMETERS {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Flags == other.Flags && self.Action == other.Action && self.Method == other.Method && self.IoGranularity == other.IoGranularity && self.CompressionFormat == other.CompressionFormat && self.Unused == other.Unused
    }
}
impl ::core::cmp::Eq for REFS_SMR_VOLUME_GC_PARAMETERS {}
impl ::core::default::Default for REFS_SMR_VOLUME_GC_PARAMETERS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct REFS_SMR_VOLUME_INFO_OUTPUT {
    pub Version: u32,
    pub Flags: u32,
    pub SizeOfRandomlyWritableTier: i64,
    pub FreeSpaceInRandomlyWritableTier: i64,
    pub SizeofSMRTier: i64,
    pub FreeSpaceInSMRTier: i64,
    pub UsableFreeSpaceInSMRTier: i64,
    pub VolumeGcState: REFS_SMR_VOLUME_GC_STATE,
    pub VolumeGcLastStatus: super::super::super::Win32::Foundation::NTSTATUS,
    pub CurrentGcBandFillPercentage: u32,
    pub Unused: [u64; 6],
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for REFS_SMR_VOLUME_INFO_OUTPUT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for REFS_SMR_VOLUME_INFO_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for REFS_SMR_VOLUME_INFO_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REFS_SMR_VOLUME_INFO_OUTPUT")
            .field("Version", &self.Version)
            .field("Flags", &self.Flags)
            .field("SizeOfRandomlyWritableTier", &self.SizeOfRandomlyWritableTier)
            .field("FreeSpaceInRandomlyWritableTier", &self.FreeSpaceInRandomlyWritableTier)
            .field("SizeofSMRTier", &self.SizeofSMRTier)
            .field("FreeSpaceInSMRTier", &self.FreeSpaceInSMRTier)
            .field("UsableFreeSpaceInSMRTier", &self.UsableFreeSpaceInSMRTier)
            .field("VolumeGcState", &self.VolumeGcState)
            .field("VolumeGcLastStatus", &self.VolumeGcLastStatus)
            .field("CurrentGcBandFillPercentage", &self.CurrentGcBandFillPercentage)
            .field("Unused", &self.Unused)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for REFS_SMR_VOLUME_INFO_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for REFS_SMR_VOLUME_INFO_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Flags == other.Flags && self.SizeOfRandomlyWritableTier == other.SizeOfRandomlyWritableTier && self.FreeSpaceInRandomlyWritableTier == other.FreeSpaceInRandomlyWritableTier && self.SizeofSMRTier == other.SizeofSMRTier && self.FreeSpaceInSMRTier == other.FreeSpaceInSMRTier && self.UsableFreeSpaceInSMRTier == other.UsableFreeSpaceInSMRTier && self.VolumeGcState == other.VolumeGcState && self.VolumeGcLastStatus == other.VolumeGcLastStatus && self.CurrentGcBandFillPercentage == other.CurrentGcBandFillPercentage && self.Unused == other.Unused
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for REFS_SMR_VOLUME_INFO_OUTPUT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for REFS_SMR_VOLUME_INFO_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REFS_STREAM_EXTENT {
    pub Vcn: i64,
    pub Lcn: i64,
    pub Length: i64,
    pub Properties: u16,
}
impl ::core::marker::Copy for REFS_STREAM_EXTENT {}
impl ::core::clone::Clone for REFS_STREAM_EXTENT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REFS_STREAM_EXTENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REFS_STREAM_EXTENT").field("Vcn", &self.Vcn).field("Lcn", &self.Lcn).field("Length", &self.Length).field("Properties", &self.Properties).finish()
    }
}
impl ::windows_core::TypeKind for REFS_STREAM_EXTENT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REFS_STREAM_EXTENT {
    fn eq(&self, other: &Self) -> bool {
        self.Vcn == other.Vcn && self.Lcn == other.Lcn && self.Length == other.Length && self.Properties == other.Properties
    }
}
impl ::core::cmp::Eq for REFS_STREAM_EXTENT {}
impl ::core::default::Default for REFS_STREAM_EXTENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER {
    pub EntryCount: u32,
    pub BufferSizeRequiredForQuery: u32,
    pub Reserved: [u32; 2],
    pub Entries: [REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER_ENTRY; 1],
}
impl ::core::marker::Copy for REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER {}
impl ::core::clone::Clone for REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER").field("EntryCount", &self.EntryCount).field("BufferSizeRequiredForQuery", &self.BufferSizeRequiredForQuery).field("Reserved", &self.Reserved).field("Entries", &self.Entries).finish()
    }
}
impl ::windows_core::TypeKind for REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.EntryCount == other.EntryCount && self.BufferSizeRequiredForQuery == other.BufferSizeRequiredForQuery && self.Reserved == other.Reserved && self.Entries == other.Entries
    }
}
impl ::core::cmp::Eq for REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER {}
impl ::core::default::Default for REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER_ENTRY {
    pub NextEntryOffset: u32,
    pub SnapshotNameLength: u16,
    pub SnapshotCreationTime: u64,
    pub StreamSize: u64,
    pub StreamAllocationSize: u64,
    pub Reserved: [u64; 2],
    pub SnapshotName: [u16; 1],
}
impl ::core::marker::Copy for REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER_ENTRY {}
impl ::core::clone::Clone for REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER_ENTRY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER_ENTRY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER_ENTRY").field("NextEntryOffset", &self.NextEntryOffset).field("SnapshotNameLength", &self.SnapshotNameLength).field("SnapshotCreationTime", &self.SnapshotCreationTime).field("StreamSize", &self.StreamSize).field("StreamAllocationSize", &self.StreamAllocationSize).field("Reserved", &self.Reserved).field("SnapshotName", &self.SnapshotName).finish()
    }
}
impl ::windows_core::TypeKind for REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER_ENTRY {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.NextEntryOffset == other.NextEntryOffset && self.SnapshotNameLength == other.SnapshotNameLength && self.SnapshotCreationTime == other.SnapshotCreationTime && self.StreamSize == other.StreamSize && self.StreamAllocationSize == other.StreamAllocationSize && self.Reserved == other.Reserved && self.SnapshotName == other.SnapshotName
    }
}
impl ::core::cmp::Eq for REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER_ENTRY {}
impl ::core::default::Default for REFS_STREAM_SNAPSHOT_LIST_OUTPUT_BUFFER_ENTRY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REFS_STREAM_SNAPSHOT_MANAGEMENT_INPUT_BUFFER {
    pub Operation: REFS_STREAM_SNAPSHOT_OPERATION,
    pub SnapshotNameLength: u16,
    pub OperationInputBufferLength: u16,
    pub Reserved: [u64; 2],
    pub NameAndInputBuffer: [u16; 1],
}
impl ::core::marker::Copy for REFS_STREAM_SNAPSHOT_MANAGEMENT_INPUT_BUFFER {}
impl ::core::clone::Clone for REFS_STREAM_SNAPSHOT_MANAGEMENT_INPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REFS_STREAM_SNAPSHOT_MANAGEMENT_INPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REFS_STREAM_SNAPSHOT_MANAGEMENT_INPUT_BUFFER").field("Operation", &self.Operation).field("SnapshotNameLength", &self.SnapshotNameLength).field("OperationInputBufferLength", &self.OperationInputBufferLength).field("Reserved", &self.Reserved).field("NameAndInputBuffer", &self.NameAndInputBuffer).finish()
    }
}
impl ::windows_core::TypeKind for REFS_STREAM_SNAPSHOT_MANAGEMENT_INPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REFS_STREAM_SNAPSHOT_MANAGEMENT_INPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.Operation == other.Operation && self.SnapshotNameLength == other.SnapshotNameLength && self.OperationInputBufferLength == other.OperationInputBufferLength && self.Reserved == other.Reserved && self.NameAndInputBuffer == other.NameAndInputBuffer
    }
}
impl ::core::cmp::Eq for REFS_STREAM_SNAPSHOT_MANAGEMENT_INPUT_BUFFER {}
impl ::core::default::Default for REFS_STREAM_SNAPSHOT_MANAGEMENT_INPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REFS_STREAM_SNAPSHOT_QUERY_DELTAS_INPUT_BUFFER {
    pub StartingVcn: i64,
    pub Flags: u32,
    pub Reserved: u32,
}
impl ::core::marker::Copy for REFS_STREAM_SNAPSHOT_QUERY_DELTAS_INPUT_BUFFER {}
impl ::core::clone::Clone for REFS_STREAM_SNAPSHOT_QUERY_DELTAS_INPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REFS_STREAM_SNAPSHOT_QUERY_DELTAS_INPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REFS_STREAM_SNAPSHOT_QUERY_DELTAS_INPUT_BUFFER").field("StartingVcn", &self.StartingVcn).field("Flags", &self.Flags).field("Reserved", &self.Reserved).finish()
    }
}
impl ::windows_core::TypeKind for REFS_STREAM_SNAPSHOT_QUERY_DELTAS_INPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REFS_STREAM_SNAPSHOT_QUERY_DELTAS_INPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.StartingVcn == other.StartingVcn && self.Flags == other.Flags && self.Reserved == other.Reserved
    }
}
impl ::core::cmp::Eq for REFS_STREAM_SNAPSHOT_QUERY_DELTAS_INPUT_BUFFER {}
impl ::core::default::Default for REFS_STREAM_SNAPSHOT_QUERY_DELTAS_INPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REFS_STREAM_SNAPSHOT_QUERY_DELTAS_OUTPUT_BUFFER {
    pub ExtentCount: u32,
    pub Reserved: [u32; 2],
    pub Extents: [REFS_STREAM_EXTENT; 1],
}
impl ::core::marker::Copy for REFS_STREAM_SNAPSHOT_QUERY_DELTAS_OUTPUT_BUFFER {}
impl ::core::clone::Clone for REFS_STREAM_SNAPSHOT_QUERY_DELTAS_OUTPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REFS_STREAM_SNAPSHOT_QUERY_DELTAS_OUTPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REFS_STREAM_SNAPSHOT_QUERY_DELTAS_OUTPUT_BUFFER").field("ExtentCount", &self.ExtentCount).field("Reserved", &self.Reserved).field("Extents", &self.Extents).finish()
    }
}
impl ::windows_core::TypeKind for REFS_STREAM_SNAPSHOT_QUERY_DELTAS_OUTPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REFS_STREAM_SNAPSHOT_QUERY_DELTAS_OUTPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.ExtentCount == other.ExtentCount && self.Reserved == other.Reserved && self.Extents == other.Extents
    }
}
impl ::core::cmp::Eq for REFS_STREAM_SNAPSHOT_QUERY_DELTAS_OUTPUT_BUFFER {}
impl ::core::default::Default for REFS_STREAM_SNAPSHOT_QUERY_DELTAS_OUTPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct REFS_VOLUME_COUNTER_INFO_INPUT_BUFFER {
    pub ResetCounters: super::super::super::Win32::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for REFS_VOLUME_COUNTER_INFO_INPUT_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for REFS_VOLUME_COUNTER_INFO_INPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for REFS_VOLUME_COUNTER_INFO_INPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REFS_VOLUME_COUNTER_INFO_INPUT_BUFFER").field("ResetCounters", &self.ResetCounters).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for REFS_VOLUME_COUNTER_INFO_INPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for REFS_VOLUME_COUNTER_INFO_INPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.ResetCounters == other.ResetCounters
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for REFS_VOLUME_COUNTER_INFO_INPUT_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for REFS_VOLUME_COUNTER_INFO_INPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REFS_VOLUME_DATA_BUFFER {
    pub ByteCount: u32,
    pub MajorVersion: u32,
    pub MinorVersion: u32,
    pub BytesPerPhysicalSector: u32,
    pub VolumeSerialNumber: i64,
    pub NumberSectors: i64,
    pub TotalClusters: i64,
    pub FreeClusters: i64,
    pub TotalReserved: i64,
    pub BytesPerSector: u32,
    pub BytesPerCluster: u32,
    pub MaximumSizeOfResidentFile: i64,
    pub FastTierDataFillRatio: u16,
    pub SlowTierDataFillRatio: u16,
    pub DestagesFastTierToSlowTierRate: u32,
    pub Reserved: [i64; 9],
}
impl ::core::marker::Copy for REFS_VOLUME_DATA_BUFFER {}
impl ::core::clone::Clone for REFS_VOLUME_DATA_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REFS_VOLUME_DATA_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REFS_VOLUME_DATA_BUFFER")
            .field("ByteCount", &self.ByteCount)
            .field("MajorVersion", &self.MajorVersion)
            .field("MinorVersion", &self.MinorVersion)
            .field("BytesPerPhysicalSector", &self.BytesPerPhysicalSector)
            .field("VolumeSerialNumber", &self.VolumeSerialNumber)
            .field("NumberSectors", &self.NumberSectors)
            .field("TotalClusters", &self.TotalClusters)
            .field("FreeClusters", &self.FreeClusters)
            .field("TotalReserved", &self.TotalReserved)
            .field("BytesPerSector", &self.BytesPerSector)
            .field("BytesPerCluster", &self.BytesPerCluster)
            .field("MaximumSizeOfResidentFile", &self.MaximumSizeOfResidentFile)
            .field("FastTierDataFillRatio", &self.FastTierDataFillRatio)
            .field("SlowTierDataFillRatio", &self.SlowTierDataFillRatio)
            .field("DestagesFastTierToSlowTierRate", &self.DestagesFastTierToSlowTierRate)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
impl ::windows_core::TypeKind for REFS_VOLUME_DATA_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REFS_VOLUME_DATA_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.ByteCount == other.ByteCount
            && self.MajorVersion == other.MajorVersion
            && self.MinorVersion == other.MinorVersion
            && self.BytesPerPhysicalSector == other.BytesPerPhysicalSector
            && self.VolumeSerialNumber == other.VolumeSerialNumber
            && self.NumberSectors == other.NumberSectors
            && self.TotalClusters == other.TotalClusters
            && self.FreeClusters == other.FreeClusters
            && self.TotalReserved == other.TotalReserved
            && self.BytesPerSector == other.BytesPerSector
            && self.BytesPerCluster == other.BytesPerCluster
            && self.MaximumSizeOfResidentFile == other.MaximumSizeOfResidentFile
            && self.FastTierDataFillRatio == other.FastTierDataFillRatio
            && self.SlowTierDataFillRatio == other.SlowTierDataFillRatio
            && self.DestagesFastTierToSlowTierRate == other.DestagesFastTierToSlowTierRate
            && self.Reserved == other.Reserved
    }
}
impl ::core::cmp::Eq for REFS_VOLUME_DATA_BUFFER {}
impl ::core::default::Default for REFS_VOLUME_DATA_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REMOTE_LINK_TRACKING_INFORMATION {
    pub TargetFileObject: *mut ::core::ffi::c_void,
    pub TargetLinkTrackingInformationLength: u32,
    pub TargetLinkTrackingInformationBuffer: [u8; 1],
}
impl ::core::marker::Copy for REMOTE_LINK_TRACKING_INFORMATION {}
impl ::core::clone::Clone for REMOTE_LINK_TRACKING_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REMOTE_LINK_TRACKING_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REMOTE_LINK_TRACKING_INFORMATION").field("TargetFileObject", &self.TargetFileObject).field("TargetLinkTrackingInformationLength", &self.TargetLinkTrackingInformationLength).field("TargetLinkTrackingInformationBuffer", &self.TargetLinkTrackingInformationBuffer).finish()
    }
}
impl ::windows_core::TypeKind for REMOTE_LINK_TRACKING_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REMOTE_LINK_TRACKING_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.TargetFileObject == other.TargetFileObject && self.TargetLinkTrackingInformationLength == other.TargetLinkTrackingInformationLength && self.TargetLinkTrackingInformationBuffer == other.TargetLinkTrackingInformationBuffer
    }
}
impl ::core::cmp::Eq for REMOTE_LINK_TRACKING_INFORMATION {}
impl ::core::default::Default for REMOTE_LINK_TRACKING_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REPAIR_COPIES_INPUT {
    pub Size: u32,
    pub Flags: u32,
    pub FileOffset: i64,
    pub Length: u32,
    pub SourceCopy: u32,
    pub NumberOfRepairCopies: u32,
    pub RepairCopies: [u32; 1],
}
impl ::core::marker::Copy for REPAIR_COPIES_INPUT {}
impl ::core::clone::Clone for REPAIR_COPIES_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REPAIR_COPIES_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REPAIR_COPIES_INPUT").field("Size", &self.Size).field("Flags", &self.Flags).field("FileOffset", &self.FileOffset).field("Length", &self.Length).field("SourceCopy", &self.SourceCopy).field("NumberOfRepairCopies", &self.NumberOfRepairCopies).field("RepairCopies", &self.RepairCopies).finish()
    }
}
impl ::windows_core::TypeKind for REPAIR_COPIES_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REPAIR_COPIES_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.Flags == other.Flags && self.FileOffset == other.FileOffset && self.Length == other.Length && self.SourceCopy == other.SourceCopy && self.NumberOfRepairCopies == other.NumberOfRepairCopies && self.RepairCopies == other.RepairCopies
    }
}
impl ::core::cmp::Eq for REPAIR_COPIES_INPUT {}
impl ::core::default::Default for REPAIR_COPIES_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct REPAIR_COPIES_OUTPUT {
    pub Size: u32,
    pub Status: super::super::super::Win32::Foundation::NTSTATUS,
    pub ResumeFileOffset: i64,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for REPAIR_COPIES_OUTPUT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for REPAIR_COPIES_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for REPAIR_COPIES_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REPAIR_COPIES_OUTPUT").field("Size", &self.Size).field("Status", &self.Status).field("ResumeFileOffset", &self.ResumeFileOffset).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for REPAIR_COPIES_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for REPAIR_COPIES_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.Status == other.Status && self.ResumeFileOffset == other.ResumeFileOffset
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for REPAIR_COPIES_OUTPUT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for REPAIR_COPIES_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REPARSE_DATA_BUFFER {
    pub ReparseTag: u32,
    pub ReparseDataLength: u16,
    pub Reserved: u16,
    pub Anonymous: REPARSE_DATA_BUFFER_0,
}
impl ::core::marker::Copy for REPARSE_DATA_BUFFER {}
impl ::core::clone::Clone for REPARSE_DATA_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for REPARSE_DATA_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for REPARSE_DATA_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub union REPARSE_DATA_BUFFER_0 {
    pub SymbolicLinkReparseBuffer: REPARSE_DATA_BUFFER_0_2,
    pub MountPointReparseBuffer: REPARSE_DATA_BUFFER_0_1,
    pub GenericReparseBuffer: REPARSE_DATA_BUFFER_0_0,
}
impl ::core::marker::Copy for REPARSE_DATA_BUFFER_0 {}
impl ::core::clone::Clone for REPARSE_DATA_BUFFER_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for REPARSE_DATA_BUFFER_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for REPARSE_DATA_BUFFER_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REPARSE_DATA_BUFFER_0_0 {
    pub DataBuffer: [u8; 1],
}
impl ::core::marker::Copy for REPARSE_DATA_BUFFER_0_0 {}
impl ::core::clone::Clone for REPARSE_DATA_BUFFER_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REPARSE_DATA_BUFFER_0_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REPARSE_DATA_BUFFER_0_0").field("DataBuffer", &self.DataBuffer).finish()
    }
}
impl ::windows_core::TypeKind for REPARSE_DATA_BUFFER_0_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REPARSE_DATA_BUFFER_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.DataBuffer == other.DataBuffer
    }
}
impl ::core::cmp::Eq for REPARSE_DATA_BUFFER_0_0 {}
impl ::core::default::Default for REPARSE_DATA_BUFFER_0_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REPARSE_DATA_BUFFER_0_1 {
    pub SubstituteNameOffset: u16,
    pub SubstituteNameLength: u16,
    pub PrintNameOffset: u16,
    pub PrintNameLength: u16,
    pub PathBuffer: [u16; 1],
}
impl ::core::marker::Copy for REPARSE_DATA_BUFFER_0_1 {}
impl ::core::clone::Clone for REPARSE_DATA_BUFFER_0_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REPARSE_DATA_BUFFER_0_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REPARSE_DATA_BUFFER_0_1").field("SubstituteNameOffset", &self.SubstituteNameOffset).field("SubstituteNameLength", &self.SubstituteNameLength).field("PrintNameOffset", &self.PrintNameOffset).field("PrintNameLength", &self.PrintNameLength).field("PathBuffer", &self.PathBuffer).finish()
    }
}
impl ::windows_core::TypeKind for REPARSE_DATA_BUFFER_0_1 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REPARSE_DATA_BUFFER_0_1 {
    fn eq(&self, other: &Self) -> bool {
        self.SubstituteNameOffset == other.SubstituteNameOffset && self.SubstituteNameLength == other.SubstituteNameLength && self.PrintNameOffset == other.PrintNameOffset && self.PrintNameLength == other.PrintNameLength && self.PathBuffer == other.PathBuffer
    }
}
impl ::core::cmp::Eq for REPARSE_DATA_BUFFER_0_1 {}
impl ::core::default::Default for REPARSE_DATA_BUFFER_0_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REPARSE_DATA_BUFFER_0_2 {
    pub SubstituteNameOffset: u16,
    pub SubstituteNameLength: u16,
    pub PrintNameOffset: u16,
    pub PrintNameLength: u16,
    pub Flags: u32,
    pub PathBuffer: [u16; 1],
}
impl ::core::marker::Copy for REPARSE_DATA_BUFFER_0_2 {}
impl ::core::clone::Clone for REPARSE_DATA_BUFFER_0_2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REPARSE_DATA_BUFFER_0_2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REPARSE_DATA_BUFFER_0_2").field("SubstituteNameOffset", &self.SubstituteNameOffset).field("SubstituteNameLength", &self.SubstituteNameLength).field("PrintNameOffset", &self.PrintNameOffset).field("PrintNameLength", &self.PrintNameLength).field("Flags", &self.Flags).field("PathBuffer", &self.PathBuffer).finish()
    }
}
impl ::windows_core::TypeKind for REPARSE_DATA_BUFFER_0_2 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REPARSE_DATA_BUFFER_0_2 {
    fn eq(&self, other: &Self) -> bool {
        self.SubstituteNameOffset == other.SubstituteNameOffset && self.SubstituteNameLength == other.SubstituteNameLength && self.PrintNameOffset == other.PrintNameOffset && self.PrintNameLength == other.PrintNameLength && self.Flags == other.Flags && self.PathBuffer == other.PathBuffer
    }
}
impl ::core::cmp::Eq for REPARSE_DATA_BUFFER_0_2 {}
impl ::core::default::Default for REPARSE_DATA_BUFFER_0_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REPARSE_DATA_BUFFER_EX {
    pub Flags: u32,
    pub ExistingReparseTag: u32,
    pub ExistingReparseGuid: ::windows_core::GUID,
    pub Reserved: u64,
    pub Anonymous: REPARSE_DATA_BUFFER_EX_0,
}
impl ::core::marker::Copy for REPARSE_DATA_BUFFER_EX {}
impl ::core::clone::Clone for REPARSE_DATA_BUFFER_EX {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for REPARSE_DATA_BUFFER_EX {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for REPARSE_DATA_BUFFER_EX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub union REPARSE_DATA_BUFFER_EX_0 {
    pub ReparseDataBuffer: REPARSE_DATA_BUFFER,
    pub ReparseGuidDataBuffer: REPARSE_GUID_DATA_BUFFER,
}
impl ::core::marker::Copy for REPARSE_DATA_BUFFER_EX_0 {}
impl ::core::clone::Clone for REPARSE_DATA_BUFFER_EX_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for REPARSE_DATA_BUFFER_EX_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for REPARSE_DATA_BUFFER_EX_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REPARSE_GUID_DATA_BUFFER {
    pub ReparseTag: u32,
    pub ReparseDataLength: u16,
    pub Reserved: u16,
    pub ReparseGuid: ::windows_core::GUID,
    pub GenericReparseBuffer: REPARSE_GUID_DATA_BUFFER_0,
}
impl ::core::marker::Copy for REPARSE_GUID_DATA_BUFFER {}
impl ::core::clone::Clone for REPARSE_GUID_DATA_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REPARSE_GUID_DATA_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REPARSE_GUID_DATA_BUFFER").field("ReparseTag", &self.ReparseTag).field("ReparseDataLength", &self.ReparseDataLength).field("Reserved", &self.Reserved).field("ReparseGuid", &self.ReparseGuid).field("GenericReparseBuffer", &self.GenericReparseBuffer).finish()
    }
}
impl ::windows_core::TypeKind for REPARSE_GUID_DATA_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REPARSE_GUID_DATA_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.ReparseTag == other.ReparseTag && self.ReparseDataLength == other.ReparseDataLength && self.Reserved == other.Reserved && self.ReparseGuid == other.ReparseGuid && self.GenericReparseBuffer == other.GenericReparseBuffer
    }
}
impl ::core::cmp::Eq for REPARSE_GUID_DATA_BUFFER {}
impl ::core::default::Default for REPARSE_GUID_DATA_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REPARSE_GUID_DATA_BUFFER_0 {
    pub DataBuffer: [u8; 1],
}
impl ::core::marker::Copy for REPARSE_GUID_DATA_BUFFER_0 {}
impl ::core::clone::Clone for REPARSE_GUID_DATA_BUFFER_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REPARSE_GUID_DATA_BUFFER_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REPARSE_GUID_DATA_BUFFER_0").field("DataBuffer", &self.DataBuffer).finish()
    }
}
impl ::windows_core::TypeKind for REPARSE_GUID_DATA_BUFFER_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REPARSE_GUID_DATA_BUFFER_0 {
    fn eq(&self, other: &Self) -> bool {
        self.DataBuffer == other.DataBuffer
    }
}
impl ::core::cmp::Eq for REPARSE_GUID_DATA_BUFFER_0 {}
impl ::core::default::Default for REPARSE_GUID_DATA_BUFFER_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REPARSE_INDEX_KEY {
    pub FileReparseTag: u32,
    pub FileId: i64,
}
impl ::core::marker::Copy for REPARSE_INDEX_KEY {}
impl ::core::clone::Clone for REPARSE_INDEX_KEY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for REPARSE_INDEX_KEY {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for REPARSE_INDEX_KEY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REQUEST_OPLOCK_INPUT_BUFFER {
    pub StructureVersion: u16,
    pub StructureLength: u16,
    pub RequestedOplockLevel: u32,
    pub Flags: u32,
}
impl ::core::marker::Copy for REQUEST_OPLOCK_INPUT_BUFFER {}
impl ::core::clone::Clone for REQUEST_OPLOCK_INPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REQUEST_OPLOCK_INPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REQUEST_OPLOCK_INPUT_BUFFER").field("StructureVersion", &self.StructureVersion).field("StructureLength", &self.StructureLength).field("RequestedOplockLevel", &self.RequestedOplockLevel).field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for REQUEST_OPLOCK_INPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REQUEST_OPLOCK_INPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.StructureVersion == other.StructureVersion && self.StructureLength == other.StructureLength && self.RequestedOplockLevel == other.RequestedOplockLevel && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for REQUEST_OPLOCK_INPUT_BUFFER {}
impl ::core::default::Default for REQUEST_OPLOCK_INPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REQUEST_OPLOCK_OUTPUT_BUFFER {
    pub StructureVersion: u16,
    pub StructureLength: u16,
    pub OriginalOplockLevel: u32,
    pub NewOplockLevel: u32,
    pub Flags: u32,
    pub AccessMode: u32,
    pub ShareMode: u16,
}
impl ::core::marker::Copy for REQUEST_OPLOCK_OUTPUT_BUFFER {}
impl ::core::clone::Clone for REQUEST_OPLOCK_OUTPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REQUEST_OPLOCK_OUTPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REQUEST_OPLOCK_OUTPUT_BUFFER").field("StructureVersion", &self.StructureVersion).field("StructureLength", &self.StructureLength).field("OriginalOplockLevel", &self.OriginalOplockLevel).field("NewOplockLevel", &self.NewOplockLevel).field("Flags", &self.Flags).field("AccessMode", &self.AccessMode).field("ShareMode", &self.ShareMode).finish()
    }
}
impl ::windows_core::TypeKind for REQUEST_OPLOCK_OUTPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REQUEST_OPLOCK_OUTPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.StructureVersion == other.StructureVersion && self.StructureLength == other.StructureLength && self.OriginalOplockLevel == other.OriginalOplockLevel && self.NewOplockLevel == other.NewOplockLevel && self.Flags == other.Flags && self.AccessMode == other.AccessMode && self.ShareMode == other.ShareMode
    }
}
impl ::core::cmp::Eq for REQUEST_OPLOCK_OUTPUT_BUFFER {}
impl ::core::default::Default for REQUEST_OPLOCK_OUTPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct REQUEST_RAW_ENCRYPTED_DATA {
    pub FileOffset: i64,
    pub Length: u32,
}
impl ::core::marker::Copy for REQUEST_RAW_ENCRYPTED_DATA {}
impl ::core::clone::Clone for REQUEST_RAW_ENCRYPTED_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for REQUEST_RAW_ENCRYPTED_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("REQUEST_RAW_ENCRYPTED_DATA").field("FileOffset", &self.FileOffset).field("Length", &self.Length).finish()
    }
}
impl ::windows_core::TypeKind for REQUEST_RAW_ENCRYPTED_DATA {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for REQUEST_RAW_ENCRYPTED_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.FileOffset == other.FileOffset && self.Length == other.Length
    }
}
impl ::core::cmp::Eq for REQUEST_RAW_ENCRYPTED_DATA {}
impl ::core::default::Default for REQUEST_RAW_ENCRYPTED_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER {
    pub ExtentCount: u32,
    pub StartingVcn: i64,
    pub Extents: [RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER_0; 1],
}
impl ::core::marker::Copy for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER {}
impl ::core::clone::Clone for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER").field("ExtentCount", &self.ExtentCount).field("StartingVcn", &self.StartingVcn).field("Extents", &self.Extents).finish()
    }
}
impl ::windows_core::TypeKind for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.ExtentCount == other.ExtentCount && self.StartingVcn == other.StartingVcn && self.Extents == other.Extents
    }
}
impl ::core::cmp::Eq for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER {}
impl ::core::default::Default for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER_0 {
    pub NextVcn: i64,
    pub Lcn: i64,
    pub ReferenceCount: u32,
}
impl ::core::marker::Copy for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER_0 {}
impl ::core::clone::Clone for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER_0").field("NextVcn", &self.NextVcn).field("Lcn", &self.Lcn).field("ReferenceCount", &self.ReferenceCount).finish()
    }
}
impl ::windows_core::TypeKind for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER_0 {
    fn eq(&self, other: &Self) -> bool {
        self.NextVcn == other.NextVcn && self.Lcn == other.Lcn && self.ReferenceCount == other.ReferenceCount
    }
}
impl ::core::cmp::Eq for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER_0 {}
impl ::core::default::Default for RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct RETRIEVAL_POINTERS_BUFFER {
    pub ExtentCount: u32,
    pub StartingVcn: i64,
    pub Extents: [RETRIEVAL_POINTERS_BUFFER_0; 1],
}
impl ::core::marker::Copy for RETRIEVAL_POINTERS_BUFFER {}
impl ::core::clone::Clone for RETRIEVAL_POINTERS_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for RETRIEVAL_POINTERS_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("RETRIEVAL_POINTERS_BUFFER").field("ExtentCount", &self.ExtentCount).field("StartingVcn", &self.StartingVcn).field("Extents", &self.Extents).finish()
    }
}
impl ::windows_core::TypeKind for RETRIEVAL_POINTERS_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for RETRIEVAL_POINTERS_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.ExtentCount == other.ExtentCount && self.StartingVcn == other.StartingVcn && self.Extents == other.Extents
    }
}
impl ::core::cmp::Eq for RETRIEVAL_POINTERS_BUFFER {}
impl ::core::default::Default for RETRIEVAL_POINTERS_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct RETRIEVAL_POINTERS_BUFFER_0 {
    pub NextVcn: i64,
    pub Lcn: i64,
}
impl ::core::marker::Copy for RETRIEVAL_POINTERS_BUFFER_0 {}
impl ::core::clone::Clone for RETRIEVAL_POINTERS_BUFFER_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for RETRIEVAL_POINTERS_BUFFER_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("RETRIEVAL_POINTERS_BUFFER_0").field("NextVcn", &self.NextVcn).field("Lcn", &self.Lcn).finish()
    }
}
impl ::windows_core::TypeKind for RETRIEVAL_POINTERS_BUFFER_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for RETRIEVAL_POINTERS_BUFFER_0 {
    fn eq(&self, other: &Self) -> bool {
        self.NextVcn == other.NextVcn && self.Lcn == other.Lcn
    }
}
impl ::core::cmp::Eq for RETRIEVAL_POINTERS_BUFFER_0 {}
impl ::core::default::Default for RETRIEVAL_POINTERS_BUFFER_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct RETRIEVAL_POINTER_BASE {
    pub FileAreaOffset: i64,
}
impl ::core::marker::Copy for RETRIEVAL_POINTER_BASE {}
impl ::core::clone::Clone for RETRIEVAL_POINTER_BASE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for RETRIEVAL_POINTER_BASE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("RETRIEVAL_POINTER_BASE").field("FileAreaOffset", &self.FileAreaOffset).finish()
    }
}
impl ::windows_core::TypeKind for RETRIEVAL_POINTER_BASE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for RETRIEVAL_POINTER_BASE {
    fn eq(&self, other: &Self) -> bool {
        self.FileAreaOffset == other.FileAreaOffset
    }
}
impl ::core::cmp::Eq for RETRIEVAL_POINTER_BASE {}
impl ::core::default::Default for RETRIEVAL_POINTER_BASE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct RETRIEVAL_POINTER_COUNT {
    pub ExtentCount: u32,
}
impl ::core::marker::Copy for RETRIEVAL_POINTER_COUNT {}
impl ::core::clone::Clone for RETRIEVAL_POINTER_COUNT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for RETRIEVAL_POINTER_COUNT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("RETRIEVAL_POINTER_COUNT").field("ExtentCount", &self.ExtentCount).finish()
    }
}
impl ::windows_core::TypeKind for RETRIEVAL_POINTER_COUNT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for RETRIEVAL_POINTER_COUNT {
    fn eq(&self, other: &Self) -> bool {
        self.ExtentCount == other.ExtentCount
    }
}
impl ::core::cmp::Eq for RETRIEVAL_POINTER_COUNT {}
impl ::core::default::Default for RETRIEVAL_POINTER_COUNT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct RKF_BYPASS_ECP_CONTEXT {
    pub Reserved: i32,
    pub Version: i32,
}
impl ::core::marker::Copy for RKF_BYPASS_ECP_CONTEXT {}
impl ::core::clone::Clone for RKF_BYPASS_ECP_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for RKF_BYPASS_ECP_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("RKF_BYPASS_ECP_CONTEXT").field("Reserved", &self.Reserved).field("Version", &self.Version).finish()
    }
}
impl ::windows_core::TypeKind for RKF_BYPASS_ECP_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for RKF_BYPASS_ECP_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.Reserved == other.Reserved && self.Version == other.Version
    }
}
impl ::core::cmp::Eq for RKF_BYPASS_ECP_CONTEXT {}
impl ::core::default::Default for RKF_BYPASS_ECP_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct RTL_HEAP_MEMORY_LIMIT_DATA {
    pub CommitLimitBytes: usize,
    pub CommitLimitFailureCode: usize,
    pub MaxAllocationSizeBytes: usize,
    pub AllocationLimitFailureCode: usize,
}
impl ::core::marker::Copy for RTL_HEAP_MEMORY_LIMIT_DATA {}
impl ::core::clone::Clone for RTL_HEAP_MEMORY_LIMIT_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for RTL_HEAP_MEMORY_LIMIT_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("RTL_HEAP_MEMORY_LIMIT_DATA").field("CommitLimitBytes", &self.CommitLimitBytes).field("CommitLimitFailureCode", &self.CommitLimitFailureCode).field("MaxAllocationSizeBytes", &self.MaxAllocationSizeBytes).field("AllocationLimitFailureCode", &self.AllocationLimitFailureCode).finish()
    }
}
impl ::windows_core::TypeKind for RTL_HEAP_MEMORY_LIMIT_DATA {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for RTL_HEAP_MEMORY_LIMIT_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.CommitLimitBytes == other.CommitLimitBytes && self.CommitLimitFailureCode == other.CommitLimitFailureCode && self.MaxAllocationSizeBytes == other.MaxAllocationSizeBytes && self.AllocationLimitFailureCode == other.AllocationLimitFailureCode
    }
}
impl ::core::cmp::Eq for RTL_HEAP_MEMORY_LIMIT_DATA {}
impl ::core::default::Default for RTL_HEAP_MEMORY_LIMIT_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct RTL_HEAP_MEMORY_LIMIT_INFO {
    pub Version: u32,
    pub Data: RTL_HEAP_MEMORY_LIMIT_DATA,
}
impl ::core::marker::Copy for RTL_HEAP_MEMORY_LIMIT_INFO {}
impl ::core::clone::Clone for RTL_HEAP_MEMORY_LIMIT_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for RTL_HEAP_MEMORY_LIMIT_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("RTL_HEAP_MEMORY_LIMIT_INFO").field("Version", &self.Version).field("Data", &self.Data).finish()
    }
}
impl ::windows_core::TypeKind for RTL_HEAP_MEMORY_LIMIT_INFO {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for RTL_HEAP_MEMORY_LIMIT_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Data == other.Data
    }
}
impl ::core::cmp::Eq for RTL_HEAP_MEMORY_LIMIT_INFO {}
impl ::core::default::Default for RTL_HEAP_MEMORY_LIMIT_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct RTL_HEAP_PARAMETERS {
    pub Length: u32,
    pub SegmentReserve: usize,
    pub SegmentCommit: usize,
    pub DeCommitFreeBlockThreshold: usize,
    pub DeCommitTotalFreeThreshold: usize,
    pub MaximumAllocationSize: usize,
    pub VirtualMemoryThreshold: usize,
    pub InitialCommit: usize,
    pub InitialReserve: usize,
    pub CommitRoutine: PRTL_HEAP_COMMIT_ROUTINE,
    pub Reserved: [usize; 2],
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for RTL_HEAP_PARAMETERS {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for RTL_HEAP_PARAMETERS {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for RTL_HEAP_PARAMETERS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("RTL_HEAP_PARAMETERS")
            .field("Length", &self.Length)
            .field("SegmentReserve", &self.SegmentReserve)
            .field("SegmentCommit", &self.SegmentCommit)
            .field("DeCommitFreeBlockThreshold", &self.DeCommitFreeBlockThreshold)
            .field("DeCommitTotalFreeThreshold", &self.DeCommitTotalFreeThreshold)
            .field("MaximumAllocationSize", &self.MaximumAllocationSize)
            .field("VirtualMemoryThreshold", &self.VirtualMemoryThreshold)
            .field("InitialCommit", &self.InitialCommit)
            .field("InitialReserve", &self.InitialReserve)
            .field("Reserved", &self.Reserved)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for RTL_HEAP_PARAMETERS {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for RTL_HEAP_PARAMETERS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct RTL_NLS_STATE {
    pub DefaultAcpTableInfo: CPTABLEINFO,
    pub DefaultOemTableInfo: CPTABLEINFO,
    pub ActiveCodePageData: *mut u16,
    pub OemCodePageData: *mut u16,
    pub LeadByteInfo: *mut u16,
    pub OemLeadByteInfo: *mut u16,
    pub CaseMappingData: *mut u16,
    pub UnicodeUpcaseTable844: *mut u16,
    pub UnicodeLowercaseTable844: *mut u16,
}
impl ::core::marker::Copy for RTL_NLS_STATE {}
impl ::core::clone::Clone for RTL_NLS_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for RTL_NLS_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("RTL_NLS_STATE")
            .field("DefaultAcpTableInfo", &self.DefaultAcpTableInfo)
            .field("DefaultOemTableInfo", &self.DefaultOemTableInfo)
            .field("ActiveCodePageData", &self.ActiveCodePageData)
            .field("OemCodePageData", &self.OemCodePageData)
            .field("LeadByteInfo", &self.LeadByteInfo)
            .field("OemLeadByteInfo", &self.OemLeadByteInfo)
            .field("CaseMappingData", &self.CaseMappingData)
            .field("UnicodeUpcaseTable844", &self.UnicodeUpcaseTable844)
            .field("UnicodeLowercaseTable844", &self.UnicodeLowercaseTable844)
            .finish()
    }
}
impl ::windows_core::TypeKind for RTL_NLS_STATE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for RTL_NLS_STATE {
    fn eq(&self, other: &Self) -> bool {
        self.DefaultAcpTableInfo == other.DefaultAcpTableInfo && self.DefaultOemTableInfo == other.DefaultOemTableInfo && self.ActiveCodePageData == other.ActiveCodePageData && self.OemCodePageData == other.OemCodePageData && self.LeadByteInfo == other.LeadByteInfo && self.OemLeadByteInfo == other.OemLeadByteInfo && self.CaseMappingData == other.CaseMappingData && self.UnicodeUpcaseTable844 == other.UnicodeUpcaseTable844 && self.UnicodeLowercaseTable844 == other.UnicodeLowercaseTable844
    }
}
impl ::core::cmp::Eq for RTL_NLS_STATE {}
impl ::core::default::Default for RTL_NLS_STATE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct RTL_SEGMENT_HEAP_MEMORY_SOURCE {
    pub Flags: u32,
    pub MemoryTypeMask: u32,
    pub NumaNode: u32,
    pub Anonymous: RTL_SEGMENT_HEAP_MEMORY_SOURCE_0,
    pub Reserved: [usize; 2],
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for RTL_SEGMENT_HEAP_MEMORY_SOURCE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for RTL_SEGMENT_HEAP_MEMORY_SOURCE {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for RTL_SEGMENT_HEAP_MEMORY_SOURCE {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for RTL_SEGMENT_HEAP_MEMORY_SOURCE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub union RTL_SEGMENT_HEAP_MEMORY_SOURCE_0 {
    pub PartitionHandle: super::super::super::Win32::Foundation::HANDLE,
    pub Callbacks: *mut RTL_SEGMENT_HEAP_VA_CALLBACKS,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for RTL_SEGMENT_HEAP_MEMORY_SOURCE_0 {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for RTL_SEGMENT_HEAP_MEMORY_SOURCE_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for RTL_SEGMENT_HEAP_MEMORY_SOURCE_0 {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for RTL_SEGMENT_HEAP_MEMORY_SOURCE_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct RTL_SEGMENT_HEAP_PARAMETERS {
    pub Version: u16,
    pub Size: u16,
    pub Flags: u32,
    pub MemorySource: RTL_SEGMENT_HEAP_MEMORY_SOURCE,
    pub Reserved: [usize; 4],
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for RTL_SEGMENT_HEAP_PARAMETERS {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for RTL_SEGMENT_HEAP_PARAMETERS {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for RTL_SEGMENT_HEAP_PARAMETERS {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for RTL_SEGMENT_HEAP_PARAMETERS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct RTL_SEGMENT_HEAP_VA_CALLBACKS {
    pub CallbackContext: super::super::super::Win32::Foundation::HANDLE,
    pub AllocateVirtualMemory: PALLOCATE_VIRTUAL_MEMORY_EX_CALLBACK,
    pub FreeVirtualMemory: PFREE_VIRTUAL_MEMORY_EX_CALLBACK,
    pub QueryVirtualMemory: PQUERY_VIRTUAL_MEMORY_CALLBACK,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for RTL_SEGMENT_HEAP_VA_CALLBACKS {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for RTL_SEGMENT_HEAP_VA_CALLBACKS {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for RTL_SEGMENT_HEAP_VA_CALLBACKS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("RTL_SEGMENT_HEAP_VA_CALLBACKS").field("CallbackContext", &self.CallbackContext).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for RTL_SEGMENT_HEAP_VA_CALLBACKS {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for RTL_SEGMENT_HEAP_VA_CALLBACKS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SCRUB_DATA_INPUT {
    pub Size: u32,
    pub Flags: u32,
    pub MaximumIos: u32,
    pub ObjectId: [u32; 4],
    pub Reserved: [u32; 41],
    pub ResumeContext: [u8; 1040],
}
impl ::core::marker::Copy for SCRUB_DATA_INPUT {}
impl ::core::clone::Clone for SCRUB_DATA_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SCRUB_DATA_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SCRUB_DATA_INPUT").field("Size", &self.Size).field("Flags", &self.Flags).field("MaximumIos", &self.MaximumIos).field("ObjectId", &self.ObjectId).field("Reserved", &self.Reserved).field("ResumeContext", &self.ResumeContext).finish()
    }
}
impl ::windows_core::TypeKind for SCRUB_DATA_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SCRUB_DATA_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.Flags == other.Flags && self.MaximumIos == other.MaximumIos && self.ObjectId == other.ObjectId && self.Reserved == other.Reserved && self.ResumeContext == other.ResumeContext
    }
}
impl ::core::cmp::Eq for SCRUB_DATA_INPUT {}
impl ::core::default::Default for SCRUB_DATA_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SCRUB_DATA_OUTPUT {
    pub Size: u32,
    pub Flags: u32,
    pub Status: u32,
    pub ErrorFileOffset: u64,
    pub ErrorLength: u64,
    pub NumberOfBytesRepaired: u64,
    pub NumberOfBytesFailed: u64,
    pub InternalFileReference: u64,
    pub ResumeContextLength: u16,
    pub ParityExtentDataOffset: u16,
    pub Reserved: [u32; 9],
    pub NumberOfMetadataBytesProcessed: u64,
    pub NumberOfDataBytesProcessed: u64,
    pub TotalNumberOfMetadataBytesInUse: u64,
    pub TotalNumberOfDataBytesInUse: u64,
    pub DataBytesSkippedDueToNoAllocation: u64,
    pub DataBytesSkippedDueToInvalidRun: u64,
    pub DataBytesSkippedDueToIntegrityStream: u64,
    pub DataBytesSkippedDueToRegionBeingClean: u64,
    pub DataBytesSkippedDueToLockConflict: u64,
    pub DataBytesSkippedDueToNoScrubDataFlag: u64,
    pub DataBytesSkippedDueToNoScrubNonIntegrityStreamFlag: u64,
    pub DataBytesScrubbed: u64,
    pub ResumeContext: [u8; 1040],
}
impl ::core::marker::Copy for SCRUB_DATA_OUTPUT {}
impl ::core::clone::Clone for SCRUB_DATA_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SCRUB_DATA_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SCRUB_DATA_OUTPUT")
            .field("Size", &self.Size)
            .field("Flags", &self.Flags)
            .field("Status", &self.Status)
            .field("ErrorFileOffset", &self.ErrorFileOffset)
            .field("ErrorLength", &self.ErrorLength)
            .field("NumberOfBytesRepaired", &self.NumberOfBytesRepaired)
            .field("NumberOfBytesFailed", &self.NumberOfBytesFailed)
            .field("InternalFileReference", &self.InternalFileReference)
            .field("ResumeContextLength", &self.ResumeContextLength)
            .field("ParityExtentDataOffset", &self.ParityExtentDataOffset)
            .field("Reserved", &self.Reserved)
            .field("NumberOfMetadataBytesProcessed", &self.NumberOfMetadataBytesProcessed)
            .field("NumberOfDataBytesProcessed", &self.NumberOfDataBytesProcessed)
            .field("TotalNumberOfMetadataBytesInUse", &self.TotalNumberOfMetadataBytesInUse)
            .field("TotalNumberOfDataBytesInUse", &self.TotalNumberOfDataBytesInUse)
            .field("DataBytesSkippedDueToNoAllocation", &self.DataBytesSkippedDueToNoAllocation)
            .field("DataBytesSkippedDueToInvalidRun", &self.DataBytesSkippedDueToInvalidRun)
            .field("DataBytesSkippedDueToIntegrityStream", &self.DataBytesSkippedDueToIntegrityStream)
            .field("DataBytesSkippedDueToRegionBeingClean", &self.DataBytesSkippedDueToRegionBeingClean)
            .field("DataBytesSkippedDueToLockConflict", &self.DataBytesSkippedDueToLockConflict)
            .field("DataBytesSkippedDueToNoScrubDataFlag", &self.DataBytesSkippedDueToNoScrubDataFlag)
            .field("DataBytesSkippedDueToNoScrubNonIntegrityStreamFlag", &self.DataBytesSkippedDueToNoScrubNonIntegrityStreamFlag)
            .field("DataBytesScrubbed", &self.DataBytesScrubbed)
            .field("ResumeContext", &self.ResumeContext)
            .finish()
    }
}
impl ::windows_core::TypeKind for SCRUB_DATA_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SCRUB_DATA_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size
            && self.Flags == other.Flags
            && self.Status == other.Status
            && self.ErrorFileOffset == other.ErrorFileOffset
            && self.ErrorLength == other.ErrorLength
            && self.NumberOfBytesRepaired == other.NumberOfBytesRepaired
            && self.NumberOfBytesFailed == other.NumberOfBytesFailed
            && self.InternalFileReference == other.InternalFileReference
            && self.ResumeContextLength == other.ResumeContextLength
            && self.ParityExtentDataOffset == other.ParityExtentDataOffset
            && self.Reserved == other.Reserved
            && self.NumberOfMetadataBytesProcessed == other.NumberOfMetadataBytesProcessed
            && self.NumberOfDataBytesProcessed == other.NumberOfDataBytesProcessed
            && self.TotalNumberOfMetadataBytesInUse == other.TotalNumberOfMetadataBytesInUse
            && self.TotalNumberOfDataBytesInUse == other.TotalNumberOfDataBytesInUse
            && self.DataBytesSkippedDueToNoAllocation == other.DataBytesSkippedDueToNoAllocation
            && self.DataBytesSkippedDueToInvalidRun == other.DataBytesSkippedDueToInvalidRun
            && self.DataBytesSkippedDueToIntegrityStream == other.DataBytesSkippedDueToIntegrityStream
            && self.DataBytesSkippedDueToRegionBeingClean == other.DataBytesSkippedDueToRegionBeingClean
            && self.DataBytesSkippedDueToLockConflict == other.DataBytesSkippedDueToLockConflict
            && self.DataBytesSkippedDueToNoScrubDataFlag == other.DataBytesSkippedDueToNoScrubDataFlag
            && self.DataBytesSkippedDueToNoScrubNonIntegrityStreamFlag == other.DataBytesSkippedDueToNoScrubNonIntegrityStreamFlag
            && self.DataBytesScrubbed == other.DataBytesScrubbed
            && self.ResumeContext == other.ResumeContext
    }
}
impl ::core::cmp::Eq for SCRUB_DATA_OUTPUT {}
impl ::core::default::Default for SCRUB_DATA_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SCRUB_PARITY_EXTENT {
    pub Offset: i64,
    pub Length: u64,
}
impl ::core::marker::Copy for SCRUB_PARITY_EXTENT {}
impl ::core::clone::Clone for SCRUB_PARITY_EXTENT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SCRUB_PARITY_EXTENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SCRUB_PARITY_EXTENT").field("Offset", &self.Offset).field("Length", &self.Length).finish()
    }
}
impl ::windows_core::TypeKind for SCRUB_PARITY_EXTENT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SCRUB_PARITY_EXTENT {
    fn eq(&self, other: &Self) -> bool {
        self.Offset == other.Offset && self.Length == other.Length
    }
}
impl ::core::cmp::Eq for SCRUB_PARITY_EXTENT {}
impl ::core::default::Default for SCRUB_PARITY_EXTENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SCRUB_PARITY_EXTENT_DATA {
    pub Size: u16,
    pub Flags: u16,
    pub NumberOfParityExtents: u16,
    pub MaximumNumberOfParityExtents: u16,
    pub ParityExtents: [SCRUB_PARITY_EXTENT; 1],
}
impl ::core::marker::Copy for SCRUB_PARITY_EXTENT_DATA {}
impl ::core::clone::Clone for SCRUB_PARITY_EXTENT_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SCRUB_PARITY_EXTENT_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SCRUB_PARITY_EXTENT_DATA").field("Size", &self.Size).field("Flags", &self.Flags).field("NumberOfParityExtents", &self.NumberOfParityExtents).field("MaximumNumberOfParityExtents", &self.MaximumNumberOfParityExtents).field("ParityExtents", &self.ParityExtents).finish()
    }
}
impl ::windows_core::TypeKind for SCRUB_PARITY_EXTENT_DATA {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SCRUB_PARITY_EXTENT_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.Flags == other.Flags && self.NumberOfParityExtents == other.NumberOfParityExtents && self.MaximumNumberOfParityExtents == other.MaximumNumberOfParityExtents && self.ParityExtents == other.ParityExtents
    }
}
impl ::core::cmp::Eq for SCRUB_PARITY_EXTENT_DATA {}
impl ::core::default::Default for SCRUB_PARITY_EXTENT_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SD_CHANGE_MACHINE_SID_INPUT {
    pub CurrentMachineSIDOffset: u16,
    pub CurrentMachineSIDLength: u16,
    pub NewMachineSIDOffset: u16,
    pub NewMachineSIDLength: u16,
}
impl ::core::marker::Copy for SD_CHANGE_MACHINE_SID_INPUT {}
impl ::core::clone::Clone for SD_CHANGE_MACHINE_SID_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SD_CHANGE_MACHINE_SID_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SD_CHANGE_MACHINE_SID_INPUT").field("CurrentMachineSIDOffset", &self.CurrentMachineSIDOffset).field("CurrentMachineSIDLength", &self.CurrentMachineSIDLength).field("NewMachineSIDOffset", &self.NewMachineSIDOffset).field("NewMachineSIDLength", &self.NewMachineSIDLength).finish()
    }
}
impl ::windows_core::TypeKind for SD_CHANGE_MACHINE_SID_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SD_CHANGE_MACHINE_SID_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.CurrentMachineSIDOffset == other.CurrentMachineSIDOffset && self.CurrentMachineSIDLength == other.CurrentMachineSIDLength && self.NewMachineSIDOffset == other.NewMachineSIDOffset && self.NewMachineSIDLength == other.NewMachineSIDLength
    }
}
impl ::core::cmp::Eq for SD_CHANGE_MACHINE_SID_INPUT {}
impl ::core::default::Default for SD_CHANGE_MACHINE_SID_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SD_CHANGE_MACHINE_SID_OUTPUT {
    pub NumSDChangedSuccess: u64,
    pub NumSDChangedFail: u64,
    pub NumSDUnused: u64,
    pub NumSDTotal: u64,
    pub NumMftSDChangedSuccess: u64,
    pub NumMftSDChangedFail: u64,
    pub NumMftSDTotal: u64,
}
impl ::core::marker::Copy for SD_CHANGE_MACHINE_SID_OUTPUT {}
impl ::core::clone::Clone for SD_CHANGE_MACHINE_SID_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SD_CHANGE_MACHINE_SID_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SD_CHANGE_MACHINE_SID_OUTPUT").field("NumSDChangedSuccess", &self.NumSDChangedSuccess).field("NumSDChangedFail", &self.NumSDChangedFail).field("NumSDUnused", &self.NumSDUnused).field("NumSDTotal", &self.NumSDTotal).field("NumMftSDChangedSuccess", &self.NumMftSDChangedSuccess).field("NumMftSDChangedFail", &self.NumMftSDChangedFail).field("NumMftSDTotal", &self.NumMftSDTotal).finish()
    }
}
impl ::windows_core::TypeKind for SD_CHANGE_MACHINE_SID_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SD_CHANGE_MACHINE_SID_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.NumSDChangedSuccess == other.NumSDChangedSuccess && self.NumSDChangedFail == other.NumSDChangedFail && self.NumSDUnused == other.NumSDUnused && self.NumSDTotal == other.NumSDTotal && self.NumMftSDChangedSuccess == other.NumMftSDChangedSuccess && self.NumMftSDChangedFail == other.NumMftSDChangedFail && self.NumMftSDTotal == other.NumMftSDTotal
    }
}
impl ::core::cmp::Eq for SD_CHANGE_MACHINE_SID_OUTPUT {}
impl ::core::default::Default for SD_CHANGE_MACHINE_SID_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SD_ENUM_SDS_ENTRY {
    pub Hash: u32,
    pub SecurityId: u32,
    pub Offset: u64,
    pub Length: u32,
    pub Descriptor: [u8; 1],
}
impl ::core::marker::Copy for SD_ENUM_SDS_ENTRY {}
impl ::core::clone::Clone for SD_ENUM_SDS_ENTRY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SD_ENUM_SDS_ENTRY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SD_ENUM_SDS_ENTRY").field("Hash", &self.Hash).field("SecurityId", &self.SecurityId).field("Offset", &self.Offset).field("Length", &self.Length).field("Descriptor", &self.Descriptor).finish()
    }
}
impl ::windows_core::TypeKind for SD_ENUM_SDS_ENTRY {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SD_ENUM_SDS_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.Hash == other.Hash && self.SecurityId == other.SecurityId && self.Offset == other.Offset && self.Length == other.Length && self.Descriptor == other.Descriptor
    }
}
impl ::core::cmp::Eq for SD_ENUM_SDS_ENTRY {}
impl ::core::default::Default for SD_ENUM_SDS_ENTRY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SD_ENUM_SDS_INPUT {
    pub StartingOffset: u64,
    pub MaxSDEntriesToReturn: u64,
}
impl ::core::marker::Copy for SD_ENUM_SDS_INPUT {}
impl ::core::clone::Clone for SD_ENUM_SDS_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SD_ENUM_SDS_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SD_ENUM_SDS_INPUT").field("StartingOffset", &self.StartingOffset).field("MaxSDEntriesToReturn", &self.MaxSDEntriesToReturn).finish()
    }
}
impl ::windows_core::TypeKind for SD_ENUM_SDS_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SD_ENUM_SDS_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.StartingOffset == other.StartingOffset && self.MaxSDEntriesToReturn == other.MaxSDEntriesToReturn
    }
}
impl ::core::cmp::Eq for SD_ENUM_SDS_INPUT {}
impl ::core::default::Default for SD_ENUM_SDS_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SD_ENUM_SDS_OUTPUT {
    pub NextOffset: u64,
    pub NumSDEntriesReturned: u64,
    pub NumSDBytesReturned: u64,
    pub SDEntry: [SD_ENUM_SDS_ENTRY; 1],
}
impl ::core::marker::Copy for SD_ENUM_SDS_OUTPUT {}
impl ::core::clone::Clone for SD_ENUM_SDS_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SD_ENUM_SDS_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SD_ENUM_SDS_OUTPUT").field("NextOffset", &self.NextOffset).field("NumSDEntriesReturned", &self.NumSDEntriesReturned).field("NumSDBytesReturned", &self.NumSDBytesReturned).field("SDEntry", &self.SDEntry).finish()
    }
}
impl ::windows_core::TypeKind for SD_ENUM_SDS_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SD_ENUM_SDS_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.NextOffset == other.NextOffset && self.NumSDEntriesReturned == other.NumSDEntriesReturned && self.NumSDBytesReturned == other.NumSDBytesReturned && self.SDEntry == other.SDEntry
    }
}
impl ::core::cmp::Eq for SD_ENUM_SDS_OUTPUT {}
impl ::core::default::Default for SD_ENUM_SDS_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SD_GLOBAL_CHANGE_INPUT {
    pub Flags: u32,
    pub ChangeType: u32,
    pub Anonymous: SD_GLOBAL_CHANGE_INPUT_0,
}
impl ::core::marker::Copy for SD_GLOBAL_CHANGE_INPUT {}
impl ::core::clone::Clone for SD_GLOBAL_CHANGE_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for SD_GLOBAL_CHANGE_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for SD_GLOBAL_CHANGE_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub union SD_GLOBAL_CHANGE_INPUT_0 {
    pub SdChange: SD_CHANGE_MACHINE_SID_INPUT,
    pub SdQueryStats: SD_QUERY_STATS_INPUT,
    pub SdEnumSds: SD_ENUM_SDS_INPUT,
}
impl ::core::marker::Copy for SD_GLOBAL_CHANGE_INPUT_0 {}
impl ::core::clone::Clone for SD_GLOBAL_CHANGE_INPUT_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for SD_GLOBAL_CHANGE_INPUT_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for SD_GLOBAL_CHANGE_INPUT_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SD_GLOBAL_CHANGE_OUTPUT {
    pub Flags: u32,
    pub ChangeType: u32,
    pub Anonymous: SD_GLOBAL_CHANGE_OUTPUT_0,
}
impl ::core::marker::Copy for SD_GLOBAL_CHANGE_OUTPUT {}
impl ::core::clone::Clone for SD_GLOBAL_CHANGE_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for SD_GLOBAL_CHANGE_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for SD_GLOBAL_CHANGE_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub union SD_GLOBAL_CHANGE_OUTPUT_0 {
    pub SdChange: SD_CHANGE_MACHINE_SID_OUTPUT,
    pub SdQueryStats: SD_QUERY_STATS_OUTPUT,
    pub SdEnumSds: SD_ENUM_SDS_OUTPUT,
}
impl ::core::marker::Copy for SD_GLOBAL_CHANGE_OUTPUT_0 {}
impl ::core::clone::Clone for SD_GLOBAL_CHANGE_OUTPUT_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for SD_GLOBAL_CHANGE_OUTPUT_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for SD_GLOBAL_CHANGE_OUTPUT_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SD_QUERY_STATS_INPUT {
    pub Reserved: u32,
}
impl ::core::marker::Copy for SD_QUERY_STATS_INPUT {}
impl ::core::clone::Clone for SD_QUERY_STATS_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SD_QUERY_STATS_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SD_QUERY_STATS_INPUT").field("Reserved", &self.Reserved).finish()
    }
}
impl ::windows_core::TypeKind for SD_QUERY_STATS_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SD_QUERY_STATS_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Reserved == other.Reserved
    }
}
impl ::core::cmp::Eq for SD_QUERY_STATS_INPUT {}
impl ::core::default::Default for SD_QUERY_STATS_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SD_QUERY_STATS_OUTPUT {
    pub SdsStreamSize: u64,
    pub SdsAllocationSize: u64,
    pub SiiStreamSize: u64,
    pub SiiAllocationSize: u64,
    pub SdhStreamSize: u64,
    pub SdhAllocationSize: u64,
    pub NumSDTotal: u64,
    pub NumSDUnused: u64,
}
impl ::core::marker::Copy for SD_QUERY_STATS_OUTPUT {}
impl ::core::clone::Clone for SD_QUERY_STATS_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SD_QUERY_STATS_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SD_QUERY_STATS_OUTPUT").field("SdsStreamSize", &self.SdsStreamSize).field("SdsAllocationSize", &self.SdsAllocationSize).field("SiiStreamSize", &self.SiiStreamSize).field("SiiAllocationSize", &self.SiiAllocationSize).field("SdhStreamSize", &self.SdhStreamSize).field("SdhAllocationSize", &self.SdhAllocationSize).field("NumSDTotal", &self.NumSDTotal).field("NumSDUnused", &self.NumSDUnused).finish()
    }
}
impl ::windows_core::TypeKind for SD_QUERY_STATS_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SD_QUERY_STATS_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.SdsStreamSize == other.SdsStreamSize && self.SdsAllocationSize == other.SdsAllocationSize && self.SiiStreamSize == other.SiiStreamSize && self.SiiAllocationSize == other.SiiAllocationSize && self.SdhStreamSize == other.SdhStreamSize && self.SdhAllocationSize == other.SdhAllocationSize && self.NumSDTotal == other.NumSDTotal && self.NumSDUnused == other.NumSDUnused
    }
}
impl ::core::cmp::Eq for SD_QUERY_STATS_OUTPUT {}
impl ::core::default::Default for SD_QUERY_STATS_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
pub struct SECURITY_CLIENT_CONTEXT {
    pub SecurityQos: super::super::super::Win32::Security::SECURITY_QUALITY_OF_SERVICE,
    pub ClientToken: *mut ::core::ffi::c_void,
    pub DirectlyAccessClientToken: super::super::super::Win32::Foundation::BOOLEAN,
    pub DirectAccessEffectiveOnly: super::super::super::Win32::Foundation::BOOLEAN,
    pub ServerIsRemote: super::super::super::Win32::Foundation::BOOLEAN,
    pub ClientTokenControl: TOKEN_CONTROL,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::marker::Copy for SECURITY_CLIENT_CONTEXT {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::clone::Clone for SECURITY_CLIENT_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::fmt::Debug for SECURITY_CLIENT_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SECURITY_CLIENT_CONTEXT").field("SecurityQos", &self.SecurityQos).field("ClientToken", &self.ClientToken).field("DirectlyAccessClientToken", &self.DirectlyAccessClientToken).field("DirectAccessEffectiveOnly", &self.DirectAccessEffectiveOnly).field("ServerIsRemote", &self.ServerIsRemote).field("ClientTokenControl", &self.ClientTokenControl).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::windows_core::TypeKind for SECURITY_CLIENT_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::cmp::PartialEq for SECURITY_CLIENT_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.SecurityQos == other.SecurityQos && self.ClientToken == other.ClientToken && self.DirectlyAccessClientToken == other.DirectlyAccessClientToken && self.DirectAccessEffectiveOnly == other.DirectAccessEffectiveOnly && self.ServerIsRemote == other.ServerIsRemote && self.ClientTokenControl == other.ClientTokenControl
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::cmp::Eq for SECURITY_CLIENT_CONTEXT {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::default::Default for SECURITY_CLIENT_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
pub struct SECURITY_DESCRIPTOR {
    pub Revision: u8,
    pub Sbz1: u8,
    pub Control: u16,
    pub Owner: super::super::super::Win32::Foundation::PSID,
    pub Group: super::super::super::Win32::Foundation::PSID,
    pub Sacl: *mut super::super::super::Win32::Security::ACL,
    pub Dacl: *mut super::super::super::Win32::Security::ACL,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::marker::Copy for SECURITY_DESCRIPTOR {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::clone::Clone for SECURITY_DESCRIPTOR {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::fmt::Debug for SECURITY_DESCRIPTOR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SECURITY_DESCRIPTOR").field("Revision", &self.Revision).field("Sbz1", &self.Sbz1).field("Control", &self.Control).field("Owner", &self.Owner).field("Group", &self.Group).field("Sacl", &self.Sacl).field("Dacl", &self.Dacl).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::windows_core::TypeKind for SECURITY_DESCRIPTOR {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::cmp::PartialEq for SECURITY_DESCRIPTOR {
    fn eq(&self, other: &Self) -> bool {
        self.Revision == other.Revision && self.Sbz1 == other.Sbz1 && self.Control == other.Control && self.Owner == other.Owner && self.Group == other.Group && self.Sacl == other.Sacl && self.Dacl == other.Dacl
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::cmp::Eq for SECURITY_DESCRIPTOR {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::default::Default for SECURITY_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SECURITY_DESCRIPTOR_RELATIVE {
    pub Revision: u8,
    pub Sbz1: u8,
    pub Control: u16,
    pub Owner: u32,
    pub Group: u32,
    pub Sacl: u32,
    pub Dacl: u32,
}
impl ::core::marker::Copy for SECURITY_DESCRIPTOR_RELATIVE {}
impl ::core::clone::Clone for SECURITY_DESCRIPTOR_RELATIVE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SECURITY_DESCRIPTOR_RELATIVE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SECURITY_DESCRIPTOR_RELATIVE").field("Revision", &self.Revision).field("Sbz1", &self.Sbz1).field("Control", &self.Control).field("Owner", &self.Owner).field("Group", &self.Group).field("Sacl", &self.Sacl).field("Dacl", &self.Dacl).finish()
    }
}
impl ::windows_core::TypeKind for SECURITY_DESCRIPTOR_RELATIVE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SECURITY_DESCRIPTOR_RELATIVE {
    fn eq(&self, other: &Self) -> bool {
        self.Revision == other.Revision && self.Sbz1 == other.Sbz1 && self.Control == other.Control && self.Owner == other.Owner && self.Group == other.Group && self.Sacl == other.Sacl && self.Dacl == other.Dacl
    }
}
impl ::core::cmp::Eq for SECURITY_DESCRIPTOR_RELATIVE {}
impl ::core::default::Default for SECURITY_DESCRIPTOR_RELATIVE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SECURITY_OBJECT_AI_PARAMS {
    pub Size: u32,
    pub ConstraintMask: u32,
}
impl ::core::marker::Copy for SECURITY_OBJECT_AI_PARAMS {}
impl ::core::clone::Clone for SECURITY_OBJECT_AI_PARAMS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SECURITY_OBJECT_AI_PARAMS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SECURITY_OBJECT_AI_PARAMS").field("Size", &self.Size).field("ConstraintMask", &self.ConstraintMask).finish()
    }
}
impl ::windows_core::TypeKind for SECURITY_OBJECT_AI_PARAMS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SECURITY_OBJECT_AI_PARAMS {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.ConstraintMask == other.ConstraintMask
    }
}
impl ::core::cmp::Eq for SECURITY_OBJECT_AI_PARAMS {}
impl ::core::default::Default for SECURITY_OBJECT_AI_PARAMS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct SECURITY_USER_DATA {
    pub UserName: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub LogonDomainName: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub LogonServer: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub pSid: super::super::super::Win32::Foundation::PSID,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for SECURITY_USER_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for SECURITY_USER_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for SECURITY_USER_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SECURITY_USER_DATA").field("UserName", &self.UserName).field("LogonDomainName", &self.LogonDomainName).field("LogonServer", &self.LogonServer).field("pSid", &self.pSid).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for SECURITY_USER_DATA {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for SECURITY_USER_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.UserName == other.UserName && self.LogonDomainName == other.LogonDomainName && self.LogonServer == other.LogonServer && self.pSid == other.pSid
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for SECURITY_USER_DATA {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for SECURITY_USER_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SEC_APPLICATION_PROTOCOLS {
    pub ProtocolListsSize: u32,
    pub ProtocolLists: [SEC_APPLICATION_PROTOCOL_LIST; 1],
}
impl ::core::marker::Copy for SEC_APPLICATION_PROTOCOLS {}
impl ::core::clone::Clone for SEC_APPLICATION_PROTOCOLS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SEC_APPLICATION_PROTOCOLS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SEC_APPLICATION_PROTOCOLS").field("ProtocolListsSize", &self.ProtocolListsSize).field("ProtocolLists", &self.ProtocolLists).finish()
    }
}
impl ::windows_core::TypeKind for SEC_APPLICATION_PROTOCOLS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SEC_APPLICATION_PROTOCOLS {
    fn eq(&self, other: &Self) -> bool {
        self.ProtocolListsSize == other.ProtocolListsSize && self.ProtocolLists == other.ProtocolLists
    }
}
impl ::core::cmp::Eq for SEC_APPLICATION_PROTOCOLS {}
impl ::core::default::Default for SEC_APPLICATION_PROTOCOLS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SEC_APPLICATION_PROTOCOL_LIST {
    pub ProtoNegoExt: SEC_APPLICATION_PROTOCOL_NEGOTIATION_EXT,
    pub ProtocolListSize: u16,
    pub ProtocolList: [u8; 1],
}
impl ::core::marker::Copy for SEC_APPLICATION_PROTOCOL_LIST {}
impl ::core::clone::Clone for SEC_APPLICATION_PROTOCOL_LIST {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SEC_APPLICATION_PROTOCOL_LIST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SEC_APPLICATION_PROTOCOL_LIST").field("ProtoNegoExt", &self.ProtoNegoExt).field("ProtocolListSize", &self.ProtocolListSize).field("ProtocolList", &self.ProtocolList).finish()
    }
}
impl ::windows_core::TypeKind for SEC_APPLICATION_PROTOCOL_LIST {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SEC_APPLICATION_PROTOCOL_LIST {
    fn eq(&self, other: &Self) -> bool {
        self.ProtoNegoExt == other.ProtoNegoExt && self.ProtocolListSize == other.ProtocolListSize && self.ProtocolList == other.ProtocolList
    }
}
impl ::core::cmp::Eq for SEC_APPLICATION_PROTOCOL_LIST {}
impl ::core::default::Default for SEC_APPLICATION_PROTOCOL_LIST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SEC_CERTIFICATE_REQUEST_CONTEXT {
    pub cbCertificateRequestContext: u8,
    pub rgCertificateRequestContext: [u8; 1],
}
impl ::core::marker::Copy for SEC_CERTIFICATE_REQUEST_CONTEXT {}
impl ::core::clone::Clone for SEC_CERTIFICATE_REQUEST_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SEC_CERTIFICATE_REQUEST_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SEC_CERTIFICATE_REQUEST_CONTEXT").field("cbCertificateRequestContext", &self.cbCertificateRequestContext).field("rgCertificateRequestContext", &self.rgCertificateRequestContext).finish()
    }
}
impl ::windows_core::TypeKind for SEC_CERTIFICATE_REQUEST_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SEC_CERTIFICATE_REQUEST_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.cbCertificateRequestContext == other.cbCertificateRequestContext && self.rgCertificateRequestContext == other.rgCertificateRequestContext
    }
}
impl ::core::cmp::Eq for SEC_CERTIFICATE_REQUEST_CONTEXT {}
impl ::core::default::Default for SEC_CERTIFICATE_REQUEST_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SEC_CHANNEL_BINDINGS {
    pub dwInitiatorAddrType: u32,
    pub cbInitiatorLength: u32,
    pub dwInitiatorOffset: u32,
    pub dwAcceptorAddrType: u32,
    pub cbAcceptorLength: u32,
    pub dwAcceptorOffset: u32,
    pub cbApplicationDataLength: u32,
    pub dwApplicationDataOffset: u32,
}
impl ::core::marker::Copy for SEC_CHANNEL_BINDINGS {}
impl ::core::clone::Clone for SEC_CHANNEL_BINDINGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SEC_CHANNEL_BINDINGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SEC_CHANNEL_BINDINGS")
            .field("dwInitiatorAddrType", &self.dwInitiatorAddrType)
            .field("cbInitiatorLength", &self.cbInitiatorLength)
            .field("dwInitiatorOffset", &self.dwInitiatorOffset)
            .field("dwAcceptorAddrType", &self.dwAcceptorAddrType)
            .field("cbAcceptorLength", &self.cbAcceptorLength)
            .field("dwAcceptorOffset", &self.dwAcceptorOffset)
            .field("cbApplicationDataLength", &self.cbApplicationDataLength)
            .field("dwApplicationDataOffset", &self.dwApplicationDataOffset)
            .finish()
    }
}
impl ::windows_core::TypeKind for SEC_CHANNEL_BINDINGS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SEC_CHANNEL_BINDINGS {
    fn eq(&self, other: &Self) -> bool {
        self.dwInitiatorAddrType == other.dwInitiatorAddrType && self.cbInitiatorLength == other.cbInitiatorLength && self.dwInitiatorOffset == other.dwInitiatorOffset && self.dwAcceptorAddrType == other.dwAcceptorAddrType && self.cbAcceptorLength == other.cbAcceptorLength && self.dwAcceptorOffset == other.dwAcceptorOffset && self.cbApplicationDataLength == other.cbApplicationDataLength && self.dwApplicationDataOffset == other.dwApplicationDataOffset
    }
}
impl ::core::cmp::Eq for SEC_CHANNEL_BINDINGS {}
impl ::core::default::Default for SEC_CHANNEL_BINDINGS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SEC_DTLS_MTU {
    pub PathMTU: u16,
}
impl ::core::marker::Copy for SEC_DTLS_MTU {}
impl ::core::clone::Clone for SEC_DTLS_MTU {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SEC_DTLS_MTU {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SEC_DTLS_MTU").field("PathMTU", &self.PathMTU).finish()
    }
}
impl ::windows_core::TypeKind for SEC_DTLS_MTU {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SEC_DTLS_MTU {
    fn eq(&self, other: &Self) -> bool {
        self.PathMTU == other.PathMTU
    }
}
impl ::core::cmp::Eq for SEC_DTLS_MTU {}
impl ::core::default::Default for SEC_DTLS_MTU {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SEC_FLAGS {
    pub Flags: u64,
}
impl ::core::marker::Copy for SEC_FLAGS {}
impl ::core::clone::Clone for SEC_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SEC_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SEC_FLAGS").field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for SEC_FLAGS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SEC_FLAGS {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for SEC_FLAGS {}
impl ::core::default::Default for SEC_FLAGS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SEC_NEGOTIATION_INFO {
    pub Size: u32,
    pub NameLength: u32,
    pub Name: *mut u16,
    pub Reserved: *mut ::core::ffi::c_void,
}
impl ::core::marker::Copy for SEC_NEGOTIATION_INFO {}
impl ::core::clone::Clone for SEC_NEGOTIATION_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SEC_NEGOTIATION_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SEC_NEGOTIATION_INFO").field("Size", &self.Size).field("NameLength", &self.NameLength).field("Name", &self.Name).field("Reserved", &self.Reserved).finish()
    }
}
impl ::windows_core::TypeKind for SEC_NEGOTIATION_INFO {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SEC_NEGOTIATION_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.NameLength == other.NameLength && self.Name == other.Name && self.Reserved == other.Reserved
    }
}
impl ::core::cmp::Eq for SEC_NEGOTIATION_INFO {}
impl ::core::default::Default for SEC_NEGOTIATION_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SEC_PRESHAREDKEY {
    pub KeySize: u16,
    pub Key: [u8; 1],
}
impl ::core::marker::Copy for SEC_PRESHAREDKEY {}
impl ::core::clone::Clone for SEC_PRESHAREDKEY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SEC_PRESHAREDKEY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SEC_PRESHAREDKEY").field("KeySize", &self.KeySize).field("Key", &self.Key).finish()
    }
}
impl ::windows_core::TypeKind for SEC_PRESHAREDKEY {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SEC_PRESHAREDKEY {
    fn eq(&self, other: &Self) -> bool {
        self.KeySize == other.KeySize && self.Key == other.Key
    }
}
impl ::core::cmp::Eq for SEC_PRESHAREDKEY {}
impl ::core::default::Default for SEC_PRESHAREDKEY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SEC_PRESHAREDKEY_IDENTITY {
    pub KeyIdentitySize: u16,
    pub KeyIdentity: [u8; 1],
}
impl ::core::marker::Copy for SEC_PRESHAREDKEY_IDENTITY {}
impl ::core::clone::Clone for SEC_PRESHAREDKEY_IDENTITY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SEC_PRESHAREDKEY_IDENTITY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SEC_PRESHAREDKEY_IDENTITY").field("KeyIdentitySize", &self.KeyIdentitySize).field("KeyIdentity", &self.KeyIdentity).finish()
    }
}
impl ::windows_core::TypeKind for SEC_PRESHAREDKEY_IDENTITY {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SEC_PRESHAREDKEY_IDENTITY {
    fn eq(&self, other: &Self) -> bool {
        self.KeyIdentitySize == other.KeyIdentitySize && self.KeyIdentity == other.KeyIdentity
    }
}
impl ::core::cmp::Eq for SEC_PRESHAREDKEY_IDENTITY {}
impl ::core::default::Default for SEC_PRESHAREDKEY_IDENTITY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SEC_SRTP_MASTER_KEY_IDENTIFIER {
    pub MasterKeyIdentifierSize: u8,
    pub MasterKeyIdentifier: [u8; 1],
}
impl ::core::marker::Copy for SEC_SRTP_MASTER_KEY_IDENTIFIER {}
impl ::core::clone::Clone for SEC_SRTP_MASTER_KEY_IDENTIFIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SEC_SRTP_MASTER_KEY_IDENTIFIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SEC_SRTP_MASTER_KEY_IDENTIFIER").field("MasterKeyIdentifierSize", &self.MasterKeyIdentifierSize).field("MasterKeyIdentifier", &self.MasterKeyIdentifier).finish()
    }
}
impl ::windows_core::TypeKind for SEC_SRTP_MASTER_KEY_IDENTIFIER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SEC_SRTP_MASTER_KEY_IDENTIFIER {
    fn eq(&self, other: &Self) -> bool {
        self.MasterKeyIdentifierSize == other.MasterKeyIdentifierSize && self.MasterKeyIdentifier == other.MasterKeyIdentifier
    }
}
impl ::core::cmp::Eq for SEC_SRTP_MASTER_KEY_IDENTIFIER {}
impl ::core::default::Default for SEC_SRTP_MASTER_KEY_IDENTIFIER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SEC_SRTP_PROTECTION_PROFILES {
    pub ProfilesSize: u16,
    pub ProfilesList: [u16; 1],
}
impl ::core::marker::Copy for SEC_SRTP_PROTECTION_PROFILES {}
impl ::core::clone::Clone for SEC_SRTP_PROTECTION_PROFILES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SEC_SRTP_PROTECTION_PROFILES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SEC_SRTP_PROTECTION_PROFILES").field("ProfilesSize", &self.ProfilesSize).field("ProfilesList", &self.ProfilesList).finish()
    }
}
impl ::windows_core::TypeKind for SEC_SRTP_PROTECTION_PROFILES {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SEC_SRTP_PROTECTION_PROFILES {
    fn eq(&self, other: &Self) -> bool {
        self.ProfilesSize == other.ProfilesSize && self.ProfilesList == other.ProfilesList
    }
}
impl ::core::cmp::Eq for SEC_SRTP_PROTECTION_PROFILES {}
impl ::core::default::Default for SEC_SRTP_PROTECTION_PROFILES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SEC_TOKEN_BINDING {
    pub MajorVersion: u8,
    pub MinorVersion: u8,
    pub KeyParametersSize: u16,
    pub KeyParameters: [u8; 1],
}
impl ::core::marker::Copy for SEC_TOKEN_BINDING {}
impl ::core::clone::Clone for SEC_TOKEN_BINDING {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SEC_TOKEN_BINDING {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SEC_TOKEN_BINDING").field("MajorVersion", &self.MajorVersion).field("MinorVersion", &self.MinorVersion).field("KeyParametersSize", &self.KeyParametersSize).field("KeyParameters", &self.KeyParameters).finish()
    }
}
impl ::windows_core::TypeKind for SEC_TOKEN_BINDING {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SEC_TOKEN_BINDING {
    fn eq(&self, other: &Self) -> bool {
        self.MajorVersion == other.MajorVersion && self.MinorVersion == other.MinorVersion && self.KeyParametersSize == other.KeyParametersSize && self.KeyParameters == other.KeyParameters
    }
}
impl ::core::cmp::Eq for SEC_TOKEN_BINDING {}
impl ::core::default::Default for SEC_TOKEN_BINDING {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SEC_TRAFFIC_SECRETS {
    pub SymmetricAlgId: [u16; 64],
    pub ChainingMode: [u16; 64],
    pub HashAlgId: [u16; 64],
    pub KeySize: u16,
    pub IvSize: u16,
    pub MsgSequenceStart: u16,
    pub MsgSequenceEnd: u16,
    pub TrafficSecretType: SEC_TRAFFIC_SECRET_TYPE,
    pub TrafficSecretSize: u16,
    pub TrafficSecret: [u8; 1],
}
impl ::core::marker::Copy for SEC_TRAFFIC_SECRETS {}
impl ::core::clone::Clone for SEC_TRAFFIC_SECRETS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SEC_TRAFFIC_SECRETS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SEC_TRAFFIC_SECRETS").field("SymmetricAlgId", &self.SymmetricAlgId).field("ChainingMode", &self.ChainingMode).field("HashAlgId", &self.HashAlgId).field("KeySize", &self.KeySize).field("IvSize", &self.IvSize).field("MsgSequenceStart", &self.MsgSequenceStart).field("MsgSequenceEnd", &self.MsgSequenceEnd).field("TrafficSecretType", &self.TrafficSecretType).field("TrafficSecretSize", &self.TrafficSecretSize).field("TrafficSecret", &self.TrafficSecret).finish()
    }
}
impl ::windows_core::TypeKind for SEC_TRAFFIC_SECRETS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SEC_TRAFFIC_SECRETS {
    fn eq(&self, other: &Self) -> bool {
        self.SymmetricAlgId == other.SymmetricAlgId && self.ChainingMode == other.ChainingMode && self.HashAlgId == other.HashAlgId && self.KeySize == other.KeySize && self.IvSize == other.IvSize && self.MsgSequenceStart == other.MsgSequenceStart && self.MsgSequenceEnd == other.MsgSequenceEnd && self.TrafficSecretType == other.TrafficSecretType && self.TrafficSecretSize == other.TrafficSecretSize && self.TrafficSecret == other.TrafficSecret
    }
}
impl ::core::cmp::Eq for SEC_TRAFFIC_SECRETS {}
impl ::core::default::Default for SEC_TRAFFIC_SECRETS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SEC_WINNT_AUTH_IDENTITY_EX2 {
    pub Version: u32,
    pub cbHeaderLength: u16,
    pub cbStructureLength: u32,
    pub UserOffset: u32,
    pub UserLength: u16,
    pub DomainOffset: u32,
    pub DomainLength: u16,
    pub PackedCredentialsOffset: u32,
    pub PackedCredentialsLength: u16,
    pub Flags: u32,
    pub PackageListOffset: u32,
    pub PackageListLength: u16,
}
impl ::core::marker::Copy for SEC_WINNT_AUTH_IDENTITY_EX2 {}
impl ::core::clone::Clone for SEC_WINNT_AUTH_IDENTITY_EX2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SEC_WINNT_AUTH_IDENTITY_EX2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SEC_WINNT_AUTH_IDENTITY_EX2")
            .field("Version", &self.Version)
            .field("cbHeaderLength", &self.cbHeaderLength)
            .field("cbStructureLength", &self.cbStructureLength)
            .field("UserOffset", &self.UserOffset)
            .field("UserLength", &self.UserLength)
            .field("DomainOffset", &self.DomainOffset)
            .field("DomainLength", &self.DomainLength)
            .field("PackedCredentialsOffset", &self.PackedCredentialsOffset)
            .field("PackedCredentialsLength", &self.PackedCredentialsLength)
            .field("Flags", &self.Flags)
            .field("PackageListOffset", &self.PackageListOffset)
            .field("PackageListLength", &self.PackageListLength)
            .finish()
    }
}
impl ::windows_core::TypeKind for SEC_WINNT_AUTH_IDENTITY_EX2 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SEC_WINNT_AUTH_IDENTITY_EX2 {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.cbHeaderLength == other.cbHeaderLength && self.cbStructureLength == other.cbStructureLength && self.UserOffset == other.UserOffset && self.UserLength == other.UserLength && self.DomainOffset == other.DomainOffset && self.DomainLength == other.DomainLength && self.PackedCredentialsOffset == other.PackedCredentialsOffset && self.PackedCredentialsLength == other.PackedCredentialsLength && self.Flags == other.Flags && self.PackageListOffset == other.PackageListOffset && self.PackageListLength == other.PackageListLength
    }
}
impl ::core::cmp::Eq for SEC_WINNT_AUTH_IDENTITY_EX2 {}
impl ::core::default::Default for SEC_WINNT_AUTH_IDENTITY_EX2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SEC_WINNT_AUTH_IDENTITY_EXW {
    pub Version: u32,
    pub Length: u32,
    pub User: *mut u16,
    pub UserLength: u32,
    pub Domain: *mut u16,
    pub DomainLength: u32,
    pub Password: *mut u16,
    pub PasswordLength: u32,
    pub Flags: u32,
    pub PackageList: *mut u16,
    pub PackageListLength: u32,
}
impl ::core::marker::Copy for SEC_WINNT_AUTH_IDENTITY_EXW {}
impl ::core::clone::Clone for SEC_WINNT_AUTH_IDENTITY_EXW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SEC_WINNT_AUTH_IDENTITY_EXW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SEC_WINNT_AUTH_IDENTITY_EXW").field("Version", &self.Version).field("Length", &self.Length).field("User", &self.User).field("UserLength", &self.UserLength).field("Domain", &self.Domain).field("DomainLength", &self.DomainLength).field("Password", &self.Password).field("PasswordLength", &self.PasswordLength).field("Flags", &self.Flags).field("PackageList", &self.PackageList).field("PackageListLength", &self.PackageListLength).finish()
    }
}
impl ::windows_core::TypeKind for SEC_WINNT_AUTH_IDENTITY_EXW {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SEC_WINNT_AUTH_IDENTITY_EXW {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Length == other.Length && self.User == other.User && self.UserLength == other.UserLength && self.Domain == other.Domain && self.DomainLength == other.DomainLength && self.Password == other.Password && self.PasswordLength == other.PasswordLength && self.Flags == other.Flags && self.PackageList == other.PackageList && self.PackageListLength == other.PackageListLength
    }
}
impl ::core::cmp::Eq for SEC_WINNT_AUTH_IDENTITY_EXW {}
impl ::core::default::Default for SEC_WINNT_AUTH_IDENTITY_EXW {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SEC_WINNT_AUTH_IDENTITY_W {
    pub User: *mut u16,
    pub UserLength: u32,
    pub Domain: *mut u16,
    pub DomainLength: u32,
    pub Password: *mut u16,
    pub PasswordLength: u32,
    pub Flags: u32,
}
impl ::core::marker::Copy for SEC_WINNT_AUTH_IDENTITY_W {}
impl ::core::clone::Clone for SEC_WINNT_AUTH_IDENTITY_W {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SEC_WINNT_AUTH_IDENTITY_W {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SEC_WINNT_AUTH_IDENTITY_W").field("User", &self.User).field("UserLength", &self.UserLength).field("Domain", &self.Domain).field("DomainLength", &self.DomainLength).field("Password", &self.Password).field("PasswordLength", &self.PasswordLength).field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for SEC_WINNT_AUTH_IDENTITY_W {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SEC_WINNT_AUTH_IDENTITY_W {
    fn eq(&self, other: &Self) -> bool {
        self.User == other.User && self.UserLength == other.UserLength && self.Domain == other.Domain && self.DomainLength == other.DomainLength && self.Password == other.Password && self.PasswordLength == other.PasswordLength && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for SEC_WINNT_AUTH_IDENTITY_W {}
impl ::core::default::Default for SEC_WINNT_AUTH_IDENTITY_W {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct SET_CACHED_RUNS_STATE_INPUT_BUFFER {
    pub Enable: super::super::super::Win32::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for SET_CACHED_RUNS_STATE_INPUT_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for SET_CACHED_RUNS_STATE_INPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for SET_CACHED_RUNS_STATE_INPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SET_CACHED_RUNS_STATE_INPUT_BUFFER").field("Enable", &self.Enable).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for SET_CACHED_RUNS_STATE_INPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for SET_CACHED_RUNS_STATE_INPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.Enable == other.Enable
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for SET_CACHED_RUNS_STATE_INPUT_BUFFER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for SET_CACHED_RUNS_STATE_INPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT {
    pub Flags: u32,
    pub AlignmentShift: u32,
    pub FileOffsetToAlign: u64,
    pub FallbackAlignmentShift: u32,
}
impl ::core::marker::Copy for SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT {}
impl ::core::clone::Clone for SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT").field("Flags", &self.Flags).field("AlignmentShift", &self.AlignmentShift).field("FileOffsetToAlign", &self.FileOffsetToAlign).field("FallbackAlignmentShift", &self.FallbackAlignmentShift).finish()
    }
}
impl ::windows_core::TypeKind for SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags && self.AlignmentShift == other.AlignmentShift && self.FileOffsetToAlign == other.FileOffsetToAlign && self.FallbackAlignmentShift == other.FallbackAlignmentShift
    }
}
impl ::core::cmp::Eq for SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT {}
impl ::core::default::Default for SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SET_PURGE_FAILURE_MODE_INPUT {
    pub Flags: u32,
}
impl ::core::marker::Copy for SET_PURGE_FAILURE_MODE_INPUT {}
impl ::core::clone::Clone for SET_PURGE_FAILURE_MODE_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SET_PURGE_FAILURE_MODE_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SET_PURGE_FAILURE_MODE_INPUT").field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for SET_PURGE_FAILURE_MODE_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SET_PURGE_FAILURE_MODE_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for SET_PURGE_FAILURE_MODE_INPUT {}
impl ::core::default::Default for SET_PURGE_FAILURE_MODE_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
pub struct SE_ACCESS_REPLY {
    pub Size: u32,
    pub ResultListCount: u32,
    pub GrantedAccess: *mut u32,
    pub AccessStatus: *mut i32,
    pub AccessReason: *mut ACCESS_REASONS,
    pub Privileges: *mut *mut super::super::super::Win32::Security::PRIVILEGE_SET,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::marker::Copy for SE_ACCESS_REPLY {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::clone::Clone for SE_ACCESS_REPLY {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::fmt::Debug for SE_ACCESS_REPLY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SE_ACCESS_REPLY").field("Size", &self.Size).field("ResultListCount", &self.ResultListCount).field("GrantedAccess", &self.GrantedAccess).field("AccessStatus", &self.AccessStatus).field("AccessReason", &self.AccessReason).field("Privileges", &self.Privileges).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::windows_core::TypeKind for SE_ACCESS_REPLY {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::cmp::PartialEq for SE_ACCESS_REPLY {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.ResultListCount == other.ResultListCount && self.GrantedAccess == other.GrantedAccess && self.AccessStatus == other.AccessStatus && self.AccessReason == other.AccessReason && self.Privileges == other.Privileges
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::cmp::Eq for SE_ACCESS_REPLY {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::default::Default for SE_ACCESS_REPLY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
pub struct SE_ACCESS_REQUEST {
    pub Size: u32,
    pub SeSecurityDescriptor: *mut SE_SECURITY_DESCRIPTOR,
    pub DesiredAccess: u32,
    pub PreviouslyGrantedAccess: u32,
    pub PrincipalSelfSid: super::super::super::Win32::Foundation::PSID,
    pub GenericMapping: *mut super::super::super::Win32::Security::GENERIC_MAPPING,
    pub ObjectTypeListCount: u32,
    pub ObjectTypeList: *mut OBJECT_TYPE_LIST,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::marker::Copy for SE_ACCESS_REQUEST {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::clone::Clone for SE_ACCESS_REQUEST {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::fmt::Debug for SE_ACCESS_REQUEST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SE_ACCESS_REQUEST").field("Size", &self.Size).field("SeSecurityDescriptor", &self.SeSecurityDescriptor).field("DesiredAccess", &self.DesiredAccess).field("PreviouslyGrantedAccess", &self.PreviouslyGrantedAccess).field("PrincipalSelfSid", &self.PrincipalSelfSid).field("GenericMapping", &self.GenericMapping).field("ObjectTypeListCount", &self.ObjectTypeListCount).field("ObjectTypeList", &self.ObjectTypeList).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::windows_core::TypeKind for SE_ACCESS_REQUEST {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::cmp::PartialEq for SE_ACCESS_REQUEST {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.SeSecurityDescriptor == other.SeSecurityDescriptor && self.DesiredAccess == other.DesiredAccess && self.PreviouslyGrantedAccess == other.PreviouslyGrantedAccess && self.PrincipalSelfSid == other.PrincipalSelfSid && self.GenericMapping == other.GenericMapping && self.ObjectTypeListCount == other.ObjectTypeListCount && self.ObjectTypeList == other.ObjectTypeList
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::cmp::Eq for SE_ACCESS_REQUEST {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::default::Default for SE_ACCESS_REQUEST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct SE_AUDIT_INFO {
    pub Size: u32,
    pub AuditType: AUDIT_EVENT_TYPE,
    pub AuditOperation: SE_AUDIT_OPERATION,
    pub AuditFlags: u32,
    pub SubsystemName: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub ObjectTypeName: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub ObjectName: super::super::super::Win32::Foundation::UNICODE_STRING,
    pub HandleId: *mut ::core::ffi::c_void,
    pub TransactionId: *mut ::windows_core::GUID,
    pub OperationId: *mut super::super::super::Win32::Foundation::LUID,
    pub ObjectCreation: super::super::super::Win32::Foundation::BOOLEAN,
    pub GenerateOnClose: super::super::super::Win32::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for SE_AUDIT_INFO {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for SE_AUDIT_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for SE_AUDIT_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SE_AUDIT_INFO")
            .field("Size", &self.Size)
            .field("AuditType", &self.AuditType)
            .field("AuditOperation", &self.AuditOperation)
            .field("AuditFlags", &self.AuditFlags)
            .field("SubsystemName", &self.SubsystemName)
            .field("ObjectTypeName", &self.ObjectTypeName)
            .field("ObjectName", &self.ObjectName)
            .field("HandleId", &self.HandleId)
            .field("TransactionId", &self.TransactionId)
            .field("OperationId", &self.OperationId)
            .field("ObjectCreation", &self.ObjectCreation)
            .field("GenerateOnClose", &self.GenerateOnClose)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for SE_AUDIT_INFO {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for SE_AUDIT_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.AuditType == other.AuditType && self.AuditOperation == other.AuditOperation && self.AuditFlags == other.AuditFlags && self.SubsystemName == other.SubsystemName && self.ObjectTypeName == other.ObjectTypeName && self.ObjectName == other.ObjectName && self.HandleId == other.HandleId && self.TransactionId == other.TransactionId && self.OperationId == other.OperationId && self.ObjectCreation == other.ObjectCreation && self.GenerateOnClose == other.GenerateOnClose
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for SE_AUDIT_INFO {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for SE_AUDIT_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct SE_EXPORTS {
    pub SeCreateTokenPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeAssignPrimaryTokenPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeLockMemoryPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeIncreaseQuotaPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeUnsolicitedInputPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeTcbPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeSecurityPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeTakeOwnershipPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeLoadDriverPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeCreatePagefilePrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeIncreaseBasePriorityPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeSystemProfilePrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeSystemtimePrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeProfileSingleProcessPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeCreatePermanentPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeBackupPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeRestorePrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeShutdownPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeDebugPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeAuditPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeSystemEnvironmentPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeChangeNotifyPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeRemoteShutdownPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeNullSid: super::super::super::Win32::Foundation::PSID,
    pub SeWorldSid: super::super::super::Win32::Foundation::PSID,
    pub SeLocalSid: super::super::super::Win32::Foundation::PSID,
    pub SeCreatorOwnerSid: super::super::super::Win32::Foundation::PSID,
    pub SeCreatorGroupSid: super::super::super::Win32::Foundation::PSID,
    pub SeNtAuthoritySid: super::super::super::Win32::Foundation::PSID,
    pub SeDialupSid: super::super::super::Win32::Foundation::PSID,
    pub SeNetworkSid: super::super::super::Win32::Foundation::PSID,
    pub SeBatchSid: super::super::super::Win32::Foundation::PSID,
    pub SeInteractiveSid: super::super::super::Win32::Foundation::PSID,
    pub SeLocalSystemSid: super::super::super::Win32::Foundation::PSID,
    pub SeAliasAdminsSid: super::super::super::Win32::Foundation::PSID,
    pub SeAliasUsersSid: super::super::super::Win32::Foundation::PSID,
    pub SeAliasGuestsSid: super::super::super::Win32::Foundation::PSID,
    pub SeAliasPowerUsersSid: super::super::super::Win32::Foundation::PSID,
    pub SeAliasAccountOpsSid: super::super::super::Win32::Foundation::PSID,
    pub SeAliasSystemOpsSid: super::super::super::Win32::Foundation::PSID,
    pub SeAliasPrintOpsSid: super::super::super::Win32::Foundation::PSID,
    pub SeAliasBackupOpsSid: super::super::super::Win32::Foundation::PSID,
    pub SeAuthenticatedUsersSid: super::super::super::Win32::Foundation::PSID,
    pub SeRestrictedSid: super::super::super::Win32::Foundation::PSID,
    pub SeAnonymousLogonSid: super::super::super::Win32::Foundation::PSID,
    pub SeUndockPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeSyncAgentPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeEnableDelegationPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeLocalServiceSid: super::super::super::Win32::Foundation::PSID,
    pub SeNetworkServiceSid: super::super::super::Win32::Foundation::PSID,
    pub SeManageVolumePrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeImpersonatePrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeCreateGlobalPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeTrustedCredManAccessPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeRelabelPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeIncreaseWorkingSetPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeTimeZonePrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeCreateSymbolicLinkPrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeIUserSid: super::super::super::Win32::Foundation::PSID,
    pub SeUntrustedMandatorySid: super::super::super::Win32::Foundation::PSID,
    pub SeLowMandatorySid: super::super::super::Win32::Foundation::PSID,
    pub SeMediumMandatorySid: super::super::super::Win32::Foundation::PSID,
    pub SeHighMandatorySid: super::super::super::Win32::Foundation::PSID,
    pub SeSystemMandatorySid: super::super::super::Win32::Foundation::PSID,
    pub SeOwnerRightsSid: super::super::super::Win32::Foundation::PSID,
    pub SeAllAppPackagesSid: super::super::super::Win32::Foundation::PSID,
    pub SeUserModeDriversSid: super::super::super::Win32::Foundation::PSID,
    pub SeProcTrustWinTcbSid: super::super::super::Win32::Foundation::PSID,
    pub SeTrustedInstallerSid: super::super::super::Win32::Foundation::PSID,
    pub SeDelegateSessionUserImpersonatePrivilege: super::super::super::Win32::Foundation::LUID,
    pub SeAppSiloSid: super::super::super::Win32::Foundation::PSID,
    pub SeAppSiloVolumeRootMinimalCapabilitySid: super::super::super::Win32::Foundation::PSID,
    pub SeAppSiloProfilesRootMinimalCapabilitySid: super::super::super::Win32::Foundation::PSID,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for SE_EXPORTS {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for SE_EXPORTS {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for SE_EXPORTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SE_EXPORTS")
            .field("SeCreateTokenPrivilege", &self.SeCreateTokenPrivilege)
            .field("SeAssignPrimaryTokenPrivilege", &self.SeAssignPrimaryTokenPrivilege)
            .field("SeLockMemoryPrivilege", &self.SeLockMemoryPrivilege)
            .field("SeIncreaseQuotaPrivilege", &self.SeIncreaseQuotaPrivilege)
            .field("SeUnsolicitedInputPrivilege", &self.SeUnsolicitedInputPrivilege)
            .field("SeTcbPrivilege", &self.SeTcbPrivilege)
            .field("SeSecurityPrivilege", &self.SeSecurityPrivilege)
            .field("SeTakeOwnershipPrivilege", &self.SeTakeOwnershipPrivilege)
            .field("SeLoadDriverPrivilege", &self.SeLoadDriverPrivilege)
            .field("SeCreatePagefilePrivilege", &self.SeCreatePagefilePrivilege)
            .field("SeIncreaseBasePriorityPrivilege", &self.SeIncreaseBasePriorityPrivilege)
            .field("SeSystemProfilePrivilege", &self.SeSystemProfilePrivilege)
            .field("SeSystemtimePrivilege", &self.SeSystemtimePrivilege)
            .field("SeProfileSingleProcessPrivilege", &self.SeProfileSingleProcessPrivilege)
            .field("SeCreatePermanentPrivilege", &self.SeCreatePermanentPrivilege)
            .field("SeBackupPrivilege", &self.SeBackupPrivilege)
            .field("SeRestorePrivilege", &self.SeRestorePrivilege)
            .field("SeShutdownPrivilege", &self.SeShutdownPrivilege)
            .field("SeDebugPrivilege", &self.SeDebugPrivilege)
            .field("SeAuditPrivilege", &self.SeAuditPrivilege)
            .field("SeSystemEnvironmentPrivilege", &self.SeSystemEnvironmentPrivilege)
            .field("SeChangeNotifyPrivilege", &self.SeChangeNotifyPrivilege)
            .field("SeRemoteShutdownPrivilege", &self.SeRemoteShutdownPrivilege)
            .field("SeNullSid", &self.SeNullSid)
            .field("SeWorldSid", &self.SeWorldSid)
            .field("SeLocalSid", &self.SeLocalSid)
            .field("SeCreatorOwnerSid", &self.SeCreatorOwnerSid)
            .field("SeCreatorGroupSid", &self.SeCreatorGroupSid)
            .field("SeNtAuthoritySid", &self.SeNtAuthoritySid)
            .field("SeDialupSid", &self.SeDialupSid)
            .field("SeNetworkSid", &self.SeNetworkSid)
            .field("SeBatchSid", &self.SeBatchSid)
            .field("SeInteractiveSid", &self.SeInteractiveSid)
            .field("SeLocalSystemSid", &self.SeLocalSystemSid)
            .field("SeAliasAdminsSid", &self.SeAliasAdminsSid)
            .field("SeAliasUsersSid", &self.SeAliasUsersSid)
            .field("SeAliasGuestsSid", &self.SeAliasGuestsSid)
            .field("SeAliasPowerUsersSid", &self.SeAliasPowerUsersSid)
            .field("SeAliasAccountOpsSid", &self.SeAliasAccountOpsSid)
            .field("SeAliasSystemOpsSid", &self.SeAliasSystemOpsSid)
            .field("SeAliasPrintOpsSid", &self.SeAliasPrintOpsSid)
            .field("SeAliasBackupOpsSid", &self.SeAliasBackupOpsSid)
            .field("SeAuthenticatedUsersSid", &self.SeAuthenticatedUsersSid)
            .field("SeRestrictedSid", &self.SeRestrictedSid)
            .field("SeAnonymousLogonSid", &self.SeAnonymousLogonSid)
            .field("SeUndockPrivilege", &self.SeUndockPrivilege)
            .field("SeSyncAgentPrivilege", &self.SeSyncAgentPrivilege)
            .field("SeEnableDelegationPrivilege", &self.SeEnableDelegationPrivilege)
            .field("SeLocalServiceSid", &self.SeLocalServiceSid)
            .field("SeNetworkServiceSid", &self.SeNetworkServiceSid)
            .field("SeManageVolumePrivilege", &self.SeManageVolumePrivilege)
            .field("SeImpersonatePrivilege", &self.SeImpersonatePrivilege)
            .field("SeCreateGlobalPrivilege", &self.SeCreateGlobalPrivilege)
            .field("SeTrustedCredManAccessPrivilege", &self.SeTrustedCredManAccessPrivilege)
            .field("SeRelabelPrivilege", &self.SeRelabelPrivilege)
            .field("SeIncreaseWorkingSetPrivilege", &self.SeIncreaseWorkingSetPrivilege)
            .field("SeTimeZonePrivilege", &self.SeTimeZonePrivilege)
            .field("SeCreateSymbolicLinkPrivilege", &self.SeCreateSymbolicLinkPrivilege)
            .field("SeIUserSid", &self.SeIUserSid)
            .field("SeUntrustedMandatorySid", &self.SeUntrustedMandatorySid)
            .field("SeLowMandatorySid", &self.SeLowMandatorySid)
            .field("SeMediumMandatorySid", &self.SeMediumMandatorySid)
            .field("SeHighMandatorySid", &self.SeHighMandatorySid)
            .field("SeSystemMandatorySid", &self.SeSystemMandatorySid)
            .field("SeOwnerRightsSid", &self.SeOwnerRightsSid)
            .field("SeAllAppPackagesSid", &self.SeAllAppPackagesSid)
            .field("SeUserModeDriversSid", &self.SeUserModeDriversSid)
            .field("SeProcTrustWinTcbSid", &self.SeProcTrustWinTcbSid)
            .field("SeTrustedInstallerSid", &self.SeTrustedInstallerSid)
            .field("SeDelegateSessionUserImpersonatePrivilege", &self.SeDelegateSessionUserImpersonatePrivilege)
            .field("SeAppSiloSid", &self.SeAppSiloSid)
            .field("SeAppSiloVolumeRootMinimalCapabilitySid", &self.SeAppSiloVolumeRootMinimalCapabilitySid)
            .field("SeAppSiloProfilesRootMinimalCapabilitySid", &self.SeAppSiloProfilesRootMinimalCapabilitySid)
            .finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for SE_EXPORTS {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for SE_EXPORTS {
    fn eq(&self, other: &Self) -> bool {
        self.SeCreateTokenPrivilege == other.SeCreateTokenPrivilege
            && self.SeAssignPrimaryTokenPrivilege == other.SeAssignPrimaryTokenPrivilege
            && self.SeLockMemoryPrivilege == other.SeLockMemoryPrivilege
            && self.SeIncreaseQuotaPrivilege == other.SeIncreaseQuotaPrivilege
            && self.SeUnsolicitedInputPrivilege == other.SeUnsolicitedInputPrivilege
            && self.SeTcbPrivilege == other.SeTcbPrivilege
            && self.SeSecurityPrivilege == other.SeSecurityPrivilege
            && self.SeTakeOwnershipPrivilege == other.SeTakeOwnershipPrivilege
            && self.SeLoadDriverPrivilege == other.SeLoadDriverPrivilege
            && self.SeCreatePagefilePrivilege == other.SeCreatePagefilePrivilege
            && self.SeIncreaseBasePriorityPrivilege == other.SeIncreaseBasePriorityPrivilege
            && self.SeSystemProfilePrivilege == other.SeSystemProfilePrivilege
            && self.SeSystemtimePrivilege == other.SeSystemtimePrivilege
            && self.SeProfileSingleProcessPrivilege == other.SeProfileSingleProcessPrivilege
            && self.SeCreatePermanentPrivilege == other.SeCreatePermanentPrivilege
            && self.SeBackupPrivilege == other.SeBackupPrivilege
            && self.SeRestorePrivilege == other.SeRestorePrivilege
            && self.SeShutdownPrivilege == other.SeShutdownPrivilege
            && self.SeDebugPrivilege == other.SeDebugPrivilege
            && self.SeAuditPrivilege == other.SeAuditPrivilege
            && self.SeSystemEnvironmentPrivilege == other.SeSystemEnvironmentPrivilege
            && self.SeChangeNotifyPrivilege == other.SeChangeNotifyPrivilege
            && self.SeRemoteShutdownPrivilege == other.SeRemoteShutdownPrivilege
            && self.SeNullSid == other.SeNullSid
            && self.SeWorldSid == other.SeWorldSid
            && self.SeLocalSid == other.SeLocalSid
            && self.SeCreatorOwnerSid == other.SeCreatorOwnerSid
            && self.SeCreatorGroupSid == other.SeCreatorGroupSid
            && self.SeNtAuthoritySid == other.SeNtAuthoritySid
            && self.SeDialupSid == other.SeDialupSid
            && self.SeNetworkSid == other.SeNetworkSid
            && self.SeBatchSid == other.SeBatchSid
            && self.SeInteractiveSid == other.SeInteractiveSid
            && self.SeLocalSystemSid == other.SeLocalSystemSid
            && self.SeAliasAdminsSid == other.SeAliasAdminsSid
            && self.SeAliasUsersSid == other.SeAliasUsersSid
            && self.SeAliasGuestsSid == other.SeAliasGuestsSid
            && self.SeAliasPowerUsersSid == other.SeAliasPowerUsersSid
            && self.SeAliasAccountOpsSid == other.SeAliasAccountOpsSid
            && self.SeAliasSystemOpsSid == other.SeAliasSystemOpsSid
            && self.SeAliasPrintOpsSid == other.SeAliasPrintOpsSid
            && self.SeAliasBackupOpsSid == other.SeAliasBackupOpsSid
            && self.SeAuthenticatedUsersSid == other.SeAuthenticatedUsersSid
            && self.SeRestrictedSid == other.SeRestrictedSid
            && self.SeAnonymousLogonSid == other.SeAnonymousLogonSid
            && self.SeUndockPrivilege == other.SeUndockPrivilege
            && self.SeSyncAgentPrivilege == other.SeSyncAgentPrivilege
            && self.SeEnableDelegationPrivilege == other.SeEnableDelegationPrivilege
            && self.SeLocalServiceSid == other.SeLocalServiceSid
            && self.SeNetworkServiceSid == other.SeNetworkServiceSid
            && self.SeManageVolumePrivilege == other.SeManageVolumePrivilege
            && self.SeImpersonatePrivilege == other.SeImpersonatePrivilege
            && self.SeCreateGlobalPrivilege == other.SeCreateGlobalPrivilege
            && self.SeTrustedCredManAccessPrivilege == other.SeTrustedCredManAccessPrivilege
            && self.SeRelabelPrivilege == other.SeRelabelPrivilege
            && self.SeIncreaseWorkingSetPrivilege == other.SeIncreaseWorkingSetPrivilege
            && self.SeTimeZonePrivilege == other.SeTimeZonePrivilege
            && self.SeCreateSymbolicLinkPrivilege == other.SeCreateSymbolicLinkPrivilege
            && self.SeIUserSid == other.SeIUserSid
            && self.SeUntrustedMandatorySid == other.SeUntrustedMandatorySid
            && self.SeLowMandatorySid == other.SeLowMandatorySid
            && self.SeMediumMandatorySid == other.SeMediumMandatorySid
            && self.SeHighMandatorySid == other.SeHighMandatorySid
            && self.SeSystemMandatorySid == other.SeSystemMandatorySid
            && self.SeOwnerRightsSid == other.SeOwnerRightsSid
            && self.SeAllAppPackagesSid == other.SeAllAppPackagesSid
            && self.SeUserModeDriversSid == other.SeUserModeDriversSid
            && self.SeProcTrustWinTcbSid == other.SeProcTrustWinTcbSid
            && self.SeTrustedInstallerSid == other.SeTrustedInstallerSid
            && self.SeDelegateSessionUserImpersonatePrivilege == other.SeDelegateSessionUserImpersonatePrivilege
            && self.SeAppSiloSid == other.SeAppSiloSid
            && self.SeAppSiloVolumeRootMinimalCapabilitySid == other.SeAppSiloVolumeRootMinimalCapabilitySid
            && self.SeAppSiloProfilesRootMinimalCapabilitySid == other.SeAppSiloProfilesRootMinimalCapabilitySid
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for SE_EXPORTS {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for SE_EXPORTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Security\"`*"]
#[cfg(feature = "Win32_Security")]
pub struct SE_SECURITY_DESCRIPTOR {
    pub Size: u32,
    pub Flags: u32,
    pub SecurityDescriptor: super::super::super::Win32::Security::PSECURITY_DESCRIPTOR,
}
#[cfg(feature = "Win32_Security")]
impl ::core::marker::Copy for SE_SECURITY_DESCRIPTOR {}
#[cfg(feature = "Win32_Security")]
impl ::core::clone::Clone for SE_SECURITY_DESCRIPTOR {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Security")]
impl ::core::fmt::Debug for SE_SECURITY_DESCRIPTOR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SE_SECURITY_DESCRIPTOR").field("Size", &self.Size).field("Flags", &self.Flags).field("SecurityDescriptor", &self.SecurityDescriptor).finish()
    }
}
#[cfg(feature = "Win32_Security")]
impl ::windows_core::TypeKind for SE_SECURITY_DESCRIPTOR {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Security")]
impl ::core::cmp::PartialEq for SE_SECURITY_DESCRIPTOR {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.Flags == other.Flags && self.SecurityDescriptor == other.SecurityDescriptor
    }
}
#[cfg(feature = "Win32_Security")]
impl ::core::cmp::Eq for SE_SECURITY_DESCRIPTOR {}
#[cfg(feature = "Win32_Security")]
impl ::core::default::Default for SE_SECURITY_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Security\"`*"]
#[cfg(feature = "Win32_Security")]
pub union SE_SID {
    pub Sid: super::super::super::Win32::Security::SID,
    pub Buffer: [u8; 68],
}
#[cfg(feature = "Win32_Security")]
impl ::core::marker::Copy for SE_SID {}
#[cfg(feature = "Win32_Security")]
impl ::core::clone::Clone for SE_SID {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Security")]
impl ::windows_core::TypeKind for SE_SID {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Security")]
impl ::core::default::Default for SE_SID {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
pub struct SE_TOKEN_USER {
    pub Anonymous1: SE_TOKEN_USER_0,
    pub Anonymous2: SE_TOKEN_USER_1,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::marker::Copy for SE_TOKEN_USER {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::clone::Clone for SE_TOKEN_USER {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::windows_core::TypeKind for SE_TOKEN_USER {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::default::Default for SE_TOKEN_USER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
pub union SE_TOKEN_USER_0 {
    pub TokenUser: TOKEN_USER,
    pub User: SID_AND_ATTRIBUTES,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::marker::Copy for SE_TOKEN_USER_0 {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::clone::Clone for SE_TOKEN_USER_0 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::windows_core::TypeKind for SE_TOKEN_USER_0 {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::default::Default for SE_TOKEN_USER_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
pub union SE_TOKEN_USER_1 {
    pub Sid: super::super::super::Win32::Security::SID,
    pub Buffer: [u8; 68],
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::marker::Copy for SE_TOKEN_USER_1 {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::clone::Clone for SE_TOKEN_USER_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::windows_core::TypeKind for SE_TOKEN_USER_1 {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::default::Default for SE_TOKEN_USER_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SHARED_VIRTUAL_DISK_SUPPORT {
    pub SharedVirtualDiskSupport: SharedVirtualDiskSupportType,
    pub HandleState: SharedVirtualDiskHandleState,
}
impl ::core::marker::Copy for SHARED_VIRTUAL_DISK_SUPPORT {}
impl ::core::clone::Clone for SHARED_VIRTUAL_DISK_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHARED_VIRTUAL_DISK_SUPPORT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHARED_VIRTUAL_DISK_SUPPORT").field("SharedVirtualDiskSupport", &self.SharedVirtualDiskSupport).field("HandleState", &self.HandleState).finish()
    }
}
impl ::windows_core::TypeKind for SHARED_VIRTUAL_DISK_SUPPORT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SHARED_VIRTUAL_DISK_SUPPORT {
    fn eq(&self, other: &Self) -> bool {
        self.SharedVirtualDiskSupport == other.SharedVirtualDiskSupport && self.HandleState == other.HandleState
    }
}
impl ::core::cmp::Eq for SHARED_VIRTUAL_DISK_SUPPORT {}
impl ::core::default::Default for SHARED_VIRTUAL_DISK_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SHRINK_VOLUME_INFORMATION {
    pub ShrinkRequestType: SHRINK_VOLUME_REQUEST_TYPES,
    pub Flags: u64,
    pub NewNumberOfSectors: i64,
}
impl ::core::marker::Copy for SHRINK_VOLUME_INFORMATION {}
impl ::core::clone::Clone for SHRINK_VOLUME_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHRINK_VOLUME_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHRINK_VOLUME_INFORMATION").field("ShrinkRequestType", &self.ShrinkRequestType).field("Flags", &self.Flags).field("NewNumberOfSectors", &self.NewNumberOfSectors).finish()
    }
}
impl ::windows_core::TypeKind for SHRINK_VOLUME_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SHRINK_VOLUME_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.ShrinkRequestType == other.ShrinkRequestType && self.Flags == other.Flags && self.NewNumberOfSectors == other.NewNumberOfSectors
    }
}
impl ::core::cmp::Eq for SHRINK_VOLUME_INFORMATION {}
impl ::core::default::Default for SHRINK_VOLUME_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SHUFFLE_FILE_DATA {
    pub StartingOffset: i64,
    pub Length: i64,
    pub Flags: u32,
}
impl ::core::marker::Copy for SHUFFLE_FILE_DATA {}
impl ::core::clone::Clone for SHUFFLE_FILE_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SHUFFLE_FILE_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SHUFFLE_FILE_DATA").field("StartingOffset", &self.StartingOffset).field("Length", &self.Length).field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for SHUFFLE_FILE_DATA {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SHUFFLE_FILE_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.StartingOffset == other.StartingOffset && self.Length == other.Length && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for SHUFFLE_FILE_DATA {}
impl ::core::default::Default for SHUFFLE_FILE_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct SID_AND_ATTRIBUTES {
    pub Sid: super::super::super::Win32::Foundation::PSID,
    pub Attributes: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for SID_AND_ATTRIBUTES {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for SID_AND_ATTRIBUTES {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for SID_AND_ATTRIBUTES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SID_AND_ATTRIBUTES").field("Sid", &self.Sid).field("Attributes", &self.Attributes).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for SID_AND_ATTRIBUTES {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for SID_AND_ATTRIBUTES {
    fn eq(&self, other: &Self) -> bool {
        self.Sid == other.Sid && self.Attributes == other.Attributes
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for SID_AND_ATTRIBUTES {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for SID_AND_ATTRIBUTES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct SID_AND_ATTRIBUTES_HASH {
    pub SidCount: u32,
    pub SidAttr: *mut SID_AND_ATTRIBUTES,
    pub Hash: [usize; 32],
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for SID_AND_ATTRIBUTES_HASH {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for SID_AND_ATTRIBUTES_HASH {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for SID_AND_ATTRIBUTES_HASH {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SID_AND_ATTRIBUTES_HASH").field("SidCount", &self.SidCount).field("SidAttr", &self.SidAttr).field("Hash", &self.Hash).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for SID_AND_ATTRIBUTES_HASH {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for SID_AND_ATTRIBUTES_HASH {
    fn eq(&self, other: &Self) -> bool {
        self.SidCount == other.SidCount && self.SidAttr == other.SidAttr && self.Hash == other.Hash
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for SID_AND_ATTRIBUTES_HASH {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for SID_AND_ATTRIBUTES_HASH {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SID_IDENTIFIER_AUTHORITY {
    pub Value: [u8; 6],
}
impl ::core::marker::Copy for SID_IDENTIFIER_AUTHORITY {}
impl ::core::clone::Clone for SID_IDENTIFIER_AUTHORITY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SID_IDENTIFIER_AUTHORITY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SID_IDENTIFIER_AUTHORITY").field("Value", &self.Value).finish()
    }
}
impl ::windows_core::TypeKind for SID_IDENTIFIER_AUTHORITY {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SID_IDENTIFIER_AUTHORITY {
    fn eq(&self, other: &Self) -> bool {
        self.Value == other.Value
    }
}
impl ::core::cmp::Eq for SID_IDENTIFIER_AUTHORITY {}
impl ::core::default::Default for SID_IDENTIFIER_AUTHORITY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SI_COPYFILE {
    pub SourceFileNameLength: u32,
    pub DestinationFileNameLength: u32,
    pub Flags: u32,
    pub FileNameBuffer: [u16; 1],
}
impl ::core::marker::Copy for SI_COPYFILE {}
impl ::core::clone::Clone for SI_COPYFILE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SI_COPYFILE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SI_COPYFILE").field("SourceFileNameLength", &self.SourceFileNameLength).field("DestinationFileNameLength", &self.DestinationFileNameLength).field("Flags", &self.Flags).field("FileNameBuffer", &self.FileNameBuffer).finish()
    }
}
impl ::windows_core::TypeKind for SI_COPYFILE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SI_COPYFILE {
    fn eq(&self, other: &Self) -> bool {
        self.SourceFileNameLength == other.SourceFileNameLength && self.DestinationFileNameLength == other.DestinationFileNameLength && self.Flags == other.Flags && self.FileNameBuffer == other.FileNameBuffer
    }
}
impl ::core::cmp::Eq for SI_COPYFILE {}
impl ::core::default::Default for SI_COPYFILE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SMB_SHARE_FLUSH_AND_PURGE_INPUT {
    pub Version: u16,
}
impl ::core::marker::Copy for SMB_SHARE_FLUSH_AND_PURGE_INPUT {}
impl ::core::clone::Clone for SMB_SHARE_FLUSH_AND_PURGE_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SMB_SHARE_FLUSH_AND_PURGE_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SMB_SHARE_FLUSH_AND_PURGE_INPUT").field("Version", &self.Version).finish()
    }
}
impl ::windows_core::TypeKind for SMB_SHARE_FLUSH_AND_PURGE_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SMB_SHARE_FLUSH_AND_PURGE_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
    }
}
impl ::core::cmp::Eq for SMB_SHARE_FLUSH_AND_PURGE_INPUT {}
impl ::core::default::Default for SMB_SHARE_FLUSH_AND_PURGE_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SMB_SHARE_FLUSH_AND_PURGE_OUTPUT {
    pub cEntriesPurged: u32,
}
impl ::core::marker::Copy for SMB_SHARE_FLUSH_AND_PURGE_OUTPUT {}
impl ::core::clone::Clone for SMB_SHARE_FLUSH_AND_PURGE_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SMB_SHARE_FLUSH_AND_PURGE_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SMB_SHARE_FLUSH_AND_PURGE_OUTPUT").field("cEntriesPurged", &self.cEntriesPurged).finish()
    }
}
impl ::windows_core::TypeKind for SMB_SHARE_FLUSH_AND_PURGE_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SMB_SHARE_FLUSH_AND_PURGE_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.cEntriesPurged == other.cEntriesPurged
    }
}
impl ::core::cmp::Eq for SMB_SHARE_FLUSH_AND_PURGE_OUTPUT {}
impl ::core::default::Default for SMB_SHARE_FLUSH_AND_PURGE_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct SOCKADDR_STORAGE(pub u8);
impl ::core::marker::Copy for SOCKADDR_STORAGE {}
impl ::core::clone::Clone for SOCKADDR_STORAGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for SOCKADDR_STORAGE {
    type TypeKind = ::windows_core::CopyType;
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct SRV_OPEN_ECP_CONTEXT {
    pub ShareName: *mut super::super::super::Win32::Foundation::UNICODE_STRING,
    pub SocketAddress: *mut SOCKADDR_STORAGE,
    pub OplockBlockState: super::super::super::Win32::Foundation::BOOLEAN,
    pub OplockAppState: super::super::super::Win32::Foundation::BOOLEAN,
    pub OplockFinalState: super::super::super::Win32::Foundation::BOOLEAN,
    pub Version: u16,
    pub InstanceType: SRV_INSTANCE_TYPE,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for SRV_OPEN_ECP_CONTEXT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for SRV_OPEN_ECP_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for SRV_OPEN_ECP_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SRV_OPEN_ECP_CONTEXT").field("ShareName", &self.ShareName).field("SocketAddress", &self.SocketAddress).field("OplockBlockState", &self.OplockBlockState).field("OplockAppState", &self.OplockAppState).field("OplockFinalState", &self.OplockFinalState).field("Version", &self.Version).field("InstanceType", &self.InstanceType).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for SRV_OPEN_ECP_CONTEXT {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for SRV_OPEN_ECP_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.ShareName == other.ShareName && self.SocketAddress == other.SocketAddress && self.OplockBlockState == other.OplockBlockState && self.OplockAppState == other.OplockAppState && self.OplockFinalState == other.OplockFinalState && self.Version == other.Version && self.InstanceType == other.InstanceType
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for SRV_OPEN_ECP_CONTEXT {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for SRV_OPEN_ECP_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct STARTING_LCN_INPUT_BUFFER {
    pub StartingLcn: i64,
}
impl ::core::marker::Copy for STARTING_LCN_INPUT_BUFFER {}
impl ::core::clone::Clone for STARTING_LCN_INPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for STARTING_LCN_INPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("STARTING_LCN_INPUT_BUFFER").field("StartingLcn", &self.StartingLcn).finish()
    }
}
impl ::windows_core::TypeKind for STARTING_LCN_INPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for STARTING_LCN_INPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.StartingLcn == other.StartingLcn
    }
}
impl ::core::cmp::Eq for STARTING_LCN_INPUT_BUFFER {}
impl ::core::default::Default for STARTING_LCN_INPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct STARTING_LCN_INPUT_BUFFER_EX {
    pub StartingLcn: i64,
    pub Flags: u32,
}
impl ::core::marker::Copy for STARTING_LCN_INPUT_BUFFER_EX {}
impl ::core::clone::Clone for STARTING_LCN_INPUT_BUFFER_EX {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for STARTING_LCN_INPUT_BUFFER_EX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("STARTING_LCN_INPUT_BUFFER_EX").field("StartingLcn", &self.StartingLcn).field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for STARTING_LCN_INPUT_BUFFER_EX {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for STARTING_LCN_INPUT_BUFFER_EX {
    fn eq(&self, other: &Self) -> bool {
        self.StartingLcn == other.StartingLcn && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for STARTING_LCN_INPUT_BUFFER_EX {}
impl ::core::default::Default for STARTING_LCN_INPUT_BUFFER_EX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct STARTING_VCN_INPUT_BUFFER {
    pub StartingVcn: i64,
}
impl ::core::marker::Copy for STARTING_VCN_INPUT_BUFFER {}
impl ::core::clone::Clone for STARTING_VCN_INPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for STARTING_VCN_INPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("STARTING_VCN_INPUT_BUFFER").field("StartingVcn", &self.StartingVcn).finish()
    }
}
impl ::windows_core::TypeKind for STARTING_VCN_INPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for STARTING_VCN_INPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.StartingVcn == other.StartingVcn
    }
}
impl ::core::cmp::Eq for STARTING_VCN_INPUT_BUFFER {}
impl ::core::default::Default for STARTING_VCN_INPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY {
    pub EntryLength: u32,
    pub DependencyTypeFlags: u32,
    pub ProviderSpecificFlags: u32,
    pub VirtualStorageType: VIRTUAL_STORAGE_TYPE,
}
impl ::core::marker::Copy for STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY {}
impl ::core::clone::Clone for STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY").field("EntryLength", &self.EntryLength).field("DependencyTypeFlags", &self.DependencyTypeFlags).field("ProviderSpecificFlags", &self.ProviderSpecificFlags).field("VirtualStorageType", &self.VirtualStorageType).finish()
    }
}
impl ::windows_core::TypeKind for STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.EntryLength == other.EntryLength && self.DependencyTypeFlags == other.DependencyTypeFlags && self.ProviderSpecificFlags == other.ProviderSpecificFlags && self.VirtualStorageType == other.VirtualStorageType
    }
}
impl ::core::cmp::Eq for STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY {}
impl ::core::default::Default for STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY {
    pub EntryLength: u32,
    pub DependencyTypeFlags: u32,
    pub ProviderSpecificFlags: u32,
    pub VirtualStorageType: VIRTUAL_STORAGE_TYPE,
    pub AncestorLevel: u32,
    pub HostVolumeNameOffset: u32,
    pub HostVolumeNameSize: u32,
    pub DependentVolumeNameOffset: u32,
    pub DependentVolumeNameSize: u32,
    pub RelativePathOffset: u32,
    pub RelativePathSize: u32,
    pub DependentDeviceNameOffset: u32,
    pub DependentDeviceNameSize: u32,
}
impl ::core::marker::Copy for STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY {}
impl ::core::clone::Clone for STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY")
            .field("EntryLength", &self.EntryLength)
            .field("DependencyTypeFlags", &self.DependencyTypeFlags)
            .field("ProviderSpecificFlags", &self.ProviderSpecificFlags)
            .field("VirtualStorageType", &self.VirtualStorageType)
            .field("AncestorLevel", &self.AncestorLevel)
            .field("HostVolumeNameOffset", &self.HostVolumeNameOffset)
            .field("HostVolumeNameSize", &self.HostVolumeNameSize)
            .field("DependentVolumeNameOffset", &self.DependentVolumeNameOffset)
            .field("DependentVolumeNameSize", &self.DependentVolumeNameSize)
            .field("RelativePathOffset", &self.RelativePathOffset)
            .field("RelativePathSize", &self.RelativePathSize)
            .field("DependentDeviceNameOffset", &self.DependentDeviceNameOffset)
            .field("DependentDeviceNameSize", &self.DependentDeviceNameSize)
            .finish()
    }
}
impl ::windows_core::TypeKind for STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.EntryLength == other.EntryLength && self.DependencyTypeFlags == other.DependencyTypeFlags && self.ProviderSpecificFlags == other.ProviderSpecificFlags && self.VirtualStorageType == other.VirtualStorageType && self.AncestorLevel == other.AncestorLevel && self.HostVolumeNameOffset == other.HostVolumeNameOffset && self.HostVolumeNameSize == other.HostVolumeNameSize && self.DependentVolumeNameOffset == other.DependentVolumeNameOffset && self.DependentVolumeNameSize == other.DependentVolumeNameSize && self.RelativePathOffset == other.RelativePathOffset && self.RelativePathSize == other.RelativePathSize && self.DependentDeviceNameOffset == other.DependentDeviceNameOffset && self.DependentDeviceNameSize == other.DependentDeviceNameSize
    }
}
impl ::core::cmp::Eq for STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY {}
impl ::core::default::Default for STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST {
    pub RequestLevel: u32,
    pub RequestFlags: u32,
}
impl ::core::marker::Copy for STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST {}
impl ::core::clone::Clone for STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST").field("RequestLevel", &self.RequestLevel).field("RequestFlags", &self.RequestFlags).finish()
    }
}
impl ::windows_core::TypeKind for STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST {
    fn eq(&self, other: &Self) -> bool {
        self.RequestLevel == other.RequestLevel && self.RequestFlags == other.RequestFlags
    }
}
impl ::core::cmp::Eq for STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST {}
impl ::core::default::Default for STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE {
    pub ResponseLevel: u32,
    pub NumberEntries: u32,
    pub Anonymous: STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE_0,
}
impl ::core::marker::Copy for STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE {}
impl ::core::clone::Clone for STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub union STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE_0 {
    pub Lev1Depends: [STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY; 1],
    pub Lev2Depends: [STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY; 1],
}
impl ::core::marker::Copy for STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE_0 {}
impl ::core::clone::Clone for STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct STREAMS_ASSOCIATE_ID_INPUT_BUFFER {
    pub Flags: u32,
    pub StreamId: u32,
}
impl ::core::marker::Copy for STREAMS_ASSOCIATE_ID_INPUT_BUFFER {}
impl ::core::clone::Clone for STREAMS_ASSOCIATE_ID_INPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for STREAMS_ASSOCIATE_ID_INPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("STREAMS_ASSOCIATE_ID_INPUT_BUFFER").field("Flags", &self.Flags).field("StreamId", &self.StreamId).finish()
    }
}
impl ::windows_core::TypeKind for STREAMS_ASSOCIATE_ID_INPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for STREAMS_ASSOCIATE_ID_INPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags && self.StreamId == other.StreamId
    }
}
impl ::core::cmp::Eq for STREAMS_ASSOCIATE_ID_INPUT_BUFFER {}
impl ::core::default::Default for STREAMS_ASSOCIATE_ID_INPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct STREAMS_QUERY_ID_OUTPUT_BUFFER {
    pub StreamId: u32,
}
impl ::core::marker::Copy for STREAMS_QUERY_ID_OUTPUT_BUFFER {}
impl ::core::clone::Clone for STREAMS_QUERY_ID_OUTPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for STREAMS_QUERY_ID_OUTPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("STREAMS_QUERY_ID_OUTPUT_BUFFER").field("StreamId", &self.StreamId).finish()
    }
}
impl ::windows_core::TypeKind for STREAMS_QUERY_ID_OUTPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for STREAMS_QUERY_ID_OUTPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.StreamId == other.StreamId
    }
}
impl ::core::cmp::Eq for STREAMS_QUERY_ID_OUTPUT_BUFFER {}
impl ::core::default::Default for STREAMS_QUERY_ID_OUTPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER {
    pub OptimalWriteSize: u32,
    pub StreamGranularitySize: u32,
    pub StreamIdMin: u32,
    pub StreamIdMax: u32,
}
impl ::core::marker::Copy for STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER {}
impl ::core::clone::Clone for STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER").field("OptimalWriteSize", &self.OptimalWriteSize).field("StreamGranularitySize", &self.StreamGranularitySize).field("StreamIdMin", &self.StreamIdMin).field("StreamIdMax", &self.StreamIdMax).finish()
    }
}
impl ::windows_core::TypeKind for STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.OptimalWriteSize == other.OptimalWriteSize && self.StreamGranularitySize == other.StreamGranularitySize && self.StreamIdMin == other.StreamIdMin && self.StreamIdMax == other.StreamIdMax
    }
}
impl ::core::cmp::Eq for STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER {}
impl ::core::default::Default for STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct STREAM_EXTENT_ENTRY {
    pub Flags: u32,
    pub ExtentInformation: STREAM_EXTENT_ENTRY_0,
}
impl ::core::marker::Copy for STREAM_EXTENT_ENTRY {}
impl ::core::clone::Clone for STREAM_EXTENT_ENTRY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for STREAM_EXTENT_ENTRY {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for STREAM_EXTENT_ENTRY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub union STREAM_EXTENT_ENTRY_0 {
    pub RetrievalPointers: RETRIEVAL_POINTERS_BUFFER,
}
impl ::core::marker::Copy for STREAM_EXTENT_ENTRY_0 {}
impl ::core::clone::Clone for STREAM_EXTENT_ENTRY_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for STREAM_EXTENT_ENTRY_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for STREAM_EXTENT_ENTRY_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct STREAM_INFORMATION_ENTRY {
    pub Version: u32,
    pub Flags: u32,
    pub StreamInformation: STREAM_INFORMATION_ENTRY_0,
}
impl ::core::marker::Copy for STREAM_INFORMATION_ENTRY {}
impl ::core::clone::Clone for STREAM_INFORMATION_ENTRY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for STREAM_INFORMATION_ENTRY {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for STREAM_INFORMATION_ENTRY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub union STREAM_INFORMATION_ENTRY_0 {
    pub DesiredStorageClass: STREAM_INFORMATION_ENTRY_0_1,
    pub DataStream: STREAM_INFORMATION_ENTRY_0_0,
    pub Reparse: STREAM_INFORMATION_ENTRY_0_3,
    pub Ea: STREAM_INFORMATION_ENTRY_0_2,
}
impl ::core::marker::Copy for STREAM_INFORMATION_ENTRY_0 {}
impl ::core::clone::Clone for STREAM_INFORMATION_ENTRY_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for STREAM_INFORMATION_ENTRY_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for STREAM_INFORMATION_ENTRY_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct STREAM_INFORMATION_ENTRY_0_0 {
    pub Length: u16,
    pub Flags: u16,
    pub Reserved: u32,
    pub Vdl: u64,
}
impl ::core::marker::Copy for STREAM_INFORMATION_ENTRY_0_0 {}
impl ::core::clone::Clone for STREAM_INFORMATION_ENTRY_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for STREAM_INFORMATION_ENTRY_0_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("STREAM_INFORMATION_ENTRY_0_0").field("Length", &self.Length).field("Flags", &self.Flags).field("Reserved", &self.Reserved).field("Vdl", &self.Vdl).finish()
    }
}
impl ::windows_core::TypeKind for STREAM_INFORMATION_ENTRY_0_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for STREAM_INFORMATION_ENTRY_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.Length == other.Length && self.Flags == other.Flags && self.Reserved == other.Reserved && self.Vdl == other.Vdl
    }
}
impl ::core::cmp::Eq for STREAM_INFORMATION_ENTRY_0_0 {}
impl ::core::default::Default for STREAM_INFORMATION_ENTRY_0_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct STREAM_INFORMATION_ENTRY_0_1 {
    pub Class: FILE_STORAGE_TIER_CLASS,
    pub Flags: u32,
}
impl ::core::marker::Copy for STREAM_INFORMATION_ENTRY_0_1 {}
impl ::core::clone::Clone for STREAM_INFORMATION_ENTRY_0_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for STREAM_INFORMATION_ENTRY_0_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("STREAM_INFORMATION_ENTRY_0_1").field("Class", &self.Class).field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for STREAM_INFORMATION_ENTRY_0_1 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for STREAM_INFORMATION_ENTRY_0_1 {
    fn eq(&self, other: &Self) -> bool {
        self.Class == other.Class && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for STREAM_INFORMATION_ENTRY_0_1 {}
impl ::core::default::Default for STREAM_INFORMATION_ENTRY_0_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct STREAM_INFORMATION_ENTRY_0_2 {
    pub Length: u16,
    pub Flags: u16,
    pub EaSize: u32,
    pub EaInformationOffset: u32,
}
impl ::core::marker::Copy for STREAM_INFORMATION_ENTRY_0_2 {}
impl ::core::clone::Clone for STREAM_INFORMATION_ENTRY_0_2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for STREAM_INFORMATION_ENTRY_0_2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("STREAM_INFORMATION_ENTRY_0_2").field("Length", &self.Length).field("Flags", &self.Flags).field("EaSize", &self.EaSize).field("EaInformationOffset", &self.EaInformationOffset).finish()
    }
}
impl ::windows_core::TypeKind for STREAM_INFORMATION_ENTRY_0_2 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for STREAM_INFORMATION_ENTRY_0_2 {
    fn eq(&self, other: &Self) -> bool {
        self.Length == other.Length && self.Flags == other.Flags && self.EaSize == other.EaSize && self.EaInformationOffset == other.EaInformationOffset
    }
}
impl ::core::cmp::Eq for STREAM_INFORMATION_ENTRY_0_2 {}
impl ::core::default::Default for STREAM_INFORMATION_ENTRY_0_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct STREAM_INFORMATION_ENTRY_0_3 {
    pub Length: u16,
    pub Flags: u16,
    pub ReparseDataSize: u32,
    pub ReparseDataOffset: u32,
}
impl ::core::marker::Copy for STREAM_INFORMATION_ENTRY_0_3 {}
impl ::core::clone::Clone for STREAM_INFORMATION_ENTRY_0_3 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for STREAM_INFORMATION_ENTRY_0_3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("STREAM_INFORMATION_ENTRY_0_3").field("Length", &self.Length).field("Flags", &self.Flags).field("ReparseDataSize", &self.ReparseDataSize).field("ReparseDataOffset", &self.ReparseDataOffset).finish()
    }
}
impl ::windows_core::TypeKind for STREAM_INFORMATION_ENTRY_0_3 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for STREAM_INFORMATION_ENTRY_0_3 {
    fn eq(&self, other: &Self) -> bool {
        self.Length == other.Length && self.Flags == other.Flags && self.ReparseDataSize == other.ReparseDataSize && self.ReparseDataOffset == other.ReparseDataOffset
    }
}
impl ::core::cmp::Eq for STREAM_INFORMATION_ENTRY_0_3 {}
impl ::core::default::Default for STREAM_INFORMATION_ENTRY_0_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct STREAM_LAYOUT_ENTRY {
    pub Version: u32,
    pub NextStreamOffset: u32,
    pub Flags: u32,
    pub ExtentInformationOffset: u32,
    pub AllocationSize: i64,
    pub EndOfFile: i64,
    pub StreamInformationOffset: u32,
    pub AttributeTypeCode: u32,
    pub AttributeFlags: u32,
    pub StreamIdentifierLength: u32,
    pub StreamIdentifier: [u16; 1],
}
impl ::core::marker::Copy for STREAM_LAYOUT_ENTRY {}
impl ::core::clone::Clone for STREAM_LAYOUT_ENTRY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for STREAM_LAYOUT_ENTRY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("STREAM_LAYOUT_ENTRY")
            .field("Version", &self.Version)
            .field("NextStreamOffset", &self.NextStreamOffset)
            .field("Flags", &self.Flags)
            .field("ExtentInformationOffset", &self.ExtentInformationOffset)
            .field("AllocationSize", &self.AllocationSize)
            .field("EndOfFile", &self.EndOfFile)
            .field("StreamInformationOffset", &self.StreamInformationOffset)
            .field("AttributeTypeCode", &self.AttributeTypeCode)
            .field("AttributeFlags", &self.AttributeFlags)
            .field("StreamIdentifierLength", &self.StreamIdentifierLength)
            .field("StreamIdentifier", &self.StreamIdentifier)
            .finish()
    }
}
impl ::windows_core::TypeKind for STREAM_LAYOUT_ENTRY {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for STREAM_LAYOUT_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.NextStreamOffset == other.NextStreamOffset && self.Flags == other.Flags && self.ExtentInformationOffset == other.ExtentInformationOffset && self.AllocationSize == other.AllocationSize && self.EndOfFile == other.EndOfFile && self.StreamInformationOffset == other.StreamInformationOffset && self.AttributeTypeCode == other.AttributeTypeCode && self.AttributeFlags == other.AttributeFlags && self.StreamIdentifierLength == other.StreamIdentifierLength && self.StreamIdentifier == other.StreamIdentifier
    }
}
impl ::core::cmp::Eq for STREAM_LAYOUT_ENTRY {}
impl ::core::default::Default for STREAM_LAYOUT_ENTRY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SYSTEM_ACCESS_FILTER_ACE {
    pub Header: ACE_HEADER,
    pub Mask: u32,
    pub SidStart: u32,
}
impl ::core::marker::Copy for SYSTEM_ACCESS_FILTER_ACE {}
impl ::core::clone::Clone for SYSTEM_ACCESS_FILTER_ACE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SYSTEM_ACCESS_FILTER_ACE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SYSTEM_ACCESS_FILTER_ACE").field("Header", &self.Header).field("Mask", &self.Mask).field("SidStart", &self.SidStart).finish()
    }
}
impl ::windows_core::TypeKind for SYSTEM_ACCESS_FILTER_ACE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SYSTEM_ACCESS_FILTER_ACE {
    fn eq(&self, other: &Self) -> bool {
        self.Header == other.Header && self.Mask == other.Mask && self.SidStart == other.SidStart
    }
}
impl ::core::cmp::Eq for SYSTEM_ACCESS_FILTER_ACE {}
impl ::core::default::Default for SYSTEM_ACCESS_FILTER_ACE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SYSTEM_ALARM_ACE {
    pub Header: ACE_HEADER,
    pub Mask: u32,
    pub SidStart: u32,
}
impl ::core::marker::Copy for SYSTEM_ALARM_ACE {}
impl ::core::clone::Clone for SYSTEM_ALARM_ACE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SYSTEM_ALARM_ACE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SYSTEM_ALARM_ACE").field("Header", &self.Header).field("Mask", &self.Mask).field("SidStart", &self.SidStart).finish()
    }
}
impl ::windows_core::TypeKind for SYSTEM_ALARM_ACE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SYSTEM_ALARM_ACE {
    fn eq(&self, other: &Self) -> bool {
        self.Header == other.Header && self.Mask == other.Mask && self.SidStart == other.SidStart
    }
}
impl ::core::cmp::Eq for SYSTEM_ALARM_ACE {}
impl ::core::default::Default for SYSTEM_ALARM_ACE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SYSTEM_AUDIT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: u32,
    pub SidStart: u32,
}
impl ::core::marker::Copy for SYSTEM_AUDIT_ACE {}
impl ::core::clone::Clone for SYSTEM_AUDIT_ACE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SYSTEM_AUDIT_ACE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SYSTEM_AUDIT_ACE").field("Header", &self.Header).field("Mask", &self.Mask).field("SidStart", &self.SidStart).finish()
    }
}
impl ::windows_core::TypeKind for SYSTEM_AUDIT_ACE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SYSTEM_AUDIT_ACE {
    fn eq(&self, other: &Self) -> bool {
        self.Header == other.Header && self.Mask == other.Mask && self.SidStart == other.SidStart
    }
}
impl ::core::cmp::Eq for SYSTEM_AUDIT_ACE {}
impl ::core::default::Default for SYSTEM_AUDIT_ACE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SYSTEM_MANDATORY_LABEL_ACE {
    pub Header: ACE_HEADER,
    pub Mask: u32,
    pub SidStart: u32,
}
impl ::core::marker::Copy for SYSTEM_MANDATORY_LABEL_ACE {}
impl ::core::clone::Clone for SYSTEM_MANDATORY_LABEL_ACE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SYSTEM_MANDATORY_LABEL_ACE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SYSTEM_MANDATORY_LABEL_ACE").field("Header", &self.Header).field("Mask", &self.Mask).field("SidStart", &self.SidStart).finish()
    }
}
impl ::windows_core::TypeKind for SYSTEM_MANDATORY_LABEL_ACE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SYSTEM_MANDATORY_LABEL_ACE {
    fn eq(&self, other: &Self) -> bool {
        self.Header == other.Header && self.Mask == other.Mask && self.SidStart == other.SidStart
    }
}
impl ::core::cmp::Eq for SYSTEM_MANDATORY_LABEL_ACE {}
impl ::core::default::Default for SYSTEM_MANDATORY_LABEL_ACE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SYSTEM_PROCESS_TRUST_LABEL_ACE {
    pub Header: ACE_HEADER,
    pub Mask: u32,
    pub SidStart: u32,
}
impl ::core::marker::Copy for SYSTEM_PROCESS_TRUST_LABEL_ACE {}
impl ::core::clone::Clone for SYSTEM_PROCESS_TRUST_LABEL_ACE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SYSTEM_PROCESS_TRUST_LABEL_ACE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SYSTEM_PROCESS_TRUST_LABEL_ACE").field("Header", &self.Header).field("Mask", &self.Mask).field("SidStart", &self.SidStart).finish()
    }
}
impl ::windows_core::TypeKind for SYSTEM_PROCESS_TRUST_LABEL_ACE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SYSTEM_PROCESS_TRUST_LABEL_ACE {
    fn eq(&self, other: &Self) -> bool {
        self.Header == other.Header && self.Mask == other.Mask && self.SidStart == other.SidStart
    }
}
impl ::core::cmp::Eq for SYSTEM_PROCESS_TRUST_LABEL_ACE {}
impl ::core::default::Default for SYSTEM_PROCESS_TRUST_LABEL_ACE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SYSTEM_RESOURCE_ATTRIBUTE_ACE {
    pub Header: ACE_HEADER,
    pub Mask: u32,
    pub SidStart: u32,
}
impl ::core::marker::Copy for SYSTEM_RESOURCE_ATTRIBUTE_ACE {}
impl ::core::clone::Clone for SYSTEM_RESOURCE_ATTRIBUTE_ACE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SYSTEM_RESOURCE_ATTRIBUTE_ACE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SYSTEM_RESOURCE_ATTRIBUTE_ACE").field("Header", &self.Header).field("Mask", &self.Mask).field("SidStart", &self.SidStart).finish()
    }
}
impl ::windows_core::TypeKind for SYSTEM_RESOURCE_ATTRIBUTE_ACE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SYSTEM_RESOURCE_ATTRIBUTE_ACE {
    fn eq(&self, other: &Self) -> bool {
        self.Header == other.Header && self.Mask == other.Mask && self.SidStart == other.SidStart
    }
}
impl ::core::cmp::Eq for SYSTEM_RESOURCE_ATTRIBUTE_ACE {}
impl ::core::default::Default for SYSTEM_RESOURCE_ATTRIBUTE_ACE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SYSTEM_SCOPED_POLICY_ID_ACE {
    pub Header: ACE_HEADER,
    pub Mask: u32,
    pub SidStart: u32,
}
impl ::core::marker::Copy for SYSTEM_SCOPED_POLICY_ID_ACE {}
impl ::core::clone::Clone for SYSTEM_SCOPED_POLICY_ID_ACE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SYSTEM_SCOPED_POLICY_ID_ACE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SYSTEM_SCOPED_POLICY_ID_ACE").field("Header", &self.Header).field("Mask", &self.Mask).field("SidStart", &self.SidStart).finish()
    }
}
impl ::windows_core::TypeKind for SYSTEM_SCOPED_POLICY_ID_ACE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SYSTEM_SCOPED_POLICY_ID_ACE {
    fn eq(&self, other: &Self) -> bool {
        self.Header == other.Header && self.Mask == other.Mask && self.SidStart == other.SidStart
    }
}
impl ::core::cmp::Eq for SYSTEM_SCOPED_POLICY_ID_ACE {}
impl ::core::default::Default for SYSTEM_SCOPED_POLICY_ID_ACE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecBuffer {
    pub cbBuffer: u32,
    pub BufferType: u32,
    pub pvBuffer: *mut ::core::ffi::c_void,
}
impl ::core::marker::Copy for SecBuffer {}
impl ::core::clone::Clone for SecBuffer {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecBuffer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecBuffer").field("cbBuffer", &self.cbBuffer).field("BufferType", &self.BufferType).field("pvBuffer", &self.pvBuffer).finish()
    }
}
impl ::windows_core::TypeKind for SecBuffer {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecBuffer {
    fn eq(&self, other: &Self) -> bool {
        self.cbBuffer == other.cbBuffer && self.BufferType == other.BufferType && self.pvBuffer == other.pvBuffer
    }
}
impl ::core::cmp::Eq for SecBuffer {}
impl ::core::default::Default for SecBuffer {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecBufferDesc {
    pub ulVersion: u32,
    pub cBuffers: u32,
    pub pBuffers: *mut SecBuffer,
}
impl ::core::marker::Copy for SecBufferDesc {}
impl ::core::clone::Clone for SecBufferDesc {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecBufferDesc {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecBufferDesc").field("ulVersion", &self.ulVersion).field("cBuffers", &self.cBuffers).field("pBuffers", &self.pBuffers).finish()
    }
}
impl ::windows_core::TypeKind for SecBufferDesc {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecBufferDesc {
    fn eq(&self, other: &Self) -> bool {
        self.ulVersion == other.ulVersion && self.cBuffers == other.cBuffers && self.pBuffers == other.pBuffers
    }
}
impl ::core::cmp::Eq for SecBufferDesc {}
impl ::core::default::Default for SecBufferDesc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecHandle {
    pub dwLower: usize,
    pub dwUpper: usize,
}
impl ::core::marker::Copy for SecHandle {}
impl ::core::clone::Clone for SecHandle {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecHandle {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecHandle").field("dwLower", &self.dwLower).field("dwUpper", &self.dwUpper).finish()
    }
}
impl ::windows_core::TypeKind for SecHandle {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecHandle {
    fn eq(&self, other: &Self) -> bool {
        self.dwLower == other.dwLower && self.dwUpper == other.dwUpper
    }
}
impl ::core::cmp::Eq for SecHandle {}
impl ::core::default::Default for SecHandle {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgContext_AuthorityW {
    pub sAuthorityName: *mut u16,
}
impl ::core::marker::Copy for SecPkgContext_AuthorityW {}
impl ::core::clone::Clone for SecPkgContext_AuthorityW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgContext_AuthorityW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgContext_AuthorityW").field("sAuthorityName", &self.sAuthorityName).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgContext_AuthorityW {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgContext_AuthorityW {
    fn eq(&self, other: &Self) -> bool {
        self.sAuthorityName == other.sAuthorityName
    }
}
impl ::core::cmp::Eq for SecPkgContext_AuthorityW {}
impl ::core::default::Default for SecPkgContext_AuthorityW {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgContext_CredInfo {
    pub CredClass: SECPKG_CRED_CLASS,
    pub IsPromptingNeeded: u32,
}
impl ::core::marker::Copy for SecPkgContext_CredInfo {}
impl ::core::clone::Clone for SecPkgContext_CredInfo {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgContext_CredInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgContext_CredInfo").field("CredClass", &self.CredClass).field("IsPromptingNeeded", &self.IsPromptingNeeded).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgContext_CredInfo {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgContext_CredInfo {
    fn eq(&self, other: &Self) -> bool {
        self.CredClass == other.CredClass && self.IsPromptingNeeded == other.IsPromptingNeeded
    }
}
impl ::core::cmp::Eq for SecPkgContext_CredInfo {}
impl ::core::default::Default for SecPkgContext_CredInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgContext_CredentialNameW {
    pub CredentialType: u32,
    pub sCredentialName: *mut u16,
}
impl ::core::marker::Copy for SecPkgContext_CredentialNameW {}
impl ::core::clone::Clone for SecPkgContext_CredentialNameW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgContext_CredentialNameW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgContext_CredentialNameW").field("CredentialType", &self.CredentialType).field("sCredentialName", &self.sCredentialName).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgContext_CredentialNameW {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgContext_CredentialNameW {
    fn eq(&self, other: &Self) -> bool {
        self.CredentialType == other.CredentialType && self.sCredentialName == other.sCredentialName
    }
}
impl ::core::cmp::Eq for SecPkgContext_CredentialNameW {}
impl ::core::default::Default for SecPkgContext_CredentialNameW {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgContext_DceInfo {
    pub AuthzSvc: u32,
    pub pPac: *mut ::core::ffi::c_void,
}
impl ::core::marker::Copy for SecPkgContext_DceInfo {}
impl ::core::clone::Clone for SecPkgContext_DceInfo {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgContext_DceInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgContext_DceInfo").field("AuthzSvc", &self.AuthzSvc).field("pPac", &self.pPac).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgContext_DceInfo {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgContext_DceInfo {
    fn eq(&self, other: &Self) -> bool {
        self.AuthzSvc == other.AuthzSvc && self.pPac == other.pPac
    }
}
impl ::core::cmp::Eq for SecPkgContext_DceInfo {}
impl ::core::default::Default for SecPkgContext_DceInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgContext_Flags {
    pub Flags: u32,
}
impl ::core::marker::Copy for SecPkgContext_Flags {}
impl ::core::clone::Clone for SecPkgContext_Flags {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgContext_Flags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgContext_Flags").field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgContext_Flags {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgContext_Flags {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for SecPkgContext_Flags {}
impl ::core::default::Default for SecPkgContext_Flags {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgContext_KeyInfoW {
    pub sSignatureAlgorithmName: *mut u16,
    pub sEncryptAlgorithmName: *mut u16,
    pub KeySize: u32,
    pub SignatureAlgorithm: u32,
    pub EncryptAlgorithm: u32,
}
impl ::core::marker::Copy for SecPkgContext_KeyInfoW {}
impl ::core::clone::Clone for SecPkgContext_KeyInfoW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgContext_KeyInfoW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgContext_KeyInfoW").field("sSignatureAlgorithmName", &self.sSignatureAlgorithmName).field("sEncryptAlgorithmName", &self.sEncryptAlgorithmName).field("KeySize", &self.KeySize).field("SignatureAlgorithm", &self.SignatureAlgorithm).field("EncryptAlgorithm", &self.EncryptAlgorithm).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgContext_KeyInfoW {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgContext_KeyInfoW {
    fn eq(&self, other: &Self) -> bool {
        self.sSignatureAlgorithmName == other.sSignatureAlgorithmName && self.sEncryptAlgorithmName == other.sEncryptAlgorithmName && self.KeySize == other.KeySize && self.SignatureAlgorithm == other.SignatureAlgorithm && self.EncryptAlgorithm == other.EncryptAlgorithm
    }
}
impl ::core::cmp::Eq for SecPkgContext_KeyInfoW {}
impl ::core::default::Default for SecPkgContext_KeyInfoW {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgContext_Lifespan {
    pub tsStart: i64,
    pub tsExpiry: i64,
}
impl ::core::marker::Copy for SecPkgContext_Lifespan {}
impl ::core::clone::Clone for SecPkgContext_Lifespan {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgContext_Lifespan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgContext_Lifespan").field("tsStart", &self.tsStart).field("tsExpiry", &self.tsExpiry).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgContext_Lifespan {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgContext_Lifespan {
    fn eq(&self, other: &Self) -> bool {
        self.tsStart == other.tsStart && self.tsExpiry == other.tsExpiry
    }
}
impl ::core::cmp::Eq for SecPkgContext_Lifespan {}
impl ::core::default::Default for SecPkgContext_Lifespan {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgContext_LogoffTime {
    pub tsLogoffTime: i64,
}
impl ::core::marker::Copy for SecPkgContext_LogoffTime {}
impl ::core::clone::Clone for SecPkgContext_LogoffTime {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgContext_LogoffTime {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgContext_LogoffTime").field("tsLogoffTime", &self.tsLogoffTime).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgContext_LogoffTime {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgContext_LogoffTime {
    fn eq(&self, other: &Self) -> bool {
        self.tsLogoffTime == other.tsLogoffTime
    }
}
impl ::core::cmp::Eq for SecPkgContext_LogoffTime {}
impl ::core::default::Default for SecPkgContext_LogoffTime {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgContext_NamesW {
    pub sUserName: *mut u16,
}
impl ::core::marker::Copy for SecPkgContext_NamesW {}
impl ::core::clone::Clone for SecPkgContext_NamesW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgContext_NamesW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgContext_NamesW").field("sUserName", &self.sUserName).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgContext_NamesW {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgContext_NamesW {
    fn eq(&self, other: &Self) -> bool {
        self.sUserName == other.sUserName
    }
}
impl ::core::cmp::Eq for SecPkgContext_NamesW {}
impl ::core::default::Default for SecPkgContext_NamesW {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgContext_NegoKeys {
    pub KeyType: u32,
    pub KeyLength: u16,
    pub KeyValue: *mut u8,
    pub VerifyKeyType: u32,
    pub VerifyKeyLength: u16,
    pub VerifyKeyValue: *mut u8,
}
impl ::core::marker::Copy for SecPkgContext_NegoKeys {}
impl ::core::clone::Clone for SecPkgContext_NegoKeys {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgContext_NegoKeys {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgContext_NegoKeys").field("KeyType", &self.KeyType).field("KeyLength", &self.KeyLength).field("KeyValue", &self.KeyValue).field("VerifyKeyType", &self.VerifyKeyType).field("VerifyKeyLength", &self.VerifyKeyLength).field("VerifyKeyValue", &self.VerifyKeyValue).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgContext_NegoKeys {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgContext_NegoKeys {
    fn eq(&self, other: &Self) -> bool {
        self.KeyType == other.KeyType && self.KeyLength == other.KeyLength && self.KeyValue == other.KeyValue && self.VerifyKeyType == other.VerifyKeyType && self.VerifyKeyLength == other.VerifyKeyLength && self.VerifyKeyValue == other.VerifyKeyValue
    }
}
impl ::core::cmp::Eq for SecPkgContext_NegoKeys {}
impl ::core::default::Default for SecPkgContext_NegoKeys {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgContext_NegoPackageInfo {
    pub PackageMask: u32,
}
impl ::core::marker::Copy for SecPkgContext_NegoPackageInfo {}
impl ::core::clone::Clone for SecPkgContext_NegoPackageInfo {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgContext_NegoPackageInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgContext_NegoPackageInfo").field("PackageMask", &self.PackageMask).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgContext_NegoPackageInfo {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgContext_NegoPackageInfo {
    fn eq(&self, other: &Self) -> bool {
        self.PackageMask == other.PackageMask
    }
}
impl ::core::cmp::Eq for SecPkgContext_NegoPackageInfo {}
impl ::core::default::Default for SecPkgContext_NegoPackageInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgContext_NegoStatus {
    pub LastStatus: u32,
}
impl ::core::marker::Copy for SecPkgContext_NegoStatus {}
impl ::core::clone::Clone for SecPkgContext_NegoStatus {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgContext_NegoStatus {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgContext_NegoStatus").field("LastStatus", &self.LastStatus).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgContext_NegoStatus {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgContext_NegoStatus {
    fn eq(&self, other: &Self) -> bool {
        self.LastStatus == other.LastStatus
    }
}
impl ::core::cmp::Eq for SecPkgContext_NegoStatus {}
impl ::core::default::Default for SecPkgContext_NegoStatus {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgContext_NegotiationInfoW {
    pub PackageInfo: *mut SecPkgInfoW,
    pub NegotiationState: u32,
}
impl ::core::marker::Copy for SecPkgContext_NegotiationInfoW {}
impl ::core::clone::Clone for SecPkgContext_NegotiationInfoW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgContext_NegotiationInfoW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgContext_NegotiationInfoW").field("PackageInfo", &self.PackageInfo).field("NegotiationState", &self.NegotiationState).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgContext_NegotiationInfoW {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgContext_NegotiationInfoW {
    fn eq(&self, other: &Self) -> bool {
        self.PackageInfo == other.PackageInfo && self.NegotiationState == other.NegotiationState
    }
}
impl ::core::cmp::Eq for SecPkgContext_NegotiationInfoW {}
impl ::core::default::Default for SecPkgContext_NegotiationInfoW {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgContext_PackageInfoW {
    pub PackageInfo: *mut SecPkgInfoW,
}
impl ::core::marker::Copy for SecPkgContext_PackageInfoW {}
impl ::core::clone::Clone for SecPkgContext_PackageInfoW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgContext_PackageInfoW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgContext_PackageInfoW").field("PackageInfo", &self.PackageInfo).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgContext_PackageInfoW {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgContext_PackageInfoW {
    fn eq(&self, other: &Self) -> bool {
        self.PackageInfo == other.PackageInfo
    }
}
impl ::core::cmp::Eq for SecPkgContext_PackageInfoW {}
impl ::core::default::Default for SecPkgContext_PackageInfoW {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgContext_PasswordExpiry {
    pub tsPasswordExpires: i64,
}
impl ::core::marker::Copy for SecPkgContext_PasswordExpiry {}
impl ::core::clone::Clone for SecPkgContext_PasswordExpiry {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgContext_PasswordExpiry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgContext_PasswordExpiry").field("tsPasswordExpires", &self.tsPasswordExpires).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgContext_PasswordExpiry {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgContext_PasswordExpiry {
    fn eq(&self, other: &Self) -> bool {
        self.tsPasswordExpires == other.tsPasswordExpires
    }
}
impl ::core::cmp::Eq for SecPkgContext_PasswordExpiry {}
impl ::core::default::Default for SecPkgContext_PasswordExpiry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgContext_ProtoInfoW {
    pub sProtocolName: *mut u16,
    pub majorVersion: u32,
    pub minorVersion: u32,
}
impl ::core::marker::Copy for SecPkgContext_ProtoInfoW {}
impl ::core::clone::Clone for SecPkgContext_ProtoInfoW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgContext_ProtoInfoW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgContext_ProtoInfoW").field("sProtocolName", &self.sProtocolName).field("majorVersion", &self.majorVersion).field("minorVersion", &self.minorVersion).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgContext_ProtoInfoW {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgContext_ProtoInfoW {
    fn eq(&self, other: &Self) -> bool {
        self.sProtocolName == other.sProtocolName && self.majorVersion == other.majorVersion && self.minorVersion == other.minorVersion
    }
}
impl ::core::cmp::Eq for SecPkgContext_ProtoInfoW {}
impl ::core::default::Default for SecPkgContext_ProtoInfoW {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgContext_SessionKey {
    pub SessionKeyLength: u32,
    pub SessionKey: *mut u8,
}
impl ::core::marker::Copy for SecPkgContext_SessionKey {}
impl ::core::clone::Clone for SecPkgContext_SessionKey {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgContext_SessionKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgContext_SessionKey").field("SessionKeyLength", &self.SessionKeyLength).field("SessionKey", &self.SessionKey).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgContext_SessionKey {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgContext_SessionKey {
    fn eq(&self, other: &Self) -> bool {
        self.SessionKeyLength == other.SessionKeyLength && self.SessionKey == other.SessionKey
    }
}
impl ::core::cmp::Eq for SecPkgContext_SessionKey {}
impl ::core::default::Default for SecPkgContext_SessionKey {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgContext_Sizes {
    pub cbMaxToken: u32,
    pub cbMaxSignature: u32,
    pub cbBlockSize: u32,
    pub cbSecurityTrailer: u32,
}
impl ::core::marker::Copy for SecPkgContext_Sizes {}
impl ::core::clone::Clone for SecPkgContext_Sizes {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgContext_Sizes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgContext_Sizes").field("cbMaxToken", &self.cbMaxToken).field("cbMaxSignature", &self.cbMaxSignature).field("cbBlockSize", &self.cbBlockSize).field("cbSecurityTrailer", &self.cbSecurityTrailer).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgContext_Sizes {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgContext_Sizes {
    fn eq(&self, other: &Self) -> bool {
        self.cbMaxToken == other.cbMaxToken && self.cbMaxSignature == other.cbMaxSignature && self.cbBlockSize == other.cbBlockSize && self.cbSecurityTrailer == other.cbSecurityTrailer
    }
}
impl ::core::cmp::Eq for SecPkgContext_Sizes {}
impl ::core::default::Default for SecPkgContext_Sizes {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgContext_StreamSizes {
    pub cbHeader: u32,
    pub cbTrailer: u32,
    pub cbMaximumMessage: u32,
    pub cBuffers: u32,
    pub cbBlockSize: u32,
}
impl ::core::marker::Copy for SecPkgContext_StreamSizes {}
impl ::core::clone::Clone for SecPkgContext_StreamSizes {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgContext_StreamSizes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgContext_StreamSizes").field("cbHeader", &self.cbHeader).field("cbTrailer", &self.cbTrailer).field("cbMaximumMessage", &self.cbMaximumMessage).field("cBuffers", &self.cBuffers).field("cbBlockSize", &self.cbBlockSize).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgContext_StreamSizes {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgContext_StreamSizes {
    fn eq(&self, other: &Self) -> bool {
        self.cbHeader == other.cbHeader && self.cbTrailer == other.cbTrailer && self.cbMaximumMessage == other.cbMaximumMessage && self.cBuffers == other.cBuffers && self.cbBlockSize == other.cbBlockSize
    }
}
impl ::core::cmp::Eq for SecPkgContext_StreamSizes {}
impl ::core::default::Default for SecPkgContext_StreamSizes {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgContext_SubjectAttributes {
    pub AttributeInfo: *mut ::core::ffi::c_void,
}
impl ::core::marker::Copy for SecPkgContext_SubjectAttributes {}
impl ::core::clone::Clone for SecPkgContext_SubjectAttributes {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgContext_SubjectAttributes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgContext_SubjectAttributes").field("AttributeInfo", &self.AttributeInfo).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgContext_SubjectAttributes {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgContext_SubjectAttributes {
    fn eq(&self, other: &Self) -> bool {
        self.AttributeInfo == other.AttributeInfo
    }
}
impl ::core::cmp::Eq for SecPkgContext_SubjectAttributes {}
impl ::core::default::Default for SecPkgContext_SubjectAttributes {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgContext_UserFlags {
    pub UserFlags: u32,
}
impl ::core::marker::Copy for SecPkgContext_UserFlags {}
impl ::core::clone::Clone for SecPkgContext_UserFlags {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgContext_UserFlags {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgContext_UserFlags").field("UserFlags", &self.UserFlags).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgContext_UserFlags {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgContext_UserFlags {
    fn eq(&self, other: &Self) -> bool {
        self.UserFlags == other.UserFlags
    }
}
impl ::core::cmp::Eq for SecPkgContext_UserFlags {}
impl ::core::default::Default for SecPkgContext_UserFlags {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgCredentials_Cert {
    pub EncodedCertSize: u32,
    pub EncodedCert: *mut u8,
}
impl ::core::marker::Copy for SecPkgCredentials_Cert {}
impl ::core::clone::Clone for SecPkgCredentials_Cert {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgCredentials_Cert {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgCredentials_Cert").field("EncodedCertSize", &self.EncodedCertSize).field("EncodedCert", &self.EncodedCert).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgCredentials_Cert {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgCredentials_Cert {
    fn eq(&self, other: &Self) -> bool {
        self.EncodedCertSize == other.EncodedCertSize && self.EncodedCert == other.EncodedCert
    }
}
impl ::core::cmp::Eq for SecPkgCredentials_Cert {}
impl ::core::default::Default for SecPkgCredentials_Cert {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgCredentials_KdcProxySettingsW {
    pub Version: u32,
    pub Flags: u32,
    pub ProxyServerOffset: u16,
    pub ProxyServerLength: u16,
    pub ClientTlsCredOffset: u16,
    pub ClientTlsCredLength: u16,
}
impl ::core::marker::Copy for SecPkgCredentials_KdcProxySettingsW {}
impl ::core::clone::Clone for SecPkgCredentials_KdcProxySettingsW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgCredentials_KdcProxySettingsW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgCredentials_KdcProxySettingsW").field("Version", &self.Version).field("Flags", &self.Flags).field("ProxyServerOffset", &self.ProxyServerOffset).field("ProxyServerLength", &self.ProxyServerLength).field("ClientTlsCredOffset", &self.ClientTlsCredOffset).field("ClientTlsCredLength", &self.ClientTlsCredLength).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgCredentials_KdcProxySettingsW {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgCredentials_KdcProxySettingsW {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Flags == other.Flags && self.ProxyServerOffset == other.ProxyServerOffset && self.ProxyServerLength == other.ProxyServerLength && self.ClientTlsCredOffset == other.ClientTlsCredOffset && self.ClientTlsCredLength == other.ClientTlsCredLength
    }
}
impl ::core::cmp::Eq for SecPkgCredentials_KdcProxySettingsW {}
impl ::core::default::Default for SecPkgCredentials_KdcProxySettingsW {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgCredentials_NamesW {
    pub sUserName: *mut u16,
}
impl ::core::marker::Copy for SecPkgCredentials_NamesW {}
impl ::core::clone::Clone for SecPkgCredentials_NamesW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgCredentials_NamesW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgCredentials_NamesW").field("sUserName", &self.sUserName).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgCredentials_NamesW {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgCredentials_NamesW {
    fn eq(&self, other: &Self) -> bool {
        self.sUserName == other.sUserName
    }
}
impl ::core::cmp::Eq for SecPkgCredentials_NamesW {}
impl ::core::default::Default for SecPkgCredentials_NamesW {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgCredentials_SSIProviderW {
    pub sProviderName: *mut u16,
    pub ProviderInfoLength: u32,
    pub ProviderInfo: ::windows_core::PSTR,
}
impl ::core::marker::Copy for SecPkgCredentials_SSIProviderW {}
impl ::core::clone::Clone for SecPkgCredentials_SSIProviderW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgCredentials_SSIProviderW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgCredentials_SSIProviderW").field("sProviderName", &self.sProviderName).field("ProviderInfoLength", &self.ProviderInfoLength).field("ProviderInfo", &self.ProviderInfo).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgCredentials_SSIProviderW {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgCredentials_SSIProviderW {
    fn eq(&self, other: &Self) -> bool {
        self.sProviderName == other.sProviderName && self.ProviderInfoLength == other.ProviderInfoLength && self.ProviderInfo == other.ProviderInfo
    }
}
impl ::core::cmp::Eq for SecPkgCredentials_SSIProviderW {}
impl ::core::default::Default for SecPkgCredentials_SSIProviderW {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct SecPkgInfoW {
    pub fCapabilities: u32,
    pub wVersion: u16,
    pub wRPCID: u16,
    pub cbMaxToken: u32,
    pub Name: *mut u16,
    pub Comment: *mut u16,
}
impl ::core::marker::Copy for SecPkgInfoW {}
impl ::core::clone::Clone for SecPkgInfoW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for SecPkgInfoW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecPkgInfoW").field("fCapabilities", &self.fCapabilities).field("wVersion", &self.wVersion).field("wRPCID", &self.wRPCID).field("cbMaxToken", &self.cbMaxToken).field("Name", &self.Name).field("Comment", &self.Comment).finish()
    }
}
impl ::windows_core::TypeKind for SecPkgInfoW {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for SecPkgInfoW {
    fn eq(&self, other: &Self) -> bool {
        self.fCapabilities == other.fCapabilities && self.wVersion == other.wVersion && self.wRPCID == other.wRPCID && self.cbMaxToken == other.cbMaxToken && self.Name == other.Name && self.Comment == other.Comment
    }
}
impl ::core::cmp::Eq for SecPkgInfoW {}
impl ::core::default::Default for SecPkgInfoW {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct SecurityFunctionTableW {
    pub dwVersion: u32,
    pub EnumerateSecurityPackagesW: ENUMERATE_SECURITY_PACKAGES_FN_W,
    pub QueryCredentialsAttributesW: QUERY_CREDENTIALS_ATTRIBUTES_FN_W,
    pub AcquireCredentialsHandleW: ACQUIRE_CREDENTIALS_HANDLE_FN_W,
    pub FreeCredentialsHandle: FREE_CREDENTIALS_HANDLE_FN,
    pub Reserved2: *mut ::core::ffi::c_void,
    pub InitializeSecurityContextW: INITIALIZE_SECURITY_CONTEXT_FN_W,
    pub AcceptSecurityContext: ACCEPT_SECURITY_CONTEXT_FN,
    pub CompleteAuthToken: COMPLETE_AUTH_TOKEN_FN,
    pub DeleteSecurityContext: DELETE_SECURITY_CONTEXT_FN,
    pub ApplyControlToken: APPLY_CONTROL_TOKEN_FN,
    pub QueryContextAttributesW: QUERY_CONTEXT_ATTRIBUTES_FN_W,
    pub ImpersonateSecurityContext: IMPERSONATE_SECURITY_CONTEXT_FN,
    pub RevertSecurityContext: REVERT_SECURITY_CONTEXT_FN,
    pub MakeSignature: MAKE_SIGNATURE_FN,
    pub VerifySignature: VERIFY_SIGNATURE_FN,
    pub FreeContextBuffer: FREE_CONTEXT_BUFFER_FN,
    pub QuerySecurityPackageInfoW: QUERY_SECURITY_PACKAGE_INFO_FN_W,
    pub Reserved3: *mut ::core::ffi::c_void,
    pub Reserved4: *mut ::core::ffi::c_void,
    pub ExportSecurityContext: EXPORT_SECURITY_CONTEXT_FN,
    pub ImportSecurityContextW: IMPORT_SECURITY_CONTEXT_FN_W,
    pub AddCredentialsW: ADD_CREDENTIALS_FN_W,
    pub Reserved8: *mut ::core::ffi::c_void,
    pub QuerySecurityContextToken: QUERY_SECURITY_CONTEXT_TOKEN_FN,
    pub EncryptMessage: ENCRYPT_MESSAGE_FN,
    pub DecryptMessage: DECRYPT_MESSAGE_FN,
    pub SetContextAttributesW: SET_CONTEXT_ATTRIBUTES_FN_W,
    pub SetCredentialsAttributesW: SET_CREDENTIALS_ATTRIBUTES_FN_W,
    pub Reserved9: *mut ::core::ffi::c_void,
    pub QueryContextAttributesExW: QUERY_CONTEXT_ATTRIBUTES_EX_FN_W,
    pub QueryCredentialsAttributesExW: QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_W,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for SecurityFunctionTableW {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for SecurityFunctionTableW {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for SecurityFunctionTableW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("SecurityFunctionTableW").field("dwVersion", &self.dwVersion).field("Reserved2", &self.Reserved2).field("Reserved3", &self.Reserved3).field("Reserved4", &self.Reserved4).field("Reserved8", &self.Reserved8).field("Reserved9", &self.Reserved9).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for SecurityFunctionTableW {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for SecurityFunctionTableW {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct SspiAsyncContext(pub u8);
impl ::core::marker::Copy for SspiAsyncContext {}
impl ::core::clone::Clone for SspiAsyncContext {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for SspiAsyncContext {
    type TypeKind = ::windows_core::CopyType;
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
pub struct TOKEN_ACCESS_INFORMATION {
    pub SidHash: *mut SID_AND_ATTRIBUTES_HASH,
    pub RestrictedSidHash: *mut SID_AND_ATTRIBUTES_HASH,
    pub Privileges: *mut TOKEN_PRIVILEGES,
    pub AuthenticationId: super::super::super::Win32::Foundation::LUID,
    pub TokenType: TOKEN_TYPE,
    pub ImpersonationLevel: super::super::super::Win32::Security::SECURITY_IMPERSONATION_LEVEL,
    pub MandatoryPolicy: TOKEN_MANDATORY_POLICY,
    pub Flags: u32,
    pub AppContainerNumber: u32,
    pub PackageSid: super::super::super::Win32::Foundation::PSID,
    pub CapabilitiesHash: *mut SID_AND_ATTRIBUTES_HASH,
    pub TrustLevelSid: super::super::super::Win32::Foundation::PSID,
    pub SecurityAttributes: *mut ::core::ffi::c_void,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::marker::Copy for TOKEN_ACCESS_INFORMATION {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::clone::Clone for TOKEN_ACCESS_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::fmt::Debug for TOKEN_ACCESS_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOKEN_ACCESS_INFORMATION")
            .field("SidHash", &self.SidHash)
            .field("RestrictedSidHash", &self.RestrictedSidHash)
            .field("Privileges", &self.Privileges)
            .field("AuthenticationId", &self.AuthenticationId)
            .field("TokenType", &self.TokenType)
            .field("ImpersonationLevel", &self.ImpersonationLevel)
            .field("MandatoryPolicy", &self.MandatoryPolicy)
            .field("Flags", &self.Flags)
            .field("AppContainerNumber", &self.AppContainerNumber)
            .field("PackageSid", &self.PackageSid)
            .field("CapabilitiesHash", &self.CapabilitiesHash)
            .field("TrustLevelSid", &self.TrustLevelSid)
            .field("SecurityAttributes", &self.SecurityAttributes)
            .finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::windows_core::TypeKind for TOKEN_ACCESS_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::cmp::PartialEq for TOKEN_ACCESS_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.SidHash == other.SidHash && self.RestrictedSidHash == other.RestrictedSidHash && self.Privileges == other.Privileges && self.AuthenticationId == other.AuthenticationId && self.TokenType == other.TokenType && self.ImpersonationLevel == other.ImpersonationLevel && self.MandatoryPolicy == other.MandatoryPolicy && self.Flags == other.Flags && self.AppContainerNumber == other.AppContainerNumber && self.PackageSid == other.PackageSid && self.CapabilitiesHash == other.CapabilitiesHash && self.TrustLevelSid == other.TrustLevelSid && self.SecurityAttributes == other.SecurityAttributes
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::cmp::Eq for TOKEN_ACCESS_INFORMATION {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::default::Default for TOKEN_ACCESS_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct TOKEN_APPCONTAINER_INFORMATION {
    pub TokenAppContainer: super::super::super::Win32::Foundation::PSID,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for TOKEN_APPCONTAINER_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for TOKEN_APPCONTAINER_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for TOKEN_APPCONTAINER_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOKEN_APPCONTAINER_INFORMATION").field("TokenAppContainer", &self.TokenAppContainer).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for TOKEN_APPCONTAINER_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for TOKEN_APPCONTAINER_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.TokenAppContainer == other.TokenAppContainer
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for TOKEN_APPCONTAINER_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for TOKEN_APPCONTAINER_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct TOKEN_AUDIT_POLICY {
    pub PerUserPolicy: [u8; 30],
}
impl ::core::marker::Copy for TOKEN_AUDIT_POLICY {}
impl ::core::clone::Clone for TOKEN_AUDIT_POLICY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for TOKEN_AUDIT_POLICY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOKEN_AUDIT_POLICY").field("PerUserPolicy", &self.PerUserPolicy).finish()
    }
}
impl ::windows_core::TypeKind for TOKEN_AUDIT_POLICY {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for TOKEN_AUDIT_POLICY {
    fn eq(&self, other: &Self) -> bool {
        self.PerUserPolicy == other.PerUserPolicy
    }
}
impl ::core::cmp::Eq for TOKEN_AUDIT_POLICY {}
impl ::core::default::Default for TOKEN_AUDIT_POLICY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct TOKEN_BNO_ISOLATION_INFORMATION {
    pub IsolationPrefix: ::windows_core::PWSTR,
    pub IsolationEnabled: super::super::super::Win32::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for TOKEN_BNO_ISOLATION_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for TOKEN_BNO_ISOLATION_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for TOKEN_BNO_ISOLATION_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOKEN_BNO_ISOLATION_INFORMATION").field("IsolationPrefix", &self.IsolationPrefix).field("IsolationEnabled", &self.IsolationEnabled).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for TOKEN_BNO_ISOLATION_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for TOKEN_BNO_ISOLATION_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.IsolationPrefix == other.IsolationPrefix && self.IsolationEnabled == other.IsolationEnabled
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for TOKEN_BNO_ISOLATION_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for TOKEN_BNO_ISOLATION_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct TOKEN_CONTROL {
    pub TokenId: super::super::super::Win32::Foundation::LUID,
    pub AuthenticationId: super::super::super::Win32::Foundation::LUID,
    pub ModifiedId: super::super::super::Win32::Foundation::LUID,
    pub TokenSource: TOKEN_SOURCE,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for TOKEN_CONTROL {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for TOKEN_CONTROL {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for TOKEN_CONTROL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOKEN_CONTROL").field("TokenId", &self.TokenId).field("AuthenticationId", &self.AuthenticationId).field("ModifiedId", &self.ModifiedId).field("TokenSource", &self.TokenSource).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for TOKEN_CONTROL {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for TOKEN_CONTROL {
    fn eq(&self, other: &Self) -> bool {
        self.TokenId == other.TokenId && self.AuthenticationId == other.AuthenticationId && self.ModifiedId == other.ModifiedId && self.TokenSource == other.TokenSource
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for TOKEN_CONTROL {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for TOKEN_CONTROL {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Security\"`*"]
#[cfg(feature = "Win32_Security")]
pub struct TOKEN_DEFAULT_DACL {
    pub DefaultDacl: *mut super::super::super::Win32::Security::ACL,
}
#[cfg(feature = "Win32_Security")]
impl ::core::marker::Copy for TOKEN_DEFAULT_DACL {}
#[cfg(feature = "Win32_Security")]
impl ::core::clone::Clone for TOKEN_DEFAULT_DACL {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Security")]
impl ::core::fmt::Debug for TOKEN_DEFAULT_DACL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOKEN_DEFAULT_DACL").field("DefaultDacl", &self.DefaultDacl).finish()
    }
}
#[cfg(feature = "Win32_Security")]
impl ::windows_core::TypeKind for TOKEN_DEFAULT_DACL {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Security")]
impl ::core::cmp::PartialEq for TOKEN_DEFAULT_DACL {
    fn eq(&self, other: &Self) -> bool {
        self.DefaultDacl == other.DefaultDacl
    }
}
#[cfg(feature = "Win32_Security")]
impl ::core::cmp::Eq for TOKEN_DEFAULT_DACL {}
#[cfg(feature = "Win32_Security")]
impl ::core::default::Default for TOKEN_DEFAULT_DACL {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct TOKEN_DEVICE_CLAIMS {
    pub DeviceClaims: *mut ::core::ffi::c_void,
}
impl ::core::marker::Copy for TOKEN_DEVICE_CLAIMS {}
impl ::core::clone::Clone for TOKEN_DEVICE_CLAIMS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for TOKEN_DEVICE_CLAIMS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOKEN_DEVICE_CLAIMS").field("DeviceClaims", &self.DeviceClaims).finish()
    }
}
impl ::windows_core::TypeKind for TOKEN_DEVICE_CLAIMS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for TOKEN_DEVICE_CLAIMS {
    fn eq(&self, other: &Self) -> bool {
        self.DeviceClaims == other.DeviceClaims
    }
}
impl ::core::cmp::Eq for TOKEN_DEVICE_CLAIMS {}
impl ::core::default::Default for TOKEN_DEVICE_CLAIMS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct TOKEN_ELEVATION {
    pub TokenIsElevated: u32,
}
impl ::core::marker::Copy for TOKEN_ELEVATION {}
impl ::core::clone::Clone for TOKEN_ELEVATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for TOKEN_ELEVATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOKEN_ELEVATION").field("TokenIsElevated", &self.TokenIsElevated).finish()
    }
}
impl ::windows_core::TypeKind for TOKEN_ELEVATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for TOKEN_ELEVATION {
    fn eq(&self, other: &Self) -> bool {
        self.TokenIsElevated == other.TokenIsElevated
    }
}
impl ::core::cmp::Eq for TOKEN_ELEVATION {}
impl ::core::default::Default for TOKEN_ELEVATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct TOKEN_GROUPS {
    pub GroupCount: u32,
    pub Groups: [SID_AND_ATTRIBUTES; 1],
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for TOKEN_GROUPS {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for TOKEN_GROUPS {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for TOKEN_GROUPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOKEN_GROUPS").field("GroupCount", &self.GroupCount).field("Groups", &self.Groups).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for TOKEN_GROUPS {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for TOKEN_GROUPS {
    fn eq(&self, other: &Self) -> bool {
        self.GroupCount == other.GroupCount && self.Groups == other.Groups
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for TOKEN_GROUPS {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for TOKEN_GROUPS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
pub struct TOKEN_GROUPS_AND_PRIVILEGES {
    pub SidCount: u32,
    pub SidLength: u32,
    pub Sids: *mut SID_AND_ATTRIBUTES,
    pub RestrictedSidCount: u32,
    pub RestrictedSidLength: u32,
    pub RestrictedSids: *mut SID_AND_ATTRIBUTES,
    pub PrivilegeCount: u32,
    pub PrivilegeLength: u32,
    pub Privileges: *mut super::super::super::Win32::Security::LUID_AND_ATTRIBUTES,
    pub AuthenticationId: super::super::super::Win32::Foundation::LUID,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::marker::Copy for TOKEN_GROUPS_AND_PRIVILEGES {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::clone::Clone for TOKEN_GROUPS_AND_PRIVILEGES {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::fmt::Debug for TOKEN_GROUPS_AND_PRIVILEGES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOKEN_GROUPS_AND_PRIVILEGES")
            .field("SidCount", &self.SidCount)
            .field("SidLength", &self.SidLength)
            .field("Sids", &self.Sids)
            .field("RestrictedSidCount", &self.RestrictedSidCount)
            .field("RestrictedSidLength", &self.RestrictedSidLength)
            .field("RestrictedSids", &self.RestrictedSids)
            .field("PrivilegeCount", &self.PrivilegeCount)
            .field("PrivilegeLength", &self.PrivilegeLength)
            .field("Privileges", &self.Privileges)
            .field("AuthenticationId", &self.AuthenticationId)
            .finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::windows_core::TypeKind for TOKEN_GROUPS_AND_PRIVILEGES {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::cmp::PartialEq for TOKEN_GROUPS_AND_PRIVILEGES {
    fn eq(&self, other: &Self) -> bool {
        self.SidCount == other.SidCount && self.SidLength == other.SidLength && self.Sids == other.Sids && self.RestrictedSidCount == other.RestrictedSidCount && self.RestrictedSidLength == other.RestrictedSidLength && self.RestrictedSids == other.RestrictedSids && self.PrivilegeCount == other.PrivilegeCount && self.PrivilegeLength == other.PrivilegeLength && self.Privileges == other.Privileges && self.AuthenticationId == other.AuthenticationId
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::cmp::Eq for TOKEN_GROUPS_AND_PRIVILEGES {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::default::Default for TOKEN_GROUPS_AND_PRIVILEGES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct TOKEN_LINKED_TOKEN {
    pub LinkedToken: super::super::super::Win32::Foundation::HANDLE,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for TOKEN_LINKED_TOKEN {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for TOKEN_LINKED_TOKEN {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for TOKEN_LINKED_TOKEN {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOKEN_LINKED_TOKEN").field("LinkedToken", &self.LinkedToken).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for TOKEN_LINKED_TOKEN {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for TOKEN_LINKED_TOKEN {
    fn eq(&self, other: &Self) -> bool {
        self.LinkedToken == other.LinkedToken
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for TOKEN_LINKED_TOKEN {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for TOKEN_LINKED_TOKEN {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct TOKEN_MANDATORY_LABEL {
    pub Label: SID_AND_ATTRIBUTES,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for TOKEN_MANDATORY_LABEL {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for TOKEN_MANDATORY_LABEL {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for TOKEN_MANDATORY_LABEL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOKEN_MANDATORY_LABEL").field("Label", &self.Label).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for TOKEN_MANDATORY_LABEL {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for TOKEN_MANDATORY_LABEL {
    fn eq(&self, other: &Self) -> bool {
        self.Label == other.Label
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for TOKEN_MANDATORY_LABEL {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for TOKEN_MANDATORY_LABEL {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct TOKEN_MANDATORY_POLICY {
    pub Policy: u32,
}
impl ::core::marker::Copy for TOKEN_MANDATORY_POLICY {}
impl ::core::clone::Clone for TOKEN_MANDATORY_POLICY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for TOKEN_MANDATORY_POLICY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOKEN_MANDATORY_POLICY").field("Policy", &self.Policy).finish()
    }
}
impl ::windows_core::TypeKind for TOKEN_MANDATORY_POLICY {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for TOKEN_MANDATORY_POLICY {
    fn eq(&self, other: &Self) -> bool {
        self.Policy == other.Policy
    }
}
impl ::core::cmp::Eq for TOKEN_MANDATORY_POLICY {}
impl ::core::default::Default for TOKEN_MANDATORY_POLICY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct TOKEN_ORIGIN {
    pub OriginatingLogonSession: super::super::super::Win32::Foundation::LUID,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for TOKEN_ORIGIN {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for TOKEN_ORIGIN {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for TOKEN_ORIGIN {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOKEN_ORIGIN").field("OriginatingLogonSession", &self.OriginatingLogonSession).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for TOKEN_ORIGIN {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for TOKEN_ORIGIN {
    fn eq(&self, other: &Self) -> bool {
        self.OriginatingLogonSession == other.OriginatingLogonSession
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for TOKEN_ORIGIN {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for TOKEN_ORIGIN {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct TOKEN_OWNER {
    pub Owner: super::super::super::Win32::Foundation::PSID,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for TOKEN_OWNER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for TOKEN_OWNER {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for TOKEN_OWNER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOKEN_OWNER").field("Owner", &self.Owner).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for TOKEN_OWNER {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for TOKEN_OWNER {
    fn eq(&self, other: &Self) -> bool {
        self.Owner == other.Owner
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for TOKEN_OWNER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for TOKEN_OWNER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct TOKEN_PRIMARY_GROUP {
    pub PrimaryGroup: super::super::super::Win32::Foundation::PSID,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for TOKEN_PRIMARY_GROUP {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for TOKEN_PRIMARY_GROUP {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for TOKEN_PRIMARY_GROUP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOKEN_PRIMARY_GROUP").field("PrimaryGroup", &self.PrimaryGroup).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for TOKEN_PRIMARY_GROUP {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for TOKEN_PRIMARY_GROUP {
    fn eq(&self, other: &Self) -> bool {
        self.PrimaryGroup == other.PrimaryGroup
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for TOKEN_PRIMARY_GROUP {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for TOKEN_PRIMARY_GROUP {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
pub struct TOKEN_PRIVILEGES {
    pub PrivilegeCount: u32,
    pub Privileges: [super::super::super::Win32::Security::LUID_AND_ATTRIBUTES; 1],
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::marker::Copy for TOKEN_PRIVILEGES {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::clone::Clone for TOKEN_PRIVILEGES {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::fmt::Debug for TOKEN_PRIVILEGES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOKEN_PRIVILEGES").field("PrivilegeCount", &self.PrivilegeCount).field("Privileges", &self.Privileges).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::windows_core::TypeKind for TOKEN_PRIVILEGES {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::cmp::PartialEq for TOKEN_PRIVILEGES {
    fn eq(&self, other: &Self) -> bool {
        self.PrivilegeCount == other.PrivilegeCount && self.Privileges == other.Privileges
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::cmp::Eq for TOKEN_PRIVILEGES {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::default::Default for TOKEN_PRIVILEGES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct TOKEN_SID_INFORMATION {
    pub Sid: super::super::super::Win32::Foundation::PSID,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for TOKEN_SID_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for TOKEN_SID_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for TOKEN_SID_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOKEN_SID_INFORMATION").field("Sid", &self.Sid).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for TOKEN_SID_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for TOKEN_SID_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.Sid == other.Sid
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for TOKEN_SID_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for TOKEN_SID_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct TOKEN_SOURCE {
    pub SourceName: [u8; 8],
    pub SourceIdentifier: super::super::super::Win32::Foundation::LUID,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for TOKEN_SOURCE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for TOKEN_SOURCE {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for TOKEN_SOURCE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOKEN_SOURCE").field("SourceName", &self.SourceName).field("SourceIdentifier", &self.SourceIdentifier).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for TOKEN_SOURCE {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for TOKEN_SOURCE {
    fn eq(&self, other: &Self) -> bool {
        self.SourceName == other.SourceName && self.SourceIdentifier == other.SourceIdentifier
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for TOKEN_SOURCE {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for TOKEN_SOURCE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
pub struct TOKEN_STATISTICS {
    pub TokenId: super::super::super::Win32::Foundation::LUID,
    pub AuthenticationId: super::super::super::Win32::Foundation::LUID,
    pub ExpirationTime: i64,
    pub TokenType: TOKEN_TYPE,
    pub ImpersonationLevel: super::super::super::Win32::Security::SECURITY_IMPERSONATION_LEVEL,
    pub DynamicCharged: u32,
    pub DynamicAvailable: u32,
    pub GroupCount: u32,
    pub PrivilegeCount: u32,
    pub ModifiedId: super::super::super::Win32::Foundation::LUID,
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::marker::Copy for TOKEN_STATISTICS {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::clone::Clone for TOKEN_STATISTICS {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::fmt::Debug for TOKEN_STATISTICS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOKEN_STATISTICS").field("TokenId", &self.TokenId).field("AuthenticationId", &self.AuthenticationId).field("ExpirationTime", &self.ExpirationTime).field("TokenType", &self.TokenType).field("ImpersonationLevel", &self.ImpersonationLevel).field("DynamicCharged", &self.DynamicCharged).field("DynamicAvailable", &self.DynamicAvailable).field("GroupCount", &self.GroupCount).field("PrivilegeCount", &self.PrivilegeCount).field("ModifiedId", &self.ModifiedId).finish()
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::windows_core::TypeKind for TOKEN_STATISTICS {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::cmp::PartialEq for TOKEN_STATISTICS {
    fn eq(&self, other: &Self) -> bool {
        self.TokenId == other.TokenId && self.AuthenticationId == other.AuthenticationId && self.ExpirationTime == other.ExpirationTime && self.TokenType == other.TokenType && self.ImpersonationLevel == other.ImpersonationLevel && self.DynamicCharged == other.DynamicCharged && self.DynamicAvailable == other.DynamicAvailable && self.GroupCount == other.GroupCount && self.PrivilegeCount == other.PrivilegeCount && self.ModifiedId == other.ModifiedId
    }
}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::cmp::Eq for TOKEN_STATISTICS {}
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_Security"))]
impl ::core::default::Default for TOKEN_STATISTICS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct TOKEN_USER {
    pub User: SID_AND_ATTRIBUTES,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for TOKEN_USER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for TOKEN_USER {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for TOKEN_USER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOKEN_USER").field("User", &self.User).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for TOKEN_USER {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for TOKEN_USER {
    fn eq(&self, other: &Self) -> bool {
        self.User == other.User
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for TOKEN_USER {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for TOKEN_USER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct TOKEN_USER_CLAIMS {
    pub UserClaims: *mut ::core::ffi::c_void,
}
impl ::core::marker::Copy for TOKEN_USER_CLAIMS {}
impl ::core::clone::Clone for TOKEN_USER_CLAIMS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for TOKEN_USER_CLAIMS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TOKEN_USER_CLAIMS").field("UserClaims", &self.UserClaims).finish()
    }
}
impl ::windows_core::TypeKind for TOKEN_USER_CLAIMS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for TOKEN_USER_CLAIMS {
    fn eq(&self, other: &Self) -> bool {
        self.UserClaims == other.UserClaims
    }
}
impl ::core::cmp::Eq for TOKEN_USER_CLAIMS {}
impl ::core::default::Default for TOKEN_USER_CLAIMS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
pub struct TUNNEL {
    pub Mutex: super::super::Foundation::FAST_MUTEX,
    pub Cache: *mut super::super::Foundation::RTL_SPLAY_LINKS,
    pub TimerQueue: super::super::super::Win32::System::Kernel::LIST_ENTRY,
    pub NumEntries: u16,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::marker::Copy for TUNNEL {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::clone::Clone for TUNNEL {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::windows_core::TypeKind for TUNNEL {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
impl ::core::default::Default for TUNNEL {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct TXFS_CREATE_MINIVERSION_INFO {
    pub StructureVersion: u16,
    pub StructureLength: u16,
    pub BaseVersion: u32,
    pub MiniVersion: u16,
}
impl ::core::marker::Copy for TXFS_CREATE_MINIVERSION_INFO {}
impl ::core::clone::Clone for TXFS_CREATE_MINIVERSION_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for TXFS_CREATE_MINIVERSION_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TXFS_CREATE_MINIVERSION_INFO").field("StructureVersion", &self.StructureVersion).field("StructureLength", &self.StructureLength).field("BaseVersion", &self.BaseVersion).field("MiniVersion", &self.MiniVersion).finish()
    }
}
impl ::windows_core::TypeKind for TXFS_CREATE_MINIVERSION_INFO {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for TXFS_CREATE_MINIVERSION_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.StructureVersion == other.StructureVersion && self.StructureLength == other.StructureLength && self.BaseVersion == other.BaseVersion && self.MiniVersion == other.MiniVersion
    }
}
impl ::core::cmp::Eq for TXFS_CREATE_MINIVERSION_INFO {}
impl ::core::default::Default for TXFS_CREATE_MINIVERSION_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct TXFS_GET_METADATA_INFO_OUT {
    pub TxfFileId: TXFS_GET_METADATA_INFO_OUT_0,
    pub LockingTransaction: ::windows_core::GUID,
    pub LastLsn: u64,
    pub TransactionState: u32,
}
impl ::core::marker::Copy for TXFS_GET_METADATA_INFO_OUT {}
impl ::core::clone::Clone for TXFS_GET_METADATA_INFO_OUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for TXFS_GET_METADATA_INFO_OUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TXFS_GET_METADATA_INFO_OUT").field("TxfFileId", &self.TxfFileId).field("LockingTransaction", &self.LockingTransaction).field("LastLsn", &self.LastLsn).field("TransactionState", &self.TransactionState).finish()
    }
}
impl ::windows_core::TypeKind for TXFS_GET_METADATA_INFO_OUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for TXFS_GET_METADATA_INFO_OUT {
    fn eq(&self, other: &Self) -> bool {
        self.TxfFileId == other.TxfFileId && self.LockingTransaction == other.LockingTransaction && self.LastLsn == other.LastLsn && self.TransactionState == other.TransactionState
    }
}
impl ::core::cmp::Eq for TXFS_GET_METADATA_INFO_OUT {}
impl ::core::default::Default for TXFS_GET_METADATA_INFO_OUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct TXFS_GET_METADATA_INFO_OUT_0 {
    pub LowPart: i64,
    pub HighPart: i64,
}
impl ::core::marker::Copy for TXFS_GET_METADATA_INFO_OUT_0 {}
impl ::core::clone::Clone for TXFS_GET_METADATA_INFO_OUT_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for TXFS_GET_METADATA_INFO_OUT_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TXFS_GET_METADATA_INFO_OUT_0").field("LowPart", &self.LowPart).field("HighPart", &self.HighPart).finish()
    }
}
impl ::windows_core::TypeKind for TXFS_GET_METADATA_INFO_OUT_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for TXFS_GET_METADATA_INFO_OUT_0 {
    fn eq(&self, other: &Self) -> bool {
        self.LowPart == other.LowPart && self.HighPart == other.HighPart
    }
}
impl ::core::cmp::Eq for TXFS_GET_METADATA_INFO_OUT_0 {}
impl ::core::default::Default for TXFS_GET_METADATA_INFO_OUT_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct TXFS_GET_TRANSACTED_VERSION {
    pub ThisBaseVersion: u32,
    pub LatestVersion: u32,
    pub ThisMiniVersion: u16,
    pub FirstMiniVersion: u16,
    pub LatestMiniVersion: u16,
}
impl ::core::marker::Copy for TXFS_GET_TRANSACTED_VERSION {}
impl ::core::clone::Clone for TXFS_GET_TRANSACTED_VERSION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for TXFS_GET_TRANSACTED_VERSION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TXFS_GET_TRANSACTED_VERSION").field("ThisBaseVersion", &self.ThisBaseVersion).field("LatestVersion", &self.LatestVersion).field("ThisMiniVersion", &self.ThisMiniVersion).field("FirstMiniVersion", &self.FirstMiniVersion).field("LatestMiniVersion", &self.LatestMiniVersion).finish()
    }
}
impl ::windows_core::TypeKind for TXFS_GET_TRANSACTED_VERSION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for TXFS_GET_TRANSACTED_VERSION {
    fn eq(&self, other: &Self) -> bool {
        self.ThisBaseVersion == other.ThisBaseVersion && self.LatestVersion == other.LatestVersion && self.ThisMiniVersion == other.ThisMiniVersion && self.FirstMiniVersion == other.FirstMiniVersion && self.LatestMiniVersion == other.LatestMiniVersion
    }
}
impl ::core::cmp::Eq for TXFS_GET_TRANSACTED_VERSION {}
impl ::core::default::Default for TXFS_GET_TRANSACTED_VERSION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct TXFS_LIST_TRANSACTIONS {
    pub NumberOfTransactions: u64,
    pub BufferSizeRequired: u64,
}
impl ::core::marker::Copy for TXFS_LIST_TRANSACTIONS {}
impl ::core::clone::Clone for TXFS_LIST_TRANSACTIONS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for TXFS_LIST_TRANSACTIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TXFS_LIST_TRANSACTIONS").field("NumberOfTransactions", &self.NumberOfTransactions).field("BufferSizeRequired", &self.BufferSizeRequired).finish()
    }
}
impl ::windows_core::TypeKind for TXFS_LIST_TRANSACTIONS {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for TXFS_LIST_TRANSACTIONS {
    fn eq(&self, other: &Self) -> bool {
        self.NumberOfTransactions == other.NumberOfTransactions && self.BufferSizeRequired == other.BufferSizeRequired
    }
}
impl ::core::cmp::Eq for TXFS_LIST_TRANSACTIONS {}
impl ::core::default::Default for TXFS_LIST_TRANSACTIONS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct TXFS_LIST_TRANSACTIONS_ENTRY {
    pub TransactionId: ::windows_core::GUID,
    pub TransactionState: u32,
    pub Reserved1: u32,
    pub Reserved2: u32,
    pub Reserved3: i64,
}
impl ::core::marker::Copy for TXFS_LIST_TRANSACTIONS_ENTRY {}
impl ::core::clone::Clone for TXFS_LIST_TRANSACTIONS_ENTRY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for TXFS_LIST_TRANSACTIONS_ENTRY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TXFS_LIST_TRANSACTIONS_ENTRY").field("TransactionId", &self.TransactionId).field("TransactionState", &self.TransactionState).field("Reserved1", &self.Reserved1).field("Reserved2", &self.Reserved2).field("Reserved3", &self.Reserved3).finish()
    }
}
impl ::windows_core::TypeKind for TXFS_LIST_TRANSACTIONS_ENTRY {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for TXFS_LIST_TRANSACTIONS_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.TransactionId == other.TransactionId && self.TransactionState == other.TransactionState && self.Reserved1 == other.Reserved1 && self.Reserved2 == other.Reserved2 && self.Reserved3 == other.Reserved3
    }
}
impl ::core::cmp::Eq for TXFS_LIST_TRANSACTIONS_ENTRY {}
impl ::core::default::Default for TXFS_LIST_TRANSACTIONS_ENTRY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct TXFS_LIST_TRANSACTION_LOCKED_FILES {
    pub KtmTransaction: ::windows_core::GUID,
    pub NumberOfFiles: u64,
    pub BufferSizeRequired: u64,
    pub Offset: u64,
}
impl ::core::marker::Copy for TXFS_LIST_TRANSACTION_LOCKED_FILES {}
impl ::core::clone::Clone for TXFS_LIST_TRANSACTION_LOCKED_FILES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for TXFS_LIST_TRANSACTION_LOCKED_FILES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TXFS_LIST_TRANSACTION_LOCKED_FILES").field("KtmTransaction", &self.KtmTransaction).field("NumberOfFiles", &self.NumberOfFiles).field("BufferSizeRequired", &self.BufferSizeRequired).field("Offset", &self.Offset).finish()
    }
}
impl ::windows_core::TypeKind for TXFS_LIST_TRANSACTION_LOCKED_FILES {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for TXFS_LIST_TRANSACTION_LOCKED_FILES {
    fn eq(&self, other: &Self) -> bool {
        self.KtmTransaction == other.KtmTransaction && self.NumberOfFiles == other.NumberOfFiles && self.BufferSizeRequired == other.BufferSizeRequired && self.Offset == other.Offset
    }
}
impl ::core::cmp::Eq for TXFS_LIST_TRANSACTION_LOCKED_FILES {}
impl ::core::default::Default for TXFS_LIST_TRANSACTION_LOCKED_FILES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY {
    pub Offset: u64,
    pub NameFlags: u32,
    pub FileId: i64,
    pub Reserved1: u32,
    pub Reserved2: u32,
    pub Reserved3: i64,
    pub FileName: [u16; 1],
}
impl ::core::marker::Copy for TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY {}
impl ::core::clone::Clone for TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY").field("Offset", &self.Offset).field("NameFlags", &self.NameFlags).field("FileId", &self.FileId).field("Reserved1", &self.Reserved1).field("Reserved2", &self.Reserved2).field("Reserved3", &self.Reserved3).field("FileName", &self.FileName).finish()
    }
}
impl ::windows_core::TypeKind for TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.Offset == other.Offset && self.NameFlags == other.NameFlags && self.FileId == other.FileId && self.Reserved1 == other.Reserved1 && self.Reserved2 == other.Reserved2 && self.Reserved3 == other.Reserved3 && self.FileName == other.FileName
    }
}
impl ::core::cmp::Eq for TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY {}
impl ::core::default::Default for TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct TXFS_MODIFY_RM {
    pub Flags: u32,
    pub LogContainerCountMax: u32,
    pub LogContainerCountMin: u32,
    pub LogContainerCount: u32,
    pub LogGrowthIncrement: u32,
    pub LogAutoShrinkPercentage: u32,
    pub Reserved: u64,
    pub LoggingMode: u16,
}
impl ::core::marker::Copy for TXFS_MODIFY_RM {}
impl ::core::clone::Clone for TXFS_MODIFY_RM {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for TXFS_MODIFY_RM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TXFS_MODIFY_RM").field("Flags", &self.Flags).field("LogContainerCountMax", &self.LogContainerCountMax).field("LogContainerCountMin", &self.LogContainerCountMin).field("LogContainerCount", &self.LogContainerCount).field("LogGrowthIncrement", &self.LogGrowthIncrement).field("LogAutoShrinkPercentage", &self.LogAutoShrinkPercentage).field("Reserved", &self.Reserved).field("LoggingMode", &self.LoggingMode).finish()
    }
}
impl ::windows_core::TypeKind for TXFS_MODIFY_RM {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for TXFS_MODIFY_RM {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags && self.LogContainerCountMax == other.LogContainerCountMax && self.LogContainerCountMin == other.LogContainerCountMin && self.LogContainerCount == other.LogContainerCount && self.LogGrowthIncrement == other.LogGrowthIncrement && self.LogAutoShrinkPercentage == other.LogAutoShrinkPercentage && self.Reserved == other.Reserved && self.LoggingMode == other.LoggingMode
    }
}
impl ::core::cmp::Eq for TXFS_MODIFY_RM {}
impl ::core::default::Default for TXFS_MODIFY_RM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct TXFS_QUERY_RM_INFORMATION {
    pub BytesRequired: u32,
    pub TailLsn: u64,
    pub CurrentLsn: u64,
    pub ArchiveTailLsn: u64,
    pub LogContainerSize: u64,
    pub HighestVirtualClock: i64,
    pub LogContainerCount: u32,
    pub LogContainerCountMax: u32,
    pub LogContainerCountMin: u32,
    pub LogGrowthIncrement: u32,
    pub LogAutoShrinkPercentage: u32,
    pub Flags: u32,
    pub LoggingMode: u16,
    pub Reserved: u16,
    pub RmState: u32,
    pub LogCapacity: u64,
    pub LogFree: u64,
    pub TopsSize: u64,
    pub TopsUsed: u64,
    pub TransactionCount: u64,
    pub OnePCCount: u64,
    pub TwoPCCount: u64,
    pub NumberLogFileFull: u64,
    pub OldestTransactionAge: u64,
    pub RMName: ::windows_core::GUID,
    pub TmLogPathOffset: u32,
}
impl ::core::marker::Copy for TXFS_QUERY_RM_INFORMATION {}
impl ::core::clone::Clone for TXFS_QUERY_RM_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for TXFS_QUERY_RM_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TXFS_QUERY_RM_INFORMATION")
            .field("BytesRequired", &self.BytesRequired)
            .field("TailLsn", &self.TailLsn)
            .field("CurrentLsn", &self.CurrentLsn)
            .field("ArchiveTailLsn", &self.ArchiveTailLsn)
            .field("LogContainerSize", &self.LogContainerSize)
            .field("HighestVirtualClock", &self.HighestVirtualClock)
            .field("LogContainerCount", &self.LogContainerCount)
            .field("LogContainerCountMax", &self.LogContainerCountMax)
            .field("LogContainerCountMin", &self.LogContainerCountMin)
            .field("LogGrowthIncrement", &self.LogGrowthIncrement)
            .field("LogAutoShrinkPercentage", &self.LogAutoShrinkPercentage)
            .field("Flags", &self.Flags)
            .field("LoggingMode", &self.LoggingMode)
            .field("Reserved", &self.Reserved)
            .field("RmState", &self.RmState)
            .field("LogCapacity", &self.LogCapacity)
            .field("LogFree", &self.LogFree)
            .field("TopsSize", &self.TopsSize)
            .field("TopsUsed", &self.TopsUsed)
            .field("TransactionCount", &self.TransactionCount)
            .field("OnePCCount", &self.OnePCCount)
            .field("TwoPCCount", &self.TwoPCCount)
            .field("NumberLogFileFull", &self.NumberLogFileFull)
            .field("OldestTransactionAge", &self.OldestTransactionAge)
            .field("RMName", &self.RMName)
            .field("TmLogPathOffset", &self.TmLogPathOffset)
            .finish()
    }
}
impl ::windows_core::TypeKind for TXFS_QUERY_RM_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for TXFS_QUERY_RM_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.BytesRequired == other.BytesRequired
            && self.TailLsn == other.TailLsn
            && self.CurrentLsn == other.CurrentLsn
            && self.ArchiveTailLsn == other.ArchiveTailLsn
            && self.LogContainerSize == other.LogContainerSize
            && self.HighestVirtualClock == other.HighestVirtualClock
            && self.LogContainerCount == other.LogContainerCount
            && self.LogContainerCountMax == other.LogContainerCountMax
            && self.LogContainerCountMin == other.LogContainerCountMin
            && self.LogGrowthIncrement == other.LogGrowthIncrement
            && self.LogAutoShrinkPercentage == other.LogAutoShrinkPercentage
            && self.Flags == other.Flags
            && self.LoggingMode == other.LoggingMode
            && self.Reserved == other.Reserved
            && self.RmState == other.RmState
            && self.LogCapacity == other.LogCapacity
            && self.LogFree == other.LogFree
            && self.TopsSize == other.TopsSize
            && self.TopsUsed == other.TopsUsed
            && self.TransactionCount == other.TransactionCount
            && self.OnePCCount == other.OnePCCount
            && self.TwoPCCount == other.TwoPCCount
            && self.NumberLogFileFull == other.NumberLogFileFull
            && self.OldestTransactionAge == other.OldestTransactionAge
            && self.RMName == other.RMName
            && self.TmLogPathOffset == other.TmLogPathOffset
    }
}
impl ::core::cmp::Eq for TXFS_QUERY_RM_INFORMATION {}
impl ::core::default::Default for TXFS_QUERY_RM_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct TXFS_READ_BACKUP_INFORMATION_OUT {
    pub Anonymous: TXFS_READ_BACKUP_INFORMATION_OUT_0,
}
impl ::core::marker::Copy for TXFS_READ_BACKUP_INFORMATION_OUT {}
impl ::core::clone::Clone for TXFS_READ_BACKUP_INFORMATION_OUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for TXFS_READ_BACKUP_INFORMATION_OUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for TXFS_READ_BACKUP_INFORMATION_OUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub union TXFS_READ_BACKUP_INFORMATION_OUT_0 {
    pub BufferLength: u32,
    pub Buffer: [u8; 1],
}
impl ::core::marker::Copy for TXFS_READ_BACKUP_INFORMATION_OUT_0 {}
impl ::core::clone::Clone for TXFS_READ_BACKUP_INFORMATION_OUT_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for TXFS_READ_BACKUP_INFORMATION_OUT_0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for TXFS_READ_BACKUP_INFORMATION_OUT_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct TXFS_ROLLFORWARD_REDO_INFORMATION {
    pub LastVirtualClock: i64,
    pub LastRedoLsn: u64,
    pub HighestRecoveryLsn: u64,
    pub Flags: u32,
}
impl ::core::marker::Copy for TXFS_ROLLFORWARD_REDO_INFORMATION {}
impl ::core::clone::Clone for TXFS_ROLLFORWARD_REDO_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for TXFS_ROLLFORWARD_REDO_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TXFS_ROLLFORWARD_REDO_INFORMATION").field("LastVirtualClock", &self.LastVirtualClock).field("LastRedoLsn", &self.LastRedoLsn).field("HighestRecoveryLsn", &self.HighestRecoveryLsn).field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for TXFS_ROLLFORWARD_REDO_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for TXFS_ROLLFORWARD_REDO_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.LastVirtualClock == other.LastVirtualClock && self.LastRedoLsn == other.LastRedoLsn && self.HighestRecoveryLsn == other.HighestRecoveryLsn && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for TXFS_ROLLFORWARD_REDO_INFORMATION {}
impl ::core::default::Default for TXFS_ROLLFORWARD_REDO_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct TXFS_SAVEPOINT_INFORMATION {
    pub KtmTransaction: super::super::super::Win32::Foundation::HANDLE,
    pub ActionCode: u32,
    pub SavepointId: u32,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for TXFS_SAVEPOINT_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for TXFS_SAVEPOINT_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for TXFS_SAVEPOINT_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TXFS_SAVEPOINT_INFORMATION").field("KtmTransaction", &self.KtmTransaction).field("ActionCode", &self.ActionCode).field("SavepointId", &self.SavepointId).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for TXFS_SAVEPOINT_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for TXFS_SAVEPOINT_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.KtmTransaction == other.KtmTransaction && self.ActionCode == other.ActionCode && self.SavepointId == other.SavepointId
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for TXFS_SAVEPOINT_INFORMATION {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for TXFS_SAVEPOINT_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct TXFS_START_RM_INFORMATION {
    pub Flags: u32,
    pub LogContainerSize: u64,
    pub LogContainerCountMin: u32,
    pub LogContainerCountMax: u32,
    pub LogGrowthIncrement: u32,
    pub LogAutoShrinkPercentage: u32,
    pub TmLogPathOffset: u32,
    pub TmLogPathLength: u16,
    pub LoggingMode: u16,
    pub LogPathLength: u16,
    pub Reserved: u16,
    pub LogPath: [u16; 1],
}
impl ::core::marker::Copy for TXFS_START_RM_INFORMATION {}
impl ::core::clone::Clone for TXFS_START_RM_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for TXFS_START_RM_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TXFS_START_RM_INFORMATION")
            .field("Flags", &self.Flags)
            .field("LogContainerSize", &self.LogContainerSize)
            .field("LogContainerCountMin", &self.LogContainerCountMin)
            .field("LogContainerCountMax", &self.LogContainerCountMax)
            .field("LogGrowthIncrement", &self.LogGrowthIncrement)
            .field("LogAutoShrinkPercentage", &self.LogAutoShrinkPercentage)
            .field("TmLogPathOffset", &self.TmLogPathOffset)
            .field("TmLogPathLength", &self.TmLogPathLength)
            .field("LoggingMode", &self.LoggingMode)
            .field("LogPathLength", &self.LogPathLength)
            .field("Reserved", &self.Reserved)
            .field("LogPath", &self.LogPath)
            .finish()
    }
}
impl ::windows_core::TypeKind for TXFS_START_RM_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for TXFS_START_RM_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags && self.LogContainerSize == other.LogContainerSize && self.LogContainerCountMin == other.LogContainerCountMin && self.LogContainerCountMax == other.LogContainerCountMax && self.LogGrowthIncrement == other.LogGrowthIncrement && self.LogAutoShrinkPercentage == other.LogAutoShrinkPercentage && self.TmLogPathOffset == other.TmLogPathOffset && self.TmLogPathLength == other.TmLogPathLength && self.LoggingMode == other.LoggingMode && self.LogPathLength == other.LogPathLength && self.Reserved == other.Reserved && self.LogPath == other.LogPath
    }
}
impl ::core::cmp::Eq for TXFS_START_RM_INFORMATION {}
impl ::core::default::Default for TXFS_START_RM_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub struct TXFS_TRANSACTION_ACTIVE_INFO {
    pub TransactionsActiveAtSnapshot: super::super::super::Win32::Foundation::BOOLEAN,
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::marker::Copy for TXFS_TRANSACTION_ACTIVE_INFO {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::clone::Clone for TXFS_TRANSACTION_ACTIVE_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::fmt::Debug for TXFS_TRANSACTION_ACTIVE_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TXFS_TRANSACTION_ACTIVE_INFO").field("TransactionsActiveAtSnapshot", &self.TransactionsActiveAtSnapshot).finish()
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::windows_core::TypeKind for TXFS_TRANSACTION_ACTIVE_INFO {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::PartialEq for TXFS_TRANSACTION_ACTIVE_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.TransactionsActiveAtSnapshot == other.TransactionsActiveAtSnapshot
    }
}
#[cfg(feature = "Win32_Foundation")]
impl ::core::cmp::Eq for TXFS_TRANSACTION_ACTIVE_INFO {}
#[cfg(feature = "Win32_Foundation")]
impl ::core::default::Default for TXFS_TRANSACTION_ACTIVE_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct TXFS_WRITE_BACKUP_INFORMATION {
    pub Buffer: [u8; 1],
}
impl ::core::marker::Copy for TXFS_WRITE_BACKUP_INFORMATION {}
impl ::core::clone::Clone for TXFS_WRITE_BACKUP_INFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for TXFS_WRITE_BACKUP_INFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("TXFS_WRITE_BACKUP_INFORMATION").field("Buffer", &self.Buffer).finish()
    }
}
impl ::windows_core::TypeKind for TXFS_WRITE_BACKUP_INFORMATION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for TXFS_WRITE_BACKUP_INFORMATION {
    fn eq(&self, other: &Self) -> bool {
        self.Buffer == other.Buffer
    }
}
impl ::core::cmp::Eq for TXFS_WRITE_BACKUP_INFORMATION {}
impl ::core::default::Default for TXFS_WRITE_BACKUP_INFORMATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
pub struct UNICODE_PREFIX_TABLE {
    pub NodeTypeCode: i16,
    pub NameLength: i16,
    pub NextPrefixTree: *mut UNICODE_PREFIX_TABLE_ENTRY,
    pub LastNextEntry: *mut UNICODE_PREFIX_TABLE_ENTRY,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
impl ::core::marker::Copy for UNICODE_PREFIX_TABLE {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
impl ::core::clone::Clone for UNICODE_PREFIX_TABLE {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
impl ::core::fmt::Debug for UNICODE_PREFIX_TABLE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("UNICODE_PREFIX_TABLE").field("NodeTypeCode", &self.NodeTypeCode).field("NameLength", &self.NameLength).field("NextPrefixTree", &self.NextPrefixTree).field("LastNextEntry", &self.LastNextEntry).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
impl ::windows_core::TypeKind for UNICODE_PREFIX_TABLE {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
impl ::core::cmp::PartialEq for UNICODE_PREFIX_TABLE {
    fn eq(&self, other: &Self) -> bool {
        self.NodeTypeCode == other.NodeTypeCode && self.NameLength == other.NameLength && self.NextPrefixTree == other.NextPrefixTree && self.LastNextEntry == other.LastNextEntry
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
impl ::core::cmp::Eq for UNICODE_PREFIX_TABLE {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
impl ::core::default::Default for UNICODE_PREFIX_TABLE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
pub struct UNICODE_PREFIX_TABLE_ENTRY {
    pub NodeTypeCode: i16,
    pub NameLength: i16,
    pub NextPrefixTree: *mut UNICODE_PREFIX_TABLE_ENTRY,
    pub CaseMatch: *mut UNICODE_PREFIX_TABLE_ENTRY,
    pub Links: super::super::Foundation::RTL_SPLAY_LINKS,
    pub Prefix: *mut super::super::super::Win32::Foundation::UNICODE_STRING,
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
impl ::core::marker::Copy for UNICODE_PREFIX_TABLE_ENTRY {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
impl ::core::clone::Clone for UNICODE_PREFIX_TABLE_ENTRY {
    fn clone(&self) -> Self {
        *self
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
impl ::core::fmt::Debug for UNICODE_PREFIX_TABLE_ENTRY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("UNICODE_PREFIX_TABLE_ENTRY").field("NodeTypeCode", &self.NodeTypeCode).field("NameLength", &self.NameLength).field("NextPrefixTree", &self.NextPrefixTree).field("CaseMatch", &self.CaseMatch).field("Links", &self.Links).field("Prefix", &self.Prefix).finish()
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
impl ::windows_core::TypeKind for UNICODE_PREFIX_TABLE_ENTRY {
    type TypeKind = ::windows_core::CopyType;
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
impl ::core::cmp::PartialEq for UNICODE_PREFIX_TABLE_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.NodeTypeCode == other.NodeTypeCode && self.NameLength == other.NameLength && self.NextPrefixTree == other.NextPrefixTree && self.CaseMatch == other.CaseMatch && self.Links == other.Links && self.Prefix == other.Prefix
    }
}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
impl ::core::cmp::Eq for UNICODE_PREFIX_TABLE_ENTRY {}
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
impl ::core::default::Default for UNICODE_PREFIX_TABLE_ENTRY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct USN_JOURNAL_DATA {
    pub UsnJournalID: u64,
    pub FirstUsn: i64,
    pub NextUsn: i64,
    pub LowestValidUsn: i64,
    pub MaxUsn: i64,
    pub MaximumSize: u64,
    pub AllocationDelta: u64,
    pub MinSupportedMajorVersion: u16,
    pub MaxSupportedMajorVersion: u16,
}
impl ::core::marker::Copy for USN_JOURNAL_DATA {}
impl ::core::clone::Clone for USN_JOURNAL_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for USN_JOURNAL_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("USN_JOURNAL_DATA").field("UsnJournalID", &self.UsnJournalID).field("FirstUsn", &self.FirstUsn).field("NextUsn", &self.NextUsn).field("LowestValidUsn", &self.LowestValidUsn).field("MaxUsn", &self.MaxUsn).field("MaximumSize", &self.MaximumSize).field("AllocationDelta", &self.AllocationDelta).field("MinSupportedMajorVersion", &self.MinSupportedMajorVersion).field("MaxSupportedMajorVersion", &self.MaxSupportedMajorVersion).finish()
    }
}
impl ::windows_core::TypeKind for USN_JOURNAL_DATA {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for USN_JOURNAL_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.UsnJournalID == other.UsnJournalID && self.FirstUsn == other.FirstUsn && self.NextUsn == other.NextUsn && self.LowestValidUsn == other.LowestValidUsn && self.MaxUsn == other.MaxUsn && self.MaximumSize == other.MaximumSize && self.AllocationDelta == other.AllocationDelta && self.MinSupportedMajorVersion == other.MinSupportedMajorVersion && self.MaxSupportedMajorVersion == other.MaxSupportedMajorVersion
    }
}
impl ::core::cmp::Eq for USN_JOURNAL_DATA {}
impl ::core::default::Default for USN_JOURNAL_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct USN_JOURNAL_DATA_V0 {
    pub UsnJournalID: u64,
    pub FirstUsn: i64,
    pub NextUsn: i64,
    pub LowestValidUsn: i64,
    pub MaxUsn: i64,
    pub MaximumSize: u64,
    pub AllocationDelta: u64,
}
impl ::core::marker::Copy for USN_JOURNAL_DATA_V0 {}
impl ::core::clone::Clone for USN_JOURNAL_DATA_V0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for USN_JOURNAL_DATA_V0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("USN_JOURNAL_DATA_V0").field("UsnJournalID", &self.UsnJournalID).field("FirstUsn", &self.FirstUsn).field("NextUsn", &self.NextUsn).field("LowestValidUsn", &self.LowestValidUsn).field("MaxUsn", &self.MaxUsn).field("MaximumSize", &self.MaximumSize).field("AllocationDelta", &self.AllocationDelta).finish()
    }
}
impl ::windows_core::TypeKind for USN_JOURNAL_DATA_V0 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for USN_JOURNAL_DATA_V0 {
    fn eq(&self, other: &Self) -> bool {
        self.UsnJournalID == other.UsnJournalID && self.FirstUsn == other.FirstUsn && self.NextUsn == other.NextUsn && self.LowestValidUsn == other.LowestValidUsn && self.MaxUsn == other.MaxUsn && self.MaximumSize == other.MaximumSize && self.AllocationDelta == other.AllocationDelta
    }
}
impl ::core::cmp::Eq for USN_JOURNAL_DATA_V0 {}
impl ::core::default::Default for USN_JOURNAL_DATA_V0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct USN_JOURNAL_DATA_V2 {
    pub UsnJournalID: u64,
    pub FirstUsn: i64,
    pub NextUsn: i64,
    pub LowestValidUsn: i64,
    pub MaxUsn: i64,
    pub MaximumSize: u64,
    pub AllocationDelta: u64,
    pub MinSupportedMajorVersion: u16,
    pub MaxSupportedMajorVersion: u16,
    pub Flags: u32,
    pub RangeTrackChunkSize: u64,
    pub RangeTrackFileSizeThreshold: i64,
}
impl ::core::marker::Copy for USN_JOURNAL_DATA_V2 {}
impl ::core::clone::Clone for USN_JOURNAL_DATA_V2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for USN_JOURNAL_DATA_V2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("USN_JOURNAL_DATA_V2")
            .field("UsnJournalID", &self.UsnJournalID)
            .field("FirstUsn", &self.FirstUsn)
            .field("NextUsn", &self.NextUsn)
            .field("LowestValidUsn", &self.LowestValidUsn)
            .field("MaxUsn", &self.MaxUsn)
            .field("MaximumSize", &self.MaximumSize)
            .field("AllocationDelta", &self.AllocationDelta)
            .field("MinSupportedMajorVersion", &self.MinSupportedMajorVersion)
            .field("MaxSupportedMajorVersion", &self.MaxSupportedMajorVersion)
            .field("Flags", &self.Flags)
            .field("RangeTrackChunkSize", &self.RangeTrackChunkSize)
            .field("RangeTrackFileSizeThreshold", &self.RangeTrackFileSizeThreshold)
            .finish()
    }
}
impl ::windows_core::TypeKind for USN_JOURNAL_DATA_V2 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for USN_JOURNAL_DATA_V2 {
    fn eq(&self, other: &Self) -> bool {
        self.UsnJournalID == other.UsnJournalID && self.FirstUsn == other.FirstUsn && self.NextUsn == other.NextUsn && self.LowestValidUsn == other.LowestValidUsn && self.MaxUsn == other.MaxUsn && self.MaximumSize == other.MaximumSize && self.AllocationDelta == other.AllocationDelta && self.MinSupportedMajorVersion == other.MinSupportedMajorVersion && self.MaxSupportedMajorVersion == other.MaxSupportedMajorVersion && self.Flags == other.Flags && self.RangeTrackChunkSize == other.RangeTrackChunkSize && self.RangeTrackFileSizeThreshold == other.RangeTrackFileSizeThreshold
    }
}
impl ::core::cmp::Eq for USN_JOURNAL_DATA_V2 {}
impl ::core::default::Default for USN_JOURNAL_DATA_V2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct USN_RANGE_TRACK_OUTPUT {
    pub Usn: i64,
}
impl ::core::marker::Copy for USN_RANGE_TRACK_OUTPUT {}
impl ::core::clone::Clone for USN_RANGE_TRACK_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for USN_RANGE_TRACK_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("USN_RANGE_TRACK_OUTPUT").field("Usn", &self.Usn).finish()
    }
}
impl ::windows_core::TypeKind for USN_RANGE_TRACK_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for USN_RANGE_TRACK_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Usn == other.Usn
    }
}
impl ::core::cmp::Eq for USN_RANGE_TRACK_OUTPUT {}
impl ::core::default::Default for USN_RANGE_TRACK_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct USN_RECORD {
    pub RecordLength: u32,
    pub MajorVersion: u16,
    pub MinorVersion: u16,
    pub FileReferenceNumber: u64,
    pub ParentFileReferenceNumber: u64,
    pub Usn: i64,
    pub TimeStamp: i64,
    pub Reason: u32,
    pub SourceInfo: u32,
    pub SecurityId: u32,
    pub FileAttributes: u32,
    pub FileNameLength: u16,
    pub FileNameOffset: u16,
    pub FileName: [u16; 1],
}
impl ::core::marker::Copy for USN_RECORD {}
impl ::core::clone::Clone for USN_RECORD {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for USN_RECORD {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("USN_RECORD")
            .field("RecordLength", &self.RecordLength)
            .field("MajorVersion", &self.MajorVersion)
            .field("MinorVersion", &self.MinorVersion)
            .field("FileReferenceNumber", &self.FileReferenceNumber)
            .field("ParentFileReferenceNumber", &self.ParentFileReferenceNumber)
            .field("Usn", &self.Usn)
            .field("TimeStamp", &self.TimeStamp)
            .field("Reason", &self.Reason)
            .field("SourceInfo", &self.SourceInfo)
            .field("SecurityId", &self.SecurityId)
            .field("FileAttributes", &self.FileAttributes)
            .field("FileNameLength", &self.FileNameLength)
            .field("FileNameOffset", &self.FileNameOffset)
            .field("FileName", &self.FileName)
            .finish()
    }
}
impl ::windows_core::TypeKind for USN_RECORD {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for USN_RECORD {
    fn eq(&self, other: &Self) -> bool {
        self.RecordLength == other.RecordLength && self.MajorVersion == other.MajorVersion && self.MinorVersion == other.MinorVersion && self.FileReferenceNumber == other.FileReferenceNumber && self.ParentFileReferenceNumber == other.ParentFileReferenceNumber && self.Usn == other.Usn && self.TimeStamp == other.TimeStamp && self.Reason == other.Reason && self.SourceInfo == other.SourceInfo && self.SecurityId == other.SecurityId && self.FileAttributes == other.FileAttributes && self.FileNameLength == other.FileNameLength && self.FileNameOffset == other.FileNameOffset && self.FileName == other.FileName
    }
}
impl ::core::cmp::Eq for USN_RECORD {}
impl ::core::default::Default for USN_RECORD {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct USN_RECORD_COMMON_HEADER {
    pub RecordLength: u32,
    pub MajorVersion: u16,
    pub MinorVersion: u16,
}
impl ::core::marker::Copy for USN_RECORD_COMMON_HEADER {}
impl ::core::clone::Clone for USN_RECORD_COMMON_HEADER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for USN_RECORD_COMMON_HEADER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("USN_RECORD_COMMON_HEADER").field("RecordLength", &self.RecordLength).field("MajorVersion", &self.MajorVersion).field("MinorVersion", &self.MinorVersion).finish()
    }
}
impl ::windows_core::TypeKind for USN_RECORD_COMMON_HEADER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for USN_RECORD_COMMON_HEADER {
    fn eq(&self, other: &Self) -> bool {
        self.RecordLength == other.RecordLength && self.MajorVersion == other.MajorVersion && self.MinorVersion == other.MinorVersion
    }
}
impl ::core::cmp::Eq for USN_RECORD_COMMON_HEADER {}
impl ::core::default::Default for USN_RECORD_COMMON_HEADER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct USN_RECORD_EXTENT {
    pub Offset: i64,
    pub Length: i64,
}
impl ::core::marker::Copy for USN_RECORD_EXTENT {}
impl ::core::clone::Clone for USN_RECORD_EXTENT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for USN_RECORD_EXTENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("USN_RECORD_EXTENT").field("Offset", &self.Offset).field("Length", &self.Length).finish()
    }
}
impl ::windows_core::TypeKind for USN_RECORD_EXTENT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for USN_RECORD_EXTENT {
    fn eq(&self, other: &Self) -> bool {
        self.Offset == other.Offset && self.Length == other.Length
    }
}
impl ::core::cmp::Eq for USN_RECORD_EXTENT {}
impl ::core::default::Default for USN_RECORD_EXTENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub union USN_RECORD_UNION {
    pub Header: USN_RECORD_COMMON_HEADER,
    pub V2: USN_RECORD,
    pub V3: USN_RECORD_V3,
    pub V4: USN_RECORD_V4,
}
impl ::core::marker::Copy for USN_RECORD_UNION {}
impl ::core::clone::Clone for USN_RECORD_UNION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for USN_RECORD_UNION {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::default::Default for USN_RECORD_UNION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct USN_RECORD_V3 {
    pub RecordLength: u32,
    pub MajorVersion: u16,
    pub MinorVersion: u16,
    pub FileReferenceNumber: FILE_ID_128,
    pub ParentFileReferenceNumber: FILE_ID_128,
    pub Usn: i64,
    pub TimeStamp: i64,
    pub Reason: u32,
    pub SourceInfo: u32,
    pub SecurityId: u32,
    pub FileAttributes: u32,
    pub FileNameLength: u16,
    pub FileNameOffset: u16,
    pub FileName: [u16; 1],
}
impl ::core::marker::Copy for USN_RECORD_V3 {}
impl ::core::clone::Clone for USN_RECORD_V3 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for USN_RECORD_V3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("USN_RECORD_V3")
            .field("RecordLength", &self.RecordLength)
            .field("MajorVersion", &self.MajorVersion)
            .field("MinorVersion", &self.MinorVersion)
            .field("FileReferenceNumber", &self.FileReferenceNumber)
            .field("ParentFileReferenceNumber", &self.ParentFileReferenceNumber)
            .field("Usn", &self.Usn)
            .field("TimeStamp", &self.TimeStamp)
            .field("Reason", &self.Reason)
            .field("SourceInfo", &self.SourceInfo)
            .field("SecurityId", &self.SecurityId)
            .field("FileAttributes", &self.FileAttributes)
            .field("FileNameLength", &self.FileNameLength)
            .field("FileNameOffset", &self.FileNameOffset)
            .field("FileName", &self.FileName)
            .finish()
    }
}
impl ::windows_core::TypeKind for USN_RECORD_V3 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for USN_RECORD_V3 {
    fn eq(&self, other: &Self) -> bool {
        self.RecordLength == other.RecordLength && self.MajorVersion == other.MajorVersion && self.MinorVersion == other.MinorVersion && self.FileReferenceNumber == other.FileReferenceNumber && self.ParentFileReferenceNumber == other.ParentFileReferenceNumber && self.Usn == other.Usn && self.TimeStamp == other.TimeStamp && self.Reason == other.Reason && self.SourceInfo == other.SourceInfo && self.SecurityId == other.SecurityId && self.FileAttributes == other.FileAttributes && self.FileNameLength == other.FileNameLength && self.FileNameOffset == other.FileNameOffset && self.FileName == other.FileName
    }
}
impl ::core::cmp::Eq for USN_RECORD_V3 {}
impl ::core::default::Default for USN_RECORD_V3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct USN_RECORD_V4 {
    pub Header: USN_RECORD_COMMON_HEADER,
    pub FileReferenceNumber: FILE_ID_128,
    pub ParentFileReferenceNumber: FILE_ID_128,
    pub Usn: i64,
    pub Reason: u32,
    pub SourceInfo: u32,
    pub RemainingExtents: u32,
    pub NumberOfExtents: u16,
    pub ExtentSize: u16,
    pub Extents: [USN_RECORD_EXTENT; 1],
}
impl ::core::marker::Copy for USN_RECORD_V4 {}
impl ::core::clone::Clone for USN_RECORD_V4 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for USN_RECORD_V4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("USN_RECORD_V4").field("Header", &self.Header).field("FileReferenceNumber", &self.FileReferenceNumber).field("ParentFileReferenceNumber", &self.ParentFileReferenceNumber).field("Usn", &self.Usn).field("Reason", &self.Reason).field("SourceInfo", &self.SourceInfo).field("RemainingExtents", &self.RemainingExtents).field("NumberOfExtents", &self.NumberOfExtents).field("ExtentSize", &self.ExtentSize).field("Extents", &self.Extents).finish()
    }
}
impl ::windows_core::TypeKind for USN_RECORD_V4 {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for USN_RECORD_V4 {
    fn eq(&self, other: &Self) -> bool {
        self.Header == other.Header && self.FileReferenceNumber == other.FileReferenceNumber && self.ParentFileReferenceNumber == other.ParentFileReferenceNumber && self.Usn == other.Usn && self.Reason == other.Reason && self.SourceInfo == other.SourceInfo && self.RemainingExtents == other.RemainingExtents && self.NumberOfExtents == other.NumberOfExtents && self.ExtentSize == other.ExtentSize && self.Extents == other.Extents
    }
}
impl ::core::cmp::Eq for USN_RECORD_V4 {}
impl ::core::default::Default for USN_RECORD_V4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct USN_TRACK_MODIFIED_RANGES {
    pub Flags: u32,
    pub Unused: u32,
    pub ChunkSize: u64,
    pub FileSizeThreshold: i64,
}
impl ::core::marker::Copy for USN_TRACK_MODIFIED_RANGES {}
impl ::core::clone::Clone for USN_TRACK_MODIFIED_RANGES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for USN_TRACK_MODIFIED_RANGES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("USN_TRACK_MODIFIED_RANGES").field("Flags", &self.Flags).field("Unused", &self.Unused).field("ChunkSize", &self.ChunkSize).field("FileSizeThreshold", &self.FileSizeThreshold).finish()
    }
}
impl ::windows_core::TypeKind for USN_TRACK_MODIFIED_RANGES {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for USN_TRACK_MODIFIED_RANGES {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags && self.Unused == other.Unused && self.ChunkSize == other.ChunkSize && self.FileSizeThreshold == other.FileSizeThreshold
    }
}
impl ::core::cmp::Eq for USN_TRACK_MODIFIED_RANGES {}
impl ::core::default::Default for USN_TRACK_MODIFIED_RANGES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct VCN_RANGE_INPUT_BUFFER {
    pub StartingVcn: i64,
    pub ClusterCount: i64,
}
impl ::core::marker::Copy for VCN_RANGE_INPUT_BUFFER {}
impl ::core::clone::Clone for VCN_RANGE_INPUT_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for VCN_RANGE_INPUT_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VCN_RANGE_INPUT_BUFFER").field("StartingVcn", &self.StartingVcn).field("ClusterCount", &self.ClusterCount).finish()
    }
}
impl ::windows_core::TypeKind for VCN_RANGE_INPUT_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for VCN_RANGE_INPUT_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.StartingVcn == other.StartingVcn && self.ClusterCount == other.ClusterCount
    }
}
impl ::core::cmp::Eq for VCN_RANGE_INPUT_BUFFER {}
impl ::core::default::Default for VCN_RANGE_INPUT_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct VIRTUALIZATION_INSTANCE_INFO_INPUT {
    pub NumberOfWorkerThreads: u32,
    pub Flags: u32,
}
impl ::core::marker::Copy for VIRTUALIZATION_INSTANCE_INFO_INPUT {}
impl ::core::clone::Clone for VIRTUALIZATION_INSTANCE_INFO_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for VIRTUALIZATION_INSTANCE_INFO_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VIRTUALIZATION_INSTANCE_INFO_INPUT").field("NumberOfWorkerThreads", &self.NumberOfWorkerThreads).field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for VIRTUALIZATION_INSTANCE_INFO_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for VIRTUALIZATION_INSTANCE_INFO_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.NumberOfWorkerThreads == other.NumberOfWorkerThreads && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for VIRTUALIZATION_INSTANCE_INFO_INPUT {}
impl ::core::default::Default for VIRTUALIZATION_INSTANCE_INFO_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct VIRTUALIZATION_INSTANCE_INFO_INPUT_EX {
    pub HeaderSize: u16,
    pub Flags: u32,
    pub NotificationInfoSize: u32,
    pub NotificationInfoOffset: u16,
    pub ProviderMajorVersion: u16,
}
impl ::core::marker::Copy for VIRTUALIZATION_INSTANCE_INFO_INPUT_EX {}
impl ::core::clone::Clone for VIRTUALIZATION_INSTANCE_INFO_INPUT_EX {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for VIRTUALIZATION_INSTANCE_INFO_INPUT_EX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VIRTUALIZATION_INSTANCE_INFO_INPUT_EX").field("HeaderSize", &self.HeaderSize).field("Flags", &self.Flags).field("NotificationInfoSize", &self.NotificationInfoSize).field("NotificationInfoOffset", &self.NotificationInfoOffset).field("ProviderMajorVersion", &self.ProviderMajorVersion).finish()
    }
}
impl ::windows_core::TypeKind for VIRTUALIZATION_INSTANCE_INFO_INPUT_EX {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for VIRTUALIZATION_INSTANCE_INFO_INPUT_EX {
    fn eq(&self, other: &Self) -> bool {
        self.HeaderSize == other.HeaderSize && self.Flags == other.Flags && self.NotificationInfoSize == other.NotificationInfoSize && self.NotificationInfoOffset == other.NotificationInfoOffset && self.ProviderMajorVersion == other.ProviderMajorVersion
    }
}
impl ::core::cmp::Eq for VIRTUALIZATION_INSTANCE_INFO_INPUT_EX {}
impl ::core::default::Default for VIRTUALIZATION_INSTANCE_INFO_INPUT_EX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct VIRTUALIZATION_INSTANCE_INFO_OUTPUT {
    pub VirtualizationInstanceID: ::windows_core::GUID,
}
impl ::core::marker::Copy for VIRTUALIZATION_INSTANCE_INFO_OUTPUT {}
impl ::core::clone::Clone for VIRTUALIZATION_INSTANCE_INFO_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for VIRTUALIZATION_INSTANCE_INFO_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VIRTUALIZATION_INSTANCE_INFO_OUTPUT").field("VirtualizationInstanceID", &self.VirtualizationInstanceID).finish()
    }
}
impl ::windows_core::TypeKind for VIRTUALIZATION_INSTANCE_INFO_OUTPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for VIRTUALIZATION_INSTANCE_INFO_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.VirtualizationInstanceID == other.VirtualizationInstanceID
    }
}
impl ::core::cmp::Eq for VIRTUALIZATION_INSTANCE_INFO_OUTPUT {}
impl ::core::default::Default for VIRTUALIZATION_INSTANCE_INFO_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT {
    pub Size: u32,
    pub BehaviorCode: VIRTUAL_STORAGE_BEHAVIOR_CODE,
}
impl ::core::marker::Copy for VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT {}
impl ::core::clone::Clone for VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT").field("Size", &self.Size).field("BehaviorCode", &self.BehaviorCode).finish()
    }
}
impl ::windows_core::TypeKind for VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Size == other.Size && self.BehaviorCode == other.BehaviorCode
    }
}
impl ::core::cmp::Eq for VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT {}
impl ::core::default::Default for VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct VIRTUAL_STORAGE_TYPE {
    pub DeviceId: u32,
    pub VendorId: ::windows_core::GUID,
}
impl ::core::marker::Copy for VIRTUAL_STORAGE_TYPE {}
impl ::core::clone::Clone for VIRTUAL_STORAGE_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for VIRTUAL_STORAGE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VIRTUAL_STORAGE_TYPE").field("DeviceId", &self.DeviceId).field("VendorId", &self.VendorId).finish()
    }
}
impl ::windows_core::TypeKind for VIRTUAL_STORAGE_TYPE {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for VIRTUAL_STORAGE_TYPE {
    fn eq(&self, other: &Self) -> bool {
        self.DeviceId == other.DeviceId && self.VendorId == other.VendorId
    }
}
impl ::core::cmp::Eq for VIRTUAL_STORAGE_TYPE {}
impl ::core::default::Default for VIRTUAL_STORAGE_TYPE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct VOLUME_BITMAP_BUFFER {
    pub StartingLcn: i64,
    pub BitmapSize: i64,
    pub Buffer: [u8; 1],
}
impl ::core::marker::Copy for VOLUME_BITMAP_BUFFER {}
impl ::core::clone::Clone for VOLUME_BITMAP_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for VOLUME_BITMAP_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VOLUME_BITMAP_BUFFER").field("StartingLcn", &self.StartingLcn).field("BitmapSize", &self.BitmapSize).field("Buffer", &self.Buffer).finish()
    }
}
impl ::windows_core::TypeKind for VOLUME_BITMAP_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for VOLUME_BITMAP_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.StartingLcn == other.StartingLcn && self.BitmapSize == other.BitmapSize && self.Buffer == other.Buffer
    }
}
impl ::core::cmp::Eq for VOLUME_BITMAP_BUFFER {}
impl ::core::default::Default for VOLUME_BITMAP_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct VOLUME_REFS_INFO_BUFFER {
    pub CacheSizeInBytes: i64,
    pub AllocatedCacheInBytes: i64,
    pub PopulatedCacheInBytes: i64,
    pub InErrorCacheInBytes: i64,
    pub MemoryUsedForCacheMetadata: i64,
    pub CacheLineSize: u32,
    pub CacheTransactionsOutstanding: i32,
    pub CacheLinesFree: i32,
    pub CacheLinesInError: i32,
    pub CacheHitsInBytes: i64,
    pub CacheMissesInBytes: i64,
    pub CachePopulationUpdatesInBytes: i64,
    pub CacheWriteThroughUpdatesInBytes: i64,
    pub CacheInvalidationsInBytes: i64,
    pub CacheOverReadsInBytes: i64,
    pub MetadataWrittenBytes: i64,
    pub CacheHitCounter: i32,
    pub CacheMissCounter: i32,
    pub CacheLineAllocationCounter: i32,
    pub CacheInvalidationsCounter: i32,
    pub CachePopulationUpdatesCounter: i32,
    pub CacheWriteThroughUpdatesCounter: i32,
    pub MaxCacheTransactionsOutstanding: i32,
    pub DataWritesReallocationCount: i32,
    pub DataInPlaceWriteCount: i32,
    pub MetadataAllocationsFastTierCount: i32,
    pub MetadataAllocationsSlowTierCount: i32,
    pub DataAllocationsFastTierCount: i32,
    pub DataAllocationsSlowTierCount: i32,
    pub DestagesSlowTierToFastTier: i32,
    pub DestagesFastTierToSlowTier: i32,
    pub SlowTierDataFillRatio: i32,
    pub FastTierDataFillRatio: i32,
    pub SlowTierMetadataFillRatio: i32,
    pub FastTierMetadataFillRatio: i32,
    pub SlowToFastDestageReadLatency: i32,
    pub SlowToFastDestageReadLatencyBase: i32,
    pub SlowToFastDestageWriteLatency: i32,
    pub SlowToFastDestageWriteLatencyBase: i32,
    pub FastToSlowDestageReadLatency: i32,
    pub FastToSlowDestageReadLatencyBase: i32,
    pub FastToSlowDestageWriteLatency: i32,
    pub FastToSlowDestageWriteLatencyBase: i32,
    pub SlowTierContainerFillRatio: i32,
    pub SlowTierContainerFillRatioBase: i32,
    pub FastTierContainerFillRatio: i32,
    pub FastTierContainerFillRatioBase: i32,
    pub TreeUpdateLatency: i32,
    pub TreeUpdateLatencyBase: i32,
    pub CheckpointLatency: i32,
    pub CheckpointLatencyBase: i32,
    pub TreeUpdateCount: i32,
    pub CheckpointCount: i32,
    pub LogWriteCount: i32,
    pub LogFillRatio: i32,
    pub ReadCacheInvalidationsForOverwrite: i32,
    pub ReadCacheInvalidationsForReuse: i32,
    pub ReadCacheInvalidationsGeneral: i32,
    pub ReadCacheChecksOnMount: i32,
    pub ReadCacheIssuesOnMount: i32,
    pub TrimLatency: i32,
    pub TrimLatencyBase: i32,
    pub DataCompactionCount: i32,
    pub CompactionReadLatency: i32,
    pub CompactionReadLatencyBase: i32,
    pub CompactionWriteLatency: i32,
    pub CompactionWriteLatencyBase: i32,
    pub DataInPlaceWriteClusterCount: i64,
    pub CompactionFailedDueToIneligibleContainer: i32,
    pub CompactionFailedDueToMaxFragmentation: i32,
    pub CompactedContainerFillRatio: i32,
    pub CompactedContainerFillRatioBase: i32,
    pub ContainerMoveRetryCount: i32,
    pub ContainerMoveFailedDueToIneligibleContainer: i32,
    pub CompactionFailureCount: i32,
    pub ContainerMoveFailureCount: i32,
    pub NumberOfDirtyMetadataPages: i64,
    pub NumberOfDirtyTableListEntries: i32,
    pub NumberOfDeleteQueueEntries: i32,
}
impl ::core::marker::Copy for VOLUME_REFS_INFO_BUFFER {}
impl ::core::clone::Clone for VOLUME_REFS_INFO_BUFFER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for VOLUME_REFS_INFO_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("VOLUME_REFS_INFO_BUFFER")
            .field("CacheSizeInBytes", &self.CacheSizeInBytes)
            .field("AllocatedCacheInBytes", &self.AllocatedCacheInBytes)
            .field("PopulatedCacheInBytes", &self.PopulatedCacheInBytes)
            .field("InErrorCacheInBytes", &self.InErrorCacheInBytes)
            .field("MemoryUsedForCacheMetadata", &self.MemoryUsedForCacheMetadata)
            .field("CacheLineSize", &self.CacheLineSize)
            .field("CacheTransactionsOutstanding", &self.CacheTransactionsOutstanding)
            .field("CacheLinesFree", &self.CacheLinesFree)
            .field("CacheLinesInError", &self.CacheLinesInError)
            .field("CacheHitsInBytes", &self.CacheHitsInBytes)
            .field("CacheMissesInBytes", &self.CacheMissesInBytes)
            .field("CachePopulationUpdatesInBytes", &self.CachePopulationUpdatesInBytes)
            .field("CacheWriteThroughUpdatesInBytes", &self.CacheWriteThroughUpdatesInBytes)
            .field("CacheInvalidationsInBytes", &self.CacheInvalidationsInBytes)
            .field("CacheOverReadsInBytes", &self.CacheOverReadsInBytes)
            .field("MetadataWrittenBytes", &self.MetadataWrittenBytes)
            .field("CacheHitCounter", &self.CacheHitCounter)
            .field("CacheMissCounter", &self.CacheMissCounter)
            .field("CacheLineAllocationCounter", &self.CacheLineAllocationCounter)
            .field("CacheInvalidationsCounter", &self.CacheInvalidationsCounter)
            .field("CachePopulationUpdatesCounter", &self.CachePopulationUpdatesCounter)
            .field("CacheWriteThroughUpdatesCounter", &self.CacheWriteThroughUpdatesCounter)
            .field("MaxCacheTransactionsOutstanding", &self.MaxCacheTransactionsOutstanding)
            .field("DataWritesReallocationCount", &self.DataWritesReallocationCount)
            .field("DataInPlaceWriteCount", &self.DataInPlaceWriteCount)
            .field("MetadataAllocationsFastTierCount", &self.MetadataAllocationsFastTierCount)
            .field("MetadataAllocationsSlowTierCount", &self.MetadataAllocationsSlowTierCount)
            .field("DataAllocationsFastTierCount", &self.DataAllocationsFastTierCount)
            .field("DataAllocationsSlowTierCount", &self.DataAllocationsSlowTierCount)
            .field("DestagesSlowTierToFastTier", &self.DestagesSlowTierToFastTier)
            .field("DestagesFastTierToSlowTier", &self.DestagesFastTierToSlowTier)
            .field("SlowTierDataFillRatio", &self.SlowTierDataFillRatio)
            .field("FastTierDataFillRatio", &self.FastTierDataFillRatio)
            .field("SlowTierMetadataFillRatio", &self.SlowTierMetadataFillRatio)
            .field("FastTierMetadataFillRatio", &self.FastTierMetadataFillRatio)
            .field("SlowToFastDestageReadLatency", &self.SlowToFastDestageReadLatency)
            .field("SlowToFastDestageReadLatencyBase", &self.SlowToFastDestageReadLatencyBase)
            .field("SlowToFastDestageWriteLatency", &self.SlowToFastDestageWriteLatency)
            .field("SlowToFastDestageWriteLatencyBase", &self.SlowToFastDestageWriteLatencyBase)
            .field("FastToSlowDestageReadLatency", &self.FastToSlowDestageReadLatency)
            .field("FastToSlowDestageReadLatencyBase", &self.FastToSlowDestageReadLatencyBase)
            .field("FastToSlowDestageWriteLatency", &self.FastToSlowDestageWriteLatency)
            .field("FastToSlowDestageWriteLatencyBase", &self.FastToSlowDestageWriteLatencyBase)
            .field("SlowTierContainerFillRatio", &self.SlowTierContainerFillRatio)
            .field("SlowTierContainerFillRatioBase", &self.SlowTierContainerFillRatioBase)
            .field("FastTierContainerFillRatio", &self.FastTierContainerFillRatio)
            .field("FastTierContainerFillRatioBase", &self.FastTierContainerFillRatioBase)
            .field("TreeUpdateLatency", &self.TreeUpdateLatency)
            .field("TreeUpdateLatencyBase", &self.TreeUpdateLatencyBase)
            .field("CheckpointLatency", &self.CheckpointLatency)
            .field("CheckpointLatencyBase", &self.CheckpointLatencyBase)
            .field("TreeUpdateCount", &self.TreeUpdateCount)
            .field("CheckpointCount", &self.CheckpointCount)
            .field("LogWriteCount", &self.LogWriteCount)
            .field("LogFillRatio", &self.LogFillRatio)
            .field("ReadCacheInvalidationsForOverwrite", &self.ReadCacheInvalidationsForOverwrite)
            .field("ReadCacheInvalidationsForReuse", &self.ReadCacheInvalidationsForReuse)
            .field("ReadCacheInvalidationsGeneral", &self.ReadCacheInvalidationsGeneral)
            .field("ReadCacheChecksOnMount", &self.ReadCacheChecksOnMount)
            .field("ReadCacheIssuesOnMount", &self.ReadCacheIssuesOnMount)
            .field("TrimLatency", &self.TrimLatency)
            .field("TrimLatencyBase", &self.TrimLatencyBase)
            .field("DataCompactionCount", &self.DataCompactionCount)
            .field("CompactionReadLatency", &self.CompactionReadLatency)
            .field("CompactionReadLatencyBase", &self.CompactionReadLatencyBase)
            .field("CompactionWriteLatency", &self.CompactionWriteLatency)
            .field("CompactionWriteLatencyBase", &self.CompactionWriteLatencyBase)
            .field("DataInPlaceWriteClusterCount", &self.DataInPlaceWriteClusterCount)
            .field("CompactionFailedDueToIneligibleContainer", &self.CompactionFailedDueToIneligibleContainer)
            .field("CompactionFailedDueToMaxFragmentation", &self.CompactionFailedDueToMaxFragmentation)
            .field("CompactedContainerFillRatio", &self.CompactedContainerFillRatio)
            .field("CompactedContainerFillRatioBase", &self.CompactedContainerFillRatioBase)
            .field("ContainerMoveRetryCount", &self.ContainerMoveRetryCount)
            .field("ContainerMoveFailedDueToIneligibleContainer", &self.ContainerMoveFailedDueToIneligibleContainer)
            .field("CompactionFailureCount", &self.CompactionFailureCount)
            .field("ContainerMoveFailureCount", &self.ContainerMoveFailureCount)
            .field("NumberOfDirtyMetadataPages", &self.NumberOfDirtyMetadataPages)
            .field("NumberOfDirtyTableListEntries", &self.NumberOfDirtyTableListEntries)
            .field("NumberOfDeleteQueueEntries", &self.NumberOfDeleteQueueEntries)
            .finish()
    }
}
impl ::windows_core::TypeKind for VOLUME_REFS_INFO_BUFFER {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for VOLUME_REFS_INFO_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.CacheSizeInBytes == other.CacheSizeInBytes
            && self.AllocatedCacheInBytes == other.AllocatedCacheInBytes
            && self.PopulatedCacheInBytes == other.PopulatedCacheInBytes
            && self.InErrorCacheInBytes == other.InErrorCacheInBytes
            && self.MemoryUsedForCacheMetadata == other.MemoryUsedForCacheMetadata
            && self.CacheLineSize == other.CacheLineSize
            && self.CacheTransactionsOutstanding == other.CacheTransactionsOutstanding
            && self.CacheLinesFree == other.CacheLinesFree
            && self.CacheLinesInError == other.CacheLinesInError
            && self.CacheHitsInBytes == other.CacheHitsInBytes
            && self.CacheMissesInBytes == other.CacheMissesInBytes
            && self.CachePopulationUpdatesInBytes == other.CachePopulationUpdatesInBytes
            && self.CacheWriteThroughUpdatesInBytes == other.CacheWriteThroughUpdatesInBytes
            && self.CacheInvalidationsInBytes == other.CacheInvalidationsInBytes
            && self.CacheOverReadsInBytes == other.CacheOverReadsInBytes
            && self.MetadataWrittenBytes == other.MetadataWrittenBytes
            && self.CacheHitCounter == other.CacheHitCounter
            && self.CacheMissCounter == other.CacheMissCounter
            && self.CacheLineAllocationCounter == other.CacheLineAllocationCounter
            && self.CacheInvalidationsCounter == other.CacheInvalidationsCounter
            && self.CachePopulationUpdatesCounter == other.CachePopulationUpdatesCounter
            && self.CacheWriteThroughUpdatesCounter == other.CacheWriteThroughUpdatesCounter
            && self.MaxCacheTransactionsOutstanding == other.MaxCacheTransactionsOutstanding
            && self.DataWritesReallocationCount == other.DataWritesReallocationCount
            && self.DataInPlaceWriteCount == other.DataInPlaceWriteCount
            && self.MetadataAllocationsFastTierCount == other.MetadataAllocationsFastTierCount
            && self.MetadataAllocationsSlowTierCount == other.MetadataAllocationsSlowTierCount
            && self.DataAllocationsFastTierCount == other.DataAllocationsFastTierCount
            && self.DataAllocationsSlowTierCount == other.DataAllocationsSlowTierCount
            && self.DestagesSlowTierToFastTier == other.DestagesSlowTierToFastTier
            && self.DestagesFastTierToSlowTier == other.DestagesFastTierToSlowTier
            && self.SlowTierDataFillRatio == other.SlowTierDataFillRatio
            && self.FastTierDataFillRatio == other.FastTierDataFillRatio
            && self.SlowTierMetadataFillRatio == other.SlowTierMetadataFillRatio
            && self.FastTierMetadataFillRatio == other.FastTierMetadataFillRatio
            && self.SlowToFastDestageReadLatency == other.SlowToFastDestageReadLatency
            && self.SlowToFastDestageReadLatencyBase == other.SlowToFastDestageReadLatencyBase
            && self.SlowToFastDestageWriteLatency == other.SlowToFastDestageWriteLatency
            && self.SlowToFastDestageWriteLatencyBase == other.SlowToFastDestageWriteLatencyBase
            && self.FastToSlowDestageReadLatency == other.FastToSlowDestageReadLatency
            && self.FastToSlowDestageReadLatencyBase == other.FastToSlowDestageReadLatencyBase
            && self.FastToSlowDestageWriteLatency == other.FastToSlowDestageWriteLatency
            && self.FastToSlowDestageWriteLatencyBase == other.FastToSlowDestageWriteLatencyBase
            && self.SlowTierContainerFillRatio == other.SlowTierContainerFillRatio
            && self.SlowTierContainerFillRatioBase == other.SlowTierContainerFillRatioBase
            && self.FastTierContainerFillRatio == other.FastTierContainerFillRatio
            && self.FastTierContainerFillRatioBase == other.FastTierContainerFillRatioBase
            && self.TreeUpdateLatency == other.TreeUpdateLatency
            && self.TreeUpdateLatencyBase == other.TreeUpdateLatencyBase
            && self.CheckpointLatency == other.CheckpointLatency
            && self.CheckpointLatencyBase == other.CheckpointLatencyBase
            && self.TreeUpdateCount == other.TreeUpdateCount
            && self.CheckpointCount == other.CheckpointCount
            && self.LogWriteCount == other.LogWriteCount
            && self.LogFillRatio == other.LogFillRatio
            && self.ReadCacheInvalidationsForOverwrite == other.ReadCacheInvalidationsForOverwrite
            && self.ReadCacheInvalidationsForReuse == other.ReadCacheInvalidationsForReuse
            && self.ReadCacheInvalidationsGeneral == other.ReadCacheInvalidationsGeneral
            && self.ReadCacheChecksOnMount == other.ReadCacheChecksOnMount
            && self.ReadCacheIssuesOnMount == other.ReadCacheIssuesOnMount
            && self.TrimLatency == other.TrimLatency
            && self.TrimLatencyBase == other.TrimLatencyBase
            && self.DataCompactionCount == other.DataCompactionCount
            && self.CompactionReadLatency == other.CompactionReadLatency
            && self.CompactionReadLatencyBase == other.CompactionReadLatencyBase
            && self.CompactionWriteLatency == other.CompactionWriteLatency
            && self.CompactionWriteLatencyBase == other.CompactionWriteLatencyBase
            && self.DataInPlaceWriteClusterCount == other.DataInPlaceWriteClusterCount
            && self.CompactionFailedDueToIneligibleContainer == other.CompactionFailedDueToIneligibleContainer
            && self.CompactionFailedDueToMaxFragmentation == other.CompactionFailedDueToMaxFragmentation
            && self.CompactedContainerFillRatio == other.CompactedContainerFillRatio
            && self.CompactedContainerFillRatioBase == other.CompactedContainerFillRatioBase
            && self.ContainerMoveRetryCount == other.ContainerMoveRetryCount
            && self.ContainerMoveFailedDueToIneligibleContainer == other.ContainerMoveFailedDueToIneligibleContainer
            && self.CompactionFailureCount == other.CompactionFailureCount
            && self.ContainerMoveFailureCount == other.ContainerMoveFailureCount
            && self.NumberOfDirtyMetadataPages == other.NumberOfDirtyMetadataPages
            && self.NumberOfDirtyTableListEntries == other.NumberOfDirtyTableListEntries
            && self.NumberOfDeleteQueueEntries == other.NumberOfDeleteQueueEntries
    }
}
impl ::core::cmp::Eq for VOLUME_REFS_INFO_BUFFER {}
impl ::core::default::Default for VOLUME_REFS_INFO_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct WIM_PROVIDER_ADD_OVERLAY_INPUT {
    pub WimType: u32,
    pub WimIndex: u32,
    pub WimFileNameOffset: u32,
    pub WimFileNameLength: u32,
}
impl ::core::marker::Copy for WIM_PROVIDER_ADD_OVERLAY_INPUT {}
impl ::core::clone::Clone for WIM_PROVIDER_ADD_OVERLAY_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for WIM_PROVIDER_ADD_OVERLAY_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("WIM_PROVIDER_ADD_OVERLAY_INPUT").field("WimType", &self.WimType).field("WimIndex", &self.WimIndex).field("WimFileNameOffset", &self.WimFileNameOffset).field("WimFileNameLength", &self.WimFileNameLength).finish()
    }
}
impl ::windows_core::TypeKind for WIM_PROVIDER_ADD_OVERLAY_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for WIM_PROVIDER_ADD_OVERLAY_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.WimType == other.WimType && self.WimIndex == other.WimIndex && self.WimFileNameOffset == other.WimFileNameOffset && self.WimFileNameLength == other.WimFileNameLength
    }
}
impl ::core::cmp::Eq for WIM_PROVIDER_ADD_OVERLAY_INPUT {}
impl ::core::default::Default for WIM_PROVIDER_ADD_OVERLAY_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct WIM_PROVIDER_EXTERNAL_INFO {
    pub Version: u32,
    pub Flags: u32,
    pub DataSourceId: i64,
    pub ResourceHash: [u8; 20],
}
impl ::core::marker::Copy for WIM_PROVIDER_EXTERNAL_INFO {}
impl ::core::clone::Clone for WIM_PROVIDER_EXTERNAL_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for WIM_PROVIDER_EXTERNAL_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("WIM_PROVIDER_EXTERNAL_INFO").field("Version", &self.Version).field("Flags", &self.Flags).field("DataSourceId", &self.DataSourceId).field("ResourceHash", &self.ResourceHash).finish()
    }
}
impl ::windows_core::TypeKind for WIM_PROVIDER_EXTERNAL_INFO {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for WIM_PROVIDER_EXTERNAL_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Flags == other.Flags && self.DataSourceId == other.DataSourceId && self.ResourceHash == other.ResourceHash
    }
}
impl ::core::cmp::Eq for WIM_PROVIDER_EXTERNAL_INFO {}
impl ::core::default::Default for WIM_PROVIDER_EXTERNAL_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct WIM_PROVIDER_OVERLAY_ENTRY {
    pub NextEntryOffset: u32,
    pub DataSourceId: i64,
    pub WimGuid: ::windows_core::GUID,
    pub WimFileNameOffset: u32,
    pub WimType: u32,
    pub WimIndex: u32,
    pub Flags: u32,
}
impl ::core::marker::Copy for WIM_PROVIDER_OVERLAY_ENTRY {}
impl ::core::clone::Clone for WIM_PROVIDER_OVERLAY_ENTRY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for WIM_PROVIDER_OVERLAY_ENTRY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("WIM_PROVIDER_OVERLAY_ENTRY").field("NextEntryOffset", &self.NextEntryOffset).field("DataSourceId", &self.DataSourceId).field("WimGuid", &self.WimGuid).field("WimFileNameOffset", &self.WimFileNameOffset).field("WimType", &self.WimType).field("WimIndex", &self.WimIndex).field("Flags", &self.Flags).finish()
    }
}
impl ::windows_core::TypeKind for WIM_PROVIDER_OVERLAY_ENTRY {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for WIM_PROVIDER_OVERLAY_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.NextEntryOffset == other.NextEntryOffset && self.DataSourceId == other.DataSourceId && self.WimGuid == other.WimGuid && self.WimFileNameOffset == other.WimFileNameOffset && self.WimType == other.WimType && self.WimIndex == other.WimIndex && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for WIM_PROVIDER_OVERLAY_ENTRY {}
impl ::core::default::Default for WIM_PROVIDER_OVERLAY_ENTRY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct WIM_PROVIDER_REMOVE_OVERLAY_INPUT {
    pub DataSourceId: i64,
}
impl ::core::marker::Copy for WIM_PROVIDER_REMOVE_OVERLAY_INPUT {}
impl ::core::clone::Clone for WIM_PROVIDER_REMOVE_OVERLAY_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for WIM_PROVIDER_REMOVE_OVERLAY_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("WIM_PROVIDER_REMOVE_OVERLAY_INPUT").field("DataSourceId", &self.DataSourceId).finish()
    }
}
impl ::windows_core::TypeKind for WIM_PROVIDER_REMOVE_OVERLAY_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for WIM_PROVIDER_REMOVE_OVERLAY_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.DataSourceId == other.DataSourceId
    }
}
impl ::core::cmp::Eq for WIM_PROVIDER_REMOVE_OVERLAY_INPUT {}
impl ::core::default::Default for WIM_PROVIDER_REMOVE_OVERLAY_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct WIM_PROVIDER_SUSPEND_OVERLAY_INPUT {
    pub DataSourceId: i64,
}
impl ::core::marker::Copy for WIM_PROVIDER_SUSPEND_OVERLAY_INPUT {}
impl ::core::clone::Clone for WIM_PROVIDER_SUSPEND_OVERLAY_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for WIM_PROVIDER_SUSPEND_OVERLAY_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("WIM_PROVIDER_SUSPEND_OVERLAY_INPUT").field("DataSourceId", &self.DataSourceId).finish()
    }
}
impl ::windows_core::TypeKind for WIM_PROVIDER_SUSPEND_OVERLAY_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for WIM_PROVIDER_SUSPEND_OVERLAY_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.DataSourceId == other.DataSourceId
    }
}
impl ::core::cmp::Eq for WIM_PROVIDER_SUSPEND_OVERLAY_INPUT {}
impl ::core::default::Default for WIM_PROVIDER_SUSPEND_OVERLAY_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct WIM_PROVIDER_UPDATE_OVERLAY_INPUT {
    pub DataSourceId: i64,
    pub WimFileNameOffset: u32,
    pub WimFileNameLength: u32,
}
impl ::core::marker::Copy for WIM_PROVIDER_UPDATE_OVERLAY_INPUT {}
impl ::core::clone::Clone for WIM_PROVIDER_UPDATE_OVERLAY_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for WIM_PROVIDER_UPDATE_OVERLAY_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("WIM_PROVIDER_UPDATE_OVERLAY_INPUT").field("DataSourceId", &self.DataSourceId).field("WimFileNameOffset", &self.WimFileNameOffset).field("WimFileNameLength", &self.WimFileNameLength).finish()
    }
}
impl ::windows_core::TypeKind for WIM_PROVIDER_UPDATE_OVERLAY_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for WIM_PROVIDER_UPDATE_OVERLAY_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.DataSourceId == other.DataSourceId && self.WimFileNameOffset == other.WimFileNameOffset && self.WimFileNameLength == other.WimFileNameLength
    }
}
impl ::core::cmp::Eq for WIM_PROVIDER_UPDATE_OVERLAY_INPUT {}
impl ::core::default::Default for WIM_PROVIDER_UPDATE_OVERLAY_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct WOF_EXTERNAL_FILE_ID {
    pub FileId: FILE_ID_128,
}
impl ::core::marker::Copy for WOF_EXTERNAL_FILE_ID {}
impl ::core::clone::Clone for WOF_EXTERNAL_FILE_ID {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for WOF_EXTERNAL_FILE_ID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("WOF_EXTERNAL_FILE_ID").field("FileId", &self.FileId).finish()
    }
}
impl ::windows_core::TypeKind for WOF_EXTERNAL_FILE_ID {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for WOF_EXTERNAL_FILE_ID {
    fn eq(&self, other: &Self) -> bool {
        self.FileId == other.FileId
    }
}
impl ::core::cmp::Eq for WOF_EXTERNAL_FILE_ID {}
impl ::core::default::Default for WOF_EXTERNAL_FILE_ID {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct WOF_EXTERNAL_INFO {
    pub Version: u32,
    pub Provider: u32,
}
impl ::core::marker::Copy for WOF_EXTERNAL_INFO {}
impl ::core::clone::Clone for WOF_EXTERNAL_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for WOF_EXTERNAL_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("WOF_EXTERNAL_INFO").field("Version", &self.Version).field("Provider", &self.Provider).finish()
    }
}
impl ::windows_core::TypeKind for WOF_EXTERNAL_INFO {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for WOF_EXTERNAL_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version && self.Provider == other.Provider
    }
}
impl ::core::cmp::Eq for WOF_EXTERNAL_INFO {}
impl ::core::default::Default for WOF_EXTERNAL_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct WOF_VERSION_INFO {
    pub WofVersion: u32,
}
impl ::core::marker::Copy for WOF_VERSION_INFO {}
impl ::core::clone::Clone for WOF_VERSION_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for WOF_VERSION_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("WOF_VERSION_INFO").field("WofVersion", &self.WofVersion).finish()
    }
}
impl ::windows_core::TypeKind for WOF_VERSION_INFO {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for WOF_VERSION_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.WofVersion == other.WofVersion
    }
}
impl ::core::cmp::Eq for WOF_VERSION_INFO {}
impl ::core::default::Default for WOF_VERSION_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub struct WRITE_USN_REASON_INPUT {
    pub Flags: u32,
    pub UsnReasonToWrite: u32,
}
impl ::core::marker::Copy for WRITE_USN_REASON_INPUT {}
impl ::core::clone::Clone for WRITE_USN_REASON_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for WRITE_USN_REASON_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("WRITE_USN_REASON_INPUT").field("Flags", &self.Flags).field("UsnReasonToWrite", &self.UsnReasonToWrite).finish()
    }
}
impl ::windows_core::TypeKind for WRITE_USN_REASON_INPUT {
    type TypeKind = ::windows_core::CopyType;
}
impl ::core::cmp::PartialEq for WRITE_USN_REASON_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags && self.UsnReasonToWrite == other.UsnReasonToWrite
    }
}
impl ::core::cmp::Eq for WRITE_USN_REASON_INPUT {}
impl ::core::default::Default for WRITE_USN_REASON_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct _REAL_NOTIFY_SYNC(pub u8);
impl ::core::marker::Copy for _REAL_NOTIFY_SYNC {}
impl ::core::clone::Clone for _REAL_NOTIFY_SYNC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows_core::TypeKind for _REAL_NOTIFY_SYNC {
    type TypeKind = ::windows_core::CopyType;
}
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type ACCEPT_SECURITY_CONTEXT_FN = ::core::option::Option<unsafe extern "system" fn(param0: *mut SecHandle, param1: *mut SecHandle, param2: *mut SecBufferDesc, param3: u32, param4: u32, param5: *mut SecHandle, param6: *mut SecBufferDesc, param7: *mut u32, param8: *mut i64) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type ACQUIRE_CREDENTIALS_HANDLE_FN_W = ::core::option::Option<unsafe extern "system" fn(param0: *mut super::super::super::Win32::Foundation::UNICODE_STRING, param1: *mut super::super::super::Win32::Foundation::UNICODE_STRING, param2: u32, param3: *mut ::core::ffi::c_void, param4: *mut ::core::ffi::c_void, param5: SEC_GET_KEY_FN, param6: *mut ::core::ffi::c_void, param7: *mut SecHandle, param8: *mut i64) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type ADD_CREDENTIALS_FN_A = ::core::option::Option<unsafe extern "system" fn(param0: *mut SecHandle, param1: *mut i8, param2: *mut i8, param3: u32, param4: *mut ::core::ffi::c_void, param5: SEC_GET_KEY_FN, param6: *mut ::core::ffi::c_void, param7: *mut i64) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type ADD_CREDENTIALS_FN_W = ::core::option::Option<unsafe extern "system" fn(param0: *mut SecHandle, param1: *mut super::super::super::Win32::Foundation::UNICODE_STRING, param2: *mut super::super::super::Win32::Foundation::UNICODE_STRING, param3: u32, param4: *mut ::core::ffi::c_void, param5: SEC_GET_KEY_FN, param6: *mut ::core::ffi::c_void, param7: *mut i64) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`, `\"Win32_System_Memory\"`*"]
#[cfg(all(feature = "Win32_Foundation", feature = "Win32_System_Memory"))]
pub type ALLOCATE_VIRTUAL_MEMORY_EX_CALLBACK = ::core::option::Option<unsafe extern "system" fn(callbackcontext: super::super::super::Win32::Foundation::HANDLE, processhandle: super::super::super::Win32::Foundation::HANDLE, baseaddress: *mut *mut ::core::ffi::c_void, regionsize: *mut usize, allocationtype: u32, pageprotection: u32, extendedparameters: *mut super::super::super::Win32::System::Memory::MEM_EXTENDED_PARAMETER, extendedparametercount: u32) -> super::super::super::Win32::Foundation::NTSTATUS>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type APPLY_CONTROL_TOKEN_FN = ::core::option::Option<unsafe extern "system" fn(param0: *mut SecHandle, param1: *mut SecBufferDesc) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type COMPLETE_AUTH_TOKEN_FN = ::core::option::Option<unsafe extern "system" fn(param0: *mut SecHandle, param1: *mut SecBufferDesc) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type DECRYPT_MESSAGE_FN = ::core::option::Option<unsafe extern "system" fn(param0: *mut SecHandle, param1: *mut SecBufferDesc, param2: u32, param3: *mut u32) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type DELETE_SECURITY_CONTEXT_FN = ::core::option::Option<unsafe extern "system" fn(param0: *mut SecHandle) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub type DRIVER_FS_NOTIFICATION = ::core::option::Option<unsafe extern "system" fn(deviceobject: *const super::super::Foundation::DEVICE_OBJECT, fsactive: super::super::super::Win32::Foundation::BOOLEAN) -> ()>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type ENCRYPT_MESSAGE_FN = ::core::option::Option<unsafe extern "system" fn(param0: *mut SecHandle, param1: u32, param2: *mut SecBufferDesc, param3: u32) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type ENUMERATE_SECURITY_PACKAGES_FN_W = ::core::option::Option<unsafe extern "system" fn(param0: *mut u32, param1: *mut *mut SecPkgInfoW) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type EXPORT_SECURITY_CONTEXT_FN = ::core::option::Option<unsafe extern "system" fn(param0: *mut SecHandle, param1: u32, param2: *mut SecBuffer, param3: *mut *mut ::core::ffi::c_void) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type FREE_CONTEXT_BUFFER_FN = ::core::option::Option<unsafe extern "system" fn(param0: *mut ::core::ffi::c_void) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type FREE_CREDENTIALS_HANDLE_FN = ::core::option::Option<unsafe extern "system" fn(param0: *mut SecHandle) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type FREE_VIRTUAL_MEMORY_EX_CALLBACK = ::core::option::Option<unsafe extern "system" fn(callbackcontext: super::super::super::Win32::Foundation::HANDLE, processhandle: super::super::super::Win32::Foundation::HANDLE, baseaddress: *mut *mut ::core::ffi::c_void, regionsize: *mut usize, freetype: u32) -> super::super::super::Win32::Foundation::NTSTATUS>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type IMPERSONATE_SECURITY_CONTEXT_FN = ::core::option::Option<unsafe extern "system" fn(param0: *mut SecHandle) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type IMPORT_SECURITY_CONTEXT_FN_W = ::core::option::Option<unsafe extern "system" fn(param0: *mut super::super::super::Win32::Foundation::UNICODE_STRING, param1: *mut SecBuffer, param2: *mut ::core::ffi::c_void, param3: *mut SecHandle) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type INITIALIZE_SECURITY_CONTEXT_FN_W = ::core::option::Option<unsafe extern "system" fn(param0: *mut SecHandle, param1: *mut SecHandle, param2: *mut super::super::super::Win32::Foundation::UNICODE_STRING, param3: u32, param4: u32, param5: u32, param6: *mut SecBufferDesc, param7: u32, param8: *mut SecHandle, param9: *mut SecBufferDesc, param10: *mut u32, param11: *mut i64) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type INIT_SECURITY_INTERFACE_W = ::core::option::Option<unsafe extern "system" fn() -> *mut SecurityFunctionTableW>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type MAKE_SIGNATURE_FN = ::core::option::Option<unsafe extern "system" fn(param0: *mut SecHandle, param1: u32, param2: *mut SecBufferDesc, param3: u32) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type PACQUIRE_FOR_LAZY_WRITE = ::core::option::Option<unsafe extern "system" fn(context: *const ::core::ffi::c_void, wait: super::super::super::Win32::Foundation::BOOLEAN) -> super::super::super::Win32::Foundation::BOOLEAN>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type PACQUIRE_FOR_LAZY_WRITE_EX = ::core::option::Option<unsafe extern "system" fn(context: *const ::core::ffi::c_void, inflags: u32, outflags: *mut u32) -> super::super::super::Win32::Foundation::BOOLEAN>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type PACQUIRE_FOR_READ_AHEAD = ::core::option::Option<unsafe extern "system" fn(context: *const ::core::ffi::c_void, wait: super::super::super::Win32::Foundation::BOOLEAN) -> super::super::super::Win32::Foundation::BOOLEAN>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type PALLOCATE_VIRTUAL_MEMORY_EX_CALLBACK = ::core::option::Option<unsafe extern "system" fn() -> super::super::super::Win32::Foundation::NTSTATUS>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type PASYNC_READ_COMPLETION_CALLBACK = ::core::option::Option<unsafe extern "system" fn(context: *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation::BOOLEAN>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type PCC_POST_DEFERRED_WRITE = ::core::option::Option<unsafe extern "system" fn(context1: *const ::core::ffi::c_void, context2: *const ::core::ffi::c_void) -> ()>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_Security\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_Security"))]
pub type PCHECK_FOR_TRAVERSE_ACCESS = ::core::option::Option<unsafe extern "system" fn(notifycontext: *const ::core::ffi::c_void, targetcontext: *const ::core::ffi::c_void, subjectcontext: *const super::super::Foundation::SECURITY_SUBJECT_CONTEXT) -> super::super::super::Win32::Foundation::BOOLEAN>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub type PCOMPLETE_LOCK_IRP_ROUTINE = ::core::option::Option<unsafe extern "system" fn(context: *const ::core::ffi::c_void, irp: *const super::super::Foundation::IRP) -> super::super::super::Win32::Foundation::NTSTATUS>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub type PDIRTY_PAGE_ROUTINE = ::core::option::Option<unsafe extern "system" fn(fileobject: *const super::super::Foundation::FILE_OBJECT, fileoffset: *const i64, length: u32, oldestlsn: *const i64, newestlsn: *const i64, context1: *const ::core::ffi::c_void, context2: *const ::core::ffi::c_void) -> ()>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type PDRIVER_FS_NOTIFICATION = ::core::option::Option<unsafe extern "system" fn() -> ()>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type PFILTER_REPORT_CHANGE = ::core::option::Option<unsafe extern "system" fn(notifycontext: *const ::core::ffi::c_void, filtercontext: *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation::BOOLEAN>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type PFLUSH_TO_LSN = ::core::option::Option<unsafe extern "system" fn(loghandle: *const ::core::ffi::c_void, lsn: i64) -> ()>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
pub type PFN_FSRTLTEARDOWNPERSTREAMCONTEXTS = ::core::option::Option<unsafe extern "system" fn(advancedheader: *const FSRTL_ADVANCED_FCB_HEADER) -> ()>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type PFREE_VIRTUAL_MEMORY_EX_CALLBACK = ::core::option::Option<unsafe extern "system" fn() -> super::super::super::Win32::Foundation::NTSTATUS>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK = ::core::option::Option<unsafe extern "system" fn(ecpcontext: *mut ::core::ffi::c_void, ecptype: *const ::windows_core::GUID) -> ()>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`, `\"Win32_System_Kernel\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation", feature = "Win32_System_Kernel"))]
pub type PFSRTL_STACK_OVERFLOW_ROUTINE = ::core::option::Option<unsafe extern "system" fn(context: *const ::core::ffi::c_void, event: *const super::super::Foundation::KEVENT) -> ()>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub type PFS_FILTER_CALLBACK = ::core::option::Option<unsafe extern "system" fn(data: *const FS_FILTER_CALLBACK_DATA, completioncontext: *mut *mut ::core::ffi::c_void) -> super::super::super::Win32::Foundation::NTSTATUS>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub type PFS_FILTER_COMPLETION_CALLBACK = ::core::option::Option<unsafe extern "system" fn(data: *const FS_FILTER_CALLBACK_DATA, operationstatus: super::super::super::Win32::Foundation::NTSTATUS, completioncontext: *const ::core::ffi::c_void) -> ()>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK = ::core::option::Option<unsafe extern "system" fn(sourcecontext: *const IO_IRP_EXT_TRACK_OFFSET_HEADER, targetcontext: *mut IO_IRP_EXT_TRACK_OFFSET_HEADER, relativeoffset: i64) -> ()>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub type POPLOCK_FS_PREPOST_IRP = ::core::option::Option<unsafe extern "system" fn(context: *const ::core::ffi::c_void, irp: *const super::super::Foundation::IRP) -> ()>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub type POPLOCK_NOTIFY_ROUTINE = ::core::option::Option<unsafe extern "system" fn(notifyparams: *const OPLOCK_NOTIFY_PARAMS) -> super::super::super::Win32::Foundation::NTSTATUS>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub type POPLOCK_WAIT_COMPLETE_ROUTINE = ::core::option::Option<unsafe extern "system" fn(context: *const ::core::ffi::c_void, irp: *const super::super::Foundation::IRP) -> ()>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type PQUERY_LOG_USAGE = ::core::option::Option<unsafe extern "system" fn(loghandle: *const ::core::ffi::c_void, percentagefull: *mut u16) -> ()>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type PQUERY_VIRTUAL_MEMORY_CALLBACK = ::core::option::Option<unsafe extern "system" fn() -> super::super::super::Win32::Foundation::NTSTATUS>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type PRELEASE_FROM_LAZY_WRITE = ::core::option::Option<unsafe extern "system" fn(context: *const ::core::ffi::c_void) -> ()>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type PRELEASE_FROM_READ_AHEAD = ::core::option::Option<unsafe extern "system" fn(context: *const ::core::ffi::c_void) -> ()>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type PRTL_ALLOCATE_STRING_ROUTINE = ::core::option::Option<unsafe extern "system" fn() -> *mut ::core::ffi::c_void>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type PRTL_FREE_STRING_ROUTINE = ::core::option::Option<unsafe extern "system" fn() -> ()>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type PRTL_HEAP_COMMIT_ROUTINE = ::core::option::Option<unsafe extern "system" fn() -> super::super::super::Win32::Foundation::NTSTATUS>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type PRTL_REALLOCATE_STRING_ROUTINE = ::core::option::Option<unsafe extern "system" fn() -> *mut ::core::ffi::c_void>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type PSE_LOGON_SESSION_TERMINATED_ROUTINE = ::core::option::Option<unsafe extern "system" fn() -> super::super::super::Win32::Foundation::NTSTATUS>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type PSE_LOGON_SESSION_TERMINATED_ROUTINE_EX = ::core::option::Option<unsafe extern "system" fn() -> super::super::super::Win32::Foundation::NTSTATUS>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Wdk_System_SystemServices\"`, `\"Win32_Foundation\"`, `\"Win32_Graphics_DirectDraw\"`, `\"Win32_Security\"`, `\"Win32_System_Kernel\"`, `\"Win32_System_Power\"`, `\"Win32_System_WindowsProgramming\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Wdk_System_SystemServices", feature = "Win32_Foundation", feature = "Win32_Graphics_DirectDraw", feature = "Win32_Security", feature = "Win32_System_Kernel", feature = "Win32_System_Power", feature = "Win32_System_WindowsProgramming"))]
pub type PUNLOCK_ROUTINE = ::core::option::Option<unsafe extern "system" fn(context: *const ::core::ffi::c_void, filelockinfo: *const FILE_LOCK_INFO) -> ()>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type QUERY_CONTEXT_ATTRIBUTES_EX_FN_W = ::core::option::Option<unsafe extern "system" fn(param0: *mut SecHandle, param1: u32, param2: *mut ::core::ffi::c_void, param3: u32) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type QUERY_CONTEXT_ATTRIBUTES_FN_W = ::core::option::Option<unsafe extern "system" fn(param0: *mut SecHandle, param1: u32, param2: *mut ::core::ffi::c_void) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type QUERY_CREDENTIALS_ATTRIBUTES_EX_FN_W = ::core::option::Option<unsafe extern "system" fn(param0: *mut SecHandle, param1: u32, param2: *mut ::core::ffi::c_void, param3: u32) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type QUERY_CREDENTIALS_ATTRIBUTES_FN_W = ::core::option::Option<unsafe extern "system" fn(param0: *mut SecHandle, param1: u32, param2: *mut ::core::ffi::c_void) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type QUERY_SECURITY_CONTEXT_TOKEN_FN = ::core::option::Option<unsafe extern "system" fn(param0: *mut SecHandle, param1: *mut *mut ::core::ffi::c_void) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type QUERY_SECURITY_PACKAGE_INFO_FN_W = ::core::option::Option<unsafe extern "system" fn(param0: *mut super::super::super::Win32::Foundation::UNICODE_STRING, param1: *mut *mut SecPkgInfoW) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type QUERY_VIRTUAL_MEMORY_CALLBACK = ::core::option::Option<unsafe extern "system" fn(callbackcontext: super::super::super::Win32::Foundation::HANDLE, processhandle: super::super::super::Win32::Foundation::HANDLE, baseaddress: *const ::core::ffi::c_void, memoryinformationclass: HEAP_MEMORY_INFO_CLASS, memoryinformation: *mut ::core::ffi::c_void, memoryinformationlength: usize, returnlength: *mut usize) -> super::super::super::Win32::Foundation::NTSTATUS>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type REVERT_SECURITY_CONTEXT_FN = ::core::option::Option<unsafe extern "system" fn(param0: *mut SecHandle) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type RTL_ALLOCATE_STRING_ROUTINE = ::core::option::Option<unsafe extern "system" fn(numberofbytes: usize) -> *mut ::core::ffi::c_void>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type RTL_FREE_STRING_ROUTINE = ::core::option::Option<unsafe extern "system" fn(buffer: *const ::core::ffi::c_void) -> ()>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type RTL_HEAP_COMMIT_ROUTINE = ::core::option::Option<unsafe extern "system" fn(base: *const ::core::ffi::c_void, commitaddress: *mut *mut ::core::ffi::c_void, commitsize: *mut usize) -> super::super::super::Win32::Foundation::NTSTATUS>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type RTL_REALLOCATE_STRING_ROUTINE = ::core::option::Option<unsafe extern "system" fn(numberofbytes: usize, buffer: *const ::core::ffi::c_void) -> *mut ::core::ffi::c_void>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type SEC_GET_KEY_FN = ::core::option::Option<unsafe extern "system" fn(arg: *mut ::core::ffi::c_void, principal: *mut ::core::ffi::c_void, keyver: u32, key: *mut *mut ::core::ffi::c_void, status: *mut ::windows_core::HRESULT) -> ()>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type SET_CONTEXT_ATTRIBUTES_FN_W = ::core::option::Option<unsafe extern "system" fn(param0: *mut SecHandle, param1: u32, param2: *mut ::core::ffi::c_void, param3: u32) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type SET_CREDENTIALS_ATTRIBUTES_FN_W = ::core::option::Option<unsafe extern "system" fn(param0: *mut SecHandle, param1: u32, param2: *mut ::core::ffi::c_void, param3: u32) -> ::windows_core::HRESULT>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Win32_Foundation\"`*"]
#[cfg(feature = "Win32_Foundation")]
pub type SE_LOGON_SESSION_TERMINATED_ROUTINE = ::core::option::Option<unsafe extern "system" fn(logonid: *const super::super::super::Win32::Foundation::LUID) -> super::super::super::Win32::Foundation::NTSTATUS>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`, `\"Wdk_Foundation\"`, `\"Win32_Foundation\"`*"]
#[cfg(all(feature = "Wdk_Foundation", feature = "Win32_Foundation"))]
pub type SE_LOGON_SESSION_TERMINATED_ROUTINE_EX = ::core::option::Option<unsafe extern "system" fn(logonid: *const super::super::super::Win32::Foundation::LUID, pserversilo: *const super::super::Foundation::EJOB, context: *const ::core::ffi::c_void) -> super::super::super::Win32::Foundation::NTSTATUS>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type SspiAsyncNotifyCallback = ::core::option::Option<unsafe extern "system" fn(handle: *const SspiAsyncContext, callbackdata: *const ::core::ffi::c_void) -> ()>;
#[doc = "*Required features: `\"Wdk_Storage_FileSystem\"`*"]
pub type VERIFY_SIGNATURE_FN = ::core::option::Option<unsafe extern "system" fn(param0: *mut SecHandle, param1: *mut SecBufferDesc, param2: u32, param3: *mut u32) -> ::windows_core::HRESULT>;
#[cfg(feature = "implement")]
::core::include!("impl.rs");
